#!/usr/bin/env superdoit_solo
# Standard options are always present unless customoptions section is used
#
#RwSimpleProjectSpecification {
#	#specName : 'Plantis',
#	#version : '0.2.0',
#	#platformSpec : {
#		'gemstone' : RwGemStoneSpecification {
#			#packageNameToPlatformPropertiesMap : { }
#		}
#	},
# 	#configsPath : 'rowan/configs',
# 	#specsPath : 'rowan/specs',
#	  #repoSpec : RwGitRepositorySpecification {
# 	 	#committish : 'master',
# 		#committishType : 'branch'
#	 },
#	 #repoPath : 'rowan/src',
#	 #comment : '',
#	 #defaultConfigurationNames : [
#	 	'Default'
#	 ],
#	 #defaultGroupNames : [
#	 	'default'
#	 ]
# }
#
usage
-----
USAGE $basename [--help | -h] [--debug | -D]

DESCRIPTION
  <put your description here>

OPTIONS
  -h, --help                 display usage message
  -D, --debug                bring up topaz debugger in the event of a script error

EXAMPLES
  $basename --help
  $basename -D
  $basename  
-----
%
instvars
platformAttributes
packageMapSpecs
%
specs
[
RwLoadSpecificationV2 {
	#projectName : 'RowanV12Metadata',
	#projectSpecFile : 'rowan/project.ston',
	#componentNames : [
		'Core'
	],
	#platformProperties : {
		'gemstone' : {
			'allusers' : {
				#defaultSymbolDictName : 'UserGlobals'
			}
		}
	},
	#comment : ''
}]
%
method
loadV12Metadata
	self preDoitSpecLoad: [:spec |
		spec projectsHome: '/home/dhenrich/_homes/rogue/_home/shared/repos/Rowan/upgrade/projectsHome'
	].
%
method
readProjectSpecification: plantisRoot
	(plantisRoot / 'rowan/specs/Plantis.ston')
		readStreamDo: [:stream |
			| bufferedStream |
			bufferedStream := ZnBufferedReadStream on:  stream.
			^ STON fromStream: bufferedStream ].
%
method
_matchPlatformAttributes: platformPatternMatcher

	platformAttributes do: [:anObject |
		(platformPatternMatcher match: anObject) ifTrue: [ ^true ] ].
	^false
%
method
_platformAttributeMatchIn: platformMatchersList

	platformMatchersList do: [:platformPatternMatcher |
		(self _matchPlatformAttributes: platformPatternMatcher) 
			ifTrue: [ ^true ] ].
	^false
%
method
visitConditionalPackageMapSpecs: aProjectLoadConfiguration
	| currentUserId |
	currentUserId := Rowan image currentUserId.
	aProjectLoadConfiguration conditionalPackageMapSpecMatchers keysAndValuesDo: [:platformMatcher :thePackageMapSpecsMap | 
		(self _platformAttributeMatchIn: {platformMatcher})
			ifTrue: [
				(thePackageMapSpecsMap 
					at: currentUserId 
					ifAbsent: [ 
						"<allusers> is preferred, but for the alpha, there are outstanding configs that use <default>"
						thePackageMapSpecsMap at: 'default'  
							ifAbsent: [ thePackageMapSpecsMap at: 'allusers'  ifAbsent: [] ] ])
								ifNotNil: [:thePackageMapSpecs |
									(thePackageMapSpecs at: #defaultSymbolDictName otherwise: nil) 
										ifNotNil: [:name | packageMapSpecs at: #defaultSymbolDictName put: name ].
									(thePackageMapSpecs at: #defaultUseSessionMethodsForExtensions otherwise: nil) 
										ifNotNil: [:boolean | packageMapSpecs at: #defaultUseSessionMethodsForExtensions put: boolean  ].
									(thePackageMapSpecs at: #packageNameToPlatformPropertiesMap otherwise: nil) 
										ifNotNil: [:theMap | 
											| map |
											map := packageMapSpecs at: #packageNameToPlatformPropertiesMap ifAbsentPut: [ Dictionary new ].
											theMap keysAndValuesDo: [:thePackageName :thePropMap | 
												thePropMap keysAndValuesDo: [:thePropertyName :thePropertyValue |
													| packageMap |
													packageMap  := map at: thePackageName ifAbsentPut: [ Dictionary new ].
													(#('symbolDictName' 'userId' 'useSessionMethodsForExtensions' ) includes: thePropertyName)
														ifTrue: [ packageMap at: thePropertyName put: thePropertyValue  ] 
														ifFalse: [ self error: 'Unrecognized property name ', thePropertyName printString, ' in package name to properties map' ] ] ] ] ] ] ]
%
doit
	| plantisHome plantisRoot projectSpec configurationNames groupNames configDirectory projectLoadConfigs res |
	self loadV12Metadata.
	plantisHome := '/home/dhenrich/_homes/rogue/_home/shared/repos' asFileReference.
	plantisRoot := plantisHome / 'Plantis'.
	projectSpec := self readProjectSpecification: plantisRoot.

	configurationNames := projectSpec loadedConfigurationNames.
	(configurationNames isNil or: [ configurationNames isEmpty ])
		ifTrue: [ configurationNames := projectSpec defaultConfigurationNames ].
	configurationNames ifNil: [ self halt: 'read all package names' ].
	groupNames := projectSpec defaultGroupNames.
	configDirectory := plantisRoot pathString , '/' , projectSpec configsPath , '/'.
	platformAttributes := Rowan platformConditionalAttributes.
	projectLoadConfigs := configurationNames collect: [:configName | 
		(Rowan globalNamed: 'RwAbstractProjectConfiguration') 
			_readStonFrom: (configDirectory asFileReference / configName , 'ston') readStream ].
	packageMapSpecs := Dictionary new.	
	projectLoadConfigs collect: [:projectLoadConfig |
		self visitConditionalPackageMapSpecs: projectLoadConfig ].
	res := { 
			configurationNames . 
			groupNames . 
			configDirectory . 
			platformAttributes collect: [:each | each asString ] . 
			projectLoadConfigs .
		}.
res halt.
	^ self noResult
%
