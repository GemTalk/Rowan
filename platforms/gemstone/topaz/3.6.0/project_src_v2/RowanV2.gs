! Class Declarations
! Generated file, do not Edit

doit
(ByteArray
	subclass: 'UUID'
	instVarNames: #(  )
	classVars: #( GeneratorClass )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Network-UUID';
		immediateInvariant.
true.
%

removeallmethods UUID
removeallclassmethods UUID

doit
(Error
	subclass: 'CypressError'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressError
removeallclassmethods CypressError

doit
(Error
	subclass: 'CypressJsonError'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressJsonError
removeallclassmethods CypressJsonError

doit
(Error
	subclass: 'CypressLoaderError'
	instVarNames: #( exception patchOperation )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

CypressLoaderError is used to report a failure applying a specific CypressPatchOperation.
The CypressLoader made a first attempt to apply the Patch Operation and reported a 
CypressLoaderErrorNotification, set aside the Patch Operation, and has retried it after applying
all other Patch Operations.


Instance Variables:

patchOperation:		the CypressPatchOperation that could not be applied.
exception:			the Error which occurred while trying to apply the Patch Operation.
';
		immediateInvariant.
true.
%

removeallmethods CypressLoaderError
removeallclassmethods CypressLoaderError

doit
(Error
	subclass: 'CypressLoaderMissingClasses'
	instVarNames: #( requirementsMap )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressLoaderMissingClasses
removeallclassmethods CypressLoaderMissingClasses

doit
(Error
	subclass: 'FileException'
	instVarNames: #( fileName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Files';
		comment: 'Common superclass for exceptions while using file streams';
		immediateInvariant.
true.
%

removeallmethods FileException
removeallclassmethods FileException

doit
(FileException
	subclass: 'CannotDeleteFileException'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Files';
		comment: 'Notfify when not able to delete';
		immediateInvariant.
true.
%

removeallmethods CannotDeleteFileException
removeallclassmethods CannotDeleteFileException

doit
(FileException
	subclass: 'FileAlreadyExistsException'
	instVarNames: #( file )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Files';
		comment: 'I am an exception that notifies that a file already exists.';
		immediateInvariant.
true.
%

removeallmethods FileAlreadyExistsException
removeallclassmethods FileAlreadyExistsException

doit
(FileException
	subclass: 'FileDoesNotExistException'
	instVarNames: #( readOnly )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Files';
		comment: 'I am raised when an operation is attempted on a file that does not exist.

The method used to signal the exception depends on the form the file name exists in:

- For strings: (FileDoesNotExistException file fileName: aString) signal 
- For Files: FileDoesNotExistException signalOnFile: aFile
- For FileReferences: FileDoesNotExistException signalWith: aFileReference


Applications that want to offer the user the opportunity to select a different file can use:

	UIManager default fileDoesNotExistsDefaultAction: exception
';
		immediateInvariant.
true.
%

removeallmethods FileDoesNotExistException
removeallclassmethods FileDoesNotExistException

doit
(FileException
	subclass: 'FileWriteError'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Files';
		comment: 'Notify about an error when trying to attempt to write to a file';
		immediateInvariant.
true.
%

removeallmethods FileWriteError
removeallclassmethods FileWriteError

doit
(Error
	subclass: 'FileSystemError'
	instVarNames: #( reference )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an abstract superclass for errors that may occur during filesystem operations.';
		immediateInvariant.
true.
%

removeallmethods FileSystemError
removeallclassmethods FileSystemError

doit
(FileSystemError
	subclass: 'DirectoryDoesNotExist'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am raised when I an operation is attempted inside a directory that does not exist. ';
		immediateInvariant.
true.
%

removeallmethods DirectoryDoesNotExist
removeallclassmethods DirectoryDoesNotExist

doit
(FileSystemError
	subclass: 'DirectoryExists'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am raised on an attempt to create a directory that already exists.';
		immediateInvariant.
true.
%

removeallmethods DirectoryExists
removeallclassmethods DirectoryExists

doit
(FileSystemError
	subclass: 'DirectoryIsNotEmpty'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am raised on an attempt to delete a directory when is not empty.';
		immediateInvariant.
true.
%

removeallmethods DirectoryIsNotEmpty
removeallclassmethods DirectoryIsNotEmpty

doit
(FileSystemError
	subclass: 'FileExists'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am raised on an attempt to create a file or directory over top of an existing file.';
		immediateInvariant.
true.
%

removeallmethods FileExists
removeallclassmethods FileExists

doit
(FileSystemError
	subclass: 'IllegalName'
	instVarNames: #( name )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am raised on an attempt to use an illegal file name
';
		immediateInvariant.
true.
%

removeallmethods IllegalName
removeallclassmethods IllegalName

doit
(Error
	subclass: 'ZnCharacterEncodingError'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am ZnCharacterEncodingError.
I am an Error.

I signal when something goes wrong while encoding or decoding characters.

Part of Zinc HTTP Components';
		immediateInvariant.
true.
%

removeallmethods ZnCharacterEncodingError
removeallclassmethods ZnCharacterEncodingError

doit
(Magnitude
	indexableSubclass: 'RwGemStoneVersionNumber'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Core-Conditional-Support';
		comment: '# GemStone version format

GemStone versions are simply an unbounded collection of $. separated positive integers.';
		immediateInvariant.
true.
%

removeallmethods RwGemStoneVersionNumber
removeallclassmethods RwGemStoneVersionNumber

doit
(Magnitude
	subclass: 'RwSemanticVersionNumber'
	instVarNames: #( normalVersion preReleaseVersion buildVersion )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Core-Conditional-Support';
		comment: 'RwSemanticVersionNumber conforms to version 2.0.0 of  [Semantic Versioning 2.0.0](http://semver.org/)

**Semantic Versioning Specification** extracted from [Semantic versioning 2.0.0](https://raw.githubusercontent.com/semver/semver/347f73f880ebe1de61891832bf8702e864ca0998/semver.md):

Semantic Versioning 2.0.0
==============================

Summary
-------

Given a version number MAJOR.MINOR.PATCH, increment the:

1. MAJOR version when you make incompatible API changes,
1. MINOR version when you add functionality in a backwards-compatible
   manner, and
1. PATCH version when you make backwards-compatible bug fixes.

Additional labels for pre-release and build metadata are available as extensions
to the MAJOR.MINOR.PATCH format.

Introduction
------------

In the world of software management there exists a dreaded place called
"dependency hell." The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.

As a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
These rules are based on but not necessarily limited to pre-existing
widespread common practices in use in both closed and open-source software.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.

I call this system "Semantic Versioning." Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.


Semantic Versioning Specification (SemVer)
------------------------------------------

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [RFC 2119](http://tools.ietf.org/html/rfc2119).

1. Software using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.

1. A normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.

1. Once a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.

1. Major version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.

1. Version 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.

1. Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.

1. Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.

1. Major version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.

1. A pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphen
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.

1. Build metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.

1. Precedence refers to how versions are compared to each other when ordered.
Precedence MUST be calculated by separating the version into major, minor, patch
and pre-release identifiers in that order (Build metadata does not figure
into precedence). Precedence is determined by the first difference when
comparing each of these identifiers from left to right as follows: Major, minor,
and patch versions are always compared numerically. Example: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. When major, minor, and patch are equal, a pre-release version has
lower precedence than a normal version. Example: 1.0.0-alpha < 1.0.0. Precedence
for two pre-release versions with the same major, minor, and patch version MUST
be determined by comparing each dot separated identifier from left to right
until a difference is found as follows: identifiers consisting of only digits
are compared numerically and identifiers with letters or hyphens are compared
lexically in ASCII sort order. Numeric identifiers always have lower precedence
than non-numeric identifiers. A larger set of pre-release fields has a higher
precedence than a smaller set, if all of the preceding identifiers are equal.
Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.

BackusNaur Form Grammar for Valid SemVer Versions
--------------------------------------------------

    <valid semver> ::= <version core>
                     | <version core> "-" <pre-release>
                     | <version core> "+" <build>
                     | <version core> "-" <pre-release> "+" <build>

    <version core> ::= <major> "." <minor> "." <patch>

    <major> ::= <numeric identifier>

    <minor> ::= <numeric identifier>

    <patch> ::= <numeric identifier>

    <pre-release> ::= <dot-separated pre-release identifiers>

    <dot-separated pre-release identifiers> ::= <pre-release identifier>
                                              | <pre-release identifier> "." <dot-separated pre-release identifiers>

    <build> ::= <dot-separated build identifiers>

    <dot-separated build identifiers> ::= <build identifier>
                                        | <build identifier> "." <dot-separated build identifiers>

    <pre-release identifier> ::= <alphanumeric identifier>
                               | <numeric identifier>

    <build identifier> ::= <alphanumeric identifier>
                         | <digits>

    <alphanumeric identifier> ::= <non-digit>
                                | <non-digit> <identifier characters>
                                | <identifier characters> <non-digit>
                                | <identifier characters> <non-digit> <identifier characters>

    <numeric identifier> ::= "0"
                           | <positive digit>
                           | <positive digit> <digits>

    <identifier characters> ::= <identifier character>
                              | <identifier character> <identifier characters>

    <identifier character> ::= <digit>
                             | <non-digit>

    <non-digit> ::= <letter>
                  | "-"

    <digits> ::= <digit>
               | <digit> <digits>

    <digit> ::= "0"
              | <positive digit>

    <positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

    <letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
               | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
               | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
               | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
               | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
               | "y" | "z"


Why Use Semantic Versioning?
----------------------------

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that "close" isn''t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called "Firetruck." It requires a
Semantically Versioned package named "Ladder." At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there''s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.


FAQ
---

### How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

### How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you''re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.

### Doesn''t this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you''re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.

### If even the tiniest backwards incompatible changes to the public API require a major version bump, won''t I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you''ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

### Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that''s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

### What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you''ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it''s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

### What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it''s obviously a minor level increment.

### What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

### How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.

### Does SemVer have a size limit on the version string?

No, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.

### Is "v1.2.3" a semantic version?

No, "v1.2.3" is not a semantic version. However, prefixing a semantic version
with a "v" is a common way (in English) to indicate it is a version number.
Abbreviating "version" as "v" is often seen with version control. Example:
`git tag v1.2.3 -m "Release version 1.2.3"`, in which case "v1.2.3" is a tag
name and the semantic version is "1.2.3".


About
-----

The Semantic Versioning specification is authored by [Tom
Preston-Werner](http://tom.preston-werner.com), inventor of Gravatar and
cofounder of GitHub.

If you''d like to leave feedback, please [open an issue on
GitHub](https://github.com/mojombo/semver/issues).


License
-------

Creative Commons - CC BY 3.0
http://creativecommons.org/licenses/by/3.0/';
		immediateInvariant.
true.
%

removeallmethods RwSemanticVersionNumber
removeallclassmethods RwSemanticVersionNumber

doit
(Notification
	subclass: 'CypressLoaderErrorNotification'
	instVarNames: #( exception patchOperation )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

CypressLoaderErrorNotification is used to notify a consumer of the CypressLoader that a particular CypressPatchOperation failed.
As a Notification, it resumes by default, logging the error to the Transcript.


Instance Variables:

patchOperation:		the CypressPatchOperation that could not be applied.
exception:			the Error which occurred while trying to apply the Patch Operation.
';
		immediateInvariant.
true.
%

removeallmethods CypressLoaderErrorNotification
removeallclassmethods CypressLoaderErrorNotification

doit
(Notification
	subclass: 'GsInteractionRequest'
	instVarNames: #( interaction )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsInteractionRequest
removeallclassmethods GsInteractionRequest

doit
(Notification
	subclass: 'ResolutionRequest'
	instVarNames: #( origin )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I represent a request for user assistance in resolving an origin. I am a resumable exception that gets raised when there is no way of automatically resolving a particular origin. ';
		immediateInvariant.
true.
%

removeallmethods ResolutionRequest
removeallclassmethods ResolutionRequest

doit
(Notification
	subclass: 'RwNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'General way for Cypress to toss things up the stack for consideration by a higher authority.';
		immediateInvariant.
true.
%

removeallmethods RwNotification
removeallclassmethods RwNotification

doit
(RwNotification
	subclass: 'RwAddUpdateRemoveMethodForUnpackagedClassNotification'
	instVarNames: #( errorMessage )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwAddUpdateRemoveMethodForUnpackagedClassNotification
removeallclassmethods RwAddUpdateRemoveMethodForUnpackagedClassNotification

doit
(RwNotification
	subclass: 'RwAdoptAuditErrorNotification'
	instVarNames: #( className isClassExtension packageName description reason )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwAdoptAuditErrorNotification
removeallclassmethods RwAdoptAuditErrorNotification

doit
(RwAdoptAuditErrorNotification
	subclass: 'RwAdoptAuditClassErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwAdoptAuditClassErrorNotification
removeallclassmethods RwAdoptAuditClassErrorNotification

doit
(RwAdoptAuditClassErrorNotification
	subclass: 'RwAdoptMissingClassErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwAdoptMissingClassErrorNotification
removeallclassmethods RwAdoptMissingClassErrorNotification

doit
(RwAdoptAuditClassErrorNotification
	subclass: 'RwAuditClassErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwAuditClassErrorNotification
removeallclassmethods RwAuditClassErrorNotification

doit
(RwAdoptAuditErrorNotification
	subclass: 'RwAdoptAuditMethodErrorNotification'
	instVarNames: #( selector isMetaclass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwAdoptAuditMethodErrorNotification
removeallclassmethods RwAdoptAuditMethodErrorNotification

doit
(RwAdoptAuditMethodErrorNotification
	subclass: 'RwAdoptMissingMethodErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwAdoptMissingMethodErrorNotification
removeallclassmethods RwAdoptMissingMethodErrorNotification

doit
(RwAdoptAuditMethodErrorNotification
	subclass: 'RwAuditMethodErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwAuditMethodErrorNotification
removeallclassmethods RwAuditMethodErrorNotification

doit
(RwNotification
	subclass: 'RwAllowChangeRepositoryRevisionOnResolveNotification'
	instVarNames: #( loadSpecification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwAllowChangeRepositoryRevisionOnResolveNotification
removeallclassmethods RwAllowChangeRepositoryRevisionOnResolveNotification

doit
(RwNotification
	subclass: 'RwDeleteClassFromSystemNotification'
	instVarNames: #( candidateClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwDeleteClassFromSystemNotification
removeallclassmethods RwDeleteClassFromSystemNotification

doit
(RwNotification
	subclass: 'RwExecuteClassInitializeMethodsAfterLoadNotification'
	instVarNames: #( candidateClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExecuteClassInitializeMethodsAfterLoadNotification
removeallclassmethods RwExecuteClassInitializeMethodsAfterLoadNotification

doit
(RwNotification
	subclass: 'RwExistingAssociationWithSameKeyNotification'
	instVarNames: #( errorMessage )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExistingAssociationWithSameKeyNotification
removeallclassmethods RwExistingAssociationWithSameKeyNotification

doit
(RwNotification
	subclass: 'RwExistingVisitorAddingExistingClassNotification'
	instVarNames: #( class classDefinition loadedProject )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExistingVisitorAddingExistingClassNotification
removeallclassmethods RwExistingVisitorAddingExistingClassNotification

doit
(RwNotification
	subclass: 'RwInvalidCategoryProtocolConventionErrorNotification'
	instVarNames: #( packageName packageConvention )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwInvalidCategoryProtocolConventionErrorNotification
removeallclassmethods RwInvalidCategoryProtocolConventionErrorNotification

doit
(RwInvalidCategoryProtocolConventionErrorNotification
	subclass: 'RwInvalidClassCategoryConventionErrorNotification'
	instVarNames: #( classDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwInvalidClassCategoryConventionErrorNotification
removeallclassmethods RwInvalidClassCategoryConventionErrorNotification

doit
(RwInvalidCategoryProtocolConventionErrorNotification
	subclass: 'RwInvalidMethodProtocolConventionErrorNotification'
	instVarNames: #( methodDefinition className isMeta )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwInvalidMethodProtocolConventionErrorNotification
removeallclassmethods RwInvalidMethodProtocolConventionErrorNotification

doit
(RwInvalidMethodProtocolConventionErrorNotification
	subclass: 'RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification
removeallclassmethods RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification

doit
(RwInvalidMethodProtocolConventionErrorNotification
	subclass: 'RwExtensionProtocolNonExtensionMethodErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExtensionProtocolNonExtensionMethodErrorNotification
removeallclassmethods RwExtensionProtocolNonExtensionMethodErrorNotification

doit
(RwInvalidMethodProtocolConventionErrorNotification
	subclass: 'RwNonExtensionProtocolExtensionMethodErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwNonExtensionProtocolExtensionMethodErrorNotification
removeallclassmethods RwNonExtensionProtocolExtensionMethodErrorNotification

doit
(RwNotification
	subclass: 'RwPerformingUnpackagedEditNotification'
	instVarNames: #( informMessage )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwPerformingUnpackagedEditNotification
removeallclassmethods RwPerformingUnpackagedEditNotification

doit
(Object
	subclass: 'AbstractFileReference'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an abstract superclass for FileLocator and FileReference. By implementing most of the methods on myself most code duplucation between the locator and the reference can be avoided';
		immediateInvariant.
true.
%

removeallmethods AbstractFileReference
removeallclassmethods AbstractFileReference

doit
(AbstractFileReference
	subclass: 'FileLocator'
	instVarNames: #( origin path )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am a late-bound reference. I refer to a file or directory in relation to a well-known location on the filesystem, called an origin. When asked to perform concrete operation, I look up the current location of my origin, and resolve my path against it. 

Usage
----------
FileLocator vmDirectory parent pathString
	> ''/Applications''


FileLocator desktop.
FileLocator desktop basename.

FileLocator home basename.
FileLocator image.
FileLocator vmBinary asAbsolute pathString 
	>  ''/Applications/CogVM.app/Contents/MacOS/CogVM''
FileLocator vmBinary pathString 
	> ''/Applications/CogVM.app/Contents/MacOS/CogVM''
		




Implementation
------------------------
origin 
	A symbolic name for base reference I use to resolve myself.

path
	A relative path that is resolved against my origin"
	
	';
		immediateInvariant.
true.
%

removeallmethods FileLocator
removeallclassmethods FileLocator

doit
(AbstractFileReference
	subclass: 'FileReference'
	instVarNames: #( filesystem path )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I combine a filesystem and path, which is sufficient to refer to a concrete file or directory. I provide methods for navigating my filesystem, performing filesystem operations and opening and closing files.  I am the primary mechanism for working with files and directories. 

| working |
working := FileSystem disk workingDirectory.
working files 

| disk |
disk := FileSystem disk.
disk root.                               	"a reference to the root directory"
disk working.                         	"a reference to the working directory"';
		immediateInvariant.
true.
%

removeallmethods FileReference
removeallclassmethods FileReference

doit
(Object
	subclass: 'CypressAbstractPackageFiler'
	instVarNames: #( repository packageDirectory packageStructure )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractPackageFiler
removeallclassmethods CypressAbstractPackageFiler

doit
(CypressAbstractPackageFiler
	subclass: 'CypressAbstractFileoutWriter'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractFileoutWriter
removeallclassmethods CypressAbstractFileoutWriter

doit
(CypressAbstractFileoutWriter
	subclass: 'CypressSmalltalkFileoutWriter'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressSmalltalkFileoutWriter
removeallclassmethods CypressSmalltalkFileoutWriter

doit
(CypressAbstractFileoutWriter
	subclass: 'CypressTopazFileoutWriter'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressTopazFileoutWriter
removeallclassmethods CypressTopazFileoutWriter

doit
(CypressAbstractPackageFiler
	subclass: 'CypressAbstractPackageReader'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractPackageReader
removeallclassmethods CypressAbstractPackageReader

doit
(CypressAbstractPackageReader
	subclass: 'CypressDoNothingPackageReader'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressDoNothingPackageReader
removeallclassmethods CypressDoNothingPackageReader

doit
(CypressAbstractPackageReader
	subclass: 'CypressFileTreeFormatPackageReader'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileTreeFormatPackageReader
removeallclassmethods CypressFileTreeFormatPackageReader

doit
(CypressAbstractPackageReader
	subclass: 'CypressFlexiblePackageReader'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFlexiblePackageReader
removeallclassmethods CypressFlexiblePackageReader

doit
(CypressAbstractPackageReader
	subclass: 'CypressPackageReader'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageReader
removeallclassmethods CypressPackageReader

doit
(CypressAbstractPackageFiler
	subclass: 'CypressAbstractPackageWriter'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #( specials )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractPackageWriter
removeallclassmethods CypressAbstractPackageWriter

doit
(CypressAbstractPackageWriter
	subclass: 'CypressFileTreeFormatPackageWriter'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileTreeFormatPackageWriter
removeallclassmethods CypressFileTreeFormatPackageWriter

doit
(CypressAbstractPackageWriter
	subclass: 'CypressPackageWriter'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageWriter
removeallclassmethods CypressPackageWriter

doit
(CypressAbstractPackageWriter
	subclass: 'CypressStrictFileTreeFormatDoNothingPackageWriter'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressStrictFileTreeFormatDoNothingPackageWriter
removeallclassmethods CypressStrictFileTreeFormatDoNothingPackageWriter

doit
(Object
	subclass: 'CypressAbstractRepository'
	instVarNames: #( url properties readerClass writerClass )
	classVars: #( DefaultCopyrightNotice )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractRepository
removeallclassmethods CypressAbstractRepository

doit
(CypressAbstractRepository
	subclass: 'CypressAbstractFileoutRepository'
	instVarNames: #( directoryPath )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractFileoutRepository
removeallclassmethods CypressAbstractFileoutRepository

doit
(CypressAbstractFileoutRepository
	subclass: 'CypressSmalltalkRepository'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

This is a "write-only" repository.
It could be made readable, to be able to file-in Smalltalk scripts, but it''s not the same thing.
';
		immediateInvariant.
true.
%

removeallmethods CypressSmalltalkRepository
removeallclassmethods CypressSmalltalkRepository

doit
(CypressAbstractFileoutRepository
	subclass: 'CypressTopazRepository'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

This is a "write-only" repository.
It could be made readable, to be able to file-in Topaz scripts, but it''s not the same thing.
';
		immediateInvariant.
true.
%

removeallmethods CypressTopazRepository
removeallclassmethods CypressTopazRepository

doit
(CypressAbstractRepository
	subclass: 'CypressDictionaryRepository'
	instVarNames: #( dictionary )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressDictionaryRepository
removeallclassmethods CypressDictionaryRepository

doit
(CypressAbstractRepository
	subclass: 'CypressFileSystemRepository'
	instVarNames: #( directoryPath )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileSystemRepository
removeallclassmethods CypressFileSystemRepository

doit
(CypressFileSystemRepository
	subclass: 'CypressFileSystemGitRepository'
	instVarNames: #( remoteUrl )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileSystemGitRepository
removeallclassmethods CypressFileSystemGitRepository

doit
(Object
	subclass: 'CypressFileUtilities'
	instVarNames: #(  )
	classVars: #( Current )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileUtilities
removeallclassmethods CypressFileUtilities

doit
(CypressFileUtilities
	subclass: 'CypressGemStoneDirectoryUtilities'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressGemStoneDirectoryUtilities
removeallclassmethods CypressGemStoneDirectoryUtilities

doit
(Object
	subclass: 'CypressGsGeneralDependencySorter'
	instVarNames: #( candidates dependsOnConverter dependentConverter individualDependencyMap dependencyGraphs candidateAliasMap )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressGsGeneralDependencySorter
removeallclassmethods CypressGsGeneralDependencySorter

doit
(Object
	subclass: 'CypressJsonParser'
	instVarNames: #( stream )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressJsonParser
removeallclassmethods CypressJsonParser

doit
(Object
	subclass: 'CypressObject'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressObject
removeallclassmethods CypressObject

doit
(CypressObject
	subclass: 'CypressAbstractPackageInformation'
	instVarNames: #( name )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractPackageInformation
removeallclassmethods CypressAbstractPackageInformation

doit
(CypressAbstractPackageInformation
	subclass: 'CypressConflictingPackageInformation'
	instVarNames: #( conflictsWith )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressConflictingPackageInformation
removeallclassmethods CypressConflictingPackageInformation

doit
(CypressAbstractPackageInformation
	subclass: 'CypressEclipsedPackageInformation'
	instVarNames: #( eclipsedBy )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressEclipsedPackageInformation
removeallclassmethods CypressEclipsedPackageInformation

doit
(CypressAbstractPackageInformation
	subclass: 'CypressKnownPackageInformation'
	instVarNames: #( repositories digests )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressKnownPackageInformation
removeallclassmethods CypressKnownPackageInformation

doit
(CypressAbstractPackageInformation
	subclass: 'CypressUnknownPackageInformation'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressUnknownPackageInformation
removeallclassmethods CypressUnknownPackageInformation

doit
(CypressObject
	subclass: 'CypressDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressDefinition
removeallclassmethods CypressDefinition

doit
(CypressDefinition
	subclass: 'CypressClassDefinition'
	instVarNames: #( category classInstVarNames classVarNames comment defaultSymbolDictionaryName instVarNames name poolDictionaryNames subclassType superclassName gs_options gs_constraints )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressClassDefinition
removeallclassmethods CypressClassDefinition

doit
(CypressDefinition
	subclass: 'CypressMethodDefinition'
	instVarNames: #( category classIsMeta className selector source )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressMethodDefinition
removeallclassmethods CypressMethodDefinition

doit
(CypressMethodDefinition
	subclass: 'RwCypressMethodDefinition'
	instVarNames: #( isExtensionMethod )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Cypress-Core';
		immediateInvariant.
true.
%

removeallmethods RwCypressMethodDefinition
removeallclassmethods RwCypressMethodDefinition

doit
(CypressObject
	subclass: 'CypressDefinitionIndex'
	instVarNames: #( definitionMap )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressDefinitionIndex
removeallclassmethods CypressDefinitionIndex

doit
(CypressObject
	subclass: 'CypressDependencySorter'
	instVarNames: #( orderedItems provided required )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressDependencySorter
removeallclassmethods CypressDependencySorter

doit
(CypressDependencySorter
	subclass: 'CypressEnvironmentDependencySorter'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Environmental-Tools';
		immediateInvariant.
true.
%

removeallmethods CypressEnvironmentDependencySorter
removeallclassmethods CypressEnvironmentDependencySorter

doit
(CypressObject
	subclass: 'CypressLoader'
	instVarNames: #( additions defaultSymbolDictionaryName errors exceptionClass methodAdditions obsoletions provisions removals requirements unloadable )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressLoader
removeallclassmethods CypressLoader

doit
(CypressLoader
	subclass: 'CypressEnvironmentLoader'
	instVarNames: #( defaultEnvironmentId lookupSymbolList compilationSymbolList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Environmental-Tools';
		immediateInvariant.
true.
%

removeallmethods CypressEnvironmentLoader
removeallclassmethods CypressEnvironmentLoader

doit
(CypressObject
	subclass: 'CypressPackageDefinition'
	instVarNames: #( name )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageDefinition
removeallclassmethods CypressPackageDefinition

doit
(CypressPackageDefinition
	subclass: 'CypressEnvironmentPackageDefinition'
	instVarNames: #( lookupSymbolList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Environmental-Tools';
		comment: 'No class-specific documentation for CypressEnvironmentPackageDefinition, hierarchy is: 
Object
  CypressObject
    CypressPackageDefinition( name)
      CypressEnvironmentPackageDefinition( lookupSymbolList)
';
		immediateInvariant.
true.
%

removeallmethods CypressEnvironmentPackageDefinition
removeallclassmethods CypressEnvironmentPackageDefinition

doit
(CypressObject
	subclass: 'CypressPackageInformation'
	instVarNames: #( name type advice competingPackageNames imageDefinitions savedDefinitions savedLocation repository repositoryDescription imageCounts changesCount )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

CypressPackageInformation documents potential and actual packages for the Cypress Package Manager. 

Candidate package names come from class categories and from method categories beginning with an asterisk. Category names may contain more information than just the package name, such as logical subdivisions within a package or method categorization in addition to the package name. For example, a Package might be named X or Y-Z or whatever. Classes could be categorized as X, Y-Z, X-A, or Y-Z-A, and methods could be categorized as *X, *Y-Z, *X-A, *Y-Z-A, etc. (The various letters X, Y, Z, and A can represent almost any sequence of characters, in either uppercase, lowercase, or both. Package names are case-insensitive.)

There are four types of CypressPackageInformation objects:
 - Known Package - those which are known to represent real packages (e.g., Y-Z). In general, it is because there is a savedLocation specified.
 - Qualified Name - the name is a Known Package name qualified by further details, and cannot be used to represent a Known Package (e.g., X-accessing).
 - Conflicted Name - the name is a prefix of a Known Package name (e.g. given a Known Package named Y-Z, there can be no package named Y).
 - Unknown - the name could represent a package, but it is not known to do so.

Instance Variables
	advice	<String>	Additional information about the type of the instance, usually used only for Qualified Names and Conflcited Names.
	changesCount	<Integer>	The number of differences between the in-image definitions of the package and the definitions previously saved to disk.
	competingPackageNames	<String>*	0 or more strings naming packages in competition with this one.
	imageCounts	<Integer pair>	The number of classes and the number of methods in the image for the package.
	name	<String>	The name of the package or potential package.
	savedLocation	<String>	The path to the directory in which the package was or should be saved, with a trailing slash (e.g., /usr/src/project/).
	type	<String>	One of ''Known Package'', ''Qualified Name'', ''Conflicted Name'', and ''Unknown''.
	imageDefinitions	<CypressDefinition>*	0 or more definitions from the image.
	savedDefinitions	<CypressDefinition>*	0 or more definitions from the savedLocation storage.

';
		immediateInvariant.
true.
%

removeallmethods CypressPackageInformation
removeallclassmethods CypressPackageInformation

doit
(CypressObject
	subclass: 'CypressPatch'
	instVarNames: #( operations )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPatch
removeallclassmethods CypressPatch

doit
(CypressObject
	subclass: 'CypressPatchOperation'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPatchOperation
removeallclassmethods CypressPatchOperation

doit
(CypressPatchOperation
	subclass: 'CypressAddition'
	instVarNames: #( definition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAddition
removeallclassmethods CypressAddition

doit
(CypressPatchOperation
	subclass: 'CypressModification'
	instVarNames: #( modification obsoletion )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressModification
removeallclassmethods CypressModification

doit
(CypressPatchOperation
	subclass: 'CypressRemoval'
	instVarNames: #( definition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressRemoval
removeallclassmethods CypressRemoval

doit
(CypressObject
	subclass: 'CypressSnapshot'
	instVarNames: #( definitions )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressSnapshot
removeallclassmethods CypressSnapshot

doit
(CypressObject
	subclass: 'CypressStructure'
	instVarNames: #( name properties packageStructure )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressStructure
removeallclassmethods CypressStructure

doit
(CypressStructure
	subclass: 'CypressClassStructure'
	instVarNames: #( instanceMethods classMethods comment isClassExtension )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressClassStructure
removeallclassmethods CypressClassStructure

doit
(CypressStructure
	subclass: 'CypressMethodStructure'
	instVarNames: #( source isMetaclass classStructure )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressMethodStructure
removeallclassmethods CypressMethodStructure

doit
(CypressMethodStructure
	subclass: 'RwCypressMethodStructure'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Cypress-Core';
		immediateInvariant.
true.
%

removeallmethods RwCypressMethodStructure
removeallclassmethods RwCypressMethodStructure

doit
(CypressStructure
	subclass: 'CypressPackageStructure'
	instVarNames: #( classes extensions )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageStructure
removeallclassmethods CypressPackageStructure

doit
(CypressPackageStructure
	subclass: 'RwCypressPackageStructure'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Cypress-Core';
		immediateInvariant.
true.
%

removeallmethods RwCypressPackageStructure
removeallclassmethods RwCypressPackageStructure

doit
(Object
	subclass: 'CypressPackageComparator'
	instVarNames: #( directoryPackageMap diskTimestamps diskSnapshots imageSnapshots snapshotDifferences currentPackageName currentAdditions currentRemovals )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Comparison';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageComparator
removeallclassmethods CypressPackageComparator

doit
(Object
	subclass: 'CypressPackageManager'
	instVarNames: #( knownPackages knownRepositories packageInformationList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageManager
removeallclassmethods CypressPackageManager

doit
(Object
	subclass: 'CypressPackageManager2'
	instVarNames: #( knownRepositories packageInformationList )
	classVars: #( SavedPackageManagers )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageManager2
removeallclassmethods CypressPackageManager2

doit
(Object
	subclass: 'CypressPackageManager3'
	instVarNames: #( knownRepositories defaultSymbolDictionaryName resolvedPackageReferences )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageManager3
removeallclassmethods CypressPackageManager3

doit
(CypressPackageManager3
	subclass: 'CypressEnvironmentPackageManager'
	instVarNames: #( defaultSymbolList lookupSymbolList compilationSymbolList defaultEnvironmentId )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Environmental-Tools';
		immediateInvariant.
true.
%

removeallmethods CypressEnvironmentPackageManager
removeallclassmethods CypressEnvironmentPackageManager

doit
(Object
	subclass: 'CypressPackageStringComparator'
	instVarNames: #( directoryPackageMap diskTimestamps diskSnapshots imageSnapshots snapshotDifferences currentPackageName currentOperations )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Comparison';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageStringComparator
removeallclassmethods CypressPackageStringComparator

doit
(Object
	subclass: 'CypressReference'
	instVarNames: #( name )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A CypressReference is an abstract superclass for various kinds of references to Cypress packages. Inspired by GoferReference in Pharo';
		immediateInvariant.
true.
%

removeallmethods CypressReference
removeallclassmethods CypressReference

doit
(CypressReference
	subclass: 'CypressPackageReference'
	instVarNames: #( package branch )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A CypressPackageReference refers to a specific Cypress package.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageReference
removeallclassmethods CypressPackageReference

doit
(CypressPackageReference
	subclass: 'CypressResolvedReference'
	instVarNames: #( repository )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A CypressResolvedReference refers to a specific Cypress package in a repository. This class is the only one that can actually load a package, because it is the only one knowing where to find it.';
		immediateInvariant.
true.
%

removeallmethods CypressResolvedReference
removeallclassmethods CypressResolvedReference

doit
(Object
	subclass: 'CypressUrl'
	instVarNames: #( fragment )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.';
		immediateInvariant.
true.
%

removeallmethods CypressUrl
removeallclassmethods CypressUrl

doit
(CypressUrl
	subclass: 'CypressFileUrl'
	instVarNames: #( host path isAbsolute )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

This class models a file URL according to (somewhat) RFC1738, see http://www.w3.org/Addressing/rfc1738.txt

Here is the relevant part of the RFC:

3.10 FILES

   The file URL scheme is used to designate files accessible on a
   particular host computer. This scheme, unlike most other URL schemes,
   does not designate a resource that is universally accessible over the
   Internet.

   A file URL takes the form:

       file://<host>/<path>

   where <host> is the fully qualified domain name of the system on
   which the <path> is accessible, and <path> is a hierarchical
   directory path of the form <directory>/<directory>/.../<name>.

   For example, a VMS file

     DISK$USER:[MY.NOTES]NOTE123456.TXT

   might become

     <URL:file://vms.host.edu/disk$user/my/notes/note12345.txt>

   As a special case, <host> can be the string "localhost" or the empty
   string; this is interpreted as `the machine from which the URL is
   being interpreted''.

   The file URL scheme is unusual in that it does not specify an
   Internet protocol or access method for such files; as such, its
   utility in network protocols between hosts is limited.

From the above we can conclude that the RFC says that the <path> part never starts or ends with a slash and is always absolute. If the last name can be a directory instead of a file is not specified clearly.

The path is stored as a SequenceableCollection of path parts.

Notes regarding non RFC features in this class:

- If the last path part is the empty string, then the FileUrl is referring to a directory. This is also shown with a trailing slash when converted to a String.

- The FileUrl has an attribute isAbsolute which signals if the path should be considered absolute or relative to the current directory. This distinction is not visible in the String representation of FileUrl, since the RFC does not have that.

- Fragment is supported (kept for historical reasons)

';
		immediateInvariant.
true.
%

removeallmethods CypressFileUrl
removeallclassmethods CypressFileUrl

doit
(CypressFileUrl
	subclass: 'CypressAbstractFileUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractFileUrl
removeallclassmethods CypressAbstractFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressCypressFileUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressCypressFileUrl
removeallclassmethods CypressCypressFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressFileTreeFormatFileUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileTreeFormatFileUrl
removeallclassmethods CypressFileTreeFormatFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressFileTreeReadOnlyFileUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileTreeReadOnlyFileUrl
removeallclassmethods CypressFileTreeReadOnlyFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressGitFileUrl'
	instVarNames: #( projectPath projectBranchOrTag repositoryPath )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressGitFileUrl
removeallclassmethods CypressGitFileUrl

doit
(CypressGitFileUrl
	subclass: 'CypressGitFileTreeUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressGitFileTreeUrl
removeallclassmethods CypressGitFileTreeUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressLaxFileUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressLaxFileUrl
removeallclassmethods CypressLaxFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressSmalltalkUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressSmalltalkUrl
removeallclassmethods CypressSmalltalkUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressTopazUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressTopazUrl
removeallclassmethods CypressTopazUrl

doit
(CypressUrl
	subclass: 'CypressGenericUrl'
	instVarNames: #( schemeName locator )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

a URL type that can''t be broken down in any systematic way.  For example, mailto: and telnet: URLs.  The part after the scheme name is stored available via the #locator message.';
		immediateInvariant.
true.
%

removeallmethods CypressGenericUrl
removeallclassmethods CypressGenericUrl

doit
(CypressGenericUrl
	subclass: 'CypressBrowserUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

URLs that instruct a browser to do something.';
		immediateInvariant.
true.
%

removeallmethods CypressBrowserUrl
removeallclassmethods CypressBrowserUrl

doit
(CypressGenericUrl
	subclass: 'CypressMailtoUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

a URL specifying a mailing address; activating it triggers a mail-sender to start up, if one is present.';
		immediateInvariant.
true.
%

removeallmethods CypressMailtoUrl
removeallclassmethods CypressMailtoUrl

doit
(CypressUrl
	subclass: 'CypressHierarchicalUrl'
	instVarNames: #( schemeName authority path query port username password )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A URL which has a hierarchical encoding.  For instance, http and ftp URLs are hierarchical.';
		immediateInvariant.
true.
%

removeallmethods CypressHierarchicalUrl
removeallclassmethods CypressHierarchicalUrl

doit
(CypressHierarchicalUrl
	subclass: 'CypressFtpUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFtpUrl
removeallclassmethods CypressFtpUrl

doit
(CypressHierarchicalUrl
	subclass: 'CypressHttpUrl'
	instVarNames: #( realm )
	classVars: #( Passwords )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A URL that can be accessed via the Hypertext Transfer Protocol (HTTP), ie, a standard Web URL

realm = the name of the security realm that has been discovered for this URL.   Look it up in Passwords.

Passwords = a Dictionary of (realm -> encoded user&password)


TODO: use the username and password, if specified
';
		immediateInvariant.
true.
%

removeallmethods CypressHttpUrl
removeallclassmethods CypressHttpUrl

doit
(CypressHttpUrl
	subclass: 'CypressHttpsUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressHttpsUrl
removeallclassmethods CypressHttpsUrl

doit
(Object
	subclass: 'CypressVersionReference'
	instVarNames: #( name package author branch versionNumber )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A CypressVersionReference refers to a specific version of a Monticello package.';
		immediateInvariant.
true.
%

removeallmethods CypressVersionReference
removeallclassmethods CypressVersionReference

doit
(Object
	subclass: 'FastUUIDGenerator'
	instVarNames: #( bits1 bits2 bits3 bits4 random semaphoreForGenerator )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Network-UUID';
		immediateInvariant.
true.
%

removeallmethods FastUUIDGenerator
removeallclassmethods FastUUIDGenerator

doit
(Object
	subclass: 'File'
	instVarNames: #( name )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Files';
		comment: 'I represent a sequential binary File. I provide the minimum operations to:

- move the cursor fo the file
- reading
- writing

I am also the entry point of the FilePlugin primitives.

!Examples of usage

"Creating a file"
file := File named: ''asd.txt'' asFileReference fullName.

"Opening / closing it"
file open.
file openForAppend.
file close.

"Accessing the file properties"
file size.
file position.
file position: 0.
file seekAbsolute: 10.
file seekRelative: 10.
file atEnd.

"Writing"
file nextPutAll: ''sdd''.

"Reading"
file next: 2.

"Buffered write"
file next: 2 putAll: ''abc'' startingAt: 2.

"Buffered read"
buffer := ByteArray new: 5.
file readInto: buffer startingAt: 1 count: 5.
buffer asString.';
		immediateInvariant.
true.
%

removeallmethods File
removeallclassmethods File

doit
(Object
	subclass: 'FileSystem'
	instVarNames: #( store )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I present a low-level protocol for interacting with filesystems. I hold a reference to
a store (a subinstance of FileSystemStore) which takes care of the details of performing 
file and directory operations on the filesystem I represent. 

I am responsible for resolving all paths that
I pass into my store. My store acts as a factory and offers platform specific actions.


FileSystem instances know two methods that return a Reference object: workingDirectory and root.

FileSystem disk workingDirectory
FileSystem disk root

';
		immediateInvariant.
true.
%

removeallmethods FileSystem
removeallclassmethods FileSystem

doit
(Object
	subclass: 'FileSystemDirectoryEntry'
	instVarNames: #( reference creation modification isDirectory isSymlink size posixPermissions )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am a cache for metadata about a file or directory. The information I hold is as follows:

reference
	A reference to the file or directory to which my data pertains.
	
creation
	The creation date and time, stored as number seconds since the 
	Smalltalk epoch.
	
modification
	The modification date and time, number seconds since the Smalltalk epoch.
	
isDirectory 
	True if my data pertains to a directory, false if a file.
	
size
	Size in bytes for a file, 0 for a directory.
';
		immediateInvariant.
true.
%

removeallmethods FileSystemDirectoryEntry
removeallclassmethods FileSystemDirectoryEntry

doit
(Object
	subclass: 'FileSystemGuide'
	instVarNames: #( visitor work selectChildren )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an abstract superclass for objects that fulfill the Guide role in the Guide/Visitor pattern. My subclasses know how to traverse a filesystem in a specific order, "showing" the files and directories they encounter to a visitor.

visitor
	An object that fulfills the Visitor role and implements the visitor protocol.
	
work
	An OrderedCollection, used to keep track of filesystem nodes that have not yet been visited';
		immediateInvariant.
true.
%

removeallmethods FileSystemGuide
removeallclassmethods FileSystemGuide

doit
(FileSystemGuide
	subclass: 'BreadthFirstGuide'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I traverse the filesystem in breadth-first order. Given this hierarchy:

alpha
	beta
	gamma
delta
	epsilon

I would visit the nodes in the following order:  alpha, delta, beta, gamma, epsilon.

I use my work instance variable as a queue, adding nodes to be visited to the end and retrieving them from the beginning.
';
		immediateInvariant.
true.
%

removeallmethods BreadthFirstGuide
removeallclassmethods BreadthFirstGuide

doit
(FileSystemGuide
	subclass: 'PostorderGuide'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I traverse the filesystem in depth-first post order. Given this hierarchy:

alpha
	beta
	gamma
delta
	epsilon

I would visit the nodes in the following order:  beta, gamma, alpha, epsilon, delta.

I use my work instance variable as a stack. I push messages that cause nodes to be traversed or visited, and execute them in reverse order.';
		immediateInvariant.
true.
%

removeallmethods PostorderGuide
removeallclassmethods PostorderGuide

doit
(FileSystemGuide
	subclass: 'PreorderGuide'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I traverse the filesystem in depth-first pre order. Given this hierarchy:

alpha
	beta
	gamma
delta
	epsilon

I would visit the nodes in the following order: alpha, beta, gamma, delta, epsilon.

I use my work instance variable as a stack. I push nodes to be visited and visit them in reverse order.';
		immediateInvariant.
true.
%

removeallmethods PreorderGuide
removeallclassmethods PreorderGuide

doit
(Object
	subclass: 'FileSystemHandle'
	instVarNames: #( reference writable )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an abstract superclass for file handle implementations. I provide a uniform interface that streams can use for read and write operations on a file regardless of the filesystem. I encapsulate the actual IO primitives.';
		immediateInvariant.
true.
%

removeallmethods FileSystemHandle
removeallclassmethods FileSystemHandle

doit
(FileSystemHandle
	subclass: 'FileHandle'
	instVarNames: #( id )
	classVars: #( Registry )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Disk';
		comment: 'I provide an interface for doing IO on an open file. I keep an id, which as an opaque identifier used by the FilePlugin primitives. I translate positions from the 1-based indexes used in Smalltalk to the 0-based offsets used by the primitives.

I implement the primitives on my class side.';
		immediateInvariant.
true.
%

removeallmethods FileHandle
removeallclassmethods FileHandle

doit
(FileSystemHandle
	subclass: 'MemoryHandle'
	instVarNames: #( entry )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Memory';
		comment: 'I provide "primitives" for doing IO on files in a MemoryFileSystem. I delegate most of my actions to the MemoryFile. This way there is only one place needed where the data is stored.';
		immediateInvariant.
true.
%

removeallmethods MemoryHandle
removeallclassmethods MemoryHandle

doit
(Object
	subclass: 'FileSystemPermission'
	instVarNames: #( posixPermission )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I''m a set of permissions for a Directory Entry';
		immediateInvariant.
true.
%

removeallmethods FileSystemPermission
removeallclassmethods FileSystemPermission

doit
(Object
	subclass: 'FileSystemResolver'
	instVarNames: #( next )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an abstract superclass for objects that can resolve origins into references. Such objects use the Chain of Responsibility pattern, and when unable to resolve a particular origin, delegate that resolution request to the next resolver in the list.

next
	The next resolver in the list, or nil
';
		immediateInvariant.
true.
%

removeallmethods FileSystemResolver
removeallclassmethods FileSystemResolver

doit
(FileSystemResolver
	subclass: 'InteractiveResolver'
	instVarNames: #( cache )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I resolve origins by consulting the user. I maintain a cache of the user''s responses.';
		immediateInvariant.
true.
%

removeallmethods InteractiveResolver
removeallclassmethods InteractiveResolver

doit
(FileSystemResolver
	subclass: 'PlatformResolver'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an abstract superclass for platform-specific resolvers.';
		immediateInvariant.
true.
%

removeallmethods PlatformResolver
removeallclassmethods PlatformResolver

doit
(PlatformResolver
	subclass: 'MacOSResolver'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an expert on Mac OS X filesystem conventions. I resolve origins according to these conventions.';
		immediateInvariant.
true.
%

removeallmethods MacOSResolver
removeallclassmethods MacOSResolver

doit
(PlatformResolver
	subclass: 'UnixResolver'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an expert on Unix filesystem conventions. I resolve origins according to these conventions.';
		immediateInvariant.
true.
%

removeallmethods UnixResolver
removeallclassmethods UnixResolver

doit
(PlatformResolver
	subclass: 'WindowsResolver'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an expert on Windows filesystem conventions. I resolve origins according to these conventions.';
		immediateInvariant.
true.
%

removeallmethods WindowsResolver
removeallclassmethods WindowsResolver

doit
(FileSystemResolver
	subclass: 'SystemResolver'
	instVarNames: #(  )
	classVars: #( UserLocalDirectory )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I resolve origins that are related to the currently running Smalltalk system, using primitives provided by the VM. ';
		immediateInvariant.
true.
%

removeallmethods SystemResolver
removeallclassmethods SystemResolver

doit
(Object
	subclass: 'FileSystemStore'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an abstract superclass for store implementations. My subclasses provide access to the actual data storage of a particular kind of filesystem. 

The file system can be accessed via
	FileSystem disk 
	FileSystem memory
	
My associated filesystem can be accessed as follows:
      DiskStore currentFileSystem';
		immediateInvariant.
true.
%

removeallmethods FileSystemStore
removeallclassmethods FileSystemStore

doit
(FileSystemStore
	subclass: 'DiskStore'
	instVarNames: #( maxFileNameLength )
	classVars: #( CurrentFS DefaultWorkingDirectory )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Disk';
		comment: 'I am an abstract superclass for disk store implementations. My subclasses provide access to the actual data storage of a particular kind of filesystem. 
';
		immediateInvariant.
true.
%

removeallmethods DiskStore
removeallclassmethods DiskStore

doit
(DiskStore
	subclass: 'UnixStore'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Disk';
		comment: 'I''m a specific store for Unix file systems';
		immediateInvariant.
true.
%

removeallmethods UnixStore
removeallclassmethods UnixStore

doit
(UnixStore
	subclass: 'MacStore'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Disk';
		comment: 'I''m a specific store for OSX file systems';
		immediateInvariant.
true.
%

removeallmethods MacStore
removeallclassmethods MacStore

doit
(DiskStore
	subclass: 'WindowsStore'
	instVarNames: #( disk )
	classVars: #( Disks )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Disk';
		comment: 'I''m a specific store for Windows file systems';
		immediateInvariant.
true.
%

removeallmethods WindowsStore
removeallclassmethods WindowsStore

doit
(FileSystemStore
	subclass: 'MemoryStore'
	instVarNames: #( root )
	classVars: #( CurrentFS )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Memory';
		comment: 'I''m a specific store for memory file system';
		immediateInvariant.
true.
%

removeallmethods MemoryStore
removeallclassmethods MemoryStore

doit
(Object
	subclass: 'FileSystemVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am an abstract superclass for objects that can perform operations on directory trees. My subclasses implement the visitor protocol, and process filesystem nodes shown to them by guides.';
		immediateInvariant.
true.
%

removeallmethods FileSystemVisitor
removeallclassmethods FileSystemVisitor

doit
(FileSystemVisitor
	subclass: 'AbstractEnumerationVisitor'
	instVarNames: #( out block )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I''m an abstract superclass for enumeration operations on directory entries. ';
		immediateInvariant.
true.
%

removeallmethods AbstractEnumerationVisitor
removeallclassmethods AbstractEnumerationVisitor

doit
(AbstractEnumerationVisitor
	subclass: 'CollectVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am a visitor that collects objects from the nodes I visit. I take a block similar to those passed to Collection>>collect:. I evaluate the block with DirectoryEntries for the nodes I visit, and collect the objects answered into an array.

I can use any guide, and the objects in the array I produce will reflect the order imposed by the guide.';
		immediateInvariant.
true.
%

removeallmethods CollectVisitor
removeallclassmethods CollectVisitor

doit
(AbstractEnumerationVisitor
	subclass: 'SelectVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I am a visitor that selects objects from the nodes I visit. I take a block similar to those passed to Collection>>select:. I evaluate the block with DirectoryEntries for the nodes I visit.

I can use any guide, and the objects in the array I produce will reflect the order imposed by the guide.';
		immediateInvariant.
true.
%

removeallmethods SelectVisitor
removeallclassmethods SelectVisitor

doit
(FileSystemVisitor
	subclass: 'CopyVisitor'
	instVarNames: #( source dest )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I create a copy of the directory tree that I visit. I use the PreorderGuide so that I can create directories before creating their contents. ';
		immediateInvariant.
true.
%

removeallmethods CopyVisitor
removeallclassmethods CopyVisitor

doit
(FileSystemVisitor
	subclass: 'DeleteVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Core';
		comment: 'I delete the directory tree that I visit. I use the PostorderGuide so that I can delete files before deleting their containing directories.';
		immediateInvariant.
true.
%

removeallmethods DeleteVisitor
removeallclassmethods DeleteVisitor

doit
(Object
	subclass: 'GsInteraction'
	instVarNames: #( defaultActionBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsInteraction
removeallclassmethods GsInteraction

doit
(GsInteraction
	subclass: 'GsChoiceInteraction'
	instVarNames: #( prompt labels values lines )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsChoiceInteraction
removeallclassmethods GsChoiceInteraction

doit
(GsInteraction
	subclass: 'GsConfirmInteraction'
	instVarNames: #( prompt confirm cancel abort )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsConfirmInteraction
removeallclassmethods GsConfirmInteraction

doit
(GsConfirmInteraction
	subclass: 'GsNotifyInteraction'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsNotifyInteraction
removeallclassmethods GsNotifyInteraction

doit
(GsInteraction
	subclass: 'GsInformInteraction'
	instVarNames: #( message )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsInformInteraction
removeallclassmethods GsInformInteraction

doit
(GsInteraction
	subclass: 'GsInspectInteraction'
	instVarNames: #( theObject )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsInspectInteraction
removeallclassmethods GsInspectInteraction

doit
(GsInspectInteraction
	subclass: 'GsExploreInteraction'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsExploreInteraction
removeallclassmethods GsExploreInteraction

doit
(GsInteraction
	subclass: 'GsTextInteraction'
	instVarNames: #( prompt template requestPassword )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsTextInteraction
removeallclassmethods GsTextInteraction

doit
(GsTextInteraction
	subclass: 'GsMultiLineTextInteraction'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsMultiLineTextInteraction
removeallclassmethods GsMultiLineTextInteraction

doit
(Object
	subclass: 'GsInteractionHandler'
	instVarNames: #( choiceBlock confirmBlock informBlock textBlock multiLineTextBlock defaultBlock inspectBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsInteractionHandler
removeallclassmethods GsInteractionHandler

doit
(Object
	subclass: 'GsTonelOrderedDictionary'
	instVarNames: #( size keys values )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		comment: 'I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating. My implementation features some ideas from the RefactoringBrowser.';
		immediateInvariant.
true.
%

removeallmethods GsTonelOrderedDictionary
removeallclassmethods GsTonelOrderedDictionary

doit
(Object
	subclass: 'JadeServer'
	instVarNames: #( classList classOrganizers readStream writeStream selectedClass methodFilterType methodFilters selections methodCommandResult )
	classVars: #( ExternalInteger GciError GsObject OopType32 OopType64 )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer
removeallclassmethods JadeServer

doit
(JadeServer
	subclass: 'JadeServer64bit'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer64bit
removeallclassmethods JadeServer64bit

doit
(JadeServer64bit
	subclass: 'JadeServer64bit24'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer64bit24
removeallclassmethods JadeServer64bit24

doit
(JadeServer64bit24
	subclass: 'JadeServer64bit3x'
	instVarNames: #( environment )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer64bit3x
removeallclassmethods JadeServer64bit3x

doit
(JadeServer64bit3x
	subclass: 'JadeServer64bit32'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer64bit32
removeallclassmethods JadeServer64bit32

doit
(JadeServer64bit32
	subclass: 'JadeServer64bit35'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer64bit35
removeallclassmethods JadeServer64bit35

doit
(Object
	subclass: 'MemoryFileSystemEntry'
	instVarNames: #( creationTime modificationTime basename )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Memory';
		comment: 'I am an abstract file system entry for a memory file system.
My subclasses should specialize on the kind of file they are.';
		immediateInvariant.
true.
%

removeallmethods MemoryFileSystemEntry
removeallclassmethods MemoryFileSystemEntry

doit
(MemoryFileSystemEntry
	subclass: 'MemoryFileSystemDirectory'
	instVarNames: #( entries )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Memory';
		comment: 'I represent a memory file system entry for a directory';
		immediateInvariant.
true.
%

removeallmethods MemoryFileSystemDirectory
removeallclassmethods MemoryFileSystemDirectory

doit
(MemoryFileSystemEntry
	subclass: 'MemoryFileSystemFile'
	instVarNames: #( bytes size closed )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Memory';
		comment: 'I represent a memory file system entry for a regular file';
		immediateInvariant.
true.
%

removeallmethods MemoryFileSystemFile
removeallclassmethods MemoryFileSystemFile

doit
(Object
	subclass: 'MemoryFileWriteStream'
	instVarNames: #( file writeStream stream )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Memory';
		comment: 'A file write stream - but within memory';
		immediateInvariant.
true.
%

removeallmethods MemoryFileWriteStream
removeallclassmethods MemoryFileWriteStream

doit
(Object
	indexableSubclass: 'Path'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Path';
		comment: 'I''m a private and abstract filesystem path, independent of the string representation used to describe paths on a specific filesystem. I provide methods for navigating the filesystem hierarchy and working with absolute and relative paths. I only refer to a concrete file or directory with regard to a specific filesystem. Normally users should not use me directly. 

API instance creation:

- #from: parses the supplied string using the default delimeter
- #from:delimiter: parses the supplied string using the supplied delimiter.
- #/ creates an absolute path from the supplied string
- #* creates a relative path from the supplied string

API path manipulation:

- #/ adds the supplied string to the receiver
';
		immediateInvariant.
true.
%

removeallmethods Path
removeallclassmethods Path

doit
(Path
	subclass: 'AbsolutePath'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Path';
		comment: 'I represent an absolute path (a position starting from Path root)';
		immediateInvariant.
true.
%

removeallmethods AbsolutePath
removeallclassmethods AbsolutePath

doit
(Path
	subclass: 'RelativePath'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Path';
		comment: 'I represent a relative path (a position starting from Path workingDirectory)';
		immediateInvariant.
true.
%

removeallmethods RelativePath
removeallclassmethods RelativePath

doit
(Object
	subclass: 'RBParser'
	instVarNames: #( scanner currentToken nextToken errorBlock source comments pragmas )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBParser takes a source code string and generates an AST for it. This is a hand-written, recursive descent parser and has been optimized for speed. The simplest way to call this is either ''RBParser parseExpression: aString'' if you want the AST for an expression, or ''RBParser parseMethod: aString'' if you want to parse an entire method.

Instance Variables:
	currentToken	<RBToken>	The current token being processed.
	emptyStatements	<Boolean>	True if empty statements are allowed. In IBM, they are, in VW they aren''t.
	errorBlock	<BlockClosure>	The block to evaluate on a syntax error.
	nextToken	<RBToken>	The next token that will be processed. This allows one-token lookahead.
	scanner	<RBScanner>	The scanner that generates a stream of tokens to parse.
	source	<String>	The source code to parse
	tags	<Collection of: Interval>	The source intervals of the tags appearing at the top of a method (e.g. Primitive calls)

Shared Variables:
	ParserType	<Symbol>	the type code we are parsing';
		immediateInvariant.
true.
%

removeallmethods RBParser
removeallclassmethods RBParser

doit
(RBParser
	subclass: 'RBPatternParser'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBPatternParser is a subclass of RBParser that allows the extended syntax that creates matching trees. These trees can be used by the ParseTreeMatcher to search and transform source code.
';
		immediateInvariant.
true.
%

removeallmethods RBPatternParser
removeallclassmethods RBPatternParser

doit
(RBParser
	subclass: 'RBTonelParser'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		immediateInvariant.
true.
%

removeallmethods RBTonelParser
removeallclassmethods RBTonelParser

doit
(Object
	subclass: 'RBParseTreeRule'
	instVarNames: #( searchTree owner )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBParseTreeRule is the abstract superclass of all of the parse tree searching rules. A parse tree rule is the first class representation of a particular rule to search for. The owner of a rule is the algorithm that actually executes the search. This arrangement allows multiple searches to be conducted by a single Searcher.

Instance Variables:
	owner	<ParseTreeSearcher>	The searcher that is actually performing the search.
	searchTree	<RBProgramNode>	The parse tree to be searched.

';
		immediateInvariant.
true.
%

removeallmethods RBParseTreeRule
removeallclassmethods RBParseTreeRule

doit
(RBParseTreeRule
	subclass: 'RBReplaceRule'
	instVarNames: #( verificationBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBReplaceRule is the abstract superclass of all of the transforming rules. The rules change the source code by replacing the node that matches the rule. Subclasses implement different strategies for this replacement.

Subclasses must implement the following messages:
	matching
		foundMatchFor:

Instance Variables:
	verificationBlock	<BlockClosure>	Is evaluated with the matching node. This allows for further verification of a match beyond simple tree matching.

';
		immediateInvariant.
true.
%

removeallmethods RBReplaceRule
removeallclassmethods RBReplaceRule

doit
(RBReplaceRule
	subclass: 'RBBlockReplaceRule'
	instVarNames: #( replaceBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBBlockReplaceRule replaces the matching node by the result of evaluating replaceBlock. This allows arbitrary computation to come up with a replacement.

Instance Variables:
	replaceBlock	<BlockClosure>	The block that returns the node to replace to matching node with.
';
		immediateInvariant.
true.
%

removeallmethods RBBlockReplaceRule
removeallclassmethods RBBlockReplaceRule

doit
(RBReplaceRule
	subclass: 'RBStringReplaceRule'
	instVarNames: #( replaceTree )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBStringReplaceRule replaces a matched tree with another tree (which may include metavariable from the matching tree). This is a very succint syntax for specifying most rewrites.

Instance Variables:
	replaceTree	<RBProgramNode>	The tree to replace the matched tree with.

';
		immediateInvariant.
true.
%

removeallmethods RBStringReplaceRule
removeallclassmethods RBStringReplaceRule

doit
(RBParseTreeRule
	subclass: 'RBSearchRule'
	instVarNames: #( answerBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBSearchRule is a parse tree rule that simply searches for matches to the rule. Every time a match is found, answerBlock is evaluated with the node that matches and the cureent answer. This two-argument approach allows a collection to be formed from all of the matches (Think inject:into:).

Instance Variables:
	answerBlock	<BlockClosure>	Block to evaluate with the matching node and the current answer.

';
		immediateInvariant.
true.
%

removeallmethods RBSearchRule
removeallclassmethods RBSearchRule

doit
(Object
	subclass: 'RBProgramNode'
	instVarNames: #( parent comments properties )
	classVars: #( FormatterClass )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBProgramNode is an abstract class that represents an abstract syntax tree node in a Smalltalk program.

Subclasses must implement the following messages:
	accessing
		start
		stop
	visitor
		acceptVisitor:

The #start and #stop methods are used to find the source that corresponds to this node. "source copyFrom: self start to: self stop" should return the source for this node.

The #acceptVisitor: method is used by RBProgramNodeVisitors (the visitor pattern). This will also require updating all the RBProgramNodeVisitors so that they know of the new node.

Subclasses might also want to redefine match:inContext: and copyInContext: to do parse tree searching and replacing.

Subclasses that contain other nodes should override equalTo:withMapping: to compare nodes while ignoring renaming temporary variables, and children that returns a collection of our children nodes.

Instance Variables:
	comments	<Collection of: Interval>	the intervals in the source that have comments for this node
	parent	<RBProgramNode>	the node we''re contained in

Shared Variables:
	FormatterClass	<Behavior>	the formatter class that is used when we are formatted';
		immediateInvariant.
true.
%

removeallmethods RBProgramNode
removeallclassmethods RBProgramNode

doit
(RBProgramNode
	subclass: 'RBMethodNode'
	instVarNames: #( selector selectorParts body source arguments pragmas replacements nodeReplacements )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBMethodNode is the AST that represents a Smalltalk method.

Instance Variables:
	arguments	<SequenceableCollection of: RBVariableNode>	the arguments to the method
	body	<BRSequenceNode>	the body/statements of the method
	nodeReplacements	<Dictionary>	a dictionary of oldNode -> newNode replacements
	replacements	<Collection of: RBStringReplacement>	the collection of string replacements for each node replacement in the parse tree
	selector	<Symbol | nil>	the method name (cached)
	selectorParts	<SequenceableCollection of: RBValueToken>	the tokens for the selector keywords
	source	<String>	the source we compiled
	tags	<Collection of: Interval>	the source location of any resource/primitive tags

';
		immediateInvariant.
true.
%

removeallmethods RBMethodNode
removeallclassmethods RBMethodNode

doit
(RBMethodNode
	subclass: 'RBPatternMethodNode'
	instVarNames: #( isList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBPatternMethodNode is a RBMethodNode that will match other method nodes without their selectors being equal. 

Instance Variables:
	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)

';
		immediateInvariant.
true.
%

removeallmethods RBPatternMethodNode
removeallclassmethods RBPatternMethodNode

doit
(RBProgramNode
	subclass: 'RBPragmaNode'
	instVarNames: #( selector selectorParts arguments isProtected left right )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBPragmaNode is an AST node that represents a method pragma.

Instance Variables:
	arguments <SequenceableCollection of: RBLiteralNode> our argument nodes
	left <Integer | nil> position of <
	right <Integer | nil> position of >
	selector <Symbol | nil>	the selector we''re sending (cached)
	selectorParts <SequenceableCollection of: RBValueToken> the tokens for each keyword';
		immediateInvariant.
true.
%

removeallmethods RBPragmaNode
removeallclassmethods RBPragmaNode

doit
(RBPragmaNode
	subclass: 'RBPatternPragmaNode'
	instVarNames: #( isList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		immediateInvariant.
true.
%

removeallmethods RBPatternPragmaNode
removeallclassmethods RBPatternPragmaNode

doit
(RBProgramNode
	subclass: 'RBReturnNode'
	instVarNames: #( return value )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBReturnNode is an AST node that represents a return expression.

Instance Variables:
	return	<Integer>	the position of the ^ character
	value	<RBValueNode>	the value that is being returned

';
		immediateInvariant.
true.
%

removeallmethods RBReturnNode
removeallclassmethods RBReturnNode

doit
(RBProgramNode
	subclass: 'RBSequenceNode'
	instVarNames: #( leftBar rightBar statements periods temporaries )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBSequenceNode is an AST node that represents a sequence of statements. Both RBBlockNodes and RBMethodNodes contain these.

Instance Variables:
	leftBar	<Integer | nil>	the position of the left | in the temporaries definition
	periods	<SequenceableCollection of: Integer>	the positions of all the periods that separate the statements
	rightBar	<Integer | nil>	the position of the right | in the temporaries definition
	statements	<SequenceableCollection of: RBStatementNode>	the statement nodes
	temporaries	<SequenceableCollection of: RBVariableNode>	the temporaries defined

';
		immediateInvariant.
true.
%

removeallmethods RBSequenceNode
removeallclassmethods RBSequenceNode

doit
(RBProgramNode
	subclass: 'RBValueNode'
	instVarNames: #( parentheses )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBValueNode is an abstract class that represents a node that returns some value.

Subclasses must implement the following messages:
	accessing
		startWithoutParentheses
		stopWithoutParentheses
	testing
		needsParenthesis

Instance Variables:
	parentheses	<SequenceableCollection of: Inteval>	the positions of the parethesis around this node. We need a collection of intervals for stupid code such as "((3 + 4))" that has multiple parethesis around the same expression.

';
		immediateInvariant.
true.
%

removeallmethods RBValueNode
removeallclassmethods RBValueNode

doit
(RBValueNode
	subclass: 'RBArrayNode'
	instVarNames: #( left right statements periods )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'A RBArrayNode is an AST node for runtime arrays.

Instance Variables
	left:	 <Integer | nil> position of {
	periods: <SequenceableCollection of: Integer> the positions of all the periods that separate the statements
	right: <Integer | nil> position of }
	statements: <SequenceableCollection of: RBStatementNode> the statement nodes';
		immediateInvariant.
true.
%

removeallmethods RBArrayNode
removeallclassmethods RBArrayNode

doit
(RBValueNode
	subclass: 'RBAssignmentNode'
	instVarNames: #( variable assignment value )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBAssignmentNode is an AST node for assignment statements

Instance Variables:
	assignment	<Integer>	position of the :=
	value	<RBValueNode>	the value that we''re assigning
	variable	<RBVariableNode>	the variable being assigned

';
		immediateInvariant.
true.
%

removeallmethods RBAssignmentNode
removeallclassmethods RBAssignmentNode

doit
(RBValueNode
	subclass: 'RBBlockNode'
	instVarNames: #( left right colons arguments bar body )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBBlockNode is an AST node that represents a block "[...]".

Instance Variables:
	arguments	<SequenceableCollection of: RBVariableNode>	the arguments for the block
	bar	<Integer | nil>	position of the | after the arguments
	body	<RBSequenceNode>	the code inside the block
	colons	<SequenceableCollection of: Integer>	positions of each : before each argument
	left	<Integer>	position of [
	right	<Integer>	position of ]

';
		immediateInvariant.
true.
%

removeallmethods RBBlockNode
removeallclassmethods RBBlockNode

doit
(RBBlockNode
	subclass: 'RBPatternBlockNode'
	instVarNames: #( valueBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBPatternBlockNode is the node in matching parse trees (it never occurs in normal Smalltalk code) that executes a block to determine if a match occurs. valueBlock takes two arguments, the first is the actual node that we are trying to match against, and second node is the dictionary that contains all the metavariable bindings that the matcher has made thus far.

Instance Variables:
	valueBlock	<BlockClosure>	The block to execute when attempting to match this to a node.

';
		immediateInvariant.
true.
%

removeallmethods RBPatternBlockNode
removeallclassmethods RBPatternBlockNode

doit
(RBPatternBlockNode
	subclass: 'RBPatternWrapperBlockNode'
	instVarNames: #( wrappedNode )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBPatternWrapperBlockNode allows further matching using a block after a node has been matched by a pattern node.

Instance Variables:
	wrappedNode	<RBProgramNode>	The original pattern node to match';
		immediateInvariant.
true.
%

removeallmethods RBPatternWrapperBlockNode
removeallclassmethods RBPatternWrapperBlockNode

doit
(RBBlockNode
	subclass: 'RBQueryBlockNode'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		immediateInvariant.
true.
%

removeallmethods RBQueryBlockNode
removeallclassmethods RBQueryBlockNode

doit
(RBValueNode
	subclass: 'RBCascadeNode'
	instVarNames: #( messages semicolons )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBCascadeNode is an AST node for cascaded messages (e.g., "self print1 ; print2").

Instance Variables:
	messages	<SequenceableCollection of: RBMessageNode>	the messages 
	semicolons	<SequenceableCollection of: Integer>	positions of the ; between messages

';
		immediateInvariant.
true.
%

removeallmethods RBCascadeNode
removeallclassmethods RBCascadeNode

doit
(RBValueNode
	subclass: 'RBLiteralNode'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBLiteralNode is an AST node that represents literals.';
		immediateInvariant.
true.
%

removeallmethods RBLiteralNode
removeallclassmethods RBLiteralNode

doit
(RBLiteralNode
	subclass: 'RBLiteralArrayNode'
	instVarNames: #( isByteArray stop contents start )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'A RBLiteralArrayNode is an AST node that represents literal arrays and literal byte arrays.

Instance Variables
	contents: <Array of: RBLiteralNode> literal nodes of the array
	isByteArray: <Boolean> if the receiver is a literal byte array
	start: <Integer | nil> source position of #( or #[
	stop: <Integer | nil> source position of ) or ]';
		immediateInvariant.
true.
%

removeallmethods RBLiteralArrayNode
removeallclassmethods RBLiteralArrayNode

doit
(RBLiteralNode
	subclass: 'RBLiteralValueNode'
	instVarNames: #( token )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBLiteralNode is an AST node that represents literal values (e.g., #foo, true, 1, etc.), but not literal arrays.

Instance Variables:
	token	<RBLiteralToken>	the token that contains the literal value as well as its source positions';
		immediateInvariant.
true.
%

removeallmethods RBLiteralValueNode
removeallclassmethods RBLiteralValueNode

doit
(RBValueNode
	subclass: 'RBMessageNode'
	instVarNames: #( receiver selector selectorParts arguments )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBMessageNode is an AST node that represents a message send.

Instance Variables:
	arguments	<SequenceableCollection of: RBValueNode>	our argument nodes
	receiver	<RBValueNode>	the receiver''s node
	selector	<Symbol | nil>	the selector we''re sending (cached)
	selectorParts	<SequenceableCollection of: RBValueToken>	the tokens for each keyword

';
		immediateInvariant.
true.
%

removeallmethods RBMessageNode
removeallclassmethods RBMessageNode

doit
(RBMessageNode
	subclass: 'RBPatternMessageNode'
	instVarNames: #( isList isCascadeList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBPatternMessageNode is a RBMessageNode that will match other message nodes without their selectors being equal. 

Instance Variables:
	isCascadeList	<Boolean>	are we matching a list of message nodes in a cascaded message
	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)';
		immediateInvariant.
true.
%

removeallmethods RBPatternMessageNode
removeallclassmethods RBPatternMessageNode

doit
(RBValueNode
	subclass: 'RBVariableNode'
	instVarNames: #( token )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBVariableNode is an AST node that represent a variable (global, inst var, temp, etc.).

Instance Variables:
	token	<RBValueToken>	the token that contains our name and position

';
		immediateInvariant.
true.
%

removeallmethods RBVariableNode
removeallclassmethods RBVariableNode

doit
(RBVariableNode
	subclass: 'RBPatternVariableNode'
	instVarNames: #( recurseInto isList isLiteral isStatement isAnything )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBPatternVariableNode is an AST node that is used to match several other types of nodes (literals, variables, value nodes, statement nodes, and sequences of statement nodes).

The different types of matches are determined by the name of the node. If the name contains a # character, then it will match a literal. If it contains, a . then it matches statements. If it contains no extra characters, then it matches only variables. These options are mutually exclusive.

The @ character can be combined with the name to match lists of items. If combined with the . character, then it will match a list of statement nodes (0 or more). If used without the . or # character, then it matches anything except for list of statements. Combining the @ with the # is not supported.

Adding another ` in the name will cause the search/replace to look for more matches inside the node that this node matched. This option should not be used for top level expressions since that would cause infinite recursion (e.g., searching only for "``@anything").

Instance Variables:
	isAnything	<Boolean>	can we match any type of node
	isList	<Boolean>	can we match a list of items (@)
	isLiteral	<Boolean>	only match a literal node (#)
	isStatement	<Boolean>	only match statements (.)
	recurseInto	<Boolean>	search for more matches in the node we match (`)

';
		immediateInvariant.
true.
%

removeallmethods RBPatternVariableNode
removeallclassmethods RBPatternVariableNode

doit
(Object
	subclass: 'RBProgramNodeVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBProgramNodeVisitor is an abstract visitor for the RBProgramNodes.

';
		immediateInvariant.
true.
%

removeallmethods RBProgramNodeVisitor
removeallclassmethods RBProgramNodeVisitor

doit
(RBProgramNodeVisitor
	subclass: 'RBConfigurableFormatter'
	instVarNames: #( codeStream indent lookaheadCode originalSource lineStart inQueryBlock )
	classVars: #( CascadedMessageInsideParentheses FormatCommentWithStatements IndentsForKeywords IndentString InQueryBlock KeepBlockInMessage LineUpBlockBrackets MaxLineLength MethodSignatureOnMultipleLines MinimumNewLinesBetweenStatements MultiLineMessages NewLineAfterCascade NewLineBeforeFirstCascade NewLineBeforeFirstKeyword NewLinesAfterMethodComment NewLinesAfterMethodPattern NewLinesAfterTemporaries NumberOfArgumentsForMultiLine OneLineMessages PeriodsAtEndOfBlock PeriodsAtEndOfMethod RetainBlankLinesBetweenStatements StringFollowingReturn StringInsideBlocks StringInsideParentheses TraditionalBinaryPrecedence UseTraditionalBinaryPrecedenceForParentheses )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBConfigurableFormatter formats the Refactoring Browser''s parse trees. It has many more formatting options than the default formatter used by the RB. To change the RB to use this formatter, execute "RBProgramNode formatterClass: RBConfigurableFormatter". For some refactorings the RB must reformat the code after the change, so it is good to have a formatter configured to your tastes.

Instance Variables:
	codeStream	<PositionableStream>	the stream we are writing our output to
	indent	<Integer>	how many times are we indenting a new line -- indents are normally tabs but could be any whitespace string
	lineStart	<Integer>	the position of the character that started the current line. This is used for calculating the line length.
	lookaheadCode	<Dictionary key: RBProgramNode value: String>	sometimes we need to lookahead while formatting, this dictionary contains the nodes that have already been formatted by lookahead
	originalSource	<String>	the original source before we started formatting. This is used to extract the comments from the original source.

';
		immediateInvariant.
true.
%

removeallmethods RBConfigurableFormatter
removeallclassmethods RBConfigurableFormatter

doit
(RBProgramNodeVisitor
	subclass: 'RBFormatter'
	instVarNames: #( codeStream lineStart firstLineLength tabs inQueryBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBFormatter formats a parse tree. It is an example of a Visitor. This is rarely called directly. Sending ''formattedCode'' to a parse tree uses this algorithm to return a pretty-printed version.

Instance Variables:
	codeStream	<PositionableStream>	The buffer where the output is accumulated.
	firstLineLength	<Integer>	The length of the first line of a message send.
	lineStart	<Integer>	The position of the current line''s start.
	tabs	<Integer>	The number of tabs currently indented.

';
		immediateInvariant.
true.
%

removeallmethods RBFormatter
removeallclassmethods RBFormatter

doit
(RBProgramNodeVisitor
	subclass: 'RBParseTreeSearcher'
	instVarNames: #( searches answer argumentSearches context messages )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'ParseTreeSearcher walks over a normal source code parse tree using the visitor pattern, and then matches these nodes against the meta-nodes using the match:inContext: methods defined for the meta-nodes.

Instance Variables:
	answer	<Object>	the "answer" that is propagated between matches
	argumentSearches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	argument searches (search for the BRProgramNode and perform the BlockClosure when its found)
	context	<RBSmallDictionary>	a dictionary that contains what each meta-node matches against. This could be a normal Dictionary that is created for each search, but is created once and reused (efficiency).
	messages	<Collection>	the sent messages in our searches
	searches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	non-argument searches (search for the BRProgramNode and perform the BlockClosure when its found)';
		immediateInvariant.
true.
%

removeallmethods RBParseTreeSearcher
removeallclassmethods RBParseTreeSearcher

doit
(RBParseTreeSearcher
	subclass: 'RBParseTreeRewriter'
	instVarNames: #( tree )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then answer is set to true, and the modified tree can be retrieved by the #tree method.

Instance Variables:
	tree	<RBProgramNode>	the parse tree we''re transforming';
		immediateInvariant.
true.
%

removeallmethods RBParseTreeRewriter
removeallclassmethods RBParseTreeRewriter

doit
(RBProgramNodeVisitor
	subclass: 'RBReadBeforeWrittenTester'
	instVarNames: #( read checkNewTemps scopeStack )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBReadBeforeWrittenTester is a visitor that identifies variables that may have been read before they are initialized.

Instance Variables:
	checkNewTemps	<Boolean>	description of checkNewTemps
	read	<Collection>	description of read
	scopeStack	<OrderedCollection>	description of scopeStack

';
		immediateInvariant.
true.
%

removeallmethods RBReadBeforeWrittenTester
removeallclassmethods RBReadBeforeWrittenTester

doit
(Object
	subclass: 'RBScanner'
	instVarNames: #( stream buffer tokenStart currentCharacter characterType classificationTable comments errorBlock )
	classVars: #( PatternVariableCharacter )
	classInstVars: #( classificationTable )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBScanner is a stream that returns a sequence of token from the string that it is created on. The tokens know where they came from in the source code and which comments were attached to them.

Instance Variables:
	buffer	<PositionableStream>	Accumulates the text for the current token.
	characterType	<ByteSymbol>	The type of the next character. (e.g. #alphabetic, etc.)
	classificationTable	<Array of: Symbol>	Mapping from Character values to their characterType.
	comments	<Collection of: Interval>	Source intervals of scanned comments that must be attached to the next token.
	currentCharacter	<Character>	The character currently being processed.
	errorBlock	<BlockClosure>	The block to execute on lexical errors.
	extendedLiterals	<Boolean>	True if IBM-type literals are allowed. In VW, this is false.
	nameSpaceCharacter	<Character>	The character used to separate namespaces.
	numberType	<ByteSymbol>	The method to perform: to scan a number. 
	separatorsInLiterals	<Boolean>	True if separators are allowed within literals.
	stream	<PositionableStream>	Contains the text to be scanned.
	tokenStart	<Integer>	The source position of the beginning of the current token

Class Instance Variables:
	classificationTable	<Array>		the default classification table for all characters

Shared Variables:
	PatternVariableCharacter	<Character>	the character that starts a pattern node';
		immediateInvariant.
true.
%

removeallmethods RBScanner
removeallclassmethods RBScanner

doit
(RBScanner
	subclass: 'RBPatternScanner'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBPatternScanner is a subclass of RBScanner that allows the extended syntax of pattern matching trees.
';
		immediateInvariant.
true.
%

removeallmethods RBPatternScanner
removeallclassmethods RBPatternScanner

doit
(RBScanner
	subclass: 'RBTonelScanner'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		immediateInvariant.
true.
%

removeallmethods RBTonelScanner
removeallclassmethods RBTonelScanner

doit
(Object
	subclass: 'RBSmallDictionary'
	instVarNames: #( keys values tally )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBSmallDictionary is a special dictionary optimized for small collections. In addition to the normal dictionary protocol, it also supports an #empty message which "empties" the collection but may hang on to the original elements (so it could collect garbage). Without #empty we would either need to create a new dictionary or explicitly remove everything from the dictionary. Both of these take more time and #empty.

Instance Variables:
array <Array of: Object> array of keys (we don''t use Associations for our key value pairs)
tally <Integer> the size of the dictionary
values <Array of: Object> array of our values
';
		immediateInvariant.
true.
%

removeallmethods RBSmallDictionary
removeallclassmethods RBSmallDictionary

doit
(Object
	subclass: 'RBStringReplacement'
	instVarNames: #( startPosition stopPosition string )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBStringReplacement represents replacing source in the original method with a different string. These are used when reformatting code after a parse tree change has been made. Depending on the change, it may be possible to minimally change the parse tree without needing to format it.

Instance Variables:
	startPosition	<Integer>	the start position in the original source
	stopPosition	<Integer>	the end position in the original source
	string	<String>	replaces everything from the startPosition to the endPosition with this string

';
		immediateInvariant.
true.
%

removeallmethods RBStringReplacement
removeallclassmethods RBStringReplacement

doit
(Object
	subclass: 'RBToken'
	instVarNames: #( sourcePointer comments )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBToken is the abstract superclass of all of the RB tokens. These tokens (unlike the standard parser''s) remember where they came from in the original source code.

Subclasses must implement the following messages:
	accessing
		length

Instance Variables:
	sourcePointer	<Integer>	The position in the original source code where this token began.
';
		immediateInvariant.
true.
%

removeallmethods RBToken
removeallclassmethods RBToken

doit
(RBToken
	subclass: 'RBAssignmentToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBAssignmentToken is the first-class representation of the assignment token '':=''
';
		immediateInvariant.
true.
%

removeallmethods RBAssignmentToken
removeallclassmethods RBAssignmentToken

doit
(RBAssignmentToken
	subclass: 'RBShortAssignmentToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		immediateInvariant.
true.
%

removeallmethods RBShortAssignmentToken
removeallclassmethods RBShortAssignmentToken

doit
(RBToken
	subclass: 'RBValueToken'
	instVarNames: #( value )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBValueToken is the abstract superclass of all tokens that have additional information attached. For example, the BinarySelector token holds onto the actual character (e.g. $+).

Instance Variables:
	value	<String>	The value of this token

';
		immediateInvariant.
true.
%

removeallmethods RBValueToken
removeallclassmethods RBValueToken

doit
(RBValueToken
	subclass: 'RBBinarySelectorToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBBinarySelectorToken is the first-class representation of a binary selector (e.g. +)
';
		immediateInvariant.
true.
%

removeallmethods RBBinarySelectorToken
removeallclassmethods RBBinarySelectorToken

doit
(RBValueToken
	subclass: 'RBIdentifierToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBIdentifierToken is the first class representation of an identifier token (e.g. Class)
';
		immediateInvariant.
true.
%

removeallmethods RBIdentifierToken
removeallclassmethods RBIdentifierToken

doit
(RBIdentifierToken
	subclass: 'RBPathToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		immediateInvariant.
true.
%

removeallmethods RBPathToken
removeallclassmethods RBPathToken

doit
(RBValueToken
	subclass: 'RBKeywordToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBKeywordToken is the first-class representation of a keyword token (e.g. add:)';
		immediateInvariant.
true.
%

removeallmethods RBKeywordToken
removeallclassmethods RBKeywordToken

doit
(RBValueToken
	subclass: 'RBLiteralArrayToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		immediateInvariant.
true.
%

removeallmethods RBLiteralArrayToken
removeallclassmethods RBLiteralArrayToken

doit
(RBValueToken
	subclass: 'RBLiteralToken'
	instVarNames: #( stopPosition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBLiteralToken is the first-class representation of a literal token (entire literals, even literal arrays, are a single token in the ST80 grammar.).

Instance Variables:
	stopPosition	<Integer>	The position within the source code where the token terminates.

';
		immediateInvariant.
true.
%

removeallmethods RBLiteralToken
removeallclassmethods RBLiteralToken

doit
(RBLiteralToken
	subclass: 'RBMultiKeywordLiteralToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		immediateInvariant.
true.
%

removeallmethods RBMultiKeywordLiteralToken
removeallclassmethods RBMultiKeywordLiteralToken

doit
(RBLiteralToken
	subclass: 'RBNumberLiteralToken'
	instVarNames: #( source )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		immediateInvariant.
true.
%

removeallmethods RBNumberLiteralToken
removeallclassmethods RBNumberLiteralToken

doit
(RBValueToken
	subclass: 'RBPatternBlockToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBPatternBlockToken is the first-class representation of the pattern block token.

';
		immediateInvariant.
true.
%

removeallmethods RBPatternBlockToken
removeallclassmethods RBPatternBlockToken

doit
(RBValueToken
	subclass: 'RBSpecialCharacterToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core';
		comment: 'RBSpecialCharacterToken is the first class representation of special characters.

';
		immediateInvariant.
true.
%

removeallmethods RBSpecialCharacterToken
removeallclassmethods RBSpecialCharacterToken

doit
(Object
	subclass: 'Rowan'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #( configuration )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Kernel';
		comment: 'No class-specific documentation for Cypress, hierarchy is: 
Object
  Cypress
';
		immediateInvariant.
true.
%

removeallmethods Rowan
removeallclassmethods Rowan

doit
(Object
	subclass: 'RowanCommandResult'
	instVarNames: #( executionTime )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'Simple object with the results of the Jadeite command.';
		immediateInvariant.
true.
%

removeallmethods RowanCommandResult
removeallclassmethods RowanCommandResult

doit
(Object
	subclass: 'RowanGsGeneralDependencySorter'
	instVarNames: #( candidates dependsOnConverter dependentConverter individualDependencyMap dependencyGraphs candidateAliasMap )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		comment: 'Copied from CypressGsGeneralDependencySorter';
		immediateInvariant.
true.
%

removeallmethods RowanGsGeneralDependencySorter
removeallclassmethods RowanGsGeneralDependencySorter

doit
(Object
	subclass: 'RowanInterface'
	instVarNames: #( name )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RowanInterface
removeallclassmethods RowanInterface

doit
(RowanInterface
	subclass: 'RwAbstractProject'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwAbstractProject
removeallclassmethods RwAbstractProject

doit
(RwAbstractProject
	subclass: 'RwAbstractUnloadedProject'
	instVarNames: #( resolvedProject )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwAbstractUnloadedProject
removeallclassmethods RwAbstractUnloadedProject

doit
(RwAbstractUnloadedProject
	subclass: 'RwDefinedProject'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwDefinedProject
removeallclassmethods RwDefinedProject

doit
(RwAbstractUnloadedProject
	subclass: 'RwResolvedProject'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwResolvedProject
removeallclassmethods RwResolvedProject

doit
(RwAbstractProject
	subclass: 'RwProject'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwProject
removeallclassmethods RwProject

doit
(RowanInterface
	subclass: 'RwPackage'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwPackage
removeallclassmethods RwPackage

doit
(Object
	subclass: 'RowanService'
	instVarNames: #( definition updates command commandArgs updateType organizer )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'Rowan Service is the abstract service class for classes that represent
first class entities in Rowan. They are transported to the client via 
ston. 

On the client, set the command & commandArgs inst vars, then tell
the browser to #issueCommand: with an array of services. A service
received without the the command inst var set will send #update to
the service. #issueCommand: should call JadeServer>>updateFromSton:
which will run the command and return a result. 

Any service that sends updates back to the client willl propogates to 
registered windows. Add a service for return to the client with:
RowanCommandResult addResult: <self>';
		immediateInvariant.
true.
%

removeallmethods RowanService
removeallclassmethods RowanService

doit
(RowanService
	subclass: 'RowanAnsweringService'
	instVarNames: #( answer )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'A place to put miscellaneous commands that don''t fit 
well in other services. 

Also good asking the server questions as it gives back 
an answer whereas other services simply return updated
services.';
		immediateInvariant.
true.
%

removeallmethods RowanAnsweringService
removeallclassmethods RowanAnsweringService

doit
(RowanService
	subclass: 'RowanAutoCommitService'
	instVarNames: #( autoCommit )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'Simple service that provides updates to the client related to auto commit.';
		immediateInvariant.
true.
%

removeallmethods RowanAutoCommitService
removeallclassmethods RowanAutoCommitService

doit
(RowanService
	subclass: 'RowanBrowserService'
	instVarNames: #( projects removedMethods allClasses hierarchyServices testPackages testCount dictionaries selectedClass newCachedSelectors newCachedClasses )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'RowanBrowserService handles services that fall outside
the scope of other services.';
		immediateInvariant.
true.
%

removeallmethods RowanBrowserService
removeallclassmethods RowanBrowserService

doit
(RowanService
	subclass: 'RowanClassService'
	instVarNames: #( name comment instVarNames classVarNames classInstVarNames superclassName subclassType poolDictionaryNames classType meta isExtension version versions oop template filters filterType methods selectedPackageServices packageName definedPackageName selectedMethods projectName hierarchyServices variables categories isTestCase expand visibleTests isNewClass updateAfterCommand isInSymbolList dictionaryName wasRemoved renamedName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'Most class operations done here. 

selectedMethods - client side selection. Used after a method compile.';
		immediateInvariant.
true.
%

removeallmethods RowanClassService
removeallclassmethods RowanClassService

doit
(RowanService
	subclass: 'RowanDebuggerService'
	instVarNames: #( initialProcessOop processes )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanDebuggerService
removeallclassmethods RowanDebuggerService

doit
(RowanService
	subclass: 'RowanDictionaryService'
	instVarNames: #( name classes hierarchyServices globals defaultTemplate )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanDictionaryService
removeallclassmethods RowanDictionaryService

doit
(RowanService
	subclass: 'RowanFrameService'
	instVarNames: #( label method stepPoint vars oop homeMethodSelector homeMethodClassName classIsResolvable )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanFrameService
removeallclassmethods RowanFrameService

doit
(RowanService
	subclass: 'RowanInspectorService'
	instVarNames: #( oop objects myself className indexedSize visibleIndices nextIndices maxIndexedVars compileErrorArray isOop instVarNames instVarsAreRemovable isDictionary isVariable selectionOop isUnordered statusText )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanInspectorService
removeallclassmethods RowanInspectorService

doit
(RowanService
	subclass: 'RowanLoggingService'
	instVarNames: #( fileName id groupId date time comment services mode location isLogging )
	classVars: #( Current )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanLoggingService
removeallclassmethods RowanLoggingService

doit
(RowanService
	subclass: 'RowanMethodService'
	instVarNames: #( oop source selector methodDefinitions classService category packageName projectName className meta hasSupers hasSubs compilationWarnings isExtension inSelectedPackage references stepPoints selectedPackageServices superDisplayString accessedInstVars breakPoints testResult definedPackage isTestMethod testRunClassName failedCompile comparisonSource firstReference renamedName isMethodForBlock homeMethodOop hasMethodHistory searchString definedClassName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanMethodService
removeallclassmethods RowanMethodService

doit
(RowanService
	subclass: 'RowanPackageService'
	instVarNames: #( projectDefinition packageName name isDirty classes defaultTemplate projectName testClasses hierarchyServices selectedClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanPackageService
removeallclassmethods RowanPackageService

doit
(RowanService
	subclass: 'RowanProcessService'
	instVarNames: #( frames oop status )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanProcessService
removeallclassmethods RowanProcessService

doit
(RowanService
	subclass: 'RowanProjectService'
	instVarNames: #( rwProject name sha branch isSkew isDirty packages changes existsOnDisk isLoaded projectUrl rowanProjectsHome isDiskDirty )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanProjectService
removeallclassmethods RowanProjectService

doit
(RowanService
	subclass: 'RowanQueryService'
	instVarNames: #( queryResults )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanQueryService
removeallclassmethods RowanQueryService

doit
(RowanService
	subclass: 'RowanTestService'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanTestService
removeallclassmethods RowanTestService

doit
(RowanService
	subclass: 'RowanVariableService'
	instVarNames: #( oop key value className )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanClientServices
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanVariableService
removeallclassmethods RowanVariableService

doit
(Object
	subclass: 'RwAbstractConfigurationPlatformAttributeMatcher'
	instVarNames: #( pattern patternMatchBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Core-Conditional-Support';
		immediateInvariant.
true.
%

removeallmethods RwAbstractConfigurationPlatformAttributeMatcher
removeallclassmethods RwAbstractConfigurationPlatformAttributeMatcher

doit
(RwAbstractConfigurationPlatformAttributeMatcher
	subclass: 'RwGemStoneVersionConfigurationPlatformAttributeMatcher'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Core-Conditional-Support';
		immediateInvariant.
true.
%

removeallmethods RwGemStoneVersionConfigurationPlatformAttributeMatcher
removeallclassmethods RwGemStoneVersionConfigurationPlatformAttributeMatcher

doit
(RwGemStoneVersionConfigurationPlatformAttributeMatcher
	subclass: 'RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher'
	instVarNames: #( pattern2 )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Core-Conditional-Support';
		immediateInvariant.
true.
%

removeallmethods RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
removeallclassmethods RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher

doit
(RwAbstractConfigurationPlatformAttributeMatcher
	subclass: 'RwStringConfigurationPlatformAttributeMatcher'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Core-Conditional-Support';
		immediateInvariant.
true.
%

removeallmethods RwStringConfigurationPlatformAttributeMatcher
removeallclassmethods RwStringConfigurationPlatformAttributeMatcher

doit
(Object
	subclass: 'RwAbstractProjectComponentVisitorV2'
	instVarNames: #( projectLoadSpecs readComponents readProjects visitedComponents visitedComponentNames platformConditionalAttributes definedGroupNames projectNames groupNames componentNames )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-ComponentsV2';
		immediateInvariant.
true.
%

removeallmethods RwAbstractProjectComponentVisitorV2
removeallclassmethods RwAbstractProjectComponentVisitorV2

doit
(RwAbstractProjectComponentVisitorV2
	subclass: 'RwResolvedProjectComponentVisitorV2'
	instVarNames: #( resolvedProject )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-ComponentsV2';
		immediateInvariant.
true.
%

removeallmethods RwResolvedProjectComponentVisitorV2
removeallclassmethods RwResolvedProjectComponentVisitorV2

doit
(Object
	subclass: 'RwAbstractProjectSetModificationVisitor'
	instVarNames: #( currentProjectDefinition currentPackageDefinition currentClassDefinition currentClassExtension )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwAbstractProjectSetModificationVisitor
removeallclassmethods RwAbstractProjectSetModificationVisitor

doit
(Object
	subclass: 'RwAbstractReaderWriterVisitor'
	instVarNames: #( currentProjectDefinition packageConvention currentPackageDefinition currentClassDefinition currentClassExtension )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwAbstractReaderWriterVisitor
removeallclassmethods RwAbstractReaderWriterVisitor

doit
(RwAbstractReaderWriterVisitor
	subclass: 'RwModificationWriterVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Abstract class with support for walking a modification tree and writing out the source code in a variety of formats:
	topaz fileout
	Tonel
	Filetree';
		immediateInvariant.
true.
%

removeallmethods RwModificationWriterVisitor
removeallclassmethods RwModificationWriterVisitor

doit
(RwModificationWriterVisitor
	subclass: 'RwGsModificationTopazWriterVisitorV2'
	instVarNames: #( topazFilenameComponentMap topazFilename topazFileHeader topazFileFooter excludeClassInitializers excludeRemoveAllMethods fileNamesInFileInOrder logCreation filenameExtension classSymbolDictionaryNames classDefinitions classExtensions bufferedStream topazFilenamePackageNamesMap classDefPackageNameMap classExtPackageNameMap classInitializationDefinitions buildPackageNamesMap repositoryRootPath )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-CoreV2';
		comment: 'No class-specific documentation for RwGsModificationTopazWriterVisitorV2, hierarchy is:
Object
  RwAbstractReaderWriterVisitor( currentProjectDefinition packageConvention currentPackageDefinition currentClassDefinition currentClassExtension)
    RwModificationWriterVisitor
      RwGsModificationTopazWriterVisitorV2( topazFilenameComponentMap topazFilename topazFileHeader filenameExtension classSymbolDictionaryNames classDefinitions classExtensions bufferedStream topazFilenamePackageNamesMap classDefPackageNameMap classExtPackageNameMap classInitializationDefinitions buildPackageNamesMap repositoryRootPath)
';
		immediateInvariant.
true.
%

removeallmethods RwGsModificationTopazWriterVisitorV2
removeallclassmethods RwGsModificationTopazWriterVisitorV2

doit
(RwModificationWriterVisitor
	subclass: 'RwModificationCypressFamilyWriterVisitor'
	instVarNames: #( classDefFileNameMap classExtFileNameMap classDefBeforeFileNameMap classExtBeforeFileNameMap packageDefFileNameMap packageDefBeforeFileNameMap )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwModificationCypressFamilyWriterVisitor
removeallclassmethods RwModificationCypressFamilyWriterVisitor

doit
(RwModificationCypressFamilyWriterVisitor
	subclass: 'RwModificationFiletreeWriterVisitor'
	instVarNames: #( instanceFileNameMap classFileNameMap instanceBeforeFileNameMap classBeforeFileNameMap packageExtension separateMethodMetaAndSource noMethodMetaData useCypressPropertiesFile monticelloMetadata )
	classVars: #(  )
	classInstVars: #( specials )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwModificationFiletreeWriterVisitor
removeallclassmethods RwModificationFiletreeWriterVisitor

doit
(RwModificationCypressFamilyWriterVisitor
	subclass: 'RwModificationTonelWriterVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwModificationTonelWriterVisitor
removeallclassmethods RwModificationTonelWriterVisitor

doit
(RwModificationWriterVisitor
	subclass: 'RwModificationCypressFamilyWriterVisitorV2'
	instVarNames: #( classDefFileNameMap classExtFileNameMap classDefBeforeFileNameMap classExtBeforeFileNameMap packageDefFileNameMap packageDefBeforeFileNameMap packagesRoot )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwModificationCypressFamilyWriterVisitorV2
removeallclassmethods RwModificationCypressFamilyWriterVisitorV2

doit
(RwModificationCypressFamilyWriterVisitorV2
	subclass: 'RwModificationFiletreeWriterVisitorV2'
	instVarNames: #( instanceFileNameMap classFileNameMap instanceBeforeFileNameMap classBeforeFileNameMap packageExtension separateMethodMetaAndSource noMethodMetaData useCypressPropertiesFile monticelloMetadata )
	classVars: #(  )
	classInstVars: #( specials )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwModificationFiletreeWriterVisitorV2
removeallclassmethods RwModificationFiletreeWriterVisitorV2

doit
(RwModificationCypressFamilyWriterVisitorV2
	subclass: 'RwModificationTonelWriterVisitorV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwModificationTonelWriterVisitorV2
removeallclassmethods RwModificationTonelWriterVisitorV2

doit
(RwModificationTonelWriterVisitorV2
	subclass: 'RwModificationPharoTonelFormatV1WriterVisitorV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwModificationPharoTonelFormatV1WriterVisitorV2
removeallclassmethods RwModificationPharoTonelFormatV1WriterVisitorV2

doit
(RwAbstractReaderWriterVisitor
	subclass: 'RwRepositoryComponentProjectReaderVisitor'
	instVarNames: #( packageNames packageNamesBlock currentProjectReferenceDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwRepositoryComponentProjectReaderVisitor
removeallclassmethods RwRepositoryComponentProjectReaderVisitor

doit
(RwRepositoryComponentProjectReaderVisitor
	subclass: 'RwRepositoryResolvedProjectFiletreeReaderVisitorV2'
	instVarNames: #( packageExtension )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwRepositoryResolvedProjectFiletreeReaderVisitorV2
removeallclassmethods RwRepositoryResolvedProjectFiletreeReaderVisitorV2

doit
(RwRepositoryComponentProjectReaderVisitor
	subclass: 'RwRepositoryResolvedProjectTonelReaderVisitorV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwRepositoryResolvedProjectTonelReaderVisitorV2
removeallclassmethods RwRepositoryResolvedProjectTonelReaderVisitorV2

doit
(Object
	subclass: 'RwAbstractResolvedObjectV2'
	instVarNames: #( projectRepository loadSpecification projectSpecification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions-Common';
		immediateInvariant.
true.
%

removeallmethods RwAbstractResolvedObjectV2
removeallclassmethods RwAbstractResolvedObjectV2

doit
(RwAbstractResolvedObjectV2
	subclass: 'RwAbstractResolvedProjectV2'
	instVarNames: #( projectDefinition projectStructure )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwAbstractResolvedProjectV2
removeallclassmethods RwAbstractResolvedProjectV2

doit
(RwAbstractResolvedProjectV2
	subclass: 'RwResolvedLoadSpecificationV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwResolvedLoadSpecificationV2
removeallclassmethods RwResolvedLoadSpecificationV2

doit
(RwAbstractResolvedProjectV2
	subclass: 'RwResolvedProjectSpecificationV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwResolvedProjectSpecificationV2
removeallclassmethods RwResolvedProjectSpecificationV2

doit
(RwAbstractResolvedProjectV2
	subclass: 'RwResolvedProjectV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwResolvedProjectV2
removeallclassmethods RwResolvedProjectV2

doit
(RwAbstractResolvedProjectV2
	subclass: 'RwResolvedRepositoryV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwResolvedRepositoryV2
removeallclassmethods RwResolvedRepositoryV2

doit
(Object
	subclass: 'RwAbstractTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		comment: 'Fundamental concepts:

	read			(disk -> def)
	write			(def -> disk)

	install			(def -> image)
	derive			(image -> def)

	load			(disk ->  image)
	commit			(image -> disk)

	project			manages collections of packages
	package			manages collections of definitions
	definitions	manages properties of classes and methods
	repository		manages disk representation of defintions';
		immediateInvariant.
true.
%

removeallmethods RwAbstractTool
removeallclassmethods RwAbstractTool

doit
(RwAbstractTool
	subclass: 'RwClassTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwClassTool
removeallclassmethods RwClassTool

doit
(RwClassTool
	subclass: 'RwClsCommonAuditTool'
	instVarNames: #( theAuditDetails )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwClsCommonAuditTool
removeallclassmethods RwClsCommonAuditTool

doit
(RwClsCommonAuditTool
	subclass: 'RwClsAuditTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		comment: 'This class audits individual classes';
		immediateInvariant.
true.
%

removeallmethods RwClsAuditTool
removeallclassmethods RwClsAuditTool

doit
(RwClsCommonAuditTool
	subclass: 'RwClsExtensionAuditTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwClsExtensionAuditTool
removeallclassmethods RwClsExtensionAuditTool

doit
(RwClassTool
	subclass: 'RwClsDiffTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwClsDiffTool
removeallclassmethods RwClsDiffTool

doit
(RwAbstractTool
	subclass: 'RwGitTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwGitTool
removeallclassmethods RwGitTool

doit
(RwAbstractTool
	subclass: 'RwPackageTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPackageTool
removeallclassmethods RwPackageTool

doit
(RwPackageTool
	subclass: 'RwPkgAdoptTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgAdoptTool
removeallclassmethods RwPkgAdoptTool

doit
(RwPackageTool
	subclass: 'RwPkgCreateTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgCreateTool
removeallclassmethods RwPkgCreateTool

doit
(RwPackageTool
	subclass: 'RwPkgDisownTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgDisownTool
removeallclassmethods RwPkgDisownTool

doit
(RwPackageTool
	subclass: 'RwPkgLoadTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgLoadTool
removeallclassmethods RwPkgLoadTool

doit
(RwPackageTool
	subclass: 'RwPkgRevertTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgRevertTool
removeallclassmethods RwPkgRevertTool

doit
(RwAbstractTool
	subclass: 'RwPkgAuditToolV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-CoreV2';
		immediateInvariant.
true.
%

removeallmethods RwPkgAuditToolV2
removeallclassmethods RwPkgAuditToolV2

doit
(RwAbstractTool
	subclass: 'RwProjectTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwProjectTool
removeallclassmethods RwProjectTool

doit
(RwProjectTool
	subclass: 'RwPrjAdoptTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjAdoptTool
removeallclassmethods RwPrjAdoptTool

doit
(RwProjectTool
	subclass: 'RwPrjAuditTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjAuditTool
removeallclassmethods RwPrjAuditTool

doit
(RwProjectTool
	subclass: 'RwPrjBrowserToolV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-CoreV2';
		immediateInvariant.
true.
%

removeallmethods RwPrjBrowserToolV2
removeallclassmethods RwPrjBrowserToolV2

doit
(RwProjectTool
	subclass: 'RwPrjCloneTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjCloneTool
removeallclassmethods RwPrjCloneTool

doit
(RwProjectTool
	subclass: 'RwPrjCommitTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjCommitTool
removeallclassmethods RwPrjCommitTool

doit
(RwProjectTool
	subclass: 'RwPrjCreateToolV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-CoreV2';
		immediateInvariant.
true.
%

removeallmethods RwPrjCreateToolV2
removeallclassmethods RwPrjCreateToolV2

doit
(RwProjectTool
	subclass: 'RwPrjDeleteTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjDeleteTool
removeallclassmethods RwPrjDeleteTool

doit
(RwProjectTool
	subclass: 'RwPrjDiffTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjDiffTool
removeallclassmethods RwPrjDiffTool

doit
(RwProjectTool
	subclass: 'RwPrjDisownTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjDisownTool
removeallclassmethods RwPrjDisownTool

doit
(RwProjectTool
	subclass: 'RwPrjEditTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjEditTool
removeallclassmethods RwPrjEditTool

doit
(RwProjectTool
	subclass: 'RwPrjLoadToolV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-CoreV2';
		immediateInvariant.
true.
%

removeallmethods RwPrjLoadToolV2
removeallclassmethods RwPrjLoadToolV2

doit
(RwProjectTool
	subclass: 'RwPrjQueryTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjQueryTool
removeallclassmethods RwPrjQueryTool

doit
(RwProjectTool
	subclass: 'RwPrjReadToolV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-CoreV2';
		immediateInvariant.
true.
%

removeallmethods RwPrjReadToolV2
removeallclassmethods RwPrjReadToolV2

doit
(RwProjectTool
	subclass: 'RwPrjReconcileToolV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-CoreV2';
		immediateInvariant.
true.
%

removeallmethods RwPrjReconcileToolV2
removeallclassmethods RwPrjReconcileToolV2

doit
(RwProjectTool
	subclass: 'RwPrjTestTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjTestTool
removeallclassmethods RwPrjTestTool

doit
(RwProjectTool
	subclass: 'RwPrjTraceTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjTraceTool
removeallclassmethods RwPrjTraceTool

doit
(RwProjectTool
	subclass: 'RwPrjWriteToolV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-CoreV2';
		immediateInvariant.
true.
%

removeallmethods RwPrjWriteToolV2
removeallclassmethods RwPrjWriteToolV2

doit
(Object
	subclass: 'RwAuditDetail'
	instVarNames: #( reason message owner )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		comment: 'Audit failure detail for a class. 

Reasons:
	#loadedPackageNotInRegistry
	#loadedPackageInWrongRegistry';
		immediateInvariant.
true.
%

removeallmethods RwAuditDetail
removeallclassmethods RwAuditDetail

doit
(RwAuditDetail
	subclass: 'RwAuditClassDetail'
	instVarNames: #( behavior )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		comment: 'Audit failure detail for a class. 

Reasons:
	#missingGemStoneClassForLoadedClass
	#missingGemStoneClassForLoadedClassExtension
	#emptyLoadedClassExtension
	#missingCompiledMethodsForLoadedClassExtension';
		immediateInvariant.
true.
%

removeallmethods RwAuditClassDetail
removeallclassmethods RwAuditClassDetail

doit
(RwAuditDetail
	subclass: 'RwAuditClassPropertyDetail'
	instVarNames: #( class loadedPropertyValue classPropertyValue )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		comment: 'Audit failure detail for class properties. 

Reasons:
	#differentSuperclass
	#differentClassInstVars
	#differentClassVars
	#differentPoolDictionaries
	#differentComment
	#differentCategory
	#missingSymbolDictionary
	#missingClassInSymbolDictionary';
		immediateInvariant.
true.
%

removeallmethods RwAuditClassPropertyDetail
removeallclassmethods RwAuditClassPropertyDetail

doit
(RwAuditDetail
	subclass: 'RwAuditMethodCategoryDetail'
	instVarNames: #( behavior category )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		comment: 'Audit failure detail for a class. 

Reasons:
	#rowanHybridExtensionCategoryMatchesClassPackage
	#rowanHybridExtensionCategoryFormatError';
		immediateInvariant.
true.
%

removeallmethods RwAuditMethodCategoryDetail
removeallclassmethods RwAuditMethodCategoryDetail

doit
(RwAuditDetail
	subclass: 'RwAuditMethodDetail'
	instVarNames: #( behavior selector loadedMethod method loadedCategory category )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		comment: 'Audit failure detail for method. 

Reasons:
	#missingCompiledMethod
	#missingLoadedMethod
	#differentMethodCategory
	#methodsNotIdentical';
		immediateInvariant.
true.
%

removeallmethods RwAuditMethodDetail
removeallclassmethods RwAuditMethodDetail

doit
(RwAuditDetail
	subclass: 'RwAuditPackageClassSymbolDictionaryDetail'
	instVarNames: #( loadedClass classSymbolDictionaryName packageSymbolDictionaryName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		comment: 'Audit failure detail for a package and class. 

Reasons:
	#differentSymbolDictionaryForClassAndPackage
	#differentSymbolDictionaryForClassExtensionAndPackage';
		immediateInvariant.
true.
%

removeallmethods RwAuditPackageClassSymbolDictionaryDetail
removeallclassmethods RwAuditPackageClassSymbolDictionaryDetail

doit
(Object
	subclass: 'RwBasicProjectLoadComponentV2'
	instVarNames: #( name comment projectName conditionalPackageMapSpecs preloadDoitName postloadDoitName doitDict )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-ComponentsV2';
		immediateInvariant.
true.
%

removeallmethods RwBasicProjectLoadComponentV2
removeallclassmethods RwBasicProjectLoadComponentV2

doit
(RwBasicProjectLoadComponentV2
	subclass: 'RwAbstractSimpleProjectLoadComponentV2'
	instVarNames: #( packageNames condition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-ComponentsV2';
		immediateInvariant.
true.
%

removeallmethods RwAbstractSimpleProjectLoadComponentV2
removeallclassmethods RwAbstractSimpleProjectLoadComponentV2

doit
(RwAbstractSimpleProjectLoadComponentV2
	subclass: 'RwAbstractRowanProjectLoadComponentV2'
	instVarNames: #( componentNames )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-ComponentsV2';
		immediateInvariant.
true.
%

removeallmethods RwAbstractRowanProjectLoadComponentV2
removeallclassmethods RwAbstractRowanProjectLoadComponentV2

doit
(RwAbstractRowanProjectLoadComponentV2
	subclass: 'RwSimpleProjectLoadComponentV2'
	instVarNames: #( projectNames )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-ComponentsV2';
		immediateInvariant.
true.
%

removeallmethods RwSimpleProjectLoadComponentV2
removeallclassmethods RwSimpleProjectLoadComponentV2

doit
(RwSimpleProjectLoadComponentV2
	subclass: 'RwSimpleNestedProjectLoadComponentV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-ComponentsV2';
		immediateInvariant.
true.
%

removeallmethods RwSimpleNestedProjectLoadComponentV2
removeallclassmethods RwSimpleNestedProjectLoadComponentV2

doit
(RwSimpleNestedProjectLoadComponentV2
	subclass: 'RwPlatformNestedProjectLoadComponentV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-ComponentsV2';
		immediateInvariant.
true.
%

removeallmethods RwPlatformNestedProjectLoadComponentV2
removeallclassmethods RwPlatformNestedProjectLoadComponentV2

doit
(Object
	subclass: 'RwClassAdditionOrRemoval'
	instVarNames: #( projectDefinition packageDefinition classKey classesModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypClassAdditionOrRemoval, hierarchy is: 
Object
  CypClassAdditionOrRemoval( packageDefinition classKey classesModification)
';
		immediateInvariant.
true.
%

removeallmethods RwClassAdditionOrRemoval
removeallclassmethods RwClassAdditionOrRemoval

doit
(Object
	subclass: 'RwConfiguration'
	instVarNames: #( packageInfoSource )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Configuration that guides Cypress operation.

Specific parameters:

packageInfoSource
--------------------------
A Symbol indicating where the authoritative repository of information about package membership of classes and methods is.
Acceptable values are platform-specific:

#Cypress -- the information is stored in Cypress-specific objects. Valid on all platforms, but recommended only when all code modifications are done through Cypress or tools that are Cypress-aware

#Category -- Valid for Pharo and GemStone. The category of a class is the name of its package, and a method''s membership in a protocol whose name starts with $* indicates extension methods.

#SymbolDictionary -- Valid for GemStone. The SymbolDictionary in which the class''s name is first found is the name of its package, and a method''s membership in a protocol whose name starts with $* indicates extension methods.

#Store -- Valid for VW. Cypress package membership is Store package membership.';
		immediateInvariant.
true.
%

removeallmethods RwConfiguration
removeallclassmethods RwConfiguration

doit
(Object
	subclass: 'RwDefinition'
	instVarNames: #( properties )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'Abstract.
Defines some "code" entity.
The definition object''s primary responsibility is to hold information.
It holds exactly the same information as the disk representation in some form of Cypress repository.
Other non-definition classes construct and use the information in definitions to read, write, and compare
code.

properties is a dictionary. Keys and values should be strings. These correspond to the properties in a Cypress repository, and are used in various ways, some of them dialect-specific.';
		immediateInvariant.
true.
%

removeallmethods RwDefinition
removeallclassmethods RwDefinition

doit
(RwDefinition
	subclass: 'RwAbstractClassDefinition'
	instVarNames: #( classMethodDefinitions instanceMethodDefinitions )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		immediateInvariant.
true.
%

removeallmethods RwAbstractClassDefinition
removeallclassmethods RwAbstractClassDefinition

doit
(RwAbstractClassDefinition
	subclass: 'RwClassDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'Defines a class.
Properties should include ''name'' and ''super''.
Other typical properties are ''instvars'' ''classinstvars'' ''classvars''.
Methods are their own definitions: classMethodDefinitions instanceMethodDefinitions
';
		immediateInvariant.
true.
%

removeallmethods RwClassDefinition
removeallclassmethods RwClassDefinition

doit
(RwAbstractClassDefinition
	subclass: 'RwClassExtensionDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'Extends an existing class with additional methods.
Properties must include ''name'', the name of the class to be extended, but should not include other things like ''super'' or ''instvars''.
';
		immediateInvariant.
true.
%

removeallmethods RwClassExtensionDefinition
removeallclassmethods RwClassExtensionDefinition

doit
(RwDefinition
	subclass: 'RwAbstractProjectDefinitionV2'
	instVarNames: #( packages components comment )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwAbstractProjectDefinitionV2
removeallclassmethods RwAbstractProjectDefinitionV2

doit
(RwAbstractProjectDefinitionV2
	subclass: 'RwProjectDefinitionV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwProjectDefinitionV2
removeallclassmethods RwProjectDefinitionV2

doit
(RwDefinition
	subclass: 'RwAbstractRepositoryDefinitionV2'
	instVarNames: #( projectsHome repositoryRoot repositoryUrl )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions-Common';
		immediateInvariant.
true.
%

removeallmethods RwAbstractRepositoryDefinitionV2
removeallclassmethods RwAbstractRepositoryDefinitionV2

doit
(RwAbstractRepositoryDefinitionV2
	subclass: 'RwDiskRepositoryDefinitionV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwDiskRepositoryDefinitionV2
removeallclassmethods RwDiskRepositoryDefinitionV2

doit
(RwDiskRepositoryDefinitionV2
	subclass: 'RwGitRepositoryDefinitionV2'
	instVarNames: #( remote remoteUrl committish )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwGitRepositoryDefinitionV2
removeallclassmethods RwGitRepositoryDefinitionV2

doit
(RwDiskRepositoryDefinitionV2
	subclass: 'RwNoRepositoryDefinitionV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwNoRepositoryDefinitionV2
removeallclassmethods RwNoRepositoryDefinitionV2

doit
(RwDiskRepositoryDefinitionV2
	subclass: 'RwReadOnlyDiskRepositoryDefinitionV2'
	instVarNames: #( sesstionTempsKey commitId )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-DefinitionsV2';
		immediateInvariant.
true.
%

removeallmethods RwReadOnlyDiskRepositoryDefinitionV2
removeallclassmethods RwReadOnlyDiskRepositoryDefinitionV2

doit
(RwDefinition
	subclass: 'RwDefinitionSetDefinition'
	instVarNames: #( definitions )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'No class-specific documentation for CypPackageSetDefinition, hierarchy is: 
Object
  CypDefinition( properties)
    CypPackageSetDefinition( packages)
';
		immediateInvariant.
true.
%

removeallmethods RwDefinitionSetDefinition
removeallclassmethods RwDefinitionSetDefinition

doit
(RwDefinitionSetDefinition
	subclass: 'RwPackageSetDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'No class-specific documentation for CypPackageSetDefinition, hierarchy is: 
Object
  CypDefinition( properties)
    CypPackageSetDefinition( packages)
';
		immediateInvariant.
true.
%

removeallmethods RwPackageSetDefinition
removeallclassmethods RwPackageSetDefinition

doit
(RwDefinitionSetDefinition
	subclass: 'RwProjectSetDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'No class-specific documentation for CypPackageSetDefinition, hierarchy is: 
Object
  CypDefinition( properties)
    CypPackageSetDefinition( packages)
';
		immediateInvariant.
true.
%

removeallmethods RwProjectSetDefinition
removeallclassmethods RwProjectSetDefinition

doit
(RwDefinition
	subclass: 'RwMethodDefinition'
	instVarNames: #( source )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		immediateInvariant.
true.
%

removeallmethods RwMethodDefinition
removeallclassmethods RwMethodDefinition

doit
(RwDefinition
	subclass: 'RwPackageDefinition'
	instVarNames: #( classDefinitions classExtensions )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'Defines a package, which is a bunch of class definitions and class extensions.
Properties include ''name''.
Sub-definitions are classDefinitions and classExtensions
';
		immediateInvariant.
true.
%

removeallmethods RwPackageDefinition
removeallclassmethods RwPackageDefinition

doit
(Object
	subclass: 'RwElementsModification'
	instVarNames: #( elementsModified )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Abstract. Represents a modification to the elements of some code entity. "Modification" means that the code entity exists both before and after, but has differences in some of its elements.

Instvars:

elementsAdded		Dictionary elementKey -> element
elementsRemoved	Dictonary elementKey -> element
elementsModified	Dictionary elementKey -> CypModification  (key may have changed -- if so the key here is the old key)';
		immediateInvariant.
true.
%

removeallmethods RwElementsModification
removeallclassmethods RwElementsModification

doit
(RwElementsModification
	subclass: 'RwClassesModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the classes or classExtensions of a package. The elements are classes. Key is class name.';
		immediateInvariant.
true.
%

removeallmethods RwClassesModification
removeallclassmethods RwClassesModification

doit
(RwElementsModification
	subclass: 'RwClassExtensionsModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypClassExtensionsModification, hierarchy is: 
Object
  CypElementsModification( elementsAdded elementsRemoved elementsModified)
    CypClassExtensionsModification
';
		immediateInvariant.
true.
%

removeallmethods RwClassExtensionsModification
removeallclassmethods RwClassExtensionsModification

doit
(RwElementsModification
	subclass: 'RwEntitySetModification'
	instVarNames: #( movedClasses movedMethods movedPackages )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwEntitySetModification
removeallclassmethods RwEntitySetModification

doit
(RwEntitySetModification
	subclass: 'RwPackageSetModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between two PackageSets. The elements are packages. Key is package name.
movedClasses are classes that have moved from one package to another within the package set.
movedMethods are methods that have moved from a class definition to an extension of that class, or vice versa, or between two extensions of the same class.';
		immediateInvariant.
true.
%

removeallmethods RwPackageSetModification
removeallclassmethods RwPackageSetModification

doit
(RwEntitySetModification
	subclass: 'RwProjectSetModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between two PackageSets. The elements are packages. Key is package name.
movedClasses are classes that have moved from one package to another within the package set.
movedMethods are methods that have moved from a class definition to an extension of that class, or vice versa, or between two extensions of the same class.';
		immediateInvariant.
true.
%

removeallmethods RwProjectSetModification
removeallclassmethods RwProjectSetModification

doit
(RwElementsModification
	subclass: 'RwMethodsModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the instance or class methods defined by a class or class extension. The elements are method definitions. Key is selector (as string).';
		immediateInvariant.
true.
%

removeallmethods RwMethodsModification
removeallclassmethods RwMethodsModification

doit
(RwMethodsModification
	subclass: 'RwExtensionMethodsModification'
	instVarNames: #( extendedClassName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExtensionMethodsModification
removeallclassmethods RwExtensionMethodsModification

doit
(RwElementsModification
	subclass: 'RwPackagesModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the classes or classExtensions of a package. The elements are classes. Key is class name.';
		immediateInvariant.
true.
%

removeallmethods RwPackagesModification
removeallclassmethods RwPackagesModification

doit
(RwElementsModification
	subclass: 'RwPropertiesModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the properties of a single entity. The elements are associations of propertyName -> propertyValue. Key is property name.';
		immediateInvariant.
true.
%

removeallmethods RwPropertiesModification
removeallclassmethods RwPropertiesModification

doit
(RwElementsModification
	subclass: 'RwSourceModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'DELETE ME';
		immediateInvariant.
true.
%

removeallmethods RwSourceModification
removeallclassmethods RwSourceModification

doit
(Object
	subclass: 'RwEntitySet'
	instVarNames: #( entities )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'Holds some number of RwDefinitions or RwLoadedThingss to be operated on together. The entities put into the receiver should be at the same semantic level: all methods, class, packages , or projects.

When the receiver is sent #asDefinition, the receiver is converted to a RwDefinitionSetDefinition and all entities are converted to their definition counterparts.';
		immediateInvariant.
true.
%

removeallmethods RwEntitySet
removeallclassmethods RwEntitySet

doit
(Object
	subclass: 'RwGsImage'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		comment: 'Keeps track of what LoadedPackages are in the GemStone repository, and is the gateway for operations to query or change the image.';
		immediateInvariant.
true.
%

removeallmethods RwGsImage
removeallclassmethods RwGsImage

doit
(Object
	subclass: 'RwGsImagePatchVisitor_V2'
	instVarNames: #( patchSet currentProject currentPackage currentClass currentMethod )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		comment: 'Walks a diff tree and adds patches to a patchSet that will update the GemStone image (repository) to the code state represented by the ''after'' state of the diff, provided that the ''before'' state of the diff is the current state of the image.';
		immediateInvariant.
true.
%

removeallmethods RwGsImagePatchVisitor_V2
removeallclassmethods RwGsImagePatchVisitor_V2

doit
(Object
	subclass: 'RwGsInstanceMigrator'
	instVarNames: #( migrationEnabled maxThreads maxCpuPercentage )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsInstanceMigrator
removeallclassmethods RwGsInstanceMigrator

doit
(RwGsInstanceMigrator
	subclass: 'RwGsDeferredInstanceMigrator'
	instVarNames: #( classesToMigrate )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsDeferredInstanceMigrator
removeallclassmethods RwGsDeferredInstanceMigrator

doit
(Object
	subclass: 'RwGsPatchSet_V2'
	instVarNames: #( instanceMigrator addedProjects addedPackages deletedPackages movedPackages projectsWithPropertyChanges addedClasses deletedClasses movedClasses extendedClasses classesWithPropertyChanges classesWithSymbolDictionaryChanges classesWithClassVariableChanges classesWithConstraintChanges classesWithNewVersions addedMethods deletedMethods deleteNewVersionMethods movedMethods extendedMethods methodsWithPropertyChanges methodsNeedingRecompile tempSymbols createdClasses errors currentProjectDefinition movedClassesSymbolList addedUnmanagedClasses loadSymbolList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		comment: 'A set of patches (changes) to be applied atomically (or as close to atomically as possible) to a GemStone repository.';
		immediateInvariant.
true.
%

removeallmethods RwGsPatchSet_V2
removeallclassmethods RwGsPatchSet_V2

doit
(Object
	subclass: 'RwGsPatchV2'
	instVarNames: #( packageDefinition projectDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsPatchV2
removeallclassmethods RwGsPatchV2

doit
(RwGsPatchV2
	subclass: 'RwGsClassPatchV2'
	instVarNames: #( classDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassPatchV2
removeallclassmethods RwGsClassPatchV2

doit
(RwGsClassPatchV2
	subclass: 'RwGsClassAdditionSymbolDictPatchV2'
	instVarNames: #( newClass symbolAssociation )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassAdditionSymbolDictPatchV2
removeallclassmethods RwGsClassAdditionSymbolDictPatchV2

doit
(RwGsClassAdditionSymbolDictPatchV2
	subclass: 'RwGsClassUnmanagedAdditionSymbolDictPatchV2'
	instVarNames: #( oldClassVersion )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassUnmanagedAdditionSymbolDictPatchV2
removeallclassmethods RwGsClassUnmanagedAdditionSymbolDictPatchV2

doit
(RwGsClassPatchV2
	subclass: 'RwGsClassConstraintsSymDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassConstraintsSymDictPatchV2
removeallclassmethods RwGsClassConstraintsSymDictPatchV2

doit
(RwGsClassPatchV2
	subclass: 'RwGsClassDeletionSymbolDictPatchV2'
	instVarNames: #( existingClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassDeletionSymbolDictPatchV2
removeallclassmethods RwGsClassDeletionSymbolDictPatchV2

doit
(RwGsClassPatchV2
	subclass: 'RwGsClassExtensionSymbolDictPatchV2'
	instVarNames: #( patchClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassExtensionSymbolDictPatchV2
removeallclassmethods RwGsClassExtensionSymbolDictPatchV2

doit
(RwGsClassPatchV2
	subclass: 'RwGsClassPropertiesSymDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassPropertiesSymDictPatchV2
removeallclassmethods RwGsClassPropertiesSymDictPatchV2

doit
(RwGsClassPatchV2
	subclass: 'RwGsClassSymbolDictionaryMoveSymDictPatchV2'
	instVarNames: #( classModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassSymbolDictionaryMoveSymDictPatchV2
removeallclassmethods RwGsClassSymbolDictionaryMoveSymDictPatchV2

doit
(RwGsClassPatchV2
	subclass: 'RwGsClassVariableChangeSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassVariableChangeSymbolDictPatchV2
removeallclassmethods RwGsClassVariableChangeSymbolDictPatchV2

doit
(RwGsClassPatchV2
	subclass: 'RwGsClassVersioningPatchV2'
	instVarNames: #( classModification oldClassVersion newClassVersion symbolAssociation )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassVersioningPatchV2
removeallclassmethods RwGsClassVersioningPatchV2

doit
(RwGsClassPatchV2
	subclass: 'RwGsClassVersioningSymbolDictPatchV2'
	instVarNames: #( classModification oldClassVersion newClassVersion symbolAssociation )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassVersioningSymbolDictPatchV2
removeallclassmethods RwGsClassVersioningSymbolDictPatchV2

doit
(RwGsClassVersioningSymbolDictPatchV2
	subclass: 'RwGsClassUnmanagedVersioningSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsClassUnmanagedVersioningSymbolDictPatchV2
removeallclassmethods RwGsClassUnmanagedVersioningSymbolDictPatchV2

doit
(RwGsPatchV2
	subclass: 'RwGsMethodPatchV2'
	instVarNames: #( isMeta methodDefinition classDefinition behavior selector compiledMethod )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodPatchV2
removeallclassmethods RwGsMethodPatchV2

doit
(RwGsMethodPatchV2
	subclass: 'RwGsMethodAdditionSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodAdditionSymbolDictPatchV2
removeallclassmethods RwGsMethodAdditionSymbolDictPatchV2

doit
(RwGsMethodPatchV2
	subclass: 'RwGsMethodDeletionSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodDeletionSymbolDictPatchV2
removeallclassmethods RwGsMethodDeletionSymbolDictPatchV2

doit
(RwGsMethodDeletionSymbolDictPatchV2
	subclass: 'RwGsMethodDeletionExtensionSymbolDictPatchV2'
	instVarNames: #( extendedClassName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodDeletionExtensionSymbolDictPatchV2
removeallclassmethods RwGsMethodDeletionExtensionSymbolDictPatchV2

doit
(RwGsMethodDeletionExtensionSymbolDictPatchV2
	subclass: 'RwGsMethodDeletionExtensionSessionMethodSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodDeletionExtensionSessionMethodSymbolDictPatchV2
removeallclassmethods RwGsMethodDeletionExtensionSessionMethodSymbolDictPatchV2

doit
(RwGsMethodPatchV2
	subclass: 'RwGsMethodExtensionSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodExtensionSymbolDictPatchV2
removeallclassmethods RwGsMethodExtensionSymbolDictPatchV2

doit
(RwGsMethodExtensionSymbolDictPatchV2
	subclass: 'RwGsMethodExtensionSessionMethodSymbolDictPatchV2'
	instVarNames: #( sessionDictsArray methDict catDict pArray )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodExtensionSessionMethodSymbolDictPatchV2
removeallclassmethods RwGsMethodExtensionSessionMethodSymbolDictPatchV2

doit
(RwGsMethodPatchV2
	subclass: 'RwGsMethodPropertiesSymDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodPropertiesSymDictPatchV2
removeallclassmethods RwGsMethodPropertiesSymDictPatchV2

doit
(RwGsMethodPropertiesSymDictPatchV2
	subclass: 'RwGsMethodExtensionSessionMethodPropertiesSymDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodExtensionSessionMethodPropertiesSymDictPatchV2
removeallclassmethods RwGsMethodExtensionSessionMethodPropertiesSymDictPatchV2

doit
(RwGsMethodPatchV2
	subclass: 'RwGsMethodSourceSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodSourceSymbolDictPatchV2
removeallclassmethods RwGsMethodSourceSymbolDictPatchV2

doit
(RwGsMethodSourceSymbolDictPatchV2
	subclass: 'RwGsMethodExtensionSessionMethodSourceSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodExtensionSessionMethodSourceSymbolDictPatchV2
removeallclassmethods RwGsMethodExtensionSessionMethodSourceSymbolDictPatchV2

doit
(RwGsPatchV2
	subclass: 'RwGsPackagePatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsPackagePatchV2
removeallclassmethods RwGsPackagePatchV2

doit
(RwGsPackagePatchV2
	subclass: 'RwGsPackageAdditionSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsPackageAdditionSymbolDictPatchV2
removeallclassmethods RwGsPackageAdditionSymbolDictPatchV2

doit
(RwGsPackagePatchV2
	subclass: 'RwGsPackageDeletionSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsPackageDeletionSymbolDictPatchV2
removeallclassmethods RwGsPackageDeletionSymbolDictPatchV2

doit
(RwGsPackagePatchV2
	subclass: 'RwGsPackageMoveSymbolDictPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsPackageMoveSymbolDictPatchV2
removeallclassmethods RwGsPackageMoveSymbolDictPatchV2

doit
(RwGsPatchV2
	subclass: 'RwGsProjectPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsProjectPatchV2
removeallclassmethods RwGsProjectPatchV2

doit
(RwGsProjectPatchV2
	subclass: 'RwGsProjectAdditionPatchV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsProjectAdditionPatchV2
removeallclassmethods RwGsProjectAdditionPatchV2

doit
(Object
	subclass: 'RwGsSymbolDictionaryRegistryV2'
	instVarNames: #( symbolDictionary packageRegistry methodRegistry )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		immediateInvariant.
true.
%

removeallmethods RwGsSymbolDictionaryRegistryV2
removeallclassmethods RwGsSymbolDictionaryRegistryV2

doit
(Object
	subclass: 'RwGsSymbolDictionaryRegistry_ImplementationV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-LoaderV2';
		comment: 'The Rowan-GemStone-Loader implementation does depend upon having a stable and consistent implementation of the RwGsSymbolDictionaryRegistry behavior for the duration of a load.

Right before a load, all of the classes that make up the Rowan-GemStone-Loader package are copied and isolated from the rest of the system, so that updates to the loader code itself will not change the behavior of the loader implementation while the load is in progress.

The class RwGsSymbolDictionaryRegistry is not part of the Rowan-GemStone-Loader package, because instance of the class are expected to have long lifetimes.

This class implements the behavior for RwGsSymbolDictionaryRegistry and since it is the Rowan-GemStone-Loader package, it can be copied and isolated during a load, without affecting the long lived instances of RwGsSymbolDictionaryRegistry.

The methods in the receiver (class-side only) have an extra `instance:` argument tacked on that refers to the instance of RwGsSymbolDictionaryRegistry that was the original target of the message. For example:

	RwGsSymbolDictionaryRegistry_implementation class>>addClassAssociation:forClass:toPackageNamed:instance:

The methods in RwGsSymbolDictionaryRegistry are implemented with a compiled in reference to the RwGsSymbolDictionaryRegistry_implementation class as follows:

	addClassAssociation: assoc forClass: class toPackageNamed: packageName

		^ RwGsSymbolDictionaryRegistry_implementation addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self

This form is adequate for message sends from classes outside of the Rowan-GemStone-Loader package.

Inside the Rowan-GemStone-Loader package, the messgaes sends must pass in a reference to the `RwGsSymbolDictionaryRegistry_implementation`. This reference will refer to the cloned copy of the class when the RowanLoader symbol dictionary is cloned. The methods have and extra `implementationClass:` that refers to the class and allows the caller to pass in a reference to the cloned class. For example:

	addClassAssociation: assoc forClass: class toPackageNamed: packageName implementationClass: implementationClass

		"Copy the name association to the correct 
			SymbolDictionary in the live SymbolList.
			Create a LoadedClass for the new class, add it to the defining LoadedPackage."

		^ implementationClass addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self';
		immediateInvariant.
true.
%

removeallmethods RwGsSymbolDictionaryRegistry_ImplementationV2
removeallclassmethods RwGsSymbolDictionaryRegistry_ImplementationV2

doit
(Object
	subclass: 'RwLoadedThing'
	instVarNames: #( properties name handle )
	classVars: #( AbsentToken )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'properties: dictionary of properties
name: name of class or package, selector of method
handle: reference to the class or method object, or to the native package object for dialects that have that.';
		immediateInvariant.
true.
%

removeallmethods RwLoadedThing
removeallclassmethods RwLoadedThing

doit
(RwLoadedThing
	subclass: 'RwLoadedClass'
	instVarNames: #( loadedPackage loadedInstanceMethods loadedClassMethods )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'package: the CypLoadedPackage that defines me and all my methods that are not extension methods.
extensions: a collection of CypLoadedExtendedClasses for this class. From these we can tell which methods don''t belong to our default package.';
		immediateInvariant.
true.
%

removeallmethods RwLoadedClass
removeallclassmethods RwLoadedClass

doit
(RwLoadedClass
	subclass: 'RwGsLoadedSymbolDictClass'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsLoadedSymbolDictClass
removeallclassmethods RwGsLoadedSymbolDictClass

doit
(RwLoadedThing
	subclass: 'RwLoadedClassExtension'
	instVarNames: #( loadedPackage loadedInstanceMethods loadedClassMethods )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypLoadedClassExtension, hierarchy is: 
Object
  CypLoadedThing( properties name handle)
    CypLoadedClassExtension( loadedPackage loadedMethods)
';
		immediateInvariant.
true.
%

removeallmethods RwLoadedClassExtension
removeallclassmethods RwLoadedClassExtension

doit
(RwLoadedClassExtension
	subclass: 'RwGsLoadedSymbolDictClassExtension'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsLoadedSymbolDictClassExtension
removeallclassmethods RwGsLoadedSymbolDictClassExtension

doit
(RwLoadedThing
	subclass: 'RwLoadedMethod'
	instVarNames: #( loadedClass classIsMeta )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypLoadedMethod, hierarchy is: 
Object
  CypLoadedThing( properties name handle)
    CypLoadedMethod
';
		immediateInvariant.
true.
%

removeallmethods RwLoadedMethod
removeallclassmethods RwLoadedMethod

doit
(RwLoadedMethod
	subclass: 'RwGsLoadedSymbolDictMethod'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		comment: 'The MethodRegistry maps GsNMethods to LoadedMethods.';
		immediateInvariant.
true.
%

removeallmethods RwGsLoadedSymbolDictMethod
removeallclassmethods RwGsLoadedSymbolDictMethod

doit
(RwLoadedThing
	subclass: 'RwLoadedPackage'
	instVarNames: #( repository commitId loadedClasses loadedClassExtensions isDirty loadedProject )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'repository: The repository I was loaded from (if known, nil otherwise)
commitId: A repository-specific way of identifying source code commit, if it''s a type of repository that has that kind of information (nil otherwise)
loadedClasses: Dictionary -- keys are (non-meta) classes, values are the LoadedClasses that I define.
loadedClassExtensions: -- Dictionary -- keys are (non-meta) classes, values are the LoadedClassExtensions that I define.';
		immediateInvariant.
true.
%

removeallmethods RwLoadedPackage
removeallclassmethods RwLoadedPackage

doit
(RwLoadedPackage
	subclass: 'RwGsLoadedSymbolDictPackage'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsLoadedSymbolDictPackage
removeallclassmethods RwGsLoadedSymbolDictPackage

doit
(RwLoadedThing
	subclass: 'RwLoadedProject'
	instVarNames: #( loadedPackages isDirty )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwLoadedProject
removeallclassmethods RwLoadedProject

doit
(RwLoadedProject
	subclass: 'RwGsLoadedSymbolDictResolvedProjectV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-CoreV2';
		immediateInvariant.
true.
%

removeallmethods RwGsLoadedSymbolDictResolvedProjectV2
removeallclassmethods RwGsLoadedSymbolDictResolvedProjectV2

doit
(Object
	subclass: 'RwMethodAdditionOrRemoval'
	instVarNames: #( projectDefinition packageDefinition classDefinitionOrExtension methodKey isMeta methodsModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypMethodAdditionOrRemoval, hierarchy is: 
Object
  CypMethodAdditionOrRemoval( packageDefinition classDefinitionOrExtension methodKey isMeta methodsModification)
';
		immediateInvariant.
true.
%

removeallmethods RwMethodAdditionOrRemoval
removeallclassmethods RwMethodAdditionOrRemoval

doit
(Object
	subclass: 'RwModification'
	instVarNames: #( propertiesModification before after )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Abstract. Represents a modification to some code entity. "Modification" means that the code entity exists both before and after, but has differences in some of its elements.

Instvars:

before		A definition of the state before the modification
after		A definition of state after the modification';
		immediateInvariant.
true.
%

removeallmethods RwModification
removeallclassmethods RwModification

doit
(RwModification
	subclass: 'RwClassModification'
	instVarNames: #( instanceMethodsModification classMethodsModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single class definition or class extension.

Instvars:

propertiesModification			PropertiesModification -- changes to class or class extension properties
instanceMethodsModification	MethodsModification -- changes to instance methods defined
classMethodsModification		MethodsModification -- changes to class methods defined';
		immediateInvariant.
true.
%

removeallmethods RwClassModification
removeallclassmethods RwClassModification

doit
(RwClassModification
	subclass: 'RwClassExtensionModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwClassExtensionModification
removeallclassmethods RwClassExtensionModification

doit
(RwClassModification
	subclass: 'RwClassModificationForcingNewClassVersion'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwClassModificationForcingNewClassVersion
removeallclassmethods RwClassModificationForcingNewClassVersion

doit
(RwClassModification
	subclass: 'RwClassUnmanagedModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwClassUnmanagedModification
removeallclassmethods RwClassUnmanagedModification

doit
(RwModification
	subclass: 'RwMethodModification'
	instVarNames: #( sourceModification isMeta classDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single method

Instvars:

propertiesModification			PropertiesModification -- changes to method properties
oldSource						String -- source code before
newSource						String -- source code after';
		immediateInvariant.
true.
%

removeallmethods RwMethodModification
removeallclassmethods RwMethodModification

doit
(RwMethodModification
	subclass: 'RwExtensionMethodModification'
	instVarNames: #( extendedClassName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExtensionMethodModification
removeallclassmethods RwExtensionMethodModification

doit
(RwMethodModification
	subclass: 'RwMethodModificationForNewClassVersion'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwMethodModificationForNewClassVersion
removeallclassmethods RwMethodModificationForNewClassVersion

doit
(RwMethodModificationForNewClassVersion
	subclass: 'RwExtensionMethodModificationForNewClassVersion'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExtensionMethodModificationForNewClassVersion
removeallclassmethods RwExtensionMethodModificationForNewClassVersion

doit
(RwModification
	subclass: 'RwPackageModification'
	instVarNames: #( classesModification classExtensionsModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single package.

Instvars:

propertiesModification			PropertiesModification -- changes to package properties
classesModification				ClassesModification -- changes to classes defined
classExtensionsModification		ClassesModificaiton -- changes to classes extended';
		immediateInvariant.
true.
%

removeallmethods RwPackageModification
removeallclassmethods RwPackageModification

doit
(RwModification
	subclass: 'RwProjectModification'
	instVarNames: #( packagesModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single package.

Instvars:

propertiesModification			PropertiesModification -- changes to package properties
classesModification				ClassesModification -- changes to classes defined
classExtensionsModification		ClassesModificaiton -- changes to classes extended';
		immediateInvariant.
true.
%

removeallmethods RwProjectModification
removeallclassmethods RwProjectModification

doit
(Object
	subclass: 'RwMove'
	instVarNames: #( projectBefore projectAfter packageBefore packageAfter )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwMove
removeallclassmethods RwMove

doit
(RwMove
	subclass: 'RwClassExtensionMove'
	instVarNames: #( classExtensionBefore classExtensionAfter )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwClassExtensionMove
removeallclassmethods RwClassExtensionMove

doit
(RwMove
	subclass: 'RwClassMove'
	instVarNames: #( classBefore classAfter )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents the move of a class definition from one package to another.';
		immediateInvariant.
true.
%

removeallmethods RwClassMove
removeallclassmethods RwClassMove

doit
(RwMove
	subclass: 'RwMethodMove'
	instVarNames: #( methodBefore methodAfter isMeta classOrExtensionBefore classOrExtensionAfter )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents a move of a method from a class definition to a class extension, or from a class extension to a class definition, or between two extensions, of the same class. This should always also result in a change of package, since a class should not be defined and extended in the same package, nor extended twice in the same package.';
		immediateInvariant.
true.
%

removeallmethods RwMethodMove
removeallclassmethods RwMethodMove

doit
(RwMove
	subclass: 'RwPackageMove'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwPackageMove
removeallclassmethods RwPackageMove

doit
(Object
	subclass: 'RwPackageAdditionOrRemoval'
	instVarNames: #( projectDefinition packageDefinition packageKey packagesModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwPackageAdditionOrRemoval
removeallclassmethods RwPackageAdditionOrRemoval

doit
(Object
	subclass: 'RwPlatform'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Kernel';
		comment: 'Provides services specific to the Smalltalk dialect being run,
and locates other services that are dialect-specific.';
		immediateInvariant.
true.
%

removeallmethods RwPlatform
removeallclassmethods RwPlatform

doit
(RwPlatform
	subclass: 'RwGsPlatform'
	instVarNames: #( alternateImageClass enableInstanceMigration instanceMigrator )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		comment: 'This class is private to Cypress.
A GsPlatform is the gateway object for requesting platform-specific actions.';
		immediateInvariant.
true.
%

removeallmethods RwGsPlatform
removeallclassmethods RwGsPlatform

doit
(Object
	subclass: 'RwPropertyModification'
	instVarNames: #( key oldValue newValue )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypPropertyModification, hierarchy is: 
Object
  CypDiff( changes)
    CypLeafModification( key before after)
      CypPropertyModification
';
		immediateInvariant.
true.
%

removeallmethods RwPropertyModification
removeallclassmethods RwPropertyModification

doit
(RwPropertyModification
	subclass: 'RwUnconditionalPropertyModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypPropertyModification, hierarchy is: 
Object
  CypDiff( changes)
    CypLeafModification( key before after)
      CypPropertyModification
';
		immediateInvariant.
true.
%

removeallmethods RwUnconditionalPropertyModification
removeallclassmethods RwUnconditionalPropertyModification

doit
(Object
	subclass: 'RwResolvedLoadComponentsV2'
	instVarNames: #( components )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-ComponentsV2';
		immediateInvariant.
true.
%

removeallmethods RwResolvedLoadComponentsV2
removeallclassmethods RwResolvedLoadComponentsV2

doit
(Object
	subclass: 'RwSpecification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwSpecification
removeallclassmethods RwSpecification

doit
(RwSpecification
	subclass: 'RwLoadSpecificationV2'
	instVarNames: #( specName projectName projectAlias gitUrl diskUrl mercurialUrl readonlyDiskUrl relativeRepositoryRoot svnUrl revision projectSpecFile componentNames groupNames customConditionalAttributes platformProperties comment projectsHome repositoryResolutionPolicy )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-SpecificationsV2';
		immediateInvariant.
true.
%

removeallmethods RwLoadSpecificationV2
removeallclassmethods RwLoadSpecificationV2

doit
(RwLoadSpecificationV2
	subclass: 'RwEmbeddedLoadSpecificationV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-SpecificationsV2';
		immediateInvariant.
true.
%

removeallmethods RwEmbeddedLoadSpecificationV2
removeallclassmethods RwEmbeddedLoadSpecificationV2

doit
(RwSpecification
	subclass: 'RwProjectSpecificationV2'
	instVarNames: #( specName projectName projectSpecPath componentsPath packagesPath projectsPath specsPath packageFormat packageConvention comment repoType loadedCommitId )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-SpecificationsV2';
		immediateInvariant.
true.
%

removeallmethods RwProjectSpecificationV2
removeallclassmethods RwProjectSpecificationV2

doit
(Object
	subclass: 'RwUrl'
	instVarNames: #( fragment )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.

The classes in this hierarchy:

RwUrl
 RwFileUrl
  RwCypressUrl
  RwFiletreeUrl
   RwTonelUrl
  RwGithubUrl
 RwGenericUrl
 RwHierarchicalUrl
  RwSmalltalkRepositoryUrl
   RwGitFileTreeUrl

are specificaly designed for parsing URLS for Rowan source code repositories:

 file:/opt/git/shared/repos/rowan/sample/repository
 http://gsdevkit.github.io/GsDevKit_home/rowan/Sample.ston
 https://raw.githubusercontent.com/dalehenrich/sample/master/specs/Sample.ston

 github://GsDevKit/GsDevKit:master/repository
 filetree:///opt/git/shared/repos/rowan/sample/repository
 tonel:/opt/git/shared/repos/rowan/sample/repository
 gitfiletree://gitlab.com/GsDevKit/GsDevKit:master/repository

 cypress:/opt/git/shared/repos/rowan/sample/repository/
 smalltalk://dkh:pass@gitlab.ferlicot.fr:3456/Projet/Bazard:dev/src
 smalltalk://git@git.gemtalksystems.com/btree340:dev/repository
 smalltalk://git@github.com/GsDevKit/GsDevKit:350/repository
 smalltalk://github.com/GsDevKit/GsDevKit:350/repository


The file:, http: and https: schemes should conform to the standard specs. ZnUrl is used for parsing http: and https: urls.

The github:, filetree:, gitfiletree: and tonel: schemes are supported for backward compatibility with schemes that have historically been used to identify Metacello repository urls.

The cypress: and smalltalk: schemes are new and intended to be used moving forward with Metacello and Rowan.

The cypress: url is used to indicate that path to a Cypress-style repository, i.e., a disk-based format for storing Smalltalk packages in filetree or tonel format. A cypress: url does not define the specific repository type (filetree or tonel). The type of the repository is encoded in a .filetree file located in the directory specified by pathString of the url.

The smalltalk: scheme is based on Thierry Goubier''s gitfiletree url[1]. The original github: scheme cannot be used for arbitrary git servers or git servers using non-standard ports or requiring usernames and passwords. Thierry''s scheme handles the full range of possibilites.

[1] https://github.com/dalehenrich/filetree/blob/734eed46ea57ebf5e24e5d935768bd49727fc22f/repository/MonticelloFileTree-Git.package/MCFileTreeGitRepository.class/class/basicFromUrl..st';
		immediateInvariant.
true.
%

removeallmethods RwUrl
removeallclassmethods RwUrl

doit
(RwUrl
	subclass: 'RwFileUrl'
	instVarNames: #( host path isAbsolute )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'This class models a file URL according to (somewhat) RFC1738, see http://www.w3.org/Addressing/rfc1738.txt

Here is the relevant part of the RFC:

3.10 FILES

   The file URL scheme is used to designate files accessible on a
   particular host computer. This scheme, unlike most other URL schemes,
   does not designate a resource that is universally accessible over the
   Internet.

   A file URL takes the form:

       file://<host>/<path>

   where <host> is the fully qualified domain name of the system on
   which the <path> is accessible, and <path> is a hierarchical
   directory path of the form <directory>/<directory>/.../<name>.

   For example, a VMS file

     DISK$USER:[MY.NOTES]NOTE123456.TXT

   might become

     <URL:file://vms.host.edu/disk$user/my/notes/note12345.txt>

   As a special case, <host> can be the string "localhost" or the empty
   string; this is interpreted as `the machine from which the URL is
   being interpreted''.

   The file URL scheme is unusual in that it does not specify an
   Internet protocol or access method for such files; as such, its
   utility in network protocols between hosts is limited.

From the above we can conclude that the RFC says that the <path> part never starts or ends with a slash and is always absolute. If the last name can be a directory instead of a file is not specified clearly.

The path is stored as a SequenceableCollection of path parts.

Notes regarding non RFC features in this class:

- If the last path part is the empty string, then the FileUrl is referring to a directory. This is also shown with a trailing slash when converted to a String.

- The FileUrl has an attribute isAbsolute which signals if the path should be considered absolute or relative to the current directory. This distinction is not visible in the String representation of FileUrl, since the RFC does not have that.

- Fragment is supported (kept for historical reasons)

';
		immediateInvariant.
true.
%

removeallmethods RwFileUrl
removeallclassmethods RwFileUrl

doit
(RwUrl
	subclass: 'RwGenericUrl'
	instVarNames: #( schemeName locator )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'a URL type that can''t be broken down in any systematic way.  For example, mailto: and telnet: URLs.  The part after the scheme name is stored available via the #locator message.';
		immediateInvariant.
true.
%

removeallmethods RwGenericUrl
removeallclassmethods RwGenericUrl

doit
(RwUrl
	subclass: 'RwHierarchicalUrl'
	instVarNames: #( schemeName authority path query port username password )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'A URL which has a hierarchical encoding.  For instance, http and ftp URLs are hierarchical.';
		immediateInvariant.
true.
%

removeallmethods RwHierarchicalUrl
removeallclassmethods RwHierarchicalUrl

doit
(RwHierarchicalUrl
	subclass: 'RwHttpUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		immediateInvariant.
true.
%

removeallmethods RwHttpUrl
removeallclassmethods RwHttpUrl

doit
(RwHttpUrl
	subclass: 'RwHttpsUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		immediateInvariant.
true.
%

removeallmethods RwHttpsUrl
removeallclassmethods RwHttpsUrl

doit
(Object
	subclass: 'ZnBufferedReadStream'
	instVarNames: #( stream buffer position limit )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am ZnBufferedReadStream.

I wrap another ReadStream and add efficient buffering for the typical access pattern of parsers: sending lots of #next, #peek and #atEnd messages.

By design I do not implement #position and #position: or anything based on that.

I can wrap both binary or character streams and act accordingly.

Part of Zinc HTTP Components.';
		immediateInvariant.
true.
%

removeallmethods ZnBufferedReadStream
removeallclassmethods ZnBufferedReadStream

doit
(Object
	subclass: 'ZnBufferedReadWriteStream'
	instVarNames: #( readStream writeStream lastRead )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am ZnBufferedReadWriteStream.
I wrap a buffered read stream and a buffered write stream on the same file.

I discard my read buffer on writes, and flush my write buffer on reads.
Make sure to always send me #flush or #close when you''re done,
otherwise the last buffer might not yet have been written.
My class side''s #on:do: helps to ensure this.

I can wrap both binary or character streams and act accordingly.

Part of Zinc HTTP Components.';
		immediateInvariant.
true.
%

removeallmethods ZnBufferedReadWriteStream
removeallclassmethods ZnBufferedReadWriteStream

doit
(Object
	subclass: 'ZnBufferedWriteStream'
	instVarNames: #( stream buffer position )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am ZnBufferedWriteStream.
I wrap a write stream and add buffering.

Make sure to always send me #flush or #close when you''re done,
otherwise the last buffer might not yet have been written.
My class side''s #on:do: helps to ensure this.

I can wrap both binary or character streams and act accordingly.

Part of Zinc HTTP Components.';
		immediateInvariant.
true.
%

removeallmethods ZnBufferedWriteStream
removeallclassmethods ZnBufferedWriteStream

doit
(Object
	subclass: 'ZnCharacterEncoder'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am ZnCharacterEncoder, I encode and decode Character objects to and from a binary stream.
I am an abstract class with following protocol:

#nextFromStream:
#nextPut:toStream:
#encodedByteCountFor:
#backOnStream:

The first two are compatible with TextConverter and subclasses.

I add some convenience methods:

#encodeString:
#decodeBytes:
#encodedByteCountForString:

Contrary to older encoders, I work strictly from strings to bytes and vice versa and I will throw errors instead of silently ignoring them.

I also implement optimized bulk operations:

#next:putAll:startingAt:toStream:
#readInto:startingAt:count:fromStream:

Additionally, I can encode Integer code points to a binary stream as well as read Integer code points from a binary stream. This is in a sense a more fundamental operation that avoids instanciating Character objects.

#nextCodePointFromStream:
#nextPutCodePoint:toStream:
#encodedByteCountForCodePoint:

#decodeAsCodePoints:
#encodeCodePoints:
#encodedByteCountForCodePoints:

Part of Zinc HTTP Components.';
		immediateInvariant.
true.
%

removeallmethods ZnCharacterEncoder
removeallclassmethods ZnCharacterEncoder

doit
(ZnCharacterEncoder
	subclass: 'ZnUTF8Encoder'
	instVarNames: #(  )
	classVars: #( Default )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am the GemStone/S implementation of ZnUTF8Encoder.
I implement the variable length UTF-8 encoding and decoding of Unicode according to RFC 3629.

Wikipedia reference http://en.wikipedia.org/wiki/UTF-8

Part of Zinc HTTP Components.

I use the ICU library to encode strings and decode ByteArray and Utf8 instances ... ';
		immediateInvariant.
true.
%

removeallmethods ZnUTF8Encoder
removeallclassmethods ZnUTF8Encoder

doit
(Object
	subclass: 'ZnCharacterReadWriteStream'
	instVarNames: #( readStream writeStream )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am a read-write character stream. I am mainly used to open the Pharo source and changes files.';
		immediateInvariant.
true.
%

removeallmethods ZnCharacterReadWriteStream
removeallclassmethods ZnCharacterReadWriteStream

doit
(Object
	subclass: 'ZnEncodedStream'
	instVarNames: #( stream encoder )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am ZnEncodedStream, an abstract support class for read and write streams on an encoded binary stream.

Part of Zinc HTTP Components';
		immediateInvariant.
true.
%

removeallmethods ZnEncodedStream
removeallclassmethods ZnEncodedStream

doit
(ZnEncodedStream
	subclass: 'ZnEncodedReadStream'
	instVarNames: #( peeked )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am ZnEncodedReadStream, an abstract support class for read streams on a binary encoded wrapped stream.

Part of Zinc HTTP Components';
		immediateInvariant.
true.
%

removeallmethods ZnEncodedReadStream
removeallclassmethods ZnEncodedReadStream

doit
(ZnEncodedReadStream
	subclass: 'ZnCharacterReadStream'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am ZnCharacterReadStream.
I wrap another binary ReadStream and use a ZnCharacerEncoder to allow Characters to be read.

I am not positionable, but I do allow a one character peek using a one character internal buffer.

Part of Zinc HTTP Components.
';
		immediateInvariant.
true.
%

removeallmethods ZnCharacterReadStream
removeallclassmethods ZnCharacterReadStream

doit
(ZnEncodedStream
	subclass: 'ZnEncodedWriteStream'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am ZnEncodedWriteStream, an abstract support class for write streams on a binary encoded wrapped stream.

Part of Zinc HTTP Components';
		immediateInvariant.
true.
%

removeallmethods ZnEncodedWriteStream
removeallclassmethods ZnEncodedWriteStream

doit
(ZnEncodedWriteStream
	subclass: 'ZnCharacterWriteStream'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Zinc-Character-Encoding-Core';
		comment: 'I am ZnCharacterWriteStream.
I wrap another binary WriteStream and use a ZnCharacerEncoder to allow Characters to be written.

Part of Zinc HTTP Components.';
		immediateInvariant.
true.
%

removeallmethods ZnCharacterWriteStream
removeallclassmethods ZnCharacterWriteStream

doit
(STONWriter
	subclass: 'TonelSTONWriter'
	instVarNames: #( aliases )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		comment: 'I''m a modified STON writer to make tonel metadata look as we want.

- it accept aliasses for classes, so I can say OrderedDictionary -> nil (then I do not have an extra information I do not want). Btw, tonel needs to use ordered dictionaries instead plain dictionaries because output needs to be deterministic, and we want to control the order of attributes we publish.
- if dictionary has just one element, it prints it in just one line, to have a more compact view.';
		immediateInvariant.
true.
%

removeallmethods TonelSTONWriter
removeallclassmethods TonelSTONWriter

doit
(TonelSTONWriter
	subclass: 'PharoTonelV1STONWriter'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods PharoTonelV1STONWriter
removeallclassmethods PharoTonelV1STONWriter

doit
(Stream
	subclass: 'AbstractBinaryFileStream'
	instVarNames: #( file handle forWrite )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Files';
		comment: 'Provides a simple, platform-independent, file stream. I am 
   - binary
   - not buffered
   - provide no encoding/conversions

!Examples of usage

"Creating a file"
stream := (File named: ''asd.txt'' asFileReference fullName) readStream.

"Accessing the stream properties"
stream position.
stream atEnd.

"Writing"
stream nextPut: 17.
stream nextPutAll: ''sdd''.

"Reading"
stream next.
stream next: 2.

"Skipping"
stream skip: 2. 

"reading up to something"
stream upTo: 23.
stream upToAnyOf: #[ 13 30 ].

"peeking"
stream peek.';
		immediateInvariant.
true.
%

removeallmethods AbstractBinaryFileStream
removeallclassmethods AbstractBinaryFileStream

doit
(AbstractBinaryFileStream
	subclass: 'BinaryFileStream'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Files';
		comment: 'I am a concrete subclass of AbstractBinaryFileStream for normal files. Regardless the position of the file, I will make my operarions on my position and then return the file it''s own position.

In addition to my superclass'' API I provide the following methods.

stream upToEnd
"reads the full stream up to the end and returns the contents"';
		immediateInvariant.
true.
%

removeallmethods BinaryFileStream
removeallclassmethods BinaryFileStream

doit
(StringKeyValueDictionary
	subclass: 'RwAuditReport'
	instVarNames: #( owner )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwAuditReport
removeallclassmethods RwAuditReport

doit
(StringKeyValueDictionary
	subclass: 'RwProjectAuditReport'
	instVarNames: #( projectName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwProjectAuditReport
removeallclassmethods RwProjectAuditReport

doit
(WriteStream
	subclass: 'CypressMessageDigestStream'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-MesssageDigest';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressMessageDigestStream
removeallclassmethods CypressMessageDigestStream

doit
(WriteStreamPortable
	subclass: 'MemoryWriteStream'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'FileSystem-Memory';
		comment: 'I am like a WriteStream but I have more capacities than it.
I am closer to a FileStream so I delegate some operations to my handle (collection instance variable)';
		immediateInvariant.
true.
%

removeallmethods MemoryWriteStream
removeallclassmethods MemoryWriteStream

! Class implementation for 'UUID'

!		Class methods for 'UUID'

category: 'instance creation'
classmethod: UUID
fromString: aString
	| object |
	aString size ~= 36 ifTrue: [Error signal].
	object := self nilUUID. 
	object asUUID: aString.
	^object
%

category: 'accessing'
classmethod: UUID
generatorClass
  self _generatorClass ifNil: [ ^ FastUUIDGenerator ].
  ^ self _generatorClass
%

category: 'accessing'
classmethod: UUID
generatorClass: aClass
  GeneratorClass := aClass.
  aClass ifNotNil: [ aClass initialize ]
%

category: 'instance creation'
classmethod: UUID
new
  ^ (self new: 16) initialize
%

category: 'instance creation'
classmethod: UUID
nilUUID
	"Must call basicNew: here because I have a non-trivial initialize method."

	^self basicNew: 16
%

category: 'private'
classmethod: UUID
_generatorClass
  ^ GeneratorClass
%

!		Instance methods for 'UUID'

category: 'comparing'
method: UUID
< aMagnitude
  "Answer whether the receiver is less than the argument."

  self size = aMagnitude size
    ifFalse: [ ^ self size < aMagnitude size ].
  1 to: self size do: [ :i | 
    (self at: i) = (aMagnitude at: i)
      ifFalse: [ ^ (self at: i) < (aMagnitude at: i) ] ].
  ^ false
%

category: 'comparing'
method: UUID
<= uuid
	^ (self = uuid) or: [ self < uuid ]
%

category: 'comparing'
method: UUID
> uuid
	^ uuid < self
%

category: 'comparing'
method: UUID
>= uuid
	^ (self = uuid) or: [ uuid < self ]
%

category: 'converting'
method: UUID
asInteger
  ^ self inject: 0 into: [ :sum :each | sum * 256 + each ]
%

category: 'converting'
method: UUID
asString
	| result data |
	data := String new: 36.
	result := WriteStream on: data.
	1 to: 4 do:[:i| self printHexAt: i to: result].
	result nextPut: $-.
	5 to: 6 do:[:i| self printHexAt: i to: result].
	result nextPut: $-.
	7 to: 8 do:[:i| self printHexAt: i to: result].
	result nextPut: $-.
	9 to: 10 do:[:i| self printHexAt: i to: result].
	result nextPut: $-.
	11 to: 16 do:[:i| self printHexAt: i to: result].
	^data.
%

category: 'converting'
method: UUID
asString36
	"Encode the UUID as a base 36 string using 0-9 and lowercase a-z.
	This is the shortest representation still being able to work as
	filenames etc since it does not depend on case nor characters
	that might cause problems, and it fits into short filenames like on
	the old MacOS HFS filesystem. The check for 36r is to make this code
	work in versions before Squeak 3.8."

	| num candidate |
	num := 0.
	1 to: self size do: [:i | num := num + ((256 raisedTo: i - 1) * (self at: i))].
	candidate := num printStringBase: 36.
	^((candidate beginsWith: '36r')
			ifTrue: [candidate copyFrom: 4 to: candidate size]
			ifFalse: [candidate]) asLowercase
%

category: 'converting'
method: UUID
asUUID: aString
	| stream token byte sz |
	stream := ReadStream on: (aString copyReplaceAll: '-' with: '') asUppercase.
	sz := stream _collection size.
	1 to: sz/2 do: [:i | 
		token := stream next: 2.
		byte := Integer fromHexString: token.
		self at: i put: byte].
	^self
%

category: 'initialization'
method: UUID
initialize
  self _primMakeUUID
%

category: 'testing'
method: UUID
isNilUUID
  1 to: self size do: [ :i | 
    (self at: i) ~= 0
      ifTrue: [ ^ false ] ].
  ^ true
%

category: 'converting'
method: UUID
printHexAt: index to: aStream
	| map v |
	map := '0123456789abcdef'.
	v := self at: index.
	aStream nextPut: (map at: (v bitShift: -4) + 1). 
	aStream nextPut: (map at: (v bitAnd: 15) + 1).
%

category: 'printing'
method: UUID
printOn: aStream
	aStream nextPutAll: 'an UUID('.
	self asString printOn: aStream.
	aStream nextPutAll: ')'
%

category: 'printing'
method: UUID
printString

	^self asString
%

category: 'private'
method: UUID
_primMakeUUID
  self class generatorClass default generateBytes: self forVersion: 4
%

! Class implementation for 'CypressLoaderError'

!		Class methods for 'CypressLoaderError'

category: 'instance creation'
classmethod: CypressLoaderError
patchOperation: aPatchOperation exception: anException

	^self new
		initializePatchOperation: aPatchOperation exception: anException;
		yourself
%

!		Instance methods for 'CypressLoaderError'

category: 'accessing'
method: CypressLoaderError
exception
	"Answer the original exception raised when applying the Patch Operation."

	^exception
%

category: 'updating'
method: CypressLoaderError
exception: anException
	"Assign the original exception raised when applying the Patch Operation."

	exception := anException
%

category: 'initializing - private'
method: CypressLoaderError
initialize

	super initialize.
	gsResumable := true
%

category: 'initializing - private'
method: CypressLoaderError
initializeMessageText

	| str |
	(str := String new )
		addAll: self patchOperation printString;
		addAll: ' failed because ';
		addAll: self exception printString.
	self details: str .
%

category: 'initializing - private'
method: CypressLoaderError
initializePatchOperation: aPatchOperation exception: anException

	self
		patchOperation: aPatchOperation;
		exception: anException;
		initializeMessageText
%

category: 'handling'
method: CypressLoaderError
logNotification: aString

	GsFile gciLogServer: aString.
	Transcript cr; nextPutAll: aString.
%

category: 'accessing'
method: CypressLoaderError
patchOperation
	"Answer the Patch Operation that could not be applied."

	^patchOperation
%

category: 'updating'
method: CypressLoaderError
patchOperation: aCypressPatchOperation
	"Assign the Patch Operation that could not be applied."

	patchOperation := aCypressPatchOperation
%

! Class implementation for 'CypressLoaderMissingClasses'

!		Class methods for 'CypressLoaderMissingClasses'

category: 'instance creation'
classmethod: CypressLoaderMissingClasses
missingRequirementsMap: aDictionary
	"Answer an instance of the receiver initialized on the specified
	 missing requirements. aDictionary maps prerequisite names to
	 a collection of dependent definitions."

	^self new
		initializeRequirementsMap: aDictionary;
		yourself
%

!		Instance methods for 'CypressLoaderMissingClasses'

category: 'initializing - private'
method: CypressLoaderMissingClasses
initialize

	super initialize.
	gsResumable := true
%

category: 'initializing - private'
method: CypressLoaderMissingClasses
initializeMessageText

	| str |
	str := 'Missing classes:' copy .
	self requirementsMap keysAndValuesDo: 
			[:className :definitions |
			str
				space;
				addAll: className printString , '(' , definitions size printString
							, ')'].
	self details: str.
%

category: 'initializing - private'
method: CypressLoaderMissingClasses
initializeRequirementsMap: aDictionary

	self
		requirementsMap: aDictionary;
		initializeMessageText.
%

category: 'accessing'
method: CypressLoaderMissingClasses
requirementsMap
	"The requirements map is a Dictionary mapping missing class
	 names to a collection of dependent definitions."

   ^requirementsMap
%

category: 'updating'
method: CypressLoaderMissingClasses
requirementsMap: aDictionary
	"The requirements map is a Dictionary mapping missing class
	 names to a collection of dependent definitions."

	requirementsMap := aDictionary
%

! Class implementation for 'FileException'

!		Class methods for 'FileException'

category: 'exceptioninstantiator'
classmethod: FileException
fileName: aFileName
	^self new fileName: aFileName
%

category: 'instance creation'
classmethod: FileException
signalOnFile: aFile 
	
	(self fileName: aFile basename) signal: aFile name
%

category: 'instance creation'
classmethod: FileException
signalWith: aReference
	"Signal a new instance of the receiver with the supplied reference.
	aReference is something that can be converted to a path, e.g. a String, Path or FileReference"
  | str |
	^(self fileName: (str := aReference asPath pathString)) signal: str
%

!		Instance methods for 'FileException'

category: 'exceptiondescription'
method: FileException
buildMessageText
  self details: fileName printString .
  super buildMessageText
%

category: 'exceptiondescription'
method: FileException
fileName
	^fileName
%

category: 'exceptionbuilder'
method: FileException
fileName: aFileName
	fileName := aFileName
%

category: 'exceptiondescription'
method: FileException
isResumable
	"Determine whether an exception is resumable."

	^true
%

! Class implementation for 'FileAlreadyExistsException'

!		Class methods for 'FileAlreadyExistsException'

category: 'instance creation'
classmethod: FileAlreadyExistsException
signalOnFile: aFile 
	
	self new
		file: aFile;
		signal: aFile name "use signal: so filename shows up in exception printString"
%

!		Instance methods for 'FileAlreadyExistsException'

category: 'accessing'
method: FileAlreadyExistsException
buildMessageText
  self details:  'File already exists: ', (file ifNotNil:[:f | f basename] ifNil:['nil']).
  super buildMessageText 
%

category: 'accessing'
method: FileAlreadyExistsException
file
	^ file
%

category: 'accessing'
method: FileAlreadyExistsException
file: aFile
	
	file := aFile
%

! Class implementation for 'FileDoesNotExistException'

!		Class methods for 'FileDoesNotExistException'

category: 'signalling'
classmethod: FileDoesNotExistException
signalWithFile: aFile writeMode: writeMode

  | ex |
	^ (ex := self fileName: aFile basename)
		readOnly: writeMode not;
		signal: ex fileName  "use signal: so file name shows up in  ex printString"
%

!		Instance methods for 'FileDoesNotExistException'

category: 'accessing'
method: FileDoesNotExistException
readOnly
	^readOnly == true
%

category: 'accessing'
method: FileDoesNotExistException
readOnly: aBoolean
	readOnly := aBoolean
%

! Class implementation for 'FileSystemError'

!		Class methods for 'FileSystemError'

category: 'instance creation'
classmethod: FileSystemError
reference: aReference
	^ self basicNew initializeWithReference: aReference
%

category: 'instance creation'
classmethod: FileSystemError
signalWith: aReference
	^ (self reference: aReference) signal
%

!		Instance methods for 'FileSystemError'

category: 'initialize-release'
method: FileSystemError
initializeWithReference: aReference
	reference := aReference.
	self details: aReference printString
%

category: 'testing'
method: FileSystemError
isResumable
	^ true
%

category: 'accessing'
method: FileSystemError
reference
	^ reference
%

! Class implementation for 'IllegalName'

!		Class methods for 'IllegalName'

category: 'instance creation'
classmethod: IllegalName
name: aName
	^ self basicNew initializeWithName: aName
%

category: 'instance creation'
classmethod: IllegalName
signalWith: aName
	^ (self name: aName) signal
%

!		Instance methods for 'IllegalName'

category: 'initialization'
method: IllegalName
initializeWithName: aName
	name := aName.
	self messageText: aName
%

category: 'accessing'
method: IllegalName
name
	^ name
%

! Class implementation for 'RwGemStoneVersionNumber'

!		Class methods for 'RwGemStoneVersionNumber'

category: 'instance creation'
classmethod: RwGemStoneVersionNumber
fromString: aString

	| new components |
	components := OrderedCollection new.
	(aString substrings: '.') do: [:subString | 
		components add: subString asInteger].
	new := self new: components size.
	1 to: components size do: [:i | new at: i put: (components at: i) ].
	^new
%

!		Instance methods for 'RwGemStoneVersionNumber'

category: 'comparing'
method: RwGemStoneVersionNumber
< aRwGemStoneVersionNumber

	| condensed aCondensed |
	aRwGemStoneVersionNumber species = self species
		ifFalse: [ ^ false ].
	condensed := self collapseZeros.
	aCondensed := aRwGemStoneVersionNumber collapseZeros.
	(condensed ~~ self or: [ aCondensed ~~ aRwGemStoneVersionNumber ])
		ifTrue: [ ^ condensed compareLessThan: aCondensed ].
	^ self compareLessThan: aRwGemStoneVersionNumber
%

category: 'comparing'
method: RwGemStoneVersionNumber
= aRwGemStoneVersionNumber

	| condensed aCondensed |
	aRwGemStoneVersionNumber species = self species
		ifFalse: [ ^ false ].
	condensed := self collapseZeros.
	aCondensed := aRwGemStoneVersionNumber collapseZeros.
	(condensed ~~ self or: [ aCondensed ~~ aRwGemStoneVersionNumber ])
		ifTrue: [ ^ condensed compareEqualTo: aCondensed ].
	^ self compareEqualTo: aRwGemStoneVersionNumber
%

category: 'accessing'
method: RwGemStoneVersionNumber
approximateBase

	| base condensed |
	condensed := self collapseZeros.
	base := condensed copyFrom: 1 to: condensed size - 1.
	base at: base size put: (base at: base size) + 1.
	^base
%

category: 'converting'
method: RwGemStoneVersionNumber
asRwGemStoneVersionNumber

	^self
%

category: 'printing'
method: RwGemStoneVersionNumber
asString
	"Answer a string that represents the receiver."

	^ self printString
%

category: 'private'
method: RwGemStoneVersionNumber
collapseZeros
	"the rule must be that zeros can be collapsed as long as the series of zeros ends in a 0"

	| collection newSize new j lastElementIsStringOrZero canCollapse |
	(self size = 0 or: [ self at: 1 ]) == 0
		ifTrue: [ ^ self ].
	collection := OrderedCollection new.
	lastElementIsStringOrZero := true.
	canCollapse := true.
	self size to: 1 by: -1 do: [ :i | 
		| element |
		element := self at: i.
		(canCollapse and: [ element == 0 ])
			ifTrue: [ 
				lastElementIsStringOrZero
					ifFalse: [ 
						canCollapse := false.
						collection addFirst: element.]]
			ifFalse: [ 
				collection addFirst: element.
				canCollapse := lastElementIsStringOrZero := element isString ] ].
	collection size = self size
		ifTrue: [ ^ self ].
	newSize := collection size.
	new := self species new: newSize.
	j := 0.
	collection
		do: [ :element | 
			new at: j + 1 put: element.
			j := j + 1 ].
	^ new
%

category: 'private'
method: RwGemStoneVersionNumber
compareEqualTo: aRwGemStoneVersionNumber

	| mySize |
	aRwGemStoneVersionNumber species = self species ifFalse: [ ^false ].
	mySize := self size.
	mySize = aRwGemStoneVersionNumber size 
		ifFalse: [ ^false ].
	1 to: mySize do: [:i |
		(self at: i) = (aRwGemStoneVersionNumber at: i) ifFalse: [ ^false ]].
	^true
%

category: 'private'
method: RwGemStoneVersionNumber
compareLessThan: aRwGemStoneVersionNumber

	| mySize aSize commonSize count more |
	mySize := self size.
	aSize := aRwGemStoneVersionNumber size.
	commonSize :=  mySize min: aSize.
	count := 0.
	more := true.
	[ more and: [ count < commonSize ]] whileTrue: [
		(self at: count + 1) = (aRwGemStoneVersionNumber at: count + 1)
			ifTrue: [ count := count + 1 ]
			ifFalse: [ more := false ]].
	count < commonSize
		ifTrue: [ 
			^(self at: count + 1) < (aRwGemStoneVersionNumber at: count + 1) ].
	mySize < aSize
		ifTrue: [ 
			mySize = 0 ifTrue: [ ^true ].
			"if the versions at commonSize are equal and the next version slot in aRwGemStoneVersionNumber 
			 is a string, then it's considered that I'm > aRwGemStoneVersionNumber
			 (i.e., '2.9.9' is greater than '2.9.9-alpha.2')"
			(self at: commonSize) = (aRwGemStoneVersionNumber at: commonSize)
				ifFalse: [ ^true ]. 
			^(aRwGemStoneVersionNumber at: commonSize+1) isString not]
		ifFalse: [ 
			mySize = aSize ifTrue: [ ^false ].
			aSize <= 0 ifTrue: [ ^false ].
			"if the versions at commonSize are equal and the next version slot is a string, 
			 then it's considered that I'm < aRwGemStoneVersionNumber
			 (i.e., '2.9.9-alpha.2' is less than '2.9.9')"
			(self at: commonSize) = (aRwGemStoneVersionNumber at: commonSize)
				ifFalse: [ ^false ].
			 ^(self at: commonSize+1) isString]
%

category: 'copying'
method: RwGemStoneVersionNumber
copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize new j |
	newSize := stop - start + 1.
	new := self species new: newSize.
	j := 0.
	start to: stop do: [:i |
		new at: j + 1 put: (self at: i).
		j := j + 1 ].
	^new
%

category: 'enumerating'
method: RwGemStoneVersionNumber
do: aBlock 
	"Refer to the comment in Collection|do:."
	1 to: self size do:
		[:index | aBlock value: (self at: index)]
%

category: 'enumerating'
method: RwGemStoneVersionNumber
do: elementBlock separatedBy: separatorBlock
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	| beforeFirst | 
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		elementBlock value: each]
%

category: 'comparing'
method: RwGemStoneVersionNumber
hash

"Returns a numeric hash key for the receiver."

| mySize interval hashValue |

(mySize := self size) == 0
  ifTrue: [ ^15243 ].

"Choose an interval so that we sample at most 5 elements of the receiver"
interval := ((mySize - 1) // 4) max: 1.

hashValue := 4459.
1 to: mySize by: interval do: [ :i | | anElement |
  anElement := self at: i.
  (anElement isKindOf: SequenceableCollection)
    ifTrue: [
      hashValue := (hashValue bitShift: -1) bitXor: anElement size.
      ]
    ifFalse: [
      hashValue := (hashValue bitShift: -1) bitXor: anElement hash.
      ].
  ].

^ hashValue abs
%

category: 'printing'
method: RwGemStoneVersionNumber
printOn: aStream

	| beforeFirst | 
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [
				each isString
					ifTrue: [ aStream nextPut: $- ]
					ifFalse: [ aStream nextPut: $. ] ].
		aStream nextPutAll: each asString ]
%

category: 'matching'
method: RwGemStoneVersionNumber
rwPlatformAttributeMatchForGemStoneVersion: anRwGemStoneVersionConfigurationPlatformAttributeMatcher

	^ anRwGemStoneVersionConfigurationPlatformAttributeMatcher matchVersion: self
%

category: 'matching'
method: RwGemStoneVersionNumber
rwPlatformAttributeMatchForString: anRwStringConfigurationPlatformAttributeMatcher

	^ anRwStringConfigurationPlatformAttributeMatcher matchString: self printString
%

category: 'accessing'
method: RwGemStoneVersionNumber
versionString

	| strm |
	strm := WriteStream on: String new.
	self printOn: strm.
	^strm contents
%

category: 'comparing'
method: RwGemStoneVersionNumber
~> aRwGemStoneVersionNumber

	aRwGemStoneVersionNumber size == 1 ifTrue: [ ^false ].
	^self >= aRwGemStoneVersionNumber and: [ self < aRwGemStoneVersionNumber approximateBase ]
%

! Class implementation for 'RwSemanticVersionNumber'

!		Class methods for 'RwSemanticVersionNumber'

category: 'private'
classmethod: RwSemanticVersionNumber
extractNumericComponent: subString
    "$. separated components are integers"

    | number stream |
	stream := subString readStream.
	number := [ Integer fromStream: stream ] on: Error do: [:ex | ^ subString ].
	^ stream atEnd
		ifTrue: [ 
			(subString size > 1 and: [ (subString at: 1) = $0 ])
				ifTrue: [ self error: 'invalid version number: numberic components may not have a leading 0' ]
				ifFalse: [ number ] ]
		ifFalse: [ subString ]
%

category: 'instance creation'
classmethod: RwSemanticVersionNumber
fromString: aString
  | preRelease build versionString identifierCount normalEnd preReleaseEnd normalComponents preReleaseComponents buildComponents |
  normalComponents := OrderedCollection new.
  preReleaseComponents := OrderedCollection new.
  buildComponents := OrderedCollection new.
  preRelease := aString indexOf: $- startingAt: 1.
  build := aString indexOf: $+ startingAt: 1.
  (build > 0 and: [ preRelease > build ])
    ifTrue: [ preRelease := 0 ].
  normalEnd := preRelease = 0
    ifTrue: [ 
      build = 0
        ifTrue: [ aString size ]
        ifFalse: [ build - 1 ] ]
    ifFalse: [ preRelease - 1 ].
  versionString := aString copyFrom: 1 to: normalEnd.
  identifierCount := 0.
  (versionString subStrings: '.')
    do: [ :subString | 
      | integer |
      subString isEmpty
        ifTrue: [ self error: 'invalid version number: normal version component MUST NOT be empty' ].
	  integer := self integerFromString: subString.
	  integer < 0
		ifTrue: [ 
		  self
			error:
			  'invalid version number: normal version component MUST be integer '
				, subString printString ] .
      normalComponents add: integer.
      identifierCount := identifierCount + 1 ].
  identifierCount ~= 3
    ifTrue: [ self error: 'invalid version number: normal version MUST have only 3 components' ].
  preReleaseEnd := build = 0
    ifTrue: [ aString size ]
    ifFalse: [ build - 1 ].
  preRelease > 0
    ifTrue: [ 
      versionString := aString copyFrom: preRelease + 1 to: preReleaseEnd.
      (versionString subStrings: '.')
        do: [ :subString | 
	      subString isEmpty
              ifTrue: [ self error: 'invalid version number: preRelease version component MUST NOT be empty' ].
          (self isSemanticIdentifier: subString)
            ifFalse: [ 
              self
                error:
                  'invalid version number: preRelease version component must be one of [0-9A-Za-z-], MUST NOT be empty, and first component MUST NOT be 0' ].
          preReleaseComponents
            add:
              (self extractNumericComponent: subString) ] ].
  build > 0
    ifTrue: [ 
      versionString := aString copyFrom: build + 1 to: aString size.
      (versionString subStrings: '.')
        do: [ :subString | 
	      subString isEmpty
              ifTrue: [ self error: 'invalid version number: preRelease version component MUST NOT be empty' ].
          (self isSemanticIdentifier: subString)
            ifFalse: [ 
              self
                error:
                  'invalid version number: build version component must be one of [0-9A-Za-z-] and MUST NOT be empty' ].
          buildComponents add: subString ] ].

  ^ self new
    normalVersion: normalComponents;
    preReleaseVersion: preReleaseComponents;
    buildVersion: buildComponents;
    yourself
%

category: 'private'
classmethod: RwSemanticVersionNumber
integerFromString: aString
  aString
    detect: [ :char | char isDigit not ]
    ifNone: [ 
      | integer |
      integer := aString asInteger.
      ((aString at: 1) = $0 and: [ aString size > 1 ])
        ifTrue: [ 
          self
            error:
              'invalid version number: normal version component must not have leading 0s'
                , aString asString ].
      ^ integer ].
  self
    error:
      'invalid version number: normal version component must be integer '
        , aString asString
%

category: 'private'
classmethod: RwSemanticVersionNumber
isSemanticIdentifier: aString
    "whether the receiver is composed entirely of alphanumerics"

   aString do: [ :c | 
     c isAlphaNumeric
       ifFalse: [ c = $- ifFalse: [ ^ false ] ] ].
    ^ true
%

category: 'private'
classmethod: RwSemanticVersionNumber
validateVersionNumber: svn against: aString
  svn printString = aString
    ifFalse: [ 
      self
        error:
          'The printString of a semantic version number should be equal to the source version string' ]
%

!		Instance methods for 'RwSemanticVersionNumber'

category: 'comparing'
method: RwSemanticVersionNumber
< aRwSemanticVersionNumber
    aRwSemanticVersionNumber species = self species
        ifFalse: [ ^ false ].
    ^ self compareLessThan: aRwSemanticVersionNumber
%

category: 'comparing'
method: RwSemanticVersionNumber
= aMetacelloVersionNumber
    aMetacelloVersionNumber species = self species
        ifFalse: [ ^ false ].
    ^ self compareEqualTo: aMetacelloVersionNumber
%

category: 'accessing'
method: RwSemanticVersionNumber
approximateBase

	| base |
	base := self copyFrom: 1 to: self size - 1.
	base at: base size put: (base at: base size) + 1.
	^base
%

category: 'converting'
method: RwSemanticVersionNumber
asRwSemanticVersionNumber
    ^ self
%

category: 'printing'
method: RwSemanticVersionNumber
asString
	"Answer a string that represents the receiver."

	^ self printString
%

category: 'accessing'
method: RwSemanticVersionNumber
buildVersion
    buildVersion ifNil: [ buildVersion := #() ].
    ^ buildVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
buildVersion: anObject
	buildVersion := anObject
%

category: 'private'
method: RwSemanticVersionNumber
compareEqualTo: aRwSemanticVersionNumber
    aRwSemanticVersionNumber species = self species
        ifFalse: [ ^ false ].
    (self compareEqualTo: self normalVersion other: aRwSemanticVersionNumber normalVersion)
        ifFalse: [ ^ false ].
    (self compareEqualTo: self preReleaseVersion other: aRwSemanticVersionNumber preReleaseVersion)
        ifFalse: [ ^ false ].
    ^ true
%

category: 'private'
method: RwSemanticVersionNumber
compareEqualTo: myComponents other: otherComponents
    | mySize |
    mySize := myComponents size.
    mySize = otherComponents size
        ifFalse: [ ^ false ].
    1 to: mySize do: [ :i | 
        (myComponents at: i) = (otherComponents at: i)
            ifFalse: [ ^ false ] ].
    ^ true
%

category: 'private'
method: RwSemanticVersionNumber
compareLessThan: aRwSemanticVersionNumber
    | myComponents otherComponents defaultResult |
    aRwSemanticVersionNumber species = self species
        ifFalse: [ ^ false ].
    myComponents := self normalVersion.
    otherComponents := aRwSemanticVersionNumber normalVersion.
    defaultResult := true.
    (self compareEqualTo: myComponents other: otherComponents)
        ifTrue: [ defaultResult := false ]
        ifFalse: [ 
            (self compareLessThan: myComponents other: otherComponents version: #'normal')
                ifFalse: [ ^ false ] ].
    myComponents := self preReleaseVersion.
    otherComponents := aRwSemanticVersionNumber preReleaseVersion.
    (self compareEqualTo: myComponents other: otherComponents)
        ifTrue: [ 
            myComponents size > 0
                ifTrue: [ defaultResult := false ] ]
        ifFalse: [ ^ self compareLessThan: myComponents other: otherComponents version: #'preRelease' ].
    ^ defaultResult
%

category: 'private'
method: RwSemanticVersionNumber
compareLessThan: myComponents other: otherComponents version: version
    | mySize aSize commonSize count more |
    mySize := myComponents size.
    aSize := otherComponents size.
    commonSize := mySize min: aSize.
    count := 0.
    more := true.
    [ more and: [ count < commonSize ] ]
        whileTrue: [ 
            (myComponents at: count + 1) = (otherComponents at: count + 1)
                ifTrue: [ count := count + 1 ]
                ifFalse: [ more := false ] ].
    count < commonSize
        ifTrue: [ ^ (myComponents at: count + 1) rwSemanticVersionComponentLessThan: (otherComponents at: count + 1) ].
    mySize < aSize
        ifTrue: [ 
            mySize = 0
                ifTrue: [ 
                    #'preRelease' == version
                        ifTrue: [ ^ false ].
                    ^ true ].
            (myComponents at: commonSize) = (otherComponents at: commonSize)
                ifFalse: [ ^ true ].
            ^ true ]
        ifFalse: [ 
            mySize = aSize
                ifTrue: [ ^ false ].
            aSize = 0
                ifTrue: [ 
                    #'build' == version
                        ifTrue: [ ^ false ].
                    ^ true ].
            (myComponents at: commonSize) = (otherComponents at: commonSize)
                ifFalse: [ ^ false ].
            ^ true ]
%

category: 'copying'
method: RwSemanticVersionNumber
copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize new j |
	newSize := stop - start + 1.
	new := self species new: newSize.
	j := 0.
	start to: stop do: [:i |
		new at: j + 1 put: (self at: i).
		j := j + 1 ].
	^new
%

category: 'operations'
method: RwSemanticVersionNumber
decrementMajorVersion
  self decrementNormalVersionAt: 1
%

category: 'operations'
method: RwSemanticVersionNumber
decrementMinorVersion
  self decrementNormalVersionAt: 2
%

category: 'operations'
method: RwSemanticVersionNumber
decrementMinorVersionNumber
  self decrementNormalVersionAt: 3
%

category: 'private'
method: RwSemanticVersionNumber
decrementNormalVersionAt: index
  | int col |
  col := self normalVersion.
  int := col at: index.
  int > 0
    ifTrue: [ col at: index put: int - 1 ]
%

category: 'operations'
method: RwSemanticVersionNumber
decrementPatchVersion
  self decrementNormalVersionAt: 3
%

category: 'enumerating'
method: RwSemanticVersionNumber
do: aBlock 
	"Refer to the comment in Collection|do:."
	1 to: self size do:
		[:index | aBlock value: (self at: index)]
%

category: 'enumerating'
method: RwSemanticVersionNumber
do: elementBlock separatedBy: separatorBlock
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	| beforeFirst | 
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		elementBlock value: each]
%

category: 'comparing'
method: RwSemanticVersionNumber
hash
    ^ self versionComponents hash
%

category: 'operations'
method: RwSemanticVersionNumber
incrementMajorVersion
  self incrementNormalVersionAt: 1
%

category: 'operations'
method: RwSemanticVersionNumber
incrementMinorVersion
  self incrementNormalVersionAt: 2
%

category: 'operations'
method: RwSemanticVersionNumber
incrementMinorVersionNumber
  self incrementNormalVersionAt: 3
%

category: 'private'
method: RwSemanticVersionNumber
incrementNormalVersionAt: index
  | int col |
  col := self normalVersion.
  int := col at: index.
  col at: index put: int + 1
%

category: 'operations'
method: RwSemanticVersionNumber
incrementPatchVersion
  self incrementNormalVersionAt: 3
%

category: 'accessing'
method: RwSemanticVersionNumber
normalVersion
    normalVersion ifNil: [ normalVersion := #() ].
    ^ normalVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
normalVersion: anObject
	normalVersion := anObject
%

category: 'copying'
method: RwSemanticVersionNumber
postCopy
  normalVersion := normalVersion copy.
  preReleaseVersion := preReleaseVersion copy.
  buildVersion := buildVersion copy
%

category: 'accessing'
method: RwSemanticVersionNumber
preReleaseVersion
    preReleaseVersion ifNil: [ preReleaseVersion := #() ].
    ^ preReleaseVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
preReleaseVersion: anObject
	preReleaseVersion := anObject
%

category: 'printing'
method: RwSemanticVersionNumber
print: components prefix: prefixChar on: aStream
    | beforeFirst |
    beforeFirst := true.
    components
        do: [ :component | 
            beforeFirst
                ifTrue: [ 
                    beforeFirst := false.
                    prefixChar ifNotNil: [ aStream nextPut: prefixChar ] ]
                ifFalse: [ aStream nextPut: $. ].
            aStream nextPutAll: component asString ]
%

category: 'printing'
method: RwSemanticVersionNumber
printOn: aStream
    self print: self normalVersion prefix: nil on: aStream.
    self print: self preReleaseVersion prefix: $- on: aStream.
    self print: self buildVersion prefix: $+ on: aStream
%

category: 'private'
method: RwSemanticVersionNumber
versionComponents
    ^ self normalVersion , self preReleaseVersion , self buildVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
versionString

	| strm |
	strm := WriteStream on: String new.
	self printOn: strm.
	^strm contents
%

category: 'comparing'
method: RwSemanticVersionNumber
~> aMetacelloVersionNumber

	"if this selector is to survive it will need work ... see RwGemStoneVersionNumber ... I think that collapseZeroes will be needed (in some form) to 
		make this boy give expected results"

	aMetacelloVersionNumber size == 1 ifTrue: [ ^false ].
	^self >= aMetacelloVersionNumber and: [ self < aMetacelloVersionNumber approximateBase ]
%

! Class implementation for 'CypressLoaderErrorNotification'

!		Class methods for 'CypressLoaderErrorNotification'

category: 'instance creation'
classmethod: CypressLoaderErrorNotification
patchOperation: aPatchOperation exception: anException

	^self new
		initializePatchOperation: aPatchOperation exception: anException;
		yourself
%

!		Instance methods for 'CypressLoaderErrorNotification'

category: 'handling'
method: CypressLoaderErrorNotification
defaultAction
	"Log the notification to the GCI log and the Transcript, then resume."

	self logNotification: 'Notice: ' , self asString.
	^super defaultAction
%

category: 'accessing'
method: CypressLoaderErrorNotification
exception
	"Answer the original exception raised when applying the Patch Operation."

	^exception
%

category: 'updating'
method: CypressLoaderErrorNotification
exception: anException
	"Assign the original exception raised when applying the Patch Operation."

	exception := anException
%

category: 'initializing - private'
method: CypressLoaderErrorNotification
initializeMessageText

	| str |
	str :=	self patchOperation printString ,  ' failed because '.
	str addAll: self exception printString.
	self details: str .
%

category: 'initializing - private'
method: CypressLoaderErrorNotification
initializePatchOperation: aPatchOperation exception: anException

	self
		patchOperation: aPatchOperation;
		exception: anException;
		initializeMessageText
%

category: 'handling'
method: CypressLoaderErrorNotification
logNotification: aString

	GsFile gciLogServer: aString.
	Transcript cr; nextPutAll: aString.
%

category: 'accessing'
method: CypressLoaderErrorNotification
patchOperation
	"Answer the Patch Operation that could not be applied."

	^patchOperation
%

category: 'updating'
method: CypressLoaderErrorNotification
patchOperation: aCypressPatchOperation
	"Assign the Patch Operation that could not be applied."

	patchOperation := aCypressPatchOperation
%

! Class implementation for 'GsInteractionRequest'

!		Class methods for 'GsInteractionRequest'

category: 'interacting'
classmethod: GsInteractionRequest
signal: aGsInteraction
  ^ (self new interaction: aGsInteraction) signal
%

!		Instance methods for 'GsInteractionRequest'

category: 'signaling'
method: GsInteractionRequest
defaultAction
  ^ self interaction defaultActionFor: self
%

category: 'Compatibility'
method: GsInteractionRequest
gsArguments
  "This method included here for G/S 2.x only ... not needed nor used in 3.x"

  ^ {(self interaction)}
%

category: 'Instance initialization'
method: GsInteractionRequest
initialize
  super initialize.
  gsNumber := 121001
%

category: 'accessing'
method: GsInteractionRequest
interaction

   "Return the value of the instance variable 'interaction'."
   ^interaction
%

category: 'accessing'
method: GsInteractionRequest
interaction: anObject

   "Modify the value of the instance variable 'interaction'."
   interaction := anObject
%

category: 'signaling'
method: GsInteractionRequest
response: anObject
  self resume: anObject
%

! Class implementation for 'ResolutionRequest'

!		Class methods for 'ResolutionRequest'

category: 'instance creation'
classmethod: ResolutionRequest
for: origin
	^ self new
		origin: origin;
		signal
%

!		Instance methods for 'ResolutionRequest'

category: 'exceptionDescription'
method: ResolutionRequest
defaultAction
"
	| filedir ref |
	filedir := UIManager default chooseDirectory: 'Where is ', origin asString, '?'.
	ref := filedir ifNotNil: [FileSystem disk referenceTo: filedir fullName].
	self resume: ref
"

	self error: 'Not yet implemented'
%

category: 'accessing'
method: ResolutionRequest
origin: aSymbol
	origin := aSymbol
%

! Class implementation for 'RwAdoptAuditErrorNotification'

!		Class methods for 'RwAdoptAuditErrorNotification'

category: 'instance creation'
classmethod: RwAdoptAuditErrorNotification
classNamed: className isClassExtension: classExtension  intoPackageNamed: packageName

	^ self new
		className: className;
		isClassExtension: classExtension;
		packageName: packageName;
		yourself
%

!		Instance methods for 'RwAdoptAuditErrorNotification'

category: 'accessing'
method: RwAdoptAuditErrorNotification
className

	^ className
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
className: aString

	className := aString
%

category: 'Handling'
method: RwAdoptAuditErrorNotification
defaultAction
 
	^ Error signal: self _errorMessage
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
description

	^ description ifNil: [ '' ]
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
description: aString

	description := aString
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
isClassExtension

	^ isClassExtension
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
isClassExtension: aBoolean

	isClassExtension := aBoolean
%

category: 'Handling'
method: RwAdoptAuditErrorNotification
methodErrorDo: methodBlock classErrorDo: classBlock
	"helper method for use in exception handling block ... avoid isKindOf:"

	self subclassResponsibility: #methodErrorDo:classErrorDo:
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
packageName

	^ packageName
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
packageName: aString

	packageName := aString
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
reason
	^reason
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
reason: object
	reason := object
%

category: 'private'
method: RwAdoptAuditErrorNotification
_errorMessage

	self subclassResponsibility: #_errorMessage
%

! Class implementation for 'RwAdoptAuditClassErrorNotification'

!		Instance methods for 'RwAdoptAuditClassErrorNotification'

category: 'Handling'
method: RwAdoptAuditClassErrorNotification
methodErrorDo: methodBlock classErrorDo: classBlock
	"helper method for use in exception handling block ... avoid isKindOf:"

	classBlock value
%

! Class implementation for 'RwAdoptMissingClassErrorNotification'

!		Instance methods for 'RwAdoptMissingClassErrorNotification'

category: 'private'
method: RwAdoptMissingClassErrorNotification
_errorMessage

	| extensionMessage |
	extensionMessage := self isClassExtension
		ifTrue: [ ' extension ' ]
		ifFalse: [ ' ' ].
	^ 'Unable to adopt the class ', self className printString, ' into the', extensionMessage, 'package ', self packageName printString, ' as it is not present in the current user''s symbol list.'
%

! Class implementation for 'RwAuditClassErrorNotification'

!		Instance methods for 'RwAuditClassErrorNotification'

category: 'Handling'
method: RwAuditClassErrorNotification
defaultAction
	"record audit error"
	^ true
%

! Class implementation for 'RwAdoptAuditMethodErrorNotification'

!		Class methods for 'RwAdoptAuditMethodErrorNotification'

category: 'instance creation'
classmethod: RwAdoptAuditMethodErrorNotification
method: methodSelector isMeta: isMeta inClassNamed: className isClassExtension: classExtension  intoPackageNamed: packageName


	^ (self classNamed: className isClassExtension: classExtension  intoPackageNamed: packageName)
		selector: methodSelector;
		isMetaclass: isMeta;
		yourself
%

!		Instance methods for 'RwAdoptAuditMethodErrorNotification'

category: 'accessing'
method: RwAdoptAuditMethodErrorNotification
isMetaclass

	^ isMetaclass
%

category: 'accessing'
method: RwAdoptAuditMethodErrorNotification
isMetaclass: aBoolean

	isMetaclass := aBoolean
%

category: 'Handling'
method: RwAdoptAuditMethodErrorNotification
methodErrorDo: methodBlock classErrorDo: classBlock
	"helper method for use in exception handling block ... avoid isKindOf:"

	methodBlock value
%

category: 'accessing'
method: RwAdoptAuditMethodErrorNotification
methodPrintString

	^ self 
		className, 
		(self isMetaclass ifTrue: [ ' class >> ' ] ifFalse: [ ' >> ' ]),
		self selector
%

category: 'accessing'
method: RwAdoptAuditMethodErrorNotification
selector

	^ selector
%

category: 'accessing'
method: RwAdoptAuditMethodErrorNotification
selector: aString

	selector := aString
%

! Class implementation for 'RwAdoptMissingMethodErrorNotification'

!		Instance methods for 'RwAdoptMissingMethodErrorNotification'

category: 'private'
method: RwAdoptMissingMethodErrorNotification
_errorMessage

	| extensionMessage metaClassMessage |
	metaClassMessage := self isMetaclass
		ifTrue: [ ' class << #' ]
		ifFalse: [ '  << #' ].
	extensionMessage := self isClassExtension
		ifTrue: [ ' extension ' ]
		ifFalse: [ ' ' ].
	^ 'Unable to adopt the method ', self className, metaClassMessage, self selector asString, ' into the package ', self packageName printString, '. The method is not present in the class''s method dictionary.'
%

! Class implementation for 'RwAuditMethodErrorNotification'

!		Instance methods for 'RwAuditMethodErrorNotification'

category: 'Handling'
method: RwAuditMethodErrorNotification
defaultAction
	"record audit error"
	^ true
%

! Class implementation for 'RwAllowChangeRepositoryRevisionOnResolveNotification'

!		Class methods for 'RwAllowChangeRepositoryRevisionOnResolveNotification'

category: 'Instance creation'
classmethod: RwAllowChangeRepositoryRevisionOnResolveNotification
signal: aRwProjectLoadSpecificationV2
	"An exception of the type associated with the receiver is signaled."

	^ self new
		loadSpecification: aRwProjectLoadSpecificationV2;
		signal
%

!		Instance methods for 'RwAllowChangeRepositoryRevisionOnResolveNotification'

category: 'Handling'
method: RwAllowChangeRepositoryRevisionOnResolveNotification
defaultAction
	"By default allow revisions to be changed when resolving a load specification"

	^ false
%

category: 'accessing'
method: RwAllowChangeRepositoryRevisionOnResolveNotification
loadSpecification
	^loadSpecification
%

category: 'accessing'
method: RwAllowChangeRepositoryRevisionOnResolveNotification
loadSpecification: object
	loadSpecification := object
%

! Class implementation for 'RwDeleteClassFromSystemNotification'

!		Instance methods for 'RwDeleteClassFromSystemNotification'

category: 'accessing'
method: RwDeleteClassFromSystemNotification
candidateClass
	"class to be deleted from system, if receiver is #resumed: with true"

	^ candidateClass
%

category: 'accessing'
method: RwDeleteClassFromSystemNotification
candidateClass: aClassToBeDeleted

	candidateClass := aClassToBeDeleted
%

category: 'handling'
method: RwDeleteClassFromSystemNotification
defaultAction

	^ true
%

! Class implementation for 'RwExecuteClassInitializeMethodsAfterLoadNotification'

!		Instance methods for 'RwExecuteClassInitializeMethodsAfterLoadNotification'

category: 'accessing'
method: RwExecuteClassInitializeMethodsAfterLoadNotification
candidateClass
	"class to which #initialize if receiver is #resumed: with true"

	^ candidateClass
%

category: 'accessing'
method: RwExecuteClassInitializeMethodsAfterLoadNotification
candidateClass: aClassToInitialize

	candidateClass := aClassToInitialize
%

category: 'handling'
method: RwExecuteClassInitializeMethodsAfterLoadNotification
defaultAction

	^ true
%

! Class implementation for 'RwExistingAssociationWithSameKeyNotification'

!		Instance methods for 'RwExistingAssociationWithSameKeyNotification'

category: 'handling'
method: RwExistingAssociationWithSameKeyNotification
defaultAction

	self error: self errorMessage
%

category: 'accessing'
method: RwExistingAssociationWithSameKeyNotification
errorMessage

   ^errorMessage
%

category: 'accessing'
method: RwExistingAssociationWithSameKeyNotification
errorMessage: anObject

   errorMessage := anObject
%

! Class implementation for 'RwExistingVisitorAddingExistingClassNotification'

!		Instance methods for 'RwExistingVisitorAddingExistingClassNotification'

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
class
	^class
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
class: object
	class := object
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
classDefinition

	^ classDefinition
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
classDefinition: aClassDefinition

	classDefinition := aClassDefinition
%

category: 'handling'
method: RwExistingVisitorAddingExistingClassNotification
defaultAction

	loadedProject ifNil: [ ^ self error: 'Visitor adding a class ', classDefinition name printString, ' that already exists' ].
	self error: 
		'Visitor adding a class ', 
		classDefinition name printString, 
		' that already exists in the project ', 
		loadedProject name printString, 
		', but the project was not included in the load'
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
loadedProject

	^ loadedProject
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
loadedProject: aLoadedProject

	loadedProject := aLoadedProject
%

! Class implementation for 'RwInvalidCategoryProtocolConventionErrorNotification'

!		Instance methods for 'RwInvalidCategoryProtocolConventionErrorNotification'

category: 'Handling'
method: RwInvalidCategoryProtocolConventionErrorNotification
classCategoryNotificationDo: classCategoryBlock nonExtensionMethodNoficationDo: nonExtensionMethodBlock extensionMethodPackageMismatchNoficationDo: extensionMethodPackageMismatchBlock  extensionMethodNonExtensionProtocolNoficationDo: extensionMethodNonExtensionProtocolBlock
	"helper method for use in exception handling block ... avoid isKindOf:"

	
	self subclassResponsibility: #classCategoryNotificationDo:nonExtensionMethodNoficationDo:extensionMethodPackageMismatchNoficationDo:extensionMethodNonExtensionProtocolNoficationDo:
%

category: 'Handling'
method: RwInvalidCategoryProtocolConventionErrorNotification
defaultAction
 
	^ Error signal: self _errorMessage
%

category: 'accessing'
method: RwInvalidCategoryProtocolConventionErrorNotification
packageConvention

	^ packageConvention
%

category: 'accessing'
method: RwInvalidCategoryProtocolConventionErrorNotification
packageConvention: aString

	packageConvention := aString
%

category: 'accessing'
method: RwInvalidCategoryProtocolConventionErrorNotification
packageName

	^ packageName
%

category: 'accessing'
method: RwInvalidCategoryProtocolConventionErrorNotification
packageName: aString

	packageName := aString
%

category: 'private'
method: RwInvalidCategoryProtocolConventionErrorNotification
_errorMessage

	^ self subclassResponsibility: #_errorMessage
%

! Class implementation for 'RwInvalidClassCategoryConventionErrorNotification'

!		Class methods for 'RwInvalidClassCategoryConventionErrorNotification'

category: 'instance creation'
classmethod: RwInvalidClassCategoryConventionErrorNotification
signalWithClassDefinition: aClassDefinition packageName: packageName packageConvention: aString

	^ self new
			classDefinition: aClassDefinition;
			packageName:  packageName;
			packageConvention: aString;
			signal
%

!		Instance methods for 'RwInvalidClassCategoryConventionErrorNotification'

category: 'Handling'
method: RwInvalidClassCategoryConventionErrorNotification
classCategoryNotificationDo: classCategoryBlock nonExtensionMethodNoficationDo: nonExtensionMethodBlock extensionMethodPackageMismatchNoficationDo: extensionMethodPackageMismatchBlock  extensionMethodNonExtensionProtocolNoficationDo: extensionMethodNonExtensionProtocolBlock
	"class category does not match the package name"

	classCategoryBlock value
%

category: 'accessing'
method: RwInvalidClassCategoryConventionErrorNotification
classDefinition

	^ classDefinition
%

category: 'accessing'
method: RwInvalidClassCategoryConventionErrorNotification
classDefinition: aClassDefinition

	classDefinition := aClassDefinition
%

category: 'private'
method: RwInvalidClassCategoryConventionErrorNotification
_errorMessage

	^ 'The class category ', 
		self classDefinition category printString, 
		' for the class ', 
		self classDefinition name printString, 
		' violates the package convention ', 
		self packageConvention printString
%

! Class implementation for 'RwInvalidMethodProtocolConventionErrorNotification'

!		Class methods for 'RwInvalidMethodProtocolConventionErrorNotification'

category: 'instance creation'
classmethod: RwInvalidMethodProtocolConventionErrorNotification
signalWithMethodDefinition: aMethodDefinition className: className isMeta: isMeta packageName:  packageName packageConvention: aString

	^ self new
			methodDefinition: aMethodDefinition;
			className: className;
			isMeta: isMeta;
			packageName:  packageName;
			packageConvention: aString;
			signal
%

!		Instance methods for 'RwInvalidMethodProtocolConventionErrorNotification'

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
className

	^ className
%

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
className: aString

	className := aString
%

category: 'Handling'
method: RwInvalidMethodProtocolConventionErrorNotification
defaultAction
 
	^ Error signal: self _errorMessage
%

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
isMeta

	^ isMeta
%

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
isMeta: aBool

	isMeta := aBool
%

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
methodDefinition

	^ methodDefinition
%

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
methodDefinition: aMethodDef

	methodDefinition := aMethodDef
%

category: 'private'
method: RwInvalidMethodProtocolConventionErrorNotification
_errorMessage

	^ 'The method protocol ', 
		self methodDefinition protocol printString, 
		' for the method ', 
		self _methodPrintString printString, 
		' in the package ', 
		self packageName printString,
		' violates the package convention ', 
		self packageConvention printString, 
		'. '
%

category: 'private'
method: RwInvalidMethodProtocolConventionErrorNotification
_methodPrintString

	^ self className, (self isMeta ifTrue: [ ' class>>' ] ifFalse: [ '>>' ]), self methodDefinition selector
%

! Class implementation for 'RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification'

!		Instance methods for 'RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification'

category: 'Handling'
method: RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification
classCategoryNotificationDo: classCategoryBlock nonExtensionMethodNoficationDo: nonExtensionMethodBlock extensionMethodPackageMismatchNoficationDo: extensionMethodPackageMismatchBlock  extensionMethodNonExtensionProtocolNoficationDo: extensionMethodNonExtensionProtocolBlock
	"extension method protocol does start with a *, but does not match the package name"

	extensionMethodPackageMismatchBlock value
%

category: 'private'
method: RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification
_errorMessage

	^ super _errorMessage, 'The extension protocol does not match the package of the extension method.'
%

! Class implementation for 'RwExtensionProtocolNonExtensionMethodErrorNotification'

!		Instance methods for 'RwExtensionProtocolNonExtensionMethodErrorNotification'

category: 'Handling'
method: RwExtensionProtocolNonExtensionMethodErrorNotification
classCategoryNotificationDo: classCategoryBlock nonExtensionMethodNoficationDo: nonExtensionMethodBlock extensionMethodPackageMismatchNoficationDo: extensionMethodPackageMismatchBlock  extensionMethodNonExtensionProtocolNoficationDo: extensionMethodNonExtensionProtocolBlock
	"method protocol starts with a * for non-extension method"

	nonExtensionMethodBlock value
%

category: 'private'
method: RwExtensionProtocolNonExtensionMethodErrorNotification
_errorMessage

	^ super _errorMessage, 'The protocol should not start with a *, as the method is NOT an extension method.'
%

! Class implementation for 'RwNonExtensionProtocolExtensionMethodErrorNotification'

!		Instance methods for 'RwNonExtensionProtocolExtensionMethodErrorNotification'

category: 'Handling'
method: RwNonExtensionProtocolExtensionMethodErrorNotification
classCategoryNotificationDo: classCategoryBlock nonExtensionMethodNoficationDo: nonExtensionMethodBlock extensionMethodPackageMismatchNoficationDo: extensionMethodPackageMismatchBlock  extensionMethodNonExtensionProtocolNoficationDo: extensionMethodNonExtensionProtocolBlock
	"extension method protocol doesn't start with a *"

	extensionMethodNonExtensionProtocolBlock value
%

category: 'private'
method: RwNonExtensionProtocolExtensionMethodErrorNotification
_errorMessage

	^ super _errorMessage, 'The protocol should start with a *, as the method IS an extension method.'
%

! Class implementation for 'RwPerformingUnpackagedEditNotification'

!		Instance methods for 'RwPerformingUnpackagedEditNotification'

category: 'handling'
method: RwPerformingUnpackagedEditNotification
defaultAction

	^ self error: self errorMessage
%

category: 'accessing'
method: RwPerformingUnpackagedEditNotification
errorMessage

   ^self informMessage
%

category: 'accessing'
method: RwPerformingUnpackagedEditNotification
informMessage

   ^informMessage
%

category: 'accessing'
method: RwPerformingUnpackagedEditNotification
informMessage: anObject

   informMessage := anObject
%

category: 'signalling'
method: RwPerformingUnpackagedEditNotification
signal: aMessage

	self informMessage: aMessage.
	^ self signal
%

! Class implementation for 'AbstractFileReference'

!		Instance methods for 'AbstractFileReference'

category: 'copying'
method: AbstractFileReference
, extension
	^ self resolve, extension
%

category: 'navigating'
method: AbstractFileReference
/ aString
	"aString is either a file or path.  If aString is relative, it is appended to the receiver, if it is absolute, an instance of the receiver with the path is answered"

	^ self withPath: (self path resolvePath: (self fileSystem pathFromString: aString))
%

category: 'comparing'
method: AbstractFileReference
<= other
	^ self path <= other path
%

category: 'accessing'
method: AbstractFileReference
absolutePath
	"Returns the absolute path"
	
	^ self subclassResponsibility
%

category: 'enumerating'
method: AbstractFileReference
allChildren
	"Return all the files and folders recursively nested in the receiver"
	
	^ CollectVisitor breadthFirst: self resolve collect: [:entry | entry reference]
%

category: 'enumerating'
method: AbstractFileReference
allChildrenMatching: aPattern
    "Return all the files and folders recursively nested in the receiver and matching the pattern, aPattern"
    
    ^ self allChildren select: [ :each |  aPattern match: each basename ]
%

category: 'enumerating'
method: AbstractFileReference
allDirectories
	"Return all the directories recursively nested in the receiver."
	^ (SelectVisitor breadthFirst: self resolve select: [:entry | entry isDirectory ])
		collect: [ :each| each reference ]
%

category: 'enumerating'
method: AbstractFileReference
allDirectoriesMatching: aPattern
    "Return all the directories recursively nested in the receiver."
    ^ (SelectVisitor 
			breadthFirst: self resolve 
			select: [:entry | entry isDirectory and: [ aPattern match: entry basename ] ])
        collect: [ :each | each reference ]
%

category: 'enumerating'
method: AbstractFileReference
allEntries
	^ CollectVisitor breadthFirst: self resolve
%

category: 'enumerating'
method: AbstractFileReference
allFiles
	"Return all the files (not directories) recursively nested in the receiver."
	^ (SelectVisitor breadthFirst: self resolve select: [:entry | entry isFile ])
		collect: [ :each| each reference ]
%

category: 'converting'
method: AbstractFileReference
asAbsolute 
	self subclassResponsibility
%

category: 'converting'
method: AbstractFileReference
asFileReference 
	self subclassResponsibility 
%

category: 'converting'
method: AbstractFileReference
asPath
	"Answer the receiver's path"

	self subclassResponsibility 
%

category: 'delegated'
method: AbstractFileReference
asPathWith: anObject
	^ self resolve asPathWith: anObject
%

category: 'resolving'
method: AbstractFileReference
asResolvedBy: anObject
	^ anObject resolveReference: self
%

category: 'accessing'
method: AbstractFileReference
base
	"Returns the base of the basename, i.e. /foo/gloops.taz base is 'gloops'"
	^ self fullPath base
%

category: 'accessing'
method: AbstractFileReference
basename
	"Returns the basename, i.e. /foo/gloops.taz basename is 'gloops.taz'"
	^ self fullPath basename
%

category: 'accessing'
method: AbstractFileReference
basenameWithIndicator
	"Returns the basename with the indicator appended, i.e. /foo/gloops.taz basenameWithIndicator is 'gloops.taz', whereras /foo basenameWithIndicator is 'foo/'" 
	^ self basename, self indicator   
%

category: 'accessing'
method: AbstractFileReference
basenameWithoutExtension
	"Returns the basename, i.e. /foo/gloops.taz basenameWithoutExtension is 'gloops'"
	^ self fullPath basenameWithoutExtension
%

category: 'accessing'
method: AbstractFileReference
basenameWithoutExtension: anExtension
	"Returns the basename without specified extension (if any)
	('/foo/gloops.taz' asFileReference basenameWithoutExtension: 'taz') = 'gloops'
	"
	^ self fullPath basenameWithoutExtension: anExtension
%

category: 'streams-compatibility'
method: AbstractFileReference
binaryReadStream
	^ self subclassResponsibility
%

category: 'streams-compatibility'
method: AbstractFileReference
binaryReadStreamDo: aBlock
	| stream |
	stream := self binaryReadStream.
	^ [ aBlock value: stream ] 
		ensure: [ stream close ]
%

category: 'streams-compatibility'
method: AbstractFileReference
binaryReadStreamDo: doBlock ifAbsent: absentBlock
	^ self isFile 
		ifTrue: [ self binaryReadStreamDo: doBlock ]
		ifFalse: absentBlock
%

category: 'streams-compatibility'
method: AbstractFileReference
binaryReadStreamIfAbsent: absentBlock
	^ self isFile
		ifTrue: [ self binaryReadStream ]
		ifFalse: absentBlock
%

category: 'streams'
method: AbstractFileReference
binaryWriteStream
	"Answer a binary write stream on the receiver"

	^ self subclassResponsibility
%

category: 'streams'
method: AbstractFileReference
binaryWriteStreamDo: aBlock
	"Pass a binary write stream on the receiver to the supplied block, and ensure that the stream is closed after evaluation."

	| stream |

	stream := self binaryWriteStream.
	^ [ aBlock value: stream ] 
		ensure: [ stream close ]
%

category: 'streams'
method: AbstractFileReference
binaryWriteStreamDo: doBlock ifPresent: presentBlock
	^ self isFile
		ifTrue: presentBlock
		ifFalse: [ self binaryWriteStreamDo: doBlock ]
%

category: 'delegated'
method: AbstractFileReference
canonicalize
	"Answer the receiver with references to the current folder (.) and parent folder (..) removed"

	^ self withPath: self resolve path canonicalize
%

category: 'private'
method: AbstractFileReference
childGeneratorBlock: doBlock matching: patterns
	"
	FileSystem workingDirectory filesMatching: '*'
	FileSystem workingDirectory filesMatching: '*.image;*.changes'
	"
	
	| files reference|
	files := Set new.
	reference := self resolve.
	
	(patterns subStrings: ';', String crlf) do: [ :pattern | 
		doBlock value: reference value: [ :basename|
			(pattern match: basename)
				ifTrue: [ files add: (self / basename) ]]].
	
	^files asOrderedCollection
%

category: 'enumerating'
method: AbstractFileReference
childNames
	^ self children collect: [:each | each basename ]
%

category: 'enumerating'
method: AbstractFileReference
children
	"Answer an array containing references to the direct children of this reference."
	| reference |
	reference := self resolve.
	^ (reference fileSystem childNamesAt: reference path) 
		collect: [ :aName | self / aName ]
%

category: 'enumerating'
method: AbstractFileReference
childrenMatching: patterns
	"
	FileSystem disk workingDirectory childrenMatching: '*'
	FileSystem disk workingDirectory childrenMatching: '*.image;*.changes'
	"
	^ self 
		childGeneratorBlock: [:reference : aBlock| 
			reference fileSystem childNamesAt: reference path do: aBlock ]
		matching:  patterns 
%

category: 'comparing'
method: AbstractFileReference
contains: anObject
	"Return true if anObject is in a subfolder of me"
	^ anObject isContainedBy: self resolve
%

category: 'comparing'
method: AbstractFileReference
containsPath: aPath
	^ self fullPath containsPath: aPath
%

category: 'accessing'
method: AbstractFileReference
contents
	self readStreamDo: [ :stream |
		^ stream contents ]
%

category: 'operations'
method: AbstractFileReference
copyAllTo: aResolvable
	"Performs a deep copy of the receiver, to a location specified by the argument. If the receiver is a file, the file will be copied; if a directory, the directory and its contents will be copied recursively. The argument must be a reference that doesn't exist; it will be created by the copy."
	
	CopyVisitor copy: self resolve asAbsolute to: aResolvable resolve
%

category: 'delegated'
method: AbstractFileReference
copyTo: aReference
	^ self resolve copyTo: aReference resolve
%

category: 'copying'
method: AbstractFileReference
copyWithPath: newPath
	self subclassResponsibility
%

category: 'enumerating'
method: AbstractFileReference
createDirectory
	"Verifies that the directory does not exist and only creates if necessary. Do not remove files contained if they exist.If the parents does not exist return an exception"
	self parent exists ifFalse:[DirectoryDoesNotExist signalWith: self parent path].
	^ self resolve ensureCreateDirectory
%

category: 'enumerating'
method: AbstractFileReference
createFile
	"Create if necessary a file for the receiver. If the parent does not exist return an exception"
	self parent exists ifFalse:[DirectoryDoesNotExist signalWith: self parent path].
	self writeStream close.
	
%

category: 'accessing'
method: AbstractFileReference
creationTime
	^ self resolve creationTime 
%

category: 'operations'
method: AbstractFileReference
delete
	"Delete the receiver, does raise an error if it is not present."
	
	^ self resolve delete
%

category: 'operations'
method: AbstractFileReference
deleteAll
	"Delete this directory and all children of it, raise an error if the file does not exist."
	DeleteVisitor delete: self resolve
%

category: 'operations'
method: AbstractFileReference
deleteAllChildren
	"delete all children of the receiver, raise an error if the receiver does not exist"
	
	self children do: [:aReference | aReference deleteAll ]
%

category: 'operations'
method: AbstractFileReference
deleteIfAbsent: aBlock
	"Delete the receiver, when it does not exist evaluate the block"
	self resolve deleteIfAbsent: aBlock
%

category: 'enumerating'
method: AbstractFileReference
directories
	"Return all the directories (by opposition to files) contained in the receiver"

	| reference |
	reference := self resolve.
	^ (reference fileSystem directoryNamesAt: reference path) 
		collect: [ :aName | self withPath: self path / aName ]
%

category: 'enumerating'
method: AbstractFileReference
directoriesMatching: patterns
	"
	FileSystem disk workingDirectory directoriesMatching: '*'
	FileSystem disk workingDirectory directoriesMatching: 'package-cache'
	"
	^ self 
		childGeneratorBlock: [:reference : aBlock| 
			reference fileSystem directoryNamesAt: reference path do: aBlock ]
		matching:  patterns 
%

category: 'enumerating'
method: AbstractFileReference
directoryNames
	^ self directories collect: #basename
%

category: 'operations'
method: AbstractFileReference
ensureCreateDirectory
	"Verifies that the directory does not exist and only creates if necessary. Do not remove files contained if they exist.Creates the parents if needed"
	^ self resolve ensureCreateDirectory
%

category: 'operations'
method: AbstractFileReference
ensureCreateFile
	"Create if necessary a file for the receiver. If the parent does not exist creates it"
	self parent ensureCreateDirectory.
	self writeStream close.
	
%

category: 'operations'
method: AbstractFileReference
ensureDelete
	"Delete the file and does not raise exception if it does not exist contrary to delete.
	However if it is a directory and it has children an error is signaled. If it is required to 
	delete even with children, use #ensureDeleteAll."
	
	self deleteIfAbsent: [].
%

category: 'operations'
method: AbstractFileReference
ensureDeleteAll
	"Delete this directory and all children of it, and does not raise an error if the file does not exist."
	
	self exists ifFalse: [ ^ self  ].
	self deleteAll
	
%

category: 'operations'
method: AbstractFileReference
ensureDeleteAllChildren
	"delete all children of the receiver and does not raise an error if the receiver does not exist"
	
	self exists ifFalse: [ ^ self  ].
	self deleteAllChildren
%

category: 'enumerating'
method: AbstractFileReference
entries
	^ self resolve entries
%

category: 'accessing'
method: AbstractFileReference
entry
	^ self resolve entry
%

category: 'delegated'
method: AbstractFileReference
exists
	"Return true if the file reference exist (e.g., if there is a file on the hard disk pointed by the file reference)
	
	E.g., (if you are on Unix or OSX)
	'/tmp/' asFileReference exists => true
	'/tmp/zorkbar' asFileReference exists => false
	"
	^ self resolve exists
%

category: 'accessing'
method: AbstractFileReference
extension
	
	^ self fullPath extension.
%

category: 'accessing'
method: AbstractFileReference
extensions
	  "#('foo' 'foo.tar' 'foo.tar.gz' 'foo.1.tar' 'foo.1.tar.gz') collect: [:thing| thing extensions] => #(#() #('tar') #('tar' 'gz') #('1' 'tar') #('1' 'tar' 'gz'))"
	
        ^ self fullPath extensions
%

category: 'enumerating'
method: AbstractFileReference
fileNames
	^ self files collect: #basename
%

category: 'enumerating'
method: AbstractFileReference
files
	"Return all the files (as opposed to folders) contained in the receiver"
	
	| reference |
	reference := self resolve.
	^ (reference fileSystem fileNamesAt: reference path) 
		collect: [ :aName | self withPath: self path / aName ]
%

category: 'enumerating'
method: AbstractFileReference
filesMatching: patterns
	"
	FileSystem disk workingDirectory filesMatching: '*'
	FileSystem disk workingDirectory filesMatching: '*.image;*.changes'
	"
	^ self 
		childGeneratorBlock: [:reference : aBlock| 
			reference fileSystem fileNamesAt: reference path do: aBlock ]
		matching:  patterns 
%

category: 'accessing'
method: AbstractFileReference
fileSystem
	^ self resolve fileSystem
%

category: 'delegated'
method: AbstractFileReference
fullName

	^ self resolve fullName
%

category: 'accessing'
method: AbstractFileReference
fullNameWithIndicator
	"Returns the basename with the indicator appended, i.e. /foo/gloops.taz basenameWithIndicator is '/foo/gloops.taz', whereras /foo basenameWithIndicator is '/foo/'" 
	^ self fullName, self indicator   
%

category: 'accessing'
method: AbstractFileReference
fullPath
	"Returns the absolute path, better use absolutePath"
	
	^ self subclassResponsibility
%

category: 'enumerating'
method: AbstractFileReference
glob: aBlock
	^ SelectVisitor breadthFirst: self resolve select: aBlock
%

category: 'testing'
method: AbstractFileReference
hasChildren
	^self resolve hasChildren
%

category: 'testing'
method: AbstractFileReference
hasDirectories
	^self resolve hasDirectories
%

category: 'testing'
method: AbstractFileReference
hasFiles
	^self resolve hasFiles
%

category: 'comparing'
method: AbstractFileReference
hash
	"Hash is reimplemented because #= is reimplemented"
	^ self path  hash
%

category: 'accessing'
method: AbstractFileReference
humanReadableSize
	^ self size humanReadableSIByteSize
%

category: 'testing'
method: AbstractFileReference
ifFile: fBlock ifDirectory: dBlock ifAbsent: aBlock
	^ self isFile
		ifTrue: fBlock
		ifFalse: [
			self isDirectory
				ifTrue: dBlock
				ifFalse: aBlock ]
%

category: 'printing'
method: AbstractFileReference
indicator
	"Returns a string indicating the type of reference:
	- '?' for a non existing reference',
	- '/' for a directory,
	- the empty string for a file."
	"When this framework gets more complete, it is possible to extend this behavior with the following indicators (taken from unix ls utility):
	- '*' for a regular file that is executable
	- '@' for a symbolic link
	- '|' for FIFOs
	- '=' for sockets
	- '>' for doors"
	^ self exists
		ifTrue: [self isDirectory ifTrue: ['/'] ifFalse: ['']  ]
		ifFalse: ['?']
%

category: 'initialization'
method: AbstractFileReference
initialize
%

category: 'testing'
method: AbstractFileReference
isAbsolute 
	self subclassResponsibility 
%

category: 'testing'
method: AbstractFileReference
isChildOf: anObject
	^ self parent = anObject
%

category: 'comparing'
method: AbstractFileReference
isContainedBy: anObject
	"DoubleDispatch helper for #contains:"
	^ anObject containsReference: self resolve
%

category: 'testing'
method: AbstractFileReference
isDirectory
	^ self resolve isDirectory
%

category: 'testing'
method: AbstractFileReference
isFile
	^ self resolve isFile
%

category: 'testing'
method: AbstractFileReference
isReadable
	^ self resolve isReadable
%

category: 'testing'
method: AbstractFileReference
isRelative 
	self subclassResponsibility 
%

category: 'testing'
method: AbstractFileReference
isRoot
	^ self resolve isRoot
%

category: 'testing'
method: AbstractFileReference
isWritable
	^ self resolve isWritable
%

category: 'accessing'
method: AbstractFileReference
item
	^ self
%

category: 'navigating'
method: AbstractFileReference
makeRelative: anObject
	^ anObject relativeToReference: self resolve
%

category: 'accessing'
method: AbstractFileReference
modificationTime
	^ self resolve modificationTime 
%

category: 'operations'
method: AbstractFileReference
moveTo: aReference
	"Move the receiver in the location passed as argument.
	
	(FileSystem disk workingDirectory / 'paf' ) ensureCreateFile.
	(FileSystem disk workingDirectory / 'fooFolder') ensureCreateDirectory. 
	(FileSystem disk workingDirectory / 'paf' ) moveTo: (FileSystem disk workingDirectory / 'fooFolder' / 'paf')
	"
	^ self resolve moveTo: aReference
%

category: 'utilities'
method: AbstractFileReference
nextVersion
	^ self resolve nextVersion
%

category: 'streams'
method: AbstractFileReference
openWritable: aBoolean
	^ self resolve openWritable: aBoolean
%

category: 'delegated'
method: AbstractFileReference
parent
	^ self withPath: self resolve path parent
%

category: 'delegated'
method: AbstractFileReference
parentUpTo: aParentDirName
	^ self withPath: (self path parentUpTo: aParentDirName)
%

category: 'accessing'
method: AbstractFileReference
pathSegments
	^ self fullPath segments
%

category: 'delegated'
method: AbstractFileReference
pathString
	^ self resolve pathString
%

category: 'accessing'
method: AbstractFileReference
permissions
	"Return the FileSystemPermission for this node"
	^ self resolve permissions
%

category: 'streams'
method: AbstractFileReference
readStream
	self subclassResponsibility
%

category: 'streams'
method: AbstractFileReference
readStreamDo: aBlock
	| stream |
	stream := self readStream.
	^ [ aBlock value: stream ] 
		ensure: [ stream close ]
%

category: 'streams'
method: AbstractFileReference
readStreamDo: doBlock ifAbsent: absentBlock
	^ self isFile 
		ifTrue: [ self readStreamDo: doBlock ]
		ifFalse: absentBlock
%

category: 'streams'
method: AbstractFileReference
readStreamEncoded: anEncoding

	^ ZnCharacterReadStream
		on: self binaryReadStream
		encoding: anEncoding
%

category: 'streams'
method: AbstractFileReference
readStreamEncoded: anEncoding do: aBlock
	| stream |
	stream := self readStreamEncoded: anEncoding.
	^ [ aBlock value: stream ] 
		ensure: [ stream close ]
%

category: 'streams'
method: AbstractFileReference
readStreamIfAbsent: absentBlock
	^ self isFile
		ifTrue: [ self readStream ]
		ifFalse: absentBlock
%

category: 'navigating'
method: AbstractFileReference
relativeTo: landmark
	"Answer a new path relative to landmark."
	
	"parent/child/grandChild relativeTo: parent returns child/grandChild
	(Filesystem disk / 'griffle' / 'plonk' / 'nurp') relativeTo: (Filesystem disk / 'griffle') 
	returns plonk/nurp"

	^ landmark makeRelative: self resolve
%

category: 'navigating'
method: AbstractFileReference
relativeToPath: landmarkPath 
	
	^ self fullPath relativeTo: landmarkPath
%

category: 'navigating'
method: AbstractFileReference
relativeToReference: landmarkReference
	"Return the path of the receiver relative to landmarkReference."
	
	^ self fullPath relativeTo: landmarkReference path
%

category: 'operations'
method: AbstractFileReference
renameTo: newBasename
	self subclassResponsibility
%

category: 'navigating'
method: AbstractFileReference
resolve
	^ self subclassResponsibility 
%

category: 'navigating'
method: AbstractFileReference
resolve: anObject
	^ anObject asResolvedBy: self
%

category: 'navigating'
method: AbstractFileReference
resolvePath: aPath
	^ self withPath: (self path resolvePath: aPath)
%

category: 'navigating'
method: AbstractFileReference
resolveReference: aReference
	^ aReference isAbsolute
		ifTrue: [ aReference ]
		ifFalse: [ self withPath: aReference path ]
%

category: 'navigating'
method: AbstractFileReference
resolveString: aString 
	self subclassResponsibility
%

category: 'accessing'
method: AbstractFileReference
size
	"Return the size of the file in bytes -- Brute force"

	| result |
	result := GsFile sizeOfOnServer: self pathString.
	(result == false or: [ result isNil ])
		ifTrue: [ ^ FileDoesNotExistException signalWith: self pathString ].
	^ result
%

category: 'streams'
method: AbstractFileReference
streamWritable: writable do: aBlock
	^ writable 
		ifTrue: [ self writeStreamDo: aBlock ]
		ifFalse: [ self readStreamDo: aBlock ]
%

category: 'accessing'
method: AbstractFileReference
uri
	"Convert my path into a file:// type url. For odd characters use %20 notation."

	^ self asUrl
%

category: 'navigating'
method: AbstractFileReference
withExtension: aString
	^ self withPath: (self path withExtension: aString)
%

category: 'copying'
method: AbstractFileReference
withoutExtension
  "Returns the new reference based on receiver with fullname without its extension"

  ^  (self parent / self basenameWithoutExtension)
%

category: 'navigating'
method: AbstractFileReference
withPath: newPath
	^ self path == newPath
		ifTrue: [ self ]
		ifFalse: [ self copyWithPath: newPath ]
%

category: 'streams'
method: AbstractFileReference
writeStream
	self subclassResponsibility
%

category: 'streams'
method: AbstractFileReference
writeStreamDo: aBlock
	| stream |
	stream := self writeStream.
	^ [ aBlock value: stream ]
		ensure: [ stream close ]
%

category: 'streams'
method: AbstractFileReference
writeStreamDo: doBlock ifPresent: presentBlock
	^ self isFile
		ifTrue: presentBlock
		ifFalse: [ self writeStreamDo: doBlock ]
%

category: 'streams'
method: AbstractFileReference
writeStreamEncoded: anEncoding

	^ ZnCharacterWriteStream
		on: self binaryWriteStream
		encoding: anEncoding
%

category: 'streams'
method: AbstractFileReference
writeStreamEncoded: anEncoding do: aBlock
	| stream |
	stream := self writeStreamEncoded: anEncoding.
	^ [ aBlock value: stream ]
		ensure: [ stream close ]
%

category: 'streams'
method: AbstractFileReference
writeStreamIfPresent: presentBlock
	^ self isFile 
		ifTrue: presentBlock
		ifFalse: [ self writeStream ]
%

! Class implementation for 'FileLocator'

!		Class methods for 'FileLocator'

category: 'windows-origins'
classmethod: FileLocator
A
	^ self driveNamed: #A 
%

category: 'adding'
classmethod: FileLocator
addResolver: aResolver
	self resolver addResolver: aResolver
%

category: 'windows-origins'
classmethod: FileLocator
B
	^ self driveNamed: #B
%

category: 'windows-origins'
classmethod: FileLocator
C
	^ self driveNamed: #C
%

category: 'origins'
classmethod: FileLocator
cache
	^ self origin: #cache
%

category: 'gemstone-origins'
classmethod: FileLocator
clientWorkingDirectory
	^ FileSystem client referenceTo: RelativePath new
%

category: 'origins'
classmethod: FileLocator
cwd
	^ self workingDirectory
%

category: 'windows-origins'
classmethod: FileLocator
D
	^ self driveNamed: #D
%

category: 'gemstone-origins'
classmethod: FileLocator
dbfScratchDir
	"Answer the path to the DBF_SCRATCH_DIR"

	^ self origin: #dbfScratchDir
%

category: 'origins'
classmethod: FileLocator
desktop
	^ self origin: #desktop
%

category: 'origins'
classmethod: FileLocator
documents
	^ self origin: #documents
%

category: 'windows-origins'
classmethod: FileLocator
driveNamed: driveName
	^ FileReference fileSystem: (FileSystem disk) path: Path / (driveName, ':')
%

category: 'windows-origins'
classmethod: FileLocator
E
	^ self driveNamed: #E
%

category: 'gemstone-origins'
classmethod: FileLocator
extent1
	"Answer the path to the first exent extent"

	^ self origin: #extent1
%

category: 'gemstone-origins'
classmethod: FileLocator
extent1Directory

	^ self origin: #extent1Directory
%

category: 'gemstone-origins'
classmethod: FileLocator
extent: extentIndex
	"Answer the path to the extent at extentIndex in DBF_EXTENT_NAMES: (System stoneConfigurationReport at: #DBF_EXTENT_NAMES) at: extentIndex"

	^ self origin: ('extent', extentIndex printString) asSymbol
%

category: 'windows-origins'
classmethod: FileLocator
F
	^ self driveNamed: #F
%

category: 'flushing'
classmethod: FileLocator
flushCaches
	self resolver flushCaches
%

category: 'windows-origins'
classmethod: FileLocator
G
	^ self driveNamed: #G
%

category: 'gemstone-origins'
classmethod: FileLocator
gemLogDirectory
	"locator for the log directory (parent directory of gemLog)"

	^ self origin: #gemLogDirectory
%

category: 'windows-origins'
classmethod: FileLocator
H
	^ self driveNamed: #H
%

category: 'origins'
classmethod: FileLocator
home
	^ self origin: #home
%

category: 'windows-origins'
classmethod: FileLocator
I
	^ self driveNamed: #I
%

category: 'gemstone-origins'
classmethod: FileLocator
image
	"commonly used, so we need to define it, but the closest that GemStone comes is the #dbfScratchDir"

	^ self dbfScratchDir
%

category: 'gemstone-origins'
classmethod: FileLocator
imageDirectory
	"commonly used, so we need to define it, but the closest that GemStone comes is the #dbfScratchDir"

	^ self dbfScratchDir
%

category: 'windows-origins'
classmethod: FileLocator
J
	^ self driveNamed: #J
%

category: 'windows-origins'
classmethod: FileLocator
K
	^ self driveNamed: #K
%

category: 'windows-origins'
classmethod: FileLocator
L
	^ self driveNamed: #L
%

category: 'windows-origins'
classmethod: FileLocator
M
	^ self driveNamed: #M
%

category: 'windows-origins'
classmethod: FileLocator
N
	^ self driveNamed: #N
%

category: 'windows-origins'
classmethod: FileLocator
O
	^ self driveNamed: #O
%

category: 'instance creation'
classmethod: FileLocator
origin: aSymbol 
	^ self origin: aSymbol path: Path workingDirectory
%

category: 'instance creation'
classmethod: FileLocator
origin: aSymbol path: aPath
	^ self basicNew 
			initializeWithOrigin: aSymbol path: aPath
%

category: 'windows-origins'
classmethod: FileLocator
P
	^ self driveNamed: #P
%

category: 'origins'
classmethod: FileLocator
preferences
	^ self origin: #preferences
%

category: 'windows-origins'
classmethod: FileLocator
Q
	^ self driveNamed: #Q
%

category: 'windows-origins'
classmethod: FileLocator
R
	^ self driveNamed: #R
%

category: 'accessing'
classmethod: FileLocator
resolver

	^ SessionTemps current at: #FileLocator_Resolver ifAbsentPut: [
		InteractiveResolver new
			addResolver: SystemResolver new;
			addResolver: PlatformResolver forCurrentPlatform;
			yourself ]
%

category: 'origins'
classmethod: FileLocator
root
	^ FileSystem disk root
%

category: 'windows-origins'
classmethod: FileLocator
S
	^ self driveNamed: #S
%

category: 'gemstone-origins'
classmethod: FileLocator
serverWorkingDirectory
	^ FileSystem server referenceTo: RelativePath new
%

category: 'accessing'
classmethod: FileLocator
supportedOrigins
	| origins current |
	origins := IdentitySet new.
	current := self resolver.
	[current notNil] whileTrue:
		[origins addAll: current supportedOrigins.
		current := current next].
	^ origins
%

category: 'mac-origins'
classmethod: FileLocator
systemApplicationSupport
	^ self origin: #systemApplicationSupport
%

category: 'mac-origins'
classmethod: FileLocator
systemLibrary
	^ self origin: #systemLibrary
%

category: 'windows-origins'
classmethod: FileLocator
T
	^ self driveNamed: #T
%

category: 'origins'
classmethod: FileLocator
temp
	^ self origin: #temp
%

category: 'gemstone-origins'
classmethod: FileLocator
tranlog
	"Answer the path to the current tranlog directory"

	^ self origin: #tranlog
%

category: 'windows-origins'
classmethod: FileLocator
U
	^ self driveNamed: #U
%

category: 'mac-origins'
classmethod: FileLocator
userApplicationSupport
	^ self origin: #userApplicationSupport
%

category: 'unix-origins'
classmethod: FileLocator
userData
	^ self origin: #userData
%

category: 'mac-origins'
classmethod: FileLocator
userLibrary
	^ self origin: #userLibrary
%

category: 'windows-origins'
classmethod: FileLocator
V
	^ self driveNamed: #V
%

category: 'windows-origins'
classmethod: FileLocator
W
	^ self driveNamed: #W
%

category: 'origins'
classmethod: FileLocator
workingDirectory
	^ FileSystem disk referenceTo: RelativePath new
%

category: 'windows-origins'
classmethod: FileLocator
X
	^ self driveNamed: #X
%

category: 'windows-origins'
classmethod: FileLocator
Y
	^ self driveNamed: #Y
%

category: 'windows-origins'
classmethod: FileLocator
Z
	^ self driveNamed: #Z
%

!		Instance methods for 'FileLocator'

category: 'comparing'
method: FileLocator
= other
	^ self species = other species
		and: [origin = other origin
			and: [path = other path]]
%

category: 'accessing'
method: FileLocator
absolutePath
	"Return the absolute path"
	^ self resolve path
%

category: 'converting'
method: FileLocator
asAbsolute
	^ self 
%

category: 'converting'
method: FileLocator
asFileReference
	^ self resolve
%

category: 'converting'
method: FileLocator
asPath
	"Answer the receiver's path"

	^self resolve asPath
%

category: 'streams-compatibility'
method: FileLocator
binaryReadStream
	^ self resolve binaryReadStream
%

category: 'streams-compatibility'
method: FileLocator
binaryWriteStream
	"Answer a binary write stream on the receiver"

	^ self resolve binaryWriteStream
%

category: 'copying'
method: FileLocator
copyWithPath: newPath
	^ self class origin: origin path: newPath
%

category: 'error handling'
method: FileLocator
doesNotUnderstand: aMessage
	"Redirect message to the resolved version of this FileLocator.
	If FileReference won't understand the message send a normal DNU."

	| resolved |
	
	resolved := self resolve.
	(resolved respondsTo: aMessage selector)
		ifTrue: [ ^ resolved perform: aMessage selector withArguments: aMessage arguments ].
	
	^ super doesNotUnderstand: aMessage.
%

category: 'accessing'
method: FileLocator
fullPath
	^ self resolve path
%

category: 'comparing'
method: FileLocator
hash
	^ origin hash bitXor: path hash
%

category: 'initialize-release'
method: FileLocator
initializeWithOrigin: aSymbol path: aPath
	self initialize.
	origin := aSymbol.
	path := aPath.
%

category: 'testing'
method: FileLocator
isAbsolute
	^ true
%

category: 'testing'
method: FileLocator
isRelative
	^ false
%

category: 'accessing'
method: FileLocator
origin
	^ origin
%

category: 'accessing'
method: FileLocator
path
	^ path
%

category: 'printing'
method: FileLocator
printOn: aStream
	| fs |
	aStream
		nextPut: ${;
		nextPutAll: origin;
		nextPut: $}.
	path isWorkingDirectory
		ifTrue: [ ^ self ].
	fs := self fileSystem.
	aStream nextPut: fs delimiter.
	fs printPath: path on: aStream
%

category: 'streams'
method: FileLocator
readStream
	^ self resolve readStream 
%

category: 'operations'
method: FileLocator
renameTo: newBasename
	
	| result |
	result := self resolve renameTo: newBasename.
	path size > 0
		ifTrue: [ path basename: newBasename ]
		ifFalse: [ path := result path ]
%

category: 'navigating'
method: FileLocator
resolve
	^ (self class resolver resolve: origin) resolve: path
%

category: 'navigating'
method: FileLocator
resolveString: aString
	| filesystem thePath |
	filesystem := (self class resolver resolve: origin) fileSystem.
	thePath := filesystem pathFromString: aString.
	^ self withPath: (path resolvePath: thePath)
%

category: 'streams'
method: FileLocator
writeStream
	^ self resolve writeStream 
%

! Class implementation for 'FileReference'

!		Class methods for 'FileReference'

category: 'cross platform'
classmethod: FileReference
/ aString
	"Answer a reference to the argument resolved against the root of the current disk filesystem."
	
	^ FileSystem disk / aString
%

category: 'instance creation'
classmethod: FileReference
fileSystem: aFilesystem path: aPath
	^ self new setFileSystem: aFilesystem path: aPath
%

category: 'instance creation'
classmethod: FileReference
newTempFilePrefix: prefix suffix: suffix
	| tmpDir random fileName |
	
	tmpDir := FileLocator temp asFileReference.
	[ 
		random := UUID new asInteger asString.
		fileName := prefix , random , suffix.
		(tmpDir / fileName) exists ] whileTrue.
	^ tmpDir / fileName
%

!		Instance methods for 'FileReference'

category: 'navigating'
method: FileReference
, extension
	^ self withPath: self path, extension
%

category: 'comparing'
method: FileReference
= other
	"Two FileReferences are considered equal if they refer to the same file / directory.
	As paths can have multiple relative representations, compare the absolute paths."
	"Perform the path comparison last as conversion to absolute paths is relatively expensive"
	^ self species = other species
		and: [self fileSystem = other fileSystem
			and: [self absolutePath = other absolutePath]]
%

category: 'accessing'
method: FileReference
absolutePath
	"Return the absolute of the receiver"
	^ self path isRelative
		ifFalse: [ self path ]
		ifTrue: [ filesystem resolve: self path ]
%

category: 'converting'
method: FileReference
asAbsolute
	"Return the receiver as an absolute file reference."
	
	^ self isAbsolute
		ifTrue: [ self ]
		ifFalse: [ filesystem referenceTo: (filesystem resolve: path) ]
%

category: 'converting'
method: FileReference
asFileReference
	^ self
%

category: 'converting'
method: FileReference
asPath
	"Answer the receivers path"

	^path
%

category: 'printing'
method: FileReference
asString
  "needed for informative topaz stack display"
  ^ path asString 
%

category: 'streams'
method: FileReference
binaryReadStream
	
	^ filesystem binaryReadStreamOn: self path
%

category: 'streams'
method: FileReference
binaryWriteStream
	"Answer a binary write stream on the receiver"

	^ ZnBufferedWriteStream on: (filesystem binaryWriteStreamOn: self path)
%

category: 'comparing'
method: FileReference
containsReference: aReference
	^  aReference fileSystem = filesystem and: [path contains: aReference path]
%

category: 'operations'
method: FileReference
copyTo: aReference
	self isDirectory
		ifTrue: [ aReference ensureCreateDirectory ]
		ifFalse: [ filesystem copy: path toReference: aReference ]
%

category: 'copying'
method: FileReference
copyWithPath: newPath
	^ filesystem referenceTo: newPath
%

category: 'accessing'
method: FileReference
creationTime 
	^ filesystem creationTimeOf: self path
%

category: 'operations'
method: FileReference
delete
	"Deletes the referenced file or directory. If the directory is not empty, 
	raises an error. Use #deleteAll to delete with the children."

	(self isDirectory and:[self hasChildren]) 
		ifTrue:[DirectoryIsNotEmpty signalWith: self].
	filesystem delete: path
%

category: 'operations'
method: FileReference
deleteIfAbsent: aBlock
	self exists 
		ifTrue: [ self delete ]
		ifFalse: aBlock
%

category: 'operations'
method: FileReference
ensureCreateDirectory
	"Create if necessary a directory for the receiver."
	filesystem ensureCreateDirectory: path
	
%

category: 'navigating'
method: FileReference
entries
	"Return the entries (meta data - file description) of the direct children of the receiver"
	^ self fileSystem entriesAt: self path 
%

category: 'accessing'
method: FileReference
entry
	"Return the entry (meta data) describing the receiver."
	^ filesystem entryAt: path
%

category: 'testing'
method: FileReference
exists
	^ filesystem exists: path
%

category: 'accessing'
method: FileReference
fileSystem
	"Return the filesystem to which the receiver belong."
	^ filesystem
%

category: 'accessing'
method: FileReference
fullName
	"Return the full path name of the receiver."
	^ filesystem stringFromPath: (filesystem resolve: path)
%

category: 'accessing'
method: FileReference
fullPath
	^ self path
%

category: 'testing'
method: FileReference
hasChildren
	"Return whether the receiver has any children."
	"FileSystem workingDirectory hasChildren"
	
	^ filesystem hasChildren: path
%

category: 'testing'
method: FileReference
hasDirectories
	"Return whether the receiver has children that are directories."
	"FileSystem workingDirectory hasDirectories"
	
	^ filesystem hasDirectories: path
%

category: 'testing'
method: FileReference
hasFiles
	"Return whether the receiver has children that are files."
	"FileSystem workingDirectory hasFiles"
	
	^ filesystem hasFiles: path
%

category: 'comparing'
method: FileReference
hash
	^ path hash bitXor: filesystem hash
%

category: 'testing'
method: FileReference
isAbsolute
	^ path isAbsolute
%

category: 'testing'
method: FileReference
isDirectory
	^ filesystem isDirectory: path
%

category: 'testing'
method: FileReference
isFile
	^ filesystem isFile: path
%

category: 'testing'
method: FileReference
isReadable
	^ filesystem isReadable: path
%

category: 'testing'
method: FileReference
isRelative
	^ path isRelative
%

category: 'testing'
method: FileReference
isRoot
	^ path isRoot
%

category: 'testing'
method: FileReference
isSymlink 
	^ filesystem isSymlink: path
%

category: 'testing'
method: FileReference
isWritable
	^ filesystem isWritable: path
%

category: 'utilities'
method: FileReference
lastFileFor: baseFileName extension: extension
  "Assumes a file is named using a version number encoded as '.' followed by digits
  preceding the file extension, e.g., games.22.ston
  Answer the file name with the largest number.
  If a version number is not found, raises an error"

  "FileSystem workingDirectory lastFileFor: 'games' extension: 'ston'"

    | files |
    files := self childrenMatching: baseFileName , '.*.' , extension.
    files ifEmpty: [ ^ self error: 'No file with number pattern' ].
    ^ (files asSortedCollection: [ :a :b | a basename < b basename ]) last
%

category: 'accessing'
method: FileReference
modificationTime 
	"Returns the last date of modification of self"
	^ filesystem modificationTimeOf: self path
%

category: 'operations'
method: FileReference
moveTo: aReference
	
	| result |
	result := self fileSystem 
		move: self path
		to: aReference resolve.
	result ifNotNil: [
		self setFileSystem: result fileSystem path: result path ].		
%

category: 'utilities'
method: FileReference
nextNameFor: baseFileName extension: extension
  "Assumes a file name includes a version number encoded as '.' followed by digits 
   preceding the file extension, e.g., games.22.ston
   Increment the version number (of the largest one) and answer the new file name, e.g., games23.ston
   If a version number is not found, set the version to 1 and answer a new file name"

	"(FileSystem workingDirectory nextNameFor: 'games' extension: 'ston') asFileReference ensureCreateFile"

	| files splits version |
	files := self childrenMatching: baseFileName , '.*.' , extension.
	files ifEmpty: [ ^ baseFileName , '.1.' , extension ].
	splits := files
		collect: [ :filename | filename basename splitOn: $. ]
		thenSelect: [ :split | (split at: 1) = baseFileName and: [ split size = 3 ] ].
	splits := splits asSortedCollection: [ :a :b | (a at: 2) asNumber < (b at: 2) asNumber ].
	version := splits isEmpty
		ifTrue: [ 1 ]
		ifFalse: [ (splits last at: 2) asNumber + 1 ].
	^ baseFileName , '.' , version asString , '.' , extension
%

category: 'utilities'
method: FileReference
nextVersion
	"Assumes a file (or folder) name includes a version number encoded as '.' followed by digits 
	preceding the file extension.  Increment the version number and answer the new file name.
	If a version number is not found, return just the file"

	| parent version versionNumbers nameWithoutExtension |
	
	self exists
		ifFalse: [ ^ self ].
	
	parent := self parent.
	nameWithoutExtension := self basename copyUpTo: $..
	
	versionNumbers := parent children 
				select: [ :f| 
					(f basename beginsWith: nameWithoutExtension) ]
				thenCollect: [ :f| 
					Number squeezeNumberOutOfString: (f basename copyLast: (f basename size - nameWithoutExtension size))   ifFail: [ 0 ]].
	
	versionNumbers ifEmpty: [ ^self ].
	
	version := versionNumbers max + 1.
	^ parent / (nameWithoutExtension , '.', version asString) , self extension
%

category: 'streams'
method: FileReference
openWritable: aBoolean 
	^ filesystem open: path writable: aBoolean
%

category: 'accessing'
method: FileReference
path
	"Return the path internal representation that denotes the receiver in the context of its filesystem. "
	^ path
%

category: 'printing'
method: FileReference
pathString
	"Return the full path name of the receiver."
	
	^ filesystem stringFromPath: (filesystem resolve: path)
%

category: 'accessing'
method: FileReference
permissions
	^ filesystem permissions: self path
%

category: 'printing'
method: FileReference
printOn: aStream
	filesystem forReferencePrintOn: aStream.
	filesystem printPath: path on: aStream
%

category: 'streams'
method: FileReference
readStream

	^ self readStreamEncoded: 'utf8'
%

category: 'operations'
method: FileReference
renameTo: newBasename
	
	| destinationPath |
	destinationPath := self fileSystem 
		rename: self 
		to: self parent / newBasename.
	
	destinationPath ifNotNil: [
		self 
			setFileSystem: filesystem 
			path: destinationPath ].
	^ self
		
%

category: 'accessing'
method: FileReference
resolve
	^ self
%

category: 'resolving'
method: FileReference
resolvePath: anObject
	^ self withPath: (path resolve: anObject)
%

category: 'resolving'
method: FileReference
resolveReference: aReference
	
	^ (filesystem = aReference fileSystem or: [aReference isRelative])
		ifTrue: [filesystem referenceTo: (path resolvePath: aReference path)]
		ifFalse: [aReference]
%

category: 'resolving'
method: FileReference
resolveString: aString 
	| thePath |
	thePath := filesystem pathFromString: aString.
	^ filesystem referenceTo: (path resolve: thePath)
%

category: 'initialize-release'
method: FileReference
setFileSystem: aFilesystem path: aPath
	filesystem := aFilesystem.
	path := aPath
%

category: 'accessing'
method: FileReference
size
	^ filesystem sizeOf: path
%

category: 'streams'
method: FileReference
writeStream
	
	^ self writeStreamEncoded: 'utf8'
%

! Class implementation for 'CypressAbstractPackageFiler'

!		Class methods for 'CypressAbstractPackageFiler'

category: 'instance creation'
classmethod: CypressAbstractPackageFiler
forRepository: aCypressFileSystemRepository

	^self new
		initializeForRepository: aCypressFileSystemRepository;
		yourself.
%

!		Instance methods for 'CypressAbstractPackageFiler'

category: 'private'
method: CypressAbstractPackageFiler
fileUtils

	^CypressFileUtilities current
%

category: 'initializing - private'
method: CypressAbstractPackageFiler
initializeForRepository: aCypressFileSystemRepository

	repository := aCypressFileSystemRepository
%

category: 'accessing'
method: CypressAbstractPackageFiler
packageDirectory

	^packageDirectory
%

category: 'accessing'
method: CypressAbstractPackageFiler
packageDirectory: aDirectory

	packageDirectory := aDirectory
%

category: 'accessing'
method: CypressAbstractPackageFiler
packageStructure

	^packageStructure
%

category: 'accessing'
method: CypressAbstractPackageFiler
packageStructure: aPackageStructure

	packageStructure := aPackageStructure
%

category: 'accessing'
method: CypressAbstractPackageFiler
propertiesFileNameExtension

	^'.ston'
%

category: 'accessing'
method: CypressAbstractPackageFiler
propertiesFileNameExtensions

	^Array with: self propertiesFileNameExtension
%

category: 'accessing'
method: CypressAbstractPackageFiler
repository

	^repository
%

category: 'private'
method: CypressAbstractPackageFiler
string: aString endsWith: subString
	"Answer whether the last characters of aString are the same as subString."

	| expectedStart |
	expectedStart := aString size - subString size + 1 max: 1.
	^expectedStart
		= (aString indexOfSubCollection: subString startingAt: expectedStart)
%

! Class implementation for 'CypressAbstractFileoutWriter'

!		Instance methods for 'CypressAbstractFileoutWriter'

category: 'accessing'
method: CypressAbstractFileoutWriter
classesInDependencyOrder

	^(CypressGsGeneralDependencySorter
		on: self packageStructure classes
		dependsOn: [:candidate | candidate superclassName]
		dependent: [:candidate | candidate className]) inOrder
%

category: 'accessing'
method: CypressAbstractFileoutWriter
classesWithInitializers

	^self classesInDependencyOrder
		select: [:each | each classMethods anySatisfy: [:method | method selector = 'initialize']]
%

category: 'private'
method: CypressAbstractFileoutWriter
determinePackageDirectory

	^self fileUtils ensureDirectoryExists: self repository directoryPath
%

category: 'accessing'
method: CypressAbstractFileoutWriter
extensions

	^self packageStructure extensions
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOut: aString implementationsFrom: someClassStructures on: aStream

	someClassStructures
		do: [:each | self fileOutType: aString implementationOf: each on: aStream]
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOut: aString methods: someMethodStructures on: aStream

	someMethodStructures isEmpty ifTrue: [^self].
	self
		fileOut: aString methodsPreambleFor: someMethodStructures any classStructure on: aStream;
		fileOutMethods: someMethodStructures on: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutClassDeclarationsOn: aStream

	self classesInDependencyOrder
		do: [:classStructure | self fileOutClassDeclaration: classStructure on: aStream]
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutClassesOn: aStream

	self
		fileOutClassesPreambleOn: aStream;
		fileOutClassDeclarationsOn: aStream;
		fileOutClassImplementationsOn: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutClassImplementationsOn: aStream

	self
		fileOut: 'Class Implementation'
		implementationsFrom: self classesInDependencyOrder
		on: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutClassInitializersOn: aStream

	self fileOutClassInitializersPreambleOn: aStream.
	self classesWithInitializers do: [:each | self fileOutClassInitializerFor: each on: aStream].
	self fileOutClassInitializersPostambleOn: aStream.
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutExtensionImplementationsOn: aStream
  | sortedExtensions |
  sortedExtensions := self extensions
    asSortedCollection: [ :a :b | a className <= b className ].
  self
    fileOut: 'Class Extension'
    implementationsFrom: sortedExtensions
    on: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutExtensionsOn: aStream

	self
		fileOutExtensionsPreambleOn: aStream;
		fileOutExtensionImplementationsOn: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutMethods: someMethodStructures on: aStream

	(someMethodStructures
		asSortedCollection: [:a :b | a selector <= b selector])
			do: [:methodStructure | self fileOutMethod: methodStructure on: aStream]
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutPackageOn: aStream

	self
		fileOutPackagePreambleOn: aStream;
		fileOutClassesOn: aStream;
		fileOutExtensionsOn: aStream;
		fileOutClassInitializersOn: aStream;
		fileOutPackagePostambleOn: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutType: aString implementationOf: classStructure on: aStream

	self
		fileOutPreambleType: aString
			for: classStructure
			on: aStream;
		fileOut: 'Class'
			methods: classStructure classMethods
			on: aStream;
		fileOut: 'Instance'
			methods: classStructure instanceMethods
			on: aStream
%

category: 'accessing'
method: CypressAbstractFileoutWriter
packageName

	^self packageStructure packageName
%

category: 'accessing'
method: CypressAbstractFileoutWriter
packageNameExtension

	^self subclassResponsibility: #packageNameExtension
%

category: 'writing'
method: CypressAbstractFileoutWriter
writePackageStructure

	CypressFileUtilities current
		writeStreamFor: self packageStructure packageName
				, self packageNameExtension
		in: self packageDirectory
		do: [:fileStream | self fileOutPackageOn: fileStream]
%

category: 'writing'
method: CypressAbstractFileoutWriter
writePackageStructure: aPackageStructure

	self
		packageStructure: aPackageStructure;
		packageDirectory: self determinePackageDirectory;
		writePackageStructure
%

! Class implementation for 'CypressSmalltalkFileoutWriter'

!		Instance methods for 'CypressSmalltalkFileoutWriter'

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOut: aString methodsPreambleFor: classStructure on: aStream

	self
		writeChunk: '" ------------------- ' , aString , ' methods for '
				, classStructure name , '"'
		on: aStream.
	aStream
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutClassDeclaration: classStructure on: aStream
	"This is the structure for VW/Pharo  class definitions. It may or may not be portable
	to all dialects that use chunk-format fileins. It does not attempt to handle VW
	namespaces at this time. Probably should use an XML fileout for that."

	aStream
		nextPutAll: classStructure superclassName;
		nextPutAll: ' subclass: #';
		nextPutAll: classStructure className;
		lf;
		nextPutAll: '	instanceVariableNames:  ''';
		nextPutAll: classStructure instanceVariablesString;
		nextPut: $';
		lf;
		nextPutAll: '	classVariableNames: ''';
		nextPutAll: classStructure classVariablesString;
		nextPut: $';
		lf;
		nextPutAll: '	poolDictionaries: ''';
		nextPutAll: classStructure poolDictionariesString;
		nextPut: $';
		lf;
		nextPutAll: '	category: ''';
		nextPutAll: classStructure category.
	self writeChunk: '''' on: aStream.
	aStream
		lf;
		lf;
		nextPutAll: classStructure className;
		nextPutAll: ' comment:';
		lf.
	self writeChunk: classStructure comment printString on: aStream.
	aStream
		lf;
		lf;
		nextPutAll: classStructure className;
		nextPutAll: ' class instanceVariableNames: ''';
		nextPutAll: classStructure classInstanceVariablesString.
	self writeChunk: '''' on: aStream.
	aStream
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutClassesPreambleOn: aStream

	self writeChunk: '" Class Declarations "' on: aStream.
	aStream
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutClassInitializerFor: classStructure on: aStream

	self writeChunk: classStructure className , ' initialize.' on: aStream.
	aStream lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutClassInitializersPostambleOn: aStream

	aStream
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutClassInitializersPreambleOn: aStream

	self writeChunk: '" Class initializers "' on: aStream.
	aStream
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutExtensionsPreambleOn: aStream

	self writeChunk: '" Class Extensions "' on: aStream.
	aStream
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutMethod: methodStructure on: aStream

	aStream nextPutAll: '!'.
	self
		writeChunk: methodStructure classStructure className
				, (methodStructure isMetaclass
						ifTrue: [' class methodsFor: ']
						ifFalse: [' methodsFor: '])
					, methodStructure category printString
		on: aStream.
	aStream lf.
	self
		writeChunk: methodStructure source on: aStream;
		writeChunk: ' ' on: aStream.
	aStream lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutPackagePostambleOn: aStream

	aStream
		lf;
		lf.
	self writeChunk: '" End of Package: ' , self packageName , '"' on: aStream.
	aStream
		lf;
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutPackagePreambleOn: aStream

	self writeChunk: '" Package: ' , self packageName , '"' on: aStream.
	aStream
		lf;
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutPreambleType: aString for: classStructure on: aStream

	self writeChunk: '" ' , aString , ' for ' , classStructure name , '"'
		on: aStream.
	aStream
		lf;
		lf
%

category: 'accessing'
method: CypressSmalltalkFileoutWriter
packageNameExtension

	^'.st'
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
writeChunk: aString on: aStream

	aString do: 
			[:each |
			aStream nextPut: each.
			each = $! ifTrue: [aStream nextPut: each]].
	aStream nextPut: $!
%

! Class implementation for 'CypressTopazFileoutWriter'

!		Instance methods for 'CypressTopazFileoutWriter'

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOut: aString methodsPreambleFor: classStructure on: aStream

	aStream
		nextPutAll: '! ------------------- ', aString, ' methods for ', classStructure name; lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutClassDeclaration: classStructure on: aStream
  aStream
    nextPutAll: 'doit';
    lf;
    nextPutAll: '(' , classStructure superclassName;
    lf.
  self
    writeClassTypeMessage: classStructure
    on: aStream
    hasInstanceVariables: [ aStream
        nextPutAll:
            '	instVarNames: #( ' , classStructure instanceVariablesString , ' )';
        lf ].
  aStream
    nextPutAll: '	classVars: #( ' , classStructure classVariablesString , ' )';
    lf;
    nextPutAll:
        '	classInstVars: #( ' , classStructure classInstanceVariablesString , ' )';
    lf;
    nextPutAll: '	poolDictionaries: #()';
    lf;
    nextPutAll: '	inDictionary: UserGlobals';
    lf;
    nextPutAll: '	options: #())';
    lf;
    nextPutAll: '		category: ' , classStructure category printString , ';';
    lf;
    nextPutAll: '		comment: ' , classStructure comment printString , ';';
    lf;
    nextPutAll: '		immediateInvariant.';
    lf;
    nextPutAll: 'true.';
    lf;
    nextPutAll: '%';
    lf;
    lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutClassesPreambleOn: aStream

	aStream
		nextPutAll: '! Class Declarations'; lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutClassInitializerFor: classStructure on: aStream

	aStream
		nextPutAll: classStructure className, ' initialize.'; lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutClassInitializersPostambleOn: aStream

	aStream
                nextPutAll: 'true.'; lf;
		nextPutAll: '%'; lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutClassInitializersPreambleOn: aStream

	aStream
		nextPutAll: '! Class initializers '; lf;
		lf;
		nextPutAll: 'doit'; lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutExtensionsPreambleOn: aStream

	aStream
		nextPutAll: '! Class Extensions'; lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutMethod: methodStructure on: aStream

	aStream
		nextPutAll: 'category: ', methodStructure category printString; lf;
		nextPutAll: (methodStructure isMetaclass ifTrue: ['classmethod: '] ifFalse: ['method: ']), methodStructure classStructure className; lf;
		nextPutAll: methodStructure source.
	methodStructure source last = Character lf
		ifFalse: [aStream lf].
	aStream nextPutAll: '%'; lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutPackagePostambleOn: aStream

	aStream
		lf;
		lf;
		nextPutAll: '! End of Package: ', self packageName; lf;
		lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutPackagePreambleOn: aStream

	aStream
		nextPutAll: '! Package: ', self packageName; lf;
		lf;
		lf;
		nextPutAll: '! Remove existing behavior from package ', self packageName; lf;
		nextPutAll: '!!!! This can be cleaned up when some package functionality is moved to the base system.'; lf;
		lf;
		nextPutAll: 'doit'; lf;
		nextPutAll: '| packageName |'; lf;
		nextPutAll: 'packageName := ', self packageName printString, '.'; lf;
		nextPutAll: 'System myUserProfile symbolList do: [:symDict |'; lf;
		nextPutAll: '	symDict do: [:possibleClass |'; lf;
		nextPutAll: '			| toRemove |'; lf;
		nextPutAll: '		possibleClass isBehavior ifTrue: ['; lf;
		nextPutAll: '			{possibleClass. possibleClass class} do: [:aClass |'; lf;
		nextPutAll: '				aClass category = packageName'; lf;
		nextPutAll: '					ifTrue: ['; lf;
		nextPutAll: '							"*anythingbutpackagename[-anything]"'; lf;
		nextPutAll: '						toRemove := aClass categoryNames select: '; lf;
		nextPutAll: '										[:each |'; lf;
		nextPutAll: '										each isEmpty not and: ['; lf;
		nextPutAll: '											(each first = $* and: [(each size = (packageName size + 1) and: [(each findStringNoCase: packageName startingAt: 2) = 2])'; lf;
		nextPutAll: '														or: [each size > (packageName size + 1) and: [(each findStringNoCase: packageName startingAt: 2) = 2 and: [(each at: packageName size + 2) = $-]]]])'; lf;
		nextPutAll: '											or: [each first ~= $*]]]'; lf;
		nextPutAll: '					]'; lf;
		nextPutAll: '					ifFalse: ['; lf;
		nextPutAll: '							"*packagename[-anything]"'; lf;
		nextPutAll: '						toRemove := aClass categoryNames select: '; lf;
		nextPutAll: '										[:each |'; lf;
		nextPutAll: '										each isEmpty not and: ['; lf;
		nextPutAll: '											each first = $* and: [(each size = (packageName size + 1) and: [(each findStringNoCase: packageName startingAt: 2) = 2])'; lf;
		nextPutAll: '														or: [each size > (packageName size + 1) and: [(each findStringNoCase: packageName startingAt: 2) = 2 and: [(each at: packageName size + 2) = $-]]]]]]'; lf;
		nextPutAll: '					].'; lf;
		nextPutAll: '				toRemove do: [:each | aClass removeCategory: each].'; lf;
		nextPutAll: '			]'; lf;
		nextPutAll: '		]'; lf;
		nextPutAll: '	]'; lf;
		nextPutAll: '].'; lf;
                nextPutAll: 'true.'; lf;
		nextPutAll: '%'; lf;
		lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutPreambleType: aString for: classStructure on: aStream

	aStream
		nextPutAll: '! ', aString, ' for ', classStructure name; lf;
		lf
%

category: 'accessing'
method: CypressTopazFileoutWriter
packageNameExtension

	^'.gs'
%

category: 'writing - private'
method: CypressTopazFileoutWriter
writeClassTypeMessage: classStructure on: aStream hasInstanceVariables: instanceVariableBlock
  | classType classTypeMessage hasInstanceVariables |
  hasInstanceVariables := true.
  classType := classStructure subclassType.
  classType = 'indexableSubclass'
    ifTrue: [ classTypeMessage := 'indexableSubclass: ' ]
    ifFalse: [ classType = 'byteSubclass'
        ifTrue: [ classTypeMessage := 'byteSubclass: '.
          hasInstanceVariables := false ]
        ifFalse: [ classType = ''
            ifTrue: [ classTypeMessage := 'subclass: ' ]
            ifFalse: [ self error: 'unknown subclass type: ' , classType ] ] ].
  aStream
    tab;
    nextPutAll: classTypeMessage , classStructure className asString printString;
    lf.
  hasInstanceVariables
    ifTrue: [ instanceVariableBlock value ]
%

! Class implementation for 'CypressAbstractPackageReader'

!		Instance methods for 'CypressAbstractPackageReader'

category: 'private'
method: CypressAbstractPackageReader
classStructureFrom: classPropertiesDict

	^(CypressClassStructure new)
		packageStructure: self packageStructure;
		isClassExtension: true;
		properties: classPropertiesDict;
		yourself
%

category: 'private'
method: CypressAbstractPackageReader
classStructureFrom: classPropertiesDict comment: classComment

	^(self classStructureFrom: classPropertiesDict)
		isClassExtension: false;
		comment: classComment;
		yourself
%

category: 'reading'
method: CypressAbstractPackageReader
isPropertiesFileDirectoryEntry: entry

	^self propertiesFileNameExtensions
		anySatisfy: [:each | self string: entry endsWith: '/properties' , each]
%

category: 'accessing'
method: CypressAbstractPackageReader
packageExtension

	^self packageStructure
		packageExtensionOr: [self repository packageExtension]
%

category: 'parsing'
method: CypressAbstractPackageReader
parseSelectorFrom: methodString

	| meth |
	^
	[meth := self
				_parseMethod: methodString
				category: #xyzzy
				using: GsSession currentSession symbolList
				environmentId: 0.
	meth class ~~ GsNMethod
		ifTrue: 
			["if error slot is nil, then the method wasn't compiled because of errors"
			(meth at: 2) == nil ifFalse: [^nil].
			meth := meth at: 1].
	meth selector asString]
			on: CompileError
			do: [:ex | ex return: '_____could_not_parse_selector_from_method_source_____']
%

category: 'reading'
method: CypressAbstractPackageReader
readClassCommentFromDirectoryEntries: entries

	self fileUtils readStreamFor: (entries
				detect: [:entry | self string: entry endsWith: '/README.md']
				ifNone: [^''])
		do: [:fileStream | ^fileStream contents]
%

category: 'reading'
method: CypressAbstractPackageReader
readClassPropertiesFromDirectoryEntries: entries

	self fileUtils readStreamFor: (entries
				detect: [:entry | self isPropertiesFileDirectoryEntry: entry]
				ifNone: [^Dictionary new])
		do: [:fileStream | ^CypressJsonParser parseStream: fileStream]
%

category: 'reading'
method: CypressAbstractPackageReader
readClassStructureFromEntry: classEntry

	| classDirectory classPropertiesDict classComment entries classStructure |
	classDirectory := classEntry.
	entries := self fileUtils directoryEntriesFrom: classDirectory.
	classPropertiesDict := self
				readClassPropertiesFromDirectoryEntries: entries.
	classComment := self readClassCommentFromDirectoryEntries: entries.
	classStructure := self classStructureFrom: classPropertiesDict
				comment: classComment.
	self readMethodStructureFor: classStructure in: entries.
	^classStructure
%

category: 'reading'
method: CypressAbstractPackageReader
readCypressFormatMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods

	| notice category source selector |
	(fileStream peekFor: $")
		ifTrue: [fileStream nextLine]
		ifFalse: [self error: 'Method does not have valid Cypress format'].
	(fileStream match: 'notice: ')
		ifTrue: [notice := fileStream nextLine trimSeparators]
		ifFalse: [self error: 'Method does not have valid Cypress format'].
	(fileStream match: 'category: ')
		ifTrue: [category := fileStream nextLine trimSeparators]
		ifFalse: [self error: 'Method does not have valid Cypress format'].
	(fileStream peekFor: $")
		ifTrue: [fileStream nextLine]
		ifFalse: [self error: 'Method does not have valid Cypress format'].
	source := fileStream upToEnd.
	selector := self parseSelectorFrom: source.
	methods at: selector
		put: ((CypressMethodStructure new)
				packageStructure: self packageStructure;
				classStructure: classStructure;
				name: selector;
				isMetaclass: isMeta;
				selector: selector;
				category: category;
				source: source;
				yourself)
%

category: 'reading'
method: CypressAbstractPackageReader
readExtensionClassStructureFromEntry: classEntry

	| classPropertiesDict entries classStructure |
	entries := self fileUtils directoryEntriesFrom: classEntry.
	classPropertiesDict := self
				readClassPropertiesFromDirectoryEntries: entries.
	classStructure := self classStructureFrom: classPropertiesDict.
	self readMethodStructureFor: classStructure in: entries.
	^classStructure
%

category: 'reading'
method: CypressAbstractPackageReader
readFileTreeFormatMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods

	| category source selector |
	category := fileStream nextLine trimSeparators.
	source := fileStream upToEnd.
	selector := self parseSelectorFrom: source.
	methods at: selector
		put: ((CypressMethodStructure new)
				packageStructure: self packageStructure;
				classStructure: classStructure;
				name: selector;
				isMetaclass: isMeta;
				selector: selector;
				category: category;
				source: source;
				yourself)
%

category: 'reading'
method: CypressAbstractPackageReader
readMethodStructureFor: classStructure in: entries

	entries do: 
			[:entry |
			| methods isMeta |
			methods := (isMeta := self string: entry endsWith: '/class')
						ifTrue: [classStructure classMethods]
						ifFalse: [classStructure instanceMethods].
			((self string: entry endsWith: '/instance')
				or: [self string: entry endsWith: '/class'])
					ifTrue: 
						[((self fileUtils directoryEntriesFrom: entry)
							select: [:each | self string: each endsWith: '.st']) do: 
									[:methodEntry |
									self fileUtils readStreamFor: methodEntry
										do: 
											[:fileStream |
											self
												readMethodStructureFrom: fileStream
												intoClassStructure: classStructure
												meta: isMeta
												methods: methods]]]]
%

category: 'reading'
method: CypressAbstractPackageReader
readMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods

	self subclassResponsibility: #readMethodStructureFrom:intoClassStructure:meta:methods:
%

category: 'reading'
method: CypressAbstractPackageReader
readPackageStructure

	(self fileUtils directoryEntriesFrom: self packageDirectory) do: 
			[:entry |
			(self isPropertiesFileDirectoryEntry: entry)
				ifTrue: [self packageStructure properties: (self readPropertiesFile: entry)].
			(self string: entry endsWith: '.class')
				ifTrue: 
					[self packageStructure classes
						add: (self readClassStructureFromEntry: entry)].
			(self string: entry endsWith: '.extension')
				ifTrue: 
					[self packageStructure extensions
						add: (self readExtensionClassStructureFromEntry: entry)]]
%

category: 'reading'
method: CypressAbstractPackageReader
readPackageStructureForPackageNamed: packageName

	| structureName |
	structureName := packageName , self repository packageExtension.
	self
		packageStructure: (CypressPackageStructure named: structureName);
		packageDirectory: (self fileUtils directoryFromPath: structureName
					relativeTo: self repository directoryPath);
		readPackageStructure
%

category: 'reading'
method: CypressAbstractPackageReader
readPropertiesFile: entry

	self fileUtils
		readStreamFor: entry
		do: [:fileStream | ^CypressJsonParser parseStream: fileStream]
%

category: 'parsing'
method: CypressAbstractPackageReader
_parseMethod: source category: cat using: aSymbolList environmentId: anEnvironmentId
	"Compiles the method into disposable dictionaries, if possible.
	 Attempts auto-recompile for undefinedSymbols.
	 Returns the compiled method or signals a CompileError."

	| undefinedSymbolList undefinedSymbols |
	undefinedSymbols := SymbolDictionary new name: #UndefinedSymbols.
	undefinedSymbolList := SymbolList with: undefinedSymbols.
	^
	[UndefinedObject
		compileMethod: source
		dictionaries: aSymbolList
		category: cat
		intoMethodDict: GsMethodDictionary new
		intoCategories: GsMethodDictionary new
		environmentId: anEnvironmentId]
			onSynchronous: (Array with: CompileError with: CompileWarning)
			do: (Array with: 
						[:ex |
						| undefSymbol symbols |
						undefSymbol := true.
						symbols := Array new.
						ex errorDetails do: 
								[:errArray |
								(errArray atOrNil: 1) == 1031
									ifTrue: [symbols add: (errArray atOrNil: 5) asSymbol]
									ifFalse: [undefSymbol := false]].
						undefSymbol
							ifTrue: 
								["attempt auto-define of undefined symbols"
								symbols do: [:sym | undefinedSymbols at: sym put: nil].
								
								[^UndefinedObject
									compileMethod: source
									dictionaries: aSymbolList , undefinedSymbolList
									category: cat
									intoMethodDict: GsMethodDictionary new
									intoCategories: GsMethodDictionary new
									environmentId: anEnvironmentId]
										onException: CompileError
										do: [:exb | undefSymbol := false]].
						undefSymbol ifFalse: [ex outer]]
					with: [:ex | ex resume])
%

! Class implementation for 'CypressDoNothingPackageReader'

!		Instance methods for 'CypressDoNothingPackageReader'

category: 'reading'
method: CypressDoNothingPackageReader
readPackageStructure
%

! Class implementation for 'CypressFileTreeFormatPackageReader'

!		Instance methods for 'CypressFileTreeFormatPackageReader'

category: 'private'
method: CypressFileTreeFormatPackageReader
classStructureFrom: fileteeClassPropertiesDict comment: classComment
  | classPropertiesDict subclassType filetreeSubclassType |
  classPropertiesDict := fileteeClassPropertiesDict copy.
  filetreeSubclassType := classPropertiesDict at: 'type'.
  filetreeSubclassType = 'normal'
    ifTrue: [ subclassType := '' ]
    ifFalse: [ 
      filetreeSubclassType = 'variable'
        ifTrue: [ subclassType := 'indexableSubclass' ]
        ifFalse: [ 
          filetreeSubclassType = 'bytes'
            ifTrue: [ subclassType := 'byteSubclass' ]
            ifFalse: [ self error: 'unknown subclass type: ' , filetreeSubclassType printString ] ] ].
  classPropertiesDict at: '_gs_subclassType' put: subclassType.
  ^ super classStructureFrom: classPropertiesDict comment: classComment
%

category: 'accessing'
method: CypressFileTreeFormatPackageReader
propertiesFileNameExtension

	^'.json'
%

category: 'accessing'
method: CypressFileTreeFormatPackageReader
propertiesFileNameExtensions

	^Array
		with: super propertiesFileNameExtension
		with: self propertiesFileNameExtension
%

category: 'reading'
method: CypressFileTreeFormatPackageReader
readMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods
	"Strict!"

	self
		readFileTreeFormatMethodStructureFrom: fileStream
		intoClassStructure: classStructure
		meta: isMeta
		methods: methods
%

! Class implementation for 'CypressFlexiblePackageReader'

!		Instance methods for 'CypressFlexiblePackageReader'

category: 'reading'
method: CypressFlexiblePackageReader
isPropertiesFileDirectoryEntry: entry
	"Expect .ston properties file, but tolerate .json if present."

	^(super isPropertiesFileDirectoryEntry: entry)
		or: [self string: entry endsWith: '/properties.json']
%

category: 'reading'
method: CypressFlexiblePackageReader
readMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods
	"If the stream begins with a double quote, process it on the assumption it is a Cypress-format method.
	 Otherwise, treat it as a FileTree-format method."

	fileStream peek = $"
		ifTrue: 
			[self
				readCypressFormatMethodStructureFrom: fileStream
				intoClassStructure: classStructure
				meta: isMeta
				methods: methods]
		ifFalse: 
			[self
				readFileTreeFormatMethodStructureFrom: fileStream
				intoClassStructure: classStructure
				meta: isMeta
				methods: methods]
%

! Class implementation for 'CypressPackageReader'

!		Instance methods for 'CypressPackageReader'

category: 'reading'
method: CypressPackageReader
readMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods
	"Strict!"

	self
		readCypressFormatMethodStructureFrom: fileStream
		intoClassStructure: classStructure
		meta: isMeta
		methods: methods
%

! Class implementation for 'CypressAbstractPackageWriter'

!		Class methods for 'CypressAbstractPackageWriter'

category: 'initialization'
classmethod: CypressAbstractPackageWriter
initializeSpecials
	"Valid binarySelector characters  '!' | '%' | '&' | '*' | '+' | ','' | '/' | '<' | '=' | '>' | '?' | '@' | '\' | '~' | '|' | '-'"

	| map |
	map := Dictionary new.
	map
		at: $! put: 'bang';
		at: $% put: 'percent';
		at: $& put: 'and';
		at: $* put: 'star';
		at: $+ put: 'plus';
		at: $, put: 'comma';
		at: $- put: 'minus';
		at: $/ put: 'slash';
		at: $< put: 'less';
		at: $= put: 'equals';
		at: $> put: 'more';
		at: $? put: 'wat';
		at: $@ put: 'at';
		at: $\ put: 'backslash';
		at: $| put: 'pipe';
		at: $~ put: 'tilde'.
	map keys do: [:key | map at: (map at: key) put: key].
	^map
%

category: 'accessing'
classmethod: CypressAbstractPackageWriter
specials

	^specials ifNil: [specials := self initializeSpecials]
%

!		Instance methods for 'CypressAbstractPackageWriter'

category: 'private'
method: CypressAbstractPackageWriter
determinePackageDirectory

	^self fileUtils ensureDirectoryExists: (self fileUtils
				directoryFromPath: self packageStructure name
				relativeTo: self repository directoryPath)
%

category: 'private'
method: CypressAbstractPackageWriter
directoryForDirectoryNamed: directoryNameOrPath

	^directoryNameOrPath = '.'
		ifTrue: [self fileUtils ensureDirectoryExists: self packageDirectory]
		ifFalse: [self subPackageFileDirectoryFor: directoryNameOrPath]
%

category: 'private'
method: CypressAbstractPackageWriter
fileNameForSelector: selector

	^selector last = $:
		ifTrue: [selector copyReplacing: $: with: $.]
		ifFalse: 
			[(selector first isLetter or: [selector first = $_])
				ifTrue: [selector]
				ifFalse: 
					[| specials output |
					specials := self class specials.
					output := WriteStreamPortable on: (String new: 100).
					output nextPut: $^.
					selector do: [:each | output nextPutAll: (specials at: each)]
						separatedBy: [output nextPut: $.].
					output contents]]
%

category: 'writing'
method: CypressAbstractPackageWriter
removeOldReplacingWithNew
  self fileUtils deleteAll: self packageDirectory.
  self writePropertiesFile.
  self writePackageStructure
%

category: 'private'
method: CypressAbstractPackageWriter
subPackageFileDirectoryFor: directoryNameOrPath

	| dir |
	dir := self fileUtils directoryFromPath: directoryNameOrPath
				relativeTo: self packageDirectory.
	self fileUtils ensureDirectoryExists: dir.
	^dir
%

category: 'writing'
method: CypressAbstractPackageWriter
writeClassComment: classStructure on: fileStream

	fileStream
		nextPutAll: (CypressObject normalizeLineEndingsOf: classStructure comment)
%

category: 'writing'
method: CypressAbstractPackageWriter
writeClassStructure: classStructure to: classPath

	self
		writeInDirectoryName: classPath
			fileName: 'README'
			extension: '.md'
			visit: [:fileStream | self writeClassComment: classStructure on: fileStream];
		writeInDirectoryName: classPath
			fileName: 'properties'
			extension: self propertiesFileNameExtension
			visit: [:fileStream | classStructure properties _writeCypressJsonOn: fileStream]
%

category: 'writing'
method: CypressAbstractPackageWriter
writeExtensionClassStructure: classStructure to: classPath

	self
		writeInDirectoryName: classPath
		fileName: 'properties'
		extension: self propertiesFileNameExtension
		visit: 
			[:fileStream |
			(Dictionary with: 'name' -> classStructure className)
				_writeCypressJsonOn: fileStream]
%

category: 'private'
method: CypressAbstractPackageWriter
writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock

	| directory |
	directory := self directoryForDirectoryNamed: directoryNameOrPath.
	self fileUtils
		writeStreamFor: fileName , ext
		in: directory
		do: [:fileStream | visitBlock value: fileStream]
%

category: 'writing'
method: CypressAbstractPackageWriter
writeMethodStructure: methodStructure onStream: fileStream

	self subclassResponsibility: #writeMethodStructure:onStream:
%

category: 'writing'
method: CypressAbstractPackageWriter
writeMethodStructure: methodStructure to: methodPath

	| filename |
	filename := self fileNameForSelector: methodStructure selector.
	self
		writeInDirectoryName: methodPath
		fileName: filename
		extension: '.st'
		visit: [:fileStream | self writeMethodStructure: methodStructure onStream: fileStream]
%

category: 'writing'
method: CypressAbstractPackageWriter
writePackageStructure

	self
		writePackageStructureClasses: self packageStructure classes
			isClassExtension: false;
		writePackageStructureClasses: self packageStructure extensions
			isClassExtension: true
%

category: 'writing'
method: CypressAbstractPackageWriter
writePackageStructure: aPackageStructure

	self
		packageStructure: aPackageStructure;
		packageDirectory: self determinePackageDirectory;
		removeOldReplacingWithNew
%

category: 'writing'
method: CypressAbstractPackageWriter
writePackageStructureClasses: classStructures isClassExtension: isClassExtension

	| classDirExtension |
	classDirExtension := isClassExtension
				ifTrue: ['.extension']
				ifFalse: ['.class'].
	classStructures do: 
			[:classStructure |
			| classPath instanceMethodPath classMethodPath |
			classPath := classStructure className , classDirExtension
						, self fileUtils pathNameDelimiter asString.
			isClassExtension
				ifTrue: [self writeExtensionClassStructure: classStructure to: classPath]
				ifFalse: [self writeClassStructure: classStructure to: classPath].
			instanceMethodPath := classPath , 'instance' , self fileUtils pathNameDelimiter asString.
			classStructure instanceMethods
				do: [:methodStructure | self writeMethodStructure: methodStructure to: instanceMethodPath].
			classMethodPath := classPath , 'class' , self fileUtils pathNameDelimiter asString.
			classStructure classMethods
				do: [:methodStructure | self writeMethodStructure: methodStructure to: classMethodPath]]
%

category: 'writing'
method: CypressAbstractPackageWriter
writePropertiesFile

	self
		writeInDirectoryName: '.'
		fileName: 'properties'
		extension: self propertiesFileNameExtension
		visit: [:fileStream | Dictionary new _writeCypressJsonOn: fileStream]
%

! Class implementation for 'CypressFileTreeFormatPackageWriter'

!		Instance methods for 'CypressFileTreeFormatPackageWriter'

category: 'private'
method: CypressFileTreeFormatPackageWriter
adjustClassPropertiesForFileTree: classPropertyDict
  | props classType |
  props := classPropertyDict copy.
  classType := (props at: '_gs_subclassType' ifAbsent: [  ])
    ifNil: [ 'normal' ]
    ifNotNil: [ :type | 
      props removeKey: '_gs_subclassType'.
      type = 'indexableSubclass'
        ifTrue: [ 'variable' ]
        ifFalse: [ 
          type = 'byteSubclass'
            ifTrue: [ 'bytes' ]
            ifFalse: [ self error: 'unknown subclass type: ' , type ] ] ].
  props at: 'type' put: classType.
  ^ props
%

category: 'accessing'
method: CypressFileTreeFormatPackageWriter
propertiesFileNameExtension
  ^ '.json'
%

category: 'writing'
method: CypressFileTreeFormatPackageWriter
removeOldReplacingWithNew

	self fileUtils deleteAll: self packageDirectory
		rejecting: 
			[:filename |
			"do not delete the monticello.meta directory to preserve existing Monticello meta data.
       Equivalent behavior to MCFileTreeRepository with Metadata property set to false."
			(self string: filename endsWith: 'monticello.meta')
				or: [ (self string: filename endsWith: '.filetree')
					or: [self string: filename endsWith: 'methodProperties.json']]].
	self writePropertiesFile.
	self writePackageStructure
%

category: 'writing'
method: CypressFileTreeFormatPackageWriter
writeClassStructure: classStructure to: classPath

	self
		writeInDirectoryName: classPath
			fileName: 'README'
			extension: '.md'
			visit: [:fileStream | self writeClassComment: classStructure on: fileStream];
		writeInDirectoryName: classPath
			fileName: 'properties'
			extension: self propertiesFileNameExtension
			visit: 
				[:fileStream |
				(self adjustClassPropertiesForFileTree: classStructure properties)
					_writeCypressJsonOn: fileStream]
%

category: 'writing'
method: CypressFileTreeFormatPackageWriter
writeExtensionClassStructure: classStructure to: classPath

	self
		writeInDirectoryName: classPath
		fileName: 'properties'
		extension: self propertiesFileNameExtension
		visit: 
			[:fileStream |
			(Dictionary with: 'name' -> classStructure className)
				_writeCypressJsonOn: fileStream]
%

category: 'writing'
method: CypressFileTreeFormatPackageWriter
writeMethodStructure: methodStructure onStream: fileStream

	fileStream
		nextPutAll: methodStructure category;
		lf;
		nextPutAll: (CypressObject normalizeLineEndingsOf: methodStructure source)
%

category: 'writing'
method: CypressFileTreeFormatPackageWriter
writePropertiesFile

	self
		writeInDirectoryName: '.'
		fileName: 'properties'
		extension: self propertiesFileNameExtension
		visit: [:fileStream | Dictionary new _writeCypressJsonOn: fileStream]
%

! Class implementation for 'CypressPackageWriter'

!		Instance methods for 'CypressPackageWriter'

category: 'accessing - private'
method: CypressPackageWriter
methodNoticeLine

	^self packageStructure properties
		at: 'copyrightLine'
		ifAbsent: [self repository copyrightProperty]
%

category: 'writing'
method: CypressPackageWriter
writeMethodStructure: methodStructure onStream: fileStream

	fileStream
		nextPutAll: '"';
		lf;
		nextPutAll: 'notice: ' , self methodNoticeLine;
		lf;
		nextPutAll: 'category: ' , methodStructure category;
		lf;
		nextPutAll: '"';
		lf;
		nextPutAll: (CypressObject normalizeLineEndingsOf: methodStructure source)
%

category: 'writing'
method: CypressPackageWriter
writePropertiesFile

	self
		writeInDirectoryName: '.'
		fileName: 'properties'
		extension: self propertiesFileNameExtension
		visit: [:fileStream | self repository properties _writeCypressJsonOn: fileStream]
%

! Class implementation for 'CypressStrictFileTreeFormatDoNothingPackageWriter'

!		Instance methods for 'CypressStrictFileTreeFormatDoNothingPackageWriter'

category: 'writing'
method: CypressStrictFileTreeFormatDoNothingPackageWriter
removeOldReplacingWithNew
	"Change nothing, since a Cypress writer has insufficient information
	 for preserving the FileTree details. Strictly read-only."
%

category: 'writing'
method: CypressStrictFileTreeFormatDoNothingPackageWriter
writePropertiesFile
	"Change nothing, since a Cypress writer has insufficient information
	 for preserving the FileTree details. Strictly read-only."
%

! Class implementation for 'CypressAbstractRepository'

!		Class methods for 'CypressAbstractRepository'

category: 'instance creation'
classmethod: CypressAbstractRepository
createOn: aUrl alias: aString
  ^ self onUrl: aUrl alias: aString
%

category: 'accessing'
classmethod: CypressAbstractRepository
defaultCopyrightNotice

	^DefaultCopyrightNotice
%

category: 'accessing'
classmethod: CypressAbstractRepository
defaultCopyrightNotice: aString

	DefaultCopyrightNotice := aString
%

category: 'initializing'
classmethod: CypressAbstractRepository
initialize

	self initializeDefaultCopyrightNotice
%

category: 'initializing'
classmethod: CypressAbstractRepository
initializeDefaultCopyrightNotice

	self defaultCopyrightNotice isNil ifFalse: [^self].
	self defaultCopyrightNotice: 'This work is protected by copyright. All rights reserved.'
%

category: 'instance creation'
classmethod: CypressAbstractRepository
onUrl: aUrl alias: aString

	^(aUrl repositoryClass new)
		initializeUrl: aUrl andAlias: aString;
		yourself
%

!		Instance methods for 'CypressAbstractRepository'

category: 'accessing properties'
method: CypressAbstractRepository
alias

	^properties 
		at: 'alias'
		ifAbsent: ['']
%

category: 'accessing properties'
method: CypressAbstractRepository
alias: aString

	properties 
		at: 'alias'
		put: aString
%

category: 'accessing properties'
method: CypressAbstractRepository
copyrightProperty

	^properties 
		at: '_cypress_copyright'
		ifAbsent: ['']
%

category: 'accessing properties'
method: CypressAbstractRepository
copyrightProperty: aString

	properties 
		at: '_cypress_copyright'
		put: aString
%

category: 'accessing'
method: CypressAbstractRepository
defaultCopyrightNotice

	^self class defaultCopyrightNotice
%

category: 'accessing'
method: CypressAbstractRepository
description

	^self alias
%

category: 'initializing - private'
method: CypressAbstractRepository
initialize

	self initializeDefaultRepositoryProperties.
	readerClass := CypressPackageReader.
	writerClass := CypressPackageWriter.
%

category: 'initializing - private'
method: CypressAbstractRepository
initializeDefaultCopyrightProperty

	self copyrightProperty: self defaultCopyrightNotice
%

category: 'initializing - private'
method: CypressAbstractRepository
initializeDefaultRepositoryProperties

	properties := Dictionary new.
	self initializeDefaultCopyrightProperty
%

category: 'initializing - private'
method: CypressAbstractRepository
initializeUrl: aUrl andAlias: aString

	self
		initialize;
		url: aUrl;
		alias: aString;
		validateUrl
%

category: 'accessing properties'
method: CypressAbstractRepository
packageExtension

	^properties 
		at: 'packageExtension'
		ifAbsent: ['.package']
%

category: 'printing'
method: CypressAbstractRepository
printDetailsOn: aStream

	aStream nextPutAll: self alias
%

category: 'printing'
method: CypressAbstractRepository
printOn: aStream

	aStream
		nextPutAll: self class name;
		nextPutAll: '('.
	self printDetailsOn: aStream.
	aStream nextPutAll: ')'
%

category: 'reading'
method: CypressAbstractRepository
reader

	^readerClass forRepository: self
%

category: 'reading'
method: CypressAbstractRepository
readPackageStructureForPackageNamed: packageName

	^(self reader)
		readPackageStructureForPackageNamed: packageName;
		packageStructure
%

category: 'accessing'
method: CypressAbstractRepository
url

	^url
%

category: 'accessing'
method: CypressAbstractRepository
url: aString

	url := aString
%

category: 'validating - private'
method: CypressAbstractRepository
validateUrl
	"At this level, there is nothing to check.
	 But different URLs denote different kinds of repositories, and
	 each kind of repository may have specific checks."
%

category: 'writing'
method: CypressAbstractRepository
writePackageStructure: aPackageStructure

	^self writer writePackageStructure: aPackageStructure
%

category: 'writing'
method: CypressAbstractRepository
writer

	^writerClass forRepository: self
%

! Class implementation for 'CypressAbstractFileoutRepository'

!		Class methods for 'CypressAbstractFileoutRepository'

category: 'instance creation'
classmethod: CypressAbstractFileoutRepository
on: aDirectory

	^self new
		initializeForDirectory: aDirectory;
		yourself.
%

!		Instance methods for 'CypressAbstractFileoutRepository'

category: 'accessing'
method: CypressAbstractFileoutRepository
description

	| desc |
	desc := super description.
	^desc notEmpty
		ifTrue: [desc]
		ifFalse: [self directoryPath]
%

category: 'accessing'
method: CypressAbstractFileoutRepository
directoryPath

	^directoryPath
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
directoryPath:  aString

	directoryPath := aString
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
ensureDirectoryPathExists

	self fileUtils ensureDirectoryExists: self directoryPath
%

category: 'accessing - private'
method: CypressAbstractFileoutRepository
fileUtils

	^CypressFileUtilities current
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
initializeCreationOn: aUrl alias: aString

	self
		initializeUrl: aUrl andAlias: aString;
		alias: aString
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
initializeForDirectory: aDirectory

	self initialize.
	self directoryPath: aDirectory.
	self directoryPath isEmpty ifTrue: [^self].	"Not really valid; not a very good idea."
	self ensureDirectoryPathExists.
	self initializeReaderAndWriterClasses.
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
initializeReaderAndWriterClasses
  self subclassResponsibility: #'initializeReaderAndWriterClasses'
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
initializeUrl: aUrl andAlias: aString

	super initializeUrl: aUrl andAlias: aString.
	self directoryPath: self url pathForDirectory.
	self ensureDirectoryPathExists.
	self initializeReaderAndWriterClasses.
%

category: 'printing'
method: CypressAbstractFileoutRepository
printDetailsOn: aStream

	self alias notEmpty
		ifTrue: 
			[aStream
				nextPutAll: self alias;
				nextPutAll: ': '].
	aStream nextPutAll: self url printString
%

category: 'validating - private'
method: CypressAbstractFileoutRepository
validateUrl
	"At this level, there is nothing to check.
	 But different URLs denote different kinds of repositories, and
	 each kind of repository may have specific checks."

	self url fileName isEmpty
		ifFalse: [self error: self printString, ' should not be used with URLs for file names (', self url fileName, ' in ', self url pathForDirectory, ')']
%

! Class implementation for 'CypressSmalltalkRepository'

!		Instance methods for 'CypressSmalltalkRepository'

category: 'initializing - private'
method: CypressSmalltalkRepository
initializeReaderAndWriterClasses

	readerClass := CypressDoNothingPackageReader.
	writerClass := CypressSmalltalkFileoutWriter.
%

! Class implementation for 'CypressTopazRepository'

!		Instance methods for 'CypressTopazRepository'

category: 'initializing - private'
method: CypressTopazRepository
initializeReaderAndWriterClasses

	readerClass := CypressDoNothingPackageReader.
	writerClass := CypressTopazFileoutWriter.
%

! Class implementation for 'CypressDictionaryRepository'

!		Class methods for 'CypressDictionaryRepository'

category: 'instance creation'
classmethod: CypressDictionaryRepository
on: aDictionary
  ^ self new
    initializeForDictionary: aDictionary;
    yourself
%

!		Instance methods for 'CypressDictionaryRepository'

category: 'accessing'
method: CypressDictionaryRepository
dictionary
  ^ dictionary
%

category: 'accessing'
method: CypressDictionaryRepository
dictionary: aDictionary
  dictionary := aDictionary
%

category: 'initializing - private'
method: CypressDictionaryRepository
initialize
  super initialize.
  readerClass := nil.
  writerClass := nil
%

category: 'initializing - private'
method: CypressDictionaryRepository
initializeForDictionary: aDictionary
  self initialize.
  self dictionary: aDictionary
%

category: 'accessing'
method: CypressDictionaryRepository
packageNames
  ^ self dictionary keys
%

category: 'reading'
method: CypressDictionaryRepository
readPackageStructureForPackageNamed: packageName
  ^ (self dictionary at: packageName) packageStructure
%

category: 'writing'
method: CypressDictionaryRepository
writePackageStructure: aPackageStructure
  ^ self dictionary at: aPackageStructure packageName put: aPackageStructure
%

! Class implementation for 'CypressFileSystemRepository'

!		Class methods for 'CypressFileSystemRepository'

category: 'instance creation'
classmethod: CypressFileSystemRepository
on: aDirectory

	^self new
		initializeForDirectory: aDirectory;
		yourself.
%

!		Instance methods for 'CypressFileSystemRepository'

category: 'accessing - properties'
method: CypressFileSystemRepository
codeFormatProperty

	^properties 
		at: '_gs_format'
		ifAbsent: ['Cypress']
%

category: 'updating properties'
method: CypressFileSystemRepository
codeFormatProperty: aString

	self validate: aString isOneOf: #('Cypress' 'FileTree' 'Flexible').
	properties 
		at: '_gs_format'
		put: aString
%

category: 'accessing'
method: CypressFileSystemRepository
description
  | desc |
  desc := super description.
  ^ desc notEmpty
    ifTrue: [ desc ]
    ifFalse: [ self url asString ]
%

category: 'accessing'
method: CypressFileSystemRepository
directoryPath

	^directoryPath
%

category: 'initializing - private'
method: CypressFileSystemRepository
directoryPath: aString
  | delim |
  delim := self fileUtils pathNameDelimiter.
  aString last = delim last
    ifTrue: [ directoryPath := aString ]
    ifFalse: [ directoryPath := aString , delim ]
%

category: 'testing - private'
method: CypressFileSystemRepository
doesRepositoryFileExist: fileName
	"Answer whether the named file exists at the repository level."

	^self fileUtils
		directoryExists: (self fileUtils
				directoryFromPath: fileName
				relativeTo: self directoryPath)
%

category: 'initializing - private'
method: CypressFileSystemRepository
ensureDirectoryPathExists

	self fileUtils ensureDirectoryExists: self directoryPath
%

category: 'accessing - private'
method: CypressFileSystemRepository
fileUtils

	^CypressFileUtilities current
%

category: 'initializing - private'
method: CypressFileSystemRepository
fixupMissingCopyrightProperty

	self copyrightProperty isEmpty ifFalse: [^self].
	self initializeDefaultCopyrightProperty.
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeCreationOn: aUrl alias: aString

	self
		initializeUrl: aUrl andAlias: aString;
		alias: aString;
		writePropertiesFile
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeDefaultRepositoryProperties

	super initializeDefaultRepositoryProperties.
	self
		codeFormatProperty: 'Cypress';
		strictCodeFormat: false.
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeForDirectory: aDirectory

	self initialize.
	self directoryPath: aDirectory.
	self directoryPath isEmpty ifTrue: [^self].	"Not really valid; not a very good idea."
	self ensureDirectoryPathExists.
	self readPropertiesFile.
	self fixupMissingCopyrightProperty.
	self initializeReaderAndWriterClasses.
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeForFileTreeRepository
  self initializeDefaultRepositoryProperties.
  self
    codeFormatProperty: 'FileTree';
    strictCodeFormat: true
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeReaderAndWriterClasses

	self isCodeFormatCypress
		ifTrue: 
			[self isCodeFormatStrict
				ifTrue: 
					[readerClass := CypressPackageReader.
					writerClass := CypressPackageWriter]
				ifFalse: 
					[readerClass := CypressFlexiblePackageReader.
					writerClass := CypressPackageWriter]]
		ifFalse: 
			[self isCodeFormatStrict
				ifTrue: 
					[readerClass := CypressFileTreeFormatPackageReader.
					writerClass := CypressStrictFileTreeFormatDoNothingPackageWriter]
				ifFalse: 
					[readerClass := CypressFlexiblePackageReader.
					writerClass := CypressFileTreeFormatPackageWriter]]
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeRepositoryDirectory
  self directoryPath: self url pathForDirectory.
  self ensureDirectoryPathExists
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeUrl: aUrl andAlias: aString
  super initializeUrl: aUrl andAlias: aString.
  self initializeRepositoryDirectory.
  self readPropertiesFile.
  self codeFormatProperty: self url codeFormat.
  self strictCodeFormat: self url isStrict.
  self fixupMissingCopyrightProperty.
  self initializeReaderAndWriterClasses
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatCypress

	^self isCodeFormatProperty: 'Cypress'
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatFileTree

	^self isCodeFormatProperty: 'FileTree'
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatFlexiblyCypress

	^self isCodeFormatStrict not and: [self isCodeFormatCypress]
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatFlexiblyFileTree

	^self isCodeFormatStrict not and: [self isCodeFormatFileTree]
%

category: 'testing properties - private'
method: CypressFileSystemRepository
isCodeFormatProperty: aString

	^(properties at: '_gs_format') equalsNoCase: aString
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatStrict

	^(properties 
		at: '_gs_strict'
		ifAbsent: ['']) equalsNoCase: 'true'
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatStrictlyCypress

	^self isCodeFormatStrict and: [self isCodeFormatCypress]
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatStrictlyFileTree

	^self isCodeFormatStrict and: [self isCodeFormatFileTree]
%

category: 'accessing'
method: CypressFileSystemRepository
packageNames

	| extension extensionSize |
	extension := self packageExtension.
	extensionSize := extension size.
	^(self fileUtils
		directoryEntriesFrom: self directoryPath , '*' , extension) collect: 
				[:each |
				| localName |
				localName := self fileUtils localNameFrom: each.
				localName copyFrom: 1 to: localName size - extensionSize]
%

category: 'printing'
method: CypressFileSystemRepository
printDetailsOn: aStream
  self alias notEmpty
    ifTrue: [ aStream
        nextPutAll: self alias;
        nextPutAll: ': ' ].
  aStream nextPutAll: self url printString
%

category: 'accessing'
method: CypressFileSystemRepository
properties
  ^ properties
%

category: 'reading'
method: CypressFileSystemRepository
readPropertiesFile

	self readPropertiesFile: (#('properties.ston' 'properties.json' '.filetree')
				detect: [:each | self doesRepositoryFileExist: each]
				ifNone: [^self]).
%

category: 'reading'
method: CypressFileSystemRepository
readPropertiesFile: fileName
	"Expect 'properties.ston' for Cypress, but permit 'properties.json' in which case we assume
	 the format should be FileTree.

	 Supported properties are:
		_cypress_copyright	- the (optional, default) copyright notice for the whole repository
		_gs_format			- optional, determines which format will be used for writing packages (and reading, but ...)
							- either Cypress or FileTree (case-insensitive)
		_gs_strict			- optional, determines whether the reader strictly enforces the format
							- either true or false (case-insensitive)
		_gs_fileout			- optional, determines whether to also produce a *.gs fileout when writing a package
							- either true or false (case-insensitive)
	"

	fileName = '.filetree' ifTrue: [^self initializeForFileTreeRepository].
	self fileUtils
		readStreamFor: fileName
		in: self directoryPath
		do: [:fileStream | properties := CypressJsonParser parseStream: fileStream]
%

category: 'updating properties'
method: CypressFileSystemRepository
strictCodeFormat: aBoolean

	self strictCodeFormatProperty: aBoolean printString

%

category: 'updating properties - private'
method: CypressFileSystemRepository
strictCodeFormatProperty: aString

	self validate: aString isOneOf: #('true' 'false').
	properties 
		at: '_gs_strict'
		put: aString
%

category: 'updating properties - private'
method: CypressFileSystemRepository
validate: aString isOneOf: someStrings

	someStrings
		detect: [:each | aString equalsNoCase: each]
		ifNone: [self error: aString printString, ' must be one of ', someStrings printString].
%

category: 'validating - private'
method: CypressFileSystemRepository
validateUrl
	"At this level, there is nothing to check.
	 But different URLs denote different kinds of repositories, and
	 each kind of repository may have specific checks."

	self url fileName isEmpty
		ifFalse: [self error: self printString, ' should not be used with URLs for file names (', self url fileName, ' in ', self url pathForDirectory, ')']
%

category: 'writing'
method: CypressFileSystemRepository
writePropertiesFile

	self writePropertiesFile: (self isCodeFormatFileTree
				ifTrue: ['properties.json']
				ifFalse: ['properties.ston'])
%

category: 'writing'
method: CypressFileSystemRepository
writePropertiesFile: fileName

	self fileUtils
		writeStreamFor: fileName
		in: self directoryPath
		do: [:fileStream | properties _writeCypressJsonOn: fileStream]
%

! Class implementation for 'CypressFileSystemGitRepository'

!		Class methods for 'CypressFileSystemGitRepository'

category: 'accessing'
classmethod: CypressFileSystemGitRepository
gitRepositoryDir
  | path |
  path := (SessionTemps current at: #'Cypress_FileSystem_Git_Repository_Directory' otherwise: nil)
    ifNil: [
      path := (System gemEnvironmentVariable: 'GEMSTONE_GITDIR')
        ifNil: [ 
          CypressFileUtilities current workingDirectory
          , CypressFileUtilities current pathNameDelimiter , 'cypress-git-repos' ].
      SessionTemps current at: #'Cypress_FileSystem_Git_Repository_Directory' put: path ].
  ^path
%

category: 'accessing'
classmethod: CypressFileSystemGitRepository
gitRepositoryDir: directoryPath
  ^ SessionTemps current at: #'Cypress_FileSystem_Git_Repository_Directory' put: directoryPath
%

category: 'git commands'
classmethod: CypressFileSystemGitRepository
performOnServer: commandLine
  | result |
  result := self
    performOnServer: commandLine
    status: [ :performOnServerStatusArray | "Array of 5 elements: 
       raw status Integer, 
       child process status Integer (after WEXITSTATUS macro applied), 
       result String (or nil if operation failed) ,
       error string from script file write, fork, or result file read ,
       errno value, a SmallInteger from file write, fork, or file read"
      (performOnServerStatusArray at: 1) ~~ 0
        ifTrue: [ | message |
          message := 'performOnServer: ' , commandLine printString , ' stdout: '
            , (performOnServerStatusArray at: 3) printString
            , ' failed with status: '
            , (performOnServerStatusArray at: 1) printString , ' errno: '
            , (performOnServerStatusArray at: 5) printString , ' errStr: '
            , (performOnServerStatusArray at: 4) asString.
          self error: message ].
      performOnServerStatusArray at: 3 ].
  Transcript
    cr;
    show: commandLine printString;
    cr;
    show: result.
  ^ result
%

category: 'git commands'
classmethod: CypressFileSystemGitRepository
performOnServer: commandLine status: statusBlock
  | performOnServerStatusArray |
  performOnServerStatusArray := System _performOnServer: commandLine.
  ^ statusBlock value: performOnServerStatusArray
%

category: 'git commands'
classmethod: CypressFileSystemGitRepository
runGitCommand: argsArray in: gitRootPath

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	stream nextPutAll: 'cd ' , gitRootPath , '; git '.
	argsArray do: 
			[:arg |
			stream
				space;
				nextPutAll: arg].
	^self performOnServer: stream contents
%

!		Instance methods for 'CypressFileSystemGitRepository'

category: 'accessing'
method: CypressFileSystemGitRepository
currentBranch
  | result |
  result := self
    gitCommand: #('rev-parse' '--abbrev-ref' 'HEAD')
    in: self directoryPath.
  ^ result trimWhiteSpace
%

category: 'git querying'
method: CypressFileSystemGitRepository
gitCloneRepositoryAndCheckoutIn: aDirectoryName workingDirectory: workingDirectory
  "Do a clone on the remote repository and do a checkout on it to get the right branch. Complement the directory as well with the working directory."

  | gitDir branch |
  gitDir := workingDirectory , self fileUtils pathNameDelimiter
    , (aDirectoryName subStrings: '/') last.
  branch := self projectBranchOrTag.
  (self fileUtils directoryExists: gitDir)
    ifTrue: [ | targetDirBranch |
      self directoryPath: (self repositoryPath isEmpty
            ifTrue: [ gitDir ]
            ifFalse: [ gitDir , self fileUtils pathNameDelimiter , self repositoryPath ]).
      targetDirBranch := self currentBranch.
      targetDirBranch = branch
        ifFalse: [ self error: self class name asString
                ,
                  ' target directory already exists and is on another branch, cancelling clone and repository instanciation : '
                , gitDir ] ]
    ifFalse: [ self gitCommand: #('clone') , {'-b'.
              branch} , {remoteUrl.
              gitDir} in: workingDirectory.
      self directoryPath: (self repositoryPath isEmpty
            ifTrue: [ gitDir ]
            ifFalse: [ gitDir , self fileUtils pathNameDelimiter , self repositoryPath ]) ]
%

category: 'git querying'
method: CypressFileSystemGitRepository
gitCommand: aCommandString in: aDirectory
  ^ self class runGitCommand: aCommandString in: aDirectory
%

category: 'initializing - private'
method: CypressFileSystemGitRepository
initializeRepositoryDirectory
  self remoteUrl: self url httpsAccessString.
  self
    gitCloneRepositoryAndCheckoutIn: self projectPath
    workingDirectory: self class gitRepositoryDir.
  (self isGitRepository: self directoryPath)
    ifFalse: [ self error: 'This url is not a git repository' , self url printString ]
%

category: 'git querying'
method: CypressFileSystemGitRepository
isGitRepository: aDirectory
  "Check that we have a git repository"

  | gitPath |
  gitPath := self gitCommand: #('rev-parse' '--show-toplevel') in: aDirectory.
  (gitPath indexOfSubCollection: 'fatal:' startingAt: 1 ifAbsent: [ 0 ]) = 1
    ifTrue: [ ^ false ].
  ^ true
%

category: 'accessing'
method: CypressFileSystemGitRepository
projectBranchOrTag
  "right now only expect to work with branches"

  ^ self url projectBranchOrTag
%

category: 'accessing'
method: CypressFileSystemGitRepository
projectPath
  ^ self url projectPath
%

category: 'accessing'
method: CypressFileSystemGitRepository
remoteUrl

   ^remoteUrl
%

category: 'accessing'
method: CypressFileSystemGitRepository
remoteUrl: anObject

   remoteUrl := anObject
%

category: 'accessing'
method: CypressFileSystemGitRepository
repositoryPath
  ^ self url repositoryPath
%

category: 'validating - private'
method: CypressFileSystemGitRepository
validateUrl
  "At this level, there is nothing to check.
	 But different URLs denote different kinds of repositories, and
	 each kind of repository may have specific checks."

  (self url projectPath isEmpty or: [ self url projectBranchOrTag isEmpty ])
    ifTrue: [ self error: self printString , ' should not be used with non-git URLs.' ]
%

! Class implementation for 'CypressFileUtilities'

!		Class methods for 'CypressFileUtilities'

category: 'accessing'
classmethod: CypressFileUtilities
current

	^Current
%

category: 'utilities'
classmethod: CypressFileUtilities
deleteAll: aDirectory

	self subclassResponsibility: #deleteAll:
%

category: 'utilities'
classmethod: CypressFileUtilities
deleteAll: aDirectory rejecting: rejectBlock
  self subclassResponsibility: #'deleteAll:rejecting:'
%

category: 'utilities'
classmethod: CypressFileUtilities
directoryEntriesFrom: aDirectory

	self subclassResponsibility: #directoryEntriesFrom:
%

category: 'utilities'
classmethod: CypressFileUtilities
directoryExists: aDirectory

	self subclassResponsibility: #directoryExists:
%

category: 'unknown'
classmethod: CypressFileUtilities
directoryFileNamesAndContents: aDirectory

	self subclassResponsibility: #directoryFileNamesAndContents:
%

category: 'utilities'
classmethod: CypressFileUtilities
directoryFromPath: directoryPath relativeTo: aDirectory

	self subclassResponsibility: #directoryFromPath:relativeTo:
%

category: 'utilities'
classmethod: CypressFileUtilities
ensureDirectoryExists: aDirectory

	self subclassResponsibility: #ensureDirectoryExists:
%

category: 'initializating'
classmethod: CypressFileUtilities
install

	Current := self
%

category: 'utilities'
classmethod: CypressFileUtilities
localNameFrom: aDirectory

	self subclassResponsibility: #localNameFrom:
%

category: 'utilities'
classmethod: CypressFileUtilities
pathNameDelimiter

	self subclassResponsibility: #pathNameDelimiter
%

category: 'utilities'
classmethod: CypressFileUtilities
readStreamFor: filePath do: aOneArgBlock

	self subclassResponsibility: #readStreamFor:do:
%

category: 'utilities'
classmethod: CypressFileUtilities
readStreamFor: filePath in: aDirectory do: aOneArgBlock

	self subclassResponsibility: #readStreamFor:in:do:
%

category: 'utilities'
classmethod: CypressFileUtilities
workingDirectory

	self subclassResponsibility: #workingDirectory
%

category: 'utilities'
classmethod: CypressFileUtilities
writeStreamFor: filePath in: aDirectory do: aOneArgBlock

	self subclassResponsibility: #writeStreamFor:in:do:
%

! Class implementation for 'CypressGemStoneDirectoryUtilities'

!		Class methods for 'CypressGemStoneDirectoryUtilities'

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
deleteAll: aDirectory
  "Delete all the files and directories under the named directory.
	 Ensure we don't try to recursively delete . or .."

  self deleteAll: aDirectory rejecting: [ :filename | false ]
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
deleteAll: aDirectory rejecting: rejectBlock
	"Delete all the files and directories under the named directory.
       Reject file and directores in aDirectory that are rejected by rejectBlock.
       The rejectBlock is not used recursively.
       Ensure we don't try to recursively delete . or .."

	| filename isFile |
	(GsFile contentsAndTypesOfDirectory: aDirectory onClient: false)
		doWithIndex: 
			[:each :index |
			index odd
				ifTrue: [filename := each]
				ifFalse: 
					[isFile := each.
					isFile
						ifTrue: 
							[(rejectBlock value: filename)
								ifFalse: 
									[(rejectBlock value: filename) ifFalse: [GsFile removeServerFile: filename]]]
						ifFalse: 
							[(self endsWithSpecial: filename)
								ifFalse: 
									[(rejectBlock value: filename)
										ifFalse: 
											[self deleteAll: filename rejecting: rejectBlock.
											GsFile removeServerDirectory: filename]]]]]
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
directoryEntriesFrom: aDirectory
	"Answer fully qualified paths to the contents of aDirectory."

	^(GsFile contentsOfDirectory: aDirectory onClient: false) ifNil: [#()]
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
directoryExists: aDirectory

	"handle the case where GsFile class>>existsOnServer: returns nil"
	^ (GsFile existsOnServer: aDirectory) == true
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
directoryFileNamesAndContents: aDirectory
	"Walk the directory tree starting at aDirectory and
	 answer a map of the names of the files in the tree to
	 their contents (which work best when text)."

	| map |
	map := Dictionary new.
	self directoryFileNamesAndContents: aDirectory into: map.
	^map.
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
directoryFileNamesAndContents: aDirectory into: aDictionary
	"Walk the directory tree starting at aDirectory and
	 answer a map of the names of the files in the tree to
	 their contents (which work best when text)."

	| filename isFile |
	(GsFile contentsAndTypesOfDirectory: aDirectory onClient: false)
		doWithIndex: 
			[:each :index |
			index odd
				ifTrue: [filename := each]
				ifFalse: 
					[isFile := each.
					isFile
						ifTrue: 
							[| file |
							file := GsFile openReadOnServer: filename.
							file isNil
								ifFalse: 
									[aDictionary at: filename put: file contents.
									file close]]
						ifFalse: 
							[(self endsWithSpecial: filename)
								ifFalse: [self directoryFileNamesAndContents: filename into: aDictionary]]]]
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
directoryFromPath: directoryPath relativeTo: aDirectory

	| delimiter |
	delimiter := self pathNameDelimiter.
	^(aDirectory last = delimiter last
		or: [(directoryPath indexOfSubCollection: delimiter startingAt: 1 ifAbsent: [ 0 ]) = 1])
			ifTrue: [aDirectory , directoryPath]
			ifFalse: [aDirectory , delimiter , directoryPath]
%

category: 'private'
classmethod: CypressGemStoneDirectoryUtilities
endsWithSpecial: filename
	"Answer true if the given filename ends with any of the special sequences
	'/..' '/.' '\..' '\.', false otherwise."

	| filenameSize finalChars |
	filenameSize := filename size.
	finalChars := filename copyFrom: filenameSize - 1 to: filenameSize.
	finalChars = '/.' ifTrue: [^true].
	finalChars = '\.' ifTrue: [^true].
	finalChars := filename copyFrom: filenameSize - 2 to: filenameSize.
	finalChars = '/..' ifTrue: [^true].
	finalChars = '\..' ifTrue: [^true].
	^false
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
ensureDirectoryExists: aDirectory

	| lastSeparator |
	(GsFile existsOnServer: aDirectory) == true ifTrue: [^aDirectory].
	(GsFile createServerDirectory: aDirectory) ifNotNil: [^aDirectory].
	lastSeparator := aDirectory findLastSubString: self pathNameDelimiter startingAt: aDirectory size.
	lastSeparator <= 1 ifTrue: [self error: 'Cannot create directory'].
	self ensureDirectoryExists: (aDirectory copyFrom: 1 to: lastSeparator - 1).
	self ensureDirectoryExists: aDirectory.
%

category: 'initializating'
classmethod: CypressGemStoneDirectoryUtilities
initialize
	"self initialize"

	self install
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
localNameFrom: aDirectory

	| endOfPath |
	endOfPath := aDirectory findLastSubString: self pathNameDelimiter startingAt: aDirectory size.
	^aDirectory copyFrom: endOfPath + 1 to: aDirectory size
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
pathNameDelimiter

	^'/'
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
readStreamFor: filePath do: aOneArgBlock

	| file stream blockResult |
	GsFile serverErrorString.
	file := GsFile openReadOnServer: filePath.
	GsFile serverErrorString ifNotNil: [:errorMessage | self error: errorMessage].
	[stream := ReadStreamPortable on: (String withAll: file contents asByteArray decodeFromUTF8).
	blockResult := aOneArgBlock value: stream] ensure: [file close].
	^ blockResult
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
readStreamFor: filePath in: aDirectory do: aOneArgBlock

	^ self
		readStreamFor: (self directoryFromPath: filePath relativeTo: aDirectory)
		do: aOneArgBlock
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
workingDirectory

	^System gemEnvironmentVariable: 'PWD'
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
writeStreamFor: filePath in: aDirectory do: aOneArgBlock

	| file stream |
	GsFile serverErrorString.
	file := GsFile openWriteOnServer: (self directoryFromPath: filePath relativeTo: aDirectory).
	GsFile serverErrorString ifNotNil: [:errorMessage | self error: errorMessage].
	stream := WriteStreamPortable on: String new.
	[aOneArgBlock value: stream] ensure: [file nextPutAll: stream contents encodeAsUTF8; close]
%

! Class implementation for 'CypressGsGeneralDependencySorter'

!		Class methods for 'CypressGsGeneralDependencySorter'

category: 'instance creation'
classmethod: CypressGsGeneralDependencySorter
on: someCandidates dependsOn: aOneArgBlock dependent: anotherOneArgBlock
	"Create an instance of the receiver capable for sorting the dependencies of someCandidates.
	 aOneArgBlock is used to evaluate the key of the object depended on for a candidate.
	 anotherOneArgBlock is used to evaluate the key of the candidate itself."

	^self new
		initializeOn: someCandidates dependsOn: aOneArgBlock dependent: anotherOneArgBlock;
		yourself.
%

!		Instance methods for 'CypressGsGeneralDependencySorter'

category: 'sorting - private'
method: CypressGsGeneralDependencySorter
determineGraphRoots
  ^ dependencyGraphs
    selectAssociations: [ :each | (candidateAliasMap includesKey: each key) not ]
%

category: 'initializing - private'
method: CypressGsGeneralDependencySorter
initializeOn: someCandidates dependsOn: aOneArgBlock dependent: anotherOneArgBlock

	candidates := someCandidates.
	dependsOnConverter := aOneArgBlock.
	dependentConverter := anotherOneArgBlock.
	individualDependencyMap := Dictionary new.
	dependencyGraphs := Dictionary new.
	candidateAliasMap := Dictionary new
%

category: 'sorting'
method: CypressGsGeneralDependencySorter
inOrder
  | sorted sortedRoots |
  sorted := OrderedCollection new.
  self mapCandidatesIntoGraphs.
  sortedRoots := SortedCollection sortBlock: [ :a :b | a key <= b key ].
  self determineGraphRoots associationsDo: [ :assoc | sortedRoots add: assoc ].
  sortedRoots do: [ :assoc | self transcribeGraph: assoc value into: sorted ].
  ^ sorted
%

category: 'sorting - private'
method: CypressGsGeneralDependencySorter
mapCandidatesIntoGraphs

	| dependsOnKey dependentKey |
	candidates do: 
			[:each |
			| individualDependency |
			dependsOnKey := dependsOnConverter value: each.
			dependentKey := dependentConverter value: each.
			candidateAliasMap at: dependentKey put: each.
			individualDependencyMap at: dependsOnKey ifAbsentPut: [Dictionary new].
			individualDependencyMap at: dependentKey ifAbsentPut: [Dictionary new].
			individualDependency := individualDependencyMap
						associationAt: dependsOnKey.
			(dependencyGraphs includesKey: dependsOnKey)
				ifFalse: [dependencyGraphs add: individualDependency].
			individualDependency value
				add: (individualDependencyMap associationAt: dependentKey)]
%

category: 'sorting - private'
method: CypressGsGeneralDependencySorter
transcribeGraph: subtree into: sorted
  (subtree keys asSortedCollection: [ :a :b | a <= b ])
    do: [ :name | | subsubtree |
      subsubtree := subtree at: name.
      sorted add: (candidateAliasMap at: name).
      self transcribeGraph: subsubtree into: sorted ]
%

! Class implementation for 'CypressJsonParser'

!		Class methods for 'CypressJsonParser'

category: 'instance creation'
classmethod: CypressJsonParser
new

	CypressJsonError signal: 'Instantiate the parser with a stream.'
%

category: 'instance creation'
classmethod: CypressJsonParser
on: aStream
	^ self basicNew initializeOn: aStream
%

category: 'accessing'
classmethod: CypressJsonParser
parse: aString
	^ self parseStream: aString readStream
%

category: 'accessing'
classmethod: CypressJsonParser
parseStream: aStream
	^ (self on: aStream) parse
%

!		Instance methods for 'CypressJsonParser'

category: 'adding'
method: CypressJsonParser
addProperty: anAssociation to: anObject
	"Add the property anAssociation described with key and value to anObject. Subclasses might want to refine this implementation."
	
	^ anObject 
		add: anAssociation;
		yourself
%

category: 'adding'
method: CypressJsonParser
addValue: anObject to: aCollection
	"Add anObject to aCollection. Subclasses might want to refine this implementation."

	^ aCollection copyWith: anObject
%

category: 'creating'
method: CypressJsonParser
createArray
	"Create an empty collection. Subclasses might want to refine this implementation."

	^ Array new
%

category: 'creating'
method: CypressJsonParser
createFalse
	"Create the false literal. Subclasses might want to refine this implementation."
	
	^ false
%

category: 'creating'
method: CypressJsonParser
createNull
	"Create the null literal. Subclasses might want to refine this implementation."

	^ nil
%

category: 'creating'
method: CypressJsonParser
createObject
	"Create an empty object. Subclasses might want to refine this implementation."
	
	^ Dictionary new
%

category: 'creating'
method: CypressJsonParser
createProperty: aKey with: aValue
	"Create an empty attribute value pair. Subclasses might want to refine this implementation."
	
	^ aKey -> aValue
%

category: 'creating'
method: CypressJsonParser
createString: aString
	"Create a string literal. Subclasses might want to refine this implementation."

	^ aString
%

category: 'creating'
method: CypressJsonParser
createTrue
	"Create the true literal. Subclasses might want to refine this implementation."

	^ true
%

category: 'private'
method: CypressJsonParser
expect: aString
	"Expects aString and consume input, throw an error otherwise."

	^(self match: aString)
		ifFalse: [CypressJsonError signal: aString , ' expected']
%

category: 'initialization'
method: CypressJsonParser
initializeOn: aStream
	stream := aStream
%

category: 'private'
method: CypressJsonParser
match: aString
	"Tries to match aString, consume input and answer true if successful."
	
	| position |
	position := stream position.
	aString do: [ :each |
		(stream atEnd or: [ stream next ~= each ]) ifTrue: [ 
			stream position: position.
			^ false ] ].
	self whitespace.
	^ true
%

category: 'parsing'
method: CypressJsonParser
parse

	| result |
	result := self
				whitespace;
				parseValue.
	stream atEnd ifFalse: [CypressJsonError signal: 'end of input expected'].
	^result
%

category: 'parsing'
method: CypressJsonParser
parseArray

	| result |
	self expect: '['.
	result := self createArray.
	(self match: ']') ifTrue: [^result].
	[stream atEnd] whileFalse: 
			[result := self addValue: self parseValue to: result.
			(self match: ']') ifTrue: [^result].
			self expect: ','].
	CypressJsonError signal: 'end of array expected'
%

category: 'parsing-internal'
method: CypressJsonParser
parseCharacter
	| char |
	(char := stream next) = $\ 
		ifFalse: [ ^ char ].
	(char := stream next) = $" 
		ifTrue: [ ^ char ].
	char = $\
		ifTrue: [ ^ char ].
	char = $/
		ifTrue: [ ^ char ].
	char = $b
		ifTrue: [ ^ Character backspace ].
	char = $f
		ifTrue: [ ^ Character newPage ].
	char = $n
		ifTrue: [ ^ Character lf ].
	char = $r
		ifTrue: [ ^ Character cr ].
	char = $t
		ifTrue: [ ^ Character tab ].
	char = $u
		ifTrue: [ ^ self parseCharacterHex ].
	CypressJsonError signal: 'invalid escape character \' , (String with: char)
%

category: 'parsing-internal'
method: CypressJsonParser
parseCharacterHex
  | value |
  value := self parseCharacterHexDigit.
  3 timesRepeat: [ value := (value bitShift: 4) + self parseCharacterHexDigit ].
  ^ Character codePoint: value
%

category: 'parsing-internal'
method: CypressJsonParser
parseCharacterHexDigit
    | digit |
    stream atEnd
        ifFalse: [ 
            digit := stream next codePoint.
            (digit between: 48 and: 57)
                ifTrue: [ ^ digit - 48 ].	"$0"	"$9"
            (digit between: 65 and: 70)
                ifTrue: [ ^ digit - 55 ].	"$A"	"$F"
            (digit between: 97 and: 102)
                ifTrue: [ ^ digit - 87 ]	"$a"	"$f" ].
    CypressJsonError signal: 'hex-digit expected'
%

category: 'parsing-internal'
method: CypressJsonParser
parseNumber
	| negated number |
	negated := stream peek = $-.
	negated ifTrue: [ stream next ].
	number := self parseNumberInteger.
	(stream peek = $.) ifTrue: [
		stream next. 
		number := number + self parseNumberFraction ].
	(stream peek = $e or: [ stream peek = $E ]) ifTrue: [
		stream next.
		number := number * self parseNumberExponent ].
	negated ifTrue: [ number := number negated ].
	self whitespace.
	^ number
%

category: 'parsing-internal'
method: CypressJsonParser
parseNumberExponent
    | number negated |
    number := 0.
    negated := stream peek = $-.
    (negated or: [ stream peek = $+ ])
        ifTrue: [ stream next ].
    [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next codePoint - 48) ].
    negated
        ifTrue: [ number := number negated ].
    ^ 10 raisedTo: number
%

category: 'parsing-internal'
method: CypressJsonParser
parseNumberFraction
    | number power |
    number := 0.
    power := 1.0.
    [ stream atEnd not and: [ stream peek isDigit ] ]
        whileTrue: [ 
            number := 10 * number + (stream next codePoint - 48).
            power := power * 10.0 ].
    ^ number / power
%

category: 'parsing-internal'
method: CypressJsonParser
parseNumberInteger
    | number |
    number := 0.
    [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next codePoint - 48) ].
    ^ number
%

category: 'parsing'
method: CypressJsonParser
parseObject

	| result |
	self expect: '{'.
	result := self createObject.
	(self match: '}') ifTrue: [^result].
	[stream atEnd] whileFalse: 
			[result := self addProperty: self parseProperty to: result.
			(self match: '}') ifTrue: [^result].
			self expect: ','].
	CypressJsonError signal: 'end of object expected'
%

category: 'parsing-internal'
method: CypressJsonParser
parseProperty
	| name value |
	name := self parseString.
	self expect: ':'.
	value := self parseValue.
	^ self createProperty: name with: value.
%

category: 'parsing-internal'
method: CypressJsonParser
parseString
	| result |
	self expect: '"'.
	result := WriteStreamPortable on: String new.
	[ stream atEnd or: [ stream peek = $" ] ] 
		whileFalse: [ result nextPut: self parseCharacter ].
	^ self expect: '"'; createString: result contents
%

category: 'parsing'
method: CypressJsonParser
parseValue
	| char |
	stream atEnd ifFalse: [ 
		char := stream peek.
		char = ${
			ifTrue: [ ^ self parseObject ].
		char = $[
			ifTrue: [ ^ self parseArray ].
		char = $"
			ifTrue: [ ^ self parseString ].
		(char = $- or: [ char between: $0 and: $9 ])
			ifTrue: [ ^ self parseNumber ].
		(self match: 'true')
			ifTrue: [ ^ self createTrue ].
		(self match: 'false')
			ifTrue: [ ^ self createFalse ].
		(self match: 'null')
			ifTrue: [ ^ self createNull ] ].
	CypressJsonError signal: 'invalid input'
%

category: 'private'
method: CypressJsonParser
whitespace
	"Strip whitespaces from the input stream."

	[ stream atEnd not and: [ stream peek isSeparator ] ]
		whileTrue: [ stream next ]
%

! Class implementation for 'CypressObject'

!		Class methods for 'CypressObject'

category: 'miscellany'
classmethod: CypressObject
collection: aCollection gather: aOneArgBlock
	"Evaluate the block once for each element of aCollection. The block should answer a collection. 
	Answer an Array containing all elements of all the answered collections."

	| result |
	result := Array new.
	aCollection do: [:each | result addAll: (aOneArgBlock value: each)].
	^result
%

category: 'miscellany'
classmethod: CypressObject
elementsIn: sourceCollection butNotIn: exclusionCollection

	| exclusionSet |
	exclusionSet := exclusionCollection asSet.
	^sourceCollection reject: [:each | exclusionSet includes: each]
%

category: 'miscellany'
classmethod: CypressObject
elementsInBoth: collection1 and: collection2
	"Set intersection generalized to any collections."

	| temporarySet |
	temporarySet := collection2 asSet.
	^collection1 select: [:each | temporarySet includes: each]
%

category: 'converting'
classmethod: CypressObject
normalizeLineEndingsOf: aString
	"Answer a copy of aString with the line endings normalized to
	 correspond to the current platform, regardless of how they were
	 saved. For example, Squeak uses CR and would normalize with
	 #withSqueakLineEndings, for example.

	 GemStone Smalltalk uses the Unix line ending of LF."

	| cr lf inPos outPos outString newOutPos indexLF indexCR |
	cr := Character cr.
	indexCR := aString indexOf: cr startingAt: 1.
	indexCR = 0 ifTrue: [^aString].
	lf := Character lf.
	indexLF := aString indexOf: lf startingAt: 1.
	indexLF = 0 ifTrue: [^aString copyReplacing: cr with: lf].
	inPos := outPos := 1.
	outString := String new: aString size.
	
	["check if next CR is before next LF or if there are no more LF"
	(indexLF = 0 or: [indexCR < indexLF])
		ifTrue: 
			[newOutPos := outPos + 1 + indexCR - inPos.
			outString
				replaceFrom: outPos
				to: newOutPos - 2
				with: aString
				startingAt: inPos.
			outString at: newOutPos - 1 put: lf.
			outPos := newOutPos.
			1 + indexCR = indexLF
				ifTrue: 
					["Caught a CR-LF pair"
					inPos := 1 + indexLF.
					indexLF := aString indexOf: lf startingAt: inPos]
				ifFalse: [inPos := 1 + indexCR].
			indexCR := aString indexOf: cr startingAt: inPos]
		ifFalse: 
			[newOutPos := outPos + 1 + indexLF - inPos.
			outString
				replaceFrom: outPos
				to: newOutPos - 1
				with: aString
				startingAt: inPos.
			outPos := newOutPos.
			inPos := 1 + indexLF.
			indexLF := aString indexOf: lf startingAt: inPos].
	indexCR = 0]
			whileFalse.

	"no more CR line endings. copy the rest"
	newOutPos := outPos + (aString size - inPos + 1).
	outString
		replaceFrom: outPos
		to: newOutPos - 1
		with: aString
		startingAt: inPos.
	^outString copyFrom: 1 to: newOutPos - 1
%

!		Instance methods for 'CypressObject'

category: 'accessing'
method: CypressObject
allClasses

	| classes |
	classes := Array new.
	self symbolList
		do: [:dict | classes addAll: (dict select: [:each | each isBehavior])].
	^classes
%

category: 'private'
method: CypressObject
anyElementOf: aCollection ifEmpty: aBlock

	aCollection do: [:each | ^each].
	^aBlock value
%

category: 'accessing'
method: CypressObject
classesInPackageNamed: aString

	| packageName classes |
	packageName := aString asLowercase.
	classes := Array new.
	self symbolList do: 
			[:dict |
			classes
				addAll: (dict select: 
							[:each |
							each isBehavior and: 
									[| candidateName |
									candidateName := each category asLowercase.
									candidateName = packageName
										or: [(candidateName indexOfSubCollection: packageName , '-' startingAt: 1 ifAbsent: [ 0 ]) = 1]]])].
	^classes sortAscending: #('name')
%

category: 'miscellany'
method: CypressObject
collection: aCollection gather: aOneArgBlock
	"Evaluate the block once for each element of aCollection. The block should answer a collection. 
	Answer an Array containing all elements of all the answered collections."

	^self class collection: aCollection gather: aOneArgBlock
%

category: 'initializing'
method: CypressObject
defaultSymbolDictionaryName
  "Name of the SymbolDictionary where new classes should be installed"

  ^ #'UserGlobals'
%

category: 'sorting'
method: CypressObject
determineClassHierarchicalOrder: someClasses
	"Returns an ordered collection of the specified classes such that
	 hierarchical dependencies come first."
	"Not sure whether we ever get non-behaviors. 
	The previous, more complex, version of this method contained this filter."

	| order toBeOrdered processed aClass |
	toBeOrdered := (someClasses select: [:each | each isBehavior])
				asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[(aClass := self anyElementOf: toBeOrdered ifEmpty: [nil]) isNil]
		whileFalse: 
			[self
				orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed].
	^order
%

category: 'miscellany'
method: CypressObject
elementsIn: sourceCollection butNotIn: exclusionCollection

	^self class elementsIn: sourceCollection butNotIn: exclusionCollection
%

category: 'miscellany'
method: CypressObject
elementsInBoth: collection1 and: collection2
	"Set intersection generalized to any collections."

	^self class elementsInBoth: collection1 and: collection2
%

category: 'initializing'
method: CypressObject
initialize
	"Placeholder: #initialize is not defined by Object in GemStone Smalltalk."
%

category: 'converting'
method: CypressObject
normalizeLineEndingsOf: aString
	"Answer a copy of aString with the line endings normalized to
	 correspond to the current platform, regardless of how they were
	 saved. For example, Squeak uses CR and would normalize with
	 #withSqueakLineEndings, for example."

	^self class normalizeLineEndingsOf: aString.
%

category: 'private'
method: CypressObject
orderBySuperclass: aClass from: toBeOrdered into: order ignoring: processed
	"Private. Add to 'order', superclasses first, aClass and any of its superclasses 
	that appear in 'toBeOrdered' but do not appear in 'processed'.
	Remove from 'toBeOrdered' any class added to 'ordered'.
	Any class seen, add to 'processed' whether or not added to 'order'."

	| superclass |
	superclass := aClass superclass.
	superclass isNil | (processed includes: superclass)
		ifFalse: 
			[self
				orderBySuperclass: superclass
				from: toBeOrdered
				into: order
				ignoring: processed].
	processed add: aClass.
	(toBeOrdered includes: aClass)
		ifTrue: 
			[toBeOrdered remove: aClass.
			order add: aClass]
%

category: 'printing'
method: CypressObject
printDetailsOn: aStream
%

category: 'printing'
method: CypressObject
printOn: aStream

	| className |
	className := self class name.
	aStream
		nextPutAll: (className first isVowel ifTrue:[ 'an ' ] ifFalse:[ 'a ' ]);
		nextPutAll: className;
		nextPutAll: '('.
	self printDetailsOn: aStream.
	aStream nextPutAll: ')'.
%

category: 'accessing'
method: CypressObject
resolveGlobalNamed: aString

	^self resolveGlobalNamed: aString
		or: [CypressError signal: 'Could not resolve global named ' , aString printString]
%

category: 'accessing'
method: CypressObject
resolveGlobalNamed: aString or: aBlock

	^((System myUserProfile resolveSymbol: aString) ifNil: [^aBlock value])
		value
%

category: 'converting'
method: CypressObject
stringForVariables: variableList

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	variableList do: [:each | stream nextPutAll: each]
		separatedBy: [stream space].
	^stream contents
%

category: 'accessing'
method: CypressObject
symbolDictionaryForClassNamed: aString
  "Answer the SymbolDictionary containing the named class.
	 If there are multiple answers, answer the first.
	 If there are no answers (i.e., the class does not exist), put it in UserGlobals."

  ^ self
    symbolDictionaryForClassNamed: aString
    or: [ System myUserProfile objectNamed: self defaultSymbolDictionaryName ]
%

category: 'accessing'
method: CypressObject
symbolDictionaryForClassNamed: aString or: aBlock
	"Answer the SymbolDictionary containing the named class.
	 If there are multiple answers, answer the first.
	 If there are no answers (i.e., the class does not exist), answer
	 the result of evaluating aBlock."

	^self symbolList asArray
		detect: [:each | each anySatisfy: [:every | every isBehavior and: [every name asString = aString asString]]]
		ifNone: aBlock
%

category: 'accessing'
method: CypressObject
symbolList
  ^ System myUserProfile symbolList
%

! Class implementation for 'CypressAbstractPackageInformation'

!		Class methods for 'CypressAbstractPackageInformation'

category: 'Instance Creation'
classmethod: CypressAbstractPackageInformation
named: aString

	^self new
		initializeWithName: aString;
		yourself
%

!		Instance methods for 'CypressAbstractPackageInformation'

category: 'Initializing - private'
method: CypressAbstractPackageInformation
initialize
%

category: 'Initializing - private'
method: CypressAbstractPackageInformation
initializeWithName: aString

	self initialize.
	self name: aString
%

category: 'Testing'
method: CypressAbstractPackageInformation
isKnown

	^false
%

category: 'Accessing'
method: CypressAbstractPackageInformation
name

	^name
%

category: 'Updating'
method: CypressAbstractPackageInformation
name: aString

	name := aString
%

category: 'Printing'
method: CypressAbstractPackageInformation
printDetailsOn: aStream

	aStream nextPutAll: self name
%

category: 'Accessing'
method: CypressAbstractPackageInformation
repositories

	^#()
%

! Class implementation for 'CypressConflictingPackageInformation'

!		Class methods for 'CypressConflictingPackageInformation'

category: 'Instance Creation'
classmethod: CypressConflictingPackageInformation
fromUnknown: unknownPackageInformation conflictingWith: knownPackageInformation

	^(self named: unknownPackageInformation name)
		conflictsWith: knownPackageInformation;
		yourself.
%

!		Instance methods for 'CypressConflictingPackageInformation'

category: 'Accessing'
method: CypressConflictingPackageInformation
conflictsWith

	^conflictsWith
%

category: 'Updating'
method: CypressConflictingPackageInformation
conflictsWith: someCypressKnownPackageInformations

	conflictsWith := someCypressKnownPackageInformations
%

! Class implementation for 'CypressEclipsedPackageInformation'

!		Class methods for 'CypressEclipsedPackageInformation'

category: 'Instance Creation'
classmethod: CypressEclipsedPackageInformation
fromUnknown: unknownPackageInformation eclipsedBy: knownPackageInformation

	^(self named: unknownPackageInformation name)
		eclipsedBy: knownPackageInformation;
		yourself.
%

!		Instance methods for 'CypressEclipsedPackageInformation'

category: 'Accessing'
method: CypressEclipsedPackageInformation
eclipsedBy

	^eclipsedBy
%

category: 'Updating'
method: CypressEclipsedPackageInformation
eclipsedBy: aPackageInformation

	eclipsedBy := aPackageInformation
%

! Class implementation for 'CypressKnownPackageInformation'

!		Class methods for 'CypressKnownPackageInformation'

category: 'Instance Creation'
classmethod: CypressKnownPackageInformation
fromUnknown: aPackageInformation

	^self named: aPackageInformation name
%

!		Instance methods for 'CypressKnownPackageInformation'

category: 'Updating'
method: CypressKnownPackageInformation
addRepository: aRepository

	self repositories at: aRepository url put: aRepository.
	self updateDigestsFromImageAndRepository: aRepository.
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
determineDigestFromImage

	^self packageStructure digest
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
determineDigestFromRepository: aRepository

	^ (aRepository readPackageStructureForPackageNamed: self name) digest.
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
digestFor: source

	^self digestFor: source or: [nil]
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
digestFor: source or: aBlock

	^self digests at: source ifAbsent: aBlock
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
digests

	^digests
%

category: 'Initializing - private'
method: CypressKnownPackageInformation
digests: anIdentityDictionary
	"Key: Source of package definitions (#IMAGE or a Repository url)
	 Value: (e.g. MD5) Digest of the package's defintions or an empty string.
	 A nil digest means there are no definitions for the given source."

   digests := anIdentityDictionary
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
imageDigest

	^self digestFor: #IMAGE.
%

category: 'Initializing - private'
method: CypressKnownPackageInformation
initialize

	super initialize.
	self
		repositories: IdentityDictionary new;
		digests: IdentityDictionary new.
%

category: 'Testing'
method: CypressKnownPackageInformation
isKnown

	^true
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
packageStructure

	^CypressPackageStructure
		fromPackage: (CypressPackageDefinition named: self name)
%

category: 'Updating'
method: CypressKnownPackageInformation
removeRepository: aRepository

	self repositories removeKey: aRepository url ifAbsent: [].
	self digests removeKey: aRepository url ifAbsent: [].
	self updateDigestsFromImage.
%

category: 'Accessing'
method: CypressKnownPackageInformation
repositories

	^repositories
%

category: 'Initializing - private'
method: CypressKnownPackageInformation
repositories: anIdentityDictionary
	"Key: Repository url
	 Value: Repository"

	repositories := anIdentityDictionary
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
repositoryDigests

	^self repositories collect: [:each | self digestFor: each url]
%

category: 'Updating - digests'
method: CypressKnownPackageInformation
updateDigestsFromAllRepositories

	self repositories do: [:each | self updateDigestsFromRepository: each]
%

category: 'Updating - digests'
method: CypressKnownPackageInformation
updateDigestsFromImage

	self digests at: #IMAGE put: self determineDigestFromImage
%

category: 'Updating - digests'
method: CypressKnownPackageInformation
updateDigestsFromImageAndAllRepositories

	self
		updateDigestsFromImage;
		updateDigestsFromAllRepositories
%

category: 'Updating - digests'
method: CypressKnownPackageInformation
updateDigestsFromImageAndRepository: aRepository

	self
		updateDigestsFromImage;
		updateDigestsFromRepository: aRepository
%

category: 'Updating - digests'
method: CypressKnownPackageInformation
updateDigestsFromRepository: aRepository

	self digests at: aRepository url put: (self determineDigestFromRepository: aRepository).
%

category: 'Writing'
method: CypressKnownPackageInformation
writeChangesToAllRepositories

	| imageDigest changedDigests changedRepositories |
	self updateDigestsFromImageAndAllRepositories.
	imageDigest := self imageDigest.
	changedDigests := self repositoryDigests reject: [:each | each = imageDigest].
	changedRepositories := changedDigests keys collect: [:each | self repositories at: each].
	self writePackageToRepositories: changedRepositories.
%

category: 'Writing'
method: CypressKnownPackageInformation
writePackageToRepositories: someRepositories

	| packageStructure |
	packageStructure := self packageStructure.
	^someRepositories
		do: [:each | each writePackageStructure: packageStructure]
%

! Class implementation for 'CypressDefinition'

!		Instance methods for 'CypressDefinition'

category: 'comparing'
method: CypressDefinition
= aDefinition

	^(aDefinition isKindOf: CypressDefinition)
		and: [aDefinition description = self description]
%

category: 'loading'
method: CypressDefinition
actualClass

	self subclassResponsibility: #actualClass
%

category: 'visiting'
method: CypressDefinition
classDefinition: classBlock methodDefinition: methodBlock
	"default is noop"
%

category: 'accessing'
method: CypressDefinition
description
	self subclassResponsibility: #description
%

category: 'accessing'
method: CypressDefinition
details

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	self printDetailsOn: stream.
	^stream contents
%

category: 'comparing'
method: CypressDefinition
hash
    ^ self description hash
%

category: 'testing'
method: CypressDefinition
isSameRevisionAs: aDefinition
	^ self = aDefinition
%

category: 'loading'
method: CypressDefinition
loadClassDefinition
  self loadClassDefinition: self defaultSymbolDictionaryName
%

category: 'loading'
method: CypressDefinition
loadClassDefinition: aDefaultSymbolDictionaryName
  "default is to do nothing"
%

category: 'loading'
method: CypressDefinition
loadMethodDefinition
	"default is to do nothing"
%

category: 'loading'
method: CypressDefinition
postLoad
	"noop"
%

category: 'loading'
method: CypressDefinition
postLoadOver: aDefinition

	self postLoad
%

category: 'dependency'
method: CypressDefinition
provisions
	"Answer list of global names defined by this definition"

	^#()
%

category: 'dependency'
method: CypressDefinition
requirements
	"Answer list of global names required by this definition"

	^#()
%

category: 'loading'
method: CypressDefinition
unloadDefinition

	self subclassResponsibility: #unloadDefinition
%

! Class implementation for 'CypressClassDefinition'

!		Class methods for 'CypressClassDefinition'

category: 'instance creation'
classmethod: CypressClassDefinition
forClass: aClass

	| superclassname |
	superclassname := aClass superclass
				ifNil: ['nil']
				ifNotNil: [:sClass | sClass name].
	^self
		name: aClass name
		superclassName: superclassname
		category: aClass category
		instVarNames: aClass instVarNames
		classInstVarNames: aClass class instVarNames
		classVarNames: aClass classVarNames
		poolDictionaryNames: aClass sharedPools
		comment: aClass rwComment
		subclassType: (self subclassTypeOf: aClass)
%

category: 'private'
classmethod: CypressClassDefinition
subclassTypeOf: aClass
	"Answer a description of the argument to identify whether it is a regular class,
	 a byte subclass, or an indexable subclass."

	^(aClass isBytes and: [aClass superClass isBytes not])
		ifTrue: ['byteSubclass']
		ifFalse: 
			[(aClass isIndexable and: [aClass superClass isIndexable not])
				ifTrue: ['indexableSubclass']
				ifFalse: ['']]
%

!		Instance methods for 'CypressClassDefinition'

category: 'comparing'
method: CypressClassDefinition
= aDefinition
  ^ super = aDefinition
    and: [ 
      superclassName = aDefinition superclassName
        and: [ 
          category = aDefinition category
            and: [ 
              instVarNames = aDefinition instVarNames
                and: [ 
                  classInstVarNames = aDefinition classInstVarNames
                    and: [ 
                      classVarNames asSortedCollection = aDefinition classVarNames asSortedCollection
                        and: [ 
                          poolDictionaryNames = aDefinition poolDictionaryNames
                            and: [ comment = aDefinition comment ] ] ] ] ] ] ]
%

category: 'loading'
method: CypressClassDefinition
actualClass

	^self resolveGlobalNamed: self name
%

category: 'loading'
method: CypressClassDefinition
actualClassOrNil

	^self resolveGlobalNamed: self name or: [nil]
%

category: 'converting'
method: CypressClassDefinition
asCypressClassDefinition

	^self
%

category: 'accessing'
method: CypressClassDefinition
category

	^category
%

category: 'visiting'
method: CypressClassDefinition
classDefinition: classBlock methodDefinition: methodBlock

	classBlock value: self
%

category: 'accessing'
method: CypressClassDefinition
classDefinitionCreationString

	| stream symbolDict |
	stream := WriteStreamPortable on: (String new: 100).
	stream
		nextPutAll: '(CypressClassDefinition';
		lf;
		tab;
		nextPutAll: 'name: ' , self className printString;
		lf;
		tab;
		nextPutAll: 'superclassName: ' , self superclassName printString;
		lf;
		tab;
		nextPutAll: 'category: ' , self category printString;
		lf;
		tab;
		nextPutAll: 'instVarNames: #(' , self instanceVariablesString , ')';
		lf;
		tab;
		nextPutAll: 'classInstVarNames: #(' , self classInstanceVariablesString
					, ')';
		lf;
		tab;
		nextPutAll: 'classVarNames: #(' , self classVariablesString , ')';
		lf;
		tab;
		nextPutAll: 'poolDictionaryNames: #(' , self poolDictionariesString , ')';
		lf;
		tab;
		nextPutAll: 'comment: ' , self comment printString;
		lf;
		tab;
		nextPutAll: 'subclassType: ' , self subclassType printString , ')';
		lf;
		tab;
		tab;
		yourself.
	symbolDict := self symbolDictionaryForClassNamed: self className.
	self actualClassOrNil isNil
		ifTrue: 
			[stream
				nextPutAll: 'loadClassDefinition.';
				yourself]
		ifFalse: 
			[stream
				nextPutAll: 'loadClassDefinition: ' , symbolDict name asString printString
							, '.';
				yourself].
	^stream contents
%

category: 'private'
method: CypressClassDefinition
classInstanceVariablesString
  ^ self stringForVariables: self classInstVarNames
%

category: 'accessing'
method: CypressClassDefinition
classInstVarNames
  ^ classInstVarNames
%

category: 'accessing'
method: CypressClassDefinition
className

	^self name
%

category: 'loading'
method: CypressClassDefinition
classNeedingMigration: aClass
  "right now we will create classes without doing a migration ..."

  
%

category: 'private'
method: CypressClassDefinition
classVariablesString
  ^ self stringForVariables: self classVarNames asSortedCollection
%

category: 'accessing'
method: CypressClassDefinition
classVarNames
  ^ classVarNames sort
%

category: 'accessing'
method: CypressClassDefinition
comment

	^comment
%

category: 'loading'
method: CypressClassDefinition
createOrReviseByteClass
	"To be resolved:
		- the question of an 'environment' in which to create the class.
		- the question of which SymbolDictionary in which to create the class.
	 These are perhaps the same question."

	| superClass |
	superClass := self resolveGlobalNamed: self superclassName.
	^(superClass
		byteSubclass: self name
		classVars: (self classVarNames collect: [:each | each asSymbol])
		classInstVars: (self classInstVarNames collect: [:each | each asSymbol])
		poolDictionaries: self poolDictionaryList
		inDictionary: (self symbolDictionaryForClassNamed: self name)
		options: #())
			category: category;
			comment: self comment
%

category: 'loading'
method: CypressClassDefinition
createOrReviseIndexableClass
	"To be resolved:
		- the question of an 'environment' in which to create the class.
		- the question of which SymbolDictionary in which to create the class.
	 These are perhaps the same question."

	| superClass |
	superClass := self resolveGlobalNamed: self superclassName.
	^(superClass
		indexableSubclass: self name
		instVarNames: (self instVarNames collect: [:each | each asSymbol])
		classVars: (self classVarNames collect: [:each | each asSymbol])
		classInstVars: (self classInstVarNames collect: [:each | each asSymbol])
		poolDictionaries: self poolDictionaryList
		inDictionary: (self symbolDictionaryForClassNamed: self name)
		options: #())
			category: category;
			comment: self comment
%

category: 'loading'
method: CypressClassDefinition
createOrReviseRegularClass
	"To be resolved:
		- the question of an 'environment' in which to create the class.
		- the question of which SymbolDictionary in which to create the class.
	 These are perhaps the same question."

	| superClass |
	superClass := self resolveGlobalNamed: self superclassName.
	^(superClass
		subclass: self name
		instVarNames: (self instVarNames collect: [:each | each asSymbol])
		classVars: (self classVarNames collect: [:each | each asSymbol])
		classInstVars: (self classInstVarNames collect: [:each | each asSymbol])
		poolDictionaries: self poolDictionaryList
		inDictionary: (self symbolDictionaryForClassNamed: self name)
		options: #())
			category: category;
			comment: self comment
%

category: 'accessing'
method: CypressClassDefinition
defaultSymbolDictionaryName
  ^ defaultSymbolDictionaryName ifNil: [ super defaultSymbolDictionaryName ]
%

category: 'accessing'
method: CypressClassDefinition
defaultSymbolDictionaryName: aSymbol
  defaultSymbolDictionaryName := aSymbol
%

category: 'accessing'
method: CypressClassDefinition
description

	^ Array with: name
%

category: 'loading'
method: CypressClassDefinition
failedCompiledMethods: someCompiledMethods

	someCompiledMethods isEmpty ifTrue: [^self].
	self halt: 'not implemented yet'
%

category: 'accessing'
method: CypressClassDefinition
gs_constraints

	^gs_constraints ifNil: [ gs_constraints := #() ]
%

category: 'accessing'
method: CypressClassDefinition
gs_constraints: aCollection

	gs_constraints := aCollection
%

category: 'accessing'
method: CypressClassDefinition
gs_options

	^gs_options ifNil: [ gs_options := #() ]
%

category: 'accessing'
method: CypressClassDefinition
gs_options: aCollection

	gs_options := aCollection
%

category: 'accessing'
method: CypressClassDefinition
gs_reservedOop
	^ ''
%

category: 'comparing'
method: CypressClassDefinition
hash

	| hash |
	hash := name hash.
	hash := superclassName hash bitOr: hash.
	hash := (category ifNil: ['']) hash bitOr: hash.
	instVarNames , classInstVarNames, classVarNames, poolDictionaryNames
		do: [:vName | hash := vName hash bitOr: hash].
	^hash
%

category: 'private'
method: CypressClassDefinition
instanceVariablesString
    ^ self stringForVariables: self instVarNames
%

category: 'accessing'
method: CypressClassDefinition
instVarNames
  ^ instVarNames
%

category: 'testing'
method: CypressClassDefinition
isClassDefinition
  ^ true
%

category: 'testing'
method: CypressClassDefinition
isMethodDefinition
  ^ false
%

category: 'loading'
method: CypressClassDefinition
loadClassDefinition
  "Create a new version of the defined class. If the class already exists,
	 copy the behaviors and state from the old version."

  ^ self loadClassDefinition: self defaultSymbolDictionaryName
%

category: 'loading'
method: CypressClassDefinition
loadClassDefinition: aDefaultSymbolDictionaryName
	"Create a new version of the defined class. If the class already exists,
	 copy the behaviors and state from the old version."

	| newClass oldClass |
        self defaultSymbolDictionaryName: aDefaultSymbolDictionaryName.
	oldClass := self actualClassOrNil.
	newClass := self createOrReviseClass.
	(oldClass isNil or: [newClass == oldClass]) ifTrue: [^self].
	self classNeedingMigration: newClass.
	self
		recompileWithSubclassesFrom: oldClass
		to: newClass
		symbolList: System myUserProfile symbolList.
%

category: 'accessing'
method: CypressClassDefinition
name

	^name
%

category: 'initialization'
method: CypressClassDefinition
name: aClassName superclassName: aSuperclassName category: aCategory instVarNames: someInstanceVariableNames classInstVarNames: someClassInstanceVariableNames classVarNames: someClassVariableNames poolDictionaryNames: somePoolDictionaryNames comment: aComment subclassType: aSubclassType

	name := aClassName.
	superclassName := aSuperclassName.
	category := aCategory.
	instVarNames := someInstanceVariableNames.
	classInstVarNames := someClassInstanceVariableNames.
	classVarNames := someClassVariableNames.
	poolDictionaryNames := somePoolDictionaryNames.
	comment := aComment.
	subclassType := aSubclassType asString
%

category: 'initialization'
method: CypressClassDefinition
name: aClassName superclassName: aSuperclassName category: aCategory instVarNames: someInstanceVariableNames 
	classInstVarNames: someClassInstanceVariableNames classVarNames: someClassVariableNames 
	poolDictionaryNames: somePoolDictionaryNames gs_options: someGs_options gs_constraints: someGs_constraints
	comment: aComment subclassType: aSubclassType

	name := aClassName.
	superclassName := aSuperclassName.
	category := aCategory.
	instVarNames := someInstanceVariableNames.
	classInstVarNames := someClassInstanceVariableNames.
	classVarNames := someClassVariableNames.
	poolDictionaryNames := somePoolDictionaryNames.
	gs_options := someGs_options.
	gs_constraints := someGs_constraints.
	comment := aComment.
	subclassType := aSubclassType asString
%

category: 'loading'
method: CypressClassDefinition
poolDictionariesForNames: pdNames
  | ar existingDict symList sharedPool |
  ar := Array new.
  symList := System myUserProfile symbolList.
  pdNames
    do: [ :poolName | 
      existingDict := symList objectNamed: poolName.
      existingDict
        ifNil: [ 
          | pool |
          pool := SymbolDictionary new.
          pool name: poolName asSymbol.
          ar add: pool ]
        ifNotNil: [ 
          (existingDict isKindOf: SymbolDictionary)
            ifTrue: [ ar add: existingDict ]
            ifFalse: [ 
              sharedPool ifNil: [ sharedPool := symList objectNamed: #'SharedPool' ].
              ((existingDict isKindOf: Class)
                and: [ existingDict isSubclassOf: sharedPool ])
                ifTrue: [ 
                  | cvars pName |
                  ar add: (cvars := existingDict _createClassVarsDict).
                  pName := poolName asSymbol.	"only change dictionary name if needed , to avoid SecurityError"
                  cvars name ~~ pName
                    ifTrue: [ cvars name: pName ] ] ] ] ].
  ^ ar
%

category: 'private'
method: CypressClassDefinition
poolDictionariesString
  ^ self stringForVariables: self poolDictionaryNames
%

category: 'loading'
method: CypressClassDefinition
poolDictionaryList

  ^ self poolDictionariesForNames: self poolDictionaryNames
%

category: 'accessing'
method: CypressClassDefinition
poolDictionaryNames

	^poolDictionaryNames
%

category: 'printString'
method: CypressClassDefinition
printDetailsOn: aStream

	aStream nextPutAll: self name
%

category: 'dependency'
method: CypressClassDefinition
provisions
	"Answer list of global names defined by this definition"

	^{ self name }
%

category: 'loading'
method: CypressClassDefinition
recompileWithSubclassesFrom: oldClass to: newClass symbolList: aSymbolList

	| olds news removedClassVariables removedSharedPools organizer subclasses newSubclass |
	olds := oldClass _classVars ifNil: [#()] ifNotNil: [:vars | vars keys].
	news := newClass _classVars ifNil: [#()] ifNotNil: [:vars | vars keys].
	removedClassVariables := self elementsIn: olds butNotIn: news.
	removedSharedPools := self elementsIn: oldClass sharedPools
				butNotIn: newClass sharedPools.
	self failedCompiledMethods: (newClass
				_copyMethodsAndVariablesFrom: oldClass
				except: 
					{$V.
					removedClassVariables.
					$P.
					removedSharedPools}
				dictionaries: aSymbolList).
	organizer := ClassOrganizer new.
	subclasses := organizer subclassesOf: oldClass.


	"Do this -after- #subclassesOf:, which has the side effect of replacing the new
	  class with the old class in the organizer"
	organizer addClass: newClass.

	"Iterate over all the first-level subclasses of the old class to create new subclasses"
	subclasses do: 
			[:oldSubclass |
			newSubclass := 
					[oldSubclass definition evaluateInContext: nil symbolList: aSymbolList]
							on: Error
							do: [:ex | ex return: nil].
			(newSubclass notNil and: [newSubclass ~~ oldSubclass])
				ifTrue: 
					[self
						classNeedingMigration: newSubclass;
						recompileWithSubclassesFrom: oldSubclass
							to: newSubclass
							symbolList: aSymbolList]]
%

category: 'dependency'
method: CypressClassDefinition
requirements
	"Answer list of global names required by this definition"

  self superclassName = 'nil'
    ifTrue: [ ^ #() ].
  ^{self superclassName}
%

category: 'accessing'
method: CypressClassDefinition
subclassType

	^subclassType
%

category: 'accessing'
method: CypressClassDefinition
superclassName

	^superclassName
%

category: 'loading'
method: CypressClassDefinition
unloadDefinition
	"GemStone could hold multiple definitions of the same class name.
	 Ignore aliased references.
	 Unload only the first one resolved.
	 It is an error if there is not at least one SymbolDictionary holding a
	 class with that name."

	| dictionarySymbolPair |
	dictionarySymbolPair := ((System myUserProfile symbolList
				dictionariesAndSymbolsOf: self actualClass)
					select: [:each | each last = self name asSymbol]) first.
	dictionarySymbolPair first removeKey: dictionarySymbolPair last
%

! Class implementation for 'CypressMethodDefinition'

!		Class methods for 'CypressMethodDefinition'

category: 'instance creation'
classmethod: CypressMethodDefinition
className: aName classIsMeta: isMetaclass selector: aSelector category: aCategory source: aSource

	^self new
		className: aName asString
		classIsMeta: isMetaclass
		selector: aSelector asString
		category: aCategory asString
		source: (self normalizeLineEndingsOf: aSource)
%

category: 'instance creation'
classmethod: CypressMethodDefinition
forMethod: aGsNMethod

	| behavior selector |
	behavior := aGsNMethod inClass.
	selector := aGsNMethod selector.
	^self new
		className: behavior theNonMetaClass name asString
		classIsMeta: behavior isMeta
		selector: selector asString
		category: (behavior categoryOfSelector: selector) asString
		source: (self normalizeLineEndingsOf: aGsNMethod sourceString asString)
%

!		Instance methods for 'CypressMethodDefinition'

category: 'comparing'
method: CypressMethodDefinition
= aDefinition
    ^ super = aDefinition
        and: [ aDefinition source = self source
                and: [ aDefinition category = self category ] ]
%

category: 'loading'
method: CypressMethodDefinition
actualClass

  ^ self theNonMetaClass
    ifNotNil: [:cls |
      self classIsMeta
        ifTrue: [ cls class ]
        ifFalse: [ cls  ] ].
%

category: 'converting'
method: CypressMethodDefinition
asCypressMethodDefinition

	^self
%

category: 'accessing'
method: CypressMethodDefinition
category

	^category
%

category: 'visiting'
method: CypressMethodDefinition
classDefinition: classBlock methodDefinition: methodBlock

	methodBlock value: self
%

category: 'accessing'
method: CypressMethodDefinition
classIsMeta

	^classIsMeta
%

category: 'accessing'
method: CypressMethodDefinition
className

	^className
%

category: 'initialization'
method: CypressMethodDefinition
className: aName classIsMeta: isMetaclass selector: aSelector category: aCategory source: aSource

	className := aName.
	classIsMeta := isMetaclass.
	selector := aSelector.
	category := aCategory.
	source := self normalizeLineEndingsOf: aSource
%

category: 'accessing'
method: CypressMethodDefinition
description
	^ Array	
		with: className
		with: selector
		with: classIsMeta
%

category: 'comparing'
method: CypressMethodDefinition
hash

	| hash |
	hash := classIsMeta asString hash.
	hash := source hash bitOr: hash.
	hash := category hash bitOr: hash.
	hash := className hash bitOr: hash.
	^hash
%

category: 'visiting'
method: CypressMethodDefinition
instanceMethod: instanceBlock classMethod: classBlock

	^(self classIsMeta
		ifTrue: [ classBlock ]
		ifFalse: [ instanceBlock ]) value: self
%

category: 'testing'
method: CypressMethodDefinition
isClassDefinition
  ^ false
%

category: 'testing'
method: CypressMethodDefinition
isInitializer
	^ self selector = 'initialize' and: [self classIsMeta]
%

category: 'testing'
method: CypressMethodDefinition
isMethodDefinition
  ^ true
%

category: 'loading'
method: CypressMethodDefinition
loadMethodDefinition

	self actualClass
		compileMethod: self source
		dictionaries: System myUserProfile symbolList
		category: self category
		environmentId: 0
%

category: 'loading'
method: CypressMethodDefinition
postLoadOver: aDefinition

	super postLoadOver: aDefinition.
	(self isInitializer
		and: [ aDefinition isNil or: [ self source ~= aDefinition source ]]) 
			ifTrue: [ self theNonMetaClass initialize ].
%

category: 'printing'
method: CypressMethodDefinition
printDetailsOn: aStream

	aStream
		nextPutAll: self className;
		nextPutAll: (self classIsMeta ifTrue: [' class'] ifFalse: ['']);
		nextPutAll: '>>';
		nextPutAll: self selector.
%

category: 'dependency'
method: CypressMethodDefinition
requirements
	"Answer list of global names required by this definition"

	^{self className}
%

category: 'accessing'
method: CypressMethodDefinition
selector

	^selector
%

category: 'accessing'
method: CypressMethodDefinition
source

	^source
%

category: 'loading'
method: CypressMethodDefinition
theNonMetaClass

	^self resolveGlobalNamed: self className or: []
%

category: 'loading'
method: CypressMethodDefinition
unloadDefinition

  self actualClass ifNotNil: [:cl | cl removeSelector: self selector asSymbol ].
%

! Class implementation for 'RwCypressMethodDefinition'

!		Instance methods for 'RwCypressMethodDefinition'

category: 'accessing'
method: RwCypressMethodDefinition
isExtensionMethod

	^ isExtensionMethod ifNil: [ isExtensionMethod := false ]
%

category: 'accessing'
method: RwCypressMethodDefinition
isExtensionMethod: anObject

   isExtensionMethod := anObject
%

! Class implementation for 'CypressDefinitionIndex'

!		Class methods for 'CypressDefinitionIndex'

category: 'instance creation'
classmethod: CypressDefinitionIndex
definitions: aCollection
	^ self new addAll: aCollection
%

!		Instance methods for 'CypressDefinitionIndex'

category: 'adding'
method: CypressDefinitionIndex
add: aDefinition
	^ self definitionMap at: aDefinition description put: aDefinition
%

category: 'adding'
method: CypressDefinitionIndex
addAll: aCollection
	aCollection do: [:ea | self add: ea]
%

category: 'querying'
method: CypressDefinitionIndex
definitionLike: aDefinition ifPresent: foundBlock ifAbsent: errorBlock
	| definition |
	definition := self definitionMap at: aDefinition description ifAbsent: [].
	^ definition
		ifNil: errorBlock
		ifNotNil: [foundBlock value: definition]
%

category: 'accessing'
method: CypressDefinitionIndex
definitionMap
	definitionMap ifNil: [ definitionMap := Dictionary new ].
	^ definitionMap
%

category: 'accessing'
method: CypressDefinitionIndex
definitions
	^self definitionMap values
%

category: 'removing'
method: CypressDefinitionIndex
remove: aDefinition
	self definitionMap removeKey: aDefinition description ifAbsent: []
%

! Class implementation for 'CypressDependencySorter'

!		Instance methods for 'CypressDependencySorter'

category: 'building'
method: CypressDependencySorter
add: aPatchOperation
	| requirements |
	requirements := self unresolvedRequirementsFor: aPatchOperation.
	requirements isEmpty
		ifTrue: [self addToOrder: aPatchOperation]
		ifFalse: [self addRequirements: requirements for: aPatchOperation].
	^ aPatchOperation
%

category: 'building'
method: CypressDependencySorter
addAll: aCollection
	aCollection do: [:aPatchOperation | self add: aPatchOperation ]
%

category: 'private'
method: CypressDependencySorter
addExternalProvisions: aCollection

	(self elementsInBoth: aCollection and: self externalRequirements)
		do: [:globalName | self addProvision: globalName]
%

category: 'private'
method: CypressDependencySorter
addProvision: aGlobalName
	| newlySatisfied |
	self provided add: aGlobalName.
	newlySatisfied := self required removeKey: aGlobalName ifAbsent: [#()].
	self addAll: newlySatisfied.
%

category: 'private'
method: CypressDependencySorter
addRequirement: globalName for: aPatchOperation
	(self itemsRequiring: globalName) add: aPatchOperation
%

category: 'private'
method: CypressDependencySorter
addRequirements: aCollection for: aPatchOperation
	aCollection do: [:globalName | self addRequirement: globalName for: aPatchOperation]
%

category: 'private'
method: CypressDependencySorter
addToOrder: aPatchOperation
	self orderedItems add: aPatchOperation.
	aPatchOperation provisions do: [:globalName | self addProvision: globalName ].
%

category: 'accessing'
method: CypressDependencySorter
externalRequirements

	| unloaded providedByUnloaded |
	unloaded := self itemsWithMissingRequirements.
	providedByUnloaded := (self collection: unloaded
				gather: [:e | e provisions]) asSet.
	^self required keys
		reject: [:globalName | providedByUnloaded includes: globalName]
%

category: 'private'
method: CypressDependencySorter
itemsRequiring: globalName
	^ self required at: globalName ifAbsentPut: [Set new]
%

category: 'accessing'
method: CypressDependencySorter
itemsWithMissingRequirements
	| patchOperations |
	patchOperations := Set new.
	self required values do: [:aSetOfPatchOperations | patchOperations addAll: aSetOfPatchOperations ].
	^ patchOperations
%

category: 'accessing'
method: CypressDependencySorter
orderedItems
	"ordered list of patch operations"

	orderedItems ifNil: [ orderedItems := OrderedCollection new ].
	^orderedItems
%

category: 'accessing'
method: CypressDependencySorter
provided
	"set of global names provided by definitions already loaded"

	provided ifNil: [ provided := Set new ].
	^provided
%

category: 'accessing'
method: CypressDependencySorter
required
	"dictionary of required global name mapped to list of definitions that require the global"

	required ifNil: [ required := Dictionary new ].
	^required
%

category: 'private'
method: CypressDependencySorter
unresolvedRequirementsFor: aPatchOperation
	"Answer a list of global names that are required by <aPatchOperation>, but not 
	 provided by patchOperations that have already been processed"

	^self elementsIn: aPatchOperation requirements butNotIn: self provided
%

! Class implementation for 'CypressEnvironmentDependencySorter'

!		Instance methods for 'CypressEnvironmentDependencySorter'

category: 'building'
method: CypressEnvironmentDependencySorter
add: aPatchOperation
  | requirements |
  requirements := self unresolvedRequirementsFor: aPatchOperation.
  requirements removeIfPresent: 'nil'.
  requirements removeIfPresent: nil.
  requirements isEmpty
    ifTrue: [ self addToOrder: aPatchOperation ]
    ifFalse: [ self addRequirements: requirements for: aPatchOperation ].
  ^ aPatchOperation
%

! Class implementation for 'CypressLoader'

!		Class methods for 'CypressLoader'

category: 'accessing'
classmethod: CypressLoader
defaultSymbolDictionaryName
  "Name of the SymbolDictionary where new classes should be installed"

  ^ (SessionTemps current 
      at: #'Cypress_Loader_Default_Symbol_Dictionary_Name' 
      ifAbsent: [] ) 
        ifNil: [
          System myUserProfile userId = 'SystemUser'
          ifTrue: [ #Globals ]
          ifFalse: [ #'UserGlobals' ] ]
%

category: 'accessing'
classmethod: CypressLoader
defaultSymbolDictionaryName: aSymbol
  SessionTemps current 
      at: #'Cypress_Loader_Default_Symbol_Dictionary_Name'
      put: aSymbol
%

category: 'unloading'
classmethod: CypressLoader
unloadSnapshot: aSnapshot
  ^ self new
    unloadSnapshot: aSnapshot;
    load
%

category: 'loading'
classmethod: CypressLoader
updatePackage: aPackage defaultSymbolDictionaryName: defaultSymbolDictionaryName withSnapshot: aSnapshot
  "Answer the loader used to apply the update."

  ^ self new
    defaultSymbolDictionaryName: defaultSymbolDictionaryName;
    updatePackage: aPackage withSnapshot: aSnapshot;
    load
%

category: 'loading'
classmethod: CypressLoader
updatePackage: aPackage withSnapshot: aSnapshot
  "Answer the loader used to apply the update."

  ^ self
    updatePackage: aPackage
    defaultSymbolDictionaryName: nil
    withSnapshot: aSnapshot
%

!		Instance methods for 'CypressLoader'

category: 'updating'
method: CypressLoader
addFailedPatchOperation: aPatchOperation

	self errors add: aPatchOperation
%

category: 'accessing'
method: CypressLoader
additions

	additions ifNil: [ additions := OrderedCollection new ].
	^additions
%

category: 'loading'
method: CypressLoader
analyze
  self
    analyzeRemovalOfAdditions;
    analyzeAdditions;
    analyzeRemovals
%

category: 'loading'
method: CypressLoader
analyzeAdditions

	| sorter |
	sorter := CypressDependencySorter new 
		addAll: self additions;
		addExternalProvisions: self provisions;
		yourself.
	additions := sorter orderedItems.
	requirements := sorter externalRequirements.
	unloadable := sorter required.
%

category: 'loading'
method: CypressLoader
analyzeRemovalOfAdditions
  "if there is an addition and a removal for the same definition, the addition wins ... needed when loading multiple packages and a defintion has been moved from one package to another --- see atomic loads for Metacello"

  | index |
  index := CypressDefinitionIndex
    definitions: (self additions collect: [ :each | each definition ]).
  self removals
    removeAllSuchThat: [ :removal | 
      (index
        definitionLike: removal definition
        ifPresent: [ :additionDefinition | self obsoletions at: additionDefinition description put: removal definition ]
        ifAbsent: [  ]) notNil ]
%

category: 'loading'
method: CypressLoader
analyzeRemovals

	| sorter |
	sorter := CypressDependencySorter new 
		addAll: self removals;
		yourself.
	removals := sorter orderedItems reverse.
%

category: 'applying'
method: CypressLoader
applyAddition: aCypressPatchOperation

	self additions add: aCypressPatchOperation
%

category: 'applying'
method: CypressLoader
applyModification: aCypressPatchOperation
  self additions add: aCypressPatchOperation.
  self obsoletions
    at: aCypressPatchOperation modification description
    put: aCypressPatchOperation obsoletion
%

category: 'applying'
method: CypressLoader
applyRemoval: aCypressPatchOperation

	self removals add: aCypressPatchOperation
%

category: 'loading'
method: CypressLoader
attemptInitialLoad
  ^ self attemptInitialLoad: true
%

category: 'loading'
method: CypressLoader
attemptInitialLoad: doUnloads

	self
		resetErrors;
		notifyOnFailedPatchOperations;
		loadAdditions: self additions .
  doUnloads ifTrue:[ self unloadRemovals: self removals].
%

category: 'accessing'
method: CypressLoader
defaultSymbolDictionaryName
  ^ defaultSymbolDictionaryName ifNil: [ self class defaultSymbolDictionaryName ]
%

category: 'accessing'
method: CypressLoader
defaultSymbolDictionaryName: aSymbol
  defaultSymbolDictionaryName := aSymbol
%

category: 'loading'
method: CypressLoader
errorOnFailedPatchOperations

	exceptionClass := CypressLoaderError.
%

category: 'accessing'
method: CypressLoader
errors
	errors ifNil: [self resetErrors].
	^errors
%

category: 'loading'
method: CypressLoader
handleCompileError: aCompileError from: aPatchOperation

	| undefinedSymbolErrors otherErrors |
	undefinedSymbolErrors := aCompileError errorDetails
				select: [:each | each first = 1031].
	otherErrors := aCompileError errorDetails
				reject: [:each | each first = 1031].
	undefinedSymbolErrors do: [:each | self requirements add: each last].
	aCompileError pass
%

category: 'loading'
method: CypressLoader
handlePatchOperation: aPatchOperation failure: anException
	"Signal the loader exception appropriate to the current phase.
	 Note that a handler may suppress the #addFailedPatchOperation: by
	 sending #return or #return: to the resignaled exception. Otherwise,
	 resumption from a resumable resignalled exception will continue through
	 this method."

	(exceptionClass patchOperation: aPatchOperation exception: anException) signal.
	self addFailedPatchOperation: aPatchOperation.
%

category: 'loading'
method: CypressLoader
load
  ^self load: true
%

category: 'loading'
method: CypressLoader
load: doUnloads
	self analyze .
  doUnloads ifTrue:[ self reportUnloadableDefinitions ].
	self attemptInitialLoad: doUnloads  ;
		retryFailedLoads;
		postLoad.
%

category: 'loading'
method: CypressLoader
loadAdditions: somePatchOperations
	"Load class definitions first, then method definitions."

	somePatchOperations
		do: [:each | self loadClassDefinition: each];
		do: [:each | self loadMethodDefinition: each].
%

category: 'operations'
method: CypressLoader
loadClassDefinition: aPatchOperation

	[ aPatchOperation loadClassDefinition: self defaultSymbolDictionaryName ]
		on: Error
		do: [:ex | self handlePatchOperation: aPatchOperation failure: ex].
%

category: 'operations'
method: CypressLoader
loadMethodDefinition: aPatchOperation

	
	[[aPatchOperation loadMethodDefinition]
		on: CompileError
		do: [:ex | self handleCompileError: ex from: aPatchOperation]]
			on: Error
			do: [:ex | self handlePatchOperation: aPatchOperation failure: ex]
%

category: 'accessing'
method: CypressLoader
methodAdditions

	^#()
%

category: 'loading'
method: CypressLoader
notifyOnFailedPatchOperations

	exceptionClass := CypressLoaderErrorNotification.
%

category: 'accessing'
method: CypressLoader
obsoletions
  obsoletions ifNil: [ obsoletions := Dictionary new ].
  ^ obsoletions
%

category: 'loading'
method: CypressLoader
postLoad
	"This is where the obsoletion is taken into account ..."

	self additions do: [:each | self postLoad: each].
%

category: 'operations'
method: CypressLoader
postLoad: aPatchOperation

	[aPatchOperation postLoadDefinition]
		on: Error
		do: [:ex | self handlePatchOperation: aPatchOperation failure: ex].
%

category: 'accessing'
method: CypressLoader
provisions
	^ provisions ifNil: [provisions := (self allClasses collect: [:cl | cl name asString]) asSet ]
%

category: 'accessing'
method: CypressLoader
removals

	removals ifNil: [ removals := OrderedCollection new ].
	^removals
%

category: 'loading'
method: CypressLoader
reportUnloadableDefinitions

	self unloadable isEmpty ifTrue: [^self].
	(CypressLoaderMissingClasses missingRequirementsMap: unloadable) signal.
%

category: 'accessing'
method: CypressLoader
requirements

	^requirements
%

category: 'loading'
method: CypressLoader
resetErrors

	errors := OrderedCollection new.
%

category: 'loading'
method: CypressLoader
retryFailedLoads
	"In case any of the failed loads were resolved by subsequent
	 patch operations after the initial attempt or by editting of the
	 failed patch operations by exception handling during the notification
	 phase (initial attempt)."

	| failed |
	failed := self errors.
	self
		resetErrors;
		errorOnFailedPatchOperations;
		loadAdditions: (self elementsInBoth: self additions and: failed);
		unloadRemovals: (self elementsInBoth: self removals and: failed)
%

category: 'accessing'
method: CypressLoader
unloadable

	unloadable ifNil: [ unloadable := OrderedCollection new ].
	^unloadable
%

category: 'operations'
method: CypressLoader
unloadDefinition: aPatchOperation

	[aPatchOperation unloadDefinition]
		on: Error
		do: [:ex | self handlePatchOperation: aPatchOperation failure: ex].
%

category: 'loading'
method: CypressLoader
unloadRemovals: somePatchOperations
	"Removals need to be done after adding classes and methods."

	somePatchOperations
		do: [:each | self unloadDefinition: each].
%

category: 'unloading'
method: CypressLoader
unloadSnapshot: aSnapshot
  |  patch |
  patch := CypressSnapshot empty patchRelativeToBase: aSnapshot.
  patch applyTo: self
%

category: 'loading'
method: CypressLoader
updatePackage: aPackage withSnapshot: aSnapshot

	| patch snapshot |
	snapshot := aPackage snapshot.
	patch := aSnapshot patchRelativeToBase: snapshot.
	patch applyTo: self.
	snapshot definitions do: [:ea | self provisions addAll: ea provisions]
%

! Class implementation for 'CypressEnvironmentLoader'

!		Instance methods for 'CypressEnvironmentLoader'

category: 'accessing'
method: CypressEnvironmentLoader
allClasses
  | classes |
  classes := Array new.
  self defaultSymbolList
    do: [ :dict | classes addAll: (dict select: [ :each | each isBehavior ]) ].
  ^ classes
%

category: 'loading'
method: CypressEnvironmentLoader
analyzeAdditions
  | sorter |
  sorter := CypressEnvironmentDependencySorter new
    addAll: self additions;
    addExternalProvisions: self provisions;
    yourself.
  additions := sorter orderedItems.
  requirements := sorter externalRequirements.
  unloadable := sorter required
%

category: 'loading'
method: CypressEnvironmentLoader
analyzeRemovals
  | sorter |
  sorter := CypressEnvironmentDependencySorter new
    addAll: self removals;
    yourself.
  removals := sorter orderedItems reverse
%

category: 'accessing'
method: CypressEnvironmentLoader
compilationSymbolList
  ^ compilationSymbolList
    ifNil: [ compilationSymbolList := self defaultSymbolList ]
%

category: 'accessing'
method: CypressEnvironmentLoader
compilationSymbolList: anObject

   compilationSymbolList := anObject
%

category: 'accessing'
method: CypressEnvironmentLoader
defaultEnvironmentId
  ^ defaultEnvironmentId ifNil: [ defaultEnvironmentId := 0 ]
%

category: 'accessing'
method: CypressEnvironmentLoader
defaultEnvironmentId: anObject

   defaultEnvironmentId := anObject
%

category: 'accessing'
method: CypressEnvironmentLoader
defaultSymbolList
  ^ System myUserProfile symbolList
%

category: 'operations'
method: CypressEnvironmentLoader
loadClassDefinition: aPatchOperation
  [ 
  aPatchOperation
    loadClassDefinition: self defaultSymbolDictionaryName
    environmentLoader: self ]
    on: Error
    do: [ :ex | self handlePatchOperation: aPatchOperation failure: ex ]
%

category: 'operations'
method: CypressEnvironmentLoader
loadMethodDefinition: aPatchOperation
  [ 
  [ 
  aPatchOperation
    loadMethodDefinition: self lookupSymbolList
    environmentLoader: self ]
    on: CompileError
    do: [ :ex | self handleCompileError: ex from: aPatchOperation ] ]
    on: Error
    do: [ :ex | self handlePatchOperation: aPatchOperation failure: ex ]
%

category: 'accessing'
method: CypressEnvironmentLoader
lookupSymbolList
  ^ lookupSymbolList ifNil: [ lookupSymbolList := self defaultSymbolList ]
%

category: 'accessing'
method: CypressEnvironmentLoader
lookupSymbolList: anObject

   lookupSymbolList := anObject
%

category: 'operations'
method: CypressEnvironmentLoader
postLoad: aPatchOperation
  [ 
  aPatchOperation
    postLoadDefinition: lookupSymbolList
    environmentId: self defaultEnvironmentId ]
    on: Error
    do: [ :ex | self handlePatchOperation: aPatchOperation failure: ex ]
%

! Class implementation for 'CypressPackageDefinition'

!		Class methods for 'CypressPackageDefinition'

category: 'instance creation'
classmethod: CypressPackageDefinition
named: aString

	^self new
		name: aString;
		yourself.
%

!		Instance methods for 'CypressPackageDefinition'

category: 'comparing'
method: CypressPackageDefinition
= other
	^ other species = self species and: [other name sameAs: name]
%

category: 'snapshotting'
method: CypressPackageDefinition
addClass: aClass toDefinitions: definitions

	definitions add: (CypressClassDefinition forClass: aClass)
%

category: 'snapshotting'
method: CypressPackageDefinition
addExtensionMethodsFromClass: aClass toMap: classMap

	| defs map |
	defs := classMap at: aClass theNonMetaClass
				ifAbsent: [OrderedCollection new].
	map := Dictionary new.
	aClass categorysDo: 
			[:category :selectors |
			(category asLowercase
				indexOfSubCollection: '*' , self basePackageName asLowercase startingAt: 1 ifAbsent: [ 0 ]) = 1
				ifTrue: [map at: category put: selectors asSortedCollection]].
	map keys asSortedCollection do: 
			[:category |
			(map at: category) do: 
					[:selector |
					defs add: (CypressMethodDefinition
								forMethod: (aClass compiledMethodAt: selector))]].
	defs notEmpty ifTrue: [classMap at: aClass theNonMetaClass put: defs]
%

category: 'snapshotting'
method: CypressPackageDefinition
addMethodsFromClass: aClass toDefinitions: definitions
	"Add only those methods which are not extensions from other packages."

	(((aClass methodDictForEnv: 0)
		reject: [:each | (each inClass categoryOfSelector: each selector) first = $*])
			asSortedCollection: [:a :b | a selector <= b selector])
			do: [:method | definitions add: (CypressMethodDefinition forMethod: method)]
%

category: 'accessing'
method: CypressPackageDefinition
basePackageName
  "package name may have a platform/branch extension, when comparing against category/protocol names, extension is ignored"

  | nm index |
  nm := self name.
  index := nm indexOfSubCollection: '.' startingAt: 1.
  index = 0
    ifTrue: [ ^ nm ].
  ^ nm copyFrom: 1 to: index - 1
%

category: 'accessing'
method: CypressPackageDefinition
classes
  ^ self classesInPackageNamed: self basePackageName
%

category: 'comparing'
method: CypressPackageDefinition
hash
  ^ name hash
%

category: 'accessing'
method: CypressPackageDefinition
name
	^ name
%

category: 'accessing'
method: CypressPackageDefinition
name: aString
	name := aString
%

category: 'printing'
method: CypressPackageDefinition
printDetailsOn: aStream

	aStream nextPutAll: name
%

category: 'snapshotting'
method: CypressPackageDefinition
snapshot

	| classDefinitions methodDefinitions classMap |
	classDefinitions := OrderedCollection new.
	methodDefinitions := OrderedCollection new.
	(self determineClassHierarchicalOrder: self classes) do: 
			[:cls |
			self
				addClass: cls toDefinitions: classDefinitions;
				addMethodsFromClass: cls toDefinitions: methodDefinitions;
				addMethodsFromClass: cls class toDefinitions: methodDefinitions].
	classMap := Dictionary new.
	self allClasses do: 
			[:each |
			self
				addExtensionMethodsFromClass: each toMap: classMap;
				addExtensionMethodsFromClass: each class toMap: classMap].
	(self determineClassHierarchicalOrder: classMap keys)
		do: [:aClass | methodDefinitions addAll: (classMap at: aClass)].
	^CypressSnapshot definitions: classDefinitions, methodDefinitions
%

! Class implementation for 'CypressEnvironmentPackageDefinition'

!		Instance methods for 'CypressEnvironmentPackageDefinition'

category: 'accessing'
method: CypressEnvironmentPackageDefinition
lookupSymbolList

   ^lookupSymbolList
%

category: 'accessing'
method: CypressEnvironmentPackageDefinition
lookupSymbolList: anObject

   lookupSymbolList := anObject
%

category: 'accessing'
method: CypressEnvironmentPackageDefinition
symbolList
  lookupSymbolList ifNil: [ ^ super symbolList ].
  ^ self lookupSymbolList
%

! Class implementation for 'CypressPackageInformation'

!		Class methods for 'CypressPackageInformation'

category: 'instance creation'
classmethod: CypressPackageInformation
named: aString repository: aCypressRepository
	"Answer an instance of the receiver representing the named package.
	 If the package was saved in a Repository, load up the saved details."

	^self new
		initializeFromName: aString andRepository: aCypressRepository;
		yourself
%

category: 'instance creation'
classmethod: CypressPackageInformation
new

	^super new
		initialize;
		yourself
%

!		Instance methods for 'CypressPackageInformation'

category: 'updating - type'
method: CypressPackageInformation
beConflictedWith: somePackageNames
	"Be designated as representing the prefix of one or more Known Package names."

	type := 'Conflicted Name'.
	competingPackageNames := somePackageNames sortAscending.
	advice := 'Conflicts with the packages named ', self competingPackageNamesString
%

category: 'updating - type'
method: CypressPackageInformation
beKnown
	"Be known to represent a real package."

	type := 'Known Package'.
	advice := ''.
	competingPackageNames := #()
%

category: 'updating - type'
method: CypressPackageInformation
beQualifiedNameOf: somePackageNames
	"Be designated as qualifying a Known Package name and therefore not eligible as a package name."

	type := 'Qualified Name'.
	competingPackageNames := somePackageNames sortAscending.
	advice := 'Qualifies the package named ', self competingPackageNamesString
%

category: 'updating - type'
method: CypressPackageInformation
beUnknown
	"Be designated as possibly representing a package, but not known to do so."

	type := 'Unknown'.
	advice := ''.
	competingPackageNames := #()
%

category: 'accessing'
method: CypressPackageInformation
changesCount

	^changesCount
%

category: 'accessing'
method: CypressPackageInformation
changesCount: anInteger

	changesCount := anInteger
%

category: 'accessing'
method: CypressPackageInformation
changesStatus

	^self hasChanges
		ifTrue: [' (' , self changesCount printString , ')']
		ifFalse: ['']
%

category: 'accessing'
method: CypressPackageInformation
classCount

	^self imageCounts first
%

category: 'accessing'
method: CypressPackageInformation
competingPackageNames

	^competingPackageNames
%

category: 'accessing'
method: CypressPackageInformation
competingPackageNamesString

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	self competingPackageNames
		do: [:each | stream nextPutAll: each printString]
		separatedBy: [stream nextPutAll: ', '].
	^stream contents
%

category: 'accessing'
method: CypressPackageInformation
description

	self isKnown ifTrue: [^self savedLocation].
	self isUnknown ifTrue: [^' <unknown>'].
	^' <', advice, '>'
%

category: 'accessing'
method: CypressPackageInformation
determinedChangesCount

	| notInImage notInSaved |
	notInImage := self savedDefinitions
				reject: [:each | self imageDefinitions includes: each].
	notInSaved := self imageDefinitions
		reject: [:each | self savedDefinitions includes: each].
	^notInImage size + notInSaved size
%

category: 'testing'
method: CypressPackageInformation
hasChanges

	^self changesCount > 0
%

category: 'accessing'
method: CypressPackageInformation
imageCounts

	^imageCounts
%

category: 'accessing'
method: CypressPackageInformation
imageCounts: someIntegers
	"A pair: the number of classes and number of methods"

	imageCounts := someIntegers
%

category: 'accessing'
method: CypressPackageInformation
imageDefinitionCounts

	| classCount methodCount |
	classCount := methodCount := 0.
	self imageDefinitions do: 
			[:each |
			each classDefinition: [:classDefinition | classCount := classCount + 1]
				methodDefinition: [:methodDefinition | methodCount := methodCount + 1]].
	^Array with: classCount with: methodCount
%

category: 'accessing'
method: CypressPackageInformation
imageDefinitions

	^imageDefinitions
%

category: 'accessing'
method: CypressPackageInformation
imageDefinitions: someCypressDefinitions

	imageDefinitions := someCypressDefinitions
%

category: 'accessing'
method: CypressPackageInformation
imageDefinitionsStatus

	^self classCount printString , '/' , self methodCount printString
%

category: 'initializing'
method: CypressPackageInformation
initialize

	self
		beUnknown;
		name: '';
		imageDefinitions: #();
		savedDefinitions: #();
		savedLocation: '';
		repositoryDescription: '';
		imageCounts: #(0 0);
		changesCount: 0
%

category: 'initializing'
method: CypressPackageInformation
initializeFromName: aString andRepository: aCypressRepositoryOrNil

	self name: aString.
	aCypressRepositoryOrNil isNil ifTrue: [^self].
	self updateKnownPackageRepository: aCypressRepositoryOrNil
%

category: 'testing - type'
method: CypressPackageInformation
isConflicted

	^type = 'Conflicted Name'
%

category: 'testing - type'
method: CypressPackageInformation
isKnown

	^type = 'Known Package'
%

category: 'testing - type'
method: CypressPackageInformation
isQualifiedName

	^type = 'Qualified Name'
%

category: 'testing - type'
method: CypressPackageInformation
isUnknown

	^type = 'Unknown'
%

category: 'accessing'
method: CypressPackageInformation
methodCount

	^self imageCounts last
%

category: 'accessing'
method: CypressPackageInformation
name

	^name
%

category: 'accessing'
method: CypressPackageInformation
name: aString

	name := aString
%

category: 'printing'
method: CypressPackageInformation
printDetailsOn: aStream

	aStream
		nextPutAll: self name;
		nextPutAll: ' - ';
		nextPutAll: self description
%

category: 'updating'
method: CypressPackageInformation
readDefinitionsFromRepository

	^(self repository reader readPackageStructureForPackageNamed: self name)
		packageStructure snapshot
		definitions
%

category: 'updating'
method: CypressPackageInformation
refresh

	self isKnown ifFalse: [^self].
	self
		updateImageDefinitions;
		updateSavedDefinitions;
		updateChangesCount.
%

category: 'accessing'
method: CypressPackageInformation
repository

	^repository
%

category: 'accessing'
method: CypressPackageInformation
repository: aCypressFileSystemRepository

	repository := aCypressFileSystemRepository
%

category: 'unknown'
method: CypressPackageInformation
repositoryDescription

	^repositoryDescription
%

category: 'unknown'
method: CypressPackageInformation
repositoryDescription: aString

	repositoryDescription := aString
%

category: 'accessing'
method: CypressPackageInformation
savedDefinitions

	^savedDefinitions
%

category: 'accessing'
method: CypressPackageInformation
savedDefinitions: someCypressDefinitions

	savedDefinitions := someCypressDefinitions
%

category: 'accessing'
method: CypressPackageInformation
savedLocation

	^savedLocation
%

category: 'accessing'
method: CypressPackageInformation
savedLocation: aDirectory

	savedLocation := aDirectory
%

category: 'accessing'
method: CypressPackageInformation
status

	| changes |
	(changes := self changesStatus) isEmpty ifTrue: [^self imageDefinitionsStatus].
	^self imageDefinitionsStatus, changes
%

category: 'updating'
method: CypressPackageInformation
updateChangesCount
	"Must be applied after the image definitions and saved definitions are updated."

	self changesCount: self determinedChangesCount
%

category: 'updating'
method: CypressPackageInformation
updateImageDefinitions

	self
		imageDefinitions: (CypressPackageDefinition named: self name) snapshot
					definitions;
		imageCounts: self imageDefinitionCounts
%

category: 'updating'
method: CypressPackageInformation
updateKnownPackageRepository: aCypressRepository
	"Update the receiver to reflect it being a known package."

	self
		beKnown;
		updateRepository: aCypressRepository;
		refresh.
%

category: 'updating'
method: CypressPackageInformation
updateRepository: aCypressRepository

	self
		repository: aCypressRepository;
		repositoryDescription: self repository description;
		savedLocation: self repository directoryPath
%

category: 'updating'
method: CypressPackageInformation
updateSavedDefinitions

	self savedDefinitions: self readDefinitionsFromRepository
%

! Class implementation for 'CypressPatch'

!		Class methods for 'CypressPatch'

category: 'instance creation'
classmethod: CypressPatch
fromBase: baseSnapshot toTarget: targetSnapshot
	^ (self new)
		fromBase: baseSnapshot
		toTarget: targetSnapshot
%

!		Instance methods for 'CypressPatch'

category: 'applying'
method: CypressPatch
applyTo: aCypressLoader
	operations do: [:ea | ea applyTo: aCypressLoader].
%

category: 'initialization'
method: CypressPatch
fromBase: baseSnapshot toTarget: targetSnapshot
	| base target |	
	operations := OrderedCollection new.
	base := CypressDefinitionIndex definitions: baseSnapshot definitions.
	target := CypressDefinitionIndex definitions: targetSnapshot definitions.
	
	target definitions do:
		[:t |
		base
			definitionLike: t
			ifPresent: [:b | (b isSameRevisionAs: t) ifFalse: [operations add: (CypressModification of: b to: t)]]
			ifAbsent: [operations add: (CypressAddition of: t)]].
		
	base definitions do:
		[:b |
		target
			definitionLike: b
			ifPresent: [:t | ]
			ifAbsent: [operations add: (CypressRemoval of: b)]]
%

category: 'accessing'
method: CypressPatch
operations

	^operations
%

! Class implementation for 'CypressPatchOperation'

!		Instance methods for 'CypressPatchOperation'

category: 'comparing'
method: CypressPatchOperation
= aPatchOperation
	^aPatchOperation isKindOf: self class
%

category: 'applying'
method: CypressPatchOperation
applyTo: aCypressLoader

	self subclassResponsibility: #applyTo:
%

category: 'accessing'
method: CypressPatchOperation
definition
  "answer the primary definition associated with the operation"

  self subclassResponsibility: #'definition'
%

category: 'accessing'
method: CypressPatchOperation
description

	self subclassResponsibility: #description
%

category: 'comparing'
method: CypressPatchOperation
hash
    ^ self description hash
%

category: 'loading'
method: CypressPatchOperation
loadClassDefinition
  self loadClassDefinition: self defaultSymbolDictionaryName
%

category: 'loading'
method: CypressPatchOperation
loadClassDefinition: aDefaultSymbolDictionaryName
  self subclassResponsibility: #'loadClassDefinition'
%

category: 'loading'
method: CypressPatchOperation
loadMethodDefinition

	self subclassResponsibility: #loadMethodDefinition
%

category: 'loading'
method: CypressPatchOperation
postLoadDefinition

	self subclassResponsibility: #postLoadDefinition
%

category: 'printing'
method: CypressPatchOperation
printDetailsOn: aStream

	aStream nextPutAll: self description.
%

category: 'dependency'
method: CypressPatchOperation
provisions
	"Answer list of global names defined by this definition"

	self subclassResponsibility: #provisions
%

category: 'dependency'
method: CypressPatchOperation
requirements
	"Answer list of global names required by this definition"

	self subclassResponsibility: #requirements
%

category: 'loading'
method: CypressPatchOperation
unloadDefinition

	CypressError signal: 'inappropriate to send #unloadDefinition to an addition or modification operation'
%

! Class implementation for 'CypressAddition'

!		Class methods for 'CypressAddition'

category: 'instance creation'
classmethod: CypressAddition
of: aDefinition
	^ self new definition: aDefinition
%

!		Instance methods for 'CypressAddition'

category: 'comparing'
method: CypressAddition
= aPatchOperation
	^(super = aPatchOperation) and: [self definition = aPatchOperation definition]
%

category: 'applying'
method: CypressAddition
applyTo: aCypressLoader

	aCypressLoader applyAddition: self
%

category: 'accessing'
method: CypressAddition
definition

	^definition
%

category: 'initialization'
method: CypressAddition
definition: aDefinition

	definition := aDefinition
%

category: 'accessing'
method: CypressAddition
description
    ^ 'add: ' , self definition printString
%

category: 'comparing'
method: CypressAddition
hash
  ^ super hash bitXor: definition hash
%

category: 'loading'
method: CypressAddition
loadClassDefinition: aDefaultSymbolDictionaryName
  self definition loadClassDefinition: aDefaultSymbolDictionaryName
%

category: 'loading'
method: CypressAddition
loadMethodDefinition
  self definition loadMethodDefinition
%

category: 'loading'
method: CypressAddition
postLoadDefinition
	self definition postLoadOver: nil
%

category: 'dependency'
method: CypressAddition
provisions
	"Answer list of global names defined by this definition"

	^self definition provisions
%

category: 'dependency'
method: CypressAddition
requirements
	"Answer list of global names required by this definition"

	^self definition requirements
%

! Class implementation for 'CypressModification'

!		Class methods for 'CypressModification'

category: 'instance creation'
classmethod: CypressModification
of: base to: target
	^ self new base: base target: target
%

!		Instance methods for 'CypressModification'

category: 'initialization'
method: CypressModification
= aPatchOperation
	^(super = aPatchOperation) and: [self obsoletion = aPatchOperation obsoletion and: [ self modification = aPatchOperation modification]]
%

category: 'applying'
method: CypressModification
applyTo: aCypressLoader

	aCypressLoader applyModification: self
%

category: 'initialization'
method: CypressModification
base: base target: target

	obsoletion := base.
	modification := target.
%

category: 'accessing'
method: CypressModification
definition
  "answer the primary definition associated with the operation"

  ^ self modification
%

category: 'accessing'
method: CypressModification
description
    ^ 'modify from: ' , self obsoletion printString , ' to: ' , self modification printString
%

category: 'comparing'
method: CypressModification
hash
  ^ (super hash bitXor: modification hash) bitXor: obsoletion hash
%

category: 'loading'
method: CypressModification
loadClassDefinition: aDefaultSymbolDictionaryName
  self modification loadClassDefinition: aDefaultSymbolDictionaryName
%

category: 'loading'
method: CypressModification
loadMethodDefinition

	self modification loadMethodDefinition.
%

category: 'accessing'
method: CypressModification
modification

	^modification
%

category: 'accessing'
method: CypressModification
obsoletion

	^obsoletion
%

category: 'loading'
method: CypressModification
postLoadDefinition
	self modification postLoadOver: self obsoletion
%

category: 'dependency'
method: CypressModification
provisions
	"Answer list of global names defined by this definition"

	^self modification provisions
%

category: 'dependency'
method: CypressModification
requirements
	"Answer list of global names required by this definition"

	^self modification requirements
%

! Class implementation for 'CypressRemoval'

!		Class methods for 'CypressRemoval'

category: 'instance creation'
classmethod: CypressRemoval
of: aDefinition
	^ self new definition: aDefinition
%

!		Instance methods for 'CypressRemoval'

category: 'comparing'
method: CypressRemoval
= aPatchOperation
	^(super = aPatchOperation) and: [self definition = aPatchOperation definition]
%

category: 'applying'
method: CypressRemoval
applyTo: aCypressLoader

	aCypressLoader applyRemoval: self
%

category: 'accessing'
method: CypressRemoval
definition

	^definition
%

category: 'initialization'
method: CypressRemoval
definition: aDefinition

	definition := aDefinition
%

category: 'accessing'
method: CypressRemoval
description

	^'remove: ', self definition printString
%

category: 'comparing'
method: CypressRemoval
hash
  ^ super hash bitXor: definition hash
%

category: 'loading'
method: CypressRemoval
loadClassDefinition: aDefaultSymbolDictionaryName
  CypressError
    signal: 'inappropriate to send #loadClassDefinition to a removal operation'
%

category: 'loading'
method: CypressRemoval
loadMethodDefinition
	
	CypressError signal: 'inappropriate to send #loadMethodDefinition to a removal operation'
%

category: 'loading'
method: CypressRemoval
postLoadDefinition
	
	CypressError signal: 'inappropriate to send #postLoadDefinition to a removal operation'
%

category: 'dependency'
method: CypressRemoval
provisions
	"Answer list of global names defined by this definition"

	^#()
%

category: 'dependency'
method: CypressRemoval
requirements
	"Answer list of global names required by this definition"

	^#()
%

category: 'loading'
method: CypressRemoval
unloadDefinition

	self definition unloadDefinition.
%

! Class implementation for 'CypressSnapshot'

!		Class methods for 'CypressSnapshot'

category: 'instance creation'
classmethod: CypressSnapshot
definitions: aDefinitions

	^(self new) definitions: aDefinitions
%

category: 'instance creation'
classmethod: CypressSnapshot
empty

  ^self definitions: #()
%

!		Instance methods for 'CypressSnapshot'

category: 'comparing'
method: CypressSnapshot
= other
	^ definitions asArray = other definitions asArray
%

category: 'enumerating'
method: CypressSnapshot
classDefinitions: classBlock methodDefinitions: methodBlock

	self definitions do: [:definition |
		definition classDefinition: classBlock methodDefinition: methodBlock]
%

category: 'accessing'
method: CypressSnapshot
definitions

	^definitions
%

category: 'accessing'
method: CypressSnapshot
definitions: aDefinitions

	definitions := aDefinitions
%

category: 'comparing'
method: CypressSnapshot
hash
  ^ definitions asArray hash
%

category: 'patching'
method: CypressSnapshot
patchRelativeToBase: aSnapshot
	^ CypressPatch fromBase: aSnapshot toTarget: self
%

category: 'unloading'
method: CypressSnapshot
unload

  ^CypressLoader unloadSnapshot: self
%

category: 'loading'
method: CypressSnapshot
updatePackage: aPackage
  "Answer the loader used to apply the update."

  ^ self updatePackage: aPackage defaultSymbolDictionaryName: nil
%

category: 'loading'
method: CypressSnapshot
updatePackage: aPackage defaultSymbolDictionaryName: defaultSymbolDictionaryName
  "Answer the loader used to apply the update."

  ^ CypressLoader
    updatePackage: aPackage
    defaultSymbolDictionaryName: defaultSymbolDictionaryName
    withSnapshot: self
%

! Class implementation for 'CypressStructure'

!		Class methods for 'CypressStructure'

category: 'instance creation'
classmethod: CypressStructure
named: aString

	^(self new)
		name: aString;
		yourself
%

!		Instance methods for 'CypressStructure'

category: 'accessing'
method: CypressStructure
name

	^name
%

category: 'accessing'
method: CypressStructure
name: aString 

	name := aString
%

category: 'accessing'
method: CypressStructure
packageStructure
	^packageStructure
%

category: 'accessing'
method: CypressStructure
packageStructure: aCypressPackageStructure
	packageStructure := aCypressPackageStructure
%

category: 'printing'
method: CypressStructure
printDetailsOn: aStream

	aStream nextPutAll: self name.
%

category: 'accessing'
method: CypressStructure
properties

	properties ifNil: [ properties := Dictionary new ].
	^properties
%

category: 'accessing'
method: CypressStructure
properties: aDictionary

	properties := aDictionary
%

! Class implementation for 'CypressClassStructure'

!		Class methods for 'CypressClassStructure'

category: 'instance creation'
classmethod: CypressClassStructure
fromClassDefinition: classDefinition

	^self new
		fromClassDefinition: classDefinition;
		yourself
%

!		Instance methods for 'CypressClassStructure'

category: 'converting'
method: CypressClassStructure
asCypressClassDefinition

	self isClassExtension ifTrue: [^CypressError signal: 'Extensions cannot have class definitions'].
	^CypressClassDefinition new
		name: self className
		superclassName: self superclassName
		category: self category
		instVarNames: self instanceVariableNames
		classInstVarNames: self classInstanceVariableNames
		classVarNames: self classVariableNames
		poolDictionaryNames: self poolDictionaryNames
		gs_options: self gs_options
		gs_constraints: self gs_constraints
		comment: self comment
		subclassType: self subclassType
%

category: 'accessing'
method: CypressClassStructure
category

	^self properties
		at: 'category'
		ifAbsent: [self packageStructure packageName]
%

category: 'accessing'
method: CypressClassStructure
category: aString

	^self properties at: 'category' put: aString
%

category: 'accessing'
method: CypressClassStructure
classInstanceVariableNames

	^self properties at: 'classinstvars' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
classInstanceVariableNames: someStrings

	^self properties at: 'classinstvars' put: someStrings
%

category: 'converting'
method: CypressClassStructure
classInstanceVariablesString
  ^ self stringForVariables: self classInstanceVariableNames
%

category: 'querying'
method: CypressClassStructure
classMethodNamed: methodName

	^self classMethods
		at: methodName
		ifAbsentPut: [CypressMethodStructure named: methodName]
%

category: 'accessing'
method: CypressClassStructure
classMethods

	classMethods ifNil: [ classMethods := Dictionary new ].
	^classMethods
%

category: 'accessing'
method: CypressClassStructure
className

	^self name
%

category: 'accessing'
method: CypressClassStructure
classVariableNames

	^self properties at: 'classvars' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
classVariableNames: someStrings

	^self properties at: 'classvars' put: someStrings
%

category: 'converting'
method: CypressClassStructure
classVariablesString
  ^ self stringForVariables: self classVariableNames asSortedCollection
%

category: 'accessing'
method: CypressClassStructure
comment

	comment ifNil: [ comment := '' ].
	^comment
%

category: 'accessing'
method: CypressClassStructure
comment: aString

	comment := aString
%

category: 'initialization'
method: CypressClassStructure
fromClassDefinition: classDefinition

	self
		isClassExtension: false;
		name: classDefinition name;
		category: classDefinition category;
		comment: classDefinition comment;
		superclassName: classDefinition superclassName;
		instanceVariableNames: classDefinition instVarNames;
		classInstanceVariableNames: classDefinition classInstVarNames;
		classVariableNames: classDefinition classVarNames;
		poolDictionaryNames: classDefinition poolDictionaryNames;
		subclassType: classDefinition subclassType;
		gs_options: classDefinition gs_options;
		gs_constraints: classDefinition gs_constraints
%

category: 'accessing'
method: CypressClassStructure
gs_constraints

	^self properties at: 'gs_constraints' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
gs_constraints: anConstraintsArray

	^self properties at: 'gs_constraints' put: anConstraintsArray
%

category: 'accessing'
method: CypressClassStructure
gs_options

	^self properties at: 'gs_options' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
gs_options: anOptionsArray

	^self properties at: 'gs_options' put: anOptionsArray
%

category: 'accessing'
method: CypressClassStructure
gs_reservedOop
	^ ''
%

category: 'querying'
method: CypressClassStructure
instanceMethodNamed: methodName

	^self instanceMethods
		at: methodName 
		ifAbsentPut: [CypressMethodStructure named: methodName]
%

category: 'accessing'
method: CypressClassStructure
instanceMethods

	instanceMethods ifNil: [ instanceMethods := Dictionary new ].
	^instanceMethods
%

category: 'accessing'
method: CypressClassStructure
instanceVariableNames

	^self properties at: 'instvars' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
instanceVariableNames: someStrings

	^self properties at: 'instvars' put: someStrings
%

category: 'converting'
method: CypressClassStructure
instanceVariablesString

	^self stringForVariables: self instanceVariableNames
%

category: 'accessing'
method: CypressClassStructure
isClassExtension

        isClassExtension ifNil: [ isClassExtension := true ].
        ^isClassExtension
%

category: 'accessing'
method: CypressClassStructure
isClassExtension: aBoolean

	isClassExtension := aBoolean
%

category: 'accessing'
method: CypressClassStructure
name

	^self properties at: 'name'
%

category: 'accessing'
method: CypressClassStructure
name: aString

	self properties at: 'name' put: aString
%

category: 'converting'
method: CypressClassStructure
poolDictionariesString
  ^ self stringForVariables: self poolDictionaryNames
%

category: 'accessing'
method: CypressClassStructure
poolDictionaryNames

	^self properties at: 'pools' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
poolDictionaryNames: someStrings

	^self properties at: 'pools' put: someStrings
%

category: 'accessing'
method: CypressClassStructure
subclassType

	^self properties at: '_gs_subclassType' ifAbsent: ['']
%

category: 'accessing'
method: CypressClassStructure
subclassType: aString

	aString isEmpty
		ifTrue: [self properties removeKey: '_gs_subclassType' ifAbsent: []]
		ifFalse: [self properties at: '_gs_subclassType' put: aString]
%

category: 'accessing'
method: CypressClassStructure
superclassName

	^self properties at: 'super'
%

category: 'accessing'
method: CypressClassStructure
superclassName: aString

	^self properties at: 'super' put: aString
%

! Class implementation for 'CypressMethodStructure'

!		Class methods for 'CypressMethodStructure'

category: 'instance creation'
classmethod: CypressMethodStructure
fromMethodDefinition: methodDefinition

	^self new
		fromMethodDefinition: methodDefinition;
		yourself
%

!		Instance methods for 'CypressMethodStructure'

category: 'converting'
method: CypressMethodStructure
asCypressMethodDefinition
	"Try to coerce Unicode source to simple Strings when possible."

	^CypressMethodDefinition 
        	className: self classStructure className
		classIsMeta: self isMetaclass
		selector: self selector
		category: self category
		source: self source asString
%

category: 'accessing'
method: CypressMethodStructure
category

	^self properties at: 'category'
%

category: 'accessing'
method: CypressMethodStructure
category: aString

	self properties at: 'category' put: aString
%

category: 'accessing'
method: CypressMethodStructure
classStructure
	^classStructure
%

category: 'accessing'
method: CypressMethodStructure
classStructure: aCypressClassStructure
	classStructure := aCypressClassStructure
%

category: 'initialization'
method: CypressMethodStructure
fromMethodDefinition: methodDefinition

	self isMetaclass: methodDefinition classIsMeta.
	self selector: methodDefinition selector.
	self category: methodDefinition category.
	self source: methodDefinition source.
%

category: 'accessing'
method: CypressMethodStructure
isMetaclass

	isMetaclass ifNil: [ isMetaclass := false ].
	^isMetaclass
%

category: 'accessing'
method: CypressMethodStructure
isMetaclass: aBoolean
	isMetaclass := aBoolean
%

category: 'accessing'
method: CypressMethodStructure
selector

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	self name
		do: [:chara | stream nextPut: (chara = $. ifTrue: [$:] ifFalse: [chara])].
	^stream contents
%

category: 'accessing'
method: CypressMethodStructure
selector: aString

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	aString
		do: [:chara | stream nextPut: (chara = $: ifTrue: [$.] ifFalse: [chara])].
	name := stream contents
%

category: 'accessing'
method: CypressMethodStructure
source

	^source
%

category: 'accessing'
method: CypressMethodStructure
source: aString

	source := aString
%

! Class implementation for 'RwCypressMethodStructure'

!		Instance methods for 'RwCypressMethodStructure'

category: 'converting'
method: RwCypressMethodStructure
asCypressMethodDefinition

	"Try to coerce Unicode source to simple Strings when possible."

	^ RwCypressMethodDefinition
		className: self classStructure className
		classIsMeta: self isMetaclass
		selector: self selector
		category: self category
		source: self source asString
%

category: 'initialization'
method: RwCypressMethodStructure
fromRwClassMethodDefinition: methodDefinition
  self isMetaclass: true.
  self fromRwMethodDefinition: methodDefinition
%

category: 'initialization'
method: RwCypressMethodStructure
fromRwInstanceMethodDefinition: methodDefinition
  self isMetaclass: false.
  self fromRwMethodDefinition: methodDefinition
%

category: 'initialization'
method: RwCypressMethodStructure
fromRwMethodDefinition: methodDefinition
  self selector: methodDefinition selector asString.
  self category: (methodDefinition properties at: 'protocol').
  self source: methodDefinition source
%

! Class implementation for 'CypressPackageStructure'

!		Class methods for 'CypressPackageStructure'

category: 'instance creation'
classmethod: CypressPackageStructure
fromPackage: aCypressPackageDefinition

	^(self new) 
		fromPackage: aCypressPackageDefinition;
		yourself
%

category: 'instance creation'
classmethod: CypressPackageStructure
name: aPackageNameString from: classDefinitions classMap: classMap
  ^ self new
    name: aPackageNameString from: classDefinitions classMap: classMap;
    yourself
%

!		Instance methods for 'CypressPackageStructure'

category: 'accessing'
method: CypressPackageStructure
classes

	classes ifNil: [ classes := OrderedCollection new ].
	^classes
%

category: 'accessing'
method: CypressPackageStructure
extensions

	extensions ifNil: [ extensions := OrderedCollection new ].
	^extensions
%

category: 'initialization'
method: CypressPackageStructure
fromPackage: aCypressPackageDefinition
  | snapshot classMap classDefinitions |
  snapshot := aCypressPackageDefinition snapshot.
  classDefinitions := OrderedCollection new.
  classMap := Dictionary new.
  snapshot definitions
    do: [ :definition | 
      definition
        classDefinition: [ :classDefinition | classDefinitions add: classDefinition ]
        methodDefinition: [ :methodDefinition | 
          (classMap at: methodDefinition className ifAbsentPut: [ Set new ])
            add: methodDefinition ] ].
  self
    name: aCypressPackageDefinition name , self packageExtension
    from: classDefinitions
    classMap: classMap
%

category: 'initialization'
method: CypressPackageStructure
name: aString from: classDefinitions classMap: classMap

	| classStructure |
	name := aString.
	properties := Dictionary new.
	classDefinitions do: [:classDefinition |
		classStructure := (CypressClassStructure fromClassDefinition: classDefinition)
			packageStructure: self.
		(classMap removeKey: classDefinition className ifAbsent: [#()]) do: [:methodDefinition | | methodStructure |
			methodStructure := (CypressMethodStructure fromMethodDefinition: methodDefinition)
				packageStructure: self;
				classStructure: classStructure.
			(methodDefinition
				instanceMethod: [:instanceMethod | classStructure instanceMethods ] 
				classMethod: [:classMethod | classStructure classMethods ])
					at: methodDefinition selector
					put: methodStructure ].
		self classes add: classStructure ].
	classMap keysAndValuesDo: [:className :methods |
		classStructure := (CypressClassStructure named: className)
			isClassExtension: true;
			packageStructure: self.
		methods do: [:methodDefinition | | methodStructure |
			methodStructure := (CypressMethodStructure fromMethodDefinition: methodDefinition)
				packageStructure: self;
				classStructure: classStructure.
			(methodDefinition
				instanceMethod: [:instanceMethod | classStructure instanceMethods ] 
				classMethod: [:classMethod | classStructure classMethods ])
					at: methodDefinition selector
					put: methodStructure ].
		self extensions add: classStructure ].
%

category: 'accessing'
method: CypressPackageStructure
packageExtension

	^self packageExtensionOr: ['.package' ]
%

category: 'accessing'
method: CypressPackageStructure
packageExtensionOr: aBlock

	^self properties at: 'extension' ifAbsent: aBlock
%

category: 'accessing'
method: CypressPackageStructure
packageName

	| extension extensionSize stopIndex |
	extension := self packageExtension.
	extensionSize := extension size.
	stopIndex :=  extensionSize < self name size
		ifTrue: [
			self name
					indexOfSubCollection: extension
					startingAt: self name size - extensionSize + 1
					ifAbsent: [ self name size + 1 ] ]
		ifFalse: [  self name size + 1 ].
	^self name copyFrom: 1 to: stopIndex - 1
%

category: 'accessing'
method: CypressPackageStructure
packageStructure
	^self
%

category: 'snapshotting'
method: CypressPackageStructure
snapshot
	| definitions |
	definitions := OrderedCollection new.
	self classes do: [:classStructure |
        	definitions add: classStructure asCypressClassDefinition.
                (classStructure instanceMethods asSortedCollection: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ].
                (classStructure classMethods asSortedCollection: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ]].
	self extensions do: [:classStructure |
                (classStructure instanceMethods asSortedCollection: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ].
                (classStructure classMethods asSortedCollection: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ]].
	^ CypressSnapshot definitions: definitions
%

! Class implementation for 'RwCypressPackageStructure'

!		Instance methods for 'RwCypressPackageStructure'

category: 'initialization'
method: RwCypressPackageStructure
fromPackage: aRwPackageDefinition

	| classStructure |
	aRwPackageDefinition classDefinitions
		do: [ :classDefinition | 
			classStructure := (CypressClassStructure fromClassDefinition: classDefinition)
				packageStructure: self.
			classDefinition instanceMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwInstanceMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure instanceMethods
						at: methodDefinition selector
						put: methodStructure ].
			classDefinition classMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwClassMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure classMethods
						at: methodDefinition selector
						put: methodStructure ].
			self classes add: classStructure ].
	aRwPackageDefinition classExtensions
		do: [ :extensionDefinition | 
			classStructure := (CypressClassStructure named: extensionDefinition name)
				isClassExtension: true;
				packageStructure: self.
			extensionDefinition instanceMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwInstanceMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure instanceMethods
						at: methodDefinition selector
						put: methodStructure ].
			extensionDefinition classMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwClassMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure classMethods
						at: methodDefinition selector
						put: methodStructure ].
			self extensions add: classStructure ].
	name := aRwPackageDefinition key , self packageExtension.
	properties := Dictionary new
%

category: 'initialization'
method: RwCypressPackageStructure
fromSnapshot: snapshot
  | classMap classDefinitions |
  classDefinitions := OrderedCollection new.
  classMap := Dictionary new.
  snapshot
    do: [ :definition | 
      definition
        classDefinition: [ :classDefinition | classDefinitions add: classDefinition ]
        methodDefinition: [ :methodDefinition | 
          (classMap at: methodDefinition className ifAbsentPut: [ Set new ])
            add: methodDefinition ] ].
  self name: self name from: classDefinitions classMap: classMap
%

category: 'snapshotting'
method: RwCypressPackageStructure
rwSnapshot

	| rwPackageDefinition |
	rwPackageDefinition := RwPackageDefinition new
		properties:
			(Dictionary new
				at: 'name' put: self packageName;
				yourself).
	self classes
		do: [ :classStructure | 
			| rwClassDef |
			rwClassDef := RwClassDefinition fromCypressClassStructure: classStructure.
			rwPackageDefinition addClassDefinition: rwClassDef ].
	self extensions
		do: [ :classStructure | 
			| rwClassExtensionDef |
			rwClassExtensionDef := RwClassExtensionDefinition
				newForClassNamed: classStructure className.
			(classStructure instanceMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					rwClassExtensionDef
						addInstanceMethodDefinition:
							(RwMethodDefinition fromCypressMethod: methodStructure) ].
			(classStructure classMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					rwClassExtensionDef
						addClassMethodDefinition:
							(RwMethodDefinition fromCypressMethod: methodStructure) ].
			rwPackageDefinition addClassExtensionDefinition: rwClassExtensionDef ].
	^ rwPackageDefinition
%

category: 'snapshotting'
method: RwCypressPackageStructure
snapshot

	| definitions |
	definitions := OrderedCollection new.
	self classes
		do: [ :classStructure | 
			definitions add: classStructure asCypressClassDefinition.
			(classStructure instanceMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | definitions add: methodStructure asCypressMethodDefinition ].
			(classStructure classMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | definitions add: methodStructure asCypressMethodDefinition ] ].
	self extensions
		do: [ :classStructure | 
			(classStructure instanceMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					| mdef |
					mdef := methodStructure asCypressMethodDefinition.
					mdef isExtensionMethod: true.
					definitions add: mdef ].
			(classStructure classMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					| mdef |
					mdef := methodStructure asCypressMethodDefinition.
					mdef isExtensionMethod: true.
					definitions add: mdef ] ].
	^ CypressSnapshot definitions: definitions
%

! Class implementation for 'CypressPackageComparator'

!		Class methods for 'CypressPackageComparator'

category: 'instance creation'
classmethod: CypressPackageComparator
comparingPackageNamed: packageName fromDirectory: aDirectory

	^(self new)
		comparingPackageNamed: packageName fromDirectory: aDirectory;
		yourself
%

category: 'instance creation'
classmethod: CypressPackageComparator
new

	^super new
		initialize;
		yourself
%

!		Instance methods for 'CypressPackageComparator'

category: 'comparing - private'
method: CypressPackageComparator
add: aDefinition to: aDictionary

	aDefinition
		classDefinition: [:classDefinition | self addClassDefinition: classDefinition to: aDictionary]
		methodDefinition: [:methodDefinition | self addMethodDefinition: methodDefinition to: aDictionary]
%

category: 'comparing - private'
method: CypressPackageComparator
addClassDefinition: classDefinition to: aDictionary

	(aDictionary at: classDefinition className ifAbsentPut: [Dictionary new])
		at: 'class category' put: classDefinition category;
		at: 'class comment' put: classDefinition comment;
		at: 'class definition' put: classDefinition classDefinitionString.
%

category: 'comparing - private'
method: CypressPackageComparator
addMethodDefinition: methodDefinition to: aDictionary

	((aDictionary at: methodDefinition className ifAbsentPut: [Dictionary new])
		at: (methodDefinition classIsMeta
				ifTrue: ['class methods']
				ifFalse: ['instance methods'])
		ifAbsentPut: [Dictionary new]) at: methodDefinition selector
			put: methodDefinition category -> methodDefinition source
%

category: 'comparing - private'
method: CypressPackageComparator
applyAddition: aCypressAddition

	self add: aCypressAddition definition to: self currentAdditions
%

category: 'comparing - private'
method: CypressPackageComparator
applyModification: aCypressModification

	self
		add: aCypressModification modification to: self currentAdditions;
		add: aCypressModification obsoletion to: self currentRemovals.
%

category: 'comparing - private'
method: CypressPackageComparator
applyRemoval: aCypressRemoval

	self add: aCypressRemoval definition to: self currentRemovals.
%

category: 'comparing'
method: CypressPackageComparator
compare

	diskSnapshots keys do: [:packageName |
		self resetCurrentForPackage: packageName.
		self currentPatchOperations do: [:each | each applyTo: self].
	].
	self resetCurrentForPackage: nil.
%

category: 'initializing'
method: CypressPackageComparator
comparingPackages: someNames fromDirectory: aDirectory

	(directoryPackageMap at: aDirectory ifAbsentPut: [OrderedCollection new])
		addAll: someNames.
	someNames do: 
			[:packageName |
			| reader modTime modTimestamp |
			reader := (CypressFileSystemRepository on: aDirectory) reader
						readPackageStructureForPackageNamed: packageName.
			diskSnapshots at: packageName put: reader packageStructure snapshot.
			modTime := System
						performOnServer: 'stat --printf=%y ' , reader packageDirectory.
			modTimestamp := (modTime indexOfSubCollection: 'stat:' startingAt: 1 ifAbsent: [ 0 ]) = 1
						ifTrue: [nil]
						ifFalse: [self dateAndTimeFromUnixFormatString: modTime].
			diskTimestamps at: packageName put: modTimestamp.
			imageSnapshots at: packageName
				put: (CypressPackageDefinition named: packageName) snapshot]
%

category: 'comparing - private'
method: CypressPackageComparator
currentAdditions

	currentAdditions ifNil: [self updateCurrentAdditionsAndRemovals].
	^currentAdditions
%

category: 'comparing - private'
method: CypressPackageComparator
currentDiskSnapshot

	^diskSnapshots at: currentPackageName
%

category: 'comparing - private'
method: CypressPackageComparator
currentImageSnapshot

	^imageSnapshots at: currentPackageName
%

category: 'comparing - private'
method: CypressPackageComparator
currentPatchOperations

	^(CypressPatch fromBase: self currentDiskSnapshot toTarget: self currentImageSnapshot) operations.
%

category: 'comparing - private'
method: CypressPackageComparator
currentRemovals

	currentRemovals ifNil: [self updateCurrentAdditionsAndRemovals].
	^currentRemovals
%

category: 'initializing - private'
method: CypressPackageComparator
dateAndTimeFromUnixFormatString: aString
	"YYYY-MM-DDTHH:MM:SS +HHMM
	 Examples:
		| string |
		string := '2013-06-20 14:47:55.40271592140198 -0700'.
		(DateAndTimeANSI fromUnixFormatString: string) printString = '2013-06-20T14:47:55.40271592140198-07:00'.
	"

	| stream sign positionBias |
	stream := ReadStreamPortable on: aString.
	sign := aString at: aString size - 4.
	positionBias := stream class isLegacyStreamImplementation
				ifTrue: [1]
				ifFalse: [0].
	^DateAndTime
		year: (stream next: 4) asNumber
		month: (stream
				next;
				next: 2) asNumber
		day: (stream
				next;
				next: 2) asNumber
		hour: (stream
				next;
				next: 2) asNumber
		minute: (stream
				next;
				next: 2) asNumber
		second: (stream
				next;
				next: aString size - 6 - stream position + positionBias) asNumber
		offset: (Duration
				days: 0
				hours: (stream
						next;
						next;
						next: 2) asNumber
						* (sign == $- ifTrue: [-1] ifFalse: [1])
				minutes: (stream next: 2) asNumber
				seconds: 0)
%

category: 'comparing'
method: CypressPackageComparator
getDifferences

	self compare.
	^self snapshotDifferences
%

category: 'initializing - private'
method: CypressPackageComparator
initialize

	directoryPackageMap := Dictionary new.
	diskTimestamps := Dictionary new.
	diskSnapshots := Dictionary new.
	imageSnapshots := Dictionary new.
	snapshotDifferences := Dictionary new
		at: 'newer' put: (Dictionary with: 'Finished at' -> DateAndTime now);
		at: 'older' put: (Dictionary with: 'Finished at' -> DateAndTime now);
		yourself.
%

category: 'comparing - private'
method: CypressPackageComparator
resetCurrentForPackage: aStringOrNil

	currentPackageName := aStringOrNil.
	currentAdditions := nil.
	currentRemovals := nil.
%

category: 'accessing'
method: CypressPackageComparator
snapshotDifferences

	^snapshotDifferences
%

category: 'comparing - private'
method: CypressPackageComparator
updateCurrentAdditionsAndRemovals

	| oldTimestamp |
	currentAdditions := (snapshotDifferences at: 'newer')
				at: currentPackageName
				ifAbsentPut: [Dictionary new].
	oldTimestamp := (diskTimestamps at: currentPackageName) ifNil: [^self].
	currentRemovals := (snapshotDifferences at: 'older')
				at: currentPackageName
				ifAbsentPut: [Dictionary with: 'Timestamp' -> oldTimestamp printString].
%

! Class implementation for 'CypressPackageManager'

!		Class methods for 'CypressPackageManager'

category: 'instance creation'
classmethod: CypressPackageManager
new

	^super new
		initialize;
		yourself
%

category: 'accessing'
classmethod: CypressPackageManager
packageNamePermutationsFor: aString
	"Answer the variations on possible package names from the specified string.
	 Each hyphen may possibly separate the package name from a suffix."

	| names |
	names := OrderedCollection new.
	aString doWithIndex: 
			[:each :index |
			(each = $- and: [index > 1])
				ifTrue: [names add: (aString copyFrom: 1 to: index - 1)]].
	aString last ~= $- ifTrue: [names add: aString].
	^names
%

category: 'accessing'
classmethod: CypressPackageManager
potentialPackageNames
	"Answer a list of 'package names' from classes and methods.
	 The class category is the package name, if the class is in a package at all.
	 The method category begins with an asterisk (*) before the package name,
	 but can be continued with other details (e.g., *PackageName-accessing).
	 This version does NOT recognize method category suffixes."

	| classCategories methodCategories |
	classCategories := Set new.
	methodCategories := Set new.
	System myUserProfile symbolList do: 
			[:dict |
			dict do: 
					[:aClass |
					aClass isBehavior and: 
							[classCategories addAll: (self packageNamePermutationsFor: aClass category).
							aClass categorysDo: 
									[:cat :method |
									cat first = $*
										ifTrue: 
											[methodCategories
												addAll: (self packageNamePermutationsFor: (cat copyFrom: 2 to: cat size))]].
							false]]].
	^(Set new)
		addAll: classCategories;
		addAll: methodCategories;
		removeIfPresent: 'User Classes';
		removeIfPresent: 'Kernel';
		sortAscending
%

!		Instance methods for 'CypressPackageManager'

category: 'comparing'
method: CypressPackageManager
compareDefinitionsFromConflictedPackageInformation: aCypressPackageInformation

	| badDefinitions expectedDefinitions |
	badDefinitions := (CypressPackageStructure
				fromPackage: (CypressPackageDefinition
						named: aCypressPackageInformation name))
					snapshot definitions
				asSet.
	expectedDefinitions := OrderedCollection new.
	aCypressPackageInformation competingPackageNames do: 
			[:each |
			expectedDefinitions
				addAll: (CypressPackageStructure
						fromPackage: (CypressPackageDefinition named: each)) snapshot
						definitions].
	expectedDefinitions do: [:each | badDefinitions remove: each ifAbsent: []].
	^(badDefinitions collect: [:each | each printString]) sortAscending
%

category: 'comparing'
method: CypressPackageManager
comparePackageFrom: aCypressPackageInformation

	^self comparePackagesFrom: (Array with: aCypressPackageInformation)
%

category: 'updating - private'
method: CypressPackageManager
determineKnownPackages

	^(packageInformationList select: [:each | each repository notNil])
		inject: Dictionary new
		into: 
			[:dict :each |
			dict
				at: each name put: each savedLocation;
				yourself]
%

category: 'initializing - private'
method: CypressPackageManager
initialize

	self refreshPackageInformation.
%

category: 'initializing - private'
method: CypressPackageManager
initializeConflictingPackageNames

	| conflictingPackages |
	conflictingPackages := Dictionary new.
	packageInformationList do: 
			[:each |
			conflictingPackages at: each
				put: (knownPackages keys select: 
							[:knownName |
							knownName ~= each name
								and: [(knownName indexOfSubCollection: each name , '-' startingAt: 1 ifAbsent: [ 0 ]) = 1]])].
	conflictingPackages := conflictingPackages reject: [:each | each isEmpty].
	conflictingPackages
		keysAndValuesDo: [:package :conflicts | package beConflictedWith: conflicts]
%

category: 'initializing - private'
method: CypressPackageManager
initializeKnownPackages

	knownPackages := (System myUserProfile objectNamed: #KnownCypressPackages)
				ifNil: [Dictionary new]
%

category: 'initializing - private'
method: CypressPackageManager
initializeKnownRepositories

	knownRepositories := Dictionary new.
	knownPackages asSet
		do: [:each | self repositoryOn: each]
%

category: 'initializing - private'
method: CypressPackageManager
initializePackageInformationList

	| allInterestingNames |
	allInterestingNames := Set new
		addAll: self potentialPackageNames;
		addAll: knownPackages keys;
		sortAscending.
	packageInformationList := allInterestingNames collect: 
					[:each |
					| directory repo |
					directory := knownPackages at: each ifAbsent: [nil].
					repo := directory ifNotNil: [self repositoryOn: directory].
					CypressPackageInformation named: each repository: repo]
%

category: 'initializing - private'
method: CypressPackageManager
initializeQualifiedPackageNames

	| qualifiedPackages |
	qualifiedPackages := Dictionary new.
	packageInformationList do: 
			[:each |
			qualifiedPackages at: each
				put: (knownPackages keys select: 
							[:knownName |
							knownName ~= each name
								and: [(each name indexOfSubCollection: knownName , '-' startingAt: 1 ifAbsent: [ 0 ]) = 1]])].
	qualifiedPackages := qualifiedPackages reject: [:each | each isEmpty].
	qualifiedPackages
		keysAndValuesDo: [:package :baseNames | package beQualifiedNameOf: baseNames]
%

category: 'updating'
method: CypressPackageManager
loadPackageFrom: aCypressPackageInformation

	| summary loader |
	loader := (CypressSnapshot definitions: aCypressPackageInformation savedDefinitions)
				updatePackage: (CypressPackageDefinition named: aCypressPackageInformation name).
	summary := Dictionary new.

	loader unloadable notEmpty
		ifTrue: [summary at: 'Unloadable' put: (loader unloadable collect: [:each | each printString])].
	loader errors notEmpty
		ifTrue: [summary at: 'Errors' put: (loader errors collect: [:each | each printString])].
	loader requirements notEmpty
		ifTrue: [summary at: 'Missing Requirements' put: loader requirements asArray].

	^summary
%

category: 'updating'
method: CypressPackageManager
lookForLoadedPackagesIn: aDirectory
	"Update any of the packages in the image which have a Cypress file out in
	 the specified directory to reflect the path where the package has theoretically
	 been saved."

	self lookForLoadedPackagesInRepository: (self repositoryOn: aDirectory).
	^nil
%

category: 'updating'
method: CypressPackageManager
lookForLoadedPackagesInRepository: aCypressRepository
	"Update any of the packages in the image which have a Cypress file out in
	 the specified directory to reflect the path where the package has theoretically
	 been saved."

	| packageNames |
	packageNames := aCypressRepository packageNames.
	(self packageInformationList
		select: [:each | packageNames includes: each name])
			do: [:each | each updateKnownPackageRepository: aCypressRepository].
	self saveKnownPackages.
	^nil
%

category: 'updating'
method: CypressPackageManager
lookForUnloadedPackagesIn: aDirectory
	"Load any package names from aDirectory as known packages.
	 This does not load the package contents."

	self lookForUnloadedPackagesInRepository: (self repositoryOn: aDirectory).
	^nil
%

category: 'updating'
method: CypressPackageManager
lookForUnloadedPackagesInRepository: aCypressRepository
	"Add known packages for any Cypress file outs in the specified directory."

	| packageNames existingPackageNames |
	packageNames := aCypressRepository packageNames.
	(self packageInformationList
		select: [:each | packageNames includes: each name])
			do: [:each | each updateKnownPackageRepository: aCypressRepository].
	existingPackageNames := self packageInformationList
				collect: [:each | each name].
	(packageNames reject: [:each | existingPackageNames includes: each])
		do: 
			[:each |
			self packageInformationList
				add: (CypressPackageInformation named: each repository: aCypressRepository)].
	self saveKnownPackages.
	^nil
%

category: 'accessing'
method: CypressPackageManager
packageInformationList

	^packageInformationList
%

category: 'accessing'
method: CypressPackageManager
potentialPackageNames

	^self class potentialPackageNames
%

category: 'accessing'
method: CypressPackageManager
refreshedPackageInformationList

	self refreshPackageInformation.
	^self packageInformationList.
%

category: 'updating'
method: CypressPackageManager
refreshPackageInformation

	self
		initializeKnownPackages;
		initializeKnownRepositories;
		initializePackageInformationList;
		initializeConflictingPackageNames;
		initializeQualifiedPackageNames
%

category: 'initializing - private'
method: CypressPackageManager
repositoryOn: aDirectory

	^knownRepositories
		at: aDirectory
		ifAbsentPut: [CypressFileSystemRepository on: aDirectory].
%

category: 'updating - private'
method: CypressPackageManager
saveKnownPackages

	self updateKnownPackages.
	((System myUserProfile resolveSymbol: #KnownCypressPackages)
		ifNil: 
			[(System myUserProfile objectNamed: #UserGlobals)
				addAssociation: #KnownCypressPackages -> Dictionary new])
			value: knownPackages
%

category: 'updating - private'
method: CypressPackageManager
updateKnownPackages

	knownPackages := self determineKnownPackages
%

category: 'updating'
method: CypressPackageManager
updateSavedLocation: aDirectory for: aCypressPackageInformation
	"Update the specified package to reflect the path and repository where the
	 package should be saved."

	aCypressPackageInformation
		updateKnownPackageRepository: (self repositoryOn: aDirectory).
	self saveKnownPackages.
	^nil
%

category: 'writing - private'
method: CypressPackageManager
writeCypressPackageToDiskFrom: aCypressPackageInformation

	| packageStructure |
	packageStructure := CypressPackageStructure
				fromPackage: (CypressPackageDefinition
						named: aCypressPackageInformation name).
	aCypressPackageInformation repository writer
		writePackageStructure: packageStructure
%

category: 'writing'
method: CypressPackageManager
writePackagesToDiskFrom: someCypressPackageInformations

	| packageStructure |
	^someCypressPackageInformations do: 
			[:each |
			packageStructure := CypressPackageStructure
						fromPackage: (CypressPackageDefinition named: each name).
			each repository writer writePackageStructure: packageStructure.
			each refresh.
			self saveKnownPackages]
%

category: 'writing - private'
method: CypressPackageManager
writePackageStructure: packageStructure to: aCypressRepository

	aCypressRepository writer writePackageStructure: packageStructure
%

category: 'writing'
method: CypressPackageManager
writePackageToDiskFrom: aCypressPackageInformation

	^self writePackagesToDiskFrom: (Array with: aCypressPackageInformation)
%

! Class implementation for 'CypressPackageManager2'

!		Class methods for 'CypressPackageManager2'

category: 'Instance Creation'
classmethod: CypressPackageManager2
create

	^self new
		initializeFromImage;
		yourself.
%

category: 'Initializing'
classmethod: CypressPackageManager2
initialize

	self savedPackageManagers: IdentityDictionary new
%

category: 'Accessing'
classmethod: CypressPackageManager2
named: aKey
	"Answer the Package Manager previously saved under aKey.
	 It is an error if there was not one saved under that key."

	^self
		named: aKey
		or: [self error: 'No previously saved Package Manager under the key ', aKey printString]
%

category: 'Accessing'
classmethod: CypressPackageManager2
named: aKey or: aBlock
	"Answer the Package Manager previously saved under aKey.
	 Answer the result of evaluating aBlock, if there was not one saved under that key."

	^self savedPackageManagers at: aKey ifAbsent: aBlock
%

category: 'Instance Creation'
classmethod: CypressPackageManager2
new

	^super new
		initialize;
		yourself.
%

category: 'Accessing - private'
classmethod: CypressPackageManager2
packageNamePermutationsFor: aString
	"Answer the variations on possible package names from the specified string.
	 Each hyphen may possibly separate the package name from a suffix."

	| names |
	names := OrderedCollection new.
	aString doWithIndex: 
			[:each :index |
			(each = $- and: [index > 1])
				ifTrue: [names add: (aString copyFrom: 1 to: index - 1)]].
	aString last ~= $- ifTrue: [names add: aString].
	^names
%

category: 'Accessing - private'
classmethod: CypressPackageManager2
potentialPackageNames
	"Answer a list of 'package names' from classes and methods.
	 The class category is the package name, if the class is in a package at all.
	 The method category begins with an asterisk (*) before the package name,
	 but can be continued with other details (e.g., *PackageName-accessing).
	 This version does NOT recognize method category suffixes."

	| classCategories methodCategories |
	classCategories := Set new.
	methodCategories := Set new.
	System myUserProfile symbolList do: 
			[:dict |
			dict do: 
					[:aClass |
					aClass isBehavior and: 
							[classCategories addAll: (self packageNamePermutationsFor: aClass category).
							aClass categorysDo: 
									[:cat :method |
									cat first = $*
										ifTrue: 
											[methodCategories
												addAll: (self packageNamePermutationsFor: (cat copyFrom: 2 to: cat size))]].
							false]]].
	^(Set new)
		addAll: classCategories;
		addAll: methodCategories;
		removeIfPresent: 'User Classes';
		removeIfPresent: 'Kernel';
		sortAscending
%

category: 'Updating'
classmethod: CypressPackageManager2
removePackageManagerSavedAs: aKey
	"Remove the Package Manager previously saved under aKey, if there was one.
	 Answer it or nil if there was not one saved under that key."

	^self savedPackageManagers removeKey: aKey ifAbsent: []
%

category: 'Accessing'
classmethod: CypressPackageManager2
savedPackageManagers

	^SavedPackageManagers
%

category: 'Initializing - private'
classmethod: CypressPackageManager2
savedPackageManagers: anIdentityDictionary

	SavedPackageManagers := anIdentityDictionary
%

!		Instance methods for 'CypressPackageManager2'

category: 'Updating'
method: CypressPackageManager2
addRepository: aRepository to: aKnownPackageInformation

	aKnownPackageInformation addRepository: aRepository.
%

category: 'Updating'
method: CypressPackageManager2
addUnknownPackageNamed: aString

	self packageInformationList
		at: aString
		put: (CypressUnknownPackageInformation named: aString).
%

category: 'Querying'
method: CypressPackageManager2
allResolvedPackageReferences
  | resolved |
  resolved := OrderedCollection new.
  self knownRepositories
    keysAndValuesDo: [ :repoUrl :repo | 
      repo packageNames
        do: [ :packageName | resolved add: (CypressResolvedReference name: packageName repository: repo) ] ].
  ^ resolved asSortedCollection asArray
%

category: 'Updating'
method: CypressPackageManager2
assignRepository: aRepository to: aPackageInformation

	self assignRepository: aRepository toAll: (Array with: aPackageInformation)
%

category: 'Updating'
method: CypressPackageManager2
assignRepository: aRepository toAll: somePackageInformations
	"Assign to those having no repository information and add to those with.
	 Those without a repository need to be converted to Known Package Information instances."

	self knownRepositories at: aRepository url put: aRepository.
	(somePackageInformations reject: [:each | each isKnown])
		do: [:each | self addRepository: aRepository to: (self convertToKnown: each)].
	(somePackageInformations select: [:each | each isKnown])
		do: [:each | self addRepository: aRepository to: each].
%

category: 'Updating'
method: CypressPackageManager2
convert: anUnknownPackageInformation toConflictingWith: aKnownPackageInformation

	| conflicting |
	conflicting := CypressConflictingPackageInformation
				fromUnknown: anUnknownPackageInformation
				conflictingWith: aKnownPackageInformation.
	self replace: anUnknownPackageInformation with: conflicting.
	^conflicting
%

category: 'Updating'
method: CypressPackageManager2
convert: anUnknownPackageInformation toEclipsedBy: aKnownPackageInformation

	| eclipsed |
	eclipsed := CypressEclipsedPackageInformation
				fromUnknown: anUnknownPackageInformation
				eclipsedBy: aKnownPackageInformation.
	self replace: anUnknownPackageInformation with: eclipsed.
	^eclipsed
%

category: 'Updating'
method: CypressPackageManager2
convertToKnown: aPackageInformation

	| known |
	known := CypressKnownPackageInformation fromUnknown: aPackageInformation.
	self replace: aPackageInformation with: known.
	(self findPackagesEclipsedBy: known) do: [:each | self convert: each toEclipsedBy: known].
	(self findPackagesConflictingWith: known) do: [:each | self convert: each toConflictingWith: known].
	^known.
%

category: 'Updating'
method: CypressPackageManager2
createRepositoryNamed: aName under: aDirectory alias: aString schema: schemaName

	^CypressFileSystemRepository createOn: (CypressUrl
				absoluteFromText: schemaName
						, (CypressFileUtilities current directoryFromPath: aName
								relativeTo: aDirectory)
							, '/')
		alias: aString
%

category: 'Accessing - private'
method: CypressPackageManager2
findPackagesConflictingWith: aKnownPackageInformation

	^self packageInformationList select: 
			[:each |
			aKnownPackageInformation name ~= each name and: 
					[(aKnownPackageInformation name indexOfSubCollection: each name , '-' startingAt: 1 ifAbsent: [ 0 ]) = 1]]
%

category: 'Accessing - private'
method: CypressPackageManager2
findPackagesEclipsedBy: aKnownPackageInformation

	^self packageInformationList select: 
			[:each |
			aKnownPackageInformation name ~= each name and: 
					[(each name indexOfSubCollection: aKnownPackageInformation name , '-' startingAt: 1 ifAbsent: [ 0 ]) = 1]]
%

category: 'Initializing - private'
method: CypressPackageManager2
initialize

	self
		knownRepositories: Dictionary new;
		packageInformationList: Dictionary new
%

category: 'Initializing - private'
method: CypressPackageManager2
initializeFromImage

	self initializePackageInformationList.
%

category: 'Initializing - private'
method: CypressPackageManager2
initializePackageInformationList

	self
		packageInformationList: (self potentialPackageNames
				inject: Dictionary new
				into: 
					[:dict :each |
					dict
						at: each put: (CypressUnknownPackageInformation named: each);
						yourself])
%

category: 'Accessing'
method: CypressPackageManager2
knownRepositories

	^knownRepositories
%

category: 'Updating'
method: CypressPackageManager2
knownRepositories: someNamedRepositories

	knownRepositories := someNamedRepositories
%

category: 'Loading'
method: CypressPackageManager2
loadPackageFrom: aKnownPackageInformation defaultSymbolDictionaryName: defaultSymbolDictionaryNameOrNil inRepository: aRepository
  | snapshot summary loader |
  snapshot := (aRepository
    readPackageStructureForPackageNamed: aKnownPackageInformation name) snapshot.
  loader := snapshot
    updatePackage:
      (CypressPackageDefinition named: aKnownPackageInformation name)
    defaultSymbolDictionaryName: defaultSymbolDictionaryNameOrNil.
  summary := Dictionary new.
  loader unloadable notEmpty
    ifTrue: [ 
      summary
        at: 'Unloadable'
        put: (loader unloadable collect: [ :each | each printString ]) ].
  loader errors notEmpty
    ifTrue: [ summary at: 'Errors' put: (loader errors collect: [ :each | each printString ]) ].
  loader requirements notEmpty
    ifTrue: [ summary at: 'Missing Requirements' put: loader requirements asArray ].
  ^ summary
%

category: 'Loading'
method: CypressPackageManager2
loadPackageFrom: aKnownPackageInformation inRepository: aRepository
  ^ self
    loadPackageFrom: aKnownPackageInformation
    defaultSymbolDictionaryName: nil
    inRepository: aRepository
%

category: 'Updating'
method: CypressPackageManager2
lookForPackagesInRepository: aRepository
	"Find the packages in the repository and update the list
	 of package information accordingly."

	| packageNames inImage exImage |
	packageNames := aRepository packageNames.
	inImage := self packageInformationList asArray select: [:each | packageNames includes: each name].
	exImage := packageNames reject: [:each | self packageInformationList anySatisfy: [:info | info name = each]].
	exImage := exImage collect: [:each | CypressUnknownPackageInformation named: each].

	self assignRepository: aRepository toAll: inImage, exImage
%

category: 'Accessing'
method: CypressPackageManager2
packageInformationList

	^packageInformationList
%

category: 'Updating'
method: CypressPackageManager2
packageInformationList: someNamedPackageInformations

	packageInformationList := someNamedPackageInformations
%

category: 'Accessing'
method: CypressPackageManager2
packageInformationNamed: aString

	^self packageInformationNamed: aString
		or: [self error: 'No package information for ' , aString printString]
%

category: 'Accessing'
method: CypressPackageManager2
packageInformationNamed: aString or: aBlock

	^self packageInformationList
		at: aString
		ifAbsent: aBlock.
%

category: 'Accessing - private'
method: CypressPackageManager2
potentialPackageNames

	^self class potentialPackageNames
%

category: 'Updating'
method: CypressPackageManager2
replace: oldPackageInformation with: newPackageInformation

	self packageInformationList
		at: oldPackageInformation name
		put: newPackageInformation.
%

category: 'Initializing - private'
method: CypressPackageManager2
repositoryOn: url alias: aString
	"Answer a repository instance for the specified URL.
	 The characteristics will come from the properties file at the URL location,
	 or will default according to the schema, if there is no properties file."

	^self knownRepositories
		at: url
		ifAbsentPut: [CypressAbstractRepository onUrl: url alias: aString].
%

category: 'Updating'
method: CypressPackageManager2
saveAs: aKey
	"Save the receiver in the class' collection of named managers
	 under the specified key.
	 It will quietly replace anything already under that key."


	self savedPackageManagers at: aKey put: self.
%

category: 'Accessing - private'
method: CypressPackageManager2
savedPackageManagers

	^self class savedPackageManagers
%

category: 'Writing'
method: CypressPackageManager2
writeChangesToAllRepositoriesFor: aPackageInformation

	aPackageInformation writeChangesToAllRepositories.
%

! Class implementation for 'CypressPackageManager3'

!		Class methods for 'CypressPackageManager3'

category: 'testing'
classmethod: CypressPackageManager3
isPackageLoaded: aPackageName

  ^ (CypressPackageDefinition named: aPackageName) snapshot definitions isEmpty not
%

category: 'instance creation'
classmethod: CypressPackageManager3
new
  ^self basicNew initialize
%

!		Instance methods for 'CypressPackageManager3'

category: 'Updating'
method: CypressPackageManager3
addRepository: aRepository
  self knownRepositories at: aRepository url asString put: aRepository
%

category: 'Updating'
method: CypressPackageManager3
addResolvedReference: resolvedReference
  self resolvedPackageReferences add: resolvedReference
%

category: 'Querying'
method: CypressPackageManager3
allResolvedPackageReferences
  | resolved |
  resolved := OrderedCollection new.
  self knownRepositories
    keysAndValuesDo: [ :repoUrl :repo | 
      repo packageNames
        do: [ :packageName | resolved add: (CypressResolvedReference name: packageName repository: repo) ] ].
  ^ resolved asSortedCollection asArray
%

category: 'initialization'
method: CypressPackageManager3
defaultSymbolDictionaryName

  ^defaultSymbolDictionaryName
%

category: 'initialization'
method: CypressPackageManager3
defaultSymbolDictionaryName: aStringOrNil

  defaultSymbolDictionaryName := aStringOrNil
%

category: 'Updating'
method: CypressPackageManager3
initialize
  self
    knownRepositories: Dictionary new;
    resolvedPackageReferences: OrderedCollection new;
    yourself
%

category: 'Accessing'
method: CypressPackageManager3
knownRepositories

   ^knownRepositories
%

category: 'Accessing'
method: CypressPackageManager3
knownRepositories: anObject

   knownRepositories := anObject
%

category: 'loading'
method: CypressPackageManager3
loadResolvedReference: resolvedReference
  | cypressLoader package repository snapshot |
  cypressLoader := CypressLoader new.
  cypressLoader defaultSymbolDictionaryName: self defaultSymbolDictionaryName.
  package := resolvedReference packageDefinition.
  repository := resolvedReference repository.
  snapshot := (repository
    readPackageStructureForPackageNamed: resolvedReference name) snapshot.
  cypressLoader updatePackage: package withSnapshot: snapshot.
  cypressLoader load.
  cypressLoader unloadable notEmpty
    ifTrue: [ self error: 'Unloadable definitions' ].
  cypressLoader errors notEmpty
    ifTrue: [ self error: 'Load errors' ].
  cypressLoader requirements notEmpty
    ifTrue: [ self error: 'Missing Requirements' ]
%

category: 'loading'
method: CypressPackageManager3
loadResolvedReferences
  | cypressLoader |
  cypressLoader := CypressLoader new.
  cypressLoader defaultSymbolDictionaryName: self defaultSymbolDictionaryName.
  self resolvedPackageReferences
    do: [ :resolvedReference | | package repository snapshot |
      package := resolvedReference packageDefinition.
      repository := resolvedReference repository.
      snapshot := (repository
        readPackageStructureForPackageNamed: resolvedReference name) snapshot.
      cypressLoader updatePackage: package withSnapshot: snapshot ].
  cypressLoader load.
  cypressLoader unloadable notEmpty
    ifTrue: [ self error: 'Unloadable definitions' ].
  cypressLoader errors notEmpty
    ifTrue: [ self error: 'Load errors' ].
  cypressLoader requirements notEmpty
    ifTrue: [ self error: 'Missing Requirements' ]
%

category: 'Accessing'
method: CypressPackageManager3
resolvedPackageReferences
  ^ resolvedPackageReferences
%

category: 'Accessing'
method: CypressPackageManager3
resolvedPackageReferences: anObject
  resolvedPackageReferences := anObject
%

category: 'Unloading'
method: CypressPackageManager3
unloadPackage: aPackage

  | loader summary |
  loader := (CypressPackageDefinition named: aPackage name) snapshot
              unload.
  summary := Dictionary new.
  loader unloadable notEmpty
    ifTrue: [ 
      summary
        at: 'Unloadable'
        put: (loader unloadable collect: [ :each | each printString ]) ].
  loader errors notEmpty
    ifTrue: [ summary at: 'Errors' put: (loader errors collect: [ :each | each printString ]) ].
  loader requirements notEmpty
    ifTrue: [ summary at: 'Missing Requirements' put: loader requirements asArray ].
  ^ summary
%

category: 'Unloading'
method: CypressPackageManager3
unloadPackageNamed: aPackageName
  ^ self unloadPackage: (CypressPackageDefinition named: aPackageName)
%

! Class implementation for 'CypressEnvironmentPackageManager'

!		Instance methods for 'CypressEnvironmentPackageManager'

category: 'accessing'
method: CypressEnvironmentPackageManager
compilationSymbolList
  ^ compilationSymbolList
    ifNil: [ compilationSymbolList := self defaultSymbolList ]
%

category: 'accessing'
method: CypressEnvironmentPackageManager
compilationSymbolList: anObject

   compilationSymbolList := anObject
%

category: 'accessing'
method: CypressEnvironmentPackageManager
defaultEnvironmentId

   ^defaultEnvironmentId
%

category: 'accessing'
method: CypressEnvironmentPackageManager
defaultEnvironmentId: anObject

   defaultEnvironmentId := anObject
%

category: 'accessing'
method: CypressEnvironmentPackageManager
defaultSymbolList

   ^defaultSymbolList
%

category: 'accessing'
method: CypressEnvironmentPackageManager
defaultSymbolList: anObject

   defaultSymbolList := anObject
%

category: 'loading'
method: CypressEnvironmentPackageManager
loadResolvedReferences
  | cypressLoader |
  cypressLoader := CypressEnvironmentLoader new.
  cypressLoader
    defaultSymbolDictionaryName: self defaultSymbolDictionaryName;
    compilationSymbolList: self compilationSymbolList;
    lookupSymbolList: self lookupSymbolList;
    defaultEnvironmentId: self defaultEnvironmentId.
  self resolvedPackageReferences
    do: [ :resolvedReference | 
      | package repository snapshot |
      package := resolvedReference packageDefinition.
      repository := resolvedReference repository.
      snapshot := (repository
        readPackageStructureForPackageNamed: resolvedReference name) snapshot.
      cypressLoader updatePackage: package withSnapshot: snapshot ].
  cypressLoader load.
  cypressLoader unloadable notEmpty
    ifTrue: [ self error: 'Unloadable definitions' ].
  cypressLoader errors notEmpty
    ifTrue: [ self error: 'Load errors' ].
  cypressLoader requirements notEmpty
    ifTrue: [ self error: 'Missing Requirements' ]
%

category: 'loading'
method: CypressEnvironmentPackageManager
loadResolvedReferences: fileNames
  | cypressLoader doUnloads |
  cypressLoader := CypressEnvironmentLoader new.
  cypressLoader
    defaultSymbolDictionaryName: self defaultSymbolDictionaryName;
    compilationSymbolList: self compilationSymbolList;
    lookupSymbolList: self lookupSymbolList;
    defaultEnvironmentId: self defaultEnvironmentId.
  self resolvedPackageReferences
    do: [ :resolvedReference | 
      | package repository snapshot |
      package := resolvedReference packageDefinition.
      repository := resolvedReference repository.
      snapshot := (repository
        readPackageStructureForPackageNamed: resolvedReference name
        files: fileNames ) snapshot.
      cypressLoader updatePackage: package withSnapshot: snapshot ].
  doUnloads := false .
  cypressLoader load: doUnloads .
  doUnloads ifTrue:[ cypressLoader unloadable notEmpty
      ifTrue: [ self error: 'Unloadable definitions' ]].
  cypressLoader errors notEmpty
    ifTrue: [ self error: 'Load errors' ].
  doUnloads ifTrue:[ cypressLoader requirements notEmpty
      ifTrue: [ self error: 'Missing Requirements' ]].
%

category: 'accessing'
method: CypressEnvironmentPackageManager
lookupSymbolList
  ^ lookupSymbolList ifNil: [ lookupSymbolList := self defaultSymbolList ]
%

category: 'accessing'
method: CypressEnvironmentPackageManager
lookupSymbolList: anObject

   lookupSymbolList := anObject
%

! Class implementation for 'CypressPackageStringComparator'

!		Class methods for 'CypressPackageStringComparator'

category: 'instance creation'
classmethod: CypressPackageStringComparator
comparingPackageNamed: packageName fromDirectory: aDirectory

	^(self new)
		comparingPackageNamed: packageName fromDirectory: aDirectory;
		yourself
%

category: 'instance creation'
classmethod: CypressPackageStringComparator
forCypress

	^(self new)
		comparingPackages: #('Cypress-Definitions' 'Cypress-Mocks' 'Cypress-Structure' 'Cypress-Tests' 'Cypress-GemStoneFileServer' 'Cypress-Comparison')
			fromDirectory: '/opt/git/CypressReferenceImplementation/';
		yourself
%

category: 'instance creation'
classmethod: CypressPackageStringComparator
new

	^super new
		initialize;
		yourself
%

!		Instance methods for 'CypressPackageStringComparator'

category: 'comparing - private'
method: CypressPackageStringComparator
addAddition: aCypressModification to: aCollection
  aCypressModification definition
    classDefinition: [ :classDefinition | self addClassAddition: aCypressModification to: aCollection ]
    methodDefinition: [ :methodDefinition | self addMethodAddition: aCypressModification to: aCollection ]
%

category: 'comparing - private'
method: CypressPackageStringComparator
addClassAddition: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification definition details).
      #'addition'.
      #'class'.
      (aCypressModification definition classDefinitionString)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addClassModification: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification modification details).
      #'modification'.
      #'class'.
      (aCypressModification obsoletion classDefinitionString).
      (aCypressModification modification classDefinitionString)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addClassRemoval: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification definition details).
      #'removal'.
      #'class'.
      (aCypressModification definition classDefinitionString)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addMethodAddition: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification definition details).
      #'addition'.
      #'method'.
      (aCypressModification definition source)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addMethodModification: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification modification details).
      #'modification'.
      #'method'.
      (aCypressModification obsoletion source).
      (aCypressModification modification source)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addMethodRemoval: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification definition details).
      #'removal'.
      #'method'.
      (aCypressModification definition source)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addModification: aCypressModification to: aCollection
  aCypressModification modification
    classDefinition: [ :classDefinition | self addClassModification: aCypressModification to: aCollection ]
    methodDefinition: [ :methodDefinition | self addMethodModification: aCypressModification to: aCollection ]
%

category: 'comparing - private'
method: CypressPackageStringComparator
addRemoval: aCypressModification to: aCollection
  aCypressModification definition
    classDefinition: [ :classDefinition | self addClassRemoval: aCypressModification to: aCollection ]
    methodDefinition: [ :methodDefinition | self addMethodRemoval: aCypressModification to: aCollection ]
%

category: 'comparing - private'
method: CypressPackageStringComparator
applyAddition: aCypressAddition
  self addAddition: aCypressAddition to: self currentOperations
%

category: 'comparing - private'
method: CypressPackageStringComparator
applyModification: aCypressModification
  self addModification: aCypressModification to: self currentOperations
%

category: 'comparing - private'
method: CypressPackageStringComparator
applyRemoval: aCypressRemoval
  self addRemoval: aCypressRemoval to: self currentOperations
%

category: 'comparing'
method: CypressPackageStringComparator
compare

	diskSnapshots keys do: [:packageName |
		self resetCurrentForPackage: packageName.
		self currentPatchOperations do: [:each | each applyTo: self].
	].
	self resetCurrentForPackage: nil.
%

category: 'initializing'
method: CypressPackageStringComparator
comparingPackages: someNames fromDirectory: aDirectory
  (directoryPackageMap at: aDirectory ifAbsentPut: [ OrderedCollection new ])
    addAll: someNames.
  someNames
    do: [ :packageName | 
      | reader |
      reader := (CypressFileSystemRepository on: aDirectory) reader
        readPackageStructureForPackageNamed: packageName.
      diskSnapshots at: packageName put: reader packageStructure snapshot.
      imageSnapshots
        at: packageName
        put: (CypressPackageDefinition named: packageName) snapshot ]
%

category: 'comparing - private'
method: CypressPackageStringComparator
currentDiskSnapshot

	^diskSnapshots at: currentPackageName
%

category: 'comparing - private'
method: CypressPackageStringComparator
currentImageSnapshot

	^imageSnapshots at: currentPackageName
%

category: 'comparing - private'
method: CypressPackageStringComparator
currentOperations
  (self dynamicInstVarAt: #'currentOperations')
    ifNil: [ self updateCurrentOperations ].
  ^ self dynamicInstVarAt: #'currentOperations'
%

category: 'comparing - private'
method: CypressPackageStringComparator
currentOperations: aDictionary
  self dynamicInstVarAt: #'currentOperations' put: aDictionary
%

category: 'comparing - private'
method: CypressPackageStringComparator
currentPatchOperations

	^(CypressPatch fromBase: self currentDiskSnapshot toTarget: self currentImageSnapshot) operations.
%

category: 'comparing'
method: CypressPackageStringComparator
getDifferences

	self compare.
	^self snapshotDifferences
%

category: 'initializing - private'
method: CypressPackageStringComparator
initialize
  directoryPackageMap := Dictionary new.
  diskTimestamps := Dictionary new.
  diskSnapshots := Dictionary new.
  imageSnapshots := Dictionary new.
  snapshotDifferences := Dictionary new
    at: 'operations' put: Dictionary new;
    yourself
%

category: 'comparing - private'
method: CypressPackageStringComparator
resetCurrentForPackage: aStringOrNil
  currentPackageName := aStringOrNil.
  self currentOperations: nil
%

category: 'accessing'
method: CypressPackageStringComparator
snapshotDifferences

	^snapshotDifferences
%

category: 'comparing - private'
method: CypressPackageStringComparator
updateCurrentOperations
  self
    currentOperations:
      ((snapshotDifferences at: 'operations')
        at: currentPackageName
        ifAbsentPut: [ OrderedCollection new ])
%

! Class implementation for 'CypressReference'

!		Class methods for 'CypressReference'

category: 'instance creation'
classmethod: CypressReference
name: aString
  ^ self basicNew initializeName: aString
%

category: 'instance creation'
classmethod: CypressReference
new
  self error: 'Use #name: to initialize the receiver.'
%

!		Instance methods for 'CypressReference'

category: 'comparing'
method: CypressReference
= aReference
	^ self class = aReference class and: [ self name = aReference name ]
%

category: 'comparing'
method: CypressReference
hash
	^ self name hash
%

category: 'initialization'
method: CypressReference
initializeName: aString
	name := aString
%

category: 'private'
method: CypressReference
matches: aResolvedReference
  "Answer true if the receiver matches aResolvedReference."

  self subclassResponsibility: #'matches:'
%

category: 'accessing'
method: CypressReference
name
	"Answer the name of this reference."
	
	^ name
%

category: 'accessing'
method: CypressReference
packageName
  "Answer the package name."

  self subclassResponsibility: #'packageName'
%

category: 'printing'
method: CypressReference
printOn: aStream
  aStream
    nextPutAll: self class name;
    nextPutAll: ' name: ';
    print: self name
%

category: 'querying'
method: CypressReference
resolveAllWith: aPackageManager
  "Answer a sorted collection of all resolved references within aGofer."

  ^ aPackageManager allResolvedPackageReferences
    select: [ :each | self matches: each ]
%

! Class implementation for 'CypressPackageReference'

!		Instance methods for 'CypressPackageReference'

category: 'accessing'
method: CypressPackageReference
branch
	"Answer the branch of the receiver."
	
	^ branch
%

category: 'initialization'
method: CypressPackageReference
initializeName: aString
	super initializeName: aString.
	self parseName: aString
%

category: 'private'
method: CypressPackageReference
matches: aResolvedReference
  ^ self name = aResolvedReference name
%

category: 'accessing'
method: CypressPackageReference
packageDefinition
  "For in-image packages, only the base package name is used (no branch)"

  ^ CypressPackageDefinition named: self packageName
%

category: 'accessing'
method: CypressPackageReference
packageName
  "Answer the package of the receiver."

  ^ package
%

category: 'initialization'
method: CypressPackageReference
parseName: aString
  | basicName index |
  basicName := aString.
  index := basicName indexOfSubCollection: '.' startingAt: 1.
  index = 0
    ifTrue: [ 
      package := basicName.
      branch := '' ]
    ifFalse: [ 
      package := basicName copyFrom: 1 to: index - 1.
      branch := basicName copyFrom: index to: basicName size ]
%

! Class implementation for 'CypressResolvedReference'

!		Class methods for 'CypressResolvedReference'

category: 'instance creation'
classmethod: CypressResolvedReference
name: aString repository: aRepository
	^ self basicNew initializeName: aString repository: aRepository
%

!		Instance methods for 'CypressResolvedReference'

category: 'comparing'
method: CypressResolvedReference
<= aResolvedReference
  ^ self name <= aResolvedReference name
%

category: 'initialization'
method: CypressResolvedReference
initializeName: aString repository: aRepository
	self initializeName: aString.
	repository := aRepository
%

category: 'accessing'
method: CypressResolvedReference
repository
	"Answer the repository of the receiver."
	
	^ repository
%

! Class implementation for 'CypressUrl'

!		Class methods for 'CypressUrl'

category: 'instance creation'
classmethod: CypressUrl
absoluteFromFileNameOrUrlString: aString
	"Return a URL from and handle Strings without schemes
	as local relative FileUrls instead of defaulting to a HttpUrl
	as absoluteFromText: does."

	^(CypressUrl schemeNameForString: aString)
		ifNil: [CypressFileUrl workingDirectory newFromRelativeText: aString]
		ifNotNil: [CypressUrl absoluteFromText: aString]
%

category: 'instance creation'
classmethod: CypressUrl
absoluteFromText: aString
	"Return a URL from a string and handle
	a String without a scheme as a HttpUrl."

	"CypressUrl absoluteFromText: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'" 
	"CypressUrl absoluteFromText: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"
	"CypressUrl absoluteFromText: 'telnet:chaos.resnet.gatech.edu'"
	"CypressUrl absoluteFromText: 'file:/etc/passwd'"

	| remainder index scheme fragment newUrl |
	"trim surrounding whitespace"
	remainder := aString trimSeparators.

	"extract the fragment, if any"
	index := remainder indexOf: $#.
	index > 0 ifTrue: [
		fragment := remainder copyFrom: index + 1 to: remainder size.
		remainder := remainder copyFrom: 1 to: index - 1].

	"choose class based on the scheme name, and let that class do the bulk of the parsing"
	scheme := self schemeNameForString: remainder.
	newUrl := (self urlClassForScheme: scheme) new privateInitializeFromText: remainder.
	newUrl privateFragment: fragment.
	^newUrl
%

category: 'parsing'
classmethod: CypressUrl
combine: baseURL withRelative: relURL 
	"Take two URL as string form, combine them and return the corresponding URL in string form"

	^((self absoluteFromText: baseURL) newFromRelativeText: relURL) asString
%

category: 'instance creation'
classmethod: CypressUrl
for: aString
	"Return a URL from a string and handle
	a String without a scheme as a HttpUrl."

	^self absoluteFromText: aString
%

category: 'encoding'
classmethod: CypressUrl
isCharacterSafeForHttp: aChar
	"Answer whether a character is 'safe', or needs to be escaped when used, eg, in a URL."

	^aChar codePoint < 128
		and: [aChar isAlphaNumeric or: ['.-_' includes: aChar]]
%

category: 'constants'
classmethod: CypressUrl
schemeName
	"When searching for a class to handle a particular scheme, make sure that Url classes never match by default. This is so that abstract Url classes e.g. HierarchicalUrl can be iterated over, but will not be selected"

	^ nil.
%

category: 'parsing'
classmethod: CypressUrl
schemeNameForString: aString
	"Get the scheme name from a string, or return nil if it's not specified. 
	Used in internal parsing routines - an outsider may as well use asUrl. 
	Return scheme in lowercases."
	
	"Url schemeNameForString: 'http://www.yahoo.com'"
	"Url schemeNameForString: '/etc/passwed'"
	"Url schemeNameForString: '/etc/testing:1.2.3'"

	| index schemeName |
	index := aString indexOf: $: ifAbsent: [^ nil].
	schemeName := aString copyFrom: 1 to: index - 1.
	(schemeName allSatisfy: [:each | each isLetter]) ifFalse: [^ nil].
	^ schemeName asLowercase
%

category: 'parsing'
classmethod: CypressUrl
urlClassForScheme: scheme

	| allSubclasses |
	allSubclasses := self userId = System myUserProfile userId
		ifTrue: [ ClassOrganizer new allSubclassesOf: self ]
		ifFalse: [ (ClassOrganizer newWithRoot: self forUserId: self userId) allSubclassesOf: self ].
	^allSubclasses detect: [:urlClass | urlClass schemeName = scheme]
		ifNone: [CypressGenericUrl]
%

category: 'encoding'
classmethod: CypressUrl
writeWithHttpEscapes: aCollection on: aStream
	"Write the given string or Utf8 on the stream with 'dangerous' characters 
	escaped to their %XX form, for use in HTTP transactions.
	Note that Utf8s containing code points over 128 will not work properly here."

	aCollection do: 
			[:each |
			| char |
			char := each asCharacter.
			(self isCharacterSafeForHttp: char)
				ifTrue: [aStream nextPut: char]
				ifFalse: 
					[| int |
					aStream nextPut: $%.
					int := each asInteger.
					int // 16 printOn: aStream base: 16 showRadix: false.
					int \\ 16 printOn: aStream base: 16 showRadix: false]]
%

!		Instance methods for 'CypressUrl'

category: 'downloading'
method: CypressUrl
activate
	"spawn an external handler for this URL"
	
%

category: 'converting'
method: CypressUrl
asString

	^self printString
%

category: 'converting'
method: CypressUrl
asURI
	^self asString asURI
%

category: 'converting'
method: CypressUrl
asUrl
	^self
%

category: 'converting'
method: CypressUrl
asUrlRelativeTo: aUrl
	^self
%

category: 'accessing'
method: CypressUrl
authority
	^''
%

category: 'encoding'
method: CypressUrl
decodeHttpEscapesOf: aString
	"decode string including %XX form
	 (adapted from Pharo 2.0)"

	| unescaped pos sourceSize |
	unescaped := ReadWriteStreamPortable on: String new.
	pos := 1.
	sourceSize := aString size.
	[pos > sourceSize] whileFalse: 
			[| char |
			char := aString at: pos.
			(char = $% and: [pos + 2 <= sourceSize])
				ifTrue: 
					[| asciiVal |
					asciiVal := ((aString at: pos + 1) asUppercase digitValueInRadix: 16) * 16
								+ ((aString at: pos + 2) asUppercase digitValueInRadix: 16).
					asciiVal > 255 ifTrue: [^aString].
					unescaped nextPut: (Character withValue: asciiVal).
					pos := pos + 3]
				ifFalse: 
					[char = $+
						ifTrue: [unescaped nextPut: Character space]
						ifFalse: [unescaped nextPut: char].
					pos := pos + 1]].
	^unescaped contents
%

category: 'converting'
method: CypressUrl
downloadUrl
	^self asString
%

category: 'fragment'
method: CypressUrl
fragment
	^fragment
%

category: 'downloading'
method: CypressUrl
hasContents
	"whether this URL can download contents to be displayed; if not, it fundamentally requires an outside application to deal with it.  For example, mailto: and telnet: urls"
	^false
%

category: 'parsing'
method: CypressUrl
newFromRelativeText: aString
	"return a URL relative to the current one, given by aString.  For instance, if self is 'http://host/dir/file', and aString is '/dir2/file2', then the return will be a Url for 'http://host/dir2/file2'"

	"if the scheme is the same, or not specified, then use the same class"

	| newSchemeName remainder fragmentStart newFragment newUrl bare |

	bare := aString trimSeparators.
	newSchemeName := CypressUrl schemeNameForString: bare.
	(newSchemeName notNil and: [ newSchemeName ~= self schemeName ]) ifTrue: [
		"different scheme -- start from scratch"
		^CypressUrl absoluteFromText: aString ].

	remainder := bare.

	"remove the fragment, if any"
	fragmentStart := remainder indexOf: $#.
	fragmentStart > 0 ifTrue: [
		newFragment := remainder copyFrom: fragmentStart+1 to: remainder size. 
		remainder := remainder copyFrom: 1 to: fragmentStart-1].

	"remove the scheme name"
	newSchemeName ifNotNil: [
		remainder := remainder copyFrom: (newSchemeName size + 2) to: remainder size ].

	"create and initialize the new url"
	newUrl := self class new privateInitializeFromText: remainder  relativeTo: self.


	"set the fragment"
	newUrl privateFragment: newFragment.


	^newUrl
%

category: 'printing'
method: CypressUrl
printOn: aStream

	^self subclassResponsibility: #printOn:
%

category: 'fragment'
method: CypressUrl
privateFragment: aString
	fragment := aString
%

category: 'parsing'
method: CypressUrl
privateInitializeFromText: aString

	^self subclassResponsibility: #privateInitializeFromText:
%

category: 'parsing'
method: CypressUrl
privateInitializeFromText: aString relativeTo: aUrl
	"initialize from the given string, as a relative URL.  aString will have had the scheme name removed, if it was present to begin with.  If it was, then the scheme name was the same as the receiver's scheme name"

	"by default, just do regular initialization"
	^self privateInitializeFromText: aString
%

category: 'classification'
method: CypressUrl
scheme
	"return a string with the scheme of this URL.  For instance, HTTP"

	^self subclassResponsibility: #scheme
%

category: 'classification'
method: CypressUrl
schemeName
	"return a lowercase string with the scheme of this URL.  For instance, 'http'"

	^self subclassResponsibility: #schemeName
%

category: 'fragment'
method: CypressUrl
withFragment: newFragment
	"return a URL which is the same except that it has a different fragment"
	^self copy privateFragment: newFragment; yourself
%

category: 'fragment'
method: CypressUrl
withoutFragment
	"return a URL which is identical to the receiver except that it has no fragment associated with it"
	^self withFragment: nil
%

category: 'encoding'
method: CypressUrl
writeWithHttpEscapes: aCollection on: aStream

	self class writeWithHttpEscapes: aCollection on: aStream
%

! Class implementation for 'CypressFileUrl'

!		Class methods for 'CypressFileUrl'

category: 'instance creation'
classmethod: CypressFileUrl
absoluteFromText: aString
	"Method that can be called explicitly to create a FileUrl."

	^self new privateInitializeFromText: aString
%

category: 'instance creation'
classmethod: CypressFileUrl
host: aHost pathParts: aCollectionOfPathParts isAbsolute: aBoolean
	"Create a FileUrl."

	^self new host: aHost pathParts: aCollectionOfPathParts isAbsolute: aBoolean
%

category: 'instance creation'
classmethod: CypressFileUrl
pathParts: aCollectionOfPathParts
	"Create a FileUrl."

	^self host: nil pathParts: aCollectionOfPathParts isAbsolute: true
%

category: 'instance creation'
classmethod: CypressFileUrl
pathParts: aCollectionOfPathParts isAbsolute: aBoolean
	"Create a FileUrl."

	^self host: nil pathParts: aCollectionOfPathParts isAbsolute: aBoolean
%

category: 'constants'
classmethod: CypressFileUrl
schemeName
	^'file'
%

category: 'instance creation'
classmethod: CypressFileUrl
workingDirectory

	^self absoluteFromText: CypressFileUtilities current workingDirectory
%

!		Instance methods for 'CypressFileUrl'

category: 'downloading'
method: CypressFileUrl
default
	"Answer a new URL with the receiver's path relative to the current working directory."
	
	self privateInitializeFromText: self pathString relativeTo: self class workingDirectory.
%

category: 'accessing'
method: CypressFileUrl
fileName
	"Return the last part of the path,
	most often a filename but can also be a directory."

	^self path last
%

category: 'testing'
method: CypressFileUrl
firstPartIsDriveLetter
	"Return true if the first part of the path is a letter
	followed by a $: like 'C:' "
	
	| firstPart |
	path isEmpty ifTrue: [^false].
	firstPart := path first.
	^firstPart size = 2 and: [
		firstPart first isLetter
			and: [firstPart last = $:]]
%

category: 'downloading'
method: CypressFileUrl
hasContents
	^true
%

category: 'accessing'
method: CypressFileUrl
host
	"Return the host name, either 'localhost', '', or a fully qualified domain name."
	
	^host ifNil: ['']
%

category: 'accessing'
method: CypressFileUrl
host: hostName
	"Set the host name, either 'localhost', '', or a fully qualified domain name."
	
	host := hostName
%

category: 'private-initialization'
method: CypressFileUrl
host: aHostString pathParts: aCollection isAbsolute: aBoolean

	host := aHostString.
	path := aCollection.
	isAbsolute := aBoolean
%

category: 'private-initialization'
method: CypressFileUrl
initializeFromPathString: aPathString
	"<aPathString> is a file path as a String.
	We construct a path collection using various heuristics."

	| pathString hasDriveLetter |
	pathString := aPathString.
	pathString isEmpty ifTrue: [pathString := '/'].
	"Copy without empty string preceeding first / or between duplicated /s."
	path := ((pathString subStrings: '/') copyWithout: '')
				collect: [:token | self decodeHttpEscapesOf: token].

	"A path like 'C:' refers in practice to 'c:/'"
	(pathString last = $/
		or: [(hasDriveLetter := self firstPartIsDriveLetter) and: [path size = 1]])
			ifTrue: [path add: ''].

	"Decide if we are absolute by checking for leading $/ or
	beginning with drive letter. Smarts for other OSes?"
	self isAbsolute: ((pathString at: 1) = $/
				or: [hasDriveLetter ifNil: [self firstPartIsDriveLetter]])
%

category: 'accessing'
method: CypressFileUrl
isAbsolute
	"Should the path be considered absolute to
	the filesystem instead of relative to the default directory?"
 
	^isAbsolute
%

category: 'accessing'
method: CypressFileUrl
isAbsolute: aBoolean
	"Set if the path should be considered absolute to
	the filesystem instead of relative to the default directory."

	isAbsolute := aBoolean
%

category: 'accessing'
method: CypressFileUrl
path
	"Return an ordered collection of the path elements."
	
	^path
%

category: 'accessing'
method: CypressFileUrl
path: aCollection
	"Set the collection of path elements."

	path := aCollection
%

category: 'paths'
method: CypressFileUrl
pathDirString
	"Path to directory as url, using slash as delimiter.
	Filename is left out."

	| s |
	s := WriteStreamPortable on: (String new: 100).
	isAbsolute ifTrue: [s nextPut: $/].
	1 to: self path size - 1
		do: 
			[:ii |
			s
				nextPutAll: (path at: ii);
				nextPut: $/].
	^s contents
%

category: 'paths'
method: CypressFileUrl
pathForDirectory
	"Path using local file system's pathname delimiter.
	DOS paths with drive letters should not
	be prepended with a delimiter even though
	they are absolute. Filename is left out."

	| delimiter s |
	delimiter := CypressFileUtilities current pathNameDelimiter.
	s := WriteStreamPortable on: (String new: 100).
	(self isAbsolute and: [self firstPartIsDriveLetter not])
		ifTrue: [s nextPutAll: delimiter].
	1 to: self path size - 1
		do: 
			[:ii |
			s
				nextPutAll: (path at: ii);
				nextPutAll: delimiter].
	^s contents
%

category: 'paths'
method: CypressFileUrl
pathForFile
  ^ self pathString
%

category: 'private-initialization'
method: CypressFileUrl
pathParts: aCollection isAbsolute: aBoolean

	^self host: nil pathParts: aCollection isAbsolute: aBoolean
%

category: 'paths'
method: CypressFileUrl
pathString
	"Path as it appears in a URL with $/ as delimiter."

	| s first |
	s := WriteStreamPortable on: (String new: 100).

	"isAbsolute ifTrue:[ s nextPut: $/ ]."
	first := true.
	self path do: 
			[:p |
			first ifFalse: [s nextPut: $/].
			first := false.
			self writeWithHttpEscapes: p on: s].
	^s contents
%

category: 'copying'
method: CypressFileUrl
postCopy
	"Be sure not to share the path with the copy."

	super postCopy.
	path := path copy
%

category: 'printing'
method: CypressFileUrl
printOn: aStream
	"Return the FileUrl according to RFC3986
		'file:'['//'<host>]<path>#<fragment>
	Note that <host> being '' is equivalent to 'localhost' and is not printed."

	aStream
		nextPutAll: self schemeName;
		nextPut: $:.

	"File URLs with hosts (which are fairly useless) cannot be relative."
	host isEmpty
		ifFalse: 
			[isAbsolute
				ifFalse: 
					[aStream nextPutAll: '<ErroneousURL>'.
					^nil].
			aStream
				nextPutAll: '//';
				nextPutAll: host].
	isAbsolute ifTrue: [aStream nextPut: $/].
	aStream nextPutAll: self pathString.
	fragment
		ifNotNil: 
			[aStream nextPut: $#.
			self writeWithHttpEscapes: fragment on: aStream]
%

category: 'private-initialization'
method: CypressFileUrl
privateInitializeFromText: aString
	"Calculate host and path from a file URL in String format.
	Some malformed formats are allowed and interpreted by guessing."

	| schemeName pathString bare i |
	bare := aString trimSeparators.
	schemeName := CypressUrl schemeNameForString: bare.
	(schemeName isNil or: [schemeName ~= self schemeName])
		ifTrue: 
			[host := ''.
			pathString := bare]
		ifFalse: 
			["First remove schemeName and colon"
			bare := bare copyFrom: schemeName size + 2 to: bare size.
			"A proper file URL then has two slashes before host,
			A malformed URL is interpreted as using syntax file:<path>."
			(bare indexOfSubCollection: '//' startingAt: 1 ifAbsent: [ 0 ]) = 1
				ifTrue: 
					[i := bare indexOf: $/ startingAt: 3.
					i = 0
						ifTrue: 
							[host := bare copyFrom: 3 to: bare size.
							pathString := '']
						ifFalse: 
							[host := bare copyFrom: 3 to: i - 1.
							pathString := bare copyFrom: host size + 3 to: bare size]]
				ifFalse: 
					[host := ''.
					pathString := bare]].
	self initializeFromPathString: pathString
%

category: 'private-initialization'
method: CypressFileUrl
privateInitializeFromText: pathString relativeTo: aUrl
	"<pathString> should be a filesystem path.
	This url is adjusted to be aUrl + the path."

	| newPath |
	self host: aUrl host.
	self initializeFromPathString: pathString.
	self isAbsolute: aUrl isAbsolute.
	newPath := aUrl path copy.
	newPath removeLast.	"empty string that says its a directory"
	path do: 
			[:token |
			(token ~= '..' and: [token ~= '.'])
				ifTrue: [newPath addLast: (self decodeHttpEscapesOf: token)].
			token = '..'
				ifTrue: 
					[newPath isEmpty
						ifFalse: [newPath last = '..' ifFalse: [newPath removeLast]]]
			"token = '.' do nothing"].
	path := newPath
%

category: 'classification'
method: CypressFileUrl
scheme
	^self class schemeName
%

category: 'classification'
method: CypressFileUrl
schemeName
	^self class schemeName
%

! Class implementation for 'CypressAbstractFileUrl'

!		Class methods for 'CypressAbstractFileUrl'

category: 'instance creation'
classmethod: CypressAbstractFileUrl
absoluteFromText: aString
	"Return a URL from a string and handle
	a String without a scheme as a FileUrl."

	"Url absoluteFromText: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'" 
	"Url absoluteFromText: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"
	"Url absoluteFromText: 'telnet:chaos.resnet.gatech.edu'"
	"Url absoluteFromText: 'file:/etc/passwd'"

	| remainder index scheme fragment newUrl |
	"trim surrounding whitespace"
	remainder := aString trimSeparators.

	"extract the fragment, if any"
	index := remainder indexOf: $#.
	index > 0 ifTrue: [
		fragment := remainder copyFrom: index + 1 to: remainder size.
		remainder := remainder copyFrom: 1 to: index - 1].

	"choose class based on the scheme name, and let that class do the bulk of the parsing"
	scheme := self schemeNameForString: remainder.
	newUrl := (self urlClassForScheme: scheme) new privateInitializeFromText: remainder.
	newUrl privateFragment: fragment.
	^newUrl
%

category: 'parsing'
classmethod: CypressAbstractFileUrl
urlClassForScheme: scheme

	scheme isNil ifTrue: [^CypressFileUrl].
	^super urlClassForScheme: scheme
%

!		Instance methods for 'CypressAbstractFileUrl'

category: 'accessing'
method: CypressAbstractFileUrl
codeFormat

	^self subclassResponsibility: #codeFormat.
%

category: 'private'
method: CypressAbstractFileUrl
fileUtils
  ^ CypressFileUtilities current
%

category: 'testing'
method: CypressAbstractFileUrl
isStrict

	^self subclassResponsibility: #isStrict.
%

category: 'accessing'
method: CypressAbstractFileUrl
repositoryClass

	^CypressFileSystemRepository
%

! Class implementation for 'CypressCypressFileUrl'

!		Class methods for 'CypressCypressFileUrl'

category: 'constants'
classmethod: CypressCypressFileUrl
schemeName

	^'cypress'
%

!		Instance methods for 'CypressCypressFileUrl'

category: 'accessing'
method: CypressCypressFileUrl
codeFormat

	^'Cypress'
%

category: 'testing'
method: CypressCypressFileUrl
isStrict

	^true
%

! Class implementation for 'CypressFileTreeFormatFileUrl'

!		Class methods for 'CypressFileTreeFormatFileUrl'

category: 'constants'
classmethod: CypressFileTreeFormatFileUrl
schemeName

	^'cypressft'
%

!		Instance methods for 'CypressFileTreeFormatFileUrl'

category: 'accessing'
method: CypressFileTreeFormatFileUrl
codeFormat

	^'FileTree'
%

category: 'testing'
method: CypressFileTreeFormatFileUrl
isStrict

	^false
%

! Class implementation for 'CypressFileTreeReadOnlyFileUrl'

!		Class methods for 'CypressFileTreeReadOnlyFileUrl'

category: 'constants'
classmethod: CypressFileTreeReadOnlyFileUrl
schemeName

	^'cypressfiletree'
%

!		Instance methods for 'CypressFileTreeReadOnlyFileUrl'

category: 'accessing'
method: CypressFileTreeReadOnlyFileUrl
codeFormat

	^'FileTree'
%

category: 'testing'
method: CypressFileTreeReadOnlyFileUrl
isStrict

	^true
%

! Class implementation for 'CypressGitFileUrl'

!		Class methods for 'CypressGitFileUrl'

category: 'constants'
classmethod: CypressGitFileUrl
schemeName
  "A gitcypress url with a host is the target for a remote. All other parameters are optional.
	Parameters are:
		dir : the directory inside the repository where the target MC packages are.
		branch : the git branch to fetch.
		protocol: the user name part to add to the ssh Url, default to git, but can also be https (which implies read only access).
		readOnly : is the repository read only? If present, reduce the history to a minimum (and change the GUI).
	Alternative url syntax:
		gitcypress://github.com/dalehenrich/filetree:pharo5.0_dev/repository
	with:
		host : github.com
		project : dalehenrich/filetree
		branch : pharo5.0_dev
		dir : repository
"

  ^ 'gitcypress'
%

!		Instance methods for 'CypressGitFileUrl'

category: 'accessing'
method: CypressGitFileUrl
codeFormat

	^'Cypress'
%

category: 'printing'
method: CypressGitFileUrl
httpsAccessString
  ^ 'https://' , self host , self projectPath , '.git'
%

category: 'private-initialization'
method: CypressGitFileUrl
initializeFromPathString: aPathString
  | projectDelim repoDelimIndex branchOrTagDelimIndex |
  projectBranchOrTag := repositoryPath := nil.
  projectDelim := aPathString indexOf: $/ startingAt: 2.
  repoDelimIndex := aPathString indexOf: $/ startingAt: projectDelim + 1.
  (branchOrTagDelimIndex := aPathString indexOf: $:) == 0
    ifTrue: [ repoDelimIndex == 0
        ifTrue: [ self projectPath: aPathString ]
        ifFalse: [ self projectPath: (aPathString copyFrom: 1 to: repoDelimIndex - 1).
          self
            repositoryPath:
              (aPathString copyFrom: repoDelimIndex + 1 to: aPathString size) ] ]
    ifFalse: [ self projectPath: (aPathString copyFrom: 1 to: branchOrTagDelimIndex - 1).
      repoDelimIndex == 0
        ifTrue: [ projectBranchOrTag := aPathString
            copyFrom: branchOrTagDelimIndex + 1
            to: aPathString size ]
        ifFalse: [ self projectPath: (aPathString copyFrom: 1 to: branchOrTagDelimIndex - 1).
          self parseBranchOrTagField: [ :pv :rp | projectBranchOrTag := pv.
              self repositoryPath: rp ] pathString: aPathString
          branchOrTagDelimIndex: branchOrTagDelimIndex ] ]
%

category: 'testing'
method: CypressGitFileUrl
isStrict

	^true
%

category: 'private-initialization'
method: CypressGitFileUrl
parseBranchOrTagField: parseBlock pathString: aPathString branchOrTagDelimIndex: branchOrTagDelimIndex
  | strm done escaped repoDelimIndex |
  strm := WriteStream on: String new.
  repoDelimIndex := branchOrTagDelimIndex + 1.
  escaped := done := false.
  [ done ] whileFalse: [ | char |
      repoDelimIndex > aPathString size
        ifTrue: [ done := true ]
        ifFalse: [ char := aPathString at: repoDelimIndex.
          char == $\
            ifTrue: [ escaped
                ifTrue: [ "$\ not legal in branch name ... literally ignored"
                  escaped := false ]
                ifFalse: [ escaped := true ] ]
            ifFalse: [ char == $/
                ifTrue: [ escaped
                    ifFalse: [ done := true ] ].
              done
                ifFalse: [ strm nextPut: char ].
              escaped := false ].
          repoDelimIndex := repoDelimIndex + 1 ] ].
  repoDelimIndex := repoDelimIndex - 1.
  parseBlock
    value: strm contents
    value: (aPathString copyFrom: repoDelimIndex + 1 to: aPathString size)
%

category: 'printing'
method: CypressGitFileUrl
printOn: aStream

	aStream nextPutAll: self schemeName , '://' , self host.
	aStream
		nextPutAll: self projectPath;
		nextPut: $:.
	self projectBranchOrTag do: 
			[:char |
			char = $/ ifTrue: [aStream nextPut: $\].
			aStream nextPut: char].
	aStream
		nextPut: $/;
		nextPutAll: self repositoryPath
%

category: 'accessing'
method: CypressGitFileUrl
projectBranchOrTag
  ^ projectBranchOrTag ifNil: [ 'master' ]
%

category: 'accessing'
method: CypressGitFileUrl
projectBranchOrTag: anObject

   projectBranchOrTag := anObject
%

category: 'accessing'
method: CypressGitFileUrl
projectPath

   ^projectPath
%

category: 'accessing'
method: CypressGitFileUrl
projectPath: aString
  aString last = self fileUtils pathNameDelimiter last
    ifTrue: [ projectPath := aString copyFrom: 1 to: aString size - 1 ]
    ifFalse: [ projectPath := aString ]
%

category: 'accessing'
method: CypressGitFileUrl
repositoryClass
  ^ CypressFileSystemGitRepository
%

category: 'accessing'
method: CypressGitFileUrl
repositoryPath
  ^ repositoryPath ifNil: [ '' ]
%

category: 'accessing'
method: CypressGitFileUrl
repositoryPath: aString
  (aString size > 0
    and: [ aString last = self fileUtils pathNameDelimiter last ])
    ifTrue: [ repositoryPath := aString copyFrom: 1 to: aString size - 1 ]
    ifFalse: [ repositoryPath := aString ]
%

! Class implementation for 'CypressGitFileTreeUrl'

!		Class methods for 'CypressGitFileTreeUrl'

category: 'constants'
classmethod: CypressGitFileTreeUrl
schemeName
  "A gitfiletree url with a host is the target for a remote. All other parameters are optional.
	Parameters are:
		dir : the directory inside the repository where the target MC packages are.
		branch : the git branch to fetch.
		protocol: the user name part to add to the ssh Url, default to git, but can also be https (which implies read only access).
		readOnly : is the repository read only? If present, reduce the history to a minimum (and change the GUI).
	Alternative url syntax:
		gitfiletree://github.com/dalehenrich/filetree:pharo5.0_dev/repository
	with:
		host : github.com
		project : dalehenrich/filetree
		branch : pharo5.0_dev
		dir : repository
"

  ^ 'gitfiletree'
%

!		Instance methods for 'CypressGitFileTreeUrl'

category: 'accessing'
method: CypressGitFileTreeUrl
codeFormat

	^'FileTree'
%

category: 'testing'
method: CypressGitFileTreeUrl
isStrict

	^false
%

! Class implementation for 'CypressLaxFileUrl'

!		Class methods for 'CypressLaxFileUrl'

category: 'constants'
classmethod: CypressLaxFileUrl
schemeName

	^'cypresslax'
%

!		Instance methods for 'CypressLaxFileUrl'

category: 'accessing'
method: CypressLaxFileUrl
codeFormat

	^'Cypress'
%

category: 'testing'
method: CypressLaxFileUrl
isStrict

	^false
%

! Class implementation for 'CypressSmalltalkUrl'

!		Class methods for 'CypressSmalltalkUrl'

category: 'constants'
classmethod: CypressSmalltalkUrl
schemeName

	^'chunk'
%

!		Instance methods for 'CypressSmalltalkUrl'

category: 'accessing'
method: CypressSmalltalkUrl
codeFormat

	^'Chunk'
%

category: 'testing'
method: CypressSmalltalkUrl
isStrict

	^true
%

category: 'accessing'
method: CypressSmalltalkUrl
repositoryClass

	^CypressSmalltalkRepository
%

! Class implementation for 'CypressTopazUrl'

!		Class methods for 'CypressTopazUrl'

category: 'constants'
classmethod: CypressTopazUrl
schemeName

	^'topaz'
%

!		Instance methods for 'CypressTopazUrl'

category: 'accessing'
method: CypressTopazUrl
codeFormat

	^'Topaz'
%

category: 'testing'
method: CypressTopazUrl
isStrict

	^true
%

category: 'accessing'
method: CypressTopazUrl
repositoryClass

	^CypressTopazRepository
%

! Class implementation for 'CypressGenericUrl'

!		Class methods for 'CypressGenericUrl'

category: 'parsing'
classmethod: CypressGenericUrl
absoluteFromText: aString

	| schemeName locator |
	schemeName := CypressUrl schemeNameForString: aString.
	schemeName ifNil: [^self schemeName: 'xnoscheme' locator: aString].
	locator := aString copyFrom: schemeName size + 2 to: aString size.
	^self schemeName: schemeName locator: locator
%

category: 'instance creation'
classmethod: CypressGenericUrl
schemeName: schemeName  locator: locator
	^self new schemeName: schemeName  locator: locator
%

!		Instance methods for 'CypressGenericUrl'

category: 'access'
method: CypressGenericUrl
locator
	^locator
%

category: 'printing'
method: CypressGenericUrl
printOn: aStream
	
	self schemeName ifNotNil: [
		aStream nextPutAll: self schemeName; nextPut: $:].
	
	aStream nextPutAll: self locator.

	self fragment ifNotNil: [
		aStream nextPut: $#; nextPutAll: self fragment].
%

category: 'parsing'
method: CypressGenericUrl
privateInitializeFromText: aString

	schemeName := CypressUrl schemeNameForString: aString.
	locator := schemeName
				ifNil: [aString]
				ifNotNil: [aString copyFrom: schemeName size + 2 to: aString size]
%

category: 'parsing'
method: CypressGenericUrl
privateInitializeFromText: aString relativeTo: aUrl
	schemeName := aUrl schemeName.
	locator := aString.
%

category: 'classification'
method: CypressGenericUrl
scheme
	^ self schemeName.
%

category: 'access'
method: CypressGenericUrl
schemeName
	^schemeName
%

category: 'private'
method: CypressGenericUrl
schemeName: schemeName0  locator: locator0
	schemeName := schemeName0.
	locator := locator0.
%

! Class implementation for 'CypressBrowserUrl'

!		Class methods for 'CypressBrowserUrl'

category: 'constants'
classmethod: CypressBrowserUrl
schemeName

	^'browser'
%

!		Instance methods for 'CypressBrowserUrl'

category: 'downloading'
method: CypressBrowserUrl
hasContents

	^true
%

! Class implementation for 'CypressMailtoUrl'

!		Class methods for 'CypressMailtoUrl'

category: 'constants'
classmethod: CypressMailtoUrl
schemeName

	^ 'mailto'
%

! Class implementation for 'CypressHierarchicalUrl'

!		Class methods for 'CypressHierarchicalUrl'

category: 'instance creation'
classmethod: CypressHierarchicalUrl
schemeName: schemeName  authority: authority  path: path  query: query
	^self new schemeName: schemeName  authority: authority  path: path  query: query
%

!		Instance methods for 'CypressHierarchicalUrl'

category: 'access'
method: CypressHierarchicalUrl
authority
	^authority
%

category: 'access'
method: CypressHierarchicalUrl
fileName
	"Return the last part of the path,
	most often a filename but does not need to be."

	^self path last
%

category: 'printing'
method: CypressHierarchicalUrl
fullPath

	| ans |
	ans := WriteStreamPortable on: String new.
	path do: 
			[:pathElem |
			ans nextPut: $/.
			self writeWithHttpEscapes: pathElem on: ans].
	self query isNil
		ifFalse: 
			[ans nextPut: $?.
			ans nextPutAll: self query].
	self fragment isNil
		ifFalse: 
			[ans nextPut: $#.
			self writeWithHttpEscapes: self fragment on: ans].
	^ans contents
%

category: 'downloading'
method: CypressHierarchicalUrl
hasContents
	"most of these do...."
	^true
%

category: 'access'
method: CypressHierarchicalUrl
isAbsolute
	
	path size > 0 ifFalse: [^ false].
	(path at: 1) size > 0 ifFalse: [^ false].
	^ ((path at: 1) at: 1) ~~ $.
%

category: 'access'
method: CypressHierarchicalUrl
password
	"http://user:pword@foo.com' asUrl password"
	^password
%

category: 'access'
method: CypressHierarchicalUrl
path
	"return a collection of the decoded path elements, as strings"
	^path
%

category: 'access'
method: CypressHierarchicalUrl
path: aCollection
	"Set the collection of path elements."

	path := aCollection
%

category: 'access'
method: CypressHierarchicalUrl
port
	^port
%

category: 'copying'
method: CypressHierarchicalUrl
postCopy
	"Be sure not to share the path with the copy"

	super postCopy.
	path := path copy
%

category: 'printing'
method: CypressHierarchicalUrl
printOn: aStream

	aStream nextPutAll: self schemeName.
	aStream nextPutAll: '://'.
	self username
		ifNotNil: 
			[self writeWithHttpEscapes: self username on: aStream.
			self password
				ifNotNil: 
					[aStream nextPutAll: ':'.
					self writeWithHttpEscapes: self password on: aStream].
			aStream nextPutAll: '@'].
	aStream nextPutAll: self authority.
	port
		ifNotNil: 
			[aStream
				nextPut: $:;
				nextPutAll: port printString].
	path do: 
			[:pathElem |
			aStream nextPut: $/.
			self writeWithHttpEscapes: pathElem on: aStream].
	self query isNil
		ifFalse: 
			[aStream nextPut: $?.
			aStream nextPutAll: self query].
	self fragment isNil
		ifFalse: 
			[aStream nextPut: $#.
			self writeWithHttpEscapes: self fragment on: aStream]
%

category: 'parsing'
method: CypressHierarchicalUrl
privateInitializeFromText: aString
	| remainder ind specifiedSchemeName |
	remainder := aString.
	schemeName
		ifNil: 
			[specifiedSchemeName := CypressUrl schemeNameForString: remainder.
			specifiedSchemeName
				ifNotNil: 
					[schemeName := specifiedSchemeName.
					remainder := remainder copyFrom: schemeName size + 2 to: remainder size].
			schemeName
				ifNil: 
					["assume HTTP"
					schemeName := 'http']].

	"remove leading // if it's there"
	(remainder indexOfSubCollection: '//' startingAt: 1 ifAbsent: [ 0 ]) = 1
		ifTrue: [remainder := remainder copyFrom: 3 to: remainder size].

	"get the query"
	ind := remainder indexOf: $?.
	ind > 0
		ifTrue: 
			[query := remainder copyFrom: ind + 1 to: remainder size.
			remainder := remainder copyFrom: 1 to: ind - 1].

	"get the authority"
	ind := remainder indexOf: $/.
	ind > 0
		ifTrue: 
			[ind = 1
				ifTrue: [authority := '']
				ifFalse: 
					[authority := remainder copyFrom: 1 to: ind - 1.
					remainder := remainder copyFrom: ind + 1 to: remainder size]]
		ifFalse: 
			[authority := remainder.
			remainder := ''].

	"extract the username+password"
	ind := authority indexOf: $@.
	ind > 0
		ifTrue: 
			[username := authority copyFrom: 1 to: ind - 1.
			authority := authority copyFrom: ind + 1 to: authority size.
			ind := username indexOf: $:.
			ind > 0
				ifTrue: 
					[password := (self
								decodeHttpEscapesOf: (username copyFrom: ind + 1 to: username size))
									asByteArray decodeFromUTF8
								asString.
					username := username copyFrom: 1 to: ind - 1]
				ifFalse: [password := nil].
			username := (self decodeHttpEscapesOf: username) asByteArray
						decodeFromUTF8 asString].

	"Extract the port"
	(authority includes: $:)
		ifTrue: 
			[| lastColonIndex portString |
			lastColonIndex := authority findLast: [:c | c = $:].
			portString := authority copyFrom: lastColonIndex + 1 to: authority size.
			(portString size > 0) 
				ifTrue: [ 
					(portString allSatisfy: [:each | each isDigit])
						ifTrue: 
							[port := Integer fromString: portString.
							port > 65535 ifTrue: [self error: 'Invalid port number']]
						ifFalse: [self error: 'Invalid port number']].
			authority := authority copyFrom: 1 to: lastColonIndex - 1].

	"get the path"
	path := self privateParsePath: remainder relativeTo: #()
%

category: 'parsing'
method: CypressHierarchicalUrl
privateInitializeFromText: aString relativeTo: aUrl

	| remainder ind basePath |
	remainder := aString.
	"set the scheme"
	schemeName := aUrl schemeName.

	"a leading // means the authority is specified, meaning it is absolute"
	(remainder indexOfSubCollection: '//' startingAt: 1 ifAbsent: [ 0 ]) = 1
		ifTrue: [^self privateInitializeFromText: aString].

	"otherwise, use the same authority"
	authority := aUrl authority.
	port := aUrl port.
	username := aUrl username.
	password := aUrl password.

	"get the query"
	ind := remainder indexOf: $?.
	ind > 0
		ifTrue: 
			[query := remainder copyFrom: ind + 1 to: remainder size.
			remainder := remainder copyFrom: 1 to: ind - 1].

	"get the path"
	(remainder indexOfSubCollection: '/' startingAt: 1 ifAbsent: [ 0 ]) = 1
		ifTrue: [basePath := #()]
		ifFalse: [basePath := aUrl path].
	path := self privateParsePath: remainder relativeTo: basePath
%

category: 'parsing'
method: CypressHierarchicalUrl
privateParsePath: remainder relativeTo: basePath

	| nextTok s parsedPath |
	s := remainder readStream.
	parsedPath := OrderedCollection new.
	parsedPath addAll: basePath.
	parsedPath isEmpty ifFalse: [parsedPath removeLast].
	
	[s peek = $/ ifTrue: [s next].
	nextTok := WriteStreamPortable on: String new.
	[s atEnd or: [s peek = $/]] whileFalse: [nextTok nextPut: s next].
	nextTok := self decodeHttpEscapesOf: nextTok contents.
	nextTok = '..'
		ifTrue: [parsedPath size > 0 ifTrue: [parsedPath removeLast]]
		ifFalse: [nextTok ~= '.' ifTrue: [parsedPath add: nextTok]].
	s atEnd]
			whileFalse.
	parsedPath isEmpty ifTrue: [parsedPath add: ''].
	^parsedPath
%

category: 'access'
method: CypressHierarchicalUrl
query
	"return the query, the part after any ?.  Any %XY's have already been decoded.  If there wasno query part, nil is returned (it is possible to also have an empty query"
	^query 
%

category: 'classification'
method: CypressHierarchicalUrl
scheme
	^ self schemeName.
%

category: 'access'
method: CypressHierarchicalUrl
schemeName
	^schemeName
%

category: 'private'
method: CypressHierarchicalUrl
schemeName: schemeName0  authority: authority0  path: path0  query: query0
	"initialize a new instance"
	schemeName := schemeName0.
	authority := authority0.
	path := path0.
	query := query0.
%

category: 'access'
method: CypressHierarchicalUrl
username
	"http://user:pword@foo.com' asUrl username"
	^username
%

! Class implementation for 'CypressFtpUrl'

!		Class methods for 'CypressFtpUrl'

category: 'constants'
classmethod: CypressFtpUrl
schemeName

	^ 'ftp'.
%

! Class implementation for 'CypressHttpUrl'

!		Class methods for 'CypressHttpUrl'

category: 'constants'
classmethod: CypressHttpUrl
schemeName

	^ 'http'.
%

! Class implementation for 'CypressHttpsUrl'

!		Class methods for 'CypressHttpsUrl'

category: 'constants'
classmethod: CypressHttpsUrl
schemeName

	^ 'https'.
%

! Class implementation for 'CypressVersionReference'

!		Class methods for 'CypressVersionReference'

category: 'instance creation'
classmethod: CypressVersionReference
name: aString

	^(self basicNew)
		initializeName: aString;
		yourself
%

category: 'instance creation'
classmethod: CypressVersionReference
new

	self error: 'Use #name: to initialize the receiver.'
%

!		Instance methods for 'CypressVersionReference'

category: 'comparing'
method: CypressVersionReference
= aReference

	^self class = aReference class
		and: [self name = aReference name]
%

category: 'accessing'
method: CypressVersionReference
author
	"Answer the author of the receiver."
	
	^ author
%

category: 'accessing'
method: CypressVersionReference
branch
	"Answer the branch of the receiver."
	
	^ branch
%

category: 'comparing'
method: CypressVersionReference
hash

	^self name hash
%

category: 'initialization'
method: CypressVersionReference
initializeName: aString

	name := aString.
	self parseName: aString
%

category: 'private'
method: CypressVersionReference
matches: aResolvedReference
	^ self name = aResolvedReference name
%

category: 'accessing'
method: CypressVersionReference
name
	"Answer the name of this reference."
	
	^ name
%

category: 'accessing'
method: CypressVersionReference
packageName
	"Answer the package of the receiver."

	^ package
%

category: 'initialization'
method: CypressVersionReference
parseName: aString

	| basicName lastDotIndex packageDotIndex lastMinusIndex |
	basicName := (aString isEmpty
				or: [aString last isDigit or: [(aString includes: $() not]])
					ifTrue: [aString]
					ifFalse: 
						["up to last (, but not if there's a . after it"
						| parenIndex dotIndex |
						parenIndex := 0.
						dotIndex := 0.
						aString size to: 1
							by: -1
							do: 
								[:i |
								| c |
								c := aString at: i.
								(c = $. and: [dotIndex = 0])
									ifTrue: 
										[dotIndex := i.
										parenIndex := 0].
								(c = $( and: [parenIndex = 0]) ifTrue: [parenIndex := i]].
						aString copyFrom: 1 to: parenIndex - 1].
	lastMinusIndex := 0.
	lastDotIndex := 0.
	basicName size to: 1
		by: -1
		do: 
			[:i |
			| c |
			c := basicName at: i.
			(c = $- and: [lastMinusIndex = 0]) ifTrue: [lastMinusIndex := i].
			(c = $. and: [lastDotIndex = 0]) ifTrue: [lastDotIndex := i]].
	lastMinusIndex = 0 ifTrue: [lastMinusIndex := basicName size + 1].
	package := basicName copyFrom: 1 to: lastMinusIndex - 1.
	branch := ''.
	packageDotIndex := package indexOf: $..
	packageDotIndex > 0
		ifTrue: 
			[branch := package copyFrom: packageDotIndex + 1 to: package size.
			package := package copyFrom: 1 to: packageDotIndex - 1].
	author := lastMinusIndex = 0
				ifTrue: ['']
				ifFalse: 
					[lastDotIndex < lastMinusIndex ifTrue: [lastDotIndex := basicName size + 1].
					basicName copyFrom: lastMinusIndex + 1 to: lastDotIndex - 1].

	"if basicName is of the form anything-something.number, you'll get number.
If it contains no hyphen, or no period after the last hyphen, you get nothing"
	versionNumber := (basicName indexOf: $-) = 0
				ifTrue: [0]
				ifFalse: 
					[| index lastIndex char |
					index := lastIndex := basicName size.
					char := basicName at: index.
					[char = $. | (char = $-)] whileFalse: 
							[index := index - 1.
							char := basicName at: index].
					char = $-
						ifTrue: [0	"No period after last hyphen."]
						ifFalse: 
							[| numberString |
							numberString := basicName copyFrom: index + 1 to: lastIndex.
							(numberString notEmpty
								and: [numberString allSatisfy: [:each | each isDigit]])
									ifTrue: [numberString asInteger]
									ifFalse: [0]]]
%

category: 'printing'
method: CypressVersionReference
printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: ' name: '.
	self name printOn: aStream
%

category: 'accessing'
method: CypressVersionReference
versionNumber
	"Answer the version of the receiver."

	^ versionNumber
%

! Class implementation for 'FastUUIDGenerator'

!		Class methods for 'FastUUIDGenerator'

category: 'accessing'
classmethod: FastUUIDGenerator
default
	^(SessionTemps current at: self _defaultKey ifAbsent: [])
		ifNil: [
			| default |
			default := self new initialize.
      SessionTemps current at: self _defaultKey put: default ]
%

category: 'initialization'
classmethod: FastUUIDGenerator
initialize

	SessionTemps current removeKey: self _defaultKey ifAbsent: []
%

category: 'accessing'
classmethod: FastUUIDGenerator
next
	"Return a UUID using the shared generator"
	
	"self next"
	
	"[ UUIDGenerator next ] bench"
	
	^ self default next
%

category: 'private'
classmethod: FastUUIDGenerator
_defaultKey

	^ #'UUID_DEFAULT'
%

!		Instance methods for 'FastUUIDGenerator'

category: 'instance creation'
method: FastUUIDGenerator
generateBytes: aPlaceHolder forVersion: aVersion
	aVersion = 4 ifTrue: [self generateFieldsVersion4]
		ifFalse: [self error: 'Unsupported version'].
	self placeFields: aPlaceHolder.
%

category: 'instance creation'
method: FastUUIDGenerator
generateFieldsVersion4

	semaphoreForGenerator critical: 
			[bits1 := random integer.
			bits2 := random integer.
			bits3 := random integer.
			bits4 := random integer].
	bits2 := (bits2 bitAnd: 16rFFFF0FFF) bitOr: 16r4000.
	bits3 := (bits3 bitAnd: 16r3FFFFFFF) bitOr: 16r80000000
%

category: 'instance creation'
method: FastUUIDGenerator
initialize

	random := Random new.
	semaphoreForGenerator := Semaphore forMutualExclusion
%

category: 'accessing'
method: FastUUIDGenerator
next

	"Return the next UUID"
	
	| uuid |
	uuid := UUID nilUUID.
	self generateBytes: uuid forVersion: 4.
	^ uuid
%

category: 'instance creation'
method: FastUUIDGenerator
placeFields: aPlaceHolder

	aPlaceHolder
		unsigned32At: 1 put: bits1;
		unsigned32At: 5 put: bits2;
		unsigned32At: 9 put: bits3;
		unsigned32At: 13 put: bits4
%

! Class implementation for 'File'

!		Class methods for 'File'

category: 'primitives-file'
classmethod: File
atEnd: aGsFile
	"Answer true if the file position is at the end of the file."

	^ aGsFile atEnd
%

category: 'primitives-file'
classmethod: File
close: aGsFile
	"Close this file."

	aGsFile ifNil: [ ^ self ].
	aGsFile close
%

category: 'primitives-file'
classmethod: File
closed: aGsFile
	^ aGsFile isNil or: [ (self sizeOrNil: aGsFile) isNil ]
%

category: 'primitives-file'
classmethod: File
connectToFile: filePointer writable: writableFlag
	"Open the file with the supplied FILE* pointer, and return the file ID obtained.
	writeableFlag indicates whether to allow write operations and must be compatible with the way the file was opened.
	It is the responsibility of the caller to coordinate closing the file."

"
	<primitive: 'primitiveConnectToFile' module: 'FilePlugin' error: error>
	error = #'bad argument' ifTrue: [ 
		(filePointer isKindOf: ByteArray) ifFalse: 
			[ ^self error: 'filePointer must be a ByteArray' ].
		(writableFlag isKindOf: Boolean) ifFalse: 
			[ ^self error: 'writableFlag must be a boolean' ] ].
	^ self primitiveFailed 
"
self error: 'not yet implmented'
%

category: 'primitives-file'
classmethod: File
connectToFileDescriptor: fileDescriptor writable: writableFlag
	"Connect to the file with fileDescriptor number, and return the file ID obtained.
	writeableFlag indicates whether to allow write operations and must be compatible with the way the file was opened.
	It is the responsibility of the caller to coordinate closing the file."

"
	<primitive: 'primitiveConnectToFileDescriptor' module: 'FilePlugin' error: error>
	error = #'bad argument' ifTrue: [ 
		fileDescriptor isInteger ifFalse: 
			[ ^self error: 'fileDescriptor must be an integer' ].
		(writableFlag isKindOf: Boolean) ifFalse: 
			[ ^self error: 'writableFlag must be a boolean' ] ].
	^ self primitiveFailed 
"
self error: 'not yet implmented'

%

category: 'primitives-path'
classmethod: File
createDirectory: fullPath
	"Create a directory named by the given path. 
	Fail if the path is bad or if a file or directory by that name already exists."

	^ GsFile createServerDirectory: fullPath
%

category: 'primitives-path'
classmethod: File
deleteDirectory: fullPath
	"Delete the directory named by the given path. 
	Fail if the path is bad or if a directory by that name does not exist."

	(GsFile removeServerDirectory: fullPath)
		ifNil: [ self error: 'Error deleting directory ', fullPath printString, ' :: ', GsFile serverErrorString ]
%

category: 'primitives-path'
classmethod: File
deleteFile: aFileName
	"Delete the file of the given name. 
	Return self if the primitive succeeds, nil otherwise."

	^ GsFile _removeFile: aFileName onClient: false
%

category: 'primitives-path'
classmethod: File
delimiter
	"Return the path delimiter for the underlying platform's file system."

	"Was a primitive ... only needed to resolve whether or not we're on Windows"

	^ $/
%

category: 'primitives-file'
classmethod: File
fileDescriptorIsAvailable: anInteger
	"Answer a boolean indicating whether the supplied file descriptor (anInteger) is available.
	A file descriptor is considered available if it is connected to a console / terminal, pipe or a file.  cygwin terminals are currently not supported (the pipe is created, but nothing appears in the terminal)"

	^ (self fileDescriptorType: anInteger) between: 1 and: 3
%

category: 'primitives-file'
classmethod: File
fileDescriptorType: fdNum
	"Allow to test if the standard input/output files are from a console or not
	Return values:
	* -1 - Error
	* 0 - no console (windows only)
	* 1 - normal terminal (unix terminal / windows console)
	* 2 - pipe
	* 3 - file
	* 4 - cygwin terminal (windows only)"

"
	<primitive: 'primitiveFileDescriptorType' module: 'FilePlugin' error: error>
	error = #'bad argument'
		ifTrue: [ fdNum isInteger
				ifFalse: [ ^ self error: 'File Descriptor must be an integer!' ] ].
	^ self primitiveFailed
"
self error: 'not yet implmented'
%

category: 'primitives-file'
classmethod: File
flush: aGsFile
	"On Unix, the FilePlugin uses stdio FILE* structs which maintain their
	own internal buffer to minimize write() syscalls. This flushes that buffer.
	On Windows this and primSync: do the same thing."

	aGsFile flush
%

category: 'primitives-path'
classmethod: File
getMacFile: fileName type: typeString creator: creatorString
	"Get the Macintosh file type and creator info for the file with the given name. Fails if the file does not exist or if the type and creator type arguments are not strings of length 4. This primitive is Mac specific; it is a noop on other platforms."

"
 	<primitive: 'primitiveDirectoryGetMacTypeAndCreator' module: 'FilePlugin'>
"
self error: 'not yet implmented'

%

category: 'primitives-file'
classmethod: File
getPosition: aGsFile
	"Get this files current position."

	^ aGsFile position
%

category: 'primitives-path'
classmethod: File
lookupDirectory: fullPath filename: fileName

	"Look up <fileName> (a simple file name) in the directory identified by <fullPath> and 
   return entry array or nil "

	^ self lookupPath: fullPath, '/', fileName
%

category: 'primitives-path'
classmethod: File
lookupPath: fullPath

	"Look up the file or directory identified by <fullPath> and return an array containing:

	<fileName> 			
	<creationTime> 			(in seconds since the start of the Linux time epoch)
	<modificationTime> 	(in seconds since the start of the Linux time epoch)
	<dirFlag> 				DirFlag is true if the entry is a directory
	<fileSize> 				FileSize the file size in bytes or zero for directories
	<posixPermissions> 	Numeric Notation 
	<symLinkFlag>			seemingly, symLinkFlag is true if the entry is a symLink

	On Unix, the empty path denotes '/'. 
   On Macs and PCs, it is the container of the system volumes."

	| gsFileStat |
	(GsFile existsOnServer: fullPath) ifFalse: [^ nil ].
	gsFileStat := GsFile stat: fullPath isLstat: true.
	gsFileStat _isSmallInteger ifTrue: [ ^ nil ].
	^	{
		(Path from: fullPath) basename.
		gsFileStat ctimeUtcSeconds .
		gsFileStat mtimeUtcSeconds .
		gsFileStat isDirectory .
		gsFileStat size.
		gsFileStat mode bitAnd: 8r777. "https://github.com/GemTalk/FileSystemGs/issues/11"
		(gsFileStat mode bitAnd: 8r0120000) = 8r0120000. "https://github.com/GemTalk/FileSystemGs/issues/10"
	}
%

category: 'file creation'
classmethod: File
named: fileName
	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."

	^ self new named: fileName
%

category: 'primitives-file'
classmethod: File
open: fileName writable: writeMode
	"Open a file of the given name, and return the GsFile obtained.
	If writableFlag is true, then
		if there is none with this name, then create one
		else prepare to overwrite the existing from the beginning
	otherwise
		if the file exists, open it read-only
		else return nil"

	"writeMode - #read, #append, #write"

	| mode |
	mode := writeMode == #write 
		ifTrue: [ 'w+' ] 
		ifFalse: [ 
			writeMode = #read
				ifTrue: [ 'r' ]
				ifFalse: [ 
           writeMode == #append 
             ifTrue:[ 'a+' ] 
             ifFalse:[ Error signal:'invalid mode']]].
	^ GsFile
		open: fileName 
		mode: mode 
		onClient: false
%

category: 'file creation'
classmethod: File
openAndTruncateForWriteFileNamed: aName

	^ (self named: aName)
		delete;
		openForWrite
%

category: 'file creation'
classmethod: File
openForReadFileNamed: aName

	^ (self named: aName)
		openForRead
%

category: 'file creation'
classmethod: File
openForWriteFileNamed: aName

	^ (self named: aName) openForWrite
%

category: 'primitives-file'
classmethod: File
read: aGsFile into: byteArray startingAt: startIndex count: count
	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. 
		Answer the number of bytes actually read."

	| buf cnt |
	buf := byteArray species new: count.
	cnt := aGsFile next: count into: buf.
	cnt ifNil: [ 
		(self closed: aGsFile)
			ifTrue: [ ^ self error: 'File is closed' ].
		self error: 'File read failed: ' , (GsFile serverErrorString ifNil: [ '']) ].
	byteArray replaceFrom: startIndex to: startIndex + cnt - 1 with: buf.
	^cnt
%

category: 'primitives-path'
classmethod: File
rename: oldFileFullName to: newFileFullName 
	"Rename the file of the given name to the new name. Fail if there is no file of the old name 
	or if there is an existing file with the new name."

	(GsFile renameFileOnServer: oldFileFullName to: newFileFullName) = 0
		ifFalse: [ self error: 'Rename file failed'].
%

category: 'primitives-file'
classmethod: File
setPosition: aGsFile to: anInteger
	"Set this file to the given position."

	| pos |
	pos := aGsFile position: anInteger.
	pos ifNil: [ self error: 'position error' ].
%

category: 'primitives-file'
classmethod: File
sizeOf: aGsFile
	"Answer the size of this file."

	^ aGsFile fileSize
%

category: 'primitives-file'
classmethod: File
sizeOrNil: aGsFile
	"Answer the size of this file."

	aGsFile ifNil: [ ^ nil ].
	^ aGsFile fileSize
%

category: 'primitives-file'
classmethod: File
stdioHandles
"
	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>
	self primitiveFailed
"
self error: 'not yet implmented'
%

category: 'primitives-file'
classmethod: File
stdioIsAvailable
	"Answer a boolean indicating whether stdio is available on the current platform.
	stdio is considered available if any one of the three files (stdin, stdout, stderr) is available."

	^ (0 to: 2)
		anySatisfy: [ :fdNum | self fileDescriptorIsAvailable: fdNum ]
%

category: 'primitives-file'
classmethod: File
sync: id
	"On Unix, this syncs any written or flushed data still in the kernel file
	system buffers to disk. On Windows this and primFlush: do the same thing"

"
	<primitive: 'primitiveFileSync' module: 'FilePlugin'>

"
self error: 'not yet implmented'

	"fsync() failing cannot be ignored"
	self primitiveFailed
%

category: 'primitives-file'
classmethod: File
truncate: id to: anInteger
	"Truncate this file to the given position."
"
	<primitive: 'primitiveFileTruncate' module: 'FilePlugin'>
	self primitiveFailed
"
self error: 'not yet implmented'
%

category: 'primitives-file'
classmethod: File
write: aGsFile from: stringOrByteArray startingAt: startIndex count: count
	"Write count bytes onto this file from the given string or byte array starting at the given index. 	Answer the number of bytes written."

	| written |
	written := (startIndex = 1 and: [ count = stringOrByteArray size])
		ifTrue: [ aGsFile nextPutAll: stringOrByteArray ]
		ifFalse: [ aGsFile nextPutAll: (stringOrByteArray copyFrom: startIndex to: startIndex + count - 1) ].
	written ifNil: [ self error: 'failed write' ].
	^ written
%

!		Instance methods for 'File'

category: 'printing'
method: File
asString
  "Needed for topaz debugging"
  ^ name
%

category: 'accessing'
method: File
basename
	^self name
%

category: 'open/close'
method: File
basicOpenForWrite: writeMode 
	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."

	"writeMode - #read, #append, #write"

	^ self class open: name writable: writeMode
%

category: 'testing'
method: File
checkDoesNotExist
	"This method implements a backwards compatible logic to #newFileNamed:
	
	If the file does not exist, this method has no effect, and returns self.
	
	If the file exists, it will throw a FileAlreadyExistsException.
	If unhandled, this will open a pop-up asking the user to enter a new name or to override the existing file.
	In this case, this method returns a new file with the options selected by the user.
	"
	self exists ifTrue: [
		^ FileAlreadyExistsException signalOnFile: self ]
%

category: 'open/close'
method: File
delete
	"We retries with GC because in some platforms open files cannot be open"
	self class deleteFile: name.
	self exists
		ifTrue: [ (CannotDeleteFileException new messageText: 'Could not delete file ' , name,'. Check the file is not open.') signal ].
%

category: 'testing'
method: File
exists

	| handle |
	"We open it for read. If the returned handle is nil, the file could not be opened"
	handle := self basicOpenForWrite: #read.
	handle ifNil: [^ false].
	self class close: handle.
	^ true
%

category: 'instance creation'
method: File
name

	^ name
%

category: 'instance creation'
method: File
named: fileName

	name := fileName
%

category: 'open/close'
method: File
openForAppend

	| stream |
	stream := self openForWrite: #append.
	^ stream setToEnd; yourself
%

category: 'open/close'
method: File
openForRead

	^ self openForWrite: #read
%

category: 'open/close'
method: File
openForWrite

	^ self openForWrite: #write
%

category: 'open/close'
method: File
openForWrite: writeMode
	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."

	"writeMode - #read, #append, #write"

	| fileHandle |
	fileHandle := self basicOpenForWrite: writeMode.
	fileHandle ifNil: [
		"Opening the file failed.
		If the file does not exist, we throw an explicit FileDoesNotExistException.
		Otherwise, we throw a generic FileException."
		self exists
			ifFalse: [ ^ FileDoesNotExistException signalWithFile: self writeMode: writeMode == #write ].
		CannotDeleteFileException signal: name
	].

	^ BinaryFileStream handle: fileHandle file: self forWrite: writeMode ~~ #read
%

category: 'streaming'
method: File
readStream
	
	^ self openForRead
%

category: 'streaming'
method: File
readStreamDo: aBlock
	| stream |
	stream := self readStream.
	^ [ aBlock value: stream ]
		ensure: [ stream close ]
%

category: 'accessing'
method: File
size

	^ self readStreamDo: [ :stream | stream size ]
%

category: 'streaming'
method: File
writeStream

	^ self openForWrite
%

category: 'streaming'
method: File
writeStreamDo: aBlock
	| stream |
	stream := self writeStream.
	^ [ aBlock value: stream ]
		ensure: [ stream close ]
%

! Class implementation for 'FileSystem'

!		Class methods for 'FileSystem'

category: 'instance creation'
classmethod: FileSystem
store: aStore
	^ self basicNew
		initializeWithStore: aStore;
		yourself
%

!		Instance methods for 'FileSystem'

category: 'navigating'
method: FileSystem
* anObject
	"Return a relative reference."
	
	^ self referenceTo:( Path * anObject)
%

category: 'navigating'
method: FileSystem
/ anObject
	"Return the absolute reference obtained by resolving anObject against the
	root of this filesystem."
	
	^ self root / anObject
%

category: 'comparing'
method: FileSystem
= other
	^ self species = other species and: [self store = other store]
%

category: 'public'
method: FileSystem
binaryReadStreamOn: aResolvable
	"Resolve the argument into an absolute path and open a file handle on the file
	at that path. Ask the handle to give us a read stream for reading the file."

	^ (self open: aResolvable writable: false) binaryReadStream.
%

category: 'public'
method: FileSystem
binaryWriteStreamOn: aResolvable
	"Resolve the argument into an absolute path and open a file handle on the file
	at that path. Ask the handle to give us a binary write stream for reading the file."

	^ (self open: aResolvable writable: true) binaryWriteStream.
%

category: 'public'
method: FileSystem
checkName: aString fixErrors: fixErrors
	^ store checkName: aString fixErrors: fixErrors
%

category: 'public-enumerating'
method: FileSystem
childNamesAt: aResolvable
	^ Array streamContents: [ :out | 
		self childNamesAt: aResolvable do: [ :path|
			out nextPut: path ]].
%

category: 'public-enumerating'
method: FileSystem
childNamesAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		nodesDo: [ :entry | 
			aBlock value: (store basenameFromEntry: entry) ]
%

category: 'public-enumerating'
method: FileSystem
childrenAt: aResolvable
	^ Array streamContents: [ :out | 
		self childrenAt: aResolvable do: [ :path|
			out nextPut: path ]].
%

category: 'public-enumerating'
method: FileSystem
childrenAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		nodesDo: [ :entry | 
			aBlock value: path / (store basenameFromEntry: entry) ]
%

category: 'public'
method: FileSystem
close
	store close
%

category: 'public'
method: FileSystem
copy: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock
	"Copy the file referenced as sourcePath to the destination referred as destPath. Perform associate actions in case of problems."

	store
		copy: (self resolve: sourcePath)
		ifAbsent: absentBlock
		to: (self resolve: destinationPath)
		ifPresent: presentBlock
		fileSystem: self
%

category: 'public'
method: FileSystem
copy: sourcePath to: destPath
	"Copy the file referenced as sourcePath to the destination referred as destPath.  
	If there is no file at sourcePath, raise FileDoesNotExist.
	If destPath is a file, raise FileExists."
	
	self
		copy: sourcePath
		ifAbsent: [ store signalFileDoesNotExist: sourcePath ]
		to: destPath
		ifPresent: [ store signalFileExists: destPath ]
%

category: 'public'
method: FileSystem
copy: aPath toReference: destinationReference

	^self = destinationReference fileSystem
		ifTrue: [ self copy: aPath to: destinationReference resolve path ]
		ifFalse: [ self copy: aPath toRemote: destinationReference ]
%

category: 'public'
method: FileSystem
copy: aPath toRemote: destRef
	| inputStream path |
	path := self resolve: aPath.
	[ inputStream := self binaryReadStreamOn: path.
	inputStream ifNil: [ store signalFileDoesNotExist: path ].
	destRef fileSystem copyFrom: inputStream to: destRef path ]
		ensure: [ inputStream ifNotNil: [ inputStream close ] ]
%

category: 'public'
method: FileSystem
copyAndDelete: sourcePath to: destination
	"Copy the file referenced as sourcePath to the destination referred as destPath.  
	If there is no file at sourcePath, raise FileDoesNotExist.
	If destPath is a file, raise FileExists.
	If an error occurs during the operation, try and roll back to the original state."
	
	[
		self copy: sourcePath toReference: destination.
		self delete: sourcePath.
	] on: Error do: [ :error |
		destination delete.
		error signal.
	]
%

category: 'private'
method: FileSystem
copyFrom: inputStream to: destPath
	| buffer out |
	out := nil.
	(self exists: destPath)
		ifTrue: [ store signalFileExists: destPath ].
	^ [ 
	out := self binaryWriteStreamOn: destPath.
	buffer := ByteArray new: 1024.
	[ inputStream atEnd ]
		whileFalse: [ 
			buffer := inputStream nextInto: buffer.
			out nextPutAll: buffer ]] ensure: [ out ifNotNil: [ out close ]]
%

category: 'public'
method: FileSystem
createDirectory: aResolvable
	"Resolve aResolvable into an absolute path, then as the store to create a directory there. 
	The store is expected to raise an exception if it cannot do so."

	^ store createDirectory: (self resolve: aResolvable)
%

category: 'public'
method: FileSystem
creationTimeOf: aResolvable
	"Returns the creation date of aResolvable"

	^ store creationTimeOf: (self resolve: aResolvable)
%

category: 'public'
method: FileSystem
delete: aResolvable
	store delete: (self resolve: aResolvable)
%

category: 'public'
method: FileSystem
delimiter
	"Return path delimiter used by this filesystem."

	^ store delimiter
%

category: 'public-enumerating'
method: FileSystem
directoriesAt: aResolvable
	^ Array streamContents: [ :out | 
		self directoriesAt: aResolvable do: [ :path|
			out nextPut: path ]].
%

category: 'public-enumerating'
method: FileSystem
directoriesAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		directoryNodesDo: [ :entry | 
			aBlock value: path / (store basenameFromEntry: entry) ]
%

category: 'public-enumerating'
method: FileSystem
directoryNamesAt: aResolvable
	^ Array streamContents: [ :out | 
		self directoryNamesAt: aResolvable do: [ :name|
			out nextPut: name ]].
%

category: 'public-enumerating'
method: FileSystem
directoryNamesAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		directoryNodesDo: [ :entry | 
			aBlock value: (store basenameFromEntry: entry) ]
%

category: 'public'
method: FileSystem
ensureCreateDirectory: aResolvable
	"Resolve the argument to an absolute path, then ask the store to make
	sure that all the directories contained in the argument path exist or are created."
	
	store ensureCreateDirectory: (self resolve: aResolvable)
%

category: 'public-enumerating'
method: FileSystem
entriesAt: aResolvable
	^ Array
		streamContents: [ :out | 
			self entriesAt: aResolvable do: [ :entry | out nextPut: entry ]
		]
%

category: 'public-enumerating'
method: FileSystem
entriesAt: aResolvable do: aBlock
	^ self 
		entriesAt: aResolvable 
		ifAbsent: [ store signalDirectoryDoesNotExist: ( self resolve: aResolvable) ]
		do: aBlock 
%

category: 'public-enumerating'
method: FileSystem
entriesAt: aResolvable ifAbsent: absentBlock do: aBlock
	| path entry aFilesystem |
	path := self resolve: aResolvable.
	aFilesystem := self.
	store
		directoryAt: path
		ifAbsent: [ ^ absentBlock value ]
		nodesDo: [ :node | 
			entry := store entryFromNode: node path: path for: aFilesystem.
			aBlock value: entry ]
%

category: 'public'
method: FileSystem
entryAt: aResolvable
	| path |
	path := self resolve: aResolvable.
	^ store
		nodeAt: path
		ifPresent: [ :node | store entryFromNode: node fileSystem: self path: path ]
		ifAbsent: [ store signalFileDoesNotExist: path ]
%

category: 'public'
method: FileSystem
exists: aResolvable
	"Resolve the argument, and answer true if the there is
	a file or directory at that path, false if there is not."
	
	^ store exists: (self resolve: aResolvable)
%

category: 'public'
method: FileSystem
extensionDelimiter
	^ $.
%

category: 'public-enumerating'
method: FileSystem
fileNamesAt: aResolvable
	^ Array streamContents: [ :out | 
		self fileNamesAt: aResolvable do: [ :path|
			out nextPut: path ]].
%

category: 'public-enumerating'
method: FileSystem
fileNamesAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		fileNodesDo: [ :entry | 
			aBlock value: (store basenameFromEntry: entry) ]
%

category: 'public-enumerating'
method: FileSystem
filesAt: aResolvable
	^ Array streamContents: [ :out | 
		self filesAt: aResolvable do: [ :path|
			out nextPut: path ]].
%

category: 'public-enumerating'
method: FileSystem
filesAt: aResolvable do: aBlock
	| path |
	path := self resolve: aResolvable.
	store
		directoryAt: path
		ifAbsent: [ store signalDirectoryDoesNotExist: path ]
		fileNodesDo: [ :entry | 
			aBlock value: path / (store basenameFromEntry: entry) ]
%

category: 'printing'
method: FileSystem
forReferencePrintOn: aStream
	store forReferencePrintOn: aStream
%

category: 'public-testing'
method: FileSystem
hasChildren: aResolvable
	"Returns whether aResolvable has children."
	store directoryAt: (self resolve: aResolvable)
			ifAbsent: [ ^false ]
			nodesDo:  [ :node | ^true ].
	^false
%

category: 'public-testing'
method: FileSystem
hasDirectories: aResolvable
	self
		entriesAt: aResolvable
		ifAbsent: [  ^ false ]
		do: [ :entry | 
			entry isDirectory ifTrue: [ ^true ] ].
	^false
%

category: 'public-testing'
method: FileSystem
hasFiles: aResolvable
	self
		entriesAt: aResolvable
		ifAbsent: [  ^ false ]
		do: [ :entry | entry isFile ifTrue: [ ^true ] ].
	^false
%

category: 'comparing'
method: FileSystem
hash
	^ store hash
%

category: 'initialize-release'
method: FileSystem
initializeWithStore: aStore
	store := aStore
%

category: 'public-testing'
method: FileSystem
isCaseSensitive
	^ self store isCaseSensitive
%

category: 'public-testing'
method: FileSystem
isDirectory: aResolvable
	"Resolve the argument, and answer true if the result refers
	to a directory, false if it refers to a file or doesn't exist."

	^ store isDirectory: (self resolve: aResolvable)
%

category: 'public-testing'
method: FileSystem
isFile: aResolvable
	"Resolve the argument, and answer true if the result refers
	to a file, false if it refers to a directory or doesn't exist."

	^ store isFile: (self resolve: aResolvable)
%

category: 'public-testing'
method: FileSystem
isReadable: aResolvable
	"Resolve the argument, and answer true if the there is
	a file or directory that can be read from."
	
	^ (self permissions: aResolvable) isReadable
%

category: 'public-testing'
method: FileSystem
isSymlink: aResolvable
	"Resolve the argument, and answer true if the result refers
	to a directory, false if it refers to a file or doesn't exist."

	^ store isSymlink: (self resolve: aResolvable)
%

category: 'public-testing'
method: FileSystem
isWritable: aResolvable
	"Resolve the argument, and answer true if the there is
	a file that can be written to or directory that can be changed."
	
	^  (self permissions: aResolvable) isWritable
%

category: 'public'
method: FileSystem
modificationTime: aResolvable
	"Returns the date of the last modification of aResolvable"

	^ store modificationTimeOf: (self resolve: aResolvable)
%

category: 'public'
method: FileSystem
modificationTimeOf: aResolvable
	"Returns the last date of modification of aResolvable"

	^ store modificationTimeOf: (self resolve: aResolvable)
%

category: 'public'
method: FileSystem
move: sourcePath to: destination
	"Move the file /directory referenced as sourcePath to the destination referred as destPath.  
	If there is no file at sourcePath, raise FileDoesNotExist.
	If destPath is a file, raise FileExists.
	If destPath is a directory, move the sourcePath in to the directory"

	| fullDestination |

	destination isFile ifTrue: [ FileExists signalWith: destination ].
	destination isDirectory
		ifTrue: [ fullDestination := destination / sourcePath basename ]
		ifFalse: [ fullDestination := destination ].
	self = destination fileSystem ifTrue: 
	[
		"Ideally we would test whether the source and destination are on the same filesystem from the OSs perspective.
		Since we can't do that, just try rename, and if that fails, copy and delete."
		[ self rename: sourcePath to: fullDestination resolve path ]
			on: Error
			do: [ :error | self copyAndDelete: sourcePath to: fullDestination ].
	] ifFalse:
		[ self copyAndDelete: sourcePath to: fullDestination ].
	^fullDestination
%

category: 'public'
method: FileSystem
open
	"Some kinds of filesystems need to open connections to external resources. Does nothing by default."
	
	store open
%

category: 'public'
method: FileSystem
open: aResolvable writable: aBoolean 
	"Resolve aResolvable into an absolute path, then ask the store to open the file at
	that path using the specified access mode."
	
	| path |
	path := self resolve: aResolvable.
	^ store handleClass 
		open: (FileReference fileSystem: self path: path) 
		writable: aBoolean
		
%

category: 'delegated'
method: FileSystem
openFileStream: aResolvable writable: aBoolean
	^ store 
		openFileStream: (self resolve: aResolvable) 
		writable: aBoolean
%

category: 'private'
method: FileSystem
openStreamDescription: aResolvable writable: writeMode
	"I am  a helper method to delegate basicOpen:writable: to the store.
	 I am called from FileSystemHandle implementations."
	
	"writeMode - #read, #append, #write"

	| path |
	
	path := self resolve: aResolvable.
	^ store basicOpen: path writable: writeMode
%

category: 'converting'
method: FileSystem
pathFromObject: anObject 
	^ anObject asPathWith: self
%

category: 'converting'
method: FileSystem
pathFromString: aString
	^ store pathFromString: aString
%

category: 'public'
method: FileSystem
permissions: aResolvable
	"Resolve the argument and return the Permissions for this file or directory "

	^ store permissions: (self resolve: aResolvable)
%

category: 'printing'
method: FileSystem
printPath: aPath on: aStream
	store printPath: aPath on: aStream
%

category: 'public'
method: FileSystem
readStreamOn: aResolvable
	"Resolve the argument into an absolute path and open a file handle on the file
	at that path. Ask the handle to give us a read stream for reading the file."

	^ (self open: aResolvable writable: false) readStream.
%

category: 'public'
method: FileSystem
referenceTo: aResolvable 
	"Answer a reference to the argument from the context of the receiver filesystem.  	
		Example: Filesystem disk referenceTo: 'plonk.taz'"

	^ FileReference 
		fileSystem: self
		path: (self pathFromObject: aResolvable)
%

category: 'public'
method: FileSystem
rename: sourcePath ifAbsent: aBlock to: destPath ifPresent: pBlock
	"Rename the file referenced as sourcePath to the destination referred as destPath. 
	Perform associate actions in case of problems."
	
	| source destination |
	source := self resolve: sourcePath.
	destination := self resolve: destPath.
	store
		rename: source
		ifAbsent: aBlock
		to: destination
		ifPresent: pBlock
		fileSystem: self.
	^ destination
%

category: 'public'
method: FileSystem
rename: sourcePath to: destName
	"Rename the file referenced as sourcePath to destPath.  Raise exceptions 
	FileExists or FileDoesNotExist  if the operation fails"
	
	^ self
		rename: sourcePath
		ifAbsent: [store signalFileDoesNotExist: sourcePath]
		to: destName
		ifPresent: [store signalFileExists: destName]
%

category: 'public'
method: FileSystem
resolve: aResolvable
	^ aResolvable asResolvedBy: self
%

category: 'navigating'
method: FileSystem
resolvePath: aPath
	"Return a path where the argument is resolved in the context of the
	receiver. The behavior is similar to the one of a command line.
		> cd /a/b/c
		> cd b
		The shell will attempt to make /a/b/c/b the current directory. "

	^ self workingDirectoryPath resolve: aPath
%

category: 'navigating'
method: FileSystem
resolveReference: aReference
	^ aReference fileSystem = self ifTrue:
		[self workingDirectoryPath resolvePath: aReference path]
%

category: 'navigating'
method: FileSystem
resolveString: aString
	"Returns the root of the receiver filesystem, i.e. / on unix"
	
	^ self workingDirectoryPath resolvePath: (store pathFromString: aString)
%

category: 'accessing'
method: FileSystem
root
	"Returns the root of the receiver filesystem, i.e. / on unix"
	^ self referenceTo: Path root
%

category: 'accessing'
method: FileSystem
separator
	"Return path separator used by this filesystem."

	^ store separator
%

category: 'public'
method: FileSystem
sizeOf: aResolvable
	"Resolve the argument and return the size for this file or directory "

	^ store sizeOf: (self resolve: aResolvable)
%

category: 'accessing'
method: FileSystem
store
	^ store
%

category: 'converting'
method: FileSystem
stringFromPath: aPath
	^ store stringFromPath: aPath
%

category: 'accessing'
method: FileSystem
workingDirectory
	"Returns a reference to the directory from where the image was launched"

	^ self referenceTo: self workingDirectoryPath
%

category: 'accessing'
method: FileSystem
workingDirectoryPath
	^ store defaultWorkingDirectory
%

category: 'public'
method: FileSystem
writeStreamOn: aResolvable
	"Open a write stream on the file referred by the argument. It can be a string or a path"

	^ (self open: aResolvable writable: true) writeStream.
%

! Class implementation for 'FileSystemDirectoryEntry'

!		Class methods for 'FileSystemDirectoryEntry'

category: 'accessing'
classmethod: FileSystemDirectoryEntry
allPosixPermissions 
	^8r777
%

category: 'instance creation'
classmethod: FileSystemDirectoryEntry
fileSystem: aFilesystem path: aPath creation: cTime modification: mTime isDir: aBoolean size: anInteger posixPermissions: posixNumber isSymlink: symlinkBooleam
	"Create a directory entry given a filesystem and a path in such filesystem. In addition, the creation and modification time are required as well as a boolean that indicates whether the entry is a folder or a file and its size."

	^ self 
		reference: (aFilesystem referenceTo: aPath)
		creation: cTime
		modification: mTime
		isDir: aBoolean
		size: anInteger
		posixPermissions: posixNumber
		isSymlink: symlinkBooleam
%

category: 'instance creation'
classmethod: FileSystemDirectoryEntry
reference: ref creation: cTime modification: mTime isDir: aBoolean size: anInteger posixPermissions: posixNumber isSymlink: symlinkBoolean
	"Create a directory entry for the file reference ref, with the creation time, cTime, the modification time, mTime. aBoolean indicates if the entry represents a directory or a file of size given by anInteger"
	
	^ self basicNew
		initializeWithRef: ref
		creation: cTime
		modification: mTime
		isDir: aBoolean
		size: anInteger
		posixPermissions: posixNumber
		isSymlink: symlinkBoolean
%

!		Instance methods for 'FileSystemDirectoryEntry'

category: 'converting'
method: FileSystemDirectoryEntry
asFileReference
	^ reference
%

category: 'accessing'
method: FileSystemDirectoryEntry
basename

	^ reference basename
%

category: 'accessing'
method: FileSystemDirectoryEntry
creation
	^ self creationTime 
%

category: 'accessing'
method: FileSystemDirectoryEntry
creationSeconds
	"Return the creation date and time of the entry receiver in seconds."
		
	^ creation asSeconds
%

category: 'accessing'
method: FileSystemDirectoryEntry
creationTime
	"Return the creation date and time of the entry receiver."
	
	^ creation
%

category: 'delegate'
method: FileSystemDirectoryEntry
extension
	^ reference extension
%

category: 'delegate'
method: FileSystemDirectoryEntry
fullName
	^ reference fullName
%

category: 'initialize-release'
method: FileSystemDirectoryEntry
initializeWithRef: ref 
	creation: cTime 
	modification: mTime 
	isDir: directoryBoolean
	size: bytes 
	posixPermissions: posixNumber 
	isSymlink: symlinkBoolean
	
	reference := ref.
	creation := cTime.
	modification := mTime.
	isDirectory := directoryBoolean.
	size := bytes.
	posixPermissions := posixNumber.
	isSymlink := symlinkBoolean.
%

category: 'testing'
method: FileSystemDirectoryEntry
isDirectory
	"Return whether the receiver is a directory"
	
	^ isDirectory
%

category: 'testing'
method: FileSystemDirectoryEntry
isFile
	"Return whether the receiver is a file"
	
	^ isDirectory not
%

category: 'testing'
method: FileSystemDirectoryEntry
isSymlink 
	^isSymlink
%

category: 'accessing'
method: FileSystemDirectoryEntry
modification
	^ self modificationTime 
%

category: 'accessing'
method: FileSystemDirectoryEntry
modificationSeconds
	"Return the modification date and time of the entry receiver in seconds."
	^ modification
%

category: 'accessing'
method: FileSystemDirectoryEntry
modificationTime
	"Return the modification date and time of the entry receiver."

	^  modification
%

category: 'accessing'
method: FileSystemDirectoryEntry
name
    ^ self basename
%

category: 'delegate'
method: FileSystemDirectoryEntry
pathSegments
	^ reference pathSegments
%

category: 'accessing'
method: FileSystemDirectoryEntry
permissions 
	^self posixPermissions
		ifNotNil: [ FileSystemPermission posixPermissions: self posixPermissions ]
%

category: 'accessing'
method: FileSystemDirectoryEntry
posixPermissions 
	^posixPermissions
%

category: 'printing'
method: FileSystemDirectoryEntry
printOn: aStream

	aStream nextPutAll: 'DirectoryEntry: '.
	reference ifNotNil: [:ref | aStream nextPutAll: reference printString].
%

category: 'delegate'
method: FileSystemDirectoryEntry
readStream
	^ reference readStreamPortable
%

category: 'delegate'
method: FileSystemDirectoryEntry
readStreamPortable
	^ reference readStreamPortable
%

category: 'accessing'
method: FileSystemDirectoryEntry
reference
	^ reference
%

category: 'accessing'
method: FileSystemDirectoryEntry
size
	"Returns the receiver size"
	^ size
%

category: 'delegate'
method: FileSystemDirectoryEntry
writeStream
	^ reference writeStream
%

! Class implementation for 'FileSystemGuide'

!		Class methods for 'FileSystemGuide'

category: 'instance creation'
classmethod: FileSystemGuide
for: aVisitor
	^ self basicNew initializeWithVisitor: aVisitor
%

category: 'instance creation'
classmethod: FileSystemGuide
show: aReference to: aVisitor
	^ (self for: aVisitor) show: aReference
%

category: 'instance creation'
classmethod: FileSystemGuide
show: aReference to: aVisitor selecting: aBlock
	^ (self for: aVisitor)
		selectChildren:  aBlock;
		show: aReference
%

!		Instance methods for 'FileSystemGuide'

category: 'initialization'
method: FileSystemGuide
initialize

	work := OrderedCollection new
%

category: 'initialize-release'
method: FileSystemGuide
initializeWithVisitor: aVisitor
	self initialize.
	visitor := aVisitor.
	
%

category: 'removing'
method: FileSystemGuide
pop
	^ work removeLast
%

category: 'adding'
method: FileSystemGuide
push: anObject
	work add: anObject
%

category: 'showing'
method: FileSystemGuide
pushAll: aCollection 
	aCollection do: [ :ea | self push: ea ]
%

category: 'accessing'
method: FileSystemGuide
selectChildren
	^ selectChildren
%

category: 'accessing'
method: FileSystemGuide
selectChildren: aBlock
	"With this block you can control how the guide spreads over directories.
	Example: 
		self selectChildren: [ :parentEntry | parentEntry isSymlink not ].
		This will prevent the outer visitor to see any children of symlinked directories.
		
	Since the guides essentially rearrange the files visited controlling which children
	you see is the main concern of the guide. All the other visiting aspects can be 
	controlled in the visitor."
	selectChildren := aBlock
%

category: 'testing'
method: FileSystemGuide
shouldVisitChildrenOf: anEntry
	^ selectChildren 
		ifNil: [ true ]
		ifNotNil: [ selectChildren cull: anEntry ]
%

category: 'showing'
method: FileSystemGuide
show: aReference
	self subclassResponsibility
%

category: 'accessing'
method: FileSystemGuide
top
	^ work removeFirst
%

category: 'showing'
method: FileSystemGuide
whileNotDoneDo: aBlock
	[ work isEmpty ] whileFalse: [ aBlock value ]
%

! Class implementation for 'BreadthFirstGuide'

!		Instance methods for 'BreadthFirstGuide'

category: 'showing'
method: BreadthFirstGuide
show: aReference 
	self push: aReference entry.
	self whileNotDoneDo: [ self visitNextEntry: self top ]
%

category: 'showing'
method: BreadthFirstGuide
visitNextEntry: entry
		
	entry isFile 
		ifTrue: [ ^ visitor visitFile: entry ].
	
	visitor visitDirectory: entry.
	
	(self shouldVisitChildrenOf: entry)
		ifTrue: [ self pushAll: entry reference entries ].
%

! Class implementation for 'PostorderGuide'

!		Instance methods for 'PostorderGuide'

category: 'showing'
method: PostorderGuide
pushTraverse: aReference 
	self push: (Message 
				selector: #traverse:
				argument: aReference)
%

category: 'showing'
method: PostorderGuide
pushVisit: aReference 
	self push: (Message 
				selector: #visit:
				argument: aReference)
%

category: 'showing'
method: PostorderGuide
show: aReference 
	self pushTraverse: aReference entry.
	self whileNotDoneDo: [ self pop sendTo: self ]
%

category: 'showing'
method: PostorderGuide
traverse: anEntry 
		
	self pushVisit: anEntry.
	
	anEntry isDirectory ifTrue: [ 
		(self shouldVisitChildrenOf: anEntry)
			ifFalse: [ ^ self ].
		anEntry reference entries reverseDo: [ :each | 
			self pushTraverse: each ]]
%

category: 'showing'
method: PostorderGuide
visit: anEntry
	anEntry isDirectory
		ifTrue: [ visitor visitDirectory: anEntry ]
		ifFalse: [ visitor visitFile: anEntry ]
%

! Class implementation for 'PreorderGuide'

!		Instance methods for 'PreorderGuide'

category: 'showing'
method: PreorderGuide
pushAll: aCollection 
	aCollection reverseDo: [ :each | work add: each ]
%

category: 'showing'
method: PreorderGuide
show: aReference
	self push: aReference entry.
	self whileNotDoneDo: [ self visitNextEntry: self pop ]
%

category: 'showing'
method: PreorderGuide
visitNextEntry: entry
	
	entry isFile
		ifTrue: [ visitor visitFile: entry ]
		ifFalse: [ 
			visitor visitDirectory: entry.
			(self shouldVisitChildrenOf: entry)
				ifTrue: [ self pushAll: entry reference entries ]]
%

! Class implementation for 'FileSystemHandle'

!		Class methods for 'FileSystemHandle'

category: 'instance creation'
classmethod: FileSystemHandle
on: aReference writable: aBoolean
	^ self new setReference: aReference writable: aBoolean
%

category: 'instance creation'
classmethod: FileSystemHandle
open: aReference writable: aBoolean
	^ (self on: aReference writable: aBoolean) open
%

!		Instance methods for 'FileSystemHandle'

category: 'public'
method: FileSystemHandle
at: index
	| buffer |
	buffer := ByteArray new: 1.
	self at: index read: buffer startingAt: 1 count: 1.
	^ buffer at: 1
%

category: 'public'
method: FileSystemHandle
at: index put: anObject
	| buffer |
	buffer := ByteArray with: (anObject isCharacter
		ifTrue: [ anObject codePoint ]
		ifFalse: [ anObject ]).
	self at: index write: buffer startingAt: 1 count: 1.
	
%

category: 'public'
method: FileSystemHandle
at: offset read: buffer startingAt: start count: count
	self subclassResponsibility
%

category: 'public'
method: FileSystemHandle
at: offset write: buffer startingAt: start count: count
	self subclassResponsibility
%

category: 'private'
method: FileSystemHandle
basicOpen
	"get the raw stream description from the filesystem's store"
	^ self fileSystem 
		openStreamDescription: reference path
		writable: (writable ifTrue: [ #write ] ifFalse: [ #read ])
%

category: 'streams'
method: FileSystemHandle
binaryReadStream
	
	self subclassResponsibility 
%

category: 'streams'
method: FileSystemHandle
binaryWriteStream
	
	self subclassResponsibility 
%

category: 'public'
method: FileSystemHandle
close
	self subclassResponsibility
%

category: 'public'
method: FileSystemHandle
ensureClosed
	reference exists ifTrue: [self close]
%

category: 'accessing'
method: FileSystemHandle
fileSystem
	^ reference fileSystem 
%

category: 'public'
method: FileSystemHandle
flush
	self subclassResponsibility
%

category: 'accessing'
method: FileSystemHandle
fullName
	^ reference fullName
%

category: 'testing'
method: FileSystemHandle
isOpen
	self subclassResponsibility
%

category: 'testing'
method: FileSystemHandle
isWritable
	^ writable
%

category: 'public'
method: FileSystemHandle
open
	self subclassResponsibility
%

category: 'accessing'
method: FileSystemHandle
reference
	^ reference
%

category: 'public'
method: FileSystemHandle
reopen
	self close.
	self open
%

category: 'initialize-release'
method: FileSystemHandle
setReference: aReference writable: aBoolean
	reference := aReference resolve.
	writable := aBoolean
%

category: 'public'
method: FileSystemHandle
sync
	self subclassResponsibility
%

category: 'public'
method: FileSystemHandle
truncateTo: anInteger
	self subclassResponsibility
%

! Class implementation for 'FileHandle'

!		Class methods for 'FileHandle'

category: 'class initialization'
classmethod: FileHandle
startUp: resuming
	"This functionality is disabled for now, to avoid doing a lot of processing at
	image start up. To reenable, add this class to the start up list."
	
	resuming ifTrue: [self allInstancesDo: [:ea | ea startUp]]
%

!		Instance methods for 'FileHandle'

category: 'public'
method: FileHandle
assureOpen
	"Compatibility method to make the FileHandle Tests pass"
	self isOpen ifFalse: [ id := self basicOpen ].
%

category: 'public'
method: FileHandle
at: index read: buffer startingAt: start count: count
	
	self flag: 'TODO: remove once FileHandles are really used!'.
	self assureOpen.
	
	^ File 
		setPosition: id to: index - 1;
		read: id into: buffer startingAt: start count: count
%

category: 'public'
method: FileHandle
at: index write: buffer startingAt: start count: count
	
	self flag: 'TODO: remove once FileHandles are really used!'.
	self assureOpen.
	
	File 
		setPosition: id to: index - 1;
		write: id from: buffer startingAt: start count: count
%

category: 'public'
method: FileHandle
binaryReadStream
	^ ZnBufferedReadStream on: (File named: reference fullName) readStream
%

category: 'public'
method: FileHandle
binaryWriteStream
	^ (File named: reference fullName) writeStream
%

category: 'public'
method: FileHandle
close
	File close: id.
	id := nil
%

category: 'finalization'
method: FileHandle
finalize
	File close: id
%

category: 'public'
method: FileHandle
flush
	
	self flag: 'TODO: remove once FileHandles are really used!'.
	self assureOpen.
	
	File flush: id
%

category: 'testing'
method: FileHandle
isOpen
	^ (File sizeOrNil: id) notNil
%

category: 'public'
method: FileHandle
open
	self flag: 'TODO: for now we solely rely on the old FileStreams'
	"id := self basicOpen.
	id ifNil: 	[
		reference exists ifFalse: [FileDoesNotExist signalWith: reference].
		self error: 'Unable to open file ' , reference printString]"
%

category: 'public'
method: FileHandle
size
	
	self flag: 'TODO: remove once FileHandles are really used!'.
	self assureOpen.
	
	^ File sizeOf: id
%

category: 'private'
method: FileHandle
startUp
	"This functionality is disabled for now, to avoid doing lots of processing
	on start up."
	
	"We're starting up in a new OS process, so the file id will be invalid.
	Try to reopen the file, but fail silently: just leave the id as nil. #isOpen will
	answer false, and we'll raise an error if anyone tries to do IO."
	
	self basicOpen
%

category: 'public'
method: FileHandle
streamError
	reference exists
		ifFalse: [FileDoesNotExistException signalWith: reference].
	self error: 'Unable to open file ' , reference printString
%

category: 'public'
method: FileHandle
sync
	
	self flag: 'TODO: remove once FileHandles are really used!'.
	self assureOpen.
	
	File sync: id
%

category: 'public'
method: FileHandle
truncateTo: anInteger
	File setPosition: id to: anInteger.
	File truncate: id to: anInteger.
	self reopen
%

! Class implementation for 'MemoryHandle'

!		Instance methods for 'MemoryHandle'

category: 'public'
method: MemoryHandle
at: index
	^ entry at: index
%

category: 'public'
method: MemoryHandle
at: index put: anObject
	^ entry at: index put: anObject
%

category: 'public'
method: MemoryHandle
at: index read: aCollection startingAt: start count: count 
	^ entry at: index read: aCollection startingAt: start count: count 
%

category: 'public'
method: MemoryHandle
at: first write: aCollection startingAt: start count: count 
	writable ifFalse: [ self error: 'The receiver is not writable' ].
	entry at: first write: aCollection startingAt: start count: count.
%

category: 'streams'
method: MemoryHandle
binaryReadStream

	^ entry binaryReadStream
%

category: 'streams'
method: MemoryHandle
binaryWriteStream
	
	^ entry binaryWriteStream
%

category: 'public'
method: MemoryHandle
close
	self isOpen ifFalse: [ ^ self ].
	self truncate.
	entry := nil.
%

category: 'stream-protocol'
method: MemoryHandle
copyFrom: from to: position
	^ entry copyFrom: from to: position
%

category: 'public'
method: MemoryHandle
flush
	self truncate
%

category: 'private'
method: MemoryHandle
grow
	entry grow
%

category: 'stream-protocol'
method: MemoryHandle
grownBy: length
	entry grownBy: length
%

category: 'testing'
method: MemoryHandle
isOpen
	^ entry notNil
%

category: 'public'
method: MemoryHandle
open
	entry := self basicOpen.
%

category: 'accessing'
method: MemoryHandle
size
	"return the size for the interna"
	^ entry internalSize
%

category: 'public'
method: MemoryHandle
sync
	self flush
%

category: 'public'
method: MemoryHandle
truncate
	entry truncate
%

category: 'public'
method: MemoryHandle
truncateTo: anInteger
	entry truncateTo: anInteger
%

! Class implementation for 'FileSystemPermission'

!		Class methods for 'FileSystemPermission'

category: 'instance creation'
classmethod: FileSystemPermission
default
	^ self posixPermissions: 8r777
%

category: 'instance creation'
classmethod: FileSystemPermission
new 
	self error: 'Should not be called. Use #posixPermission: instead'
%

category: 'instance creation'
classmethod: FileSystemPermission
posixPermissions: aNumber
	^self basicNew 
		initialize: aNumber;
		yourself
%

!		Instance methods for 'FileSystemPermission'

category: 'comparing'
method: FileSystemPermission
< other
	^ posixPermission < other posixPermission
%

category: 'comparing'
method: FileSystemPermission
<= other
	^ (posixPermission > other posixPermission) not
%

category: 'comparing'
method: FileSystemPermission
> other
	^ other posixPermission < posixPermission
%

category: 'comparing'
method: FileSystemPermission
>= other
	^ other posixPermission <= posixPermission
%

category: 'accessing'
method: FileSystemPermission
groupExecute
	^ self permissionBitAt: 4
%

category: 'accessing'
method: FileSystemPermission
groupRead
	^ self permissionBitAt: 6
%

category: 'accessing'
method: FileSystemPermission
groupWrite
	^ self permissionBitAt: 5
%

category: 'initialization'
method: FileSystemPermission
initialize
%

category: 'initialization'
method: FileSystemPermission
initialize: aNumber
	posixPermission := aNumber.
	self initialize.	
%

category: 'testing'
method: FileSystemPermission
isReadable
	^ self ownerRead
%

category: 'testing'
method: FileSystemPermission
isWritable
	^ self ownerWrite
%

category: 'accessing'
method: FileSystemPermission
otherExecute
	^ self permissionBitAt: 1
%

category: 'accessing'
method: FileSystemPermission
otherRead
	^ self permissionBitAt: 3
%

category: 'accessing'
method: FileSystemPermission
otherWrite
	^ self permissionBitAt: 2
%

category: 'accessing'
method: FileSystemPermission
ownerExecute
	^ self permissionBitAt: 7
%

category: 'accessing'
method: FileSystemPermission
ownerRead
	^ self permissionBitAt: 9
%

category: 'accessing'
method: FileSystemPermission
ownerWrite
	^ self permissionBitAt: 8
%

category: 'accessing'
method: FileSystemPermission
permissionBitAt: bitIndex
	^ (posixPermission bitAt: bitIndex) == 1
%

category: 'private'
method: FileSystemPermission
posixPermission
	^ posixPermission
%

category: 'printing'
method: FileSystemPermission
printOn: aStream
	aStream 
		"Owner"
		nextPut: (self ownerRead ifTrue: [ $r ] ifFalse: [ $- ]);
		nextPut: (self ownerWrite ifTrue: [ $w ] ifFalse: [ $- ]);
		nextPut: (self ownerExecute ifTrue: [ $x ] ifFalse: [ $- ]);
		"Group"
		nextPut: (self groupRead ifTrue: [ $r ] ifFalse: [ $- ]);
		nextPut: (self groupWrite ifTrue: [ $w ] ifFalse: [ $- ]);
		nextPut: (self groupExecute ifTrue: [ $x ] ifFalse: [ $- ]);
		"Other"
		nextPut: (self otherRead ifTrue: [ $r ] ifFalse: [ $- ]);
		nextPut: (self otherWrite ifTrue: [ $w ] ifFalse: [ $- ]);
		nextPut: (self otherExecute ifTrue: [ $x ] ifFalse: [ $- ])
		
%

! Class implementation for 'FileSystemResolver'

!		Class methods for 'FileSystemResolver'

category: 'instance creation'
classmethod: FileSystemResolver
new

	^ self basicNew
		initialize;
		yourself
%

!		Instance methods for 'FileSystemResolver'

category: 'accessing'
method: FileSystemResolver
addResolver: aResolver
	next
		ifNil: [next := aResolver]
		ifNotNil: [next addResolver: aResolver]
%

category: 'resolving'
method: FileSystemResolver
canResolve: aSymbol
	^ self supportedOrigins includes: aSymbol
%

category: 'accessing'
method: FileSystemResolver
flushCaches
	self flushLocalCache.
	next ifNotNil: [next flushCaches]
%

category: 'accessing'
method: FileSystemResolver
flushLocalCache
%

category: 'initialization'
method: FileSystemResolver
initialize
%

category: 'accessing'
method: FileSystemResolver
next
	^ next
%

category: 'resolving'
method: FileSystemResolver
resolve: aSymbol
	^ (self canResolve: aSymbol)
		ifTrue: [self perform: aSymbol]
		ifFalse: [self unknownOrigin: aSymbol]
%

category: 'resolving'
method: FileSystemResolver
resolveString: aString
	| decoded fs |
	"The argument string is actually a byte array encoded differently on each platform.
	We are transforming it to an image string.
	We assume for now that the string is utf8 encoded."
	decoded := aString decodeFromUTF8 asString.
	fs := FileSystem disk.
	^ FileReference 
		fileSystem: fs 
		path: (fs pathFromString: decoded)
%

category: 'resolving'
method: FileSystemResolver
supportedOrigins
	^ #()
%

category: 'resolving'
method: FileSystemResolver
unknownOrigin: aSymbol
	^ next ifNotNil: [next resolve: aSymbol]
%

! Class implementation for 'InteractiveResolver'

!		Instance methods for 'InteractiveResolver'

category: 'accessing'
method: InteractiveResolver
flushLocalCache
	cache := IdentityDictionary new
%

category: 'initialization'
method: InteractiveResolver
initialize
	self flushLocalCache
%

category: 'resolving'
method: InteractiveResolver
resolve: origin
	^ cache at: origin ifAbsent: [self unknownOrigin: origin]
	
%

category: 'resolving'
method: InteractiveResolver
unknownOrigin: origin
	| reference |
	^ (next ifNotNil: [next resolve: origin]) ifNil: 
			[reference := ResolutionRequest for: origin.
			reference ifNotNil: [cache at: origin put: reference]]
%

! Class implementation for 'PlatformResolver'

!		Class methods for 'PlatformResolver'

category: 'instance creation'
classmethod: PlatformResolver
forCurrentPlatform
	| platformName |
	platformName :=  System gemVersionAt: 'osName' .
	^ (self allSubclasses detect: [:ea | ea platformName = platformName]) new
%

category: 'accessing'
classmethod: PlatformResolver
platformName
	^ nil
%

!		Instance methods for 'PlatformResolver'

category: 'origins'
method: PlatformResolver
cache
	"Operating Systems often define standard locations for a personal cache directory. The cache directory is a user-specific non-essential (cached) place where data should be written."
	self subclassResponsibility
%

category: 'private'
method: PlatformResolver
cantFindOriginError
	^ Error signal: 'Can''t find the requested origin' 
%

category: 'origins'
method: PlatformResolver
desktop
	^ self subclassResponsibility
%

category: 'private'
method: PlatformResolver
directoryFromEnvVariableNamed: aString
	^ self directoryFromEnvVariableNamed: aString or: [ self cantFindOriginError ]
%

category: 'private'
method: PlatformResolver
directoryFromEnvVariableNamed: aString or: aBlock
	| envValue |
	envValue := [ System gemEnvironmentVariable: aString ]
		on: Error
		do: [ ^ aBlock value ].
	^ envValue isEmptyOrNil
		ifTrue: [ aBlock value ]
		ifFalse: [ self resolveString: envValue ]
%

category: 'origins'
method: PlatformResolver
documents
	^ self subclassResponsibility
%

category: 'origins'
method: PlatformResolver
home
	^ self subclassResponsibility
%

category: 'origins'
method: PlatformResolver
preferences
	^ self subclassResponsibility
%

category: 'resolving'
method: PlatformResolver
supportedOrigins
	^ #(home desktop documents preferences cache temp)
%

category: 'origins'
method: PlatformResolver
temp
	"Where to put files that are not supposed to last long"
	^ self subclassResponsibility 
%

! Class implementation for 'MacOSResolver'

!		Class methods for 'MacOSResolver'

category: 'accessing'
classmethod: MacOSResolver
platformName
	^  'Darwin'
%

!		Instance methods for 'MacOSResolver'

category: 'origins'
method: MacOSResolver
cache
	^ self library / 'Caches'
%

category: 'origins'
method: MacOSResolver
desktop
	^ self home / 'Desktop'
%

category: 'origins'
method: MacOSResolver
documents
	^ self home / 'Documents'
%

category: 'origins'
method: MacOSResolver
home
	^ self directoryFromEnvVariableNamed: 'HOME'
%

category: 'origins'
method: MacOSResolver
library
	^ self userLibrary
%

category: 'origins'
method: MacOSResolver
preferences 
	^ self home / 'Library' / 'Preferences'
%

category: 'resolving'
method: MacOSResolver
supportedOrigins
	^ super supportedOrigins , #(userApplicationSupport systemApplicationSupport systemLibrary userLibrary)
%

category: 'origins'
method: MacOSResolver
systemApplicationSupport
	^ self systemLibrary / 'Application Support'
%

category: 'origins'
method: MacOSResolver
systemLibrary
	^  FileSystem disk root / 'Library'
%

category: 'origins'
method: MacOSResolver
temp
	^ '/tmp' asFileReference
%

category: 'origins'
method: MacOSResolver
userApplicationSupport
	^self userLibrary / 'Application Support'
%

category: 'origins'
method: MacOSResolver
userLibrary
	^  self home / 'Library'
%

! Class implementation for 'UnixResolver'

!		Class methods for 'UnixResolver'

category: 'accessing'
classmethod: UnixResolver
platformName
	^  'Linux'
%

!		Instance methods for 'UnixResolver'

category: 'origins'
method: UnixResolver
cache
	"http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html"

	^ self directoryFromEnvVariableNamed: 'XDG_CACHE_HOME' or: [ self home / '.cache' ]
%

category: 'origins'
method: UnixResolver
desktop
	^ (self xdgUserDir: 'DESKTOP') ifNil: [ self home / 'Desktop' ]
%

category: 'origins'
method: UnixResolver
documents
	^ (self xdgUserDir: 'DOCUMENTS') ifNil: [ self home / 'Documents' ]
%

category: 'origins'
method: UnixResolver
home
	^ self directoryFromEnvVariableNamed: 'HOME'
%

category: 'origins'
method: UnixResolver
preferences
	"http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html"

	^ self directoryFromEnvVariableNamed: 'XDG_CONFIG_HOME' or: [ self home / '.config' ]
%

category: 'resolving'
method: UnixResolver
supportedOrigins
	^ super supportedOrigins , #( userData )
%

category: 'origins'
method: UnixResolver
temp
	^ '/tmp' asFileReference
%

category: 'origins'
method: UnixResolver
userData
	^ self directoryFromEnvVariableNamed: 'XDG_DATA_HOME' or: [ self home / '.local' / 'share' ]
%

category: 'helpers'
method: UnixResolver
xdgParseUserDirLine: aStream
	"Format is XDG_xxx_DIR=""$HOME/yyy"", where yyy is a shell-escaped homedir-relative path, or XDG_xxx_DIR=""/yyy"", where /yyy is an absolute path. No other format is supported."
	| path firstChar |
	(aStream next = $") ifFalse: [ ^ nil ].
	firstChar := aStream next.
	(#($$ $/) includes: firstChar) ifFalse: [ ^ nil ].
	path := firstChar = $$
				ifTrue: [ (aStream next: 5) = 'HOME/' ifFalse: [ ^ nil ].
					       self home / (aStream upTo: $") ]
				ifFalse: [ self resolveString: '/', (aStream upTo: $") ].
	^ path
%

category: 'helpers'
method: UnixResolver
xdgUserDir: userDirName
	"Read ~/.config/user-dirs.dirs to find the directory of userDirName (e.g., 'DESKTOP')"
	"http://freedesktop.org/wiki/Software/xdg-user-dirs"
	"This file is written by xdg-user-dirs-update If you want to change or add directories, just edit the line you're interested in. All local changes will be retained on the next run Format is XDG_xxx_DIR=""$HOME/yyy"", where yyy is a shell-escaped homedir-relative path, or XDG_xxx_DIR=""/yyy"", where /yyy is an absolute path. No other format is supported."
	| configFile |
	configFile := self preferences / 'user-dirs.dirs'.
	(configFile isFile and: [ configFile isReadable ]) ifFalse: [ ^ nil ].
	configFile readStreamDo: [ :stream | 
		[ stream atEnd ]
			whileFalse: [ 
				((stream peek ~= $#) and: [ (stream upTo: $=) = ('XDG_', userDirName, '_DIR') ])
							ifTrue: [ ^ self xdgParseUserDirLine: stream ]
							ifFalse: [ stream nextLine ] ] ].
	^ nil
%

! Class implementation for 'WindowsResolver'

!		Class methods for 'WindowsResolver'

category: 'accessing'
classmethod: WindowsResolver
platformName
	^ 'Win32'
%

!		Instance methods for 'WindowsResolver'

category: 'origins'
method: WindowsResolver
cache
	"Because Windows does not define any location for putting cache files, we chose to use the preference directory. http://libertyboy.free.fr/computing/reference/envariables/"
	^ self preferences
%

category: 'origins'
method: WindowsResolver
desktop
	^ self home / 'Desktop'
%

category: 'origins'
method: WindowsResolver
documents
	^ self home / 'Documents'
%

category: 'origins'
method: WindowsResolver
home
	"Value of the $USERPROFILE environment variable."

	^ self directoryFromEnvVariableNamed: 'USERPROFILE'
%

category: 'origins'
method: WindowsResolver
preferences
	^ self directoryFromEnvVariableNamed: 'APPDATA' or: [ self home ]
%

category: 'origins'
method: WindowsResolver
temp
	^ self directoryFromEnvVariableNamed: 'TEMP' or: [ FileLocator C / 'windows' / 'temp' ]
%

! Class implementation for 'SystemResolver'

!		Class methods for 'SystemResolver'

category: 'accessing'
classmethod: SystemResolver
defaultLocalDirectoryName
	^ 'pharo-local'
%

category: 'accessing'
classmethod: SystemResolver
userLocalDirectory
	^ UserLocalDirectory ifNil: [ 
		(FileLocator imageDirectory / self defaultLocalDirectoryName) resolve  ]
%

category: 'accessing'
classmethod: SystemResolver
userLocalDirectory: aFileReference
	UserLocalDirectory := aFileReference
%

!		Instance methods for 'SystemResolver'

category: 'origins'
method: SystemResolver
dbfScratchDir
	"Answer the path to the DBF_SCRATCH_DIR"

	^ self  resolveString: (System stoneConfigurationReport at: #DBF_SCRATCH_DIR)
%

category: 'origins'
method: SystemResolver
extent1

	^ self _extent: 1
%

category: 'origins'
method: SystemResolver
extent1Directory

	^ self extent1 parent
%

category: 'origins'
method: SystemResolver
gemLogDirectory
	"Answer the path to the gem log directory"

	^ self  resolveString: (System gemLogPath)
%

category: 'origins'
method: SystemResolver
image

	^ self dbfScratchDir
%

category: 'origins'
method: SystemResolver
imageDirectory

	^ self dbfScratchDir
%

category: 'origins'
method: SystemResolver
rowanProjectsHome

	"Answer the path to $ROWAN_PROJECTS_HOME"

	^ (System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME')
		ifNil: [ self error: '$ROWAN_PROJECTS_HOME not defined' ]
		ifNotNil: [:str | self  resolveString: str ]
%

category: 'resolving'
method: SystemResolver
supportedOrigins
	^ #(image imageDirectory extent1 extent1Directory tranlog dbfScratchDir workingDirectory rowanProjectsHome )
%

category: 'origins'
method: SystemResolver
tranlog
	"Answer the path to the current tranlog"

	^ self  resolveString: (System stoneConfigurationReport at: #StnCurrentTranLogNames)
%

category: 'private'
method: SystemResolver
_extent: extentIndex
	"Answer the path to the extent at extentIndex in DBF_EXTENT_NAMES: (System stoneConfigurationReport at: #DBF_EXTENT_NAMES) at: extentIndex"

	| extentNames extentName |
	extentNames := System stoneConfigurationReport at: #DBF_EXTENT_NAMES.
	extentNames _isArray
		ifTrue: [  
			extentIndex > extentNames size ifTrue: [  self error: 'Requested extent index (', extentIndex printString, ') exceeds number of extents present in system (', extentNames size printString, ')'  ].
			extentName := extentNames ]
		ifFalse: [ 
			extentIndex ~= 1 ifTrue: [  self error: 'Requested extent index (', extentIndex printString, ') exceeds number of extents present in system (1)'  ].
			extentName := extentNames ].
	^ self  resolveString: extentName
%

! Class implementation for 'FileSystemStore'

!		Class methods for 'FileSystemStore'

category: 'accessing'
classmethod: FileSystemStore
delimiter
	^ self shouldBeImplemented 
%

category: 'accessing'
classmethod: FileSystemStore
isCaseSensitive
	^ self shouldBeImplemented
%

category: 'instance creation'
classmethod: FileSystemStore
new

	^self basicNew
		initialize;
		yourself
%

category: 'accessing'
classmethod: FileSystemStore
separator
	self shouldBeImplemented
%

!		Instance methods for 'FileSystemStore'

category: 'public'
method: FileSystemStore
basenameFromEntry: aNode
	"Used to extract the basename from the low-level representation (node / entry) from the store."
	self subclassResponsibility
%

category: 'abstract'
method: FileSystemStore
basicCreationTimeOf: aNode
	"Used to decide whether the low-level representation (node / entry) from the store is a readable
	file or a directory whose contents can be listed."
	self subclassResponsibility 
%

category: 'abstract'
method: FileSystemStore
basicEntry: directoryEntry path: aPath nodesDo: aBlock
	self subclassResponsibility 
%

category: 'abstract'
method: FileSystemStore
basicIsDirectory: aNode
	"Used to decide whether the low-level representation (node / entry) from the store is a directory.
	This private message should only be called form within the store."
	self subclassResponsibility 
%

category: 'abstract'
method: FileSystemStore
basicIsFile: aNode
	"Used to decide whether the low-level representation (node / entry) from the store is a file.
	This private message should only be called form within the store."
	self subclassResponsibility 
%

category: 'abstract'
method: FileSystemStore
basicIsSymlink: aNode
	^self subclassResponsibility 
	
%

category: 'abstract'
method: FileSystemStore
basicIsWritable: aNode
	"Used to decide whether the low-level representation (node / entry) from the store is 
	a writable file or can be changed."
	self subclassResponsibility 
%

category: 'abstract'
method: FileSystemStore
basicModificationTime: aNode
	"Used to decide whether the low-level representation (node / entry) from the store is a readable
	file or a directory whose contents can be listed."
	self subclassResponsibility 
%

category: 'error signalling'
method: FileSystemStore
basicOpen: aPath writable: aBoolean
	"open the file at the given path and return an identifier"
	self subclassResponsibility
%

category: 'abstract'
method: FileSystemStore
basicPosixPermissions: aNode
	"Used to get the posix permissions from a low-level filesystem entry / node"
	self subclassResponsibility 
%

category: 'abstract'
method: FileSystemStore
basicSizeOf: aNode
	"Used to get the size of the low-level representation (node / entry) "
	self subclassResponsibility 
%

category: 'public'
method: FileSystemStore
checkName: aString fixErrors: fixErrors
	^ self subclassResponsibility
%

category: 'abstract'
method: FileSystemStore
close
	"Some kinds of filesystems need to open connections to external resources"
%

category: 'private'
method: FileSystemStore
copy: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock fileSystem: aFilesystem

	| buffer out in |
	
	in := nil.
	out := nil.
	buffer := nil.
	[
		in := aFilesystem binaryReadStreamOn: sourcePath.
		in ifNil: [ ^ absentBlock value ].
		
		(self exists: destinationPath)
			ifTrue: [ "cannot overwrite destination"
				^ presentBlock value ].
			
		out := aFilesystem binaryWriteStreamOn: destinationPath.
		buffer := ByteArray new: 1024.
		
		[ in atEnd ]
			whileFalse: [ 
				buffer := in nextInto: buffer.
				out nextPutAll: buffer ]]
	ensure: [ 
		in ifNotNil: [ in close ].
		out ifNotNil: [ out close ]]
%

category: 'abstract'
method: FileSystemStore
createDirectory: aPath
	self subclassResponsibility 
%

category: 'public'
method: FileSystemStore
creationTimeOf: aPath
	"Return the date of creation of the File described by aPath"
	^ self 
		nodeAt: aPath 
		ifPresent: [ :entry | self basicCreationTimeOf: entry ] 
		ifAbsent: [ self signalFileDoesNotExist: aPath ].
	
%

category: 'accessing'
method: FileSystemStore
defaultWorkingDirectory
	^ Path root
%

category: 'abstract'
method: FileSystemStore
delete: aPath
	self subclassResponsibility 
%

category: 'accessing'
method: FileSystemStore
delimiter
	^ self class delimiter
%

category: 'public'
method: FileSystemStore
directoryAt: aPath ifAbsent: absentBlock directoryNodesDo: aBlock
	^ self 
		directoryAt: aPath 
		ifAbsent: absentBlock 
		nodesDo: [ :entry|
			(self basicIsDirectory: entry) 
				ifTrue: [ aBlock value: entry ]].
%

category: 'public'
method: FileSystemStore
directoryAt: aPath ifAbsent: absentBlock fileNodesDo: aBlock
	^ self 
		directoryAt: aPath 
		ifAbsent: absentBlock 
		nodesDo: [ :entry|
			(self basicIsDirectory: entry) 
				ifFalse: [ aBlock value: entry ]].
%

category: 'public'
method: FileSystemStore
directoryAt: aPath ifAbsent: absentBlock nodesDo: aBlock
	^ self
		nodeAt: aPath
		ifPresent: [ :entry | 
			(self basicIsDirectory: entry)
				ifTrue: [ self basicEntry: entry path: aPath nodesDo: aBlock ]
				ifFalse: [ DirectoryDoesNotExist signalWith: aPath ] ]
		ifAbsent: absentBlock
%

category: 'public'
method: FileSystemStore
ensureCreateDirectory: aPath
	(self isDirectory: aPath) ifTrue: [ ^ self ].
	self ensureCreateDirectory: aPath parent.
	self createDirectory: aPath
%

category: 'private'
method: FileSystemStore
entryFromNode: aNode fileSystem: aFilesystem path: aPath
	^ FileSystemDirectoryEntry
		fileSystem: aFilesystem
		path: aPath
		creation: (self basicCreationTimeOf: aNode)
		modification:(self basicModificationTimeOf: aNode)
		isDir: (self basicIsDirectory: aNode)
		size: (self basicSizeOf: aNode)
		posixPermissions: (self basicPosixPermissions: aNode)
		isSymlink: (self basicIsSymlink: aNode)
%

category: 'public'
method: FileSystemStore
entryFromNode: node path: path for: aFileystem
	| entryPath |
	entryPath := path / (self basenameFromEntry: node).
	^ self entryFromNode: node fileSystem: aFileystem path: entryPath
%

category: 'public'
method: FileSystemStore
exists: aPath
	self 
		nodeAt: aPath 
		ifPresent: [ :entry | ^ true ] 
		ifAbsent: [ ^ false ].
	
%

category: 'private'
method: FileSystemStore
filename: aByteString matches: aByteString2
	^ aByteString = aByteString2
%

category: 'initialization'
method: FileSystemStore
initialize
%

category: 'accessing'
method: FileSystemStore
isCaseSensitive
	^ self class isCaseSensitive
%

category: 'public'
method: FileSystemStore
isDirectory: aPath
	aPath isRoot ifTrue: [ ^ true ].
	self 
		nodeAt: aPath 
		ifPresent: [ :entry | ^ self basicIsDirectory: entry ] 
		ifAbsent: [ ^ false ].
	
%

category: 'public'
method: FileSystemStore
isFile: aPath
	"slow solution for big directories! "
	^ self 
		nodeAt: aPath 
		ifPresent: [ :entry | ^ self basicIsFile: entry ] 
		ifAbsent: [ ^ false ]
	
%

category: 'public'
method: FileSystemStore
isSymlink: aPath
	aPath isRoot ifTrue: [ ^ true ].
	self 
		nodeAt: aPath 
		ifPresent: [ :entry | ^ self basicIsSymlink: entry ] 
		ifAbsent: [ ^ false ].
	
%

category: 'public'
method: FileSystemStore
isWritable: aPath
	self nodeAt: aPath 
		ifPresent: [ :entry | ^ self basicIsWritable: entry ] 
		ifAbsent: [ ^ false ].
	
%

category: 'public'
method: FileSystemStore
modificationTimeOf: aPath
	"Returns the last date of modification of the File described by aPath"
	^ self 
		nodeAt: aPath 
		ifPresent: [ :entry | self basicModificationTimeOf: entry ] 
		ifAbsent: [ self signalFileDoesNotExist: aPath ].
	
%

category: 'public'
method: FileSystemStore
nodeAt: aPath
	^ self 
		nodeAt: aPath 
		ifPresent: [ :node| node ]
		ifAbsent: [ self error: 'the node ', aPath printString, ' not found.' ]
%

category: 'abstract'
method: FileSystemStore
nodeAt: aPath ifPresent: presentBlock ifAbsent: absentBlock
	self subclassResponsibility 
%

category: 'abstract'
method: FileSystemStore
open
	"Some kinds of filesystems need to open connections to external resources"
%

category: 'public'
method: FileSystemStore
openFileStream: path writable: writable
	self subclassResponsibility
%

category: 'converting'
method: FileSystemStore
pathFromString: aString
	"Use the unix convention by default, since many filesystems are based on it."
	
	^ Path from: aString delimiter: self delimiter
%

category: 'public'
method: FileSystemStore
permissions: aPath
	self nodeAt: aPath 
		ifPresent: [ :entry | ^ FileSystemPermission posixPermissions: (self basicPosixPermissions: entry) ] 
		ifAbsent: [ ^ FileSystemPermission default ].
	
%

category: 'converting'
method: FileSystemStore
printPath: aPath on: out
	"Use the unix convention by default, since it's the most common."
	
	aPath isAbsolute ifTrue: [ out nextPut: self delimiter ].
	^ aPath printOn: out delimiter: self delimiter
%

category: 'private'
method: FileSystemStore
rename: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock fileSystem: anFSFilesystem

	| result |
	(self exists: destinationPath) ifTrue: [ ^ presentBlock value ].
	(self exists: sourcePath) ifFalse: [ ^ absentBlock value ].
	result := self rename: sourcePath to: destinationPath.
	result ifNil: [ self  error: 'Could not rename ',  sourcePath pathString, ' to ', destinationPath pathString ].
	^ self.
%

category: 'abstract'
method: FileSystemStore
rename: sourcePath to: destinationPath
	self subclassResponsibility 
%

category: 'accessing'
method: FileSystemStore
separator
	^ self class separator
%

category: 'error signalling'
method: FileSystemStore
signalDirectoryDoesNotExist: aPath
	^ DirectoryDoesNotExist signalWith: aPath
%

category: 'error signalling'
method: FileSystemStore
signalDirectoryExists: aPath
	^ DirectoryExists signalWith: aPath
%

category: 'error signalling'
method: FileSystemStore
signalFileDoesNotExist: aPath
	^ FileDoesNotExistException
		signalWithFile: (File named: aPath asPath pathString)
		writeMode: false
%

category: 'error signalling'
method: FileSystemStore
signalFileExists: aPath
	^ FileExists signalWith: aPath
%

category: 'public'
method: FileSystemStore
sizeOf: aPath
	"Return the size of the File described by aPath"
	^ self 
		nodeAt: aPath 
		ifPresent: [ :entry | self basicSizeOf: entry ] 
		ifAbsent: [ self signalFileDoesNotExist: aPath ]
	
%

category: 'converting'
method: FileSystemStore
stringFromPath: aPath
	^ String streamContents: [ :out | 
		self printPath: aPath on: out ]
%

! Class implementation for 'DiskStore'

!		Class methods for 'DiskStore'

category: 'current'
classmethod: DiskStore
activeClass
	self allSubclasses do: [:ea | 
		ea isActiveClass ifTrue: [^ ea]].
  "Various methods go into infinite recursion if we return self."
	Error signal:'Cannot find an active subclass of DiskStore' .
%

category: 'current'
classmethod: DiskStore
createDefault
	^ self new
%

category: 'current'
classmethod: DiskStore
current
	^ self currentFileSystem store
%

category: 'current'
classmethod: DiskStore
currentFileSystem
	^ CurrentFS ifNil: [
		CurrentFS := FileSystem store: self activeClass createDefault]
%

category: 'accessing'
classmethod: DiskStore
defaultWorkingDirectory
	"Ask the VM for the default working directory.
	Clients should normally use the instance side method which caches this value."
	| pathString |

	pathString := (GsFile _expandEnvVariable: 'PWD' isClient:false).
	^(Path from: pathString delimiter: self delimiter).
%

category: 'public'
classmethod: DiskStore
delimiter
	^ self current delimiter
%

category: 'current'
classmethod: DiskStore
isActiveClass
	^ self delimiter = File delimiter
%

category: 'public'
classmethod: DiskStore
maxFileNameLength
	self subclassResponsibility 
%

category: 'current'
classmethod: DiskStore
reset
	DefaultWorkingDirectory := nil.
	CurrentFS := nil
%

category: 'system startup'
classmethod: DiskStore
shutDown: quitting
	"Force to detect filesystem after image restart"
	self reset
%

category: 'system startup'
classmethod: DiskStore
startUp: resuming
	resuming 
		ifTrue: [ self reset ].
	DefaultWorkingDirectory := self defaultWorkingDirectory.
%

!		Instance methods for 'DiskStore'

category: 'comparing'
method: DiskStore
= other
	^ self species = other species
%

category: 'private'
method: DiskStore
basenameFromEntry: entry
	^ entry at: 1
%

category: 'private'
method: DiskStore
basicCreationTimeOf: anEntry
	" the entry contains the seconds since the squeak epoch in local time"

	"this method should be reimplemented with the new file system code"

	| dt offset |
	offset := Duration seconds: 0.
	dt := DateAndTime posixSeconds: (anEntry at: 2) offset: offset.
	offset := Duration
		seconds: (dt currentTimeZone transitionAtUTC: dt) offsetFromUTC.
	^ DateAndTime posixSeconds: (anEntry at: 2) offset: offset	"SmallDateAndTime prevents changing the offset, so create a new instance, as suggesed"
%

category: 'private'
method: DiskStore
basicEntry: ignored path: aPath nodesDo: aBlock
	| pathString intOrArray |
	pathString := self stringFromPath: aPath.
	intOrArray := GsFile _contentsOfServerDirectory: pathString expandPath: true.
	intOrArray _isArray ifFalse: [ ^ self signalDirectoryDoesNotExist: aPath ].
	intOrArray
		do: [:entryPathString |
			((entryPathString endsWith: '.')  or: [ entryPathString endsWith: '..' ])
				ifFalse: [ | aFile |
          aFile := File lookupPath: entryPathString .
          "For now, ignore symLinks which reference a non-existant file."
          aFile ifNil:[ 
             (GsFile isSymbolicLink: entryPathString onClient: false) ifFalse:[
                self signalFileDoesNotExist: entryPathString 
             ]
          ] ifNotNil:[
            aBlock value: aFile 
          ]]]
%

category: 'public'
method: DiskStore
basicEntryAt: aPath
	| path basename |
	
	path := self stringFromPath: aPath parent.
	basename := aPath basename.
	
	^ (File lookupDirectory: path filename: basename)
		ifNil: [ #badDirectoryPath ].
%

category: 'private'
method: DiskStore
basicIsDirectory: anEntry
	^ anEntry at: 4
%

category: 'private'
method: DiskStore
basicIsFile: anEntry
	^ (anEntry at: 4) not
%

category: 'private'
method: DiskStore
basicIsSymlink: anEntry
	^(anEntry size >= 7)
		ifTrue: [ anEntry at: 7 ]
		ifFalse: [ false ]
%

category: 'private'
method: DiskStore
basicModificationTimeOf: anEntry
	" the entry contains the seconds since the squeak epoch in local time"

	| dt offset |
	offset := Duration seconds: 0.
	dt := DateAndTime posixSeconds: (anEntry at: 3) offset: offset.
	offset := Duration
		seconds: (dt currentTimeZone transitionAtUTC: dt) offsetFromUTC.
	^ DateAndTime posixSeconds: (anEntry at: 3) offset: offset
%

category: 'public'
method: DiskStore
basicOpen: aPath writable: writeMode

	"writeMode - #read, #append, #write"

	| string |
	string := self stringFromPath: aPath.
	^ File open: string writable: writeMode
%

category: 'private'
method: DiskStore
basicPosixPermissions: anEntry
	^ (anEntry size >= 6)
		ifTrue: [ anEntry at: 6 ]
		ifFalse: [ nil ].
%

category: 'private'
method: DiskStore
basicSizeOf: anEntry
	^ (anEntry at: 5)
%

category: 'public'
method: DiskStore
checkName: aFileName fixErrors: fixErrors
	"Check a string aFileName for validity as a file name. Answer the original file name if it is valid. If the name is not valid (e.g., it is too long or contains illegal characters) and fixing is false, raise an error. If fixing is true, fix the name (usually by truncating and/or tranforming characters), and answer the corrected name. The default behavior is just to truncate the name to the maximum length for this platform. Subclasses can do any kind of checking and correction appropriate for their platform."
	
	| maxLength |
	aFileName size = 0 ifTrue: [self error: 'zero length file name'].
	maxLength := self maxFileNameLength.
	aFileName size > maxLength ifTrue: [
		fixErrors
			ifTrue: [^ aFileName contractTo: maxLength]
			ifFalse: [self error: 'file name is too long']].
	^ aFileName
%

category: 'public'
method: DiskStore
createDirectory: path
	"Create a directory for the argument path. 
	If the path refers to an existing file, raise FileExists.
	If the path refers to an existing directory, raise DirectoryExists.
	If the parent directory of the path does not exist, raise DirectoryDoesNotExist"

	| parent pathString result |
	pathString := self stringFromPath: path.
	result := File createDirectory: pathString.
	result
		ifNil: [ 
			parent := path parent.
			(self exists: path)
				ifTrue: [ 
					(self isFile: path)
						ifTrue: [ self signalFileExists: path ]
						ifFalse: [ self signalDirectoryExists: path ] ].
			(self isDirectory: parent)
				ifFalse: [ ^ self signalDirectoryDoesNotExist: parent ].
			self error: 'Could not create the directory ',  pathString ].
	^ self
%

category: 'accessing'
method: DiskStore
defaultWorkingDirectory
	"Answer the default working directory, which is defined as the directory where the image resides."

	^ DefaultWorkingDirectory
		ifNil: [ self class defaultWorkingDirectory ]
%

category: 'public'
method: DiskStore
delete: path
	| pathString |
	
	(self exists: path)
		ifFalse: [ ^ FileDoesNotExistException signalWith: path ].
		
	pathString := self stringFromPath: path.
	
	(self isDirectory: path)
		ifTrue: [ File deleteDirectory: pathString ]
		ifFalse: [ 
			(File named: pathString) delete ]
%

category: 'printing'
method: DiskStore
forReferencePrintOn: aStream
	aStream nextPutAll: 'File @ '
%

category: 'accessing'
method: DiskStore
handleClass
	^ FileHandle
%

category: 'comparing'
method: DiskStore
hash
	^ self species hash
%

category: 'initialization'
method: DiskStore
initialize
	super initialize.
	maxFileNameLength := 255.
%

category: 'public'
method: DiskStore
isDirectory: aPath
	| entry |
	
	aPath isRoot ifTrue: [ ^ true ].
	
	entry := self  basicEntryAt: aPath.
	
	^ entry == #badDirectoryPath 
		ifTrue: [  false ]
		ifFalse: [ self basicIsDirectory: entry ].
	
%

category: 'testing'
method: DiskStore
isDiskFileSystem
	^ true
%

category: 'public'
method: DiskStore
isFile: aPath
	| entry |
	
	aPath isRoot ifTrue: [ ^ false ].
	
	entry := self  basicEntryAt: aPath.
	
	^ entry == #badDirectoryPath 
		ifTrue: [  false ]
		ifFalse: [ self basicIsFile: entry ].
	
%

category: 'public'
method: DiskStore
isReadable: aPath
	(self exists: aPath) ifFalse: [ ^ false ].
	self flag: 'TODO: we need a decent primitive for this...'.
	(self basicOpen: aPath writable: #read) 
		ifNotNil: [ :id|
			File close: id.
			^ true].
	^ false
%

category: 'public'
method: DiskStore
isSymlink: aPath
	| entry |
	
	aPath isRoot ifTrue: [ ^false ].
	
	entry := self  basicEntryAt: aPath.
	
	^ entry == #badDirectoryPath 
		ifTrue: [  false ]
		ifFalse: [ self basicIsSymlink: entry ].
	
%

category: 'public'
method: DiskStore
isWritable: aPath
	(self exists: aPath) ifFalse: [ ^ false ].
	self flag: 'TODO: we need a decent primitive for this...'.
	(self basicOpen: aPath writable: #write) 
		ifNotNil: [ :id|
			File close: id.
			^ true].
	^ false
%

category: 'public'
method: DiskStore
maxFileNameLength
	^ maxFileNameLength
%

category: 'private'
method: DiskStore
nodeAt: aPath ifPresent: presentBlock ifAbsent: absentBlock
	
	| entry |
	
	aPath isRoot ifTrue: [ ^ presentBlock value: self rootNode ].
	
	entry := self basicEntryAt: aPath.
	
	^ entry == #badDirectoryPath 
		ifTrue: absentBlock
		ifFalse: [
			entry at: 1 put: aPath basename.
			presentBlock value: entry ].
%

category: 'public'
method: DiskStore
openFileStream: path writable: writable
	| fullPath |
	fullPath := self stringFromPath: path.
	"redirect over the default implementation"
	^ writable 
		ifFalse: [ FileStreamPortable readOnlyFileNamed: fullPath ]
		ifTrue: [ FileStreamPortable fileNamed: fullPath ]
%

category: 'public'
method: DiskStore
rename: sourcePath to: destinationPath

	| sourcePathString targetPathString |
	sourcePathString := self stringFromPath: sourcePath.
	targetPathString := self stringFromPath: destinationPath.
	^ File rename: sourcePathString to: targetPathString.
%

category: 'private'
method: DiskStore
rootNode
	^ #('' 0 0 true 0 8r555)
%

! Class implementation for 'UnixStore'

!		Class methods for 'UnixStore'

category: 'public'
classmethod: UnixStore
delimiter
	^ $/
%

category: 'current'
classmethod: UnixStore
isActiveClass
  | osNam |
  osNam := System gemVersionAt: 'osName'.
  ^ (#( 'Linux' 'Darwin' 'SunOS' 'AIX') includes: osNam) and:[ super isActiveClass ]
%

category: 'public'
classmethod: UnixStore
isCaseSensitive

	^ true
%

category: 'public'
classmethod: UnixStore
maxFileNameLength

	^ 255
%

category: 'public'
classmethod: UnixStore
separator 
	^ $:
%

!		Instance methods for 'UnixStore'

category: 'public'
method: UnixStore
checkName: aFileName fixErrors: fixing
	"Check if the file name contains any invalid characters"
	| fName |
	fName := super checkName: aFileName fixErrors: fixing.
	
	(fName includes: self delimiter) ifFalse:
		[^fName].
	
	fixing ifFalse: [self error:'Invalid file name'].
	
	^ fName copyReplaceAll: self delimiter asString with: '#'
%

! Class implementation for 'MacStore'

!		Class methods for 'MacStore'

category: 'current'
classmethod: MacStore
isActiveClass
	^ ((System gemVersionAt: 'osName') = 'Darwin') and: [ super isActiveClass ]
%

category: 'public'
classmethod: MacStore
isCaseSensitive

	^ true
%

! Class implementation for 'WindowsStore'

!		Class methods for 'WindowsStore'

category: 'accessing'
classmethod: WindowsStore
delimiter
	^ $\
%

category: 'accessing'
classmethod: WindowsStore
isCaseSensitive
	^ false
%

category: 'accessing'
classmethod: WindowsStore
maxFileNameLength
	self flag: 'TODO: more tests needed here!'.
	^ 255
%

category: 'accessing'
classmethod: WindowsStore
separator 
	^ $\
%

!		Instance methods for 'WindowsStore'

category: 'public'
method: WindowsStore
checkName: aFileName fixErrors: fixing
	"Check if the file name contains any invalid characters"
	
	| fName badChars |
	fName := super checkName: aFileName fixErrors: fixing.
	badChars := (#( $: $< $> $| $/ $\ $? $* $"), ((0 to: 31) collect: [:n | n asCharacter])) asSet.
	
	(fName includesAnyOf: badChars)
		ifFalse: [^ fName].
	
	fixing ifFalse: [^self error: 'filename contains invalid characters'].
	
	^ fName collect:
		[:char | (badChars includes: char) 
				ifTrue: [$#] 
				ifFalse: [char]]
%

category: 'converting'
method: WindowsStore
currentDisk
	^ disk ifNil: [  disk := FileSystem workingDirectory path segments first ]
%

category: 'converting'
method: WindowsStore
pathFromString: aString
	"Need to distinguish '' and '/' , so tag latter with invalid character ':'  "
	| normalized pathClass pathElements |
	normalized := aString copy replaceAll: UnixStore delimiter with: self delimiter.
	pathElements := self delimiter split: normalized.
	pathClass := (Path isAbsoluteWindowsPath: normalized)
		ifTrue: [ (normalized = self delimiter asString) ifTrue: [ pathElements := { ':' } ].
			AbsolutePath ]
		ifFalse: [ self stripDrive: pathElements.
			RelativePath ].
	^pathClass withAll: pathElements
%

category: 'converting'
method: WindowsStore
printPath: aPath on: aStream
	| hasDrive |
	aPath isRoot
		ifTrue: [ ^ self ].	"effectively Windows root is empty string"
	aPath isWorkingDirectory
		ifTrue: [ ^ aPath printOn: aStream delimiter: self delimiter ].
	aPath isRelative
		ifTrue: [ ^ aPath printOn: aStream delimiter: self delimiter ].
	aPath segments first first = $:
		ifTrue: [ ^ aStream nextPut: self delimiter ].	"as tagged in #pathFromString:  "
	hasDrive := aPath segments first second = $:.
	(hasDrive not )
		ifTrue: [ aStream nextPut: self delimiter ].
	aPath printOn: aStream delimiter: self delimiter.
	(hasDrive and: [ aPath segments size = 1 ])
		ifTrue: [ aStream nextPut: self delimiter ]
%

category: 'converting'
method: WindowsStore
stripDrive: pathElements
	pathElements ifNotEmpty: [ pathElements at: 1 put: ( ($: split: pathElements first) last)  ]
%

! Class implementation for 'MemoryStore'

!		Class methods for 'MemoryStore'

category: 'current'
classmethod: MemoryStore
currentFileSystem
	^ CurrentFS ifNil: [ CurrentFS := FileSystem store: MemoryStore new ]
%

category: 'public'
classmethod: MemoryStore
delimiter
	^ $/
%

category: 'public'
classmethod: MemoryStore
isCaseSensitive
	^ true
%

category: 'class initialization'
classmethod: MemoryStore
reset
	CurrentFS := nil
%

category: 'public'
classmethod: MemoryStore
separator 
	^ $:
%

category: 'system startup'
classmethod: MemoryStore
startUp
	self reset
%

!		Instance methods for 'MemoryStore'

category: 'public'
method: MemoryStore
basenameFromEntry: aMemoryFileSystemEntry
	^ aMemoryFileSystemEntry basename
%

category: 'private'
method: MemoryStore
basicCreationTimeOf: aMemoryFileSystemEntry
	"Returns the creation date of aMemoryFileSystemEntry"
	^ aMemoryFileSystemEntry creationTime
%

category: 'private'
method: MemoryStore
basicEntry: entry nodesDo: aBlock
	entry fileEntriesDo: aBlock
%

category: 'private'
method: MemoryStore
basicEntry: directoryEntry path: aPath nodesDo: aBlock
	directoryEntry fileEntriesDo: aBlock
%

category: 'private'
method: MemoryStore
basicIsDirectory: aMemoryFileSystemEntry
	^ aMemoryFileSystemEntry isDirectory
%

category: 'private'
method: MemoryStore
basicIsFile: aMemoryFileSystemEntry
	^ aMemoryFileSystemEntry isFile
%

category: 'private'
method: MemoryStore
basicIsSymlink: aNode
	^false
%

category: 'private'
method: MemoryStore
basicModificationTimeOf: aMemoryFileSystemEntry
	"Return the basic modification time of aMemoryFileSystemEntry"
	^ aMemoryFileSystemEntry modificationTime
%

category: 'private'
method: MemoryStore
basicOpen: path writable: writeMode
	^ self
		nodeAt: path
		ifPresent: [ :aMemoryFileSystemEntry | 
			aMemoryFileSystemEntry
				basicOpen;
				yourself ]
		ifAbsent: [ writeMode == #write
				ifFalse: [ self signalFileDoesNotExist: path ]
				ifTrue: [ self createFile: path ] ]
%

category: 'private'
method: MemoryStore
basicPosixPermissions: anEntry
	^ 8r777
%

category: 'private'
method: MemoryStore
basicSizeOf: aMemoryFileSystemEntry
	"Return the basic size of aMemoryFileSystemEntry"
	^ aMemoryFileSystemEntry fileSize
%

category: 'public'
method: MemoryStore
checkName: aString fixErrors: fixErrors
	aString ifEmpty: [ self error: 'zero length file name' ].
	^ aString
%

category: 'private'
method: MemoryStore
copy: sourcePath ifAbsent: absentBlock to: destinationPath ifPresent: presentBlock fileSystem: aFilesystem
        | sourceNode destinationNode |

        sourceNode := self
                nodeAt: sourcePath
                ifPresent: [ :source | source ]
                ifAbsent: [ ^ absentBlock value].

        sourceNode isDirectory
                ifTrue: [ ^ absentBlock value ].

        destinationNode := self
                nodeAt: destinationPath parent
                ifPresent: [ :destination |  destination ]
                ifAbsent: [ ^ self signalDirectoryDoesNotExist: destinationPath parent ].

        destinationNode isFile
                ifTrue: [ self signalDirectoryDoesNotExist: destinationPath parent ].

        (destinationNode fileEntriesIncludes: destinationPath basename)
                ifTrue: [ "cannot overwrite existing file"^ presentBlock value ].

        destinationNode
                fileEntryAt: destinationPath basename
                put: (sourceNode copy
                                        basename: destinationPath basename;
                                        yourself)
%

category: 'public'
method: MemoryStore
createDirectory: path
	| parent |
	parent := path parent.
	^ self
		nodeAt: parent
		ifPresent: [ :entry | 
			entry
				fileEntryAt: path basename
				ifPresent: [ :node | 
					node isDirectory
						ifTrue: [ self signalDirectoryExists: path ]
						ifFalse: [ self signalFileExists: path ] ].
			entry ensureCreateDirectory: path basename  ]
		ifAbsent: [ self signalDirectoryDoesNotExist: parent ]
%

category: 'private'
method: MemoryStore
createFile: aPath
	^ self
		nodeAt: aPath parent
		ifPresent: [ :entry | 
			entry isDirectory
				ifTrue: [ entry ensureCreateFile: aPath basename ]]
		ifAbsent: [ self signalDirectoryDoesNotExist: aPath parent ]
%

category: 'public'
method: MemoryStore
delete: path
	self 
		nodeAt: path parent
		ifPresent: [ :dict | 
			dict fileEntryRemove: path basename ifAbsent: [ FileDoesNotExistException signalWith: path ]] 
		ifAbsent: [ DirectoryDoesNotExist signalWith: path parent ]
%

category: 'printing'
method: MemoryStore
forReferencePrintOn: aStream
	aStream nextPutAll: 'memory://'
%

category: 'accessing'
method: MemoryStore
handleClass
	^ MemoryHandle 
%

category: 'initialization'
method: MemoryStore
initialize 
	root := MemoryFileSystemDirectory new
%

category: 'testing'
method: MemoryStore
isMemoryFileSystem
	^ true
%

category: 'private'
method: MemoryStore
nodeAt: aPath ifPresent: presentBlock ifAbsent: absentBlock
	| current |
	aPath isRoot
		ifTrue: [ ^ presentBlock value: self root ].
	current := self root.
	aPath
		do: [ :segment | 
			current isDirectory
				ifTrue: [ current := current fileEntryAt: segment ifAbsent: [ ^ absentBlock value ] ]
				ifFalse: [ ^ absentBlock value ] ].
	^ presentBlock value: current
%

category: 'public'
method: MemoryStore
openFileStream: path writable: writeMode

	"writeMode - #read, #append, #write"

	| entry |
	entry := self basicOpen: path writable: writeMode.
	^ writeMode == #write
		ifTrue: [ entry writeStream ]
		ifFalse: [ entry readStreamPortable ]
%

category: 'public'
method: MemoryStore
rename: sourcePath to: destinationPath
	| sourceEntry destinationParentEntry newName |
	
	sourceEntry := self nodeAt: sourcePath.
	newName := destinationPath basename.
	
	destinationParentEntry := self nodeAt: destinationPath parent.
	
	destinationParentEntry isDirectory
		ifFalse: [ Error signal: 'Copy destination has to be a directory' ].
	destinationParentEntry 
		fileEntryAt: newName
		ifPresent: [ Error signal: 'Destination file exists already' ].
		
	destinationParentEntry 
		fileEntryAt: newName
		put: sourceEntry.
	sourceEntry basename: newName.
	
	
	(self nodeAt: sourcePath parent)
		fileEntryRemove: sourcePath basename 
	
%

category: 'private'
method: MemoryStore
replaceFile: path in: aBlock
	^ self
		nodeAt: path parent
		ifPresent: [ :entry | | old new |
			entry isDirectory
				ifFalse: [ self signalFileDoesNotExist: path ].
			old := entry fileEntryAt: path basename ifAbsent: [ self signalFileDoesNotExist: path ].
			new := aBlock value: old.
			entry fileEntryAt: path basename put: new ]
		ifAbsent: [ self signalFileDoesNotExist: path ]
%

category: 'accessing'
method: MemoryStore
root
	^ root
%

! Class implementation for 'FileSystemVisitor'

!		Instance methods for 'FileSystemVisitor'

category: 'initialization'
method: FileSystemVisitor
initialize
%

category: 'visiting'
method: FileSystemVisitor
visitDirectory: aReference
	^ self visitReference: aReference
%

category: 'visiting'
method: FileSystemVisitor
visitFile: aReference
	^ self visitReference: aReference
%

category: 'visiting'
method: FileSystemVisitor
visitReference: aReference
%

! Class implementation for 'AbstractEnumerationVisitor'

!		Instance methods for 'AbstractEnumerationVisitor'

category: 'visiting'
method: AbstractEnumerationVisitor
breadthFirst: aReference
	^ self visit: aReference with: (BreadthFirstGuide for: self)
%

category: 'initialization'
method: AbstractEnumerationVisitor
initializeWithBlock: aBlock
	self initialize.
	block := aBlock
%

category: 'visiting'
method: AbstractEnumerationVisitor
postorder: aReference
	^ self visit: aReference with: (PostorderGuide for: self)
%

category: 'visiting'
method: AbstractEnumerationVisitor
preorder: aReference
	^ self visit: aReference with: (PreorderGuide for: self)
%

category: 'visiting'
method: AbstractEnumerationVisitor
visit: aReference with: aGuide
	out := (Array new: 10) writeStreamPortable.
	aGuide show: aReference.
	^ out contents
%

category: 'visiting'
method: AbstractEnumerationVisitor
visitReference: anEntry
	self subclassResponsibility
%

! Class implementation for 'CollectVisitor'

!		Class methods for 'CollectVisitor'

category: 'instance creation'
classmethod: CollectVisitor
breadthFirst: aReference
	^ self breadthFirst: aReference collect: [:entry | entry]
%

category: 'instance creation'
classmethod: CollectVisitor
breadthFirst: aReference collect: aBlock
	^ (self collect: aBlock) breadthFirst: aReference
%

category: 'instance creation'
classmethod: CollectVisitor
collect: aBlock
	^ self basicNew initializeWithBlock: aBlock
%

category: 'instance creation'
classmethod: CollectVisitor
postorder: aReference
	^ self postorder: aReference collect: [:entry | entry]
%

category: 'instance creation'
classmethod: CollectVisitor
postorder: aReference collect: aBlock
	^ (self collect: aBlock) postorder: aReference
%

category: 'instance creation'
classmethod: CollectVisitor
preorder: aReference
	^ self preorder: aReference collect: [:entry | entry]
%

category: 'instance creation'
classmethod: CollectVisitor
preorder: aReference collect: aBlock
	^ (self collect: aBlock) preorder: aReference
%

!		Instance methods for 'CollectVisitor'

category: 'visiting'
method: CollectVisitor
visitReference: anEntry
	out nextPut: (block value: anEntry)
%

! Class implementation for 'SelectVisitor'

!		Class methods for 'SelectVisitor'

category: 'instance creation'
classmethod: SelectVisitor
breadthFirst: aReference
	^ self breadthFirst: aReference select: [:entry | true]
%

category: 'instance creation'
classmethod: SelectVisitor
breadthFirst: aReference select: aBlock
	^ (self select: aBlock) breadthFirst: aReference
%

category: 'instance creation'
classmethod: SelectVisitor
postorder: aReference
	^ self postorder: aReference select: [:entry | true]
%

category: 'instance creation'
classmethod: SelectVisitor
postorder: aReference select: aBlock
	^ (self select: aBlock) postorder: aReference
%

category: 'instance creation'
classmethod: SelectVisitor
preorder: aReference
	^ self preorder: aReference select: [:entry | true]
%

category: 'instance creation'
classmethod: SelectVisitor
preorder: aReference select: aBlock
	^ (self select: aBlock) preorder: aReference
%

category: 'instance creation'
classmethod: SelectVisitor
select: aBlock
	^ self basicNew initializeWithBlock: aBlock
%

!		Instance methods for 'SelectVisitor'

category: 'visiting'
method: SelectVisitor
visitReference: anEntry
	(block value: anEntry) 
		ifTrue: [ out nextPut: anEntry ]
%

! Class implementation for 'CopyVisitor'

!		Class methods for 'CopyVisitor'

category: 'instance creation'
classmethod: CopyVisitor
copy: source to: dest
	(self from: source to: dest) visit
%

category: 'instance creation'
classmethod: CopyVisitor
from: srcReference to: dstReference
	^ self basicNew
		initializeWithSource: srcReference 
		dest: dstReference
%

!		Instance methods for 'CopyVisitor'

category: 'visiting'
method: CopyVisitor
copyDirectory: aReference
	| directory |
	directory := dest resolve: (aReference relativeTo: source).
	directory createDirectory
%

category: 'visiting'
method: CopyVisitor
copyFile: aReference
	| copy |
	copy := dest resolve: (aReference relativeTo: source).
	aReference copyTo: copy
%

category: 'initialize-release'
method: CopyVisitor
initializeWithSource: srcReference dest: dstReference
	self initialize.
	source := srcReference.
	dest := dstReference
%

category: 'visiting'
method: CopyVisitor
visit
	(PreorderGuide for: self) 
		show: source
%

category: 'visiting'
method: CopyVisitor
visitDirectory: anEntry
	| reference |
	reference := anEntry reference.
	reference = source
		ifTrue: [dest ensureCreateDirectory]
		ifFalse: [self copyDirectory: reference]
%

category: 'visiting'
method: CopyVisitor
visitFile: anEntry
	| reference |
	reference := anEntry reference.
	reference = source
		ifTrue: [source copyTo: dest]
		ifFalse: [self copyFile: reference]
%

! Class implementation for 'DeleteVisitor'

!		Class methods for 'DeleteVisitor'

category: 'instance creation'
classmethod: DeleteVisitor
delete: aReference
	^ self new visit: aReference
%

!		Instance methods for 'DeleteVisitor'

category: 'visiting'
method: DeleteVisitor
visit: aReference
	PostorderGuide 
		show: aReference 
		to: self 
		selecting: [ :entry | entry isSymlink not ]
%

category: 'visiting'
method: DeleteVisitor
visitReference: anEntry
	anEntry reference delete
%

! Class implementation for 'GsInteraction'

!		Instance methods for 'GsInteraction'

category: 'accessing'
method: GsInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      nil ] ].
  ^ defaultActionBlock
%

category: 'accessing'
method: GsInteraction
defaultActionBlock: anObject

   "Modify the value of the instance variable 'defaultActionBlock'."
   defaultActionBlock := anObject
%

category: 'interacting'
method: GsInteraction
defaultActionFor: anInteractionRequest
  ^ self defaultActionBlock value: anInteractionRequest
%

category: 'interacting'
method: GsInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithInspect:
     interactWithMultiLineText:
     interactWithText:
  "

  self subclassResponsibility
%

category: 'printing'
method: GsInteraction
printLabel
  ^ ''
%

category: 'printing'
method: GsInteraction
printOn: aStream
  aStream nextPutAll: self class name asString , '(' , self printLabel , ')'
%

category: 'interacting'
method: GsInteraction
signal
  ^ GsInteractionRequest signal: self
%

! Class implementation for 'GsChoiceInteraction'

!		Class methods for 'GsChoiceInteraction'

category: 'instance creation'
classmethod: GsChoiceInteraction
labels: anArray
	^ self
		prompt: nil
		labels: anArray
		values: anArray
		lines: #()
%

category: 'instance creation'
classmethod: GsChoiceInteraction
labels: labelArray lines: lineArray
	^ self
		prompt: nil
		labels: labelArray
		values: labelArray
		lines: lineArray
%

category: 'instance creation'
classmethod: GsChoiceInteraction
prompt: aString labels: labelArray values: valueArray
	^ self
		prompt: aString
		labels: labelArray
		 values: valueArray
		lines: #()
%

category: 'instance creation'
classmethod: GsChoiceInteraction
prompt: aString labels: labelArray values: valueArray lines: lineArray
  ^ self new
    prompt: aString;
    labels: labelArray;
    values: valueArray;
    lines: lineArray;
    yourself
%

!		Instance methods for 'GsChoiceInteraction'

category: 'interacting'
method: GsChoiceInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithChoice: self
%

category: 'accessing'
method: GsChoiceInteraction
labels

   "Return the value of the instance variable 'labels'."
   ^labels
%

category: 'accessing'
method: GsChoiceInteraction
labels: anObject

   "Modify the value of the instance variable 'labels'."
   labels := anObject
%

category: 'accessing'
method: GsChoiceInteraction
lines

   "Return the value of the instance variable 'lines'."
   ^lines
%

category: 'accessing'
method: GsChoiceInteraction
lines: anObject

   "Modify the value of the instance variable 'lines'."
   lines := anObject
%

category: 'printing'
method: GsChoiceInteraction
printLabel
  ^ self prompt
%

category: 'accessing'
method: GsChoiceInteraction
prompt

   "Return the value of the instance variable 'prompt'."
   ^prompt
%

category: 'accessing'
method: GsChoiceInteraction
prompt: aString
  prompt := aString copyWrappedTo: 80
%

category: 'choice'
method: GsChoiceInteraction
select: anIndex
  ^ self values at: anIndex
%

category: 'choice'
method: GsChoiceInteraction
select: anIndex for: anInteractionRequest
  anInteractionRequest response: (self values at: anIndex)
%

category: 'accessing'
method: GsChoiceInteraction
values

   "Return the value of the instance variable 'values'."
   ^values
%

category: 'accessing'
method: GsChoiceInteraction
values: anObject

   "Modify the value of the instance variable 'values'."
   values := anObject
%

! Class implementation for 'GsConfirmInteraction'

!		Class methods for 'GsConfirmInteraction'

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt
  ^ self prompt: prompt confirm: 'Ok'
%

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt confirm: confirm
  ^ self prompt: prompt confirm: confirm cancel: 'Cancel'
%

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt confirm: confirm cancel: cancel
  ^ self new
    prompt: prompt;
    confirm: confirm;
    cancel: cancel
%

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt confirm: confirm cancel: cancel abort: abort
  "on confirm return true, on cancel return false on abort return nil"

  ^ self new
    prompt: prompt;
    confirm: confirm;
    cancel: cancel;
    abort: abort
%

!		Instance methods for 'GsConfirmInteraction'

category: 'accessing'
method: GsConfirmInteraction
abort
  ^ abort
%

category: 'accessing'
method: GsConfirmInteraction
abort: anObject
  abort := anObject
%

category: 'confirm'
method: GsConfirmInteraction
abortFor: anInteractionRequest
  anInteractionRequest response: self abortResponse
%

category: 'confirm'
method: GsConfirmInteraction
abortResponse
  ^ nil
%

category: 'accessing'
method: GsConfirmInteraction
cancel
  ^ cancel
%

category: 'accessing'
method: GsConfirmInteraction
cancel: anObject
	cancel := anObject
%

category: 'confirm'
method: GsConfirmInteraction
cancelFor: anInteractionRequest
  anInteractionRequest response: self cancelResponse
%

category: 'confirm'
method: GsConfirmInteraction
cancelResponse
  ^ false
%

category: 'accessing'
method: GsConfirmInteraction
confirm
	^ confirm
%

category: 'accessing'
method: GsConfirmInteraction
confirm: anObject
	confirm := anObject
%

category: 'accessing'
method: GsConfirmInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      self cancelResponse ] ].
  ^ defaultActionBlock
%

category: 'interacting'
method: GsConfirmInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithConfirm: self
%

category: 'confirm'
method: GsConfirmInteraction
ok
  ^ true
%

category: 'confirm'
method: GsConfirmInteraction
okFor: anInteractionRequest
  anInteractionRequest response: self okResponse
%

category: 'confirm'
method: GsConfirmInteraction
okResponse
  ^ true
%

category: 'printing'
method: GsConfirmInteraction
printLabel
  ^ self prompt
%

category: 'accessing'
method: GsConfirmInteraction
prompt
	^ prompt
%

category: 'accessing'
method: GsConfirmInteraction
prompt: aString
  prompt := aString copyWrappedTo: 80
%

! Class implementation for 'GsNotifyInteraction'

!		Instance methods for 'GsNotifyInteraction'

category: 'accessing'
method: GsNotifyInteraction
defaultActionBlock
  "notify answers ok by default, while confirm answers fals by default"

  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      self okResponse ] ].
  ^ defaultActionBlock
%

! Class implementation for 'GsInformInteraction'

!		Class methods for 'GsInformInteraction'

category: 'instance creation'
classmethod: GsInformInteraction
message: aString
  ^ self new
    message: aString;
    yourself
%

!		Instance methods for 'GsInformInteraction'

category: 'interacting'
method: GsInformInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithInform: self
%

category: 'accessing'
method: GsInformInteraction
message

   "Return the value of the instance variable 'message'."
   ^message
%

category: 'accessing'
method: GsInformInteraction
message: aString
  message := aString copyWrappedTo: 80
%

category: 'printing'
method: GsInformInteraction
printLabel
  ^ self message
%

! Class implementation for 'GsInspectInteraction'

!		Class methods for 'GsInspectInteraction'

category: 'instance creation'
classmethod: GsInspectInteraction
theObject: anObject
  ^ self new
    theObject: anObject;
    yourself
%

!		Instance methods for 'GsInspectInteraction'

category: 'accessing'
method: GsInspectInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      self theObject ] ].
  ^ defaultActionBlock
%

category: 'interacting'
method: GsInspectInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithInspect:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithInspect: self
%

category: 'printing'
method: GsInspectInteraction
printLabel
  ^ self theObject printString
%

category: 'accessing'
method: GsInspectInteraction
theObject

   "Return the value of the instance variable 'theObject'."
   ^theObject
%

category: 'accessing'
method: GsInspectInteraction
theObject: anObject

   "Modify the value of the instance variable 'theObject'."
   theObject := anObject
%

! Class implementation for 'GsExploreInteraction'

!		Instance methods for 'GsExploreInteraction'

category: 'interacting'
method: GsExploreInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithInspect:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithExplore: self
%

! Class implementation for 'GsTextInteraction'

!		Class methods for 'GsTextInteraction'

category: 'instance creation'
classmethod: GsTextInteraction
prompt: aString
  ^ self prompt: aString template: ''
%

category: 'instance creation'
classmethod: GsTextInteraction
prompt: promptString template: templateString
  ^ self new
    prompt: promptString;
    template: templateString;
    yourself
%

category: 'instance creation'
classmethod: GsTextInteraction
requestPassword: aString
  ^ self new
    requestPassword: aString;
    yourself
%

!		Instance methods for 'GsTextInteraction'

category: 'accessing'
method: GsTextInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      '' ] ].
  ^ defaultActionBlock
%

category: 'interacting'
method: GsTextInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithText: self
%

category: 'printing'
method: GsTextInteraction
printLabel
  ^ self prompt
%

category: 'accessing'
method: GsTextInteraction
prompt

   "Return the value of the instance variable 'prompt'."
   ^prompt
%

category: 'accessing'
method: GsTextInteraction
prompt: aString
  prompt := aString copyWrappedTo: 80
%

category: 'accessing'
method: GsTextInteraction
requestPassword

   requestPassword ifNil: [ requestPassword := false ].
   ^requestPassword
%

category: 'accessing'
method: GsTextInteraction
requestPassword: aString

   prompt := aString.
   requestPassword := true
%

category: 'accessing'
method: GsTextInteraction
template
  template ifNil: [ template := '' ].
  ^ template
%

category: 'accessing'
method: GsTextInteraction
template: anObject

   "Modify the value of the instance variable 'template'."
   template := anObject
%

! Class implementation for 'GsMultiLineTextInteraction'

!		Instance methods for 'GsMultiLineTextInteraction'

category: 'interacting'
method: GsMultiLineTextInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithMultiLineText: self
%

! Class implementation for 'GsInteractionHandler'

!		Instance methods for 'GsInteractionHandler'

category: 'accessing'
method: GsInteractionHandler
choiceBlock
  choiceBlock ifNil: [ ^ self defaultBlock ].
  ^ choiceBlock
%

category: 'accessing'
method: GsInteractionHandler
choiceBlock: anObject

   "Modify the value of the instance variable 'choiceBlock'."
   choiceBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
confirmBlock
  confirmBlock ifNil: [ ^ self defaultBlock ].
  ^ confirmBlock
%

category: 'accessing'
method: GsInteractionHandler
confirmBlock: anObject

   "Modify the value of the instance variable 'confirmBlock'."
   confirmBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
defaultBlock
  defaultBlock
    ifNil: [ 
      defaultBlock := [ :interaction | 
      self
        error:
          'No handler defined for ' , interaction class name asString , ' interaction.' ] ].
  ^ defaultBlock
%

category: 'accessing'
method: GsInteractionHandler
defaultBlock: anObject

   "Modify the value of the instance variable 'defaultBlock'."
   defaultBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
informBlock
  informBlock ifNil: [ ^ self defaultBlock ].
  ^ informBlock
%

category: 'accessing'
method: GsInteractionHandler
informBlock: anObject

   "Modify the value of the instance variable 'informBlock'."
   informBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
inspectBlock
  inspectBlock ifNil: [ ^ self defaultBlock ].
  ^ inspectBlock
%

category: 'accessing'
method: GsInteractionHandler
inspectBlock: anObject

   "Modify the value of the instance variable 'inspectBlock'."
   inspectBlock := anObject
%

category: 'interactions'
method: GsInteractionHandler
interactWithChoice: interaction
  ^ self choiceBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithConfirm: interaction
  ^ self confirmBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithExplore: interaction
  ^ self interactWithInspect: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithInform: interaction
  ^ self informBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithInspect: interaction
  ^ self inspectBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithMultiLineText: interaction
  ^ self multiLineTextBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithText: interaction
  ^ self textBlock value: interaction
%

category: 'accessing'
method: GsInteractionHandler
multiLineTextBlock
  multiLineTextBlock ifNil: [ ^ self defaultBlock ].
  ^ multiLineTextBlock
%

category: 'accessing'
method: GsInteractionHandler
multiLineTextBlock: anObject

   "Modify the value of the instance variable 'multiLineTextBlock'."
   multiLineTextBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
textBlock
  textBlock ifNil: [ ^ self defaultBlock ].
  ^ textBlock
%

category: 'accessing'
method: GsInteractionHandler
textBlock: anObject

   "Modify the value of the instance variable 'textBlock'."
   textBlock := anObject
%

! Class implementation for 'GsTonelOrderedDictionary'

!		Class methods for 'GsTonelOrderedDictionary'

category: 'instance creation'
classmethod: GsTonelOrderedDictionary
new
	^ self new: 3
%

category: 'instance creation'
classmethod: GsTonelOrderedDictionary
new: anInteger
	^ self basicNew initialize: anInteger; yourself
%

category: 'instance creation'
classmethod: GsTonelOrderedDictionary
withAll: aDictionary
	^ (self new: aDictionary size)
		addAll: aDictionary;
		yourself
%

!		Instance methods for 'GsTonelOrderedDictionary'

category: 'accessing'
method: GsTonelOrderedDictionary
add: anAssociation
	self at: anAssociation key put: anAssociation value.
	^ anAssociation
%

category: 'adding'
method: GsTonelOrderedDictionary
addAll: aDictionary
	aDictionary keysAndValuesDo: [ :key :value | self at: key put: value ].
	^ aDictionary
%

category: 'enumerating'
method: GsTonelOrderedDictionary
associationsDo: aBlock
	self keysAndValuesDo: [ :key :value | aBlock value: key -> value ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
at: aKey
	"Answer the value associated with aKey. Raise an exception, if no such key is defined."

	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
at: aKey ifAbsent: aBlock
	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index ]
		ifTrue: [ aBlock value ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
at: aKey ifAbsentPut: aBlock
	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index ]
		ifTrue: [ self privateAt: aKey put: aBlock value ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
at: aKey ifPresent: aBlock
	"Lookup aKey in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0 ifFalse: [ aBlock value: (values at: index) ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
at: aKey put: aValue
	"Set the value of aKey to be aValue."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index put: aValue ]
		ifTrue: [ self privateAt: aKey put: aValue ]
%

category: 'enumerating'
method: GsTonelOrderedDictionary
do: aBlock
	1 to: size do: [ :index | aBlock value: (values at: index) ]
%

category: 'private'
method: GsTonelOrderedDictionary
errorKeyNotFound
	self error: 'Key not found'
%

category: 'private'
method: GsTonelOrderedDictionary
findIndexFor: aKey
	1 to: size do: [ :index |
		(keys at: index) = aKey
			ifTrue: [ ^ index ] ].
	^ 0
%

category: 'private'
method: GsTonelOrderedDictionary
grow
	| newKeys newValues |
	newKeys := Array new: 2 * size.
	newValues := Array new: 2 * size.
	1 to: size do: [ :index |
		newKeys at: index put: (keys at: index).
		newValues at: index put: (values at: index) ].
	keys := newKeys.
	values := newValues
%

category: 'testing'
method: GsTonelOrderedDictionary
includesKey: aKey
	"Answer whether the receiver has a key equal to aKey."

	^ (self findIndexFor: aKey) ~= 0
%

category: 'initialization'
method: GsTonelOrderedDictionary
initialize: anInteger
  size := 0.
  keys := Array new: anInteger.
  values := Array new: anInteger
%

category: 'testing'
method: GsTonelOrderedDictionary
isCollection
	^ true
%

category: 'testing'
method: GsTonelOrderedDictionary
isEmpty
	^ size = 0
%

category: 'enumerating'
method: GsTonelOrderedDictionary
keys
	^ keys copyFrom: 1 to: size
%

category: 'enumerating'
method: GsTonelOrderedDictionary
keysAndValuesDo: aBlock
	1 to: size do: [ :index | aBlock value: (keys at: index) value: (values at: index) ]
%

category: 'enumerating'
method: GsTonelOrderedDictionary
keysDo: aBlock
	1 to: size do: [ :each | aBlock value: (keys at: each) ]
%

category: 'copying'
method: GsTonelOrderedDictionary
postCopy
	super postCopy.
	keys := keys copy.
	values := values copy
%

category: 'printing'
method: GsTonelOrderedDictionary
printOn: aStream
	super printOn: aStream.
	
	aStream nextPut: $(.
	self size <= 100
		ifTrue: [
			| first |
			first := true.
			self keysAndValuesDo: [ :key :value |
				"keysAndValuesDo:separatedBy: would be nice"
				first
					ifTrue: [ first := false ]
					ifFalse: [ aStream space ].
				aStream
					print: key;
					nextPutAll: '->';				
					print: value ] ]
		ifFalse: [
			aStream
				nextPutAll: 'size ';
				print: self size ].
	aStream nextPut: $)	
%

category: 'private'
method: GsTonelOrderedDictionary
privateAt: aKey put: aValue
	size = keys size ifTrue: [ self grow ].
	keys at: (size := size + 1) put: aKey.
	^ values at: size put: aValue
%

category: 'private'
method: GsTonelOrderedDictionary
removeIndex: index
	| value |
	value := values at: index.
	index to: size - 1 do:
			[ :i | 
			keys at: i put: (keys at: i + 1).
			values at: i put: (values at: i + 1) ].
	keys at: size put: nil.
	values at: size put: nil.
	size := size - 1.
	^ value
%

category: 'accessing'
method: GsTonelOrderedDictionary
removeKey: aKey
	"Remove aKey from the receiver, raise an exception if the element is missing."

	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
removeKey: aKey ifAbsent: aBlock
	"Remove aKey from the receiver, evaluate aBlock if the element is missing."

	| index |
	index := self findIndexFor: aKey.
	index = 0 ifTrue: [ ^ aBlock value ].
	^ self removeIndex: index
%

category: 'accessing'
method: GsTonelOrderedDictionary
size
	^ size
%

category: 'ston'
method: GsTonelOrderedDictionary
stonOn: stonWriter
	"Instances of STON mapClass will be encoded directly, without a class tag.
	Other (sub)classes will be encoded with a class tag and will use a map representation. "
	
    stonWriter encodeMap: self
%

category: 'enumerating'
method: GsTonelOrderedDictionary
values
	^ values copyFrom: 1 to: size
%

category: 'filetree'
method: GsTonelOrderedDictionary
_writeCypressJsonOn: fileStream
	"Private method which may be removed in a future GemStone version."

	self _writeCypressJsonOn: fileStream indent: 0
%

category: 'filetree'
method: GsTonelOrderedDictionary
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	| indent cnt |
	indent := startIndent.
	aStream
		nextPutAll: '{';
		lf.
	cnt := 0.
	indent := indent + 1.
	self keys do: 
			[:key |
			| value |
			value := self at: key.
			cnt := cnt + 1.
			indent timesRepeat: [aStream tab].
			key _writeCypressJsonOn: aStream indent: indent.
			aStream nextPutAll: ' : '.
			value _writeCypressJsonOn: aStream indent: indent.
			cnt < size
				ifTrue: 
					[aStream
						nextPutAll: ',';
						lf]].
	size = 0 ifTrue: [indent timesRepeat: [aStream tab]].
	aStream nextPutAll: ' }'
%

! Class implementation for 'JadeServer'

!		Class methods for 'JadeServer'

category: 'jadeite server'
classmethod: JadeServer
theJadeiteServer
  ^ SessionTemps current
    at: #'jadeiteServer'
    ifAbsentPut: [ 
      | jadeServerClass |
      jadeServerClass := (System _gemVersion beginsWith: '3.2')
        ifTrue: [ Rowan jadeServerClassNamed: #'JadeServer64bit32' ]
        ifFalse: [ Rowan jadeServerClassNamed: #'JadeServer64bit35' ].
      jadeServerClass new
        initialize;
        yourself ]
%

!		Instance methods for 'JadeServer'

category: 'category'
method: JadeServer
abort

	classOrganizers := Array new: 4.
	System abortTransaction.
%

category: 'category'
method: JadeServer
addAccessorsFor: aString inBehavior: aBehavior

	aBehavior compileAccessingMethodsFor: (Array with: aString asSymbol).

%

category: 'category'
method: JadeServer
addCategory: aString to: aClass 

	aClass addCategory: aString.

%

category: 'category'
method: JadeServer
addGroup: aString toUser: aUserProfile

	aUserProfile addGroup: aString.

%

category: 'category'
method: JadeServer
addMethodCategoryNamesToMethodFilters

	classList do: [:each | methodFilters addAll: each categoryNames].

%

category: 'category'
method: JadeServer
addMissingAccessorsFor: aClass

	aClass compileMissingAccessingMethods.

%

category: 'category'
method: JadeServer
addPrivilege: aString toUser: aUserProfile

	aUserProfile addPrivilege: aString.

%

category: 'category'
method: JadeServer
addProcess: aProcess to: aStream withStatus: aString scheduler: aScheduler

	| x |
	aStream lf
"1"	nextPutAll: aString; tab;
"2"	nextPutAll: aProcess asOop printString; tab;
"3"	nextPutAll: aProcess priority printString; tab;
"4"	nextPutAll: (aProcess createdByApplication ifTrue: ['Y'] ifFalse: ['']); tab; 
"5"	nextPutAll: ((x := aProcess stackId) == -1 	ifTrue: [''] ifFalse: [x printString]); tab;
"6"	nextPutAll: ((x := aProcess waitingOn) 	isNil ifTrue: [''] ifFalse: [x asOop printString]); tab;
"7"	nextPutAll: ((x := aProcess _signalTime) 	isNil ifTrue: [''] ifFalse: [(x - aScheduler _now) printString]); tab;
"8"	nextPutAll: (aProcess isPartialContinuation	ifTrue: ['partial'] ifFalse: [aProcess isContinuation ifTrue: ['full'] ifFalse: ['']]); tab;
"9"	"type: forked or main"
"10"	"live or terminated"
	yourself.

%

category: 'category'
method: JadeServer
addSessionWithId: anInteger toStream: aStream

	| array gsSession timeGmt x |
	array := System descriptionOfSession: anInteger.
	array size: 20.
	gsSession := GsSession sessionWithSerialNumber: (array at: 9).
	timeGmt := System timeGmt.
	aStream
		nextPutAll: '<session oop=';
		nextPutAll: (self oopOf: gsSession) printString printString;
		nextPutAll: ' name=';
		nextPutAll: (array at: 1) userId printString;
		nextPutAll: ' process=';
		nextPutAll: (array at: 2) printString printString;
		nextPutAll: ' host=';
		nextPutAll: (array at: 3) printString;
		nextPutAll: ' primitive=';
		nextPutAll: (array at: 4) printString printString;
		nextPutAll: ' viewAge=';
		nextPutAll: (timeGmt - (array at: 5)) printString printString;
		nextPutAll: ' state=';
		nextPutAll: (array at: 6) printString printString;
		nextPutAll: ' transaction=';
		nextPutAll: (array at: 7) printString printString;
		nextPutAll: ' hasOldestCR=';
		nextPutAll: (array at: 8) printString printString;
		nextPutAll: ' serial=';
		nextPutAll: (array at: 9) printString printString;
		nextPutAll: ' id=';
		nextPutAll: (array at: 10) printString printString;
		nextPutAll: ' ip=';
		nextPutAll: (array at: 11) printString;
		nextPutAll: ' priority=';
		nextPutAll: ((x := array at: 12) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' hostId=';
		nextPutAll: ((x := array at: 13)  isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' quietTime=';
		nextPutAll: ((x := array at: 14) isNil ifTrue: [''] ifFalse: [(timeGmt - x)  printString]) printString;
		nextPutAll: ' lifeTime=';
		nextPutAll: ((x := array at: 15) isNil ifTrue: [''] ifFalse: [(timeGmt - x)  printString]) printString;
		nextPutAll: ' backlog=';
		nextPutAll: ((x := array at: 16) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' description=';
		nextPutAll: ((x := array at: 17) isNil ifTrue: [''] ifFalse: [x]) printString;
		nextPutAll: ' objects=';
		nextPutAll: ((x := array at: 18) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' pages=';
		nextPutAll: ((x := array at: 19) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' voteState=';
		nextPutAll: ((x := array at: 20) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' />';
		yourself.

%

category: 'category'
method: JadeServer
addUser: aUserProfile toStream: aStream

	(self oopOf: aUserProfile) printOn: aStream.
	aStream tab; nextPutAll: aUserProfile userId.
	aStream tab; nextPutAll: (aUserProfile lastLoginTime asStringUsingFormat: #(1 2 3 $  2 1 $: true true true false)).
	aStream tab. aUserProfile loginsAllowedBeforeExpiration printOn: aStream.
	aStream tab. aUserProfile isDisabled printOn: aStream.
	aStream tab. aUserProfile activeUserIdLimit printOn: aStream.
	aStream tab.	"; nextPutAll: aUserProfile nativeLanguage asString."
	aStream tab. aUserProfile reasonForDisabledAccount printOn: aStream.
	aStream tab; nextPutAll: (aUserProfile lastPasswordChange asStringUsingFormat: #(1 2 3 $  2 1 $: true true true false)).
	aStream tab. aUserProfile passwordNeverExpires printOn: aStream.
	aStream lf.

%

category: 'category'
method: JadeServer
allGroups

	| allGroups myGroups stream |
	allGroups := AllGroups keys asSortedCollection.
	myGroups := (AllUsers userWithId: 'GcUser') groups.
	stream := WriteStream on: String new.
	allGroups do: [:each | 
		stream nextPutAll: each; tab.
		(myGroups includes: each) printOn: stream.
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
allSessions

	| list stream |
	stream := WriteStream on: String new.
	stream nextPutAll: '<?xml version=''1.0'' ?><sessions>'.
	list := System currentSessionNames subStrings: Character lf.
	list := list reject: [:each | each isEmpty].
	list := list collect: [:each | (each subStrings at: 3) asNumber].
	list do: [:each | 
		self
			addSessionWithId: each
			toStream: stream.
	].
	^stream 
		nextPutAll: '</sessions>';
		contents.

%

category: 'category'
method: JadeServer
allUsersPasswordLimits

	| stream |
	stream := WriteStream on: String new.
	AllUsers disallowUsedPasswords printOn: stream. stream tab.
	AllUsers minPasswordSize printOn: stream. stream tab.
	AllUsers maxPasswordSize printOn: stream. stream tab.
	AllUsers maxRepeatingChars printOn: stream. stream tab.
	AllUsers maxConsecutiveChars printOn: stream. stream tab.
	AllUsers maxCharsOfSameType printOn: stream. stream tab.
	AllUsers staleAccountAgeLimit printOn: stream. stream tab.
	AllUsers passwordAgeLimit printOn: stream. stream lf.
	AllUsers disallowedPasswords do: [:each | 
		stream nextPutAll: each; tab.
	].
	stream lf. AllUsers passwordAgeWarning printOn: stream. stream lf.
	^stream contents.

%

category: 'category'
method: JadeServer
asAsciiString: aString

	^String withAll: (aString asArray collect: [:char | 
		((32 <= char asciiValue and: [char asciiValue <= 127]) or: [char isSeparator])
			ifTrue: [char]
			ifFalse: [$?].
	]).

%

category: 'category'
method: JadeServer
assignClass: aClass toCategory: aString

	aClass thisClass category: aString.

%

category: 'category'
method: JadeServer
asString: anObject

	(anObject isKindOf: String) ifTrue: [^anObject].
	Exception
		category: nil
		number: nil
		do: [:ex :cat :num :args | 
			^'<<printString error: ' , ex printString , '>>'.
		].
	^anObject printString.

%

category: 'category'
method: JadeServer
authorInitials: aString

	| packagePolicy |
	(packagePolicy := self gsPackagePolicy) isNil ifTrue: [^self].
	packagePolicy authorInitials: aString.

%

category: 'jadeite'
method: JadeServer
autoCommitIfRequired
	| commitResult |
	Rowan serviceClass autoCommit == true ifTrue:[
		commitResult := System commitTransaction.
		RowanAutoCommitService new autoCommit:  
			(commitResult 
				ifTrue:[true] 
				ifFalse:[#failed])].
%

category: 'category'
method: JadeServer
beginTransaction

	classOrganizers := Array new: 4.
	System beginTransaction.

%

category: 'category'
method: JadeServer
behaviorFor: selector in: aClass

	| behavior |
	behavior := aClass.
	[
		behavior notNil.
	] whileTrue: [
		(behavior includesSelector: selector) ifTrue: [^behavior].
		behavior := behavior superclass.
	].
	self error: 'Method not found in class or in any superclass'.

%

category: 'category'
method: JadeServer
categoryListFor: aSymbolDictionary

	| categories stream |
	categories := Set new.
	aSymbolDictionary do: [:each | 
		each isBehavior ifTrue: [
			categories add: each category.
		].
	].
	categories copy do: [:each | 
		1 to: each size do: [:i | 
			(each at: i) = $- ifTrue: [
				| string |
				string := each copyFrom: 1 to: i - 1.
				(categories includes: string) ifFalse: [
					categories add: string.
					self _addToPureExportSet: string.
				].
			].
		].
	].
	stream := WriteStream on: String new.
	categories asSortedCollection do: [:each | 
		(self oopOf: each) printOn: stream.
		stream tab; nextPutAll: each; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
categoryOfMethod: aMethod

	| selector |
	(selector := aMethod selector) isNil ifTrue: [^''].
	^self _behavior: aMethod inClass categoryOfSelector: selector.

%

category: 'category'
method: JadeServer
class: aClass includesSelector: aSelector

	^aClass includesSelector: aSelector asSymbol.

%

category: 'category'
method: JadeServer
classesForUser: aUserProfile

	| stream |
	stream := WriteStream on: String new.
	aUserProfile symbolList do: [:eachDict |
		eachDict keysAndValuesDo: [:key :value |
			value isBehavior ifTrue: [
				stream nextPutAll: key; space; nextPutAll: value category asString; tab.
			].
		].
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
classListFor: aDictionary category: aString

	| visibleClasses allClasses stream queue |
	visibleClasses := aDictionary asArray select: [:each | 
		each isBehavior and: [aString isNil or: [
			| category |
			(category := each category) notNil and: [
			category = aString or: [
			category matchPattern: (Array with: aString with: $*)]]]]].
	allClasses := visibleClasses asIdentitySet.
	queue := visibleClasses asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| parent |
		parent := queue removeFirst superclass.
		(parent notNil and: [(allClasses includes: parent) not]) ifTrue: [
			queue add: parent.
			allClasses add: parent.
		].
	].
	stream := WriteStream on: String new.
	allClasses do: [:each |
		self
			_addClass: each 
			toStream: stream 
			isVisible: (visibleClasses includes: each)
			fromDictionary: aDictionary.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
classOrganizer

	^ClassOrganizer new

%

category: 'category'
method: JadeServer
clearBreakAtStepPoint: anInteger inMethod: aGsMethod

	aGsMethod clearBreakAtStepPoint: anInteger.

%

category: 'category'
method: JadeServer
commentFor: aClass

	| description |
	(Class canUnderstand: #'classComment') ifTrue: [
		^aClass classComment.
	].
	(description := aClass description) isNil ifTrue: [^nil].
	(description class name = #'GsClassDocumentation') ifTrue: [^description detailsAboutClass].
	^description printString.

%

category: 'category'
method: JadeServer
commit

	classOrganizers := Array new: 4.
	^System commitTransaction.

%

category: 'category'
method: JadeServer
compile: aString frame: anInteger process: aGsProcess
	"Compile method from within debugger"

	| oldMethod aBehavior selector category result |
	oldMethod := aGsProcess localMethodAt: anInteger.
	result := self recompile: oldMethod withSource: aString.
	(result isKindOf: Boolean) ifTrue: [^result].
	aBehavior := oldMethod inClass.
	selector := oldMethod selector.
	selector isNil ifTrue: [^result].
	category := self _behavior: aBehavior categoryOfSelector: selector.
	result := [[ aBehavior rwCompileMethod: aString category: category ]
							on: RwExecuteClassInitializeMethodsAfterLoadNotification
							do: [:ex | ex resume: false ]] 
								on: RwPerformingUnpackagedEditNotification
								do: [:ex | ex resume ].

					
	^result
%

category: 'category'
method: JadeServer
compiledMethodAt: aSymbol inClass: aClass

	^aClass compiledMethodAt: aSymbol.

%

category: 'category'
method: JadeServer
compileMethod: methodString behavior: aBehavior symbolList: aSymbolList inCategory: categorySymbol
	"Returns aGsNMethod (if successful) -> anArrayOfErrorsOrWarnings"

	| result |
	"Method is in GsFoundation, but not in GsBase"
	result := (aBehavior class canUnderstand: #'compileMethod:category:using:environmentId:') ifTrue: [
		[
			aBehavior		"returns self or signals a CompileError"
				compileMethod: methodString
				category: categorySymbol
				using: aSymbolList
				environmentId: 0.
			nil.
		] on: (self objectInBaseNamed: #'UndefinedSymbolNotification') do: [:ex | 
			ex resume: false.
		].
	] ifFalse: [(aBehavior class canUnderstand: #'compileMethod:category:using:') ifTrue: [
		[
			aBehavior		"returns self or signals a CompileError"
				compileMethod: methodString
				category: categorySymbol
				using: aSymbolList.
			nil.
		] on: (self objectInBaseNamed: #'UndefinedSymbolNotification') do: [:ex | 
			ex resume: false.
		].
	] ifFalse: [
		aBehavior		"returns nil or an Array of error descriptions"
			compileMethod: methodString
			dictionaries: aSymbolList
			category: categorySymbol.
	]].
	result notNil ifTrue: [
		^nil -> result.
	].
	(aBehavior class canUnderstand: #_primitiveCompileMethod:symbolList:category:oldLitVars:intoMethodDict:intoCategories:intoPragmas:) ifTrue: [
		result := aBehavior 
			_primitiveCompileMethod: methodString
			symbolList: aSymbolList
			category: categorySymbol
			oldLitVars: nil
			intoMethodDict: GsMethodDictionary new 
			intoCategories: GsMethodDictionary new
			intoPragmas: nil.
	] ifFalse: [
		(aBehavior class canUnderstand: #_primitiveCompileMethod:symbolList:category:obsoleteClassNames:oldLitVars:) ifTrue: [
			result := aBehavior 
				_primitiveCompileMethod: methodString
				symbolList: aSymbolList
				category: categorySymbol
				obsoleteClassNames: nil
				oldLitVars: nil.
		] ifFalse: [
			result := aBehavior 
				_primitiveCompileMethod: methodString
				symbolList: aSymbolList
				category: categorySymbol
				oldLitVars: nil
				intoMethodDict: GsMethodDictionary new 
				intoCategories: GsMethodDictionary new.
		].
	].
	(result isKindOf: Array) ifTrue: [
		"in 2.3.x: (Array with: compiledMethod with: errors with: warnings)"
		(result at: 2) notNil ifTrue: [^nil -> (result at: 2)].
		^(result at: 1) -> (result at: 3)
	].
	^result -> nil.

%

category: 'category'
method: JadeServer
compileMethod: methodString behavior: aBehavior user: aUserProfileOrNil inCategory: categoryString
	"answers a String:
		OOP of new method <TAB> selector of new method (or empty if compile failed)
		ERROR: [details] (repeat line for each error)
		[warnings] (if no errors)"

	| userProfile result gsMethod stream errDict errorList warnings |

	userProfile := aUserProfileOrNil isNil
		ifTrue: [System myUserProfile]
		ifFalse: [aUserProfileOrNil].
	result := self 		"key: GsNMethod value: ((Array withAll: errors) or aStringOfWarnings)"
		compileMethod: methodString 
		behavior: aBehavior 
		symbolList: userProfile symbolList 
		inCategory: categoryString asSymbol.
	(gsMethod := result key) isNil ifTrue: [
		errorList := result value.
		warnings := ''.
	] ifFalse: [
		errorList := #().
		warnings := result value.
	].
	stream := WriteStream on: String new.
	gsMethod notNil ifTrue: [
		stream 
			nextPutAll: gsMethod asOop printString;
			tab;
			nextPutAll: gsMethod selector;
			yourself.
	].
	errDict := GemStoneError at: System myUserProfile nativeLanguage.
	errorList do: [:each |
		stream lf; 
			nextPutAll: 'ERROR:'; tab;
			nextPutAll: (each at: 1) printString; tab;
			nextPutAll: (each at: 2) printString; tab;
			yourself.
		(each size >= 3 and: [(each at: 3) notNil]) ifTrue: [
			stream nextPutAll: (each at: 3); tab.
		] ifFalse: [
			(each at: 1) > errDict size ifTrue: [
				stream nextPutAll: '(unknown error number)'; tab.
			] ifFalse: [
				stream nextPutAll: (errDict at: (each at: 1)) asString; tab.
			].
		].
	].
	warnings isNil ifTrue: [warnings := ''].
	stream lf; nextPutAll: warnings.
	^stream contents.

%

category: 'category'
method: JadeServer
contents
	"WriteStream method to identify things that have not yet been flushed to the output. We have flushed everything!"

	^''.

%

category: 'category'
method: JadeServer
cr

	self nextPut: Character cr.

%

category: 'category'
method: JadeServer
currentUserMayEditMethod: aMethod

	^true
%

category: 'category'
method: JadeServer
debugString: aString fromContext: anObject environment: anInteger
	anInteger == 0 ifFalse: [self error: 'Only environment 0 is supported in this version!'].
	^(RowanDebuggerService new debugStringFrom: aString)
		evaluateInContext: anObject 
		symbolList: GsSession currentSession symbolList.
%

category: 'category'
method: JadeServer
debugTestNamed: testName of: testCaseClassName
	"Open a Debugger for the TestCase class named <testCaseClassName> in the test named <testName>"

	^(self objectNamed: testCaseClassName) debug: testName asSymbol
%

category: 'category'
method: JadeServer
defectiveTestsIn: aClass

	| testClass results stream |
	testClass := aClass thisClass.
	results := testClass suite run.
	stream := WriteStream on: String new.
	stream nextPutAll: results printString; lf.
	results defects asSet do: [:each | 
		| selector class |
		selector := each selector asSymbol.
		class := each class whichClassIncludesSelector: selector.
		stream nextPutAll: class name , ' debug: ' , each selector printString; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
definitionOfClass: aClass
	^aClass definition.
%

category: 'category'
method: JadeServer
definitionOfClass: aClass forUser: aUserProfile

			| stream |
			stream := WriteStream on: String new.
"1"		aClass superclass printOn: stream.
			stream 
"2"			lf; nextPutAll: (self subclassSelectorForClass: aClass);
"3"			lf; nextPutAll: aClass name;
"4"			lf; nextPutAll: (self dictionaryForClass: aClass forUser: aUserProfile);
				yourself.
"5"		stream lf. aClass instancesInvariant printOn: stream.
"6"		stream lf. aClass isModifiable printOn: stream.
"7"		stream lf. ((aClass class canUnderstand: #'instancesDbTransient') and: [aClass instancesDbTransient]) printOn: stream.
"8"		stream lf. ((aClass class canUnderstand: #'instancesNonPersistent') and: [aClass instancesNonPersistent]) printOn: stream.
			stream lf.
		aClass instVarNames do: [:each |
				stream 
"9.*.1"		nextPutAll: each; 
					space;
"9.*.2"		nextPutAll: (aClass constraintOfInstVar: each) name;
					tab.
			].
			stream lf.
			aClass class instVarNames do: [:each | 
"10.*"		stream nextPutAll: each; tab.
			].
			stream lf.
			aClass classVarNames asSortedCollection do: [:each | 
"11.*"		stream nextPutAll: each; tab.
			].
			stream lf.
			aClass sharedPools asSortedCollection do: [:each | 
"12.*"		stream nextPutAll: (self nameForSharedPool: each forUser: aUserProfile); tab.
			].
			^stream 
"13"		lf; nextPutAll: aClass userId;
"14"		lf; nextPutAll: (aClass timeStamp asStringUsingFormat: #(3 2 1 $- 1 1 $: true true false));
				lf; 
				contents.

%

category: 'category'
method: JadeServer
delay

	(Delay forMilliseconds: 10) wait.

%

category: 'category'
method: JadeServer
describeMethod: aMethod
	"Provide info needed to create a GsMethod in Jade client"

	writeStream := WriteStream on: String new.
	self _describeMethod: (self homeMethodFor: aMethod).
	^writeStream contents

%

category: 'category'
method: JadeServer
descriptionOfConfigOption: aString

	| dict key string |
	dict := self systemConfigAsDictionary.
	(string := dict at: aString ifAbsent: [nil]) notNil ifTrue: [^string].	string := aString asUppercase.
	dict keys do: [:each1 | 
		key := (each1 reject: [:each2 | each2 = $_]) asUppercase.
		key = string ifTrue: [^dict at: each1].
	].
	^''
%

category: 'category'
method: JadeServer
descriptionOfErrorNumber: anInteger

	| array stream |
	array := GemStoneError at: #'English'.
	anInteger <= 0 ifTrue: [^'Invalid number!'].
	array size < anInteger ifTrue: [^'Invalid number!'].
	stream := WriteStream on: String new.
	array := array at: anInteger.
	array isNil ifTrue: [^'No entry in GemStoneError for #' , anInteger printString , '!'].
	(array isKindOf: String) ifTrue: [array := Array with: array].
	array do: [:each | 
		(each isKindOf: Integer) ifTrue: [
			stream space; nextPut: $%.
			each printOn: stream.
		] ifFalse: [
			stream nextPutAll: each.
		].
	].
	^stream contents.

%

category: 'category'
method: JadeServer
dictionaryAndSymbolOf: aClass

	^self symbolList dictionaryAndSymbolOf: aClass.

%

category: 'category'
method: JadeServer
dictionaryAndSymbolOf: aClass forUser: aUserProfile

	^aUserProfile symbolList dictionaryAndSymbolOf: aClass.

%

category: 'category'
method: JadeServer
dictionaryForClass: aClass forUser: aUserProfile

	| anArray |
	anArray := self dictionaryAndSymbolOf: aClass forUser: aUserProfile.
	anArray isNil ifTrue: [^''].
	anArray := self dictionaryAndSymbolOf: (anArray at: 1) forUser: aUserProfile.
	anArray isNil ifTrue: [^''].
	^(anArray at: 2)

%

category: 'category'
method: JadeServer
dictionaryListFor: aUserProfile

	| symbolList list stream |
	symbolList := aUserProfile symbolList.
	list := symbolList namesReport subStrings: Character lf.
	list := list reject: [:each | each isEmpty].
	list := list collect: [:each | each subStrings].
	stream := WriteStream on: String new.
	list do: [:each | 
		(self oopOf: (symbolList at: (each at: 1) asNumber)) printOn: stream.
		stream tab; nextPutAll: (each at: 2); lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
does: newClass replace: oldClass

	^newClass name = oldClass name.

%

category: 'category'
method: JadeServer
environment
	"Ignored prior to 3.x"

	^0
%

category: 'category'
method: JadeServer
environment: anInteger
	"Ignored prior to 3.x"
%

category: 'category'
method: JadeServer
environmentForMethod: aGsNMethod

	^0
%

category: 'category'
method: JadeServer
environmentSuperClassFor: aBehavior

	^aBehavior superclass
%

category: 'category'
method: JadeServer
errorListFor: aCollection

	| stream |
	aCollection class name == #'ErrorDescription' ifTrue: [^''].
	stream := WriteStream on: String new.
	aCollection do: [:each | 
		stream
			nextPutAll: (each at: 1) printString; tab;
			nextPutAll: (each at: 2) printString; tab;
			nextPutAll: ((2 < each size and: [(each at: 3) notNil]) ifTrue: [(each at: 3)] ifFalse: [(GemStoneError at: #English) at: (each at: 1)]); tab;
			lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
executeString: aString fromContext: anObject environment: anInteger

	anInteger == 0 ifFalse: [self error: 'Only environment 0 is supported in this version!'].
	^aString
		evaluateInContext: anObject 
		symbolList: GsSession currentSession symbolList. 
%

category: 'category'
method: JadeServer
fileInClass: aString

	| list className index dictionaryName dictionary oldClass oldString |
	list := aString subStrings.
	className := list at: 3.
	className first = $' ifFalse: [self error: 'Class name ' , className printString , ' expected to begin and end with a quote!'].
	className last = $' ifFalse: [self error: 'Class name ' , className printString , ' expected to begin and end with a quote!'].
	className := className copyFrom: 2 to: className size - 1.
	index := list indexOf: 'inDictionary:'.
	dictionaryName := list at: index + 1.
	dictionary := self objectNamed: dictionaryName.
	oldClass := dictionary at: className ifAbsent: [nil].
	oldClass notNil ifTrue: [
		oldString := (oldClass _modifiableDefinitionInDictionary: dictionary named: dictionaryName) , '.'.
	].
	oldString = aString ifFalse: [aString evaluate].

%

category: 'category'
method: JadeServer
fileOutForClass: aClass

	^aClass thisClass fileOutClass.
 
%

category: 'category'
method: JadeServer
gemLogPath

	^''

%

category: 'category'
method: JadeServer
getMethodsNamesOf: classNamed
	"NO SENDERS"
	"Answer a collection with selectors of GemStone/s class name <className>"

	^(self objectNamed: classNamed) selectors asSortedCollection

%

category: 'category'
method: JadeServer
getSubclassesNamesOf: classNamed 
	"NO SENDERS"
	"Answer a collection with all subclasses of GemStone/S class named <classNamed>"

	^((self objectNamed: classNamed) allSubclasses collect: [:each | each name]) asSortedCollection
%

category: 'category'
method: JadeServer
getTestCaseClassesNamesOf: packageName
	"Answer a collection with all test classes of the GemStone/S package named <packageNamed>"

	| classes comma stream |
	packageName isEmpty ifTrue: [^''].
	classes := (self objectInBaseNamed: #'TestCase') allSubclasses.
	packageName = '<All>' ifFalse: [
		| packageInfo packageOrganizer |
		packageOrganizer := (self objectInBaseNamed: #'PackageOrganizer') default.
		packageInfo := packageOrganizer packageNamed: packageName ifAbsent: [^''].
		packageInfo classes isEmpty ifTrue: [^''].
		classes := packageInfo classes select: [:each | classes includes: each].
	].
	stream := WriteStream on: String new.
	comma := ''.
	classes do: [:each | stream nextPutAll: comma; nextPutAll: each name. comma := ','].
	^stream contents
%

category: 'category'
method: JadeServer
getTestMethodsNamesOf: classNamed 
	"Answer a collection with all test selectors of the GemStone/S class named <classNamed>"

	| class comma stream testSelectors gsClass |
	stream := WriteStream on: String new.
	gsClass := self objectNamed: classNamed.
	gsClass isNil ifTrue: [^''].
	(class := self objectNamed: #'TestCase') isNil ifTrue: [^''].
	(gsClass isSubclassOf: class) ifFalse: [^''].
	testSelectors :=  gsClass testSelectors asSortedCollection.
	testSelectors isEmpty ifTrue: [^''].
	comma := ''.
	 testSelectors do: [:each | stream nextPutAll: comma; nextPutAll: each. comma := ','].
	^stream contents
%

category: 'category'
method: JadeServer
globalsFor: aSymbolDictionary

	| stream |
	stream := WriteStream on: String new.
	aSymbolDictionary keysAndValuesDo: [:eachKey :eachValue | 
		eachValue isBehavior ifFalse: [
			| data |
			data := (self _oopAndStringFor: eachValue) value.
			data size > 200 ifTrue: [data := data copyFrom: 1 to: 200].
			data := String withAll: (data asArray collect: [:each | (each >= Character space and: [each <= $~]) ifTrue: [each] ifFalse: [$?]]).
			stream
	"1"		nextPutAll: (self oopOf: eachValue) printString; tab;
	"2"		nextPutAll: eachKey; tab;
	"3"		nextPutAll: eachValue class name; tab;
	"4"		nextPutAll: data; tab;
				lf;
				yourself.
		].
	].
	^stream contents.

%

category: 'category'
method: JadeServer
groupListFor: aUserProfile

	| allGroups myGroups stream |
	allGroups := AllGroups keys asSortedCollection.
	myGroups := aUserProfile groups.
	stream := WriteStream on: String new.
	allGroups do: [:each | 
		stream nextPutAll: each; tab.
		(myGroups includes: each) printOn: stream.
		stream lf.
	].
	^stream contents.

%

category: 'jadeite'
method: JadeServer
gsInteractionInformFailureHandler
  self interactionHandlerActive
    ifFalse: [ 
      ^ GsInteractionHandler new
        defaultBlock: [ :ignored | self assert: false description: 'expected a confirmation' ];
        confirmBlock: [ :interaction | interaction ok ];
        informBlock: [ :interaction |  ];
        inspectBlock: [ :interaction |  ];
        yourself ].
  ^ GsInteractionHandler new
    confirmBlock: [ :interaction | 
          | exception answer |
          exception := ClientForwarderSend new
            receiver: self
            clientObj: 1
            selector: #'confirmMessageBox:'
            args: (Array with: interaction prompt).
          answer := exception defaultAction.	"expect printString of answer back. Jadeite has limited ability to convert client objects to oops"
          answer evaluate ];
    informBlock: [ :interaction | 
          | exception |
          exception := ClientForwarderSend new
            receiver: self
            clientObj: 1
            selector: #'informMessageBox:'
            args: (Array with: interaction message).
          exception defaultAction.
          nil ];
    inspectBlock: [ :interaction | 
          | exception |
          exception := ClientForwarderSend new
            receiver: self
            clientObj: 1
            selector: #'inspectServerObject:'
            args: (Array with: interaction theObject asOop).
          exception defaultAction.
          interaction theObject ]
%

category: 'category'
method: JadeServer
gsPackagePolicy

	| class |
	class := self gsPackagePolicyClass.
	class isNil ifTrue: [^nil].
	^class current.

%

category: 'category'
method: JadeServer
gsPackagePolicyClass

	^self objectInBaseNamed: #'GsPackagePolicy'.

%

category: 'category'
method: JadeServer
historyOf: aClass

	| history |
	(history := aClass classHistory) isNil ifTrue: [
		history := Array with: aClass.
	].
	^history.

%

category: 'category'
method: JadeServer
homeMethodFor: aGsMethod

	^aGsMethod
%

category: 'category'
method: JadeServer
implementorsOf: anObject

	| symbol |
	symbol := (anObject isKindOf: String)
		ifTrue: [anObject asSymbol]
		ifFalse: [anObject selector].
	^self streamOfMethods: (self classOrganizer implementorsOf: symbol).

%

category: 'category'
method: JadeServer
implementorsOf: aGsMethod startingAt: aClass

	| selector myClass list |
	selector := aGsMethod selector.
	myClass := aClass.
	list := OrderedCollection new.
	[
		(myClass includesSelector: selector) ifTrue: [list add: myClass].
		(myClass := myClass superclass) notNil.
	] whileTrue: [].
	^self stringForClassList: list.

%

category: 'category'
method: JadeServer
initialize
	"#installTranscript is run from the Jadeite
	client post login method only. This avoids
	setting up ClientForwarder sends in a topaz
	session"

	classOrganizers := Array new: 4.
	self 
		registerOBNotifications;
		yourself.
%

category: 'category'
method: JadeServer
inspect: anObject

	| stream string |
	(stream := WriteStream on: String new)
		nextPutAll: anObject class name; tab;
		yourself.
	(self oopOf: anObject) printOn: stream.
	stream lf.
	(anObject isKindOf: Dictionary superclass) ifTrue: [^self inspectDictionary: anObject on: stream].
	self inspectNamedInstanceVariablesOf: anObject on: stream.
	anObject class format > 0 ifTrue: [
		1 to: (anObject _basicSize) do: [:i | 
			i printOn: stream.
			stream tab.
			self print: (self oopOf: (anObject _at: i)) on: stream.
			stream lf.
		].
	].
	(string := anObject printString) size > 5000 ifTrue: [string := (string copyFrom: 1 to: 5000) , '...'].
	string class == String ifFalse: [
		string := String withAll: (string collect: [:each | (32 <= each asciiValue and: [each asciiValue <= 255]) ifTrue: [each] ifFalse: [$?]]).
	].
	^stream 
		nextPutAll: string; 
		contents.
%

category: 'category'
method: JadeServer
inspectDictionary: aDictionary on: aStream

	| keys keyDict |
	keys := self keysForDictionary: aDictionary.
	keyDict := Dictionary new.
	keys do: [:each | 
		| key |
		key := each printString , '~' , (self oopOf: each) printString.
		key := key collect: [:char | char asciiValue < 32 ifTrue: [$?] ifFalse: [char]].
		keyDict
			at: key
			put: each.
	].
	keys size printOn: aStream.
	aStream lf.
	keyDict keys asSortedCollection do: [:each | 
		| index keyString key value valueString |
		index := each findLast: [:char | char = $~].
		keyString := each copyFrom: 1 to: index - 1.
		keyString charSize = 1 ifFalse:[
			keyString := '<<unprintable key. charSize > 1>>']. 
		key := keyDict at: each.
		value := aDictionary at: key. 
		valueString := (self printStringOf: value to: 10).
		valueString charSize = 1 ifFalse:[
			valueString := '<<unprintable value. charSize > 1>>']. 
		aStream nextPutAll: keyString , '->' , valueString; tab.
		self print: (self oopOf: value) on: aStream.
		aStream lf.
	].
	^aStream 
		lf; 
		contents.
%

category: 'category'
method: JadeServer
inspectNamedInstanceVariablesOf: anObject on: aStream

	| list size |
	list := anObject class allInstVarNames.
	size := list size.
	anObject class format > 0 ifTrue: [
		size := size + (anObject _basicSize min: 200).
	].
	size printOn: aStream.
	aStream lf.
	1 to: list size do: [:i | 
		aStream nextPutAll: (list at: i); tab.
		self print: (self oopOf: (anObject instVarAt: i)) on: aStream.
		aStream lf.
	].

%

category: 'category'
method: JadeServer
installTranscript

	| transcript |
	transcript := self objectInBaseNamed: #'Transcript'.

	"If no Transcript object, then install me!"
	(transcript == nil or: [transcript class name == self class name]) ifTrue: [
		UserGlobals at: #'Transcript' put: self.
		System commitTransaction.
		^self.
	].
	
	"Transcript object from Seaside"
	transcript class name = 'TranscriptProxy class' ifTrue: [
		| clientForwarder |
		clientForwarder := ClientForwarder new.
		clientForwarder	clientObject: 2.
		transcript registerTranscriptClientForwarder: clientForwarder.
		^self.
	].

%

category: 'jadeite'
method: JadeServer
interactionHandlerActive
  ^ SessionTemps current at: #'rowanServiceInteractionActive' ifAbsent: [ true ]
%

category: 'category'
method: JadeServer
is32Bit

	^false.

%

category: 'category'
method: JadeServer
isClientForwarder: anObject

	^anObject _class name == #'ClientForwarder'.

%

category: 'category'
method: JadeServer
isPackagePolicyEnabled

	^self gsPackagePolicy notNil
%

category: 'category'
method: JadeServer
isResumableCategory: category number: number context: context

	| exceptionA receiver |
	category == GemStoneError ifTrue: [
		^number // 1000 = 2 or: [number // 1000 = 6].
	].
	(exceptionA := Globals at: #ExceptionA ifAbsent: [nil]) isNil ifTrue: [
		^true.
	].
	receiver := (context _frameContentsAt: 1) at: 8.
	(receiver isKindOf: exceptionA) ifTrue: [
		^receiver isResumable.
	].
	^true.

%

category: 'category'
method: JadeServer
keysForDictionary: aDictionary 

	^aDictionary keys.

%

category: 'category'
method: JadeServer
makeListener

	^nil.

%

category: 'category'
method: JadeServer
mcAddHttpRepository: aString

	| list repositoryClass repository group |
	list := aString subStrings: (Character codePoint: 255).
	(repositoryClass := self mcHttpRepositoryClass) isNil ifTrue: [self error: 'MCHttpRepository not found!'].
	repository := repositoryClass
		location: (list at: 1)
		user: (list at: 2)
		password: (list at: 3).
	(group := self mcRepositoryGroup) isNil ifTrue: [self error: 'MCRepositoryGroup not found!'].
	group addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcAddPackage: aString

	self mcWorkingCopyClass forPackage: (self mcPackageClass named: aString).

%

category: 'category'
method: JadeServer
mcAddRepository: aRepository toPackage: aMCWorkingCopy

	aMCWorkingCopy repositoryGroup addRepository: aRepository.

%

category: 'category'
method: JadeServer
mcAllFileNamesIn: anMCRepository

	| stream |
	stream := WriteStream on: String new.
	anMCRepository allFileNames do: [:each | 
		stream nextPutAll: each; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcAllVersionInfoNamesIn: anMCRepository

	| stream |
	stream := WriteStream on: String new.
	anMCRepository allVersionInfos do: [:each | 
		stream nextPutAll: each name; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcAllVersionNamesInDict: anMCRepository

	| stream list |
	stream := WriteStream on: String new.
	list := anMCRepository dictionary values.
	list := list asSortedCollection: [:a :b | 
		a package name < b package name or: [
		a package name = b package name and: [
		a info date > b info date or: [
		a info date = b info date and: [
		a info time > b info time
	]]]]].
	stream := WriteStream on: String new.
	list do: [:each | 
		stream nextPutAll: each info name; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcClassesInCategory: aString package: aMCWorkingCopy

	| visibleClasses allClasses stream queue |
	visibleClasses := aString isNil ifTrue: [
		aMCWorkingCopy packageInfo classes.
	] ifFalse: [
		aMCWorkingCopy packageInfo classes select: [:each | 
			each _classCategory notNil and: [
			each _classCategory = aString or: [
			aString notNil and: [each _classCategory matchPattern: (Array with: aString with: $*)]]]]
	].
	allClasses := visibleClasses asIdentitySet.
	queue := visibleClasses asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| parent |
		parent := queue removeFirst superclass.
		(parent notNil and: [(allClasses includes: parent) not]) ifTrue: [
			queue add: parent.
			allClasses add: parent.
		].
	].
	stream := WriteStream on: String new.
	allClasses do: [:each |
		self
			_addClass: each 
			toStream: stream 
			isVisible: (visibleClasses includes: each)
			fromDictionary: nil.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcCreationTemplateFor: anMCRepository

	^anMCRepository asCreationTemplate.

%

category: 'category'
method: JadeServer
mcHttpRepository

	^self objectInBaseNamed: #'MCHttpRepository'.

%

category: 'category'
method: JadeServer
mcHttpRepository: aRepository user: userString password: passwordString

	aRepository
		user: userString;
		password: passwordString;
		yourself.

%

category: 'category'
method: JadeServer
mcHttpRepositoryClass

	^self objectInBaseNamed: #'MCHttpRepository'.

%

category: 'category'
method: JadeServer
mcInitials: aString
	"Do initial setup and return useful information"

	| mcPlatformSupport packagePolicyEnabledFlag string x |
	string := 'Jade-' , GsSession currentSession serialNumber printString , '-' , System myUserProfile userId.
	[
		self mcInitialsA: string.
	] whileFalse: [	"Keep shortening it till it fits!"
		string := string copyFrom: 1 to: string size - 1.
	].
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	mcPlatformSupport notNil ifTrue: [mcPlatformSupport setAuthorInitials: aString].
	packagePolicyEnabledFlag := (x := self objectInBaseNamed: #'GsPackagePolicy') isNil ifTrue: ['0'] ifFalse: [x current enabled ifTrue: ['1'] ifFalse: ['0']].
	^System session printString , Character space asString , 
		(GsSession serialOfSession: System session) printString , Character space asString , 
		packagePolicyEnabledFlag

%

category: 'category'
method: JadeServer
mcInitialsA: aString
	"Subclasses provide error handling, typically means string is too long"

	System _cacheName: aString.

%

category: 'category'
method: JadeServer
mcLoadedVersionNames

	| mcWorkingCopyClass stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	stream := WriteStream on: String new.
	mcWorkingCopyClass allManagers do: [:each | 
		| packageOrVersion |
		packageOrVersion := each ancestors
			detect: [:ignored | true]
			ifNone: [each package].
		packageOrVersion := packageOrVersion notNil
			ifTrue: [packageOrVersion name]
			ifFalse: [''].
		stream
			nextPutAll: packageOrVersion; tab;
			nextPut: (each modified ifTrue: [$Y] ifFalse: [$N]); tab;
			nextPutAll: each package name;
			lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcNewDirectoryRepository: aString

	| mcRepositoryClass fileDirectoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCDirectoryRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	(fileDirectoryClass := self objectInBaseNamed: #'FileDirectory') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcNewFileTreeRepository: aString

	| mcRepositoryClass fileDirectoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCFileTreeRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	(fileDirectoryClass := self objectInBaseNamed: #'ServerFileDirectory') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcNewGitHubRepository: aString

	| mcRepositoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCGitHubRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcRepositoryClass location: aString.
	self mcRepositoryGroup addRepository: repository.
	^mcRepositoryClass
%

category: 'category'
method: JadeServer
mcNewServerDirectoryRepository: aString

	| mcDirectoryRepositoryClass fileDirectoryClass repository |
	(mcDirectoryRepositoryClass := self objectInBaseNamed: #'MCServerDirectoryRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	(fileDirectoryClass := self objectInBaseNamed: #'ServerFileDirectory') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcDirectoryRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcPackageClass

	^self objectInBaseNamed: #'MCPackage'.

%

category: 'category'
method: JadeServer
mcPatchFrom: aString1 to: aString2 inFileBasedRepository: aFileRepository

	| index name leftSnapshot rightSnapshot patch |
	index := aString2 findLast: [:each | each = $-].
	name := aString2 copyFrom: 1 to: index - 1.
	(name includes: $.) ifTrue: [name := (name subStrings: $.) first].
	leftSnapshot := aString1 isNil ifTrue: [
		(self mcWorkingCopyClass allManagers detect: [:each | each package name = name]) package snapshot.
	] ifFalse: [
		(aFileRepository versionFromFileNamed: aString1) snapshot.
	].
	rightSnapshot := (aFileRepository versionFromFileNamed: aString2) snapshot.
	patch := rightSnapshot patchRelativeToBase: leftSnapshot.
	^self 
		_mcDescriptionOfPatch: patch
		baseName: aString1
		alternateName: aString2.

%

category: 'category'
method: JadeServer
mcputDefinition: aDefinition on: aStream

	| mcOrganizationDefinitionClass mcClassDefinitionClass mcMethodDefinitionClass |
	(mcOrganizationDefinitionClass := self objectInBaseNamed: 'MCOrganizationDefinition') isNil ifTrue: [^nil].
	(mcClassDefinitionClass := self objectInBaseNamed: 'MCClassDefinitionClass') isNil ifTrue: [^nil].
	(mcMethodDefinitionClass := self objectInBaseNamed: 'MCMethodDefinition') isNil ifTrue: [^nil].

	self _addToPureExportSet: aDefinition.
		aStream nextPutAll: (self oopOf: aDefinition) printString; tab;
			nextPutAll: aDefinition class name; tab.
			
		aDefinition class == mcOrganizationDefinitionClass ifTrue: [
			aDefinition categories do: [:eachCategory | 
				aStream nextPutAll: eachCategory; space]
		] ifFalse: [	aDefinition class == mcClassDefinitionClass ifTrue: [
			aStream
				nextPutAll: aDefinition className; tab;
				nextPutAll: aDefinition superclassName; tab;
				nextPutAll: aDefinition category; tab;
				nextPutAll: aDefinition type; tab;
				yourself.
		] ifFalse: [aDefinition class == mcMethodDefinitionClass ifTrue: [
			aStream
				nextPutAll: aDefinition classIsMeta printString; tab;
				nextPutAll: aDefinition category; tab;
				nextPutAll: aDefinition selector; tab;
				nextPutAll: aDefinition className; tab;
				nextPutAll: aDefinition timeStamp printString; tab]]].
	
	^aStream.
	
%

category: 'category'
method: JadeServer
mcRemoveRepository: aRepository

	| repositoryClass group |
	(repositoryClass := self mcHttpRepositoryClass) isNil ifTrue: [self error: 'MCHttpRepository not found!'].
	(group := self mcRepositoryGroup) isNil ifTrue: [self error: 'MCRepositoryGroup not found!'].
	group removeRepository: aRepository.

%

category: 'category'
method: JadeServer
mcRemoveRepository: aRepository toPackage: aMCWorkingCopy

	aMCWorkingCopy repositoryGroup removeRepository: aRepository.

%

category: 'category'
method: JadeServer
mcRepositoryFrom: aRepository

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aRepository) printOn: stream.
	stream 
		tab;
		nextPutAll: aRepository description;
		tab;
		nextPutAll: aRepository class name;
		tab.
	^stream contents.

%

category: 'category'
method: JadeServer
mcRepositoryGroup

	| groupClass |
	(groupClass := self objectInBaseNamed: 'MCRepositoryGroup') isNil ifTrue: [^nil].
	^groupClass default.

%

category: 'category'
method: JadeServer
mcRepositoryList

	| group stream |
	(group := self mcRepositoryGroup) isNil ifTrue: [^nil].
	stream := WriteStream on: String new.
	group repositories do: [:each | 
		stream nextPutAll: (self mcRepositoryFrom: each).
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcTopazFrom: aString inDictionaryRepository: aDictionaryRepository

	| snapshot stream |
	snapshot := (aDictionaryRepository versionFromVersionNamed: aString) snapshot.
	stream := (WriteStream on: String new)
		nextPutAll: '! ' , aString , ' in ' , aDictionaryRepository printString; lf;
		yourself.
	self
		_mcTopazFrom: snapshot
		on: stream.
	^stream contents.


%

category: 'category'
method: JadeServer
mcTopazFrom: aString inFileRepository: aFileRepository

	| snapshot stream |
	snapshot := (aFileRepository versionFromFileNamed: aString) snapshot.
	stream := (WriteStream on: String new)
		nextPutAll: '! ' , aString , ' in ' , aFileRepository printString; lf;
		yourself.
	self
		_mcTopazFrom: snapshot
		on: stream.
	^stream contents.


%

category: 'category'
method: JadeServer
mcUniqueVersionNameFor: anMCWorkingCopy

	^anMCWorkingCopy uniqueVersionName.

%

category: 'category'
method: JadeServer
mcUserAndPasswordInHTTP: anMCHttpRepository

	^anMCHttpRepository user , Character tab asString , anMCHttpRepository password.

%

category: 'category'
method: JadeServer
mcVersionInfoFrom: aVersionInfo

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aVersionInfo) printOn: stream.
	stream 
		lf; nextPutAll: aVersionInfo name; 
		lf; nextPutAll: aVersionInfo date yyyymmdd;
		lf.
	aVersionInfo time printOn: stream.
	stream 
		lf; nextPutAll: aVersionInfo author; 
		lf; nextPutAll: aVersionInfo id asString;
		lf.
	aVersionInfo ancestors do: [:each | 
		stream nextPutAll: each name; tab.
	].
	stream lf.
	aVersionInfo stepChildren do: [:each | 
		stream nextPutAll: each name; tab.
	].
	stream lf.
	stream nextPutAll: aVersionInfo message.
	^stream contents.

%

category: 'category'
method: JadeServer
mcVersionInfoFromDictionaryPackageNamed: aString in: anMCDictionaryRepository

	| versionInfo |
	(versionInfo := anMCDictionaryRepository versionInfoFromVersionNamed: aString) isNil ifTrue: [^''].
	^self mcVersionInfoFrom: versionInfo.

%

category: 'category'
method: JadeServer
mcVersionInfoFromFileNamed: aString in: anMCFileBasedRepository

	| versionInfo |
	(versionInfo := anMCFileBasedRepository versionInfoFromFileNamed: aString) isNil ifTrue: [^''].
	^self mcVersionInfoFrom: versionInfo.

%

category: 'category'
method: JadeServer
mcVersionLoad: aString fromDictionary: anMCDictionaryRepository autoMigrate: aBoolean

	| version package workingCopy mcPlatformSupport autoMigrate |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCDictionaryRepository versionFromVersionNamed: aString.
	version load.
	package := version package.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	workingCopy repositoryGroup addRepository: anMCDictionaryRepository.
	mcPlatformSupport autoMigrate: autoMigrate.

%

category: 'category'
method: JadeServer
mcVersionLoad: aString fromFile: anMCFileBasedRepository autoMigrate: aBoolean

	| version package workingCopy mcPlatformSupport autoMigrate |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCFileBasedRepository loadVersionFromFileNamed: aString.
	version load.
	package := version package.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	workingCopy repositoryGroup addRepository: anMCFileBasedRepository.
	mcPlatformSupport autoMigrate: autoMigrate.

%

category: 'category'
method: JadeServer
mcVersionNameAndMessageFrom: aMCWorkingCopy

	(aMCWorkingCopy needsSaving or: [aMCWorkingCopy ancestors isEmpty]) ifTrue: [
		^'<new>	<new>'.
	].
	^aMCWorkingCopy currentVersionInfo name , Character tab asString , aMCWorkingCopy currentVersionInfo message.

%

category: 'category'
method: JadeServer
mcwcbWorkingCopies

	| mcWorkingCopyClass list stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	list := mcWorkingCopyClass allManagers.
	list := list asSortedCollection: [:a :b | a package name <= b package name].
	stream := WriteStream on: String new.
	list do: [:each |
		self saveWorkingCopy: each to: stream.
		stream lf].
	^stream contents
%

category: 'category'
method: JadeServer
mcWorkingCopyClass

	^self objectInBaseNamed: #'MCWorkingCopy'.

%

category: 'category'
method: JadeServer
mcWorkingCopyNamed: aString

	| mcWorkingCopyClass workingCopy stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	workingCopy := mcWorkingCopyClass allManagers 
		detect: [:each | each package name = aString]
		ifNone: [^nil].
	stream := WriteStream on: String new.
	self 
		saveWorkingCopy: workingCopy 
		to: stream.
	^stream contents.

%

category: 'category'
method: JadeServer
methodsContaining: aString

	^self streamOfMethods: (self classOrganizer substringSearch: aString) first.

%

category: 'category'
method: JadeServer
methodsFor: childClass upTo: parentClass filter: aString isVariables: aBoolean 

	| filterList answerList aClass stream selectors |
	filterList := (aString subStrings: Character tab) reject: [:each | each isEmpty].
	aBoolean ifTrue: [filterList := (filterList collect: [:each | each asSymbol]) asIdentitySet].
	aClass := childClass.
	answerList := IdentitySet new.
	selectors := IdentitySet new.
	[
		| methods |
		methods := self 
			_methodsFor: aClass
			filter: filterList
			isVariables: aBoolean.
		methods do: [:each | 
			(selectors includes: each selector) ifFalse: [
				answerList add: each.
				selectors add: each selector.
			].
		].
		aClass = parentClass.
	] whileFalse: [
		aClass := aClass superclass.
	].
	stream := WriteStream on: String new.
	answerList do: [:each | self _addMethod: each toStream: stream].
	^stream contents
%

category: 'category'
method: JadeServer
methodSignatureForSelector: aSymbol

	^aSymbol.

%

category: 'category'
method: JadeServer
millisecondsElapsedTime: aBlock

	^Time millisecondsElapsedTime: aBlock.

%

category: 'category'
method: JadeServer
moveClassesInDictionary: sourceDictionary category: aString to: destinationDictionary

	sourceDictionary copy keysAndValuesDo: [:eachKey :eachValue | 
		(eachValue isBehavior and: [eachValue category = aString]) ifTrue: [
			sourceDictionary removeKey: eachKey.
			destinationDictionary
				at: eachKey
				put: eachValue.
		].
	].

%

category: 'category'
method: JadeServer
moveDictionary: source toBefore: target forUser: aUserProfile

	| list |
	list := aUserProfile symbolList.
	list remove: source.
	target notNil ifTrue: [
		list
			add: source 
			before: target.
	] ifFalse: [
		list addLast: source.
	].


%

category: 'category'
method: JadeServer
moveMethod: aGsMethod toCategory: aString
	aGsMethod inClass
		rwMoveMethod: aGsMethod selector
		toCategory: aString.

%

category: 'category'
method: JadeServer
mySessionInfo

	| dict stream |
	stream := WriteStream on: String new.
	stream nextPutAll: self gemLogPath; cr.
	dict := System gemVersionReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	dict := System gemConfigurationReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	^stream contents
%

category: 'category'
method: JadeServer
nameForSharedPool: anObject forUser: aUserProfile

	| anArray dict sharedPoolClass |
	anArray := self dictionaryAndSymbolOf: anObject forUser: aUserProfile.
	anArray notNil ifTrue: [^anArray at: 2].
	(dict := aUserProfile objectNamed: anObject name) isNil ifTrue: [^'???'].
	(sharedPoolClass := self objectNamed: 'SharedPool') isNil ifTrue: [^'???'].
	((dict isKindOf: Class) and: [dict isSubclassOf: sharedPoolClass]) ifTrue: [^anObject name , ' _classVars'].
	^'???'.

%

category: 'category'
method: JadeServer
nameOfFirstDictionaryReferencing: aGlobal

	| list |
	list := self symbolList dictionaryAndSymbolOf: aGlobal.
	list isNil ifTrue: [^''].
	^list first name
%

category: 'category'
method: JadeServer
newUser: aString

	| userProfile stream |
	userProfile := UserProfile 
		newWithUserId: aString
		password: 'swordfish'
		privileges: #()
		inGroups: #().
	stream := WriteStream on: String new.
	self
		addUser: userProfile 
		toStream: stream.
	^stream contents.

%

category: 'category'
method: JadeServer
nextLine

	^readStream upTo: Character lf.

%

category: 'category'
method: JadeServer
nextLineAsList

	^(self nextLine subStrings: Character tab) reject: [:each | each isEmpty].

%

category: 'category'
method: JadeServer
nextPut: aCharacter

	self nextPutAll: aCharacter asString.

%

category: 'category'
method: JadeServer
nextPutAll: anObject

	| string args |
	string := self asString: anObject.
	args := Array
		with: self
		with: 1
		with: #'nextPutAll:'
		with: (Array with: string).
	System
		signal: 2336
		args: args
		signalDictionary: GemStoneError.

%

category: 'category'
method: JadeServer
obConfirmationRequest: anOBConfirmationRequest

	^String new 
		addAll: anOBConfirmationRequest cancelChoice;
		add: Character lf;
		addAll: anOBConfirmationRequest okChoice;
		add: Character lf;
		addAll: anOBConfirmationRequest prompt;
		yourself.

%

category: 'category'
method: JadeServer
obInformRequest: anOBInformRequest

	^anOBInformRequest message
%

category: 'category'
method: JadeServer
objectForOop: anInteger

	self subclassResponsibility.
%

category: 'category'
method: JadeServer
objectInBaseNamed: aString

	^[(SymbolList withAll: self class sharedPools) objectNamed: aString asSymbol] on: Error do: [:ex | ex return: nil].

%

category: 'category'
method: JadeServer
objectNamed: aString

	^System myUserProfile objectNamed: aString asSymbol.

%

category: 'category'
method: JadeServer
objectSecurityPolicyFor: anObject

	^anObject segment.

%

category: 'category'
method: JadeServer
obTextRequest: anOBTextRequest

	| prompt template |
	prompt := anOBTextRequest prompt.
	template := anOBTextRequest template.
	^String new 
		addAll: prompt size printString;
		add: Character lf;
		addAll: prompt;
		addAll: template;
		yourself.

%

category: 'category'
method: JadeServer
oopOf: anObject

	^anObject asOop.

%

category: 'category'
method: JadeServer
packagePolicy: aPackagePolicy includesSelector: aSymbol forClass: aClass

	^aPackagePolicy notNil and: [aPackagePolicy includesSelector: aSymbol for: aClass].

%

category: 'category'
method: JadeServer
postSaveClass: aGsClass activities: aString 

	| gsClass copyMethods migrateInstances recompileSubclasses removeFromClassHistory symbolList list index key oldClass newClass oldNewList stream |
	gsClass := (self historyOf: aGsClass) last.
	list := aString subStrings: Character tab.
	list := list collect: [:each | each = 'true'].
	symbolList := self symbolList.
	copyMethods := list at: 1.
	recompileSubclasses := list at: 2.
	migrateInstances := list at: 3.
	removeFromClassHistory := list at: 4.
	oldNewList := OrderedCollection new.
	stream := WriteStream on: String new.
	oldClass := (self historyOf: gsClass) asArray reverse at: 2.
	oldNewList add: oldClass -> gsClass.
	recompileSubclasses ifTrue: [
		(self classOrganizer allSubclassesOf: oldClass) do: [:each | 
			gsClass := GsSession currentSession execute: each definition.
			oldNewList add: each -> gsClass.
		].
	].
	copyMethods ifTrue: [
		oldNewList do: [:eachAssoc | 
			oldClass := eachAssoc key.
			newClass := eachAssoc value.
			index := symbolList findFirst: [:eachDict | eachDict includes: newClass].
			index = 0 ifTrue: [self error: 'Where did the class go?'].
			key := (symbolList at: index) keyAtValue: newClass.
			list := newClass copyMethodsFrom: oldClass dictionaries: symbolList.
			list do: [:eachMethod | 
				stream
					nextPutAll: 'method'; tab;
					nextPutAll: index printString; tab;
					nextPutAll: key; tab;
					nextPutAll: eachMethod selector; lf;
					yourself]]].
	migrateInstances ifTrue: [
		System commitTransaction ifFalse: [self error: 'commit failed!'].
		oldNewList do: [:eachAssoc | 
			oldClass := eachAssoc key.
			newClass := eachAssoc value.
			list := oldClass migrateInstancesTo: newClass.
			list do: [:each | 
				each notEmpty ifTrue: [
					stream
						nextPutAll: 'migrate'; tab;
						nextPutAll: newClass name; tab;
						nextPutAll: each size printString; lf;
						yourself.
				].
			].
		].
	].
	removeFromClassHistory ifTrue: [
		oldNewList do: [:eachAssoc | 
			newClass := eachAssoc value.
			((self historyOf: newClass) asArray copyFrom: 1 to: (self historyOf: newClass) size - 1) do: [:each | 
				(self historyOf: newClass) removeVersion: each.
			].
		].
	].
	^stream contents.

%

category: 'category'
method: JadeServer
print: anObject on: aStream
	"convert multi-byte strings to single-byte"

	| string |
	string := self printStringOf: anObject.
	string class == String ifFalse: [
		string := String withAll: (string collect: [:each | (32 <= each asciiValue and: [each asciiValue <= 255]) ifTrue: [each] ifFalse: [$?]]).
	].
	aStream nextPutAll: string.

%

category: 'category'
method: JadeServer
printStringOf: anObject

	^anObject printString.
%

category: 'category'
method: JadeServer
printStringOf: anObject to: anInteger

	| string |
	(string := self printStringOf: anObject) size > anInteger ifTrue: [string := (string copyFrom: 1 to: anInteger) , '...'].
	string := String withAll: (string collect: [:each | (32 <= each asciiValue and: [each asciiValue <= 255]) ifTrue: [each] ifFalse: [$?]]).
	^string.
%

category: 'category'
method: JadeServer
privilegeListFor: aUserProfile

	| allPrivileges myPrivileges stream |
	allPrivileges := (aUserProfile class instVarAt: 6) at: #'PrivilegeNames'.
	myPrivileges := aUserProfile privileges.
	stream := WriteStream on: String new.
	allPrivileges do: [:each | 
		stream nextPutAll: each; tab.
		(myPrivileges includes: each) printOn: stream.
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
processes

	| scheduler stream |
	scheduler := ProcessorScheduler scheduler.
	stream := (WriteStream on: String new)
		nextPutAll: 'highestPriority'; 			space; nextPutAll: scheduler highestPriority 			printString; tab;
		nextPutAll: 'highIOPriority'; 			space; nextPutAll: scheduler highIOPriority 			printString; tab;
		nextPutAll: 'lowestPriority'; 			space; nextPutAll: scheduler lowestPriority 				printString; tab;
		nextPutAll: 'lowIOPriority'; 				space; nextPutAll: scheduler lowIOPriority 				printString; tab;
		nextPutAll: 'systemBackgroundPriority'; 	space; nextPutAll: scheduler systemBackgroundPriority 	printString; tab;
		nextPutAll: 'timingPriority'; 			space; nextPutAll: scheduler timingPriority 			printString; tab;
		nextPutAll: 'userBackgroundPriority'; 		space; nextPutAll: scheduler userBackgroundPriority 		printString; tab;
		nextPutAll: 'userInterruptPriority'; 		space; nextPutAll: scheduler userInterruptPriority 		printString; tab;
		nextPutAll: 'userSchedulingPriority'; 		space; nextPutAll: scheduler userSchedulingPriority 		printString; tab;
		yourself.
	scheduler readyProcesses 		do: [:each | self addProcess: each to: stream withStatus: 'ready'		scheduler: scheduler].
	scheduler suspendedProcesses 	do: [:each | self addProcess: each to: stream withStatus: 'suspended'	scheduler: scheduler].
	self waitingProcesses			do: [:each | self addProcess: each to: stream withStatus: 'waiting'	scheduler: scheduler].
	^stream contents.


%

category: 'category'
method: JadeServer
referencesToObject: anObject

	^self streamOfMethods: (self classOrganizer referencesToObject: anObject).

%

category: 'category'
method: JadeServer
registerOBNotifications

	| platform clientForwarder |
	(platform := self objectInBaseNamed: #'OBGemStonePlatform') isNil ifTrue: [^self].
	clientForwarder := ClientForwarder new.
	clientForwarder	clientObject: 1.
	self
		registerOBNotificationsForPlatform: platform 
		clientForwarder: clientForwarder.

%

category: 'category'
method: JadeServer
registerOBNotificationsForPlatform: platform clientForwarder: clientForwarder

	platform 
		registerBrowseClientForwarder: clientForwarder;
		registerChoiceClientForwarder: clientForwarder;
		registerCloseClientForwarder: clientForwarder;
		registerConfirmationClientForwarder: clientForwarder;
		registerInformClientForwarder: clientForwarder;
		registerMultiLineTextClientForwarder: clientForwarder;
		registerTextClientForwarder: clientForwarder;
		yourself.

%

category: 'category'
method: JadeServer
removeCategory: aString fromBehavior: aBehavior

	aBehavior rwRemoveCategory: aString.

%

category: 'category'
method: JadeServer
removeClass: aClass from: aDictionary

	| key |
	key := aDictionary
		keyAtValue: aClass
		ifAbsent: [^false].
	aDictionary removeKey: key.
	^true.

%

category: 'category'
method: JadeServer
removeDictionary: aDictionary fromUser: aUserProfile

	| symbolList index |
	symbolList := aUserProfile symbolList.
	index := symbolList indexOf: aDictionary.
	aUserProfile removeDictionaryAt: index.

%

category: 'category'
method: JadeServer
removeGroup: aString fromUser: aUserProfile

	aUserProfile removeGroup: aString.

%

category: 'category'
method: JadeServer
removeKey: aString fromSymbolDictionary: aSymbolDictionary

	aSymbolDictionary removeKey: aString asSymbol.


%

category: 'category'
method: JadeServer
removeMethod: aGsMethod

	aGsMethod inClass removeSelector: aGsMethod selector.

%

category: 'category'
method: JadeServer
removePriorVersionsOf: aClass

	[
		1 < (self historyOf: aClass) size.
	] whileTrue: [
		(self historyOf: aClass) removeVersion: (self historyOf: aClass) first.
	].

%

category: 'category'
method: JadeServer
removePrivilege: aString fromUser: aUserProfile

	aUserProfile deletePrivilege: aString.

%

category: 'category'
method: JadeServer
renameCategory: oldString to: newString inBehavior: aBehavior

	aBehavior
		renameCategory: oldString asSymbol
		to: newString.

%

category: 'category'
method: JadeServer
reset
	"WriteStream protocol"
%

category: 'category'
method: JadeServer
runAsTest: aGsMethod

	aGsMethod inClass debug: aGsMethod selector.
	^true.

%

category: 'category'
method: JadeServer
runTestNamed: testName in: gsClass
	"The receiver run the test named <testName> of GemStone/S class named <gsClass>"
	| testResult |

	testResult := (self objectNamed: gsClass) run: testName asSymbol.

	^testResult errorCount printString, ',' ,testResult failureCount printString, ',', testResult passedCount printString
%

category: 'category'
method: JadeServer
runTestsNamed: testCollection in: gsClass
	"NO SENDERS"
	"The receiver run the all test of the collection <testCollection> of GemStone/S class named <gsClass>"
	| testResult |

	testResult := ((self objectNamed: gsClass) buildSuiteFromMethods: testCollection) run.

"	stream := WriteStream on: String new.
	testResult failures do: [:each | stream nextPutAll: ',', 'F_', each selector].
	testResult errors do: [:each | stream nextPutAll: ',', 'E_', each selector].
	testResult passed do: [:each | stream nextPutAll: ',', 'P_', each selector].

	^stream contents"

	^testResult printString
%

category: 'category'
method: JadeServer
saveWorkingCopy: wc to: stream

	self _addToPureExportSet: wc.
	stream
		nextPutAll: (self oopOf: wc) printString; tab;
		nextPutAll: wc package name; tab;
		nextPutAll: wc modified printString; tab;
		nextPutAll: wc ancestors size printString; tab;
		yourself.
	wc ancestors do: [:ancestor |
		self _addToPureExportSet: ancestor.
		(self oopOf: ancestor) printOn: stream.
		stream tab.
	].
	stream nextPutAll: wc repositoryGroup repositories size printString; tab.
	wc repositoryGroup repositories do: [:repository |
		self _addToPureExportSet: repository.
		(self oopOf: repository) printOn: stream.
		stream tab.
	].

%

category: 'category'
method: JadeServer
sbAddDictionary: anOrderedCollection

	| currentName newName symbolList index |
	symbolList := self symbolList.
	newName := anOrderedCollection removeFirst.
	anOrderedCollection notEmpty ifTrue: [
		currentName := anOrderedCollection removeFirst asSymbol.
		index := symbolList findFirst: [:each | each name = currentName].
	] ifFalse: [
		index := symbolList size + 1.
	].
	symbolList
		createDictionaryNamed: newName
		at: index.
	selections at: #'dictionary' put: newName.
	self systemBrowserUpdate.
%

category: 'category'
method: JadeServer
sbAddMethodCategory: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) addCategory: anOrderedCollection first.
	selections at: #'methodCategory' put: anOrderedCollection first.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbAddMissingAccessors: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) compileMissingAccessingMethods.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbAddNameOf: aClass

	writeStream nextPutAll: aClass name.
	1 < (self historyOf: aClass) size ifTrue: [
		writeStream nextPutAll: ' ('.
		((self historyOf: aClass) indexOf: aClass) printOn: writeStream.
		writeStream nextPut: $/.
		(self historyOf: aClass) size printOn: writeStream.
		writeStream nextPut: $).
	].
	writeStream tab.

%

category: 'category'
method: JadeServer
sbAddRepository: list

	| description repository packages |
	description := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = description].
	packages := self mcWorkingCopyClass allManagers select: [:each | list includes: each package name].
	packages do: [:each | each repositoryGroup addRepository: repository].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbBreak: anOrderedCollection

	| myClass gsMethod stepPoint |
	myClass := self sbClassFrom: anOrderedCollection.
	gsMethod := self compiledMethodAt: anOrderedCollection removeFirst asSymbol inClass: myClass.
	stepPoint := anOrderedCollection removeFirst asNumber.
	anOrderedCollection removeFirst = 'set' ifTrue: [
		gsMethod setBreakAtStepPoint: stepPoint.
	] ifFalse: [
		gsMethod clearBreakAtStepPoint: stepPoint.
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbBrowseClassReferences: anOrderedCollection

	| class |
	class := (self sbClassFrom: anOrderedCollection) thisClass.
	writeStream 
		nextPutAll: 'browseClassReferences'; lf;
		nextPutAll: (self referencesToObject: class); 
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseGlobalReferences: anOrderedCollection

	| global |
	global := self objectForOop: anOrderedCollection removeFirst asNumber.
	writeStream 
		nextPutAll: 'browseGlobalReferences'; lf;
		nextPutAll: (self referencesToObject: global); 
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseImplementors: anOrderedCollection

	writeStream 
		nextPutAll: 'browseImplementors'; lf;
		nextPutAll: (self implementorsOf: anOrderedCollection removeFirst);
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseMethodsContaining: anOrderedCollection

	writeStream 
		nextPutAll: 'browseMethodsContaining'; lf;
		nextPutAll: (self methodsContaining: anOrderedCollection removeFirst);
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseMethodsWithPragma: anOrderedCollection

	writeStream 
		nextPutAll: 'browseMethodsWithPragma'; lf;
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseSenders: anOrderedCollection

	writeStream 
		nextPutAll: 'browseSenders'; lf;
		nextPutAll: (self sendersOf: anOrderedCollection removeFirst);
		yourself.

%

category: 'category'
method: JadeServer
sbChangeClassName: aList

	| oldName class newName changedIn |
	oldName := aList removeFirst asSymbol.
	class := self objectForOop: aList removeFirst asNumber.
	class name == oldName ifFalse: [self error: 'Current name is ' , class name printString].
	newName := aList removeFirst asSymbol.
	class changeNameTo: newName.
	changedIn := OrderedCollection new.
	self symbolList do: [:each | 
		(each includes: class) ifTrue: [
			(each at: oldName ifAbsent: [nil]) == class ifFalse: [self error: 'Class not at name!'].
			(each includesKey: newName) ifTrue: [self error: 'Key already in use!'].
			each
				removeKey: oldName;
				at: newName put: class;
				yourself.
			changedIn add: each.
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbChangesInPackage: anOrderedCollection
	"where anOrderedCollection is {packageName, projectName}"

	self error: 'this message is no longer supported'
%

category: 'category'
method: JadeServer
sbCheckUniqueClassName: aList

	| oldName class newName |
	oldName := aList removeFirst asSymbol.
	class := self objectForOop: aList removeFirst asNumber.
	class name == oldName ifFalse: [
		writeStream nextPutAll: 'Current name is ' , class name printString. 
		^self.
	].
	newName := aList removeFirst asSymbol.
	self symbolList do: [:each | 
		((each includes: class) and: [each includesKey: newName]) ifTrue: [
			writeStream nextPutAll: 'Dictionary '.
			each name printOn: writeStream.
			writeStream nextPutAll: ' already has a global with name '.
			newName printOn: writeStream.
			^self.
		].
	].
	
%

category: 'category'
method: JadeServer
sbClass: aList

	| string newClass mcWorkingCopyClass packages dictName |
	string := aList first.
	newClass := string evaluate.
	self classOrganizer update.
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [
		packages := Array with: nil.
	] ifFalse: [
		packages := mcWorkingCopyClass allManagers collect: [:each | each package name].
		packages := packages select: [:each | (newClass category copyFrom: 1 to: (newClass category size min: each size)) = each].
		packages isEmpty ifTrue: [
			packages := Array with: nil.
		].
	].
	dictName := (newClass class canUnderstand: #'symbolDictionaryName')
		ifTrue: [newClass symbolDictionaryName]
		ifFalse: [
			| array |
			array := self dictionaryAndSymbolOf: newClass.
			array isNil
				ifTrue: ['UserGlobals']
				ifFalse: [array first name]].
	selections 
		at: #'package' 		put: packages first;
		at: #'dictionary' 		put: dictName asString;
		at: #'category' 		put: newClass category;
		at: #'className'	put: newClass name;
		at: #'class'				put: newClass;
		yourself.
	selectedClass := newClass.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbClassCategory: aList

	| category classes |
	category := aList removeFirst.
	category := category copyFrom: 1 to: category size - 1.
	classes := aList removeFirst subStrings reject: [:each | each isEmpty].
	classes := classes collect: [:each | self objectNamed: each asSymbol].
	classes := classes collect: [:each | each thisClass].
	classes do: [:each | each category: category].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbClassComment: anOrderedCollection

	| class doc txt |
	class := (self sbClassFrom: anOrderedCollection) thisClass.
	doc := (self objectInBaseNamed: #'GsClassDocumentation') newForClass: self.
	txt := (self objectInBaseNamed: #'GsDocText') new details: self sbNextParagraph trimSeparators.
	doc documentClassWith: txt.
	class rwComment: doc.
	self systemBrowserUpdate.
%

category: 'category'
method: JadeServer
sbClassesToDictionary: anOrderedCollection

	| action targetName target sourceNames sources classNames |
	action := anOrderedCollection removeFirst.
	targetName := anOrderedCollection removeFirst asSymbol.
	target := self symbolList detect: [:each | each name = targetName].
	sourceNames := self nextLineAsList collect: [:each | each asSymbol].
	sources := sourceNames collect: [:eachName | self symbolList detect: [:eachDictionary | eachDictionary name = eachName]].
	classNames := self nextLineAsList collect: [:each | each asSymbol].
	classNames do: [:eachName | 
		| source class |
		source := sources detect: [:eachDict | 
			class := eachDict detect: [:eachGlobal | eachGlobal isBehavior and: [eachGlobal name = eachName]] ifNone: [nil].
			class notNil.
		].
		target at: class name put: class.
		action = 'move' ifTrue: [source removeKey: class name].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbClassFrom: anOrderedCollection

	| selectedClassName selectedClassOop set myClass |
	selectedClassName := (anOrderedCollection removeFirst subStrings: Character space) first.
	selectedClassOop := anOrderedCollection removeFirst asNumber.
	set := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal |
			eachGlobal isBehavior ifTrue: [
				set addAll: (self historyOf: eachGlobal).
			].
		].
	].
	myClass := set detect: [:each | (self oopOf: each) = selectedClassOop].
	myClass name asString = selectedClassName ifFalse: [self error: 'Class not found!'].
	anOrderedCollection removeFirst = 'classTab' ifTrue: [myClass := myClass class].
	^myClass.

%

category: 'category'
method: JadeServer
sbComparePackages: anOrderedCollection

	| current ancestor repository patch string |
	current := self mcWorkingCopyClass forPackage: (self mcPackageClass named: anOrderedCollection removeFirst).
	ancestor := anOrderedCollection removeFirst.
	repository := anOrderedCollection removeFirst.
	repository := current repositoryGroup repositories detect: [:each | each description = repository].
	ancestor := repository class name = #'MCDictionaryRepository'
		ifTrue: [repository versionFromVersionNamed: ancestor]
		ifFalse: [repository versionFromFileNamed: ancestor , '.mcz'].
	patch := current package snapshot patchRelativeToBase: ancestor snapshot.
	string := self 
		_mcDescriptionOfPatch: patch
		baseName: ancestor info name
		alternateName: nil.
	writeStream 
		nextPutAll: 'comparePackages'; lf;
		nextPutAll: string;
		yourself.

%

category: 'category'
method: JadeServer
sbCopyMethodsFor: newClass

	| history oldClass symbolList |
	newClass isMeta ifFalse: [self sbCopyMethodsFor: newClass class].
	history := self historyOf: newClass thisClass.
	oldClass := history at: history size - 1.
	newClass isMeta ifTrue: [oldClass := oldClass class].
	symbolList := self symbolList.
	oldClass selectors do: [:each | 
		| source category errors |
		source := (self compiledMethodAt: each inClass: oldClass) sourceString.
		category := self _behavior: oldClass categoryOfSelector: each.
		errors := newClass 
			compileMethod: source
			dictionaries: symbolList
			category: category.
		errors notNil ifTrue: [
			writeStream
				nextPutAll: 'compileError'; lf;
				nextPutAll: newClass name; tab;
				nextPutAll: category; lf;
				nextPutAll: source; lf;
				nextPut: $%; lf;
				yourself.
			newClass removeSelector: each ifAbsent: [].
		].
	].

%

category: 'category'
method: JadeServer
sbFileOutClass: anOrderedCollection

	writeStream nextPutAll: (self sbClassFrom: anOrderedCollection) thisClass fileOutClass.

%

category: 'category'
method: JadeServer
sbFileOutDictionary: anOrderedCollection

	| dictionary |
	dictionary := self objectNamed: anOrderedCollection first.
	writeStream nextPutAll: '! ------- Create dictionary if it is not present
run
| aSymbol names userProfile |
aSymbol := ' , dictionary name printString , '.
userProfile := System myUserProfile.
names := userProfile symbolList names.
(names includes: aSymbol) ifFalse: [
	| symbolDictionary |
	symbolDictionary := SymbolDictionary new name: aSymbol; yourself.
	userProfile insertDictionary: symbolDictionary at: names size + 1.
].
' , '%
'.
	self classOrganizer
		fileOutClassesAndMethodsInDictionary: dictionary
		on: writeStream.

%

category: 'category'
method: JadeServer
sbFileOutMethod: anOrderedCollection

	| aClass |
	aClass := (self sbClassFrom: anOrderedCollection) thisClass.
	writeStream nextPutAll: aClass fileOutMethod: anOrderedCollection removeFirst.

%

category: 'category'
method: JadeServer
sbFindClass

	| classToPackageMap |
	classToPackageMap := self sbFindClassPackageMap.
	self symbolList do: [:eachDict | 
		| name |
		name := eachDict name.
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				| category |
				category := eachGlobal category.
				category isNil ifTrue: [category := ''].
"1"			self sbAddNameOf: eachGlobal.
				writeStream
"2"				nextPutAll: name; tab;
"3"				nextPutAll: category; tab;		"Class category"
"4"				nextPutAll: (classToPackageMap at: eachGlobal ifAbsent: ['']); tab;		"Package name if available"
					lf.
			].
		].
	].

%

category: 'category'
method: JadeServer
sbFindClassPackageMap

	| systemOrganizerClass mcWorkingCopyClass dictionary packageInfoList |
	dictionary := Dictionary new.
	(systemOrganizerClass := self objectInBaseNamed: #'SystemOrganizer') isNil ifTrue: [^dictionary].
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^dictionary].
	packageInfoList := mcWorkingCopyClass allManagers collect: [:each | each packageInfo].
	systemOrganizerClass new categoryDict keysAndValuesDo: [:catName :classes |
		| symbol packageInfo |
		symbol := catName asSymbol.
		packageInfo := packageInfoList detect: [:each | each includesSystemCategory: symbol] ifNone: [nil].
		packageInfo notNil ifTrue: [
			| name |
			name := packageInfo name.
			classes do: [:each | dictionary at: each put: name].
		].
	].
	^dictionary.

%

category: 'category'
method: JadeServer
sbFindSelectors: anOrderedCollection

	| allSymbols pattern |
	pattern := (anOrderedCollection collect: [:each | each = '*' ifTrue: [$*] ifFalse: [each]]) asArray.
	allSymbols := ((AllUsers userWithId: #SymbolUser ifAbsent: [AllUsers userWithId: #DataCurator]) resolveSymbol: #AllSymbols) value.
	allSymbols := allSymbols select: [:each |each asUppercase matchPattern: pattern].
	allSymbols := allSymbols select: [:each | (self classOrganizer implementorsOf: each) notEmpty].
	allSymbols := allSymbols asSortedCollection.
	allSymbols do: [:each | writeStream nextPutAll: each; nextPut: Character lf; yourself].

%

category: 'category'
method: JadeServer
sbInstVarsOldParent: oldParent newParent: newParent oldChild: oldChild

	| added removed newList used missing |
	added := newParent allInstVarNames asIdentitySet - oldParent allInstVarNames asIdentitySet.
	removed := oldParent allInstVarNames asIdentitySet - newParent allInstVarNames asIdentitySet.
	newList := oldChild instVarNames.
	used := IdentitySet new.
	(oldChild class canUnderstand: #'_methodDict') ifTrue: [
		oldChild _methodDict do: [:each | used addAll: each instVarsAccessed].
	].
	(oldChild class canUnderstand: #'persistentMethodDictsDo:') ifTrue: [
		oldChild persistentMethodDictsDo: [:eachDict | 
			eachDict do: [:eachMethod | 
				used addAll: eachMethod instVarsAccessed.
			].
		].
	].
	used := used * removed.	"Only interested in things that have been removed."
	missing := (used - newList asIdentitySet) asSortedCollection asArray.
	newList := newList , missing.
	newList := newList reject: [:each | added includes: each].
	^newList.

%

category: 'category'
method: JadeServer
sbListMethodPragmas
	"none before 3x"

%

category: 'category'
method: JadeServer
sbLoadLatestVersionOfConfiguration: anOrderedCollection

	anOrderedCollection do: [:each | 
		(self objectNamed: each) project latestVersion load.
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbMethodCategory: anOrderedCollection
	| behavior category |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection removeFirst.
	anOrderedCollection do: [:each | behavior rwMoveMethod: each asSymbol toCategory: category].
	self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbMethodClass: anOrderedCollection
	"Drag/drop method onto class"

	| sourceBehavior action targetName set target |
	sourceBehavior := self sbClassFrom: anOrderedCollection.
	action := anOrderedCollection removeFirst.
	targetName := anOrderedCollection removeFirst asSymbol.
	set := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			(eachGlobal isBehavior and: [eachGlobal name = targetName]) ifTrue: [set add: eachGlobal].
		].
	].
	1 < set size ifTrue: [self error: 'Target name is ambiguous!'].
	1 = set size ifFalse: [self error: 'Target not found!'].
	target := set asArray first.
	sourceBehavior isMeta ifTrue: [target := target class].
	anOrderedCollection do: [:each | 
		| gsMethod result |
		gsMethod := self compiledMethodAt: each asSymbol inClass: sourceBehavior.
		result := self		"key: GsNMethod value: (Array withAll: errors and warnings)"
				compileMethod: gsMethod sourceString
				behavior: target
				symbolList: self symbolList 
				inCategory: (self _behavior: sourceBehavior categoryOfSelector: gsMethod selector).
		(result key notNil and: [action = 'move']) ifTrue: [
			sourceBehavior removeSelector: gsMethod selector.
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbMigrateAll: aClass

	| mcPlatformSupport classes instances |
	((mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport') notNil and: [mcPlatformSupport autoMigrate]) ifTrue: [^self].
	System commitTransaction ifFalse: [self error: 'commit failed!'].
	classes := (ClassOrganizer new allSubclassesOf: aClass) 
		inject: (IdentitySet withAll: (self historyOf: aClass))
		into: [:set :each | set addAll: (self historyOf: each); yourself].
	classes := classes asArray.
	instances := (self objectInBaseNamed: #'SystemRepository') listInstances: classes.
	1 to: classes size do: [:i | 
		| class |
		class := classes at: i.
		class 
			migrateInstances: (instances at: i) 
			to: (self historyOf: class) last.
		System commitTransaction ifFalse: [self error: 'commit failed!'].
	].

%

category: 'category'
method: JadeServer
sbNextParagraph

	| stream |
	stream := WriteStream on: String new.
	[
		readStream peek = $%.
	] whileFalse: [
		stream nextPutAll: self nextLine; lf.
	].
	self nextLine.
	^stream contents.

%

category: 'category'
method: JadeServer
sbObjectLog: anOrderedCollection

	| command priorities class log debuggerLogEntryClass | 
	(class := self objectInBaseNamed: #'ObjectLogEntry') isNil ifTrue: [^self].
	debuggerLogEntryClass := self objectInBaseNamed: #'DebuggerLogEntry'.
	(command := anOrderedCollection removeFirst) = 'delete' ifTrue: [
		anOrderedCollection do: [:each | 			| oop entry |
			oop := each asNumber.			entry := class objectLog detect: [:each2 | (self oopOf: each2) = oop] ifNone: [nil].			entry notNil ifTrue: [class objectLog remove: entry].
		].
		^self systemBrowserCommand.
	].
	writeStream nextPutAll: 'objectLog'; lf.
	priorities := anOrderedCollection removeFirst asArray collect: [:each | each asString asNumber].
	log := class objectLog select: [:each | priorities includes: each priority].
	log reverseDo: [:each | 
		| labelString objectString |
		objectString := String withAll: (each objectString asArray collect: [:char | 
			char asciiValue < 32 ifTrue: [Character space] ifFalse: [
			127 < char asciiValue ifTrue: [$?] ifFalse: [char]]]).
		500 < objectString size ifTrue: [objectString := (objectString copyFrom: 1 to: 500) , '...'].
		each label = each object printString ifTrue: [
			labelString := ''.
		] ifFalse: [
			labelString := String withAll: (each labelString asArray collect: [:char | 
				char asciiValue < 32 ifTrue: [Character space] ifFalse: [
				127 < char asciiValue ifTrue: [$?] ifFalse: [char]]]).
			500 < labelString size ifTrue: [labelString := (labelString copyFrom: 1 to: 500) , '...'].
		].
"1"	(self oopOf: each) printOn: writeStream.
"2"	writeStream tab; nextPutAll: each class name; tab.
"3"	each pid printOn: writeStream. 
		writeStream tab.
"4"	each stamp rounded printOn: writeStream.
"5"	writeStream tab; nextPutAll: labelString; tab.
"6"	each priority printOn: writeStream.
		writeStream tab.
"7"	each tag printOn: writeStream.
"8"	writeStream tab; nextPutAll: objectString; tab.
		(debuggerLogEntryClass notNil and: [each isKindOf: debuggerLogEntryClass]) ifTrue: [
"9"		(self oopOf: each continuation) printOn: writeStream.
		] ifFalse: [
			writeStream nextPutAll: '0'.
		].
		writeStream lf.
	].

%

category: 'category'
method: JadeServer
sbPostSaveClass: anOrderedCollection
	"this has been Rowanized"

	self systemBrowserUpdate 
%

category: 'category'
method: JadeServer
sbReadMethodFilter

	| pieces |
	pieces := self nextLine subStrings: Character tab.
	methodFilterType := pieces at: 1.
	methodCommandResult type: methodFilterType.
	methodCommandResult writeTypeTo: writeStream

%

category: 'category'
method: JadeServer
sbRecompileSubclassesOf: newClass andCopyMethods: aBoolean

	| history oldClass symbolList list |
	history := self historyOf: newClass thisClass.
	oldClass := history at: history size - 1.
	symbolList := self symbolList.
	list := self classOrganizer subclassesOf: oldClass.
	list do: [:oldSubclass |
		| instVars classInstVars definition string newSubclass i j |
		instVars := self sbInstVarsOldParent: oldClass newParent: newClass oldChild: oldSubclass.
		classInstVars := self sbInstVarsOldParent: oldClass class newParent: newClass class oldChild: oldSubclass class.

		definition := oldSubclass definition.
		0 < (i := definition findString: 'instVarNames:' startingAt: 1) ifTrue: [
			j := definition indexOf: Character lf startingAt: i.
			string := String withAll: 'instVarNames: #('.
			instVars do: [:each | string addAll: each; add: Character space].
			string add: $).
			definition := (definition copyFrom: 1 to: i - 1) , string , (definition copyFrom: j to: definition size).
		].
		0 < (i := definition findString: 'classInstVars:' startingAt: 1) ifTrue: [
			j := definition indexOf: Character lf startingAt: i.
			string := String withAll: 'classInstVars: #('.
			classInstVars do: [:each | string addAll: each; add: Character space].
			string add: $).
			definition := (definition copyFrom: 1 to: i - 1) , string , (definition copyFrom: j to: definition size).
		].
		newSubclass := definition evaluate.
		aBoolean ifTrue: [self sbCopyMethodsFor: newSubclass].
		self classOrganizer update.
	].

%

category: 'category'
method: JadeServer
sbRemoveClasses
	| containers classNames |
	self nextLine = 'packageList'. "ignore this" 
	containers := self nextLineAsList.
	classNames := (self nextLineAsList reject: [:each | each isEmpty])
				collect: [:each | (each subStrings: Character space) first asSymbol].
	containers do: 
			[:packageName |
			classNames
				do: [:className | (Rowan packageServiceClass forPackageNamed: packageName) removeClassNamed: className]].
	^self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbRemoveDictionaries: anOrderedCollection

	anOrderedCollection do: [:each | 
		self symbolList removeDictionaryNamed: each asSymbol.
	].
	self systemBrowserUpdate.
%

category: 'category'
method: JadeServer
sbRemoveGlobals

	| symbolList dictionaries globals |
	symbolList := self symbolList.
	dictionaries := self nextLineAsList collect: [:each | each asSymbol].
	dictionaries := dictionaries collect: [:eachName | symbolList detect: [:eachDict | eachDict name = eachName]].
	globals := self nextLineAsList collect: [:each | each asSymbol].
	dictionaries do: [:eachDict | 
		globals do: [:eachKey | 
			eachDict removeKey: eachKey ifAbsent: [].
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRemoveHistory: aClass

	(ClassOrganizer new allSubclassesOf: aClass) asArray , (Array with: aClass) do: [:eachNewClass | 
		(self historyOf: eachNewClass) asArray do: [:eachClass | 
			eachClass ~~ eachNewClass ifTrue: [
				(self historyOf: eachNewClass) removeVersion: eachClass.
			].
		].
	].

%

category: 'category'
method: JadeServer
sbRemoveKey: aSymbol fromDictionary: aDictionary

	aDictionary removeKey: aSymbol.

%

category: 'category'
method: JadeServer
sbRemoveMethodCategories: anOrderedCollection

	| behavior |
	behavior := self sbClassFrom: anOrderedCollection.
	anOrderedCollection do: [:each | behavior rwRemoveCategory: each].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRemoveMethods: anOrderedCollection
	| behavior classEntity  notRemoved|
	behavior := self sbClassFrom: anOrderedCollection.
	classEntity := Rowan classServiceClass forClassNamed: behavior name meta: behavior isMeta.
	notRemoved := Array new. 
	anOrderedCollection do: [:each | classEntity removeSelector: each asSymbol ifAbsent: [notRemoved add: each]].
	self systemBrowserUpdate.
	notRemoved isEmpty ifFalse:[self error: 'The following selectors were not removed. Possibly in a superclass? ', notRemoved printString].
%

category: 'category'
method: JadeServer
sbRemovePriorVersions

	| isPackages containers classNames |
	isPackages := self nextLine = 'packageList'.
	containers := self nextLineAsList.
	classNames := (self nextLineAsList reject: [:each | each isEmpty]) collect: [:each | (each subStrings: Character space) first asSymbol].
	self symbolList do: [:eachDictionary | 
		| dictionaryName |
		dictionaryName := eachDictionary name asString.
		classNames do: [:eachName |
			| class flag |
			(class := eachDictionary at: eachName ifAbsent: [nil]) notNil ifTrue: [
				isPackages ifTrue: [
					flag := false.
					containers do: [:each | flag := flag or: [(class category copyFrom: 1 to: (class category size min: each size)) = each]].
				] ifFalse: [
					flag := containers includes: dictionaryName.
				].
				flag ifTrue: [
					| classHistory |
					classHistory := self historyOf: class.
					classHistory size - 1 timesRepeat: [
						classHistory removeVersion: classHistory first.
					].
				].
			].
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRevertClass

	| isPackages container className |
	isPackages := self nextLine = 'packageList'.
	container := self nextLine trimSeparators.
	className := self nextLine trimSeparators.
	self symbolList do: [:eachDictionary | 
		| dictionaryName class flag |
		dictionaryName := eachDictionary name asString.
		(class := eachDictionary at: className ifAbsent: [nil]) notNil ifTrue: [
			isPackages ifTrue: [
				flag := (class category copyFrom: 1 to: (class category size min: container size)) = container.
			] ifFalse: [
				flag := container = dictionaryName.
			].
			flag ifTrue: [
				| history |
				history := class classHistory.
				(class == history last and: [1 < history size]) ifFalse: [self error: 'Unexpected class history!'].
				history removeVersion: class.
				class := history last.
				eachDictionary at: class name put: class.
			].
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRunClassTests: aString

	| behavior |
	behavior := self sbClassFrom: (aString subStrings: Character tab).
	^self defectiveTestsIn: behavior.

%

category: 'category'
method: JadeServer
sbRunMethodTests: aString

	| list class |
	list := aString subStrings: Character tab.
	class := (self sbClassFrom: list) thisClass.
	list do: [:each | class debug: each asSymbol].
	^true.

%

category: 'category'
method: JadeServer
sbSaveMethod: anOrderedCollection
	"Save in method editor"

	| behavior category string association gsMethod |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection notEmpty ifTrue: [anOrderedCollection removeFirst] ifFalse: ['other'].
	string := self sbNextParagraph.
	association := self		"key: GsNMethod value: (Array withAll: errors and warnings)"
		compileMethod: string 
		behavior: behavior 
		symbolList: self symbolList 
		inCategory: category asSymbol.
	(gsMethod := association key) isNil ifTrue: [
		System
			signal: 1001 
			args: (Array with: association value)
			signalDictionary: GemStoneError.
	].
	selections 
		at: #'methodCategory' 	put: (self _behavior: gsMethod inClass categoryOfSelector: gsMethod selector) asString;
		at: #'method'					put: gsMethod selector asString;
		at: #'methodWarnings'	put: association value;
		yourself.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbSavePackage: list

	| packageName package repositoryDescription repository versionName httpUser httpPassword comment |
	packageName := list removeFirst.
	package := self mcWorkingCopyClass allManagers detect: [:each | each package name = packageName].
	repositoryDescription := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = repositoryDescription].
	versionName := list removeFirst.
	list notEmpty ifTrue: [httpUser := list removeFirst].
	list notEmpty ifTrue: [httpPassword := list removeFirst].
	comment := self sbNextParagraph.
	[
		comment notEmpty and: [comment last asciiValue <= 32].
	] whileTrue: [
		comment := comment copyFrom: 1 to: comment size - 1.
	].
	(repository class name = #'MCHttpRepository') ifTrue: [
		repository
			user: httpUser;
			password: httpPassword;
			yourself.
	].
	self 
		mcStore: package 
		name: versionName 
		message: comment 
		repository: repository.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbSetHomeDictionary: list

	| name dictionary packagePolicy |
	name := list removeFirst asSymbol.
	dictionary := self symbolList detect: [:each | each name = name].
	(packagePolicy := self gsPackagePolicy) notNil ifTrue: [
		packagePolicy homeSymbolDict: dictionary.
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbUniqueVersionName: aList

	| packageName package |
	packageName := aList removeFirst.
	package := self mcWorkingCopyClass allManagers detect: [:each | each package name = packageName].
	writeStream
		nextPutAll: 'uniqueVersionName'; lf;
		nextPutAll: package uniqueVersionName;
		yourself.


%

category: 'category'
method: JadeServer
sbUnloadPackage: anOrderedCollection
	| service |
	service := Rowan packageServiceClass forPackageNamed: anOrderedCollection removeFirst.
	service deletePackage.
	self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbUpdateClasses

	| tabName |
	tabName := self nextLine.
	writeStream nextPutAll: tabName; lf.
	tabName = 'classList' ifTrue: [^self sbUpdateClassList].
	tabName = 'classHierarchy' ifTrue: [^self sbUpdateClassHierarchy].
	self error: 'Unexpected token!'.

%

category: 'category'
method: JadeServer
sbUpdateMethod

	| classes method names selection aSymbol |

	aSymbol := methodCommandResult selectedSelectors first. 

	"Inherited implimentors"
	classes := self sbUpdateMethodInheritedImplementationsOf: aSymbol.
	names := classes collect: [:each | each name asString].
	methodCommandResult inheritedClasses: names. 
	methodCommandResult writeInheritedClassesTo: writeStream.  "Line 1"

	"Which inherited implementation is selected?"
	selection := self nextLine.
	(names includes: selection) ifFalse: [selection := names last].
	methodCommandResult inheritedClass: selection.
	methodCommandResult writeInheritedClassTo: writeStream.	"Line 2"

	method := self compiledMethodAt: aSymbol inClass: (classes detect: [:each | each name asString = selection]).
	self _describeMethod: method.

%

category: 'category'
method: JadeServer
sbUpdateMethodBreakPointsFor: aMethod
	"Answers an Array of step points"

	^aMethod _stepPointsFromBreakIpOffsets: aMethod _breakpointIpOffsets.		"at least as far back as 32-bit 6.3.0 and 64-bit 2.3.0, but not in 64-bit 3.0"

%

category: 'category'
method: JadeServer
sbUpdateMethodCategories

	methodCommandResult classNamesFrom: classList. 
	methodCommandResult updateMethodCategories; 
		writeMethodCategoriesTo: writeStream. 
	methodCommandResult updateMethodFilterSelections: self nextLineAsList 
			hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodCommandResult selectionNames.
	methodCommandResult writeSelectionsTo: writeStream.
%

category: 'category'
method: JadeServer
sbUpdateMethodFilter
	
	selectedClass isNil ifTrue: [^self].
	methodFilterType = 'categoryList' ifTrue: [^self sbUpdateMethodCategories].
	methodFilterType = 'variableList' ifTrue: [^self sbUpdateMethodVariables].
	methodFilterType = 'pragmaList' ifTrue: [^self sbUpdateMethodPragmas].
	self error: 'Unexpected token!'.

%

category: 'category'
method: JadeServer
sbUpdateMethodFilterSelections

	| mySelections override |
	mySelections := self nextLineAsList.
	(override := selections at: #'methodCategory' ifAbsent: [nil]) notNil ifTrue: [mySelections := Array with: override].
	mySelections := methodFilters select: [:each | mySelections includes: each asString].
	mySelections notEmpty ifTrue: [methodFilters := mySelections].
	self writeList: mySelections.

%

category: 'category'
method: JadeServer
sbUpdateMethodInheritedImplementationsOf: aSymbol

	| classes currentClass |
	classes := OrderedCollection new.
	currentClass := classList last.
	[
		currentClass notNil.
	] whileTrue: [
		(self class: currentClass includesSelector: aSymbol) ifTrue: [classes add: currentClass].
		currentClass := currentClass superclass.
	].
	^classes reverse.

%

category: 'category'
method: JadeServer
sbUpdateMethodPragmas

	self sbUpdateMethodFilterSelections.

%

category: 'category'
method: JadeServer
sbUpdateMethods

	| selectors |
	selectedClass isNil ifTrue: [^self].
	methodFilterType = 'categoryList' ifTrue: [selectors := self sbUpdateMethodsByCategories] ifFalse: [
	methodFilterType = 'variableList' ifTrue: [selectors := self sbUpdateMethodsByVariables] ifFalse: [
	methodFilterType = 'pragmaList' ifTrue: [selectors := self sbUpdateMethodsByPragmas] ifFalse: [
		self error: 'Unrecognized methodFilterType: ' , methodFilterType printString]]].
	methodCommandResult selectors: selectors asSortedCollection asArray.
	methodCommandResult updateMethodsInfo.
	methodCommandResult writeMethodsTo: writeStream. 
	self sbUpdateMethodSelections

%

category: 'category'
method: JadeServer
sbUpdateMethodsByCategories

	| selectors |
	selectors := IdentitySet new.
	classList do: [:eachClass |
		eachClass selectors do: [:eachSelector |
			( methodFilters includes: (self _behavior: eachClass categoryOfSelector: eachSelector)) ifTrue: [selectors add: eachSelector].
		].
	].
	^selectors.

%

category: 'category'
method: JadeServer
sbUpdateMethodsByPragmas
	"none before 3.x"

	^#()
%

category: 'category'
method: JadeServer
sbUpdateMethodsByVariables

	| selectors filters |
	selectors := IdentitySet new.
	filters := IdentitySet withAll: (methodFilters select: [:each | each isSymbol]).
	selectedClass selectors do: [:eachSelector | 
		| gsMethod |
		gsMethod := self compiledMethodAt: eachSelector inClass: selectedClass.
		(gsMethod instVarsAccessed * filters) notEmpty ifTrue: [selectors add: eachSelector].
	].
	^selectors.

%

category: 'category'
method: JadeServer
sbUpdateMethodSelections

	| priorSelections override newSelections aList |
	aList := methodCommandResult selectors asArray. 
	priorSelections := self nextLineAsList.
	(override := selections at: #'method' ifAbsent: [nil]) notNil ifTrue: [priorSelections := Array with: override].
	newSelections := aList select: [:each | priorSelections includes: each asString].
	methodCommandResult selectedSelectors: newSelections. 
	methodCommandResult writeSelectedSelectorsTo: writeStream.
	newSelections size = 1 ifTrue: [self sbUpdateMethod].


%

category: 'category'
method: JadeServer
sbUpdateMethodVariables

	methodCommandResult classNamesFrom: classList. 
	methodCommandResult updateMethodVariables. 
	methodCommandResult writeMethodFiltersTo: writeStream. 
	methodCommandResult updateMethodFilterSelections: self nextLineAsList 
		hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodCommandResult selectionNames.
	methodCommandResult writeSelectionsTo: writeStream. 


%

category: 'category'
method: JadeServer
sbUpdatePackage: aString
	| package workingCopy list index |
	self mcPackageClass isNil
		ifTrue: 
			[writeStream
				nextPut: $%;
				lf.
			writeStream
				nextPut: $%;
				lf.
			^self ].
	package := self mcPackageClass named: aString.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	list := workingCopy ancestors collect: [:each | 0 -> each].
	index := 1.
	[list size < 4 and: [index <= list size]] whileTrue: 
			[| assoc |
			assoc := list at: index.
			assoc value ancestors do: [:parent | list add: assoc key + 1 -> parent].
			index := index + 1].
	list do: 
			[:each |
			| date time |
			date := each value date isNil
						ifTrue: ['']
						ifFalse: [each value date asStringUsingFormat: #(3 2 1 $- 1 1)].
			time := each value time isNil
						ifTrue: ['']
						ifFalse: [each value time asStringUsingFormat: #($: true false)].
			writeStream
				nextPutAll: each key printString;
				tab;
				nextPutAll: each value name;
				tab;
				nextPutAll: date;
				nextPut: $T;
				nextPutAll: time;
				tab;
				nextPutAll: (each value message
							collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$.] ifFalse: [char]]);
				lf].
	writeStream
		nextPut: $%;
		lf.
	workingCopy repositoryGroup repositories do: 
			[:each |
			writeStream
				nextPutAll: each class name;
				tab;
				nextPutAll: each description;
				tab;
				yourself.
			each class name = #MCHttpRepository
				ifTrue: 
					[writeStream
						nextPutAll: each user;
						tab;
						nextPutAll: each password;
						yourself]
				ifFalse: 
					[writeStream
						tab;
						tab].
			writeStream lf].
	writeStream
		nextPut: $%;
		lf
%

category: 'category'
method: JadeServer
sbUpdatePackagesOrDictionaries

	| selectedTab |
	selectedTab := self nextLine.
	"Removed for Rowan which may not have Monticello loaded, but have a package tab"
	"(self mcWorkingCopyClass isNil or: [self gsPackagePolicy isNil]) ifTrue: [selectedTab := 'dictionaryList']." 
	writeStream nextPutAll: selectedTab; lf.
	classList := OrderedCollection new.
	selectedTab = 'dictionaryList' ifTrue: [^self sbUpdateDictionaries].
	selectedTab = 'packageList' ifTrue: [^self sbUpdatePackages].
	selectedTab = 'projectList' ifTrue:[
		self sbUpdatePackages. 
		^self updateProjects].
	self error: 'unexpected token'.

%

category: 'category'
method: JadeServer
selectedClassOverridesSelector: aSymbol

	^selectedClass superclass notNil and: [selectedClass superclass canUnderstand: aSymbol].

%

category: 'category'
method: JadeServer
selectorsMatching: aString

	| user stream list |
	list := (aString subStrings: $*) asOrderedCollection collect: [:each | each asUppercase].
	list size - 1 to: 1 do: [:i | list add: $* afterIndex: i].
	aString last = $* ifTrue: [list addLast: $*].
	stream := WriteStream on: String new.
	user := AllUsers 
		userWithId: #SymbolUser 
		ifAbsent: [AllUsers userWithId: #DataCurator].
	list := list asArray.
	list := (user resolveSymbol: #AllSymbols) value select: [:each |each asUppercase matchPattern: list].
	list := list select: [:each | (self classOrganizer implementorsOf: each) notEmpty].
	list := list asSortedCollection.
	list do: [:each | stream nextPutAll: each; nextPut: Character lf; yourself].
	^stream contents.

%

category: 'category'
method: JadeServer
sendersOf: anObject

	| symbol |
	symbol := (anObject isKindOf: String)
		ifTrue: [anObject asSymbol]
		ifFalse: [anObject selector].
	^self streamOfMethods: (self classOrganizer sendersOf: symbol) first.

%

category: 'category'
method: JadeServer
sendSigAbortToSession: anInteger

	System sendSigAbortToSession: anInteger negated.

%

category: 'category'
method: JadeServer
sendSigUsr1ToSession: anInteger

	| description command result |
	description := System descriptionOfSession: anInteger.
	command := 'kill -usr1 ' , (description at: 2) printString.
	result := System performOnServer: command.
	result trimSeparators notEmpty ifTrue: [self error: result trimSeparators].

%

category: 'category'
method: JadeServer
setBreakAtStepPoint: anInteger inMethod: aGsMethod

	aGsMethod setBreakAtStepPoint: anInteger.

%

category: 'category'
method: JadeServer
show: anObject

	self nextPutAll: anObject printString.

%

category: 'category'
method: JadeServer
sleepAndCommit

	[
		System commitTransaction.
	] whileTrue: [
		(Delay forSeconds: 30) wait.
	].

%

category: 'category'
method: JadeServer
sourceFor: anObject in: aClass

	| behavior selector packageName category mcTimestamp dict source |
	selector := (anObject isKindOf: String) 
		ifTrue: [anObject asSymbol]
		ifFalse: [anObject selector].
	behavior := self
		behaviorFor: selector 
		in: aClass.
	category := self _behavior: behavior categoryOfSelector: selector.
	packageName := category first = $*
		ifTrue: [self _packageNameFor: category]
		ifFalse: [behavior thisClass _classCategory].
	packageName isNil ifTrue: [packageName := ''].
	mcTimestamp := ''.
	dict := behavior extraDict.
	dict notNil ifTrue: [
		dict := dict at: #'GSMethodStampDict' ifAbsent: [nil].
		dict notNil ifTrue: [
			mcTimestamp := dict
				at: selector
				ifAbsent: [''].
		].
	].
	source := behavior sourceCodeAt: selector.
	^(WriteStream on: String new)
		nextPutAll: packageName; tab;
		nextPutAll: category; tab;
		nextPutAll: mcTimestamp; lf;
		nextPutAll: source;
		contents.

%

category: 'category'
method: JadeServer
sourceForProcess: gsProcess frame: level

	self subclassResponsibility
%

category: 'category'
method: JadeServer
stackForProcess: aGsProcess

	| array stream |
	Exception
		category: nil
		number: nil
		do: [:ex :cat :num :args | nil].
	array := aGsProcess _reportOfSize: 5000.
	stream := WriteStream on: String new.
	array do: [:each | 
		stream nextPutAll: each; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
step: aGsProcess inFrame: anInteger
	aGsProcess _stepOverInFrame: anInteger.
%

category: 'category'
method: JadeServer
stepPointsFor: aGsMethod in: aClass

	| behavior method source breakStepPoints stepPoint stream |
	behavior := self
		behaviorFor: aGsMethod selector
		in: aClass.
	source := behavior sourceCodeAt: aGsMethod selector.
	method := self compiledMethodAt: aGsMethod selector inClass: behavior.
	stream := WriteStream on: String new.
	breakStepPoints := (aGsMethod class canUnderstand: #'_breakpointIpOffsets')
		ifTrue: [aGsMethod _stepPointsFromBreakIpOffsets: aGsMethod _breakpointIpOffsets]
		ifFalse: [#()].
	stepPoint := 0.
	method _sourceOffsets do: [:each | 
		stepPoint := stepPoint + 1.
		(breakStepPoints includes: stepPoint) ifTrue: [stream nextPut: $B].
		each printOn: stream.
		stream nextPut: Character space.
	].
	stream lf; 
		nextPutAll: (self stringOfLineNumbersWithBreaksIn: method); lf;
		nextPutAll: source;
		yourself.
	^stream contents.

%

category: 'category'
method: JadeServer
stoneInfo

	| dict stream |
	stream := (WriteStream on: String new)
		nextPutAll: self streamType; tab;
		nextPutAll: self stringType; tab;
		cr;
		yourself.
	dict := System stoneVersionReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	dict := System stoneConfigurationReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	^stream contents
%

category: 'category'
method: JadeServer
stopSession: anInteger

	System stopSession: anInteger.

%

category: 'category'
method: JadeServer
streamOfMethods: aList

	| stream |
	stream := WriteStream on: String new.
	aList do: [:each | 
		self
			_addMethod: each 
			toStream: stream.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
streamType

	^'Legacy'
%

category: 'category'
method: JadeServer
stringForClassList: aList

	| stream |
	stream := WriteStream on: String new.
	aList do: [:each | 
		self 
			_addClass: each 
			toStream: stream.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
stringType

	^'String'
%

category: 'category'
method: JadeServer
subclassSelectorForClass: aClass

	(aClass isBytes and: [aClass superclass notNil and: [aClass superclass isBytes not]]) ifTrue: [
		^'byteSubclass:'.
	].
	(aClass isIndexable and: [aClass superclass notNil and: [aClass superclass isIndexable not]]) ifTrue: [
		^'indexableSubclass:'.
	].
	((aClass class canUnderstand: #'isTransientDB') and: [aClass isTransientDB]) ifTrue: [
		^'transientSubclass:'.
	].
	^'subclass:'.

%

category: 'category'
method: JadeServer
superclassesOf: aClass isMeta: aBoolean

	| myClass list |
	myClass := aBoolean ifTrue: [aClass class] ifFalse: [aClass].
	list := myClass _allSuperList , (Array with: myClass).
	^self stringForClassList: list.

%

category: 'category'
method: JadeServer
symbolList

	^Rowan image symbolList
%

category: 'category'
method: JadeServer
systemBrowser: aString
	^self copy systemBrowserA: aString.

%

category: 'category'
method: JadeServer
systemBrowserA: aString

	| time |
	time := self millisecondsElapsedTime: [
		selections := Dictionary new.
		readStream := ReadStream on: aString.
		writeStream := WriteStream on: String new.
		writeStream lf.
		self environment: (readStream upTo: Character space) asNumber.
		self systemBrowserCommand.
	].
	^time printString , writeStream contents.

%

category: 'category'
method: JadeServer
systemBrowserCommand

	| list command |
	list := self nextLineAsList asOrderedCollection.
	command := list removeFirst.
	command = 'addDictionary'				ifTrue: [^self sbAddDictionary: list].
	command = 'addMethodCategory' 		ifTrue: [^self sbAddMethodCategory: list].
	command = 'addMissingAccessors'		ifTrue: [^self sbAddMissingAccessors: list].
	command = 'addPackage' 				ifTrue: [^self sbAddPackage: list].
	command = 'addRepository'			ifTrue: [^self sbAddRepository: list].

	command = 'break' 					ifTrue: [^self sbBreak: list].
	command = 'browseClassReferences'		ifTrue: [^self sbBrowseClassReferences: list].
	command = 'browseGlobalReferences'		ifTrue: [^self sbBrowseGlobalReferences: list].
	command = 'browseImplementors'		ifTrue: [^self sbBrowseImplementors: list].
	command = 'browseMethodHistory'		ifTrue: [^self sbBrowseMethodHistory: list].
	command = 'browseMethodsContaining'	ifTrue: [^self sbBrowseMethodsContaining: list].
	command = 'browseMethodsWithPragma'	ifTrue: [^self sbBrowseMethodsWithPragma: list].
	command = 'browseSenders'			ifTrue: [^self sbBrowseSenders: list].

	command = 'changeClassName'			ifTrue: [^self sbChangeClassName: list].
	command = 'changesInPackage'			ifTrue: [^self sbChangesInPackage: list].
	command = 'checkUniqueClassName'		ifTrue: [^self sbCheckUniqueClassName: list].
	command = 'class' 					ifTrue: [^self sbClass: list].
	command = 'classCategory'				ifTrue: [^self sbClassCategory: list].
	command = 'classComment'			ifTrue: [^self sbClassComment: list].
	command = 'classesToDictionary'		ifTrue: [^self sbClassesToDictionary: list].
	command = 'comparePackages'			ifTrue: [^self sbComparePackages: list].

	command = 'fileOutClass'				ifTrue: [^self sbFileOutClass: list].
	command = 'fileOutDictionary'			ifTrue: [^self sbFileOutDictionary: list].
	command = 'fileOutMethod'			ifTrue: [^self sbFileOutMethod: list].
	command = 'findClass' 				ifTrue: [^self sbFindClass].
	command = 'findSelectors'				ifTrue: [^self sbFindSelectors: list].


	command = 'listMethodPragmas'			ifTrue: [^self sbListMethodPragmas: list].
	command = 'loadLatestVersion'			ifTrue: [^self sbLoadLatestVersionOfConfiguration: list].

	command = 'method' 					ifTrue: [^self sbSaveMethod: list].
	command = 'methodCategory'			ifTrue: [^self sbMethodCategory: list].
	command = 'methodClass'				ifTrue: [^self sbMethodClass: list].

	command = 'objectLog'				ifTrue: [^self sbObjectLog: list].

	command = 'postSaveClass'			ifTrue: [^self sbPostSaveClass: list].

	command = 'removeClasses'			ifTrue: [^self sbRemoveClasses].
	command = 'removeDictionaries'			ifTrue: [^self sbRemoveDictionaries: list].
	command = 'removeGlobals'			ifTrue: [^self sbRemoveGlobals].
	command = 'removeMethodCategories' 	ifTrue: [^self sbRemoveMethodCategories: list].
	command = 'removeMethods'			ifTrue: [^self sbRemoveMethods: list].
	command = 'removePriorVersions'		ifTrue: [^self sbRemovePriorVersions].
	command = 'removeRepository'			ifTrue: [^self sbRemoveRepository: list].
	command = 'revertClass'				ifTrue: [^self sbRevertClass].

	command = 'savePackage'				ifTrue: [^self sbSavePackage: list].
	command = 'setHomeDictionary'			ifTrue: [^self sbSetHomeDictionary: list].

	command = 'uniqueVersionName'		ifTrue: [^self sbUniqueVersionName: list].
	command = 'unloadPackage'			ifTrue: [^self sbUnloadPackage: list].
	command = 'update' 					ifTrue: [^self systemBrowserUpdate].

	self error: 'Unknown command: ' , command printString.

%

category: 'category'
method: JadeServer
systemBrowserSTON: aString
	^self copy systemBrowserSTONA: aString.

%

category: 'category'
method: JadeServer
systemBrowserSTONA: aString

	| time |
	time := self millisecondsElapsedTime: [
		selections := Dictionary new.
		readStream := ReadStream on: aString.
		writeStream := WriteStream on: String new.
		writeStream lf.
		self environment: (readStream upTo: Character space) asNumber.
		self systemBrowserCommand.
	].
	^STON toString: RowanCommandResult results

%

category: 'category'
method: JadeServer
systemConfigAsDictionary

	| char dict i line list stream |
	list := Array new.
	stream := GsFile openReadOnServer: '$GEMSTONE/data/system.conf'.
	[
		[
			line := stream nextLine reject: [:each | each == Character cr or: [each == Character lf]].
			(2 < line size and: [(line copyFrom: 1 to: 2) = '#=']) ifTrue: [
				list add: (WriteStream on: String new).
			] ifFalse: [
				list last nextPutAll: line; cr.
			].
			stream atEnd not.
		] whileTrue: [].
	] ensure: [
		stream close.
	].
	list := list copyFrom: 3 to: list size.
	list := list collect: [:each | each contents].
	dict := Dictionary new.
	list do: [:each | 
		line := (ReadStream on: each) nextLine.
		line = '# End of Default GemStone Configuration Options' ifTrue: [^dict].
		(line copyFrom: 1 to: 2) = '# ' ifFalse: [line error: 'Unrecognized config file format!'].
		i := 3.
		[
			i <= line size and: [(char := line at: i) == $_ or: [char isAlphaNumeric]].
		] whileTrue: [
			i := i + 1.
		].
		dict at: (line copyFrom: 3 to: i - 1) put: each.
	].
	self error: 'End of file not recognized!'.
%

category: 'category'
method: JadeServer
terminate: aGsProcess

	aGsProcess isNil ifTrue: [^self].
	aGsProcess terminate.
	(Delay forMilliseconds: 10) wait.	"allow forked processes to finish"

%

category: 'jadeite'
method: JadeServer
updateFromSton: stonString
  | services organizer resultString |
  [ 
  Rowan commandResultClass initializeResults.
  services := STON fromString: stonString.
  organizer := ClassOrganizer new.
  [ 
  services
    do: [ :service | 
      service organizer: organizer.
      service updateType: nil.	"Update type is only for returned commands"
      service command ifNil: [ service command: #'update' ].
      service servicePerform: service command withArguments: service commandArgs ] ]
    on: GsInteractionRequest
    do: [ :ex | 
      ex
        response:
          (ex interaction interactWith: self gsInteractionInformFailureHandler) ].
  self autoCommitIfRequired.
  Rowan loggingServiceClass current logSentServices.
  resultString := STON toString: Rowan commandResultClass results.
  ^ resultString ]
    on: Error
    do: [ :ex | 
      RowanDebuggerService new saveProcessOop: GsProcess _current asOop.
      ex pass ]
%

category: 'category'
method: JadeServer
userList

	| list me stream |
	list := (AllUsers asSortedCollection: [:a :b | a userId <= b userId]) asOrderedCollection.
	me := System myUserProfile.
	list
		remove: me;
		addFirst: me;
		yourself.
	stream := WriteStream on: String new.
	list do: [:each | 
		self
			addUser: each 
			toStream: stream.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
waitingProcesses

	^ProcessorScheduler scheduler waitingProcesses

%

category: 'category'
method: JadeServer
writeList: aList

	aList do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.

%

category: 'category'
method: JadeServer
_addClass: each toStream: stream 

	self
		_addClass: each 
		toStream: stream 
		isVisible: true
		fromDictionary: nil.

%

category: 'category'
method: JadeServer
_addClass: aClass toStream: aStream isVisible: aBoolean fromDictionary: aDictionary
	"1. OOP; 2. key; 3. category; 4. dictionary name; 5. superclass OOP; 6. children; 7. Visible/Inherited; 8. Class History; 9. isTestCase"

	| testCaseClass history |
"1"	(self oopOf: aClass) printOn: aStream.
"2"	aStream tab; nextPutAll: (aDictionary  isNil ifTrue: [aClass name] ifFalse: [aDictionary keyAtValue: aClass ifAbsent: [aClass name]]); tab.
"3"	aClass category notNil ifTrue: [aStream nextPutAll: aClass category].
"4"	aStream tab; nextPutAll: (aDictionary isNil ifTrue: ['?'] ifFalse: [aDictionary name]).
"5"	aStream tab. (self oopOf: aClass superclass) printOn: aStream.
	aStream 
"6"		tab; "let client build children list"
"7"		tab; nextPut: (aBoolean ifTrue: [$V] ifFalse: [$I]);
		tab.
	(history := self historyOf: aClass) isNil ifTrue: [history := Array with: aClass].
"8"	(history indexOf: aClass) printOn: aStream.
	aStream nextPut: $/.
	history size printOn: aStream.
	aStream tab.
	testCaseClass := Globals
		at: #'TestCase'
		ifAbsent: [nil].
"9"	(testCaseClass notNil and: [aClass isSubclassOf: testCaseClass]) printOn: aStream.
	aStream lf.

%

category: 'category'
method: JadeServer
_addMethod: aGsMethod toStream: aStream
	"See GsMethod2>>initialize:"

	| inClass testCaseClass |
	inClass := aGsMethod inClass.
"1"	(self oopOf: aGsMethod) printOn: aStream.
	aStream 
"2"		tab; nextPutAll: aGsMethod selector; 
"3"		tab; nextPutAll: (self _behavior: inClass categoryOfSelector: aGsMethod selector);
		tab.

	"Class"
"4"	(self oopOf: inClass) printOn: aStream.
"5"	aStream tab; nextPutAll: inClass name; tab.
"6"	inClass category notNil ifTrue: [aStream nextPutAll: inClass category].
"7"	aStream tab; nextPutAll: (self nameOfFirstDictionaryReferencing: inClass thisClass); tab.

	"SUnit Test Method"
	testCaseClass := Globals
		at: #'TestCase'
		ifAbsent: [nil].
"8"	((testCaseClass notNil and: [inClass isSubclassOf: testCaseClass]) and: [inClass testSelectors includes: aGsMethod selector]) printOn: aStream.
	aStream lf.

%

category: 'category'
method: JadeServer
_addToPureExportSet: anObject

	System 
		_add: anObject 
		toGciSet: 39.  "PureExportSet"

%

category: 'category'
method: JadeServer
_allSelectors

	| allSelectors |
	allSelectors := IdentitySet new.
	self classOrganizer classes do: [:each | 
		allSelectors addAll: each selectors; addAll: each class selectors.
	].
	^allSelectors
%

category: 'category'
method: JadeServer
_behavior: aBehavior categoryOfSelector: aSymbol

	^aBehavior categoryOfSelector: aSymbol
%

category: 'category'
method: JadeServer
_describeMCAddition: anMCAddition on: aStream

	aStream 
		nextPut: $A; tab;
		nextPutAll: (self oopOf: anMCAddition) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCAddition definition 
		on: aStream.

%

category: 'category'
method: JadeServer
_describeMCClassDefinition: anMCClassDefinition on: aStream

	| string |
	string := anMCClassDefinition definitionString collect: [:char |
		char = Character lf
			ifTrue: [Character cr]
			ifFalse: [char].
	].
	aStream
		nextPut: $C; tab;
		nextPutAll: string; lf;
		yourself.

%

category: 'category'
method: JadeServer
_describeMCDefinition: anMCDefinition on: aStream

	anMCDefinition isMethodDefinition ifTrue: [
		self 
			_describeMCMethodDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	anMCDefinition isOrganizationDefinition ifTrue: [
		self 
			_describeMCOrganizationDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	anMCDefinition isClassDefinition ifTrue: [
		self 
			_describeMCClassDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	self halt.

%

category: 'category'
method: JadeServer
_describeMCMethodDefinition: anMCMethodDefinition on: aStream
	| unicodeFreeSource |
	unicodeFreeSource := RowanMethodService removeUnicodeFromSource: anMCMethodDefinition source.
	aStream
		nextPut: $M; tab;
		nextPutAll: anMCMethodDefinition timeStamp; tab;
		nextPutAll: anMCMethodDefinition className; tab;
		nextPutAll: anMCMethodDefinition classIsMeta printString; tab;
		nextPutAll: anMCMethodDefinition category; tab;
		nextPutAll: anMCMethodDefinition selector; tab;
		nextPutAll: unicodeFreeSource size printString; tab;
		nextPutAll: unicodeFreeSource; lf.
%

category: 'category'
method: JadeServer
_describeMCModification: anMCModification on: aStream

	aStream nextPut: $M; tab;
		nextPutAll: (self oopOf: anMCModification) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCModification obsoletion 
		on: aStream.
	self 
		_describeMCDefinition: anMCModification modification 
		on: aStream.

%

category: 'category'
method: JadeServer
_describeMCOrganizationDefinition: anMCOrganizationDefinition on: aStream

	aStream
		nextPut: $O; tab;
		yourself.
	anMCOrganizationDefinition categories do: [:each | 
		aStream nextPutAll: each; tab.
	].
	aStream lf.

%

category: 'category'
method: JadeServer
_describeMCRemoval: anMCRemoval on: aStream

	aStream nextPut: $R; tab;
		nextPutAll: (self oopOf: anMCRemoval) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCRemoval definition 
		on: aStream.

%

category: 'category'
method: JadeServer
_describeMethod: aMethod
  "Provide info needed to create a GsMethod in Jade client"

  "Nice to add packageName and mcTimestamp"

  | allSelectors class list oldGsMethod string x |
  self environment: (self environmentForMethod: aMethod).
  writeStream
    nextPutAll: (class := aMethod inClass) asOop printString;
    tab;
    nextPutAll: class printString;
    tab;
    nextPutAll: aMethod asOop printString;
    tab;
    nextPutAll:
        ((x := aMethod selector) isNil
            ifFalse: [ x ]
            ifTrue: [ '' ]);
    tab;
    nextPutAll: (self categoryOfMethod: aMethod);
    tab;
    nextPutAll: (self currentUserMayEditMethod: aMethod) asString;
    tab;
    lf.	"Line 1 for GsMethod (line 3 for JadeSystemBrowserPresenter)"	"1"	"2"	"3"	"4"	"5"	"6"	"Method source"
  writeStream nextPutAll: (string := aMethod sourceString).
  string last = Character lf
    ifFalse: [ writeStream lf ].
  writeStream
    nextPut: $%;
    lf.	"Lines 2-N"	"unimplemented selectors"	"https://github.com/jgfoster/Jade/issues/117"
  ((aMethod class includesSelector: #'_selectorPool')
    and: [ aMethod class includesSelector: #'_sourceOffsetOfFirstSendOf:' ])
    ifTrue: [ 
      allSelectors := self _allSelectors.
      (aMethod _selectorPool reject: [ :each | allSelectors includes: each ])
        do: [ :each | 
          (aMethod _sourceOffsetOfFirstSendOf: each) printOn: writeStream.
          writeStream
            space;
            nextPutAll: each;
            tab ] ].
  writeStream lf.	"Line N+1"	"Array of Associations (offset -> selector) indexed by step points"
  list := self sbUpdateMethodStepPointsFor: aMethod.
  list := list collect: [ :each | each key printString , ' ' , each value ].
  self writeList: list.	"Line N+2"	"breaks"
  list := self sbUpdateMethodBreakPointsFor: aMethod.
  self writeList: (list collect: [ :each | each printString ]).	"Line N+3"	"original method"
  oldGsMethod := (aMethod inClass class
    canUnderstand: #'persistentMethodDictForEnv:')
    ifTrue: [ 
      (aMethod inClass persistentMethodDictForEnv: 0)
        at: aMethod selector
        ifAbsent: [ aMethod ] ]
    ifFalse: [ aMethod ].
  aMethod ~~ oldGsMethod
    ifTrue: [ 
      string := oldGsMethod sourceString.
      writeStream nextPutAll: string.
      (string notEmpty and: [ string last = Character lf ])
        ifFalse: [ writeStream lf ] ].
  writeStream
    nextPut: $%;
    lf.	"method compile warnings"
  string := selections isNil
    ifTrue: [ '' ]
    ifFalse: [ selections at: #'methodWarnings' ifAbsent: [ '' ] ].
  string isNil
    ifTrue: [ string := '' ].
  writeStream
    nextPutAll: string;
    nextPut: $%;
    lf
%

category: 'category'
method: JadeServer
_mcDescriptionOfPatch: aPatch baseName: aString1 alternateName: aString2

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aPatch) printOn: stream.
	stream 
		tab; nextPutAll: (aString1 isNil ifTrue: ['loaded'] ifFalse: [aString1]);
		nextPutAll: ' vs. ';
		nextPutAll: (aString2 isNil ifTrue: ['loaded'] ifFalse: [aString2]);
		lf.
	aPatch operations do: [:each | 
		each isAddition 		ifTrue: [self _describeMCAddition: 		each on: stream].
		each isModification 	ifTrue: [self _describeMCModification: 	each on: stream].
		each isRemoval 		ifTrue: [self _describeMCRemoval: 		each on: stream].
	].
	^stream contents.


%

category: 'category'
method: JadeServer
_mcTopazFrom: aSnapshot on: aStream

	| classes dict parents methods queue |
	classes := aSnapshot definitions select: [:each | each isClassDefinition].
	dict := Dictionary new.
	classes do: [:each | 
		| parent myself |
		parent := dict 
			at: each superclassName 
			ifAbsentPut: [nil -> Set new].
		myself := dict
			at: each className
			ifAbsentPut: [nil -> Set new].
		myself key: each.
		parent value add: myself.
	].
	dict := dict reject: [:each | each key isNil].
	parents := dict keys.
	dict copy do: [:each | 
		(parents includes: each key superclassName) ifTrue: [
			dict removeKey: each key className.
		].
	].
	queue := (dict asSortedCollection: [:a :b | a key <= b key]) asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| assoc children def |
		assoc := queue removeFirst.
		children := (assoc value asSortedCollection: [:a :b | a key <= b key]) asOrderedCollection.
		queue := children , queue.
		def := assoc key.
		aStream 
			nextPutAll: '! - ' , def className; lf;
			nextPutAll: '! - ' , def commentStamp; lf;
			nextPutAll: 'run'; lf;
			nextPutAll: '(' , def superclassName; lf;
			tab; nextPutAll: 'subclass: ' , def className printString; lf;
			tab; nextPutAll: 'instVarNames: #(' , def instanceVariablesString , ')'; lf;
			tab; nextPutAll: 'classVars: #(' , def classVariablesString , ')'; lf;
			tab; nextPutAll: 'classInstVars: #(' , def classInstanceVariablesString , ')'; lf;
			tab; nextPutAll: 'poolDictionaries: #(' , def sharedPoolsString , ')'; lf;
			tab; nextPutAll: 'inDictionary: UserGlobals'; lf;
			tab; nextPutAll: 'instancesInvariant: false'; lf;
			tab; nextPutAll: 'isModifiable: false)'; lf;
			tab; nextPutAll: 'category: ' , def category printString , '.'; lf;
			nextPutAll: 'true.'; lf;
			nextPut: $%; lf;
			yourself.
	].
	methods := aSnapshot definitions select: [:each | each isMethodDefinition].
	methods := methods asSortedCollection.
	classes asSortedCollection do: [:eachClass | 
		| localMethods |
		localMethods := methods select: [:eachMethod | eachClass className = eachMethod className].
		methods removeAll: localMethods.
		aStream
			lf; nextPutAll: '! - *** - ' , eachClass className; lf;
			nextPutAll: 'removeAllClassMethods ' , eachClass className; lf;
			nextPutAll: 'removeAllMethods ' , eachClass className; lf;
			yourself.
		localMethods do: [:eachMethod | 
			| source |
			source := eachMethod source copyReplaceAll: Character cr asString with: Character lf asString.
			aStream
				nextPutAll: 'category: ''' , eachMethod category , ''''; lf;
				nextPutAll: '! - ' , eachMethod timeStamp; lf;
				nextPutAll: (eachMethod classIsMeta ifTrue: ['classMethod: '] ifFalse: ['method: ']) , eachMethod className; lf;
				nextPutAll: source; lf;
				nextPut: $%; lf;
				yourself.
		].
	].
	aStream lf; nextPutAll: '! - *** - loose methods (where class is expected to be already defined)'; lf; lf.
	methods isEmpty ifTrue: [aStream nextPutAll: '! - (none)'; lf; lf].

	methods do: [:eachMethod | 
		| source |
		source := eachMethod source copyReplaceAll: Character cr asString with: Character lf asString.
		aStream
			nextPutAll: 'category: ''' , eachMethod category , ''''; lf;
			nextPutAll: '! - ' , eachMethod timeStamp; lf;
			nextPutAll: (eachMethod classIsMeta ifTrue: ['classMethod: '] ifFalse: ['method: ']) , eachMethod className; lf;
			nextPutAll: source; lf;
			nextPut: $%; lf;
			yourself.
	].

	aStream lf; nextPutAll: '! - *** - class initialization'; lf.
	methods isEmpty ifTrue: [aStream nextPutAll: '! - (none)'; lf; lf].
	classes do: [:each | 
		aStream nextPutAll: 'send ' , each className , ' initialize'; lf.
	].


%

category: 'category'
method: JadeServer
_methodsFor: aClass categories: aList

	| methods |
	methods := IdentitySet new.
	aList do: [:eachCategory | 
		(aClass _includesCategory: eachCategory) ifTrue: [
			(aClass selectorsIn: eachCategory) do: [:eachSelector |
				methods add: (self compiledMethodAt: eachSelector inClass: aClass).
			].
		].
	].
	^methods.


%

category: 'category'
method: JadeServer
_methodsFor: aClass filter: aList isVariables: aBoolean

	^aBoolean 
		ifTrue:	[self _methodsFor: aClass variables: 	aList]
		ifFalse:	[self _methodsFor: aClass categories: aList].

%

category: 'category'
method: JadeServer
_methodsFor: aClass variables: aList

	| methods |
	aList isEmpty ifTrue: [^aClass selectors collect: [:each | self compiledMethodAt: each inClass: aClass]].
	methods := IdentitySet new.
	aClass selectors do: [:each | 
		| method intersect |
		method := self compiledMethodAt: each inClass: aClass.
		intersect := method instVarsAccessed * aList.
		intersect notEmpty ifTrue: [methods add: method].
	].
	^methods.

%

category: 'category'
method: JadeServer
_oopAndStringFor: anObject

	^(self oopOf: anObject) -> anObject printString.

%

category: 'category'
method: JadeServer
_packageNameFor: aCategoryName

	| string mcWorkingCopyClass list |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^''].
	string := aCategoryName asUppercase copyFrom: 2 to: aCategoryName size.
	list := mcWorkingCopyClass allManagers collect: [:each | each packageName].
	list := list select: [:each | (string copyFrom: 1 to: (string size min: each size)) = each asUppercase].
	list isEmpty ifTrue: [^''].
	list size = 1 ifTrue: [^list first].
	^(list asSortedCollection: [:a :b | a size <= b size]) last.

%

category: 'category'
method: JadeServer
_sourceForProcess: gsProcess frame: level

	| frame homeMethod stepPoint keys values gsMethod receiver |
	writeStream := WriteStream on: String new.
	(frame := gsProcess _frameContentsAt: level) isNil ifTrue: [^'No frame found for level ' , level printString].
	gsMethod := frame at: 1.
	stepPoint := self 
		_stepPointFromProcess: gsProcess 
		frame: frame 
		method: gsMethod
		level: level.
	writeStream
		nextPutAll: '<?xml version=''1.0'' ?><frame oop=';
		nextPutAll: (self oopOf: frame) printString printString;
		nextPutAll: ' ipOffset=';
		nextPutAll: (frame at: 2) printString printString;
		nextPutAll: ' frameOffset=';
		nextPutAll: ((frame at: 3) isNil ifTrue: [''] ifFalse: [(frame at: 3) printString]) printString;
		nextPutAll: ' stepPoint=';
		nextPutAll: stepPoint printString printString;
		nextPutAll: '>'; lf;
		yourself.
	receiver := frame at: 10.
	values := OrderedCollection new.
	(self isClientForwarder: receiver) ifTrue: [
		keys := OrderedCollection with: 'clientObject'.
		values add: receiver clientObject.
		receiver := '[aClientForwarder(' , (self oopOf: receiver) printString , ')]'.
	] ifFalse: [
		((receiver isKindOf: BlockClosure) or: [receiver isKindOf: Class]) ifTrue: [
			keys := OrderedCollection new.
		] ifFalse: [
			keys := receiver class allInstVarNames asOrderedCollection collect: [:each | '-' , each].
			1 to: keys size do: [:i |
				values add: (receiver instVarAt: i).
			].
		].
	].
	keys addFirst: #'receiver'.
	values addFirst: receiver.
	keys addAll: (frame at: 9).
	keys := keys reject: [:each | each first == $.].
	values addAll: (frame size >= 11
		ifTrue: [frame copyFrom: 11 to: frame size]
		ifFalse: [#()]).
	1 to: (keys size min: values size) do: [:i | | oop assoc key value |
		key := keys at: i.
		value := values at: i.
		assoc := self _oopAndStringFor: value.
		oop := assoc key.
		value := assoc value.
		value size > 500 ifTrue: [value := (value copyFrom: 1 to: 500) , '...'].
		value := value collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$?] ifFalse: [char]].
		writeStream
			nextPutAll: '<var oop=';
			nextPutAll: oop asString printString;
			nextPutAll: ' name=';
			nextPutAll: key asString printString;
			nextPutAll: ' ><';
			nextPutAll: '![';
			nextPutAll: 'CDATA';
			nextPutAll: '[';
			nextPutAll: value;
			nextPutAll: ']';
			nextPutAll: ']';
			nextPutAll: '></var>'; lf;
			yourself.
	].
	homeMethod := self homeMethodFor: gsMethod.
	writeStream 
		nextPutAll: '<source';
		nextPutAll: ' ><';
		nextPutAll: '![';
		nextPutAll: 'CDATA';
		nextPutAll: '[';
		yourself.
	self _describeMethod: homeMethod.
	writeStream
		nextPutAll: ']';
		nextPutAll: ']';
		nextPutAll: '></source>';
		nextPutAll: '</frame>'; lf;
		yourself.
	^self asAsciiString: writeStream contents.


%

category: 'category'
method: JadeServer
_stepPointFromProcess: gsProcess frame: aFrame method: gsMethod level: anInteger

	self subclassResponsibility.
%

category: 'category'
method: JadeServer
_stepPointsForBreaksInMethod: gsMethod

	^gsMethod _stepPointsFromBreakIpOffsets: gsMethod _breakpointIpOffsets
%

category: 'category'
method: JadeServer
_trimStackOf: aGsProcess toLevel: anInteger

	aGsProcess _trimStackToLevel: anInteger.
	^aGsProcess.

%

! Class implementation for 'JadeServer64bit'

!		Instance methods for 'JadeServer64bit'

category: 'category'
method: JadeServer64bit
addSessionWithId: anInteger toStream: aStream

	[
		super
			addSessionWithId: anInteger
			toStream: aStream.
	] on: Error do: [:ex | 
		ex resume: '?????'.
	].

%

category: 'category'
method: JadeServer64bit
addUser: aUserProfile toStream: aStream

	[
		super
			addUser: aUserProfile 
			toStream: aStream.
	] on: Error do: [:ex | 
		aStream lf.
		ex return.
	].

%

category: 'category'
method: JadeServer64bit
asString: anObject

	^[
		super asString: anObject.
	] on: Error do: [:ex | 
		ex return: '???'.
	].

%

category: 'category'
method: JadeServer64bit
homeMethodFor: aGsMethod

	^[aGsMethod homeMethod] on: Error do: [:ex | ex return: aGsMethod]
%

category: 'category'
method: JadeServer64bit
installTranscript

	[
		super installTranscript.
	] on: Error do: [:ex | 
		ex return.
	].

%

category: 'category'
method: JadeServer64bit
mcInitialsA: aString

	^[
		super mcInitialsA: aString.
		true.
	] on: Error do: [:ex | 
		ex return: false.
	].

%

category: 'category'
method: JadeServer64bit
metacelloConfigurations

	| list |
	list := Array new.
	Rowan image symbolList do: [:eachSymbolList | 
		eachSymbolList do: [:eachGlobal | 
			(eachGlobal isBehavior and: [
			(eachGlobal class includesSelector: #'isMetacelloConfig') and: [
			eachGlobal isMetacelloConfig]]) ifTrue: [list add: eachGlobal].
		].
	].
	^list
%

category: 'category'
method: JadeServer64bit
objectForOop: anInteger

	^Object _objectForOop: anInteger.

%

category: 'category'
method: JadeServer64bit
recompile: aMethod withSource: aString
	| behavior |
	behavior := aMethod inClass.
	[[ behavior rwCompileMethod: aString
				category: (self _behavior: behavior categoryOfSelector: aMethod selector) ]
					on: RwExecuteClassInitializeMethodsAfterLoadNotification
					do: [:ex | ex resume: false ]]
								on: RwPerformingUnpackagedEditNotification
								do: [:ex | ex resume ].
			Rowan serviceClass rowanFixMe.	"need to handle compile errors"
			^true
%

category: 'category'
method: JadeServer64bit
sbRemoveKey: aSymbol fromDictionary: aDictionary

	| aClass array |
	aClass := aDictionary at: aSymbol.
	array := self dictionaryAndSymbolOf: aClass.
	((array at: 1) == aDictionary and: [
		(array at: 2) == aSymbol and: [
		(Class canUnderstand: #'removeFromSystem') and: [	"mark package as modified"
		aClass removeFromSystem]]]) ifFalse: [
			aDictionary removeKey: aSymbol.
		].
%

category: 'category'
method: JadeServer64bit
sourceForProcess: gsProcess frame: level

	^[
		self
			_sourceForProcess: gsProcess 
			frame: level.
	] on: Error do: [:ex | 
			ex return: (self asAsciiString: ('?????' , ex description , Character cr asString , (GsProcess stackReportToLevel: 50))).
	].

%

category: 'category'
method: JadeServer64bit
streamType

	| isLegacy type |
	type := Globals at: #'PositionableStream_position' ifAbsent: [#'Legacy'].
	(Globals includesKey: #'PositionableStreamLegacy') ifFalse: [^type].
	isLegacy := PositionableStream isLegacyStreamImplementation.
	(type = #'Legacy') == isLegacy ifTrue: [^type].
	self error: 'Inconsistent PositionableStream configuration'.

%

category: 'category'
method: JadeServer64bit
stringType

	^(Globals at: #StringConfiguration ifAbsent: [String]) name

%

category: 'category'
method: JadeServer64bit
systemBrowser: aString

	[
		^super systemBrowser: aString.
	] on: Error do: [:ex |
		readStream := nil.
		ex pass.
	].

%

category: 'category'
method: JadeServer64bit
systemBrowserSTON: aString

	[
		^super systemBrowserSTON: aString.
	] on: Error do: [:ex |
		readStream := nil.
		ex pass.
	].

%

category: 'category'
method: JadeServer64bit
_oopAndStringFor: anObject

	^[
		super _oopAndStringFor: anObject.
	] on: Error do: [:ex | 
		ex return: 0 -> ('<ERROR IN #printString for ' , anObject class name , '>').
	].

%

category: 'category'
method: JadeServer64bit
_stepPointFromProcess: gsProcess frame: aFrame method: gsMethod level: anInteger

	^gsProcess _stepPointAt: anInteger

%

category: 'category'
method: JadeServer64bit
_trimStackOf: aGsProcess toLevel: anInteger

	^[
		super
			_trimStackOf: aGsProcess 
			toLevel: anInteger.
	] on: Error do: [:ex | 
		self 
			_trimStackOf: aGsProcess 
			toLevel: anInteger - 1.
		ex return.
	].

%

! Class implementation for 'JadeServer64bit24'

!		Instance methods for 'JadeServer64bit24'

category: 'category'
method: JadeServer64bit24
inspect: anObject

	^(self isClientForwarder: anObject)
		ifTrue: [self inspectClientForwarder: anObject]
		ifFalse: [super inspect: anObject].

%

category: 'category'
method: JadeServer64bit24
inspectClientForwarder: anObject

	| stream |
	(stream := WriteStream on: String new)
		nextPutAll: 'ClientForwarder'; tab;
		yourself.
	(self oopOf: anObject) printOn: stream.
	stream lf;
		nextPut: $1; lf;
		nextPutAll: 'clientObject'; tab;
		yourself.
	self print: (self oopOf: anObject clientObject) on: stream.
	stream lf; nextPutAll: (self printStringOf: anObject).
	^stream contents.

%

category: 'category'
method: JadeServer64bit24
isClientForwarder: anObject

	^(Reflection classOf: anObject) name == #'ClientForwarder' 

%

category: 'category'
method: JadeServer64bit24
oopOf: anObject

	^Reflection oopOf: anObject.

%

category: 'category'
method: JadeServer64bit24
printStringOf: anObject

	^(self isClientForwarder: anObject)
		ifFalse: [anObject printString]
		ifTrue: ['aClientForwarder(' , anObject clientObject printString , ')'].

%

category: 'category'
method: JadeServer64bit24
registerOBNotificationsForPlatform: platform clientForwarder: clientForwarder

	super
		registerOBNotificationsForPlatform: platform 
		clientForwarder: clientForwarder.
	platform 
		registerMultipleChoiceClientForwarder: clientForwarder;
		yourself.

%

! Class implementation for 'JadeServer64bit3x'

!		Instance methods for 'JadeServer64bit3x'

category: 'category'
method: JadeServer64bit3x
addMethodCategoryNamesToMethodFilters

	classList do: [:each | 
		each 
			env: environment 
			categorysDo:[ :categName :selectors | methodFilters add: categName ].
	].

%

category: 'category'
method: JadeServer64bit3x
addProcess: aProcess to: aStream withStatus: aString scheduler: aScheduler

	| instVarNumber modeInfo modeInfo_forked modeInfo_terminated |
	super addProcess: aProcess to: aStream withStatus: aString scheduler: aScheduler.
	(instVarNumber := GsProcess instVarNames indexOf: #'modeInfo') == 0 ifTrue: [^self].
	modeInfo := aProcess instVarAt: instVarNumber.
	(modeInfo_forked := GsProcess _classVars at: #'ModeInfo_forked' ifAbsent: [nil]) ifNil: [^self].
	(modeInfo_terminated := GsProcess _classVars at: #'ModeInfo_terminated' ifAbsent: [nil]) ifNil: [^self].
	aStream
"9"		nextPutAll: (0 < (modeInfo bitAnd: modeInfo_forked) ifTrue: ['forked'] ifFalse: ['main']); tab;
"10"		nextPutAll: (0 < (modeInfo bitAnd: modeInfo_terminated) ifTrue: ['terminated'] ifFalse: ['']); tab;
		yourself.

%

category: 'category'
method: JadeServer64bit3x
asString: anObject

	(anObject isKindOf: String) ifTrue: [^anObject].
	(anObject _class name == #'ClientForwarder') ifTrue: [^'aClientForwarder(' , (self asString: anObject clientObject) , ')'].
	^[
		anObject printString.
	] on: Error , Admonition do: [:ex | 
		ex return: '<<printString error: ' , ex description , '>>'.
	].

%

category: 'category'
method: JadeServer64bit3x
categoryOfMethod: aMethod

	| category selector |
	(selector := aMethod selector) isNil ifTrue: [^''].
	category := self _behavior: aMethod inClass categoryOfSelector: aMethod selector.
	category ifNil: [category := #'other'].
	^category.

%

category: 'category'
method: JadeServer64bit3x
class: aClass includesSelector: aSelector

	^aClass includesSelector: aSelector asSymbol environmentId: environment.

%

category: 'category'
method: JadeServer64bit3x
compiledMethodAt: aSymbol inClass: aClass

	| method | 
	method := aClass compiledMethodAt: aSymbol environmentId: environment.
	method ifNil: [self error: 'Lookup failed for selector ' , aSymbol , ' inClass ' , aClass name , ' in environment ' , environment printString].
	^method.
%

category: 'category'
method: JadeServer64bit3x
compileMethod: methodString behavior: aBehavior symbolList: aSymbolList inCategory: categorySymbol
	"returns (nil -> anArrayOfErrors) or (aGsNMethod -> compilerWarnings) or (aGsNMethod -> nil)"

	| method warnings | 

	[[ 
			[[ method := aBehavior rwCompileMethod: methodString category: categorySymbol ]
					on: RwExecuteClassInitializeMethodsAfterLoadNotification
					do: [:ex | ex resume: false ]]
						on: RwPerformingUnpackagedEditNotification
						do: [:ex | ex resume ].
		] on: CompileError do: [:ex |
		^nil -> (ex gsArguments at: 1)
	]] on: CompileWarning do: [:ex |
		warnings := ex gsArguments at: 1.
		ex resume.
	].
	^[	
		(self compiledMethodAt: method key selector inClass: aBehavior) -> warnings.
	] on: Error do: [:ex | 
		ex return: method -> warnings.
	].
%

category: 'category'
method: JadeServer64bit3x
debugString: aString fromContext: anObject environment: anInteger

	[
		^super debugString: aString fromContext: anObject environment: anInteger.
	] on: CompileWarning do: [:ex | 
		ex resume.
	].

%

category: 'category'
method: JadeServer64bit3x
describeMethod: aMethod
	"Provide info needed to create a GsMethod in Jade client"

	(aMethod class name == #'GsNMethod') ifFalse: [self error: 'Expected a GsNMethod but got ' , aMethod class name].
	^super describeMethod: aMethod
%

category: 'category'
method: JadeServer64bit3x
environment

	^environment
%

category: 'category'
method: JadeServer64bit3x
environment: anInteger

	environment := anInteger.

%

category: 'category'
method: JadeServer64bit3x
environmentForMethod: aGsNMethod

	^aGsNMethod environmentId
%

category: 'category'
method: JadeServer64bit3x
executeString: aString fromContext: anObject environment: anInteger

	[
		^super executeString: aString fromContext: anObject environment: anInteger.
	] on: CompileWarning do: [:ex | 
		ex resume.
	].

%

category: 'category'
method: JadeServer64bit3x
homeMethodFor: aGsMethod

	| result |
	result := super homeMethodFor: aGsMethod.
	(result class name == #'GsNMethod') ifFalse: [self error: 'Expected a GsNMethod but got ' , result class name].
	^result
%

category: 'category'
method: JadeServer64bit3x
initialize

	super initialize.
	environment := 0.

%

category: 'category'
method: JadeServer64bit3x
inspect: anObject
	| dynamic dynamicSize indexedSize instVarNames namedSize stream string isRcBag |
	(self isClientForwarder: anObject) ifTrue: [^self inspectClientForwarder: anObject].
	(stream := WriteStream on: String new)
		nextPutAll: anObject class name; tab;
		yourself.
	(self oopOf: anObject) printOn: stream.
	stream lf.
	(anObject isKindOf: Dictionary superclass) ifTrue: [^self inspectDictionary: anObject on: stream].
	instVarNames := anObject class allInstVarNames.
	namedSize := instVarNames size.
	dynamic := anObject dynamicInstanceVariables.
	dynamicSize := dynamic size.
	isRcBag := anObject class name == #RcIdentityBag.
	indexedSize := (anObject class isNsc or: [anObject class isIndexable]) ifFalse: [
		0.
	] ifTrue: [
		isRcBag ifTrue: [ anObject size] ifFalse: [(anObject _primitiveSize - namedSize)].
	].
	
	namedSize + dynamicSize + indexedSize printOn: stream.
	stream lf.
	1 to: instVarNames size do: [:i | 
		stream nextPutAll: (instVarNames at: i); tab.
		self print: (self oopOf: (anObject instVarAt: i)) on: stream.
		stream lf.
	].
	1 to: dynamicSize do: [:i | 
		stream nextPutAll: (dynamic at: i); tab.
		self print: (self oopOf: (anObject dynamicInstVarAt: (dynamic at: i))) on: stream.
		stream lf.
	].
	isRcBag
		ifTrue: [ |aBag |
			aBag := anObject _asIdentityBag.
			1 to: indexedSize do: [:i | 
				i printOn: stream.
				stream tab.
				self print: (self oopOf: (aBag _at: i )) on: stream.
				stream lf]]
		ifFalse: [
			1 to: indexedSize do: [:i | 
				i printOn: stream.
				stream tab.
				self print: (self oopOf: (anObject _primitiveAt: i + namedSize)) on: stream.
				stream lf] ].

	(string := anObject printString) size > 100000 ifTrue: [string := (string copyFrom: 1 to: 100000) , '...'].
	string class == String ifFalse: [
		string := String withAll: (string collect: [:each | (32 <= each codePoint and: [each codePoint <= 255]) ifTrue: [each] ifFalse: [$?]]).
	].
	^stream 
		nextPutAll: string; 
		contents.
%

category: 'category'
method: JadeServer64bit3x
inspectNamedInstanceVariablesOf: anObject on: aStream

	| list dynamic size |
	list := anObject class allInstVarNames.
	dynamic := anObject dynamicInstanceVariables.
	size := list size + dynamic size.
	anObject class format > 0 ifTrue: [
		size := size + (anObject _basicSize min: 200).
	].
	size printOn: aStream.
	aStream lf.
	1 to: list size do: [:i | 
		aStream nextPutAll: (list at: i); tab.
		self print: (self oopOf: (anObject instVarAt: i)) on: aStream.
		aStream lf.
	].
	1 to: dynamic size do: [:i | 
		aStream nextPutAll: (dynamic at: i); tab.
		self print: (self oopOf: (anObject dynamicInstVarAt: (dynamic at: i))) on: aStream.
		aStream lf.
	].

%

category: 'transcript'
method: JadeServer64bit3x
installTranscript

	Transcript class name == #'TranscriptStreamPortable' ifFalse: [^self].
	SessionTemps current at: #'TranscriptStream_SessionStream' put: self.
%

category: 'category'
method: JadeServer64bit3x
methodSignatureForSelector: aSymbol
	"Ruby bridge methods can have some strange selectors!"

	| class comma i j method source |
	environment ~~ 1 ifTrue: [^aSymbol].
	class := selectedClass whichClassIncludesSelector: aSymbol environmentId: environment.
	method := class compiledMethodAt: aSymbol environmentId: environment.
	source := (method sourceString subStrings: Character lf) first trimBlanks.
	(4 < source size and: [(source copyFrom: 1 to: 4) = 'def ']) ifTrue: [
		source := source copyFrom: 5 to: source size.
		(source includes: $#) ifTrue: [source := (source copyFrom: 1 to: (source indexOf: $#) - 1) trimBlanks].
		^source.
	].
	(i := aSymbol indexOf: $#) == 0 ifTrue: [^aSymbol].
	source := aSymbol copyFrom: 1 to: i - 1.
	(aSymbol copyFrom: i to: aSymbol size) = '#0__' ifTrue: [^source].
	comma := ''.
	source add: $(.
	j := (aSymbol at: i + 1) asString asNumber.
	1 to: j do: [:k | 
		source 
			add: comma;
			add: 'arg'.
		1 < j ifTrue: [source add: k printString].
		comma := $,.
	].
	(aSymbol at: i + 2) == $* ifTrue: [
		source 
			add: comma;
			add: (0 == j ifTrue: ['args'] ifFalse: ['rest']).
		comma := $,.
	].
	aSymbol last == $& ifTrue: [
		source
			add: comma;
			add: '&block'.
	].
	source add: $).
	^source.

%

category: 'category'
method: JadeServer64bit3x
nameOfFirstDictionaryReferencing: aGlobal

	| list |
	list := self symbolList dictionariesAndSymbolsOf: aGlobal.
	list isEmpty ifTrue: [^''].
	^list first first name
%

category: 'category'
method: JadeServer64bit3x
nextPutAll: anObject

	| exception |
	exception := ClientForwarderSend new 
		receiver: self 
		clientObj: 2
		selector:#'nextPutAll:'
		args: (Array with: (self asString: anObject)).
	exception defaultAction.  "return error direct to GCI"
%

category: 'category'
method: JadeServer64bit3x
objectSecurityPolicyFor: anObject

	^anObject objectSecurityPolicy.

%

category: 'category'
method: JadeServer64bit3x
packagePolicy: aPackagePolicy includesSelector: aSymbol forClass: aClass

	| dict |
	^aPackagePolicy notNil and: [
		(dict := aClass transientMethodDictForEnv: environment) notNil and: [
			dict keys includes: aSymbol.		"includesKey: requires protected mode!"
		].
	].

%

category: 'category'
method: JadeServer64bit3x
sbBrowseMethodsWithPragma: anOrderedCollection

	| methods symbol |
	symbol := anOrderedCollection removeFirst asSymbol.
	methods := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				(Array with: eachGlobal class with: eachGlobal) do: [:eachBehavior | 
					(eachBehavior methodDictForEnv: environment) do: [:eachMethod | 
						(eachMethod pragmas anySatisfy: [:eachPragma | symbol == eachPragma keyword]) ifTrue: [methods add: eachMethod].
					].
				].
			].
		].
	].
	writeStream 
		nextPutAll: 'browseMethodsWithPragma'; lf;
		nextPutAll: (self streamOfMethods: methods);
		yourself.

%

category: 'category'
method: JadeServer64bit3x
sbClassComment: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) thisClass rwComment: self sbNextParagraph trimSeparators.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer64bit3x
sbFileOutMethod: anOrderedCollection

	| aClass |
	aClass := self sbClassFrom: anOrderedCollection.
	writeStream nextPutAll: (aClass fileOutMethod: anOrderedCollection removeFirst asSymbol environmentId: environment).


%

category: 'category'
method: JadeServer64bit3x
sbListMethodPragmas: aList

	| pragmas |
	pragmas := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				(Array with: eachGlobal with: eachGlobal class) do: [:eachBehavior | 
					(eachBehavior methodDictForEnv: environment) do: [:eachMethod | 
						pragmas addAll: (eachMethod pragmas collect: [:eachPragma | eachPragma keyword]).
					].
				].
			].
		].
	].
	pragmas asSortedCollection do: [:each | writeStream nextPutAll: each; tab].
	^pragmas
%

category: 'category'
method: JadeServer64bit3x
sbMethod: anOrderedCollection

	| behavior category string gsMethod |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection notEmpty ifTrue: [anOrderedCollection removeFirst] ifFalse: ['other'].
	string := self sbNextParagraph.
	gsMethod := behavior
		compileMethod: string 
		dictionaries: self symbolList 
		category: category asSymbol 
		environmentId: environment.
	selections 
		at: #'methodCategory' 	put: (self _behavior: gsMethod inClass categoryOfSelector: gsMethod selector) asString;
		at: #'method'			put: gsMethod selector asString;
		yourself.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodBreakPointsFor: aMethod
	"Answers an Array of step points"

	| list array |
	(array := aMethod _allBreakpoints) isNil ifTrue: [^#()].      "{ breakpointNumber1 . method . ipOffset1 . ... }"
	list := Array new.
	1 to: array size by: 3 do:[:k |
		list add: (aMethod
			_stepPointForMeth: (array at: k + 1)
			ip: (array at: k + 2)).
	].
	^list.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodPragmas

	selectedClass notNil ifTrue:[
		methodCommandResult selections add: selectedClass asString].
	methodCommandResult updateMethodPragmas.
	methodCommandResult writeMethodFiltersTo: writeStream. 
	methodCommandResult updateMethodFilterSelections: self nextLineAsList 
		hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodCommandResult selectionNames.
	methodCommandResult writeSelectionsTo: writeStream. 


%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodsByCategories

	| selectors |
	selectors := IdentitySet new.
	classList do: [:eachClass |
		(eachClass selectorsForEnvironment: environment) do: [:eachSelector |
			(methodFilters isEmpty or: [
				| category |
				category := eachClass categoryOfSelector: eachSelector environmentId: environment.
				(category isNil and: [ methodFilters includes: #'other']) or: [ methodFilters includes: category asSymbol]]) ifTrue: [
				| method |
				method := eachClass compiledMethodAt: eachSelector environmentId: environment.
				(method respondsTo: #isRubyBridgeMethod)
					ifTrue: [ 
						method isRubyBridgeMethod ifFalse: [
							selectors add: eachSelector ] ]
					ifFalse: [ selectors add: eachSelector ]
			].
		].
	].
	^selectors.
%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodsByPragmas

	| selectors |
	selectors := IdentitySet new.
	methodFilters isEmpty ifTrue: [^#()].
	(selectedClass selectorsForEnvironment: environment) do: [:eachSelector | 
		| gsMethod |
		gsMethod := selectedClass compiledMethodAt: eachSelector environmentId: environment.
		gsMethod pragmas do: [:eachPragma | 
			( methodFilters includes: eachPragma keyword) ifTrue: [selectors add: eachSelector].
		].
	].
	^selectors.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodsByVariables

	| selectors filters |
	selectors := IdentitySet new.
	filters := IdentitySet withAll: (methodFilters select: [:each | each isSymbol]).
	(selectedClass selectorsForEnvironment: environment) do: [:eachSelector | 
		| gsMethod |
		gsMethod := selectedClass compiledMethodAt: eachSelector environmentId: environment.
		(gsMethod instVarsAccessed * filters) notEmpty ifTrue: [selectors add: eachSelector].
	].
	^selectors.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodStepPointsFor: aMethod
	"Answers an Array of Associations (offset -> selector) indexed by step point"

	|  selectors list |
	(selectors := aMethod _allDebugInfo: 10) ifNil: [^#()].
	list := (self homeMethodFor: aMethod)  _sourceOffsets.
	list := list collect: [:each | 		"exists as far back as 32-bit 6.3.0"
		| index selector |
		selector := ''.
		index := selectors indexOf: each.
		0 < index ifTrue: [selector := selectors at: index + 1].
		each -> selector.
	].
	^list.


%

category: 'category'
method: JadeServer64bit3x
selectedClassOverridesSelector: aSymbol

	^selectedClass superclass notNil and: [(selectedClass superclass whichClassIncludesSelector: aSymbol environmentId: environment) ~~ nil].

%

category: 'transcript'
method: JadeServer64bit3x
uninstallTranscript

	Transcript class name == #'TranscriptStreamPortable' ifFalse: [^self].
	SessionTemps current at: #'TranscriptStream_SessionStream' put: nil.
%

category: 'category'
method: JadeServer64bit3x
_allSelectors

	| allSelectors |
	allSelectors := IdentitySet new.
	self classOrganizer classes do: [:each | 
		allSelectors addAll: (each selectorsForEnvironment: environment); addAll: (each class selectorsForEnvironment: environment).
	].
	^allSelectors
%

category: 'category'
method: JadeServer64bit3x
_behavior: aBehavior categoryOfSelector: aSymbol

	^aBehavior categoryOfSelector: aSymbol environmentId: environment
%

category: 'category'
method: JadeServer64bit3x
_describeMethod: aMethod

	(aMethod class name == #'GsNMethod') ifFalse: [self error: 'Expected a GsNMethod but got ' , aMethod class name].
	^super _describeMethod: aMethod
%

category: 'category'
method: JadeServer64bit3x
_methodsFor: aClass categories: aList

	| methods |
	methods := IdentitySet new.
	aList do: [:eachCategory | 
		(aClass includesCategory: eachCategory) ifTrue: [
			(aClass selectorsIn: eachCategory) do: [:eachSelector |
				methods add: (self compiledMethodAt: eachSelector inClass: aClass).
			].
		].
	].
	^methods.


%

category: 'category'
method: JadeServer64bit3x
_stepPointsForBreaksInMethod: gsMethod
	"Presumably there is a way to do this, just not the same as 32-bit and 64-bit 2.x"

	^#()
%

! Class implementation for 'JadeServer64bit32'

!		Instance methods for 'JadeServer64bit32'

category: 'category'
method: JadeServer64bit32
dictionaryAndSymbolOf: aClass

	| array |
	array := self symbolList dictionariesAndSymbolsOf: aClass.
	^array isEmpty
		ifTrue: [nil]
		ifFalse: [array first].

%

category: 'category'
method: JadeServer64bit32
dictionaryAndSymbolOf: aClass forUser: aUserProfile

	| array |
	array := aUserProfile symbolList dictionariesAndSymbolsOf: aClass.
	^array isEmpty
		ifTrue: [nil]
		ifFalse: [array first].

%

category: 'category'
method: JadeServer64bit32
gsPackagePolicy

	| class |
	class := self gsPackagePolicyClass.
	class isNil ifTrue: [^nil].
	class enabled ifFalse: [^nil].
	^class current

%

category: 'category'
method: JadeServer64bit32
stepThrough: aGsProcess inFrame: anInteger
  aGsProcess _stepThrough
%

! Class implementation for 'JadeServer64bit35'

!		Instance methods for 'JadeServer64bit35'

category: 'other'
method: JadeServer64bit35
stepThrough: aGsProcess inFrame: anInteger
  aGsProcess stepThroughFromLevel: anInteger
%

! Class implementation for 'MemoryFileSystemEntry'

!		Class methods for 'MemoryFileSystemEntry'

category: 'instance creation'
classmethod: MemoryFileSystemEntry
named: aFileName
	^ self new
		basename: aFileName;
		yourself
%

category: 'instance creation'
classmethod: MemoryFileSystemEntry
new

	^ self basicNew
		initialize;
		yourself
%

!		Instance methods for 'MemoryFileSystemEntry'

category: 'accessing'
method: MemoryFileSystemEntry
basename
	^ basename
%

category: 'accessing'
method: MemoryFileSystemEntry
basename: aString
	basename := aString
%

category: 'accessing'
method: MemoryFileSystemEntry
creationTime
	
	^ creationTime
%

category: 'accessing'
method: MemoryFileSystemEntry
fileSize
	self subclassResponsibility 
%

category: 'initialization'
method: MemoryFileSystemEntry
initialize 
	creationTime := modificationTime := DateAndTime now.
%

category: 'testing'
method: MemoryFileSystemEntry
isDirectory
	self subclassResponsibility
%

category: 'testing'
method: MemoryFileSystemEntry
isFile
	^ self isDirectory not
%

category: 'accessing'
method: MemoryFileSystemEntry
modificationTime
	^ modificationTime
%

category: 'accessing'
method: MemoryFileSystemEntry
modificationTime: anObject
	
	modificationTime := anObject
%

category: 'private'
method: MemoryFileSystemEntry
modified
	modificationTime := DateAndTime now.
%

! Class implementation for 'MemoryFileSystemDirectory'

!		Instance methods for 'MemoryFileSystemDirectory'

category: 'creation'
method: MemoryFileSystemDirectory
ensureCreateDirectory: aDirectoryName
	^ self 
		fileEntryAt: aDirectoryName
		put: (self class named: aDirectoryName)
%

category: 'creation'
method: MemoryFileSystemDirectory
ensureCreateFile: aFileName
	^ self 
		fileEntryAt: aFileName 
		put: (MemoryFileSystemFile named: aFileName)
%

category: 'accessing'
method: MemoryFileSystemDirectory
entries
	^ entries
%

category: 'enumeration'
method: MemoryFileSystemDirectory
fileEntriesDo: aBlock
	
	entries keys sort do: [ :fileName|
		aBlock value: (entries at: fileName)].
%

category: 'accessing'
method: MemoryFileSystemDirectory
fileEntriesIncludes: aFileName
	^ entries includesKey: aFileName
%

category: 'accessing'
method: MemoryFileSystemDirectory
fileEntryAt: aFileName
	^ entries at: aFileName
%

category: 'accessing'
method: MemoryFileSystemDirectory
fileEntryAt: aFileName ifAbsent: aBlock
	^ entries at: aFileName ifAbsent: aBlock
%

category: 'accessing'
method: MemoryFileSystemDirectory
fileEntryAt: aFileName ifPresent: aBlock
	^ (entries at: aFileName ifAbsent: [])
			ifNotNil: [:entry | aBlock value: entry ]
%

category: 'accessing'
method: MemoryFileSystemDirectory
fileEntryAt: aFileName put: anEntry
	^ entries 
		at: aFileName 
		ifAbsentPut: [
			self modified.
			anEntry ]
%

category: 'accessing'
method: MemoryFileSystemDirectory
fileEntryRemove: aFileName
	^ self fileEntryRemove: aFileName ifAbsent: [ FileDoesNotExistException signalWith: aFileName ]
%

category: 'accessing'
method: MemoryFileSystemDirectory
fileEntryRemove: aFileName ifAbsent: absentBlock
	| deletedEntry |
	deletedEntry := entries removeKey: aFileName ifAbsent: [ ^ absentBlock value ].
	modificationTime := DateAndTime now.
	^ deletedEntry
%

category: 'accessing'
method: MemoryFileSystemDirectory
fileSize
	^ 0
%

category: 'initialization'
method: MemoryFileSystemDirectory
initialize
	super initialize.
	entries := Dictionary new.
%

category: 'testing'
method: MemoryFileSystemDirectory
isDirectory
	^ true
%

! Class implementation for 'MemoryFileSystemFile'

!		Instance methods for 'MemoryFileSystemFile'

category: 'stream-protocol'
method: MemoryFileSystemFile
at: index
	^ bytes at: index
%

category: 'stream-protocol'
method: MemoryFileSystemFile
at: index put: anObject
	index > bytes size
		ifTrue: [ self grow ].
	bytes
		at: index
		put:
			(anObject isCharacter
				ifTrue: [ anObject codePoint ]
				ifFalse: [ anObject ]).
	size := size max: index.
	self modified
%

category: 'stream-protocol'
method: MemoryFileSystemFile
at: index read: aCollection startingAt: start count: count 
	| max stop |
	max := size - index + 1 min: count.
	stop := start + max - 1.
	aCollection 
		replaceFrom: start
		to: stop
		with: bytes
		startingAt: index.
	^ stop - start + 1
%

category: 'stream-protocol'
method: MemoryFileSystemFile
at: first write: aCollection startingAt: start count: count
	| last |
	last := first + count - 1.
	last > bytes size
		ifTrue: [ self grownBy: last - size ].
	bytes
		replaceFrom: first
		to: last
		with: aCollection
		startingAt: start.
	size := last.
	self modified
%

category: 'open/close'
method: MemoryFileSystemFile
basicOpen
	closed := false
%

category: 'streams-compatibility'
method: MemoryFileSystemFile
binaryReadStream
	^ ReadStreamPortable on: self bytes from: 1 to: size
%

category: 'streams'
method: MemoryFileSystemFile
binaryWriteStream
	^ MemoryFileWriteStream on: self
%

category: 'accessing'
method: MemoryFileSystemFile
bytes
	^ bytes
%

category: 'open/close'
method: MemoryFileSystemFile
close
	 closed := true
%

category: 'testing'
method: MemoryFileSystemFile
closed
	^ closed
%

category: 'stream-protocol'
method: MemoryFileSystemFile
copyFrom: from to: position
	^ bytes copyFrom: from to: position
%

category: 'accessing'
method: MemoryFileSystemFile
fileSize
	^ size
%

category: 'stream-protocol'
method: MemoryFileSystemFile
grow
	self grownBy: self sizeIncrement
%

category: 'accessing'
method: MemoryFileSystemFile
grownBy: length
	bytes := bytes grownBy: length.
	self modified
%

category: 'initialization'
method: MemoryFileSystemFile
initialize
	super initialize.
	bytes := ByteArray new.
	size := 0.
	closed := false
%

category: 'accessing'
method: MemoryFileSystemFile
internalSize
	^ bytes size
%

category: 'testing'
method: MemoryFileSystemFile
isDirectory
	^ false
%

category: 'stream-protocol'
method: MemoryFileSystemFile
readStream
	^ ReadStream on: self bytes asString from: 1 to: size
%

category: 'accessing'
method: MemoryFileSystemFile
size

	^ size
%

category: 'accessing'
method: MemoryFileSystemFile
sizeIncrement
	^ (bytes size min: 20) max: 1024
%

category: 'accessing'
method: MemoryFileSystemFile
truncate
	self truncateTo: size
%

category: 'accessing'
method: MemoryFileSystemFile
truncateTo: aSize
	bytes size = aSize
		ifFalse: [ bytes := bytes size < aSize
				ifTrue: [ (ByteArray new: aSize)
						replaceFrom: 1
						to: bytes size
						with: bytes
						startingAt: 1 ]
				ifFalse: [ bytes copyFrom: 1 to: aSize ] ].
	size := bytes size.
	self modified
%

category: 'private'
method: MemoryFileSystemFile
updateContents: aCollection
	bytes := aCollection.
	self updateSize: aCollection size
%

category: 'private'
method: MemoryFileSystemFile
updateSize: newSize
	size := newSize.
	self modified
%

category: 'stream-protocol'
method: MemoryFileSystemFile
writeStreamDo: aBlock
	ByteArray
		streamContents: [ :aStream | 
			aBlock value: aStream.
			bytes := aStream contents ].
	self updateSize: bytes size
%

! Class implementation for 'MemoryFileWriteStream'

!		Class methods for 'MemoryFileWriteStream'

category: 'instance creation'
classmethod: MemoryFileWriteStream
on: aFile

	^ self new
		file: aFile;
		yourself
%

!		Instance methods for 'MemoryFileWriteStream'

category: 'opening-closing'
method: MemoryFileWriteStream
close
	self stream close.
	file close
%

category: 'opening-closing'
method: MemoryFileWriteStream
closed
	^ file closed
%

category: 'accessing'
method: MemoryFileWriteStream
file: aMemoryFileSystemFile 
	file := aMemoryFileSystemFile
%

category: 'writing'
method: MemoryFileWriteStream
flush
	file updateContents: self stream contents
%

category: 'testing'
method: MemoryFileWriteStream
isBinary
	^ self stream isBinary
%

category: 'writing'
method: MemoryFileWriteStream
nextPut: aCollection
	^ self stream nextPut: aCollection
%

category: 'writing'
method: MemoryFileWriteStream
nextPutAll: aCollection
	^ self stream nextPutAll: aCollection
%

category: 'positioning'
method: MemoryFileWriteStream
position
	^ self stream position
%

category: 'positioning'
method: MemoryFileWriteStream
setToEnd
	^ self stream setToEnd
%

category: 'accessing'
method: MemoryFileWriteStream
size
	^ file size
%

category: 'accessing'
method: MemoryFileWriteStream
stream
	^ stream ifNil: [ stream := WriteStreamPortable on: file bytes from: 1 to: file size ]
%

! Class implementation for 'Path'

!		Class methods for 'Path'

category: 'instance creation'
classmethod: Path
* aString
	"Answer a relative path with aString as its sole segment. For example,
	Path * 'griffle' will produce the same result as ./griffle in a unix shell.
	The selector #* was chosen for it's visual similarity to $."
	
	"Note: aString is not parsed, so supplying a string like '/griffle/plonk'
	will not create an absolute path."
	
	^ RelativePath with: aString
%

category: 'instance creation'
classmethod: Path
/ aString
	"Answer an absolute path with aString as it's sole segment. The selector
	was chosen to allow path construction with Smalltalk syntax, which 
	neverthelesss resembles paths as they appear in a unix shell. Eg.
	Path / 'griffle' / 'plonk'."
	
	aString isEmptyOrNil 
		ifTrue: [ Error signal: 'Path element cannot be empty or nil'].
	^ AbsolutePath with: aString
%

category: 'private'
classmethod: Path
addElement: element to: result
	element = '..'
		ifTrue: [ ^ self addParentElementTo: result ].
	element = ''
		ifTrue: [ ^ self addEmptyElementTo: result ].
	element = '.'
		ifFalse: [ result add: element ]
%

category: 'private'
classmethod: Path
addEmptyElementTo: result
	result isEmpty ifTrue: [result add: '']
		
%

category: 'private'
classmethod: Path
addParentElementTo: result
	(result isEmpty or: [ result last = '..' ])
		ifTrue: [ result add: '..' ]
		ifFalse: [ result removeLast ]
		
%

category: 'private'
classmethod: Path
canonicalizeElements: aCollection
	| result |
	result := OrderedCollection new.
	aCollection do: [ :element |
		self addElement: element to: result].
	^ result
%

category: 'encodings'
classmethod: Path
delimeter
	"Internal path delimeter"
	
	^$/
%

category: 'encodings'
classmethod: Path
extensionDelimiter
	"Return the extension delimiter character."
	^ $.
%

category: 'instance creation'
classmethod: Path
from: aString
	"Answer an instance of the receiver with the supplied path using the default delimiter"

	^ self from: aString delimiter: self delimeter
%

category: 'instance creation'
classmethod: Path
from: aString delimiter: aDelimiterCharacter 
	"Answer a path composed of several elements delimited by aCharacter"
	| pathClass splitPathElements |
	aString isEmpty
		ifTrue: [ ^ self root ].

	aString first = $$
		ifTrue: [
			| pathElements envVarString envVarElement eVar |
			"GemStone paths are allowed to start with an environment variable"
			pathElements := aDelimiterCharacter split: aString.
			envVarElement := (pathElements at: 1) .
			envVarString := System gemEnvironmentVariable: (eVar := envVarElement copyFrom: 2 to: envVarElement size). 
      envVarString ifNil:[ Error signal:'environment variable ' , eVar ,' not defined']. 
      envVarString := envVarString decodeFromUTF8 asString .
			pathClass :=  ((self isAbsolutePath: envVarString delimiter: aDelimiterCharacter) or: 
									[self isAbsoluteWindowsPath: envVarString]) 
				ifTrue: [ AbsolutePath ]
				ifFalse:[ RelativePath ].
			splitPathElements :=  (aDelimiterCharacter split: envVarString) , (pathElements copyFrom: 2 to: pathElements size) ]
		ifFalse: [ 	
			pathClass :=  ((self isAbsolutePath: aString delimiter: aDelimiterCharacter) or: 
									[self isAbsoluteWindowsPath: aString]) 
				ifTrue: [ AbsolutePath ]
				ifFalse:[ RelativePath ] .
			splitPathElements := aDelimiterCharacter split: aString. ].
	
	^ pathClass withAll: splitPathElements
%

category: 'ston'
classmethod: Path
fromSton: stonReader
	| elements |
	elements := Array streamContents: [ :out |
		stonReader parseListDo: [ :each | out nextPut: each ] ].
	^ self withAll: elements
%

category: 'private'
classmethod: Path
isAbsolutePath: aString delimiter: aCharacter
	"Answer a boolean indicating whether the supplied path is considered absolute"

	^aString first = aCharacter
%

category: 'private'
classmethod: Path
isAbsoluteUnixPath: aString
	^aString first = $/ 
%

category: 'private'
classmethod: Path
isAbsoluteWindowsPath: aString
	aString ifEmpty: [ ^ false ].
	(aString first = $\) ifTrue: [ ^ true ]. "e.g. \file"
	^ ((aString size > 2) and: [ aString first isLetter ])
		ifTrue: [ (aString second = $:) and: [aString third = $\] ] "e.g. C:\..."
		ifFalse: [ false ]
%

category: 'instance creation'
classmethod: Path
parent
	"Answer a path that resolves to the parent of the current
	working directory. This is similar to .. in unix, but doesn't
	rely on actual hardlinks being present in the filesystem."

	^ RelativePath with: '..'
%

category: 'instance creation'
classmethod: Path
parents: anInteger
	| path |
	path := self new: anInteger.
	1 to: anInteger do: [:i | path at: i put: '..'].
	^ path
%

category: 'private'
classmethod: Path
removeRedundantSegments: segments
	"Remove redundant elements ('.' and '') from the supplied segments"

	^segments select:
		[ :segment | segment notEmpty and: [ segment ~= '.' ] ]
%

category: 'instance creation'
classmethod: Path
root
	"Answer the root path - ie, / on unix"
	
	^ AbsolutePath new
%

category: 'private'
classmethod: Path
with: aString
	"Answer an instance of the receiver representing the supplied string.
	This should only be sent to one of the concrete subclasses, e.g. AbsolutePath and RelativePath"
	| inst parsedCollection |

	parsedCollection := self delimeter split: aString.
	parsedCollection := self removeRedundantSegments: parsedCollection.
	inst := self new: parsedCollection size.
	parsedCollection withIndexDo: [:segment :index |
		inst at: index put: segment].
	^ inst
%

category: 'private'
classmethod: Path
withAll: aCollection
	"Answer an instance of the receiver representing the supplied collection of strings.
	This should only be sent to one of the concrete subclasses, e.g. AbsolutePath and RelativePath"
	| inst parsedCollection |

	parsedCollection := OrderedCollection new: (aCollection size max: 10).
	aCollection do: [ :each |
		parsedCollection addAll: (self delimeter split: each) ].
	parsedCollection := self removeRedundantSegments: parsedCollection.
	inst := self new: parsedCollection size.
	parsedCollection withIndexDo: [:segment :index |
		inst at: index put: segment].
	^ inst
%

category: 'instance creation'
classmethod: Path
workingDirectory
	"Answer a path that will always resolve to the current working directory."
	
	^ RelativePath new
%

!		Instance methods for 'Path'

category: 'navigating'
method: Path
, extension 
	^ self withName: self basename extension: extension
%

category: 'navigating'
method: Path
/ aString
	"aString is either a file or path.  If aString is relative, it is appended to the receiver, if it is absolute, an instance of the receiver with the path is answered"

	aString isEmptyOrNil 
		ifTrue: [ Error signal: 'Path element cannot be empty or nil'].

	^self resolvePath: (self class from: aString)
%

category: 'comparing'
method: Path
<= other
	^ self fullName <= other fullName
%

category: 'comparing'
method: Path
= other
	^ self species = other species
		and: [self size = other size
			and: [(1 to: self size) allSatisfy: [:i | (self at: i) = (other at: i)]]]
%

category: 'converting'
method: Path
asPath
	^ self
%

category: 'converting'
method: Path
asPathWith: anObject
	^ self
%

category: 'navigating'
method: Path
asResolvedBy: anObject
	^ anObject resolvePath: self
%

category: 'accessing'
method: Path
base
	^self basenameWithoutExtension 
%

category: 'accessing'
method: Path
basename
	"Returns the base of the basename, 
		i.e. 
		/foo/gloops.taz basename is 'gloops.taz'
		If empty, it is the emptyPathString"

	self isEmpty ifTrue: 
		[ ^ self emptyPathString ].
	^ self at: self size
%

category: 'accessing'
method: Path
basename: newBasename
	"change the basename"
	self size == 0
		"the root node"
		ifTrue: [ ^ Error signal: '0 length Path, cannot change basename'].
	self at: self size put: newBasename
%

category: 'accessing'
method: Path
basenameWithoutExtension
	"Returns the base of the basename but without its extension, 
		i.e. 
		/foo/gloops.taz basenameWithoutExtension is 'gloops'
		/ basenameWithoutExtension is '/'"
	
	^ self basename copyUpToLast: self extensionDelimiter
%

category: 'accessing'
method: Path
basenameWithoutExtension: anExtension
	"Returns the basename without specified extension (if any)
	('/foo/gloops.taz' asPath basenameWithoutExtension: 'taz') = 'gloops'
	"
	| extensionWithDelimiter |

	extensionWithDelimiter := anExtension copyWithFirst: self extensionDelimiter.
	(self basename endsWith: extensionWithDelimiter)
		ifTrue: [^ self basename allButLast: extensionWithDelimiter size]
		ifFalse: [ ^ self basename ]
%

category: 'navigating'
method: Path
canonicalize
	"Answer the receiver with references to the current folder (.) and parent folder (..) removed"
	
	^self class withAll: (self class canonicalizeElements: self segments).
%

category: 'comparing'
method: Path
contains: anObject
	"Return true if anObject is in a subfolder of me"
	^ anObject isContainedBy: self
%

category: 'comparing'
method: Path
containsPath: aPath
	self size < aPath size ifFalse: [^ false].
	1	to: self size 
		do: [:i | (self at: i) = (aPath at: i) ifFalse: [^ false]].
	^ true
%

category: 'comparing'
method: Path
containsReference: aReference
	^ false
%

category: 'private'
method: Path
copyFrom: aPath
	| size |
	size := aPath size min: self size.
	1 to: size do: [:i | self at: i put: (aPath at: i)].
	
%

category: 'accessing'
method: Path
delimiter
	^ $/
%

category: 'enumerating'
method: Path
do: aBlock 
	1 
		to: self size
		do: 
			[ :index || segment |
			segment := self at: index.
			segment isEmpty ifFalse: [ aBlock value: segment ] ]
%

category: 'accessing'
method: Path
emptyPathString
	"Answer the string representing an empty (size = 0) instance of the receiver"

	^self delimiter asString
%

category: 'accessing'
method: Path
extension
	"Return the extension of path basename i.e., /foo/gloops.taz extension is 'taz'"
	
	^ self basename copyAfterLast: self extensionDelimiter
%

category: 'accessing'
method: Path
extensionDelimiter
	^ self class extensionDelimiter
%

category: 'accessing'
method: Path
extensions
	"Return the extensions of the receiver in order of appearance"
	"(Path from: '/foo/bar.tar.gz') extensions"
	^ (self extensionDelimiter split: self basename) allButFirst
%

category: 'accessing'
method: Path
fullName
	"Return the fullName of the receiver."
	
	^ self pathString
%

category: 'comparing'
method: Path
hash

"Returns a numeric hash key for the receiver."

| mySize interval hashValue |

(mySize := self size) == 0
  ifTrue: [ ^15243 ].

"Choose an interval so that we sample at most 5 elements of the receiver"
interval := ((mySize - 1) // 4) max: 1.

hashValue := 4459.
1 to: mySize by: interval do: [ :i | | anElement |
  anElement := self at: i.
  hashValue := (hashValue bitShift: -1) bitXor: anElement hash.
  ].

^ hashValue abs
%

category: 'testing'
method: Path
isAbsolute
	self subclassResponsibility 
%

category: 'private'
method: Path
isAllParents
	1 to: self size do: [:i | (self at: i) = '..' ifFalse: [^ false]].
	^ true
%

category: 'comparing'
method: Path
isChildOf: anObject
	^ self parent = anObject
%

category: 'comparing'
method: Path
isContainedBy: anObject
	"DoubleDispatch helper for #contains:"
	^ anObject containsPath: self
%

category: 'testing'
method: Path
isEmpty
	^ self size = 0
%

category: 'testing'
method: Path
isRelative
	^ self isAbsolute not
%

category: 'testing'
method: Path
isRoot
	self subclassResponsibility 
%

category: 'testing'
method: Path
isWorkingDirectory
	^ self size = 0
%

category: 'private'
method: Path
lengthOfStemWith: aPath
	| limit index |
	limit := self size min: aPath size.
	index := 1.
	[index <= limit and: [(self at: index) = (aPath at: index)]] 
		whileTrue: [index := index + 1].
	^ index - 1
%

category: 'navigating'
method: Path
makeRelative: anObject
	^ anObject relativeToPath: self
%

category: 'navigating'
method: Path
parent
	| size parent |
	self isRoot ifTrue: [^ self].
	self isAllParents ifTrue: [^ self / '..'].
	
	size := self size - 1.
	parent := self class new: size.
	1 to: size do: [:i | parent at: i put: (self at: i)].
	^ parent
%

category: 'navigating'
method: Path
parentUpTo: aParentDirName
	"Answers the path of the parent dir with name aParentDirName or root if not found."

	self withParents
		reverseDo: [ :dir | 
			dir basename = aParentDirName
				ifTrue: [ ^ dir ] ].
	^ Path root
%

category: 'printing'
method: Path
pathString
	"Return a string containing the path elements of the receiver, without the 'Path *' part"

	"((FileSystem workingDirectory / 'book-result' / 'W01-Welcome')
		relativeToReference: FileSystem workingDirectory) pathString
	>>> 'book-result/W01-Welcome'"

	^String streamContents: [ :stream | 
		self printPathOn: stream delimiter: self delimiter ]
%

category: 'printing'
method: Path
printOn: aStream 
	self printOn: aStream delimiter: self delimiter.
%

category: 'printing'
method: Path
printOn: aStream delimiter: aCharacter
	(1 to: self size)
		do: [:index | aStream nextPutAll: (self at: index)]
		separatedBy: [aStream nextPut: aCharacter]
%

category: 'printing'
method: Path
printPathOn: aStream
	"Print the receiver's path on aStream (without 'Path' prepended) using the default delimiter"
	"String streamContents: [ :str| 
		((FileSystem workingDirectory / 'book-result' / 'W01-Welcome') 
			relativeToReference: FileSystem workingDirectory) printPathOn: str]
	>>> 'book-result/W01-Welcome'"

	self printPathOn: aStream delimiter: self delimiter.
%

category: 'printing'
method: Path
printPathOn: aStream delimiter: aCharacter
	"Print the receiver's path on aStream (without 'Path' prepended)"
	"String streamContents: [ :str| 
		((FileSystem workingDirectory / 'book-result' / 'W01-Welcome')
			relativeToReference: FileSystem workingDirectory) printPathOn: str delimiter: $|]
	>>> 'book-result|W01-Welcome'"

	(1 to: self size)
		do: [:index | aStream nextPutAll: (self at: index)]
		separatedBy: [aStream nextPut: aCharacter]
%

category: 'printing'
method: Path
printWithDelimiter: aCharacter
	^ String streamContents: [:out | self printOn: out delimiter: aCharacter]
%

category: 'navigating'
method: Path
relativeTo: anObject
	^ anObject makeRelative: self
%

category: 'navigating'
method: Path
relativeToPath: aPath
	"Return the receiver as relative to the argument aPath"

	"(Path / 'griffle' / 'plonk' / 'nurp') 
		relativeToPath: (Path / 'griffle') 
			returns  plonk/nurp"

	| prefix relative |
	prefix := self lengthOfStemWith: aPath.
	relative := RelativePath parents: aPath size - prefix.
	prefix + 1 to: self size do: [ :i | relative := relative / (self at: i) ].
	^ relative
%

category: 'navigating'
method: Path
resolve
	^ self
%

category: 'navigating'
method: Path
resolve: anObject
	"Return a path in which the argument has been interpreted in the context of the receiver. Different 
	argument types have different resolution semantics, so we use double dispatch to resolve them correctly."
	
	^ anObject asResolvedBy: self
%

category: 'navigating'
method: Path
resolvePath: aPath
	"Answers a path created by resolving the argument against the receiver.
	If the argument is abolute answer the argument itself. Otherwise, concatenate the
	two paths."

	| elements |

	aPath isAbsolute ifTrue: [^ aPath].
	elements := Array new: self size + aPath size.

	1 to: self size do: [:i | elements at: i put: (self at: i)].
	1 to: aPath size do: [:i | elements at: self size + i put: (aPath at: i)].
	
	^ self class withAll: elements
%

category: 'navigating'
method: Path
resolveReference: aReference
	^ aReference
%

category: 'navigating'
method: Path
resolveString: aString
	"Treat strings as relative paths with a single element."
	
	^ self / aString
%

category: 'accessing'
method: Path
segments
	"return an array with all the path segements separated"
	| segments |
	
	segments := OrderedCollection new.
	
	self do: [ :part|
		segments add: part
	].
	
	^ segments asArray 
%

category: 'ston'
method: Path
stonOn: stonWriter
	stonWriter 
		writeObject: self 
		streamShortList: [ :listWriter | 
			self do: [ :each | listWriter add: each ] ]
%

category: 'navigating'
method: Path
withExtension: extension 
	| basename name |
	basename := self basename.
	^ (basename endsWith: extension) 
		ifTrue: [ self ]
		ifFalse: 
			[name := basename copyUpToLast: self extensionDelimiter.
			self withName: name extension: extension]
%

category: 'private'
method: Path
withName: name extension: extension
	| basename |
	basename :=String streamContents:
		[:out |
		out nextPutAll: name.
		out nextPut: self extensionDelimiter.
		out nextPutAll: extension].
	^ self copy 
		at: self size put: basename;
		yourself
%

category: 'enumerating'
method: Path
withParents
	| paths |
	paths := OrderedCollection new.
	1 to: self size -1 do: [ :index | paths add: ((self class new: index) copyFrom: self) ].
	paths add: self.
	
	^ paths
%

! Class implementation for 'AbsolutePath'

!		Class methods for 'AbsolutePath'

category: 'as yet unclassified'
classmethod: AbsolutePath
addEmptyElementTo: result
%

category: 'as yet unclassified'
classmethod: AbsolutePath
from: aString delimiter: aDelimiterCharater
	aString = '/'
		ifTrue: [ ^ self root ].
		
	^ super from: aString delimiter: aDelimiterCharater
%

!		Instance methods for 'AbsolutePath'

category: 'printing'
method: AbsolutePath
asString
  "used by topaz stack display"
  | str sz |
  str := '/' copy .
  1 to: (sz := self size) - 1 do:[:j | str addAll: (self at: j) ; add: $/ ].
  str add: (self at: sz ).
  ^ str
%

category: 'testing'
method: AbsolutePath
isAbsolute
	^ true
%

category: 'testing'
method: AbsolutePath
isRoot
	^ self size = 0
%

category: 'printing'
method: AbsolutePath
printOn: aStream
	aStream nextPutAll: 'Path'.
	self isRoot
		ifTrue: [aStream nextPutAll: ' root']
		ifFalse:
			[1 to: self size do:
				[:i |
				aStream 
					nextPutAll: ' / ''';
				 	nextPutAll: (self at: i);
					nextPut: $']]
%

category: 'printing'
method: AbsolutePath
printPathOn: aStream delimiter: aCharacter
	"Print the path elements of the receiver, without the 'Path *' part"

	aStream nextPut: aCharacter.
	super printPathOn: aStream delimiter: aCharacter
%

category: 'enumerating'
method: AbsolutePath
withParents
	^ super withParents addFirst: (Path root); yourself
%

! Class implementation for 'RelativePath'

!		Instance methods for 'RelativePath'

category: 'accessing'
method: RelativePath
emptyPathString
	"Answer the string representing an empty (size = 0) instance of the receiver.
	For a relative path, this is the current directory"

	^'.'
%

category: 'testing'
method: RelativePath
isAbsolute
	^ false
%

category: 'testing'
method: RelativePath
isRoot
	^ false
%

category: 'printing'
method: RelativePath
printOn: aStream
	aStream nextPutAll: 'Path '.
	self isWorkingDirectory
		ifTrue: [aStream nextPutAll: 'workingDirectory']
		ifFalse: 
			[aStream 
				nextPutAll: '* ''';
				nextPutAll: (self at: 1) asString;
				nextPut: $'.
			2 to: self size do:
				[:i |
				aStream
					nextPutAll: ' / ''';
					nextPutAll: (self at: i);
					nextPut: $']]
					
			
%

category: 'printing'
method: RelativePath
printOn: aStream delimiter: aCharacter
	self isWorkingDirectory ifTrue: [aStream nextPut: $.. ^ self].
	super printOn: aStream delimiter: aCharacter
%

! Class implementation for 'RBParser'

!		Class methods for 'RBParser'

category: 'instance creation'
classmethod: RBParser
new

	^self basicNew initialize
%

category: 'accessing'
classmethod: RBParser
parseExpression: aString 
	^self parseExpression: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseExpression: aString onError: aBlock 
	| node parser |
	parser := self new.
	parser errorBlock: aBlock.
	parser initializeParserWith: aString.
	node := parser parseExpression: aString.
	^(node statements size == 1 and: [node temporaries isEmpty]) 
		ifTrue: [node statements first]
		ifFalse: [node]
%

category: 'accessing'
classmethod: RBParser
parseMethod: aString 
	^self parseMethod: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseMethod: aString onError: aBlock 
	| parser |
	parser := self new.
	parser errorBlock: aBlock.
	parser initializeParserWith: aString.
	^parser parseMethod: aString
%

category: 'parsing'
classmethod: RBParser
parseMethodPattern: aString 
	| parser |
	parser := self new.
	parser errorBlock: [:error :position | ^nil].
	parser initializeParserWith: aString.
	^parser parseMessagePattern selector
%

category: 'accessing'
classmethod: RBParser
parseRewriteExpression: aString 
	^self parseRewriteExpression: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseRewriteExpression: aString onError: aBlock 
	^RBPatternParser parseExpression: aString onError: aBlock
%

category: 'accessing'
classmethod: RBParser
parseRewriteMethod: aString 
	^self parseRewriteMethod: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseRewriteMethod: aString onError: aBlock 
	^RBPatternParser parseMethod: aString onError: aBlock
%

!		Instance methods for 'RBParser'

category: 'private'
method: RBParser
addCommentsTo: aNode
	aNode comments: aNode comments , comments.
	comments := OrderedCollection new
%

category: 'private-classes'
method: RBParser
arrayNodeClass
	^ RBArrayNode
%

category: 'private-classes'
method: RBParser
assignmentNodeClass
	^ RBAssignmentNode
%

category: 'testing'
method: RBParser
atEnd
	^currentToken class == RBToken
%

category: 'private-classes'
method: RBParser
blockNodeClass
	^ RBBlockNode
%

category: 'private-classes'
method: RBParser
cascadeNodeClass
	^ RBCascadeNode
%

category: 'error handling'
method: RBParser
errorBlock
	^errorBlock isNil ifTrue: [[:message :position | ]] ifFalse: [errorBlock]
%

category: 'accessing'
method: RBParser
errorBlock: aBlock 
	errorBlock := aBlock.
	scanner notNil ifTrue: [scanner errorBlock: aBlock]
%

category: 'error handling'
method: RBParser
errorPosition
	^currentToken start
%

category: 'initialize-release'
method: RBParser
initialize
	comments := OrderedCollection new
%

category: 'accessing'
method: RBParser
initializeParserWith: aString 
	source := aString.
	self scanner: (self scannerClass on: aString readStreamPortable
				errorBlock: self errorBlock)
%

category: 'private-classes'
method: RBParser
literalArrayNodeClass
	^ RBLiteralArrayNode
%

category: 'private-classes'
method: RBParser
literalNodeClass
	^ RBLiteralNode
%

category: 'private-classes'
method: RBParser
messageNodeClass
	^ RBMessageNode
%

category: 'private-classes'
method: RBParser
methodNodeClass
	^ RBMethodNode
%

category: 'private'
method: RBParser
nextToken
	^nextToken isNil ifTrue: [nextToken := scanner next] ifFalse: [nextToken]
%

category: 'private-parsing'
method: RBParser
parseArgs
	| args |
	args := OrderedCollection new.
	[currentToken isIdentifier] whileTrue: [args add: self parseVariableNode].
	^args
%

category: 'private-parsing'
method: RBParser
parseArray
  | position node |
  position := currentToken start.
  self step.
  (currentToken isSpecial and: [ currentToken value = $: ])
    ifTrue: [ ^self parseQueryBlock: position ].
  node := self arrayNodeClass new.
  node left: position.
  self parseStatementList: false into: node.
  (currentToken isSpecial and: [ currentToken value = $} ])
    ifFalse: [ self parserError: 'expected }' ].
  node right: currentToken start.
  self step.
  ^ node
%

category: 'private-parsing'
method: RBParser
parseAssignment
	"Need one token lookahead to see if we have a ':='. This method could 
	make it possible to assign the literals true, false and nil."

	| node position |
	(currentToken isIdentifier and: [self nextToken isAssignment]) 
		ifFalse: [^self parseCascadeMessage].
	node := self parseVariableNode.
	position := currentToken start.
	self step.
	^self assignmentNodeClass 
		variable: node
		value: self parseAssignment
		position: position
%

category: 'private-parsing'
method: RBParser
parseBinaryMessage
	| node |
	node := self parseUnaryMessage.
	
	[currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].
	currentToken isBinary] 
			whileTrue: [node := self parseBinaryMessageWith: node].
	^node
%

category: 'private-parsing'
method: RBParser
parseBinaryMessageWith: aNode 
	| binaryToken |
	binaryToken := currentToken.
	self step.
	^self messageNodeClass 
		receiver: aNode
		selectorParts: (Array with: binaryToken)
		arguments: (Array with: self parseUnaryMessage)
%

category: 'private-parsing'
method: RBParser
parseBinaryPattern
	| binaryToken node args |
	currentToken isBinary
		ifFalse: [self parserError: 'Message pattern expected'].
	binaryToken := currentToken.
	self step.
	args := Array with: self parseVariableNode.
	node := self methodNodeClass
		selectorParts: (Array with: binaryToken)
		arguments: args.
	node comments: node comments , args last comments.
	args last comments: nil.
	^node
%

category: 'private-parsing'
method: RBParser
parseBinaryPragma
	| binaryToken |
	currentToken isBinary 
		ifFalse: [ self parserError: 'Message pattern expected' ].
	binaryToken := currentToken.
	self step.
	^ self pragmaNodeClass
		selectorParts: (Array with: binaryToken)
		arguments: (Array with: self parsePragmaLiteral)
%

category: 'private-parsing'
method: RBParser
parseBlock
	| position node |
	position := currentToken start.
	self step.
	node := self blockNodeClass new. 
	self parseBlockArgsInto: node.
	node left: position.
	node body: (self parseStatements: false).
	(currentToken isSpecial and: [currentToken value = $]])
		ifFalse: [self parserError: ''']'' expected'].
	node right: currentToken start.
	self step.
	^node
%

category: 'private-parsing'
method: RBParser
parseBlockArgsInto: node 
	| verticalBar args colons |
	args := OrderedCollection new: 2.
	colons := OrderedCollection new: 2.
	verticalBar := false.
	[currentToken isSpecial and: [currentToken value = $:]] whileTrue: 
			[colons add: currentToken start.
			self step.	":"
			verticalBar := true.
			args add: self parseVariableNode].
	verticalBar 
		ifTrue: 
			[currentToken isBinary 
				ifTrue: 
					[node bar: currentToken start.
					currentToken value = #| 
						ifTrue: [self step]
						ifFalse: 
							[currentToken value = #'||' 
								ifTrue: 
									["Hack the current token to be the start 
									of temps bar"

									currentToken
										value: #|;
										start: currentToken start + 1]
								ifFalse: [self parserError: '''|'' expected']]]
				ifFalse: 
					[(currentToken isSpecial and: [currentToken value = $]]) 
						ifFalse: [self parserError: '''|'' expected']]].
	node
		arguments: args;
		colons: colons.
	^node
%

category: 'private-parsing'
method: RBParser
parseCascadeMessage
	| node receiver messages semicolons |
	node := self parseKeywordMessage.
	(currentToken isSpecial 
		and: [currentToken value = $; and: [node isMessage]]) ifFalse: [^node].
	receiver := node receiver.
	messages := OrderedCollection new: 3.
	semicolons := OrderedCollection new: 3.
	messages add: node.
	[currentToken isSpecial and: [currentToken value = $;]] whileTrue: 
			[semicolons add: currentToken start.
			self step.
			messages add: (currentToken isIdentifier 
						ifTrue: [self parseUnaryMessageWith: receiver]
						ifFalse: 
							[currentToken isKeyword 
								ifTrue: [self parseKeywordMessageWith: receiver]
								ifFalse: 
									[| temp |
									currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].
									currentToken isBinary ifFalse: [self parserError: 'Message expected'].
									temp := self parseBinaryMessageWith: receiver.
									temp == receiver ifTrue: [self parserError: 'Message expected'].
									temp]])].
	^self cascadeNodeClass messages: messages semicolons: semicolons
%

category: 'accessing'
method: RBParser
parseExpression: aString 
	| node |
	node := self parseStatements: false.
	(RBMethodNode selector: #noMethod body: node) source: aString.	"Make the sequence node have a method node as its parent"
	self atEnd ifFalse: [self parserError: 'Unknown input at end'].
	^node
%

category: 'private-parsing'
method: RBParser
parseKeywordMessage
	^self parseKeywordMessageWith: self parseBinaryMessage
%

category: 'private-parsing'
method: RBParser
parseKeywordMessageWith: node 
	| args isKeyword keywords |
	args := OrderedCollection new: 3.
	keywords := OrderedCollection new: 3.
	isKeyword := false.
	[currentToken isKeyword] whileTrue: 
			[keywords add: currentToken.
			self step.
			args add: self parseBinaryMessage.
			isKeyword := true].
	^isKeyword 
		ifTrue: 
			[self messageNodeClass 
				receiver: node
				selectorParts: keywords
				arguments: args]
		ifFalse: [node]
%

category: 'private-parsing'
method: RBParser
parseKeywordPattern
	| keywords args node |
	keywords := OrderedCollection new.
	args := OrderedCollection new.
	[currentToken isKeyword]
		whileTrue:
			[keywords add: currentToken.
			self step.
			args add: self parseVariableNode].
	node := self methodNodeClass
		selectorParts: keywords
		arguments: args.
	node comments: (node comments, args last comments).
	args last comments: nil.
	^node
%

category: 'private-parsing'
method: RBParser
parseKeywordPragma
	| keywords arguments |
	keywords := OrderedCollection new: 2.
	arguments := OrderedCollection new: 2.
	[ currentToken isKeyword ] whileTrue: [
		keywords addLast: currentToken.
		self step.
		arguments addLast: self parsePragmaLiteral ].
	^ self pragmaNodeClass selectorParts: keywords arguments: arguments
%

category: 'private-parsing'
method: RBParser
parseLiteralArray
	| stream start stop |
	start := currentToken start.
	stream := WriteStreamPortable on: Array new.
	self step.
	[self atEnd or: [currentToken isSpecial and: [currentToken value = $)]]] 
		whileFalse: [stream nextPut: self parseLiteralArrayObject].
	(currentToken isSpecial and: [currentToken value = $)]) 
		ifFalse: [self parserError: ''')'' expected'].
	stop := currentToken stop.
	self step.
	^self literalArrayNodeClass 
		startPosition: start
		contents: stream contents
		stopPosition: stop
		isByteArray: false
%

category: 'private-parsing'
method: RBParser
parseLiteralArrayObject
	currentToken isSpecial 
		ifTrue: 
			[currentToken value = $( ifTrue: [^self parseLiteralArray].
			"currentToken value == $[ ifTrue: [^self parseLiteralByteArray]"].
	currentToken isLiteralArrayToken 
		ifTrue: 
			[^currentToken isForByteArray 
				ifTrue: [self parseLiteralByteArray]
				ifFalse: [self parseLiteralArray]].
	currentToken isLiteralToken ifFalse: [self patchLiteralArrayToken].
	^self parsePrimitiveLiteral
%

category: 'private-parsing'
method: RBParser
parseLiteralByteArray
	| stream start stop |
	start := currentToken start.
	stream := WriteStreamPortable on: Array new.
	self step.
	[self atEnd or: [currentToken isSpecial and: [currentToken value = $]]]] 
		whileFalse: [stream nextPut: self parseLiteralByteArrayObject].
	(currentToken isSpecial and: [currentToken value = $]]) 
		ifFalse: [self parserError: ''']'' expected'].
	stop := currentToken stop.
	self step.
	^self literalArrayNodeClass 
		startPosition: start
		contents: stream contents
		stopPosition: stop
		isByteArray: true
%

category: 'private-parsing'
method: RBParser
parseLiteralByteArrayObject
	(currentToken isLiteralToken and: 
			[currentToken value _isInteger and: [currentToken value between: 0 and: 255]]) 
		ifFalse: [self parserError: 'Expecting 8-bit integer'].
	^self parsePrimitiveLiteral
%

category: 'private-parsing'
method: RBParser
parseMessagePattern
	currentToken isLiteralToken ifTrue: [self patchLiteralMessage].
	^currentToken isIdentifier 
		ifTrue: [self parseUnaryPattern]
		ifFalse: 
			[currentToken isKeyword 
				ifTrue: [self parseKeywordPattern]
				ifFalse: [self parseBinaryPattern]]
%

category: 'private-parsing'
method: RBParser
parseMethod
	| methodNode | 
	methodNode := self parseMessagePattern.
	self parsePragmas.
	self addCommentsTo: methodNode.
	methodNode body: (self parseStatements: true).
	pragmas isNil
		ifFalse: [ methodNode pragmas: pragmas ].
	^methodNode
%

category: 'accessing'
method: RBParser
parseMethod: aString 
	| node |
	node := self parseMethod.
	self atEnd ifFalse: [self parserError: 'Unknown input at end'].
	node source: aString.
	^node
%

category: 'private-parsing'
method: RBParser
parseNegatedNumber
	| token |
	(self nextToken isLiteral not or: [ self nextToken realValue isNumber not ])
		ifTrue: [ self parserError: 'only numbers may be negated' ].
	token := RBLiteralToken value: self nextToken realValue negated start: currentToken start stop: nextToken stop.
	self step; step.
	^ self literalNodeClass literalToken: token
%

category: 'private-parsing'
method: RBParser
parseParenthesizedExpression
	| leftParen node |
	leftParen := currentToken start.
	self step.
	node := self parseAssignment.
	^(currentToken isSpecial and: [currentToken value = $)])
		ifTrue: 
			[node addParenthesis: (leftParen to: currentToken start).
			self step.
			node]
		ifFalse: [self parserError: ''')'' expected']
%

category: 'private-parsing'
method: RBParser
parsePragma
  ^ currentToken isIdentifier
    ifTrue: [ 
      currentToken value = 'protected'
        ifTrue: [ self parseProtectedPragma ]
        ifFalse: [ self parseUnaryPragma ] ]
    ifFalse: [ 
      currentToken isKeyword
        ifTrue: [ self parseKeywordPragma ]
        ifFalse: [ self parseBinaryPragma ] ]
%

category: 'private-parsing'
method: RBParser
parsePragmaLiteral
	^ self parseLiteralArrayObject
%

category: 'private-parsing'
method: RBParser
parsePragmas
	| pragma start |
	[ currentToken isBinary and: [ currentToken value = #< ] ] whileTrue: [
		start := currentToken start.
		self step.
		pragma := self parsePragma.
		(currentToken isBinary and: [ currentToken value = #> ]) 
			ifFalse: [ self parserError: '''>'' expected' ].
		pragma left: start; right: currentToken start.
		pragmas isNil
			ifTrue: [ pragmas := OrderedCollection new ].
		pragmas addLast: pragma.
		self step ]
%

category: 'private-parsing'
method: RBParser
parsePrimitiveIdentifier
	| token node |
	token := currentToken.
	self step.
	node := self variableNodeClass identifierToken: token.
	self addCommentsTo: node.
	^node
%

category: 'private-parsing'
method: RBParser
parsePrimitiveLiteral
	| token |
	token := currentToken.
	self step.
	^self literalNodeClass literalToken: token
%

category: 'private-parsing'
method: RBParser
parsePrimitiveObject
	currentToken isIdentifier ifTrue: [^self parsePrimitiveIdentifier].
	(currentToken isLiteralToken and: [currentToken isMultiKeyword not]) 
		ifTrue: [^self parsePrimitiveLiteral].
	currentToken isLiteralArrayToken 
		ifTrue: 
			[^currentToken isForByteArray 
				ifTrue: [self parseLiteralByteArray]
				ifFalse: [self parseLiteralArray]].
	currentToken isSpecial 
		ifTrue: 
			[currentToken value = $[ ifTrue: [^self parseBlock].
			currentToken value = $( ifTrue: [^self parseParenthesizedExpression].
			currentToken value = ${ ifTrue: [^self parseArray]].
	(currentToken isBinary and: [ currentToken value = #- ]) 
		ifTrue: [ ^self parseNegatedNumber ].
	self parserError: 'Variable expected'
%

category: 'private-parsing'
method: RBParser
parseProtectedPragma
  "encoutered 'protected' as first token in pragma"

  self step.
  currentToken isKeyword
    ifFalse: [ ^ self pragmaNodeClass selectorParts: (Array with: 'protected') arguments: #() ].
  ^ self parseKeywordPragma
    isProtected: true;
    yourself
%

category: 'private-parsing'
method: RBParser
parseQueryBlock: startPosition
  | position node |
  position := startPosition.
  node := self queryBlockNodeClass new.
  self parseBlockArgsInto: node.
  node left: position.
  node body: (self parseStatements: false).
  (currentToken isSpecial and: [ currentToken value = $} ])
    ifFalse: [ self parserError: '''}'' expected' ].
  node right: currentToken start.
  self step.
  ^ node
%

category: 'error handling'
method: RBParser
parserError: aString 
	"Evaluate the block. If it returns raise an error"

	self errorBlock value: aString value: self errorPosition.
	self error: aString
%

category: 'private-parsing'
method: RBParser
parseStatementList: pragmaBoolean into: sequenceNode 
	| statements return periods returnPosition node |
	return := false.
	statements := OrderedCollection new.
	periods := OrderedCollection new.
	self addCommentsTo: sequenceNode.
	pragmaBoolean ifTrue: [self parsePragmas].
	[currentToken isSpecial and: [currentToken value = $.]] whileTrue: 
		[periods add: currentToken start.
		self step].
	[self atEnd 
		or: [currentToken isSpecial and: ['])}' includes: currentToken value]]] 
			whileFalse: 
				[return ifTrue: [self parserError: 'End of statement list encounted'].
				(currentToken isSpecial and: [currentToken value = $^]) 
					ifTrue: 
						[returnPosition := currentToken start.
						self step.
						node := self returnNodeClass return: returnPosition
									value: self parseAssignment.
						statements add: node.
						return := true]
					ifFalse: 
						[node := self parseAssignment.
						statements add: node].
				(currentToken isSpecial and: [currentToken value = $.]) 
					ifTrue: 
						[periods add: currentToken start.
						self step.
						self addCommentsTo: node]
					ifFalse: [return := true].
				[currentToken isSpecial and: [currentToken value = $.]] whileTrue: 
					[periods add: currentToken start.
					self step]].
	statements notEmpty ifTrue: [self addCommentsTo: statements last].
	sequenceNode
		statements: statements;
		periods: periods.
	^sequenceNode
%

category: 'private-parsing'
method: RBParser
parseStatements: pragmaBoolean 
	| args leftBar rightBar |
	args := #().
	leftBar := rightBar := nil.
	currentToken isBinary 
		ifTrue: 
			[currentToken value = #| 
				ifTrue: 
					[leftBar := currentToken start.
					self step.
					args := self parseArgs.
					(currentToken isBinary and: [currentToken value = #|]) 
						ifFalse: [self parserError: '''|'' expected'].
					rightBar := currentToken start.
					self step]
				ifFalse: 
					[currentToken value = #'||' 
						ifTrue: 
							[rightBar := (leftBar := currentToken start) + 1.
							self step]]].
	^self parseStatementList: pragmaBoolean
		into: (self sequenceNodeClass 
				leftBar: leftBar
				temporaries: args
				rightBar: rightBar)
%

category: 'private-parsing'
method: RBParser
parseUnaryMessage
	| node |
	node := self parsePrimitiveObject.
	self addCommentsTo: node.
	[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].
	currentToken isIdentifier] 
			whileTrue: [node := self parseUnaryMessageWith: node].
	self addCommentsTo: node.
	^node
%

category: 'private-parsing'
method: RBParser
parseUnaryMessageWith: aNode 
	| selector |
	selector := currentToken.
	self step.
	^self messageNodeClass 
		receiver: aNode
		selectorParts: (Array with: selector)
		arguments: #()
%

category: 'private-parsing'
method: RBParser
parseUnaryPattern
	| selector |
	selector := currentToken.
	self step.
	^self methodNodeClass selectorParts: (Array with: selector) arguments: #()
%

category: 'private-parsing'
method: RBParser
parseUnaryPragma
	| selector |
	selector := currentToken.
	self step.
	^ self pragmaNodeClass selectorParts: (Array with: selector) arguments: #()
%

category: 'private-parsing'
method: RBParser
parseVariableNode
	currentToken isIdentifier 
		ifFalse: [self parserError: 'Variable name expected'].
	^self parsePrimitiveIdentifier
%

category: 'private'
method: RBParser
patchLiteralArrayToken
	(currentToken isIdentifier and: 
			[self nextToken isAssignment 
				and: [currentToken stop + 1 = self nextToken start]]) 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: (currentToken value , ':') asSymbol
						start: currentToken start
						stop: self nextToken start.
			nextToken := RBLiteralToken 
						value: #=
						start: nextToken stop
						stop: nextToken stop.
			^self].
	currentToken isAssignment 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: #':'
						start: currentToken start
						stop: currentToken start.
			nextToken := RBLiteralToken 
						value: #=
						start: currentToken stop
						stop: currentToken stop.
			^self].
	currentToken isSpecial 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: (String with: currentToken value) asSymbol
						start: currentToken start
						stop: currentToken stop.
			^self].
	(currentToken isIdentifier and: [currentToken value includes: $.]) 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: currentToken value
						start: currentToken start
						stop: currentToken stop.
			^self].
	(currentToken isIdentifier 
		or: [currentToken isBinary or: [currentToken isKeyword]]) 
			ifFalse: [^self parserError: 'Invalid token'].
	currentToken := RBLiteralToken 
				value: currentToken value asSymbol
				start: currentToken start
				stop: currentToken stop
%

category: 'private'
method: RBParser
patchLiteralMessage
	currentToken value == true 
		ifTrue: 
			[^currentToken := RBIdentifierToken value: 'true' start: currentToken start].
	currentToken value == false 
		ifTrue: 
			[^currentToken := RBIdentifierToken value: 'false' start: currentToken start].
	currentToken value == nil 
		ifTrue: 
			[^currentToken := RBIdentifierToken value: 'nil' start: currentToken start]
%

category: 'private'
method: RBParser
patchNegativeLiteral
	"Handle the special negative number case for binary message sends."

	currentToken value isNumber 
		ifFalse: [^self].
	currentToken value <= 0 ifFalse: [^self].
	currentToken value = 0 
		ifTrue: 
			[(source notNil and: 
					[source notEmpty 
						and: [(source at: (currentToken start min: source size)) = $-]]) 
				ifFalse: [^self]].
	nextToken := currentToken.
	currentToken := RBBinarySelectorToken value: #- start: nextToken start.
	nextToken value: nextToken value negated.
	(nextToken isKindOf: RBNumberLiteralToken) 
		ifTrue: 
			[nextToken source: (nextToken source copyFrom: 2 to: nextToken source size)].
	nextToken start: nextToken start + 1
%

category: 'private-classes'
method: RBParser
pragmaNodeClass
	^ RBPragmaNode
%

category: 'private-classes'
method: RBParser
queryBlockNodeClass
  ^ RBQueryBlockNode
%

category: 'private-classes'
method: RBParser
returnNodeClass
	^ RBReturnNode
%

category: 'initialize-release'
method: RBParser
scanner: aScanner 
	scanner := aScanner.
	pragmas := nil.
	self initialize.
	self step
%

category: 'accessing'
method: RBParser
scannerClass
	^RBScanner
%

category: 'private-classes'
method: RBParser
sequenceNodeClass
	^ RBSequenceNode
%

category: 'private'
method: RBParser
step
	(currentToken notNil and: [currentToken comments notNil]) 
		ifTrue: [comments addAll: currentToken comments].
	nextToken notNil 
		ifTrue: 
			[currentToken := nextToken.
			nextToken := nil]
		ifFalse: [currentToken := scanner next]
%

category: 'private-classes'
method: RBParser
variableNodeClass
	^ RBVariableNode
%

! Class implementation for 'RBPatternParser'

!		Instance methods for 'RBPatternParser'

category: 'private-classes'
method: RBPatternParser
messageNodeClass
	^RBPatternMessageNode
%

category: 'private-classes'
method: RBPatternParser
methodNodeClass
	^RBPatternMethodNode
%

category: 'private-parsing'
method: RBPatternParser
parseLiteralByteArrayObject
	| node |
	(currentToken isIdentifier and: [currentToken isPatternVariable]) 
		ifTrue: 
			[node := self variableNodeClass identifierToken: currentToken.
			node isLiteralNode 
				ifTrue: 
					[self step.
					^node]].
	^super parseLiteralByteArrayObject
%

category: 'private-parsing'
method: RBPatternParser
parsePatternBlock: aClass 
	| position node |
	position := currentToken start.
	self step.
	node := self parseBlockArgsInto: aClass new.
	node left: position.
	node body: (self parseStatements: false).
	(currentToken isSpecial and: [currentToken value = $}]) 
		ifFalse: [self parserError: '''}'' expected'].
	node right: currentToken start.
	self step.
	^node
%

category: 'private-parsing'
method: RBPatternParser
parsePragmaLiteral
  | node |
  currentToken isPatternBlock
    ifTrue: [ ^ self parsePatternBlock: RBPatternBlockNode ].
  (currentToken isIdentifier and: [ currentToken isPatternVariable ])
    ifTrue: [ 
      node := self variableNodeClass identifierToken: currentToken.
      node isLiteralNode
        ifFalse: [ self error: 'Literal pattern expected' ].
      self step.
      currentToken isPatternBlock
        ifTrue: [ 
          node := (self parsePatternBlock: RBPatternWrapperBlockNode)
            wrappedNode: node;
            yourself ].
      ^ node ].
  ^ super parsePragmaLiteral
%

category: 'private-parsing'
method: RBPatternParser
parsePrimitiveLiteral
	| node |
	(currentToken isIdentifier and: [currentToken isPatternVariable]) 
		ifTrue: 
			[node := self variableNodeClass identifierToken: currentToken.
			node isLiteralNode 
				ifTrue: 
					[self step.
					^node].
			currentToken := RBLiteralToken 
						value: currentToken value asSymbol
						start: currentToken start
						stop: currentToken stop].
	^super parsePrimitiveLiteral
%

category: 'private-parsing'
method: RBPatternParser
parsePrimitiveObject
	currentToken isPatternBlock 
		ifTrue: [^self parsePatternBlock: RBPatternBlockNode].
	^super parsePrimitiveObject
%

category: 'private-parsing'
method: RBPatternParser
parseUnaryMessage
	| node |
	node := self parsePrimitiveObject.
	self addCommentsTo: node.
	
	[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].
	currentToken isPatternBlock 
		ifTrue: 
			[node := (self parsePatternBlock: RBPatternWrapperBlockNode)
						wrappedNode: node;
						yourself].
	currentToken isIdentifier] 
			whileTrue: [node := self parseUnaryMessageWith: node].
	self addCommentsTo: node.
	^node
%

category: 'private'
method: RBPatternParser
patchLiteralArrayToken
	(currentToken isIdentifier and: [currentToken isPatternVariable]) 
		ifTrue: [^self].
	super patchLiteralArrayToken
%

category: 'private-classes'
method: RBPatternParser
pragmaNodeClass
	^RBPatternPragmaNode
%

category: 'accessing'
method: RBPatternParser
scannerClass
	^RBPatternScanner
%

category: 'private-classes'
method: RBPatternParser
variableNodeClass
	^RBPatternVariableNode
%

! Class implementation for 'RBTonelParser'

!		Instance methods for 'RBTonelParser'

category: 'accessing'
method: RBTonelParser
currentToken

	^currentToken
%

category: 'private-parsing'
method: RBTonelParser
parseTonelKeywordPattern
	" do not process $[ token .. caller will do the right thing"

	| keywords args node continue |
	keywords := OrderedCollection new.
	args := OrderedCollection new.
	continue := true.
	[  continue and: [ currentToken isKeyword ]  ]
		whileTrue:
			[keywords add: currentToken.
			continue := (self peekTonelFor: #special value: $[) not.
			continue ifTrue: [ self step ].
			args add: self parseTonelVariableNode].
	node := self methodNodeClass
		selectorParts: keywords
		arguments: args.
	node comments: (node comments, args last comments).
	args last comments: nil.
	^node
%

category: 'private-parsing'
method: RBTonelParser
parseTonelMessagePattern

	currentToken isLiteralToken ifTrue: [self patchTonelLiteralMessage].
	^ currentToken isIdentifier 
		ifTrue: [ self parseTonelUnaryPattern]
		ifFalse: 
			[currentToken isKeyword 
				ifTrue: [self parseTonelKeywordPattern]
				ifFalse: [self parseTonelBinaryPattern] ]
%

category: 'private-parsing'
method: RBTonelParser
parseTonelPragmas
	| pragma start |
	[ currentToken isBinary and: [ currentToken value = #< ] ] whileTrue: [
		start := currentToken start.
		self step.
		pragma := self parsePragma.
		(currentToken isBinary and: [ currentToken value = #> ]) 
			ifFalse: [ self parserError: '''>'' expected' ].
		pragma left: start; right: currentToken start.
		pragmas isNil
			ifTrue: [ pragmas := OrderedCollection new ].
		pragmas addLast: pragma.
		self step ]
%

category: 'private-parsing'
method: RBTonelParser
parseTonelPrimitiveIdentifier
	| token node |
	token := currentToken.
	(self peekTonelFor: #special value: $[)
		ifFalse: [ self step ].
	node := self variableNodeClass identifierToken: token.
	self addCommentsTo: node.
	^node
%

category: 'private-parsing'
method: RBTonelParser
parseTonelStatementList: pragmaBoolean into: sequenceNode 
	| statements return periods returnPosition node |
	return := false.
	statements := OrderedCollection new.
	periods := OrderedCollection new.
	self addCommentsTo: sequenceNode.
	pragmaBoolean ifTrue: [self parsePragmas].
	[currentToken isSpecial and: [currentToken value = $.]] whileTrue: 
		[periods add: currentToken start.
		self step].
	[self atEnd 
		or: [currentToken isSpecial and: ['])}' includes: currentToken value]]] 
			whileFalse: 
				[return ifTrue: [self parserError: 'End of statement list encounted'].
				(currentToken isSpecial and: [currentToken value = $^]) 
					ifTrue: 
						[returnPosition := currentToken start.
						self step.
						node := self returnNodeClass return: returnPosition
									value: self parseAssignment.
						statements add: node.
						return := true]
					ifFalse: 
						[node := self parseAssignment.
						statements add: node].
				(currentToken isSpecial and: [currentToken value = $.]) 
					ifTrue: 
						[periods add: currentToken start.
						self step.
						self addCommentsTo: node]
					ifFalse: [return := true].
				[currentToken isSpecial and: [currentToken value = $.]] whileTrue: 
					[periods add: currentToken start.
					self step]].
	statements notEmpty ifTrue: [self addCommentsTo: statements last].
	sequenceNode
		statements: statements;
		periods: periods.
	^sequenceNode
%

category: 'private-parsing'
method: RBTonelParser
parseTonelStatements: pragmaBoolean 
	| args leftBar rightBar |
	args := #().
	leftBar := rightBar := nil.
	currentToken isBinary 
		ifTrue: 
			[currentToken value = #| 
				ifTrue: 
					[leftBar := currentToken start.
					self step.
					args := self parseArgs.
					(currentToken isBinary and: [currentToken value = #|]) 
						ifFalse: [self parserError: '''|'' expected'].
					rightBar := currentToken start.
					self step]
				ifFalse: 
					[currentToken value = #'||' 
						ifTrue: 
							[rightBar := (leftBar := currentToken start) + 1.
							self step]]].
	^self parseTonelStatementList: pragmaBoolean
		into: (self sequenceNodeClass 
				leftBar: leftBar
				temporaries: args
				rightBar: rightBar)
%

category: 'private-parsing'
method: RBTonelParser
parseTonelUnaryPattern
	"only used when parsing the tonel method selector line"

	| selector |
	selector := currentToken.
	^self methodNodeClass selectorParts: (Array with: selector) arguments: #()
%

category: 'private-parsing'
method: RBTonelParser
parseTonelVariableNode
	currentToken isIdentifier 
		ifFalse: [self parserError: 'Variable name expected'].
	^self parseTonelPrimitiveIdentifier
%

category: 'private-parsing'
method: RBTonelParser
peekTonelFor: characterType value: characterValue

	^ self scanner peekTonelFor: characterType value: characterValue
%

category: 'accessing'
method: RBTonelParser
scanner

	^scanner
%

category: 'accessing'
method: RBTonelParser
scannerClass
	^RBTonelScanner
%

category: 'testing'
method: RBTonelParser
tonelMethodBodyTerminationToken
	^ currentToken isSpecial and: [ currentToken value = $] ]
%

category: 'private'
method: RBTonelParser
tonelStep
	"only used when parsing the tonel method selector line"

	(currentToken notNil and: [currentToken comments notNil]) 
		ifTrue: [comments addAll: currentToken comments].
	nextToken notNil 
		ifTrue: 
			[currentToken := nextToken.
			nextToken := nil]
		ifFalse: [currentToken := scanner tonelNext]
%

! Class implementation for 'RBParseTreeRule'

!		Class methods for 'RBParseTreeRule'

category: 'instance creation'
classmethod: RBParseTreeRule
methodSearch: aString 
	^(self new)
		methodSearchString: aString;
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeRule
new

	^self basicNew initialize
%

category: 'instance creation'
classmethod: RBParseTreeRule
search: aString 
	^(self new)
		searchString: aString;
		yourself
%

!		Instance methods for 'RBParseTreeRule'

category: 'matching'
method: RBParseTreeRule
canMatch: aProgramNode 
	^true
%

category: 'private'
method: RBParseTreeRule
context
	^owner context
%

category: 'matching'
method: RBParseTreeRule
foundMatchFor: aProgramNode
	^aProgramNode
%

category: 'initialize-release'
method: RBParseTreeRule
initialize
%

category: 'initialize-release'
method: RBParseTreeRule
methodSearchString: aString 
	searchTree := RBParser parseRewriteMethod: aString
%

category: 'initialize-release'
method: RBParseTreeRule
owner: aParseTreeSearcher
	owner := aParseTreeSearcher
%

category: 'matching'
method: RBParseTreeRule
performOn: aProgramNode 
	self context empty.
	^((searchTree match: aProgramNode inContext: self context) 
		and: [self canMatch: aProgramNode]) 
			ifTrue: 
				[owner recusivelySearchInContext.
				self foundMatchFor: aProgramNode]
			ifFalse: [nil]
%

category: 'initialize-release'
method: RBParseTreeRule
searchString: aString 
	searchTree := RBParser parseRewriteExpression: aString
%

category: 'accessing'
method: RBParseTreeRule
sentMessages
	^searchTree sentMessages
%

! Class implementation for 'RBReplaceRule'

!		Instance methods for 'RBReplaceRule'

category: 'matching'
method: RBReplaceRule
canMatch: aProgramNode 
	^verificationBlock value: aProgramNode
%

category: 'matching'
method: RBReplaceRule
foundMatchFor: aProgramNode 
	self subclassResponsibility
%

category: 'initialize-release'
method: RBReplaceRule
initialize
	super initialize.
	verificationBlock := [:aNode | true]
%

category: 'matching'
method: RBReplaceRule
replace: aProgramNode with: newNode 
	aProgramNode replaceMethodSource: newNode
%

! Class implementation for 'RBBlockReplaceRule'

!		Class methods for 'RBBlockReplaceRule'

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchFor: searchString replaceWith: replaceBlock 
	^self new searchFor: searchString replaceWith: replaceBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchFor: searchString replaceWith: replaceBlock when: aBlock 
	^self new 
		searchFor: searchString
		replaceWith: replaceBlock
		when: aBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForMethod: searchString replaceWith: replaceBlock 
	^self new searchForMethod: searchString replaceWith: replaceBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForMethod: searchString replaceWith: replaceBlock when: aBlock 
	^self new 
		searchForMethod: searchString
		replaceWith: replaceBlock
		when: aBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceBlock 
	^self new searchForTree: aRBProgramNode replaceWith: replaceBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceBlock when: aBlock 
	^self new 
		searchForTree: aRBProgramNode
		replaceWith: replaceBlock
		when: aBlock
%

!		Instance methods for 'RBBlockReplaceRule'

category: 'matching'
method: RBBlockReplaceRule
foundMatchFor: aProgramNode 
	| newNode |
	newNode := replaceBlock value: aProgramNode.
	aProgramNode replaceMethodSource: newNode.
	^newNode
%

category: 'initialize-release'
method: RBBlockReplaceRule
initialize
	super initialize.
	replaceBlock := [:aNode | aNode]
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchFor: searchString replaceWith: aBlock 
	self searchString: searchString.
	replaceBlock := aBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchFor: searchString replaceWith: replBlock when: verifyBlock 
	self searchFor: searchString replaceWith: replBlock.
	verificationBlock := verifyBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForMethod: searchString replaceWith: aBlock 
	self methodSearchString: searchString.
	replaceBlock := aBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForMethod: searchString replaceWith: replBlock when: verifyBlock 
	self searchForMethod: searchString replaceWith: replBlock.
	verificationBlock := verifyBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForTree: aBRProgramNode replaceWith: aBlock 
	searchTree := aBRProgramNode.
	replaceBlock := aBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForTree: aBRProgramNode replaceWith: replBlock when: verifyBlock 
	self searchForTree: aBRProgramNode replaceWith: replBlock.
	verificationBlock := verifyBlock
%

! Class implementation for 'RBStringReplaceRule'

!		Class methods for 'RBStringReplaceRule'

category: 'instance creation'
classmethod: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString 
	^self new searchFor: searchString replaceWith: replaceString
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString when: aBlock 
	^self new 
		searchFor: searchString
		replaceWith: replaceString
		when: aBlock
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString 
	^(self new)
		searchForMethod: searchString replaceWith: replaceString;
		yourself
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString when: aBlock 
	^self new 
		searchForMethod: searchString
		replaceWith: replaceString
		when: aBlock
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceString 
	^self new searchForTree: aRBProgramNode replaceWith: replaceString
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceString when: aBlock 
	^self new 
		searchForTree: aRBProgramNode
		replaceWith: replaceString
		when: aBlock
%

!		Instance methods for 'RBStringReplaceRule'

category: 'matching'
method: RBStringReplaceRule
foundMatchFor: aProgramNode 
	| newNode |
	newNode := replaceTree copyInContext: self context.
	aProgramNode replaceMethodSource: newNode.
	newNode copyCommentsFrom: aProgramNode.
	^newNode
%

category: 'initialize-release'
method: RBStringReplaceRule
methodReplaceString: replaceString 
	replaceTree := RBParser parseRewriteMethod: replaceString
%

category: 'initialize-release'
method: RBStringReplaceRule
replaceString: replaceString 
	replaceTree := RBParser parseRewriteExpression: replaceString.
	searchTree isSequence = replaceTree isSequence 
		ifFalse: 
			[searchTree isSequence 
				ifTrue: [replaceTree := RBSequenceNode statements: (Array with: replaceTree)]
				ifFalse: [searchTree := RBSequenceNode statements: (Array with: searchTree)]]
%

category: 'initialize-release'
method: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString 
	self searchString: searchString.
	self replaceString: replaceString
%

category: 'initialize-release'
method: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString when: aBlock 
	self searchFor: searchString replaceWith: replaceString.
	verificationBlock := aBlock
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString 
	self methodSearchString: searchString.
	self methodReplaceString: replaceString
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString when: aBlock 
	self searchForMethod: searchString replaceWith: replaceString.
	verificationBlock := aBlock
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForTree: aBRProgramNode replaceWith: replaceNode 
	searchTree := aBRProgramNode.
	replaceTree := replaceNode
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForTree: aBRProgramNode replaceWith: replaceString when: aBlock 
	self searchForTree: aBRProgramNode replaceWith: replaceString.
	verificationBlock := aBlock
%

! Class implementation for 'RBSearchRule'

!		Class methods for 'RBSearchRule'

category: 'instance creation'
classmethod: RBSearchRule
searchFor: aString thenDo: aBlock 
	^self new searchFor: aString thenDo: aBlock
%

category: 'instance creation'
classmethod: RBSearchRule
searchForMethod: aString thenDo: aBlock 
	^self new searchForMethod: aString thenDo: aBlock
%

category: 'instance creation'
classmethod: RBSearchRule
searchForTree: aBRProgramNode thenDo: aBlock 
	^self new searchForTree: aBRProgramNode thenDo: aBlock
%

!		Instance methods for 'RBSearchRule'

category: 'testing'
method: RBSearchRule
canMatch: aProgramNode 
	owner answer: (answerBlock value: aProgramNode value: owner answer).
	^true
%

category: 'initialize-release'
method: RBSearchRule
searchFor: aString thenDo: aBlock 
	self searchString: aString.
	answerBlock := aBlock
%

category: 'initialize-release'
method: RBSearchRule
searchForMethod: aString thenDo: aBlock 
	self methodSearchString: aString.
	answerBlock := aBlock
%

category: 'initialize-release'
method: RBSearchRule
searchForTree: aBRProgramNode thenDo: aBlock 
	searchTree := aBRProgramNode.
	answerBlock := aBlock
%

! Class implementation for 'RBProgramNode'

!		Class methods for 'RBProgramNode'

category: 'accessing'
classmethod: RBProgramNode
formatterClass
  ^ FormatterClass isNil
    ifTrue: [ RBConfigurableFormatter ]
    ifFalse: [ ^ Rowan globalNamed: FormatterClass name ]
%

category: 'accessing'
classmethod: RBProgramNode
formatterClass: aClass 
	FormatterClass := aClass
%

category: 'instance creation'
classmethod: RBProgramNode
new

	^self basicNew initialize
%

category: 'accessing'
classmethod: RBProgramNode
optimizedSelectors
	^ #( and: caseOf: caseOf:otherwise: ifFalse: ifFalse:ifTrue: ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: ifTrue: ifTrue:ifFalse: or: to:by:do: to:do: whileFalse whileFalse: whileTrue whileTrue: )
%

!		Instance methods for 'RBProgramNode'

category: 'visitor'
method: RBProgramNode
acceptVisitor: aProgramNodeVisitor 
	self subclassResponsibility
%

category: 'replacing'
method: RBProgramNode
addReplacement: aStringReplacement
	parent isNil ifTrue: [^self].
	parent addReplacement: aStringReplacement
%

category: 'accessing'
method: RBProgramNode
allArgumentVariables
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allArgumentVariables;
				yourself]
%

category: 'iterating'
method: RBProgramNode
allChildren
	| children |
	children := OrderedCollection new.
	self nodesDo: [ :each | children addLast: each ].
	^ children
%

category: 'accessing'
method: RBProgramNode
allDefinedVariables
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allDefinedVariables;
				yourself]
%

category: 'accessing'
method: RBProgramNode
allTemporaryVariables
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allTemporaryVariables;
				yourself]
%

category: 'accessing'
method: RBProgramNode
asReturn
	"Change the current node to a return node."

	parent isNil 
		ifTrue: [self error: 'Cannot change to a return without a parent node.'].
	parent isSequence 
		ifFalse: [self error: 'Parent node must be a sequence node.'].
	(parent isLast: self) ifFalse: [self error: 'Return node must be last.'].
	^parent addReturn
%

category: 'testing'
method: RBProgramNode
assigns: aVariableName 
	^self children anySatisfy: [:each | each assigns: aVariableName]
%

category: 'querying'
method: RBProgramNode
bestNodeFor: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	selectedChildren := self children 
				select: [:each | each intersectsInterval: anInterval].
	^selectedChildren size == 1 
		ifTrue: [selectedChildren first bestNodeFor: anInterval]
		ifFalse: [self]
%

category: 'accessing'
method: RBProgramNode
blockVariables
	^parent isNil ifTrue: [#()] ifFalse: [parent blockVariables]
%

category: 'testing-matching'
method: RBProgramNode
canMatchMethod: aCompiledMethod 
	^self sentMessages allSatisfy: 
			[:each | 
			(self class optimizedSelectors includes: each) 
				or: [aCompiledMethod refersToLiteral: each]]
%

category: 'meta variable-accessing'
method: RBProgramNode
cascadeListCharacter
	^$;
%

category: 'accessing'
method: RBProgramNode
children
	^#()
%

category: 'replacing'
method: RBProgramNode
clearReplacements
	parent isNil ifTrue: [^self].
	parent clearReplacements
%

category: 'enumeration'
method: RBProgramNode
collect: aBlock 
	"Hacked to fit collection protocols"

	^aBlock value: self
%

category: 'accessing'
method: RBProgramNode
comments
	"Answer the comments of the receiving parse tree node as intervals of starting and ending indices."
	
	^ comments isNil ifTrue: [ #() ] ifFalse: [ comments ]
%

category: 'accessing'
method: RBProgramNode
comments: aCollection
	comments := aCollection
%

category: 'testing'
method: RBProgramNode
containedBy: anInterval 
	^anInterval first <= self start and: [anInterval last >= self stop]
%

category: 'testing'
method: RBProgramNode
containsReturn
	^self children anySatisfy: [:each | each containsReturn]
%

category: 'copying'
method: RBProgramNode
copyCommentsFrom: aNode 
	"Add all comments from aNode to us. If we already have the comment, then don't add it."

	| newComments |
	newComments := OrderedCollection new.
	aNode nodesDo: [:each | newComments addAll: each comments].
	self nodesDo: 
			[:each | 
			each comments do: [:comment | newComments remove: comment ifAbsent: []]].
	newComments isEmpty ifTrue: [^self].
	newComments := newComments asSortedCollection: [:a :b | a first < b first].
	self comments: newComments
%

category: 'matching'
method: RBProgramNode
copyInContext: aDictionary
	^ self copy
%

category: 'matching'
method: RBProgramNode
copyList: matchNodes inContext: aDictionary 
	| newNodes |
	newNodes := OrderedCollection new.
	matchNodes do: 
			[:each | 
			| object |
			object := each copyInContext: aDictionary.
			newNodes addAll: object].
	^newNodes
%

category: 'testing'
method: RBProgramNode
defines: aName
	^false
%

category: 'testing'
method: RBProgramNode
directlyUses: aNode
	^true
%

category: 'enumeration'
method: RBProgramNode
do: aBlock 
	"Hacked to fit collection protocols"

	aBlock value: self
%

category: 'comparing'
method: RBProgramNode
equalTo: aNode exceptForVariables: variableNameCollection 
	| dictionary |
	dictionary := Dictionary new.
	(self equalTo: aNode withMapping: dictionary) ifFalse: [^false].
	dictionary keysAndValuesDo: 
			[:key :value | 
			(key = value or: [variableNameCollection includes: key]) ifFalse: [^false]].
	^true
%

category: 'comparing'
method: RBProgramNode
equalTo: aNode withMapping: aDictionary 
	^self = aNode
%

category: 'testing'
method: RBProgramNode
evaluatedFirst: aNode 
	self children do: 
			[:each | 
			each == aNode ifTrue: [^true].
			each isImmediateNode ifFalse: [^false]].
	^false
%

category: 'accessing'
method: RBProgramNode
formattedCode
	^ self formatterClass new format: self
%

category: 'accessing'
method: RBProgramNode
formatterClass
	^ self class formatterClass
%

category: 'comparing'
method: RBProgramNode
hashForCollection: aCollection
	^ aCollection isEmpty ifTrue: [ 0 ] ifFalse: [ aCollection first hash ]
%

category: 'testing'
method: RBProgramNode
hasMultipleReturns
	| count |
	count := 0.
	self nodesDo: [:each | each isReturn ifTrue: [count := count + 1]].
	^count > 1
%

category: 'properties'
method: RBProgramNode
hasProperty: aKey
	"Test if the property aKey is present."
	
	^ properties notNil and: [ properties includesKey: aKey ]
%

category: 'initialize release'
method: RBProgramNode
initialize
%

category: 'testing'
method: RBProgramNode
intersectsInterval: anInterval 
	^(anInterval first between: self start and: self stop) 
		or: [self start between: anInterval first and: anInterval last]
%

category: 'testing'
method: RBProgramNode
isArray
	^ false
%

category: 'testing'
method: RBProgramNode
isAssignment
	^false
%

category: 'testing'
method: RBProgramNode
isBlock
	^false
%

category: 'testing'
method: RBProgramNode
isCascade
	^false
%

category: 'testing'
method: RBProgramNode
isDirectlyUsed
	"This node is directly used as an argument, receiver, or part of an assignment."

	^parent isNil ifTrue: [false] ifFalse: [parent directlyUses: self]
%

category: 'testing'
method: RBProgramNode
isEvaluatedFirst
	"Return true if we are the first thing evaluated in this statement."

	^parent isNil or: [parent isSequence or: [parent evaluatedFirst: self]]
%

category: 'deprecated'
method: RBProgramNode
isImmediate
	^self isImmediateNode
%

category: 'testing'
method: RBProgramNode
isImmediateNode
	^false
%

category: 'testing'
method: RBProgramNode
isLast: aNode 
	| children |
	children := self children.
	^children notEmpty and: [children last == aNode]
%

category: 'testing-matching'
method: RBProgramNode
isList
	^false
%

category: 'deprecated'
method: RBProgramNode
isLiteral
	^self isLiteralNode
%

category: 'testing'
method: RBProgramNode
isLiteralArray
	^false
%

category: 'testing'
method: RBProgramNode
isLiteralNode
	^false
%

category: 'testing'
method: RBProgramNode
isMessage
	^false
%

category: 'testing'
method: RBProgramNode
isMethod
	^false
%

category: 'testing-matching'
method: RBProgramNode
isPatternNode
	^false
%

category: 'testing'
method: RBProgramNode
isPragma
	^false
%

category: 'testing'
method: RBProgramNode
isReturn
	^false
%

category: 'testing'
method: RBProgramNode
isSequence
	^false
%

category: 'testing'
method: RBProgramNode
isUsed
	"Answer true if this node could be used as part of another expression. For example, you could use the 
	result of this node as a receiver of a message, an argument, the right part of an assignment, or the 
	return value of a block. This differs from isDirectlyUsed in that it is conservative since it also includes 
	return values of blocks."

	^parent isNil ifTrue: [false] ifFalse: [parent uses: self]
%

category: 'testing'
method: RBProgramNode
isValue
	^false
%

category: 'testing'
method: RBProgramNode
isVariable
	^false
%

category: 'testing'
method: RBProgramNode
lastIsReturn
	^self isReturn
%

category: 'meta variable-accessing'
method: RBProgramNode
listCharacter
	^$@
%

category: 'meta variable-accessing'
method: RBProgramNode
literalCharacter
	^$#
%

category: 'accessing'
method: RBProgramNode
mappingFor: aNode
	| method |
	method := self methodNode.
	method isNil ifTrue: [^aNode].
	^method mappingFor: aNode
%

category: 'matching'
method: RBProgramNode
match: aNode inContext: aDictionary 
	^ self = aNode
%

category: 'matching'
method: RBProgramNode
matchList: matchNodes against: programNodes inContext: aDictionary 
	^self
		matchList: matchNodes
		index: 1
		against: programNodes
		index: 1
		inContext: aDictionary
%

category: 'matching'
method: RBProgramNode
matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 
	| node currentIndex currentDictionary nodes |
	matchNodes size < matchIndex ifTrue: [^programNodes size < programIndex].
	node := matchNodes at: matchIndex.
	node isList 
		ifTrue: 
			[currentIndex := programIndex - 1.
			
			[currentDictionary := aDictionary copy.
			programNodes size < currentIndex or: 
					[nodes := programNodes copyFrom: programIndex to: currentIndex.
					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 
							[(self 
								matchList: matchNodes
								index: matchIndex + 1
								against: programNodes
								index: currentIndex + 1
								inContext: currentDictionary) 
									ifTrue: 
										[currentDictionary 
											keysAndValuesDo: [:key :value | aDictionary at: key put: value].
										^true].
							false]]] 
					whileFalse: [currentIndex := currentIndex + 1].
			^false].
	programNodes size < programIndex ifTrue: [^false].
	(node match: (programNodes at: programIndex) inContext: aDictionary) 
		ifFalse: [^false].
	^self 
		matchList: matchNodes
		index: matchIndex + 1
		against: programNodes
		index: programIndex + 1
		inContext: aDictionary
%

category: 'accessing'
method: RBProgramNode
methodComments
	^self comments
%

category: 'accessing'
method: RBProgramNode
methodNode
	^parent isNil ifTrue: [nil] ifFalse: [parent methodNode]
%

category: 'accessing'
method: RBProgramNode
newSource
	^self formattedCode
%

category: 'iterating'
method: RBProgramNode
nodesDo: aBlock 
	aBlock value: self.
	self children do: [ :each | each nodesDo: aBlock ]
%

category: 'accessing'
method: RBProgramNode
parent
	^parent
%

category: 'accessing'
method: RBProgramNode
parent: aRBProgramNode 
	parent := aRBProgramNode
%

category: 'accessing'
method: RBProgramNode
parents
	^ parent isNil
		ifTrue: [ OrderedCollection with: self ]
		ifFalse: [ 
			parent parents
				addLast: self;
				yourself ]
%

category: 'copying'
method: RBProgramNode
postCopy
	super postCopy.
	properties := properties copy
%

category: 'accessing'
method: RBProgramNode
precedence
	^6
%

category: 'printing'
method: RBProgramNode
printOn: aStream 
	aStream
		nextPutAll: self class name;
		nextPut: $(;
		nextPutAll: self formattedCode;
		nextPut: $)
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey
	"Answer the property value associated with aKey."
	
	^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey ifAbsent: aBlock
	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."
	
	^ properties isNil
		ifTrue: [ aBlock value ]
		ifFalse: [ properties at: aKey ifAbsent: aBlock ]
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey ifAbsentPut: aBlock
	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."
	
	^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey put: anObject
	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."

	^ (properties ifNil: [ properties := RBSmallDictionary new: 1 ])
		at: aKey put: anObject
%

category: 'testing-matching'
method: RBProgramNode
recurseInto
	^false
%

category: 'meta variable-accessing'
method: RBProgramNode
recurseIntoCharacter
	^$`
%

category: 'testing'
method: RBProgramNode
references: aVariableName 
	^self children anySatisfy: [:each | each references: aVariableName]
%

category: 'replacing'
method: RBProgramNode
removeDeadCode
	self children do: [:each | each removeDeadCode]
%

category: 'properties'
method: RBProgramNode
removeProperty: aKey
	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."
	
	^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ].
%

category: 'properties'
method: RBProgramNode
removeProperty: aKey ifAbsent: aBlock
	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."
	
	| answer |
	properties isNil ifTrue: [ ^ aBlock value ].
	answer := properties removeKey: aKey ifAbsent: aBlock.
	properties isEmpty ifTrue: [ properties := nil ].
	^ answer
%

category: 'replacing'
method: RBProgramNode
replaceMethodSource: aNode 
	"We are being replaced with aNode -- if possible try to perform an in place edit of the source."

	| method |
	method := self methodNode.
	method notNil ifTrue: [method map: self to: aNode].
	aNode parent: self parent.
	[self replaceSourceWith: aNode] on: Error
		do: 
			[:ex | 
			self clearReplacements.
			ex return]
%

category: 'replacing'
method: RBProgramNode
replaceNode: aNode withNode: anotherNode 
	self error: 'I don''t store other nodes'
%

category: 'private-replacing'
method: RBProgramNode
replaceSourceFrom: aNode
	self == aNode
		ifFalse: [ self clearReplacements ]
%

category: 'private-replacing'
method: RBProgramNode
replaceSourceWith: aNode 
	aNode replaceSourceFrom: self
%

category: 'replacing'
method: RBProgramNode
replaceWith: aNode 
	parent isNil ifTrue: [self error: 'This node doesn''t have a parent'].
	self replaceMethodSource: aNode.
	parent replaceNode: self withNode: aNode
%

category: 'querying'
method: RBProgramNode
selfMessages
	| searcher |
	searcher := RBParseTreeSearcher new.
	searcher matches: 'self `@msg: ``@args'
		do: 
			[:aNode :answer | 
			answer
				add: aNode selector;
				yourself].
	^searcher executeTree: self initialAnswer: Set new
%

category: 'accessing'
method: RBProgramNode
sentMessages
	^ self children
		inject: Set new
		into: [ :messages :each | 
			messages
				addAll: each sentMessages;
				yourself ]
%

category: 'enumeration'
method: RBProgramNode
size
	"Hacked to fit collection protocols"

	^1
%

category: 'accessing'
method: RBProgramNode
source
	^parent notNil ifTrue: [parent source] ifFalse: [nil]
%

category: 'accessing'
method: RBProgramNode
sourceInterval
	^self start to: self stop
%

category: 'accessing'
method: RBProgramNode
start
	self subclassResponsibility
%

category: 'meta variable-accessing'
method: RBProgramNode
statementCharacter
	^$.
%

category: 'accessing'
method: RBProgramNode
statementComments
	| statementComments |
	statementComments := OrderedCollection withAll: self comments.
	self children do: [:each | statementComments addAll: each statementComments].
	^statementComments asSortedCollection: [:a :b | a first < b first]
%

category: 'querying'
method: RBProgramNode
statementNode
	"Return your topmost node that is contained by a sequence node."

	(parent isNil or: [parent isSequence]) ifTrue: [^self].
	^parent statementNode
%

category: 'accessing'
method: RBProgramNode
stop
	self subclassResponsibility
%

category: 'querying'
method: RBProgramNode
superMessages
	| searcher |
	searcher := RBParseTreeSearcher new.
	searcher matches: 'super `@msg: ``@args'
		do: 
			[:aNode :answer | 
			answer
				add: aNode selector;
				yourself].
	^searcher executeTree: self initialAnswer: Set new
%

category: 'accessing'
method: RBProgramNode
temporaryVariables
	^parent isNil ifTrue: [#()] ifFalse: [parent temporaryVariables]
%

category: 'testing'
method: RBProgramNode
uses: aNode
	^true
%

category: 'querying'
method: RBProgramNode
whichNodeIsContainedBy: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	selectedChildren := self children 
				select: [:each | each intersectsInterval: anInterval].
	^selectedChildren size == 1 
		ifTrue: [selectedChildren first whichNodeIsContainedBy: anInterval]
		ifFalse: [nil]
%

category: 'querying'
method: RBProgramNode
whoDefines: aName 
	^(self defines: aName) 
		ifTrue: [self]
		ifFalse: [parent notNil ifTrue: [parent whoDefines: aName] ifFalse: [nil]]
%

! Class implementation for 'RBMethodNode'

!		Class methods for 'RBMethodNode'

category: 'instance creation'
classmethod: RBMethodNode
selector: aSymbol arguments: variableNodes body: aSequenceNode 
	^(self new)
		arguments: variableNodes;
		selector: aSymbol;
		body: aSequenceNode;
		yourself
%

category: 'instance creation'
classmethod: RBMethodNode
selector: aSymbol body: aSequenceNode 
	^self 
		selector: aSymbol
		arguments: #()
		body: aSequenceNode
%

category: 'instance creation'
classmethod: RBMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	^(self new)
		selectorParts: tokenCollection arguments: variableNodes;
		yourself
%

!		Instance methods for 'RBMethodNode'

category: 'comparing'
method: RBMethodNode
= anObject 
	self == anObject ifTrue: [ ^ true ].
	self class = anObject class ifFalse: [ ^ false ].
	(self selector = anObject selector
		and: [ self pragmas size = anObject pragmas size
		and: [ self body = anObject body ] ])
			ifFalse: [ ^ false ].
	self arguments with: anObject arguments do: [ :first :second |
		first = second 
			ifFalse: [ ^ false ] ].
	self pragmas with: anObject pragmas do: [ :first :second |
		first = second 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'visitor'
method: RBMethodNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptMethodNode: self
%

category: 'accessing'
method: RBMethodNode
addNode: aNode
	^ body addNode: aNode
%

category: 'replacing'
method: RBMethodNode
addReplacement: aStringReplacement 
	replacements isNil ifTrue: [^self].
	replacements add: aStringReplacement
%

category: 'accessing'
method: RBMethodNode
addReturn
	^ body addReturn
%

category: 'accessing'
method: RBMethodNode
addSelfReturn
	^ body addSelfReturn
%

category: 'accessing'
method: RBMethodNode
allArgumentVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allArgumentVariables;
		yourself
%

category: 'accessing'
method: RBMethodNode
allDefinedVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allDefinedVariables;
		yourself
%

category: 'accessing'
method: RBMethodNode
argumentNames
	^self arguments collect: [:each | each name]
%

category: 'accessing'
method: RBMethodNode
arguments
	^arguments
%

category: 'accessing'
method: RBMethodNode
arguments: variableNodes 
	arguments := variableNodes.
	arguments do: [:each | each parent: self]
%

category: 'accessing'
method: RBMethodNode
body
	^body
%

category: 'accessing'
method: RBMethodNode
body: stmtsNode 
	body := stmtsNode.
	body parent: self
%

category: 'private'
method: RBMethodNode
buildSelector
	| selectorStream |
	selectorStream := WriteStreamPortable on: String new.
	selectorParts do: [:each | selectorStream nextPutAll: each value].
	^selectorStream contents asSymbol
%

category: 'private-replacing'
method: RBMethodNode
changeSourceSelectors: oldSelectorParts arguments: oldArguments
	"If this is the same number of arguments, we try a one to one replacement of selector parts and arguments. If this is not the case try to rewrite the signature as a whole, what unfortunately drops the comments within the signature."
	
	[ (oldSelectorParts size = selectorParts size and: [ oldArguments size = arguments size ])
		ifTrue: [
			oldSelectorParts with: selectorParts do: [ :old :new | 
				self addReplacement: (RBStringReplacement 
					replaceFrom: old start
					to: old stop
					with: new value) ].
			oldArguments with: arguments do: [ :old :new | 
				self addReplacement: (RBStringReplacement 
					replaceFrom: old start
					to: old stop
					with: new name) ] ]
		ifFalse: [
			self addReplacement: (RBStringReplacement
				replaceFrom: oldSelectorParts first start
				to: (oldArguments notEmpty
					ifTrue: [ oldArguments last stop ]
					ifFalse: [ oldSelectorParts last stop ])
				with: (String streamContents: [ :stream |
					selectorParts keysAndValuesDo: [ :index :part |
						index = 1 ifFalse: [ stream space ].
						stream nextPutAll: part value.
						index <= arguments size
							ifTrue: [ stream space; nextPutAll: (arguments at: index) name ] ] ])) ] ]
		on: Error
		do: [ :ex | ex return ]
%

category: 'accessing'
method: RBMethodNode
children
	^ OrderedCollection new
		addAll: self arguments;
		addAll: self pragmas;
		add: self body;
		yourself
%

category: 'replacing'
method: RBMethodNode
clearReplacements
	replacements := nil
%

category: 'matching'
method: RBMethodNode
copyInContext: aDictionary
	^ self class new
		selectorParts: (self selectorParts collect: [ :each | each copy removePositions ]);
		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);
		pragmas: (self pragmas isEmpty
			ifTrue: [ aDictionary at: '-pragmas-' ifAbsent: [ #() ] ]
			ifFalse: [ self copyList: self pragmas inContext: aDictionary ]);
		body: (self body copyInContext: aDictionary);
		source: (aDictionary at: '-source-' ifAbsentPut: [ self source ]);
		yourself
%

category: 'testing'
method: RBMethodNode
defines: aName 
	^arguments anySatisfy: [:each | each name = aName]
%

category: 'comparing'
method: RBMethodNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [ ^ false ].
	(self selector = anObject selector
		and: [ self pragmas size = anObject pragmas size
		and: [ self body equalTo: anObject body withMapping: aDictionary ] ]) 
			ifFalse: [ ^ false ].
	self arguments with: anObject arguments do: [ :first :second |
		(first equalTo: second	withMapping: aDictionary)
			ifFalse: [ ^ false ].
		aDictionary removeKey: first name ].
	self pragmas with: anObject pragmas do: [ :first :second |
		(first equalTo: second	withMapping: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'comparing'
method: RBMethodNode
hash
	^ ((self selector hash bitXor: (self hashForCollection: self arguments)) bitXor: (self hashForCollection: self pragmas)) bitXor: self body hash
%

category: 'initialize-release'
method: RBMethodNode
initialize
	replacements := SortedCollection sortBlock: 
					[:a :b | 
					a startPosition < b startPosition 
						or: [a startPosition = b startPosition and: [a stopPosition < b stopPosition]]].
	nodeReplacements := IdentityDictionary new
%

category: 'testing'
method: RBMethodNode
isLast: aNode 
	^body isLast: aNode
%

category: 'testing'
method: RBMethodNode
isMethod
	^true
%

category: 'testing'
method: RBMethodNode
isPrimitive
	^ self pragmas anySatisfy: [ :each | each isPrimitive ]
%

category: 'testing'
method: RBMethodNode
lastIsReturn
	^body lastIsReturn
%

category: 'replacing'
method: RBMethodNode
map: oldNode to: newNode 
	nodeReplacements at: oldNode put: newNode
%

category: 'replacing'
method: RBMethodNode
mappingFor: oldNode 
	^nodeReplacements at: oldNode ifAbsent: [oldNode]
%

category: 'matching'
method: RBMethodNode
match: aNode inContext: aDictionary 
	self class = aNode class ifFalse: [ ^ false ].
	aDictionary at: '-source-' put: aNode source.
	self selector = aNode selector ifFalse: [ ^ false ].
	^ (self matchList: arguments against: aNode arguments inContext: aDictionary)
		and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)
		and: [ body match: aNode body inContext: aDictionary ] ]
%

category: 'matching'
method: RBMethodNode
matchPragmas: matchNodes against: pragmaNodes inContext: aDictionary
	matchNodes isEmpty ifTrue: [ 
		aDictionary at: '-pragmas-' put: pragmaNodes.
		^ true ].
	^ matchNodes allSatisfy: [ :matchNode |
		pragmaNodes anySatisfy: [ :pragmaNode |
			matchNode match: pragmaNode inContext: aDictionary ] ]
%

category: 'accessing'
method: RBMethodNode
methodComments
	| methodComments |
	methodComments := OrderedCollection withAll: self comments.
	arguments do: [:each | methodComments addAll: each comments].
	^methodComments asSortedCollection: [:a :b | a first < b first]
%

category: 'accessing'
method: RBMethodNode
methodNode
	^self
%

category: 'accessing'
method: RBMethodNode
newSource
	replacements isNil ifTrue: [^self formattedCode].
	^[self reformatSource] on: Error do: [:ex | ex return: self formattedCode]
%

category: 'accessing'
method: RBMethodNode
numArgs
	^self selector numArgs
%

category: 'copying'
method: RBMethodNode
postCopy
	super postCopy.
	self arguments: (self arguments collect: [ :each | each copy ]).
	self pragmas: (self pragmas collect: [ :each | each copy ]).
	self body: self body copy
%

category: 'accessing'
method: RBMethodNode
pragmas
	^ pragmas ifNil: [ #() ]
%

category: 'accessing'
method: RBMethodNode
pragmas: aCollection
	pragmas := aCollection.
	pragmas do: [ :each | each parent: self ]
%

category: 'accessing'
method: RBMethodNode
primitiveSources
	^ self pragmas collect: [ :each | self source copyFrom: each first to: each last ]
%

category: 'printing'
method: RBMethodNode
printOn: aStream 
	aStream nextPutAll: self formattedCode
%

category: 'testing'
method: RBMethodNode
references: aVariableName 
	^body references: aVariableName
%

category: 'private'
method: RBMethodNode
reformatSource
	| stream newSource newTree |
	stream := WriteStreamPortable on: String new.
	stream
		nextPutAll: (source
			copyFrom: (replacements
				inject: 1
				into: [ :sum :each | 
					stream
						nextPutAll: (source copyFrom: sum to: each startPosition - 1);
						nextPutAll: (each string).
					each stopPosition + 1 ])
			to: source size).
	newSource := stream contents.
	newTree := RBParser 
		parseMethod: newSource 
		onError: [ :msg :pos | ^ self formattedCode ].
	self = newTree
		ifFalse: [ ^ self formattedCode ].
	^ newSource
%

category: 'accessing'
method: RBMethodNode
renameSelector: newSelector andArguments: varNodeCollection 
	| oldSelectorParts oldArguments |
	oldSelectorParts := selectorParts.
	oldArguments := arguments.
	self
		arguments: varNodeCollection;
		selector: newSelector.
	self changeSourceSelectors: oldSelectorParts arguments: oldArguments
%

category: 'replacing'
method: RBMethodNode
replaceNode: aNode withNode: anotherNode 
	aNode == body ifTrue: [self body: anotherNode].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'accessing'
method: RBMethodNode
selector
	^selector isNil
		ifTrue: [selector := self buildSelector]
		ifFalse: [selector]
%

category: 'accessing'
method: RBMethodNode
selector: aSelector 
	| keywords numArgs |
	keywords := aSelector keywords.
	numArgs := aSelector numArgs.
	numArgs == arguments size 
		ifFalse: 
			[self 
				error: 'Attempting to assign selector with wrong number of arguments.'].
	selectorParts := numArgs == 0 
				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]
				ifFalse: 
					[keywords first last = $: 
						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]
						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].
	selector := aSelector asSymbol
%

category: 'private'
method: RBMethodNode
selectorParts
	^selectorParts
%

category: 'private'
method: RBMethodNode
selectorParts: tokenCollection 
	selectorParts := tokenCollection
%

category: 'initialize-release'
method: RBMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	selectorParts := tokenCollection.
	self arguments: variableNodes
%

category: 'accessing'
method: RBMethodNode
source
	^source
%

category: 'accessing'
method: RBMethodNode
source: anObject
	source := anObject
%

category: 'accessing'
method: RBMethodNode
start
	^1
%

category: 'accessing'
method: RBMethodNode
stop
	^source size
%

category: 'testing'
method: RBMethodNode
uses: aNode 
	^body == aNode and: [aNode lastIsReturn]
%

! Class implementation for 'RBPatternMethodNode'

!		Class methods for 'RBPatternMethodNode'

category: 'instance creation'
classmethod: RBPatternMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	^(tokenCollection anySatisfy: [:each | each isPatternVariable]) 
		ifTrue: [super selectorParts: tokenCollection arguments: variableNodes]
		ifFalse: 
			[RBMethodNode selectorParts: tokenCollection arguments: variableNodes]
%

!		Instance methods for 'RBPatternMethodNode'

category: 'matching'
method: RBPatternMethodNode
copyInContext: aDictionary 
	| selectors |
	selectors := self isSelectorList 
		ifTrue: [ (aDictionary at: selectorParts first value) keywords ]
		ifFalse: [ self selectorParts collect: [ :each | aDictionary at: each value ] ].
	^ RBMethodNode new
		selectorParts: (selectors collect: [ :each | 
			(each last = $: ifTrue: [ RBKeywordToken ] ifFalse: [ RBIdentifierToken ]) 
				value: each start: nil ]);
		arguments: (self copyList: self arguments inContext: aDictionary);
		pragmas: (self pragmas isEmpty
			ifTrue: [ aDictionary at: '-pragmas-' ifAbsent: [ #() ] ]
			ifFalse: [ self copyList: self pragmas inContext: aDictionary ]);
		body: (self body copyInContext: aDictionary);
		source: (aDictionary at: '-source-');
		yourself
%

category: 'testing-matching'
method: RBPatternMethodNode
isPatternNode
	^true
%

category: 'testing'
method: RBPatternMethodNode
isSelectorList
	^isList
%

category: 'matching'
method: RBPatternMethodNode
match: aNode inContext: aDictionary 
	aNode class = self matchingClass 
		ifFalse: [ ^ false ].
	aDictionary at: '-source-' put: aNode source.
	self isSelectorList ifTrue: [
		^ (aDictionary at: selectorParts first value ifAbsentPut: [ aNode selector ]) = aNode selector
			and: [ (aDictionary at: arguments first ifAbsentPut: [ aNode arguments ]) = aNode arguments
			and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)
			and: [ body match: aNode body inContext: aDictionary ] ] ] ].
	^(self matchArgumentsAgainst: aNode inContext: aDictionary) 
		and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)
		and: [ body match: aNode body inContext: aDictionary ] ]
%

category: 'matching'
method: RBPatternMethodNode
matchArgumentsAgainst: aNode inContext: aDictionary 
	self arguments size = aNode arguments size
		ifFalse: [ ^ false ].
	(self matchSelectorAgainst: aNode inContext: aDictionary) 
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'private'
method: RBPatternMethodNode
matchingClass
	^RBMethodNode
%

category: 'matching'
method: RBPatternMethodNode
matchSelectorAgainst: aNode inContext: aDictionary 
	self selectorParts with: aNode selectorParts do: [ :first :second |
		| keyword |
		keyword := aDictionary
			at: first value
			ifAbsentPut: [ 
				first isPatternVariable 
					ifTrue: [ second value ]
					ifFalse: [ first value ] ].
		keyword = second value 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'initialize-release'
method: RBPatternMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	super selectorParts: tokenCollection arguments: variableNodes.
	isList := (tokenCollection first value at: 2) == self listCharacter
%

! Class implementation for 'RBPragmaNode'

!		Class methods for 'RBPragmaNode'

category: 'instance creation'
classmethod: RBPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	^ self new selectorParts: keywordTokens arguments: valueNodes
%

!		Instance methods for 'RBPragmaNode'

category: 'comparing'
method: RBPragmaNode
= anObject
  self == anObject
    ifTrue: [ ^ true ].
  self class = anObject class
    ifFalse: [ ^ false ].
  self selector = anObject selector
    ifFalse: [ ^ false ].
  1 to: self arguments size do: [ :i | 
    (self arguments at: i) = (anObject arguments at: i)
      ifFalse: [ ^ false ] ].
  self isProtected == anObject isProtected
    ifFalse: [ ^ false ].
  ^ true
%

category: 'visitor'
method: RBPragmaNode
acceptVisitor: aProgramNodeVisitor 
	^ aProgramNodeVisitor acceptPragmaNode: self
%

category: 'accessing'
method: RBPragmaNode
arguments
	^ arguments ifNil: [ #() ]
%

category: 'accessing'
method: RBPragmaNode
arguments: aLiteralCollection 
	arguments := aLiteralCollection.
	arguments do: [ :each | each parent: self ]
%

category: 'private'
method: RBPragmaNode
buildSelector
	| selectorStream |
	selectorStream := WriteStreamPortable on: String new.
	selectorParts do: [ :each | selectorStream nextPutAll: each value ].
	^ selectorStream contents asSymbol
%

category: 'accessing'
method: RBPragmaNode
children
	^ self arguments
%

category: 'matching'
method: RBPragmaNode
copyInContext: aDictionary 
	^ self class new
		selectorParts: (self selectorParts collect: [ :each | each copy removePositions ]);
		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);
		yourself
%

category: 'comparing'
method: RBPragmaNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [ ^ false ].
	self selector = anObject selector ifFalse: [ ^ false ].
	self arguments with: anObject arguments do: [ :first :second |
		(first equalTo: second withMapping: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'comparing'
method: RBPragmaNode
hash
	^ self selector hash bitXor: (self hashForCollection: self arguments)
%

category: 'testing'
method: RBPragmaNode
isBinary
	^ (self isUnary or: [self isKeyword]) not
%

category: 'testing'
method: RBPragmaNode
isKeyword
	^ selectorParts first value last = $:
%

category: 'testing'
method: RBPragmaNode
isPragma
	^ true
%

category: 'testing'
method: RBPragmaNode
isPrimitive
	^ #(primitive: primitive:error: primitive:error:module: primitive:module: primitive:module:error:) includes: self selector
%

category: 'testing'
method: RBPragmaNode
isProtected
  isProtected ifNil: [ ^ false ].
  ^ isProtected
%

category: 'testing'
method: RBPragmaNode
isProtected: aBool
  isProtected := aBool
%

category: 'testing'
method: RBPragmaNode
isProtectedPrimitive
  ^ self isProtected and: [ self isPrimitive ]
%

category: 'testing'
method: RBPragmaNode
isUnary
	^ arguments isEmpty
%

category: 'accessing-token'
method: RBPragmaNode
left
	^ left
%

category: 'accessing-token'
method: RBPragmaNode
left: anInteger
	left := anInteger
%

category: 'matching'
method: RBPragmaNode
match: aNode inContext: aDictionary 
	aNode class = self class
		ifFalse: [ ^ false ].
	self selector = aNode selector
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary)
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'accessing'
method: RBPragmaNode
numArgs
	^ self selector numArgs
%

category: 'copying'
method: RBPragmaNode
postCopy
	super postCopy.
	self arguments: (self arguments collect: [ :each | each copy ])
%

category: 'replacing'
method: RBPragmaNode
replaceNode: aNode withNode: anotherNode 
	self arguments: (arguments collect: [ :each | 
		each == aNode 
			ifTrue: [ anotherNode ]
			ifFalse: [ each ] ])
%

category: 'accessing-token'
method: RBPragmaNode
right
	^ right
%

category: 'accessing-token'
method: RBPragmaNode
right: anInteger
	right := anInteger
%

category: 'accessing'
method: RBPragmaNode
selector
	^ selector ifNil: [ selector := self buildSelector ]
%

category: 'accessing'
method: RBPragmaNode
selector: aSelector 
	| keywords numArgs |
	keywords := aSelector keywords.
	numArgs := aSelector numArgs.
	numArgs == arguments size 
		ifFalse: 
			[self 
				error: 'Attempting to assign selector with wrong number of arguments.'].
	selectorParts := numArgs == 0 
				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]
				ifFalse: 
					[keywords first last = $: 
						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]
						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].
	selector := aSelector asSymbol
%

category: 'private'
method: RBPragmaNode
selectorParts
	^ selectorParts
%

category: 'private'
method: RBPragmaNode
selectorParts: tokenCollection 
	selectorParts := tokenCollection
%

category: 'initialization'
method: RBPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	self selectorParts: keywordTokens.
	self arguments: valueNodes
%

category: 'accessing'
method: RBPragmaNode
sentMessages
	^ super sentMessages
		add: self selector;
		yourself
%

category: 'accessing'
method: RBPragmaNode
start
	^ left
%

category: 'accessing'
method: RBPragmaNode
stop
	^ right
%

! Class implementation for 'RBPatternPragmaNode'

!		Class methods for 'RBPatternPragmaNode'

category: 'instance creation'
classmethod: RBPatternPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	^ (keywordTokens anySatisfy: [ :each | each isPatternVariable ]) 
		ifTrue: [ super selectorParts: keywordTokens arguments: valueNodes ]
		ifFalse: [ RBPragmaNode selectorParts: keywordTokens arguments: valueNodes ]
%

!		Instance methods for 'RBPatternPragmaNode'

category: 'matching'
method: RBPatternPragmaNode
copyInContext: aDictionary 
	| selectors |
	selectors := self isSelectorList 
		ifTrue: [ (aDictionary at: selectorParts first value) keywords ]
		ifFalse: [ self selectorParts collect: [ :each | aDictionary at: each value ] ].
	^ RBPragmaNode new
		selectorParts: (selectors collect: [ :each | 
			(each last = $: ifTrue: [ RBKeywordToken ] ifFalse: [ RBIdentifierToken ]) 
				value: each start: nil ]);
		arguments: (self copyList: self arguments inContext: aDictionary);
		yourself
%

category: 'testing-matching'
method: RBPatternPragmaNode
isPatternNode
	^ true
%

category: 'testing-matching'
method: RBPatternPragmaNode
isSelectorList
	^ isList
%

category: 'matching'
method: RBPatternPragmaNode
match: aNode inContext: aDictionary
	aNode class = self matchingClass
		ifFalse: [ ^ false ].
	self isSelectorList ifTrue: [
		^ (aDictionary at: selectorParts first value ifAbsentPut: [ aNode selector ]) = aNode selector
			and: [ (aDictionary at: arguments first ifAbsentPut: [ aNode arguments ]) = aNode arguments ] ].
	^ self matchArgumentsAgainst: aNode inContext: aDictionary
%

category: 'matching'
method: RBPatternPragmaNode
matchArgumentsAgainst: aNode inContext: aDictionary 
	self arguments size = aNode arguments size
		ifFalse: [ ^ false ].
	(self matchSelectorAgainst: aNode inContext: aDictionary) 
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'private'
method: RBPatternPragmaNode
matchingClass
	^ RBPragmaNode
%

category: 'matching'
method: RBPatternPragmaNode
matchSelectorAgainst: aNode inContext: aDictionary 
	self selectorParts with: aNode selectorParts do: [ :first :second |
		| keyword |
		keyword := aDictionary
			at: first value
			ifAbsentPut: [ 
				first isPatternVariable 
					ifTrue: [ second value ]
					ifFalse: [ first value ] ].
		keyword = second value 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'initialization'
method: RBPatternPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	super selectorParts: keywordTokens arguments: valueNodes.
	isList := (keywordTokens first value at: 2) == self listCharacter
%

category: 'accessing'
method: RBPatternPragmaNode
sentMessages
	^ super sentMessages
		remove: self selector ifAbsent: [ ];
		yourself
%

! Class implementation for 'RBReturnNode'

!		Class methods for 'RBReturnNode'

category: 'instance creation'
classmethod: RBReturnNode
return: returnInteger value: aValueNode 
	^self new return: returnInteger value: aValueNode
%

category: 'instance creation'
classmethod: RBReturnNode
value: aNode
	^self return: nil value: aNode
%

!		Instance methods for 'RBReturnNode'

category: 'comparing'
method: RBReturnNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	^self value = anObject value
%

category: 'visitor'
method: RBReturnNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptReturnNode: self
%

category: 'accessing'
method: RBReturnNode
children
	^Array with: value
%

category: 'testing'
method: RBReturnNode
containsReturn
	^true
%

category: 'matching'
method: RBReturnNode
copyInContext: aDictionary 
	^ self class new
		value: (self value copyInContext: aDictionary);
		yourself
%

category: 'comparing'
method: RBReturnNode
equalTo: anObject withMapping: aDictionary 
	^self class = anObject class 
		and: [self value equalTo: anObject value withMapping: aDictionary]
%

category: 'comparing'
method: RBReturnNode
hash
	^self value hash
%

category: 'testing'
method: RBReturnNode
isReturn
	^true
%

category: 'matching'
method: RBReturnNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^value match: aNode value inContext: aDictionary
%

category: 'copying'
method: RBReturnNode
postCopy
	super postCopy.
	self value: self value copy
%

category: 'replacing'
method: RBReturnNode
replaceNode: aNode withNode: anotherNode 
	value == aNode ifTrue: [self value: anotherNode]
%

category: 'accessing-token'
method: RBReturnNode
return
	^ return
%

category: 'accessing-token'
method: RBReturnNode
return: anInteger
	return := anInteger
%

category: 'initialize-release'
method: RBReturnNode
return: returnInteger value: aValueNode 
	return := returnInteger.
	self value: aValueNode
%

category: 'accessing'
method: RBReturnNode
start
	^return
%

category: 'accessing'
method: RBReturnNode
stop
	^value stop
%

category: 'accessing'
method: RBReturnNode
value
	^value
%

category: 'accessing'
method: RBReturnNode
value: valueNode 
	value := valueNode.
	value parent: self
%

! Class implementation for 'RBSequenceNode'

!		Class methods for 'RBSequenceNode'

category: 'instance creation'
classmethod: RBSequenceNode
leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 
	^(self new)
		leftBar: leftInteger
			temporaries: variableNodes
			rightBar: rightInteger;
		yourself
%

category: 'instance creation'
classmethod: RBSequenceNode
statements: statementNodes 
	^self temporaries: #() statements: statementNodes
%

category: 'instance creation'
classmethod: RBSequenceNode
temporaries: variableNodes statements: statementNodes 
	^(self new)
		temporaries: variableNodes;
		statements: statementNodes;
		yourself
%

!		Instance methods for 'RBSequenceNode'

category: 'comparing'
method: RBSequenceNode
= anObject 
	"Can't send = to the temporaries and statements collection since they might change from arrays to OCs"

	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	self temporaries size = anObject temporaries size ifFalse: [^false].
	1 to: self temporaries size
		do: 
			[:i | 
			(self temporaries at: i) = (anObject temporaries at: i) ifFalse: [^false]].
	self statements size = anObject statements size ifFalse: [^false].
	1 to: self statements size
		do: [:i | (self statements at: i) = (anObject statements at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBSequenceNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptSequenceNode: self
%

category: 'adding nodes'
method: RBSequenceNode
addNode: aNode
	aNode parent: self.
	(statements notEmpty and: [ statements last isReturn ])
		ifTrue: [ self error: 'Cannot add statement after return node' ].
	statements := statements asOrderedCollection
		add: aNode;
		yourself.
	^ aNode
%

category: 'adding nodes'
method: RBSequenceNode
addNode: aNode before: anotherNode
	| index |
	index := self indexOfNode: anotherNode.
	index = 0
		ifTrue: [ ^ self addNode: aNode ].
	statements := statements asOrderedCollection
		add: aNode beforeIndex: index;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBSequenceNode
addNodeFirst: aNode
	aNode parent: self.
	statements := statements asOrderedCollection
		addFirst: aNode;
		yourself.
	^ aNode
%

category: 'adding nodes'
method: RBSequenceNode
addNodes: aCollection
	aCollection do: [ :each | each parent: self ].
	(statements notEmpty and: [ statements last isReturn ])
		ifTrue: [ self error: 'Cannot add statement after return node' ].
	statements := statements asOrderedCollection
		addAll: aCollection;
		yourself.
	^ aCollection
%

category: 'adding nodes'
method: RBSequenceNode
addNodes: aCollection before: anotherNode
	aCollection do: [ :each | self addNode: each before: anotherNode ].
	^ aCollection
%

category: 'adding nodes'
method: RBSequenceNode
addNodesFirst: aCollection
	aCollection do: [ :each | each parent: self ].
	statements := statements asOrderedCollection
		addAllFirst: aCollection;
		yourself.
	^ aCollection
%

category: 'accessing'
method: RBSequenceNode
addReturn
	| node |
	statements isEmpty
		ifTrue: [ ^ nil ].
	statements last isReturn
		ifTrue: [ ^ statements last ].
	node := RBReturnNode value: statements last.
	statements at: statements size put: node.
	node parent: self.
	^ node
%

category: 'adding nodes'
method: RBSequenceNode
addSelfReturn
	| node |
	self lastIsReturn
		ifTrue: [ ^ self statements last ].
	node := RBReturnNode value: (RBVariableNode named: 'self').
	^ self addNode: node
%

category: 'adding nodes'
method: RBSequenceNode
addTemporariesNamed: aCollection
	^ aCollection collect: [ :each | self addTemporaryNamed: each ]
%

category: 'adding nodes'
method: RBSequenceNode
addTemporaryNamed: aString 
	| variableNode |
	variableNode := RBVariableNode named: aString.
	variableNode parent: self.
	temporaries := temporaries copyWith: variableNode.
	^ variableNode
%

category: 'accessing'
method: RBSequenceNode
allDefinedVariables
	^(self temporaryNames asOrderedCollection)
		addAll: super allDefinedVariables;
		yourself
%

category: 'accessing'
method: RBSequenceNode
allTemporaryVariables
	^(self temporaryNames asOrderedCollection)
		addAll: super allTemporaryVariables;
		yourself
%

category: 'querying'
method: RBSequenceNode
bestNodeFor: anInterval 
	| node |
	node := super bestNodeFor: anInterval.
	node == self 
		ifTrue: 
			[(temporaries isEmpty and: [statements size == 1]) 
				ifTrue: [^statements first]].
	^node
%

category: 'accessing'
method: RBSequenceNode
children
	^(OrderedCollection new)
		addAll: self temporaries;
		addAll: self statements;
		yourself
%

category: 'matching'
method: RBSequenceNode
copyInContext: aDictionary 
	^ self class new
		temporaries: (self copyList: self temporaries inContext: aDictionary);
		statements: (self copyList: self statements inContext: aDictionary);
		yourself
%

category: 'testing'
method: RBSequenceNode
defines: aName 
	^temporaries anySatisfy: [:each | each name = aName]
%

category: 'testing'
method: RBSequenceNode
directlyUses: aNode 
	^false
%

category: 'comparing'
method: RBSequenceNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self statements size = anObject statements size ifFalse: [^false].
	1 to: self statements size
		do: 
			[:i | 
			((self statements at: i) equalTo: (anObject statements at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	aDictionary values asSet size = aDictionary size ifFalse: [^false].	"Not a one-to-one mapping"
	self temporaries
		do: [:each | aDictionary removeKey: each name ifAbsent: []].
	^true
%

category: 'comparing'
method: RBSequenceNode
hash
	^ (self hashForCollection: self temporaries) bitXor: (self hashForCollection: self statements)
%

category: 'private'
method: RBSequenceNode
indexOfNode: aNode 
	"Try to find the node by first looking for ==, and then for ="

	^(1 to: statements size) detect: [:each | (statements at: each) == aNode]
		ifNone: [statements indexOf: aNode]
%

category: 'initialize-release'
method: RBSequenceNode
initialize
	super initialize.
	periods := statements := temporaries := #()
%

category: 'testing'
method: RBSequenceNode
isLast: aNode 
	| last |
	statements isEmpty ifTrue: [^false].
	last := statements last.
	^last == aNode or: 
			[last isMessage and: 
					[(#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: last selector) 
						and: [last arguments anySatisfy: [:each | each isLast: aNode]]]]
%

category: 'testing'
method: RBSequenceNode
isSequence
	^true
%

category: 'testing'
method: RBSequenceNode
lastIsReturn
	^statements notEmpty and: [statements last lastIsReturn]
%

category: 'accessing-token'
method: RBSequenceNode
leftBar
	^ leftBar
%

category: 'accessing-token'
method: RBSequenceNode
leftBar: anInteger
	leftBar := anInteger
%

category: 'initialize-release'
method: RBSequenceNode
leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 
	leftBar := leftInteger.
	self temporaries: variableNodes.
	rightBar := rightInteger
%

category: 'matching'
method: RBSequenceNode
match: aNode inContext: aDictionary 
	self class = aNode class ifFalse: [^false].
	^(self 
		matchList: temporaries
		against: aNode temporaries
		inContext: aDictionary) and: 
				[self 
					matchList: statements
					against: aNode statements
					inContext: aDictionary]
%

category: 'accessing'
method: RBSequenceNode
methodComments
	| methodComments |
	methodComments := OrderedCollection withAll: self comments.
	temporaries do: [:each | methodComments addAll: each comments].
	(parent notNil and: [parent isBlock]) 
		ifTrue: [parent arguments do: [:each | methodComments addAll: each comments]].
	^methodComments asSortedCollection: [:a :b | a first < b first]
%

category: 'accessing-token'
method: RBSequenceNode
periods
	^ periods
%

category: 'accessing-token'
method: RBSequenceNode
periods: anArray
	periods := anArray
%

category: 'copying'
method: RBSequenceNode
postCopy
	super postCopy.
	self temporaries: (self temporaries collect: [ :each | each copy ]).
	self statements: (self statements collect: [ :each | each copy ])
%

category: 'testing'
method: RBSequenceNode
references: aVariableName 
	^statements anySatisfy: [:each | each references: aVariableName]
%

category: 'replacing'
method: RBSequenceNode
removeDeadCode
	(self isUsed ifTrue: [statements size - 1] ifFalse: [statements size]) 
		to: 1
		by: -1
		do: 
			[:i | 
			(statements at: i) isImmediateNode 
				ifTrue: 
					[self clearReplacements.
					statements removeAtIndex: i]].
	super removeDeadCode
%

category: 'replacing'
method: RBSequenceNode
removeNode: aNode
	self replaceNode: aNode withNodes: #()
%

category: 'accessing'
method: RBSequenceNode
removeTemporaryNamed: aName 
	temporaries := temporaries reject: [:each | each name = aName]
%

category: 'replacing'
method: RBSequenceNode
replaceNode: aNode withNode: anotherNode 
	self statements: (statements 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).
	self temporaries: (temporaries 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'replacing'
method: RBSequenceNode
replaceNode: aNode withNodes: aCollection 
	| index newStatements |
	self clearReplacements.
	index := self indexOfNode: aNode.
	newStatements := OrderedCollection new: statements size + aCollection size.
	1 to: index - 1 do: [:i | newStatements add: (statements at: i)].
	newStatements addAll: aCollection.
	index + 1 to: statements size
		do: [:i | newStatements add: (statements at: i)].
	aCollection do: [:each | each parent: self].
	statements := newStatements
%

category: 'accessing-token'
method: RBSequenceNode
rightBar
	^ rightBar
%

category: 'accessing-token'
method: RBSequenceNode
rightBar: anInteger
	rightBar := anInteger
%

category: 'accessing'
method: RBSequenceNode
start
	^leftBar isNil 
		ifTrue: [statements isEmpty ifTrue: [1] ifFalse: [statements first start]]
		ifFalse: [leftBar]
%

category: 'accessing'
method: RBSequenceNode
statements
	^statements
%

category: 'accessing'
method: RBSequenceNode
statements: stmtCollection 
	statements := stmtCollection.
	statements do: [:each | each parent: self]
%

category: 'accessing'
method: RBSequenceNode
stop
	^(periods isEmpty ifTrue: [0] ifFalse: [periods last]) 
		max: (statements isEmpty ifTrue: [0] ifFalse: [statements last stop])
%

category: 'accessing'
method: RBSequenceNode
temporaries
	^temporaries
%

category: 'accessing'
method: RBSequenceNode
temporaries: tempCollection 
	temporaries := tempCollection.
	temporaries do: [:each | each parent: self]
%

category: 'accessing'
method: RBSequenceNode
temporaryNames
	^temporaries collect: [:each | each name]
%

category: 'accessing'
method: RBSequenceNode
temporaryVariables
	^(super temporaryVariables asOrderedCollection)
		addAll: self temporaryNames;
		yourself
%

category: 'testing'
method: RBSequenceNode
uses: aNode 
	statements isEmpty ifTrue: [^false].
	aNode == statements last ifFalse: [^false].
	^self isUsed
%

category: 'querying'
method: RBSequenceNode
whichNodeIsContainedBy: anInterval 
	| node |
	node := super whichNodeIsContainedBy: anInterval.
	node == self 
		ifTrue: 
			[(temporaries isEmpty and: [statements size == 1]) 
				ifTrue: [^statements first]].
	^node
%

! Class implementation for 'RBValueNode'

!		Instance methods for 'RBValueNode'

category: 'accessing'
method: RBValueNode
addParenthesis: anInterval 
	parentheses isNil ifTrue: [parentheses := OrderedCollection new: 1].
	parentheses add: anInterval
%

category: 'testing'
method: RBValueNode
containedBy: anInterval 
	^anInterval first <= self startWithoutParentheses 
		and: [anInterval last >= self stopWithoutParentheses]
%

category: 'testing'
method: RBValueNode
hasParentheses
	^self parentheses notEmpty
%

category: 'testing'
method: RBValueNode
isValue
	^true
%

category: 'testing'
method: RBValueNode
needsParenthesis
	^self subclassResponsibility
%

category: 'accessing'
method: RBValueNode
parentheses
	^parentheses isNil ifTrue: [#()] ifFalse: [parentheses]
%

category: 'accessing'
method: RBValueNode
start
	^parentheses isNil 
		ifTrue: [self startWithoutParentheses]
		ifFalse: [parentheses last first]
%

category: 'accessing'
method: RBValueNode
startWithoutParentheses
	^self subclassResponsibility
%

category: 'accessing'
method: RBValueNode
stop
	^parentheses isNil
		ifTrue: [self stopWithoutParentheses]
		ifFalse: [parentheses last last]
%

category: 'accessing'
method: RBValueNode
stopWithoutParentheses
	^self subclassResponsibility
%

! Class implementation for 'RBArrayNode'

!		Class methods for 'RBArrayNode'

category: 'instance creation'
classmethod: RBArrayNode
statements: statements
	^ self new statements: statements
%

!		Instance methods for 'RBArrayNode'

category: 'comparing'
method: RBArrayNode
= anObject 
	self == anObject ifTrue: [ ^ true ].
	self class = anObject class ifFalse: [ ^ false ].
	self statements size = anObject statements size ifFalse: [ ^ false ].
	1 to: self statements size do: [ :i | 
		(self statements at: i) = (anObject statements at: i) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'visitor'
method: RBArrayNode
acceptVisitor: aProgramNodeVisitor
	^ aProgramNodeVisitor acceptArrayNode: self
%

category: 'adding nodes'
method: RBArrayNode
addNode: aNode
	statements := statements asOrderedCollection
		add: aNode;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBArrayNode
addNode: aNode before: anotherNode 
	| index |
	aNode isReturn 
		ifTrue: [ self error: 'Cannot add return node' ].
	index := self indexOfNode: anotherNode.
	index = 0 ifTrue: [ ^ self addNode: aNode ].
	statements := statements asOrderedCollection
		add: aNode beforeIndex: index;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBArrayNode
addNodeFirst: aNode
	statements := statements asOrderedCollection
		addFirst: aNode;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBArrayNode
addNodes: aCollection
	statements := statements asOrderedCollection
		addAll: aCollection;
		yourself.
	aCollection do: [ :each | each parent: self ].
	^ aCollection
%

category: 'adding nodes'
method: RBArrayNode
addNodes: aCollection before: anotherNode 
	aCollection do: [ :each | self addNode: each before: anotherNode ].
	^ aCollection
%

category: 'adding nodes'
method: RBArrayNode
addNodesFirst: aCollection
	statements := statements asOrderedCollection
		addAllFirst: aCollection;
		yourself.
	aCollection do: [ :each | each parent: self ].
	^ aCollection
%

category: 'accessing'
method: RBArrayNode
children
	^ self statements
%

category: 'matching'
method: RBArrayNode
copyInContext: aDictionary 
	^ self class statements: (self copyList: self statements inContext: aDictionary)
%

category: 'comparing'
method: RBArrayNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class 
		ifFalse: [ ^ false ].
	self statements size = anObject statements size 
		ifFalse: [ ^ false ].
	self statements with: anObject statements do: [ :first :second |
		(first equalTo: second withMapping: aDictionary)
			ifFalse: [ ^ false ] ].
	aDictionary values asSet size = aDictionary size 
		ifFalse: [ ^ false ].
	^ true
%

category: 'comparing'
method: RBArrayNode
hash
	^ self hashForCollection: self statements
%

category: 'private'
method: RBArrayNode
indexOfNode: aNode 
	"Try to find the node by first looking for ==, and then for ="

	^ (1 to: statements size) 
		detect: [ :each | (statements at: each) == aNode ]
		ifNone: [ statements indexOf: aNode ]
%

category: 'initialize-release'
method: RBArrayNode
initialize
	super initialize.
	statements := periods := #()
%

category: 'testing'
method: RBArrayNode
isArray
	^ true
%

category: 'testing'
method: RBArrayNode
lastIsReturn
	statements isEmpty ifTrue:[ ^false ].
	^statements last lastIsReturn
%

category: 'accessing-token'
method: RBArrayNode
left
	^ left
%

category: 'accessing-token'
method: RBArrayNode
left: anInteger
	left := anInteger
%

category: 'matching'
method: RBArrayNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [ ^ false ].
	^ self matchList: statements against: aNode statements inContext: aDictionary
%

category: 'testing'
method: RBArrayNode
needsParenthesis
	^ false
%

category: 'accessing-token'
method: RBArrayNode
periods
	^ periods
%

category: 'accessing-token'
method: RBArrayNode
periods: anArray
	periods := anArray
%

category: 'copying'
method: RBArrayNode
postCopy
	super postCopy.
	self statements: (self statements collect: [ :each | each copy ])
%

category: 'accessing'
method: RBArrayNode
precedence
	^0
%

category: 'testing'
method: RBArrayNode
references: aVariableName 
	^ statements anySatisfy: [ :each | each references: aVariableName ]
%

category: 'replacing'
method: RBArrayNode
replaceNode: oldNode  withNode: newNode
	self statements: (statements collect: [ :statement |
		statement == oldNode 
			ifTrue: [ newNode ]
			ifFalse: [ statement ] ])
%

category: 'accessing-token'
method: RBArrayNode
right
	^ right
%

category: 'accessing-token'
method: RBArrayNode
right: anInteger
	right := anInteger
%

category: 'accessing'
method: RBArrayNode
startWithoutParentheses 
	^ left
%

category: 'accessing'
method: RBArrayNode
statementComments
	^self comments
%

category: 'accessing'
method: RBArrayNode
statements
	^statements
%

category: 'accessing'
method: RBArrayNode
statements: statements0 
	statements := statements0.
	statements do: [:statement | statement parent: self]
%

category: 'accessing'
method: RBArrayNode
stopWithoutParentheses 
	^ right
%

category: 'testing'
method: RBArrayNode
uses: aNode 
	^ (statements anySatisfy: [ :each | each == aNode ]) or: [ self isUsed ]
%

! Class implementation for 'RBAssignmentNode'

!		Class methods for 'RBAssignmentNode'

category: 'instance creation'
classmethod: RBAssignmentNode
variable: aVariableNode value: aValueNode 
	^self 
		variable: aVariableNode
		value: aValueNode
		position: nil
%

category: 'instance creation'
classmethod: RBAssignmentNode
variable: aVariableNode value: aValueNode position: anInteger 
	^(self new)
		variable: aVariableNode
			value: aValueNode
			position: anInteger;
		yourself
%

!		Instance methods for 'RBAssignmentNode'

category: 'comparing'
method: RBAssignmentNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	^self variable = anObject variable and: [self value = anObject value]
%

category: 'visitor'
method: RBAssignmentNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptAssignmentNode: self
%

category: 'accessing-token'
method: RBAssignmentNode
assignment
	^ assignment
%

category: 'accessing-token'
method: RBAssignmentNode
assignment: anInteger
	assignment := anInteger
%

category: 'accessing'
method: RBAssignmentNode
assignmentOperator
	^ (self assignmentPosition notNil and: [ self source notNil and: [ (self source at: self assignmentPosition ifAbsent: [ nil ]) = $_ ] ])
		ifTrue: [ '_' ]
		ifFalse: [ ':=' ]
%

category: 'accessing'
method: RBAssignmentNode
assignmentPosition
	^ assignment
%

category: 'testing'
method: RBAssignmentNode
assigns: aVariableName 
	^variable name = aVariableName or: [value assigns: aVariableName]
%

category: 'querying'
method: RBAssignmentNode
bestNodeFor: anInterval 
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	assignment isNil ifTrue: [^super bestNodeFor: anInterval].
	((anInterval first between: assignment and: assignment + 1) 
		or: [assignment between: anInterval first and: anInterval last]) 
			ifTrue: [^self].
	self children do: 
			[:each | 
			| node |
			node := each bestNodeFor: anInterval.
			node notNil ifTrue: [^node]]
%

category: 'accessing'
method: RBAssignmentNode
children
	^Array with: value with: variable
%

category: 'matching'
method: RBAssignmentNode
copyInContext: aDictionary 
	^ self class new
		variable: (self variable copyInContext: aDictionary);
		value: (self value copyInContext: aDictionary);
		yourself
%

category: 'testing'
method: RBAssignmentNode
directlyUses: aNode 
	^aNode = value ifTrue: [true] ifFalse: [self isDirectlyUsed]
%

category: 'comparing'
method: RBAssignmentNode
equalTo: anObject withMapping: aDictionary 
	^self class = anObject class and: 
			[(self variable equalTo: anObject variable withMapping: aDictionary) 
				and: [self value equalTo: anObject value withMapping: aDictionary]]
%

category: 'comparing'
method: RBAssignmentNode
hash
	^self variable hash bitXor: self value hash
%

category: 'testing'
method: RBAssignmentNode
isAssignment
	^true
%

category: 'matching'
method: RBAssignmentNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^(variable match: aNode variable inContext: aDictionary)
		and: [value match: aNode value inContext: aDictionary]
%

category: 'testing'
method: RBAssignmentNode
needsParenthesis
	^parent isNil 
		ifTrue: [false]
		ifFalse: [self precedence > parent precedence]
%

category: 'copying'
method: RBAssignmentNode
postCopy
	super postCopy.
	self variable: self variable copy.
	self value: self value copy
%

category: 'accessing'
method: RBAssignmentNode
precedence
	^5
%

category: 'replacing'
method: RBAssignmentNode
replaceNode: aNode withNode: anotherNode 
	value == aNode ifTrue: [self value: anotherNode].
	variable == aNode ifTrue: [self variable: anotherNode]
%

category: 'replacing'
method: RBAssignmentNode
replaceSourceWith: aNode 
	"Check if we need to convert the assignment. Also check if we are being replaced with a setter message send. If so, create the replacements to edit the original source."

	(aNode isAssignment and: [ aNode assignmentOperator ~= self assignmentOperator ]) ifTrue: [
		self addReplacement: (RBStringReplacement 
			replaceFrom: self assignmentPosition
			to: self assignmentPosition + self assignmentOperator size - 1
			with: aNode assignmentOperator).
		(aNode variable = variable and: [ aNode value = value ])
			ifTrue: [ ^ self ] ].
	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].
	aNode receiver isVariable ifFalse: [^super replaceSourceWith: aNode].
	aNode numArgs = 1 ifFalse: [^super replaceSourceWith: aNode].
	(self mappingFor: self value) = aNode arguments first 
		ifFalse: [^super replaceSourceWith: aNode].
	(self value hasParentheses not 
		and: [aNode arguments first precedence >= aNode precedence]) 
			ifTrue: 
				[self
					addReplacement: (RBStringReplacement 
								replaceFrom: self value start
								to: self value start - 1
								with: '(');
					addReplacement: (RBStringReplacement 
								replaceFrom: self value stop + 1
								to: self value stop
								with: ')')].
	self addReplacement: (RBStringReplacement 
				replaceFrom: self variable start
				to: self assignmentPosition + 1
				with: aNode receiver name , ' ' , aNode selector)
%

category: 'accessing'
method: RBAssignmentNode
startWithoutParentheses
	^variable start
%

category: 'accessing'
method: RBAssignmentNode
stopWithoutParentheses
	^value stop
%

category: 'testing'
method: RBAssignmentNode
uses: aNode 
	^aNode = value ifTrue: [true] ifFalse: [self isUsed]
%

category: 'accessing'
method: RBAssignmentNode
value
	^value
%

category: 'accessing'
method: RBAssignmentNode
value: aValueNode 
	value := aValueNode.
	value parent: self
%

category: 'accessing'
method: RBAssignmentNode
variable
	^variable
%

category: 'accessing'
method: RBAssignmentNode
variable: varNode 
	variable := varNode.
	variable parent: self
%

category: 'initialize-release'
method: RBAssignmentNode
variable: aVariableNode value: aValueNode position: anInteger 
	self variable: aVariableNode.
	self value: aValueNode.
	assignment := anInteger
%

! Class implementation for 'RBBlockNode'

!		Class methods for 'RBBlockNode'

category: 'instance creation'
classmethod: RBBlockNode
arguments: argNodes body: sequenceNode 
	^(self new)
		arguments: argNodes;
		body: sequenceNode;
		yourself
%

category: 'instance creation'
classmethod: RBBlockNode
body: sequenceNode 
	^self arguments: #() body: sequenceNode
%

!		Instance methods for 'RBBlockNode'

category: 'comparing'
method: RBBlockNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	self body = anObject body ifFalse: [^false].
	self arguments size = anObject arguments size ifFalse: [^false].
	1 to: self arguments size
		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBBlockNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptBlockNode: self
%

category: 'accessing'
method: RBBlockNode
allArgumentVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allArgumentVariables;
		yourself
%

category: 'accessing'
method: RBBlockNode
allDefinedVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allDefinedVariables;
		yourself
%

category: 'accessing'
method: RBBlockNode
argumentNames
	^self arguments collect: [:each | each name]
%

category: 'accessing'
method: RBBlockNode
arguments
	^arguments
%

category: 'accessing'
method: RBBlockNode
arguments: argCollection 
	arguments := argCollection.
	arguments do: [:each | each parent: self]
%

category: 'accessing-token'
method: RBBlockNode
bar
	^ bar
%

category: 'accessing-token'
method: RBBlockNode
bar: anInteger
	bar := anInteger
%

category: 'accessing'
method: RBBlockNode
blockVariables
	| vars |
	vars := super blockVariables asOrderedCollection.
	vars addAll: self argumentNames.
	^vars
%

category: 'accessing'
method: RBBlockNode
body
	^body
%

category: 'accessing'
method: RBBlockNode
body: stmtsNode 
	body := stmtsNode.
	body parent: self
%

category: 'accessing'
method: RBBlockNode
children
	^self arguments copyWith: self body
%

category: 'accessing-token'
method: RBBlockNode
colons
	^ colons
%

category: 'accessing-token'
method: RBBlockNode
colons: anArray 
	colons := anArray
%

category: 'matching'
method: RBBlockNode
copyInContext: aDictionary 
	^ self class new
		arguments: (self copyList: self arguments inContext: aDictionary);
		body: (self body copyInContext: aDictionary);
		yourself
%

category: 'testing'
method: RBBlockNode
defines: aName 
	^arguments anySatisfy: [:each | each name = aName]
%

category: 'testing'
method: RBBlockNode
directlyUses: aNode 
	^false
%

category: 'comparing'
method: RBBlockNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self arguments size = anObject arguments size ifFalse: [^false].
	1 to: self arguments size
		do: 
			[:i | 
			((self arguments at: i) equalTo: (anObject arguments at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	(self body equalTo: anObject body withMapping: aDictionary)
		ifFalse: [^false].
	self arguments do: [:each | aDictionary removeKey: each name].
	^true
%

category: 'comparing'
method: RBBlockNode
hash
	^ (self hashForCollection: self arguments) bitXor: self body hash
%

category: 'testing'
method: RBBlockNode
isBlock
	^true
%

category: 'testing'
method: RBBlockNode
isImmediateNode
	^true
%

category: 'testing'
method: RBBlockNode
isLast: aNode 
	^body isLast: aNode
%

category: 'accessing-token'
method: RBBlockNode
left
	^ left
%

category: 'accessing-token'
method: RBBlockNode
left: anInteger
	left := anInteger
%

category: 'matching'
method: RBBlockNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^(self 
		matchList: arguments
		against: aNode arguments
		inContext: aDictionary) 
			and: [body match: aNode body inContext: aDictionary]
%

category: 'testing'
method: RBBlockNode
needsParenthesis
	^false
%

category: 'copying'
method: RBBlockNode
postCopy
	super postCopy.
	self arguments: (self arguments collect: [ :each | each copy ]).
	self body: self body copy
%

category: 'accessing'
method: RBBlockNode
precedence
	^0
%

category: 'testing'
method: RBBlockNode
references: aVariableName 
	^body references: aVariableName
%

category: 'replacing'
method: RBBlockNode
replaceNode: aNode withNode: anotherNode 
	body == aNode ifTrue: [self body: anotherNode].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'accessing-token'
method: RBBlockNode
right
	^ right
%

category: 'accessing-token'
method: RBBlockNode
right: anInteger
	right := anInteger
%

category: 'accessing'
method: RBBlockNode
startWithoutParentheses
	^left
%

category: 'accessing'
method: RBBlockNode
statementComments
	^self comments
%

category: 'accessing'
method: RBBlockNode
stopWithoutParentheses
	^right
%

category: 'testing'
method: RBBlockNode
uses: aNode 
	aNode = body ifFalse: [^false].
	^parent isMessage 
		ifTrue: 
			[(#(#ifTrue:ifFalse: #ifTrue: #ifFalse: #ifFalse:ifTrue:) 
				includes: parent selector) not 
				or: [parent isUsed]]
		ifFalse: [self isUsed]
%

! Class implementation for 'RBPatternBlockNode'

!		Instance methods for 'RBPatternBlockNode'

category: 'visitor'
method: RBPatternBlockNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptPatternBlockNode: self
%

category: 'matching'
method: RBPatternBlockNode
addArgumentWithNameBasedOn: aString to: aRBBlockNode 
	| name index vars |
	name := aString.
	vars := aRBBlockNode allDefinedVariables.
	index := 0.
	[vars includes: name] whileTrue: 
			[index := index + 1.
			name := name , index printString].
	aRBBlockNode 
		arguments: (aRBBlockNode arguments copyWith: (RBVariableNode named: name))
%

category: 'matching'
method: RBPatternBlockNode
constructLookupNodeFor: aString in: aRBBlockNode 
	| argumentNode |
	argumentNode := RBLiteralNode literalToken: (RBLiteralToken 
						value: aString
						start: nil
						stop: nil).
	^RBMessageNode 
		receiver: (RBVariableNode named: 'self')
		selector: #lookupMatchFor:in:
		arguments: (Array with: argumentNode with: aRBBlockNode arguments last)
%

category: 'matching'
method: RBPatternBlockNode
copyInContext: aDictionary 
	^ self replacingBlock value: aDictionary
%

category: 'matching'
method: RBPatternBlockNode
createBlockFor: aRBBlockNode
  | source |
  self replacePatternNodesIn: aRBBlockNode.
  source := aRBBlockNode formattedCode.
  ^ (source
    _compileInContext: self
    symbolList: GsSession currentSession symbolList
    oldLitVars: nil
    environmentId: 0) _executeInContext: self
%

category: 'matching'
method: RBPatternBlockNode
createMatchingBlock
	| newBlock |
	self arguments size > 2 
		ifTrue: 
			[self 
				error: 'Search blocks can only contain arguments for the node and matching dictionary'].
	newBlock := RBBlockNode arguments: arguments body: body.
	newBlock arguments isEmpty 
		ifTrue: [self addArgumentWithNameBasedOn: 'aNode' to: newBlock].
	newBlock arguments size = 1 
		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].
	^self createBlockFor: newBlock
%

category: 'matching'
method: RBPatternBlockNode
createReplacingBlock
	| newBlock |
	self arguments size > 1 
		ifTrue: 
			[self 
				error: 'Replace blocks can only contain an argument for the matching dictionary'].
	newBlock := RBBlockNode arguments: arguments body: body.
	self arguments isEmpty 
		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].
	^self createBlockFor: newBlock
%

category: 'matching'
method: RBPatternBlockNode
lookupMatchFor: aString in: aDictionary 
	^aDictionary at: aString
		ifAbsent: 
			[| variableNode |
			variableNode := RBPatternVariableNode named: aString.
			aDictionary at: variableNode ifAbsent: [nil]]
%

category: 'matching'
method: RBPatternBlockNode
match: aNode inContext: aDictionary 
	^self matchingBlock value: aNode value: aDictionary
%

category: 'matching'
method: RBPatternBlockNode
matchingBlock
	^valueBlock isNil 
		ifTrue: [valueBlock := self createMatchingBlock]
		ifFalse: [valueBlock]
%

category: 'matching'
method: RBPatternBlockNode
replacePatternNodesIn: aRBBlockNode 
	aRBBlockNode body nodesDo: 
			[:each | 
			(each isVariable and: [each isPatternNode]) 
				ifTrue: 
					[each 
						replaceWith: (self constructLookupNodeFor: each name in: aRBBlockNode)]]
%

category: 'matching'
method: RBPatternBlockNode
replacingBlock
	^valueBlock isNil 
		ifTrue: [valueBlock := self createReplacingBlock]
		ifFalse: [valueBlock]
%

category: 'accessing'
method: RBPatternBlockNode
sentMessages
	^ OrderedCollection new
%

! Class implementation for 'RBPatternWrapperBlockNode'

!		Instance methods for 'RBPatternWrapperBlockNode'

category: 'visitor'
method: RBPatternWrapperBlockNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptPatternWrapperBlockNode: self
%

category: 'matching'
method: RBPatternWrapperBlockNode
copyInContext: aDictionary 
	"I don't know what this would mean, so ignore it."

	^ wrappedNode copyInContext: aDictionary
%

category: 'matching'
method: RBPatternWrapperBlockNode
match: aNode inContext: aDictionary 
	(wrappedNode match: aNode inContext: aDictionary) ifFalse: [^false].
	^super match: aNode inContext: aDictionary
%

category: 'accessing'
method: RBPatternWrapperBlockNode
precedence
	^1
%

category: 'accessing'
method: RBPatternWrapperBlockNode
wrappedNode
	^wrappedNode
%

category: 'accessing'
method: RBPatternWrapperBlockNode
wrappedNode: aRBProgramNode 
	wrappedNode := aRBProgramNode.
	aRBProgramNode parent: self
%

! Class implementation for 'RBQueryBlockNode'

!		Instance methods for 'RBQueryBlockNode'

category: 'visitor'
method: RBQueryBlockNode
acceptVisitor: aProgramNodeVisitor
  ^ aProgramNodeVisitor acceptQueryBlockNode: self
%

! Class implementation for 'RBCascadeNode'

!		Class methods for 'RBCascadeNode'

category: 'instance creation'
classmethod: RBCascadeNode
messages: messageNodes 
	^self new messages: messageNodes
%

category: 'instance creation'
classmethod: RBCascadeNode
messages: messageNodes semicolons: integerCollection 
	^self new messages: messageNodes semicolons: integerCollection
%

!		Instance methods for 'RBCascadeNode'

category: 'comparing'
method: RBCascadeNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	self messages size = anObject messages size ifFalse: [^false].
	1 to: self messages size
		do: [:i | (self messages at: i) = (anObject messages at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBCascadeNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptCascadeNode: self
%

category: 'querying'
method: RBCascadeNode
bestNodeFor: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	messages 
		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].
	selectedChildren := (messages 
				collect: [:each | each bestNodeFor: anInterval]) 
					reject: [:each | each isNil].
	^selectedChildren detect: [:each | true] ifNone: [nil]
%

category: 'accessing'
method: RBCascadeNode
children
	^self messages
%

category: 'matching'
method: RBCascadeNode
copyInContext: aDictionary 
	^ self class new
		messages: (self copyList: self messages inContext: aDictionary);
		yourself
%

category: 'testing'
method: RBCascadeNode
directlyUses: aNode 
	^messages last = aNode and: [self isDirectlyUsed]
%

category: 'comparing'
method: RBCascadeNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self messages size = anObject messages size ifFalse: [^false].
	1 to: self messages size
		do: 
			[:i | 
			((self messages at: i) equalTo: (anObject messages at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true
%

category: 'comparing'
method: RBCascadeNode
hash
	^ self hashForCollection: self messages
%

category: 'testing'
method: RBCascadeNode
isCascade
	^true
%

category: 'matching'
method: RBCascadeNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^self 
		matchList: messages
		against: aNode messages
		inContext: aDictionary
%

category: 'accessing'
method: RBCascadeNode
messages
	^messages
%

category: 'accessing'
method: RBCascadeNode
messages: messageNodeCollection 
	messages := messageNodeCollection.
	messages do: [:each | each parent: self]
%

category: 'initialize-release'
method: RBCascadeNode
messages: messageNodes semicolons: integerCollection 
	self messages: messageNodes.
	semicolons := integerCollection
%

category: 'testing'
method: RBCascadeNode
needsParenthesis
	^parent isNil 
		ifTrue: [false]
		ifFalse: [self precedence > parent precedence]
%

category: 'copying'
method: RBCascadeNode
postCopy
	super postCopy.
	self messages: (self messages collect: [ :each | each copy ])
%

category: 'accessing'
method: RBCascadeNode
precedence
	^4
%

category: 'accessing'
method: RBCascadeNode
receiver
	^self messages first receiver
%

category: 'replacing'
method: RBCascadeNode
replaceNode: aNode withNode: anotherNode 
	self messages: (messages 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'accessing-token'
method: RBCascadeNode
semicolons
	^ semicolons
%

category: 'accessing-token'
method: RBCascadeNode
semicolons: anArray
	semicolons := anArray
%

category: 'accessing'
method: RBCascadeNode
startWithoutParentheses
	^messages first start
%

category: 'accessing'
method: RBCascadeNode
statementComments
	| statementComments |
	statementComments := OrderedCollection withAll: self comments.
	statementComments addAll: messages first receiver statementComments.
	messages do: 
			[:each | 
			each arguments 
				do: [:arg | statementComments addAll: arg statementComments]].
	^statementComments asSortedCollection: [:a :b | a first < b first]
%

category: 'accessing'
method: RBCascadeNode
stopWithoutParentheses
	^messages last stop
%

category: 'testing'
method: RBCascadeNode
uses: aNode 
	^messages last = aNode and: [self isUsed]
%

category: 'querying'
method: RBCascadeNode
whichNodeIsContainedBy: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	messages 
		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].
	selectedChildren := (messages 
				collect: [:each | each whichNodeIsContainedBy: anInterval]) 
					reject: [:each | each isNil].
	^selectedChildren detect: [:each | true] ifNone: [nil]
%

! Class implementation for 'RBLiteralNode'

!		Class methods for 'RBLiteralNode'

category: 'instance creation'
classmethod: RBLiteralNode
literalToken: aLiteralToken 
	^(aLiteralToken realValue class == Array 
		or: [aLiteralToken realValue class == ByteArray]) 
			ifTrue: 
				[RBLiteralArrayNode 
					startPosition: aLiteralToken start
					contents: (aLiteralToken value asArray 
							collect: [:each | RBLiteralNode literalToken: each])
					stopPosition: aLiteralToken stop
					isByteArray: aLiteralToken value class ~~ Array]
			ifFalse: [RBLiteralValueNode literalToken: aLiteralToken]
%

category: 'instance creation'
classmethod: RBLiteralNode
value: aValue 
	^((aValue class == Array or: [aValue class == ByteArray]) 
		ifTrue: [RBLiteralArrayNode]
		ifFalse: [RBLiteralValueNode]) value: aValue
%

!		Instance methods for 'RBLiteralNode'

category: 'comparing'
method: RBLiteralNode
= anObject 
	self == anObject ifTrue: [^true].
	^self class = anObject class
%

category: 'comparing'
method: RBLiteralNode
hash
	^self value hash
%

category: 'testing'
method: RBLiteralNode
isImmediateNode
	^true
%

category: 'testing'
method: RBLiteralNode
isLiteralNode
	^true
%

category: 'testing'
method: RBLiteralNode
needsParenthesis
	^false
%

category: 'accessing'
method: RBLiteralNode
precedence
	^0
%

category: 'private-replacing'
method: RBLiteralNode
replaceSourceFrom: aNode 
	self addReplacement: (RBStringReplacement 
				replaceFrom: aNode start
				to: aNode stop
				with: self formattedCode)
%

category: 'private-replacing'
method: RBLiteralNode
replaceSourceWith: aNode 
	self addReplacement: (RBStringReplacement 
				replaceFrom: self start
				to: self stop
				with: aNode formattedCode)
%

category: 'accessing'
method: RBLiteralNode
value
	^self subclassResponsibility
%

! Class implementation for 'RBLiteralArrayNode'

!		Class methods for 'RBLiteralArrayNode'

category: 'instance creation'
classmethod: RBLiteralArrayNode
startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 
	^(self new)
		startPosition: startInteger
			contents: anArray
			stopPosition: stopInteger
			isByteArray: aBoolean;
		yourself
%

category: 'instance creation'
classmethod: RBLiteralArrayNode
value: aValue 
	^(self new)
		startPosition: nil
			contents: (aValue asArray collect: [:each | RBLiteralNode value: each])
			stopPosition: nil
			isByteArray: aValue class ~~ Array;
		yourself
%

!		Instance methods for 'RBLiteralArrayNode'

category: 'comparing'
method: RBLiteralArrayNode
= anObject 
	super = anObject ifFalse: [^false].
	self isForByteArray = anObject isForByteArray ifFalse: [^false].
	self contents size = anObject contents size ifFalse: [^false].
	1 to: self contents size
		do: [:i | (self contents at: i) = (anObject contents at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBLiteralArrayNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptLiteralArrayNode: self
%

category: 'accessing'
method: RBLiteralArrayNode
children
	^contents
%

category: 'accessing'
method: RBLiteralArrayNode
contents
	^contents
%

category: 'initialize-release'
method: RBLiteralArrayNode
contents: aRBLiteralNodeCollection 
	contents := aRBLiteralNodeCollection.
	contents do: [:each | each parent: self]
%

category: 'matching'
method: RBLiteralArrayNode
copyInContext: aDictionary 
	^ self class 
		startPosition: nil
		contents: (self copyList: self contents inContext: aDictionary)
		stopPosition: nil
		isByteArray: isByteArray
%

category: 'comparing'
method: RBLiteralArrayNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self isForByteArray = anObject isForByteArray ifFalse: [^false].
	self contents size = anObject contents size ifFalse: [^false].
	1 to: self contents size
		do: 
			[:i | 
			((self contents at: i) equalTo: (anObject contents at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true
%

category: 'testing'
method: RBLiteralArrayNode
isForByteArray
	^isByteArray
%

category: 'testing'
method: RBLiteralArrayNode
isLiteralArray
	^true
%

category: 'matching'
method: RBLiteralArrayNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	self isForByteArray = aNode isForByteArray ifFalse: [^false].
	^self 
		matchList: contents
		against: aNode contents
		inContext: aDictionary
%

category: 'copying'
method: RBLiteralArrayNode
postCopy
	super postCopy.
	self contents: (self contents collect: [ :each | each copy ])
%

category: 'replacing'
method: RBLiteralArrayNode
replaceNode: aNode withNode: anotherNode 
	self contents: (contents 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'private-replacing'
method: RBLiteralArrayNode
replaceSourceWith: aNode 
	(self class = aNode class and: 
			[self isForByteArray = aNode isForByteArray 
				and: [self contents size = aNode contents size]]) 
		ifFalse: [^super replaceSourceWith: aNode].
	1 to: self contents size
		do: 
			[:i | 
			(self contents at: i) = (aNode contents at: i) 
				ifFalse: [(self contents at: i) replaceSourceWith: (aNode contents at: i)]]
%

category: 'initialize-release'
method: RBLiteralArrayNode
startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 
	start := startInteger.
	self contents: anArray.
	stop := stopInteger.
	isByteArray := aBoolean
%

category: 'accessing'
method: RBLiteralArrayNode
startWithoutParentheses
	^start
%

category: 'accessing'
method: RBLiteralArrayNode
stopWithoutParentheses
	^stop
%

category: 'accessing'
method: RBLiteralArrayNode
value
	| array |
	array := (isByteArray ifTrue: [ByteArray] ifFalse: [Array]) 
				new: contents size.
	1 to: contents size
		do: [:each | array at: each put: (contents at: each) value].
	^array
%

! Class implementation for 'RBLiteralValueNode'

!		Class methods for 'RBLiteralValueNode'

category: 'instance creation'
classmethod: RBLiteralValueNode
literalToken: aLiteralToken 
	^(self new)
		literalToken: aLiteralToken;
		yourself
%

category: 'instance creation'
classmethod: RBLiteralValueNode
value: aValue 
	^self literalToken: (RBLiteralToken value: aValue)
%

!		Instance methods for 'RBLiteralValueNode'

category: 'comparing'
method: RBLiteralValueNode
= anObject 
	^ super = anObject 
		and: [ self value = anObject value 
		and: [ self value species = anObject value species ] ]
%

category: 'visitor'
method: RBLiteralValueNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptLiteralNode: self
%

category: 'matching'
method: RBLiteralValueNode
copyInContext: aDictionary
	^ self class literalToken: self token copy removePositions
%

category: 'initialize-release'
method: RBLiteralValueNode
literalToken: aLiteralToken 
	token := aLiteralToken
%

category: 'accessing'
method: RBLiteralValueNode
startWithoutParentheses
	^token start
%

category: 'accessing'
method: RBLiteralValueNode
stopWithoutParentheses
	^token stop
%

category: 'accessing'
method: RBLiteralValueNode
token
	^token
%

category: 'accessing'
method: RBLiteralValueNode
value
	^token realValue
%

! Class implementation for 'RBMessageNode'

!		Class methods for 'RBMessageNode'

category: 'instance creation'
classmethod: RBMessageNode
receiver: aValueNode selector: aSymbol 
	^self 
		receiver: aValueNode
		selector: aSymbol
		arguments: #()
%

category: 'instance creation'
classmethod: RBMessageNode
receiver: aValueNode selector: aSymbol arguments: valueNodes 
	^(self new)
		receiver: aValueNode;
		arguments: valueNodes;
		selector: aSymbol;
		yourself
%

category: 'instance creation'
classmethod: RBMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	^(self new)
		receiver: aValueNode
			selectorParts: keywordTokens
			arguments: valueNodes;
		yourself
%

!		Instance methods for 'RBMessageNode'

category: 'comparing'
method: RBMessageNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	(self receiver = anObject receiver 
		and: [self selector = anObject selector]) ifFalse: [^false].
	1 to: self arguments size
		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBMessageNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptMessageNode: self
%

category: 'accessing'
method: RBMessageNode
arguments
	^arguments isNil ifTrue: [#()] ifFalse: [arguments]
%

category: 'accessing'
method: RBMessageNode
arguments: argCollection 
	arguments := argCollection.
	arguments do: [:each | each parent: self]
%

category: 'querying'
method: RBMessageNode
bestNodeFor: anInterval 
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	selectorParts do: 
			[:each | 
			((anInterval first between: each start and: each stop) 
				or: [each start between: anInterval first and: anInterval last]) 
					ifTrue: [^self]].
	self children do: 
			[:each | 
			| node |
			node := each bestNodeFor: anInterval.
			node notNil ifTrue: [^node]]
%

category: 'private'
method: RBMessageNode
buildSelector
	| selectorStream |
	selectorStream := WriteStreamPortable on: String new.
	selectorParts do: [ :each | selectorStream nextPutAll: each value ].
	^ selectorStream contents asSymbol
%

category: 'accessing'
method: RBMessageNode
children
	^(OrderedCollection with: self receiver)
		addAll: self arguments;
		yourself
%

category: 'matching'
method: RBMessageNode
copyInContext: aDictionary 
	^ self class new
		receiver: (self receiver copyInContext: aDictionary);
		selectorParts: (self selectorParts collect: [ :each | each copy removePositions ]);
		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);
		yourself
%

category: 'comparing'
method: RBMessageNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	((self receiver equalTo: anObject receiver withMapping: aDictionary)
		and: [self selector = anObject selector]) ifFalse: [^false].
	1 to: self arguments size
		do: 
			[:i | 
			((self arguments at: i) equalTo: (anObject arguments at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true
%

category: 'comparing'
method: RBMessageNode
hash
	^ (self receiver hash bitXor: self selector hash) bitXor: (self hashForCollection: self arguments)
%

category: 'testing'
method: RBMessageNode
isBinary
	^(self isUnary or: [self isKeyword]) not
%

category: 'testing'
method: RBMessageNode
isCascaded
	^parent notNil and: [parent isCascade]
%

category: 'private-replacing'
method: RBMessageNode
isContainmentReplacement: aNode 
	^(self mappingFor: self receiver) = aNode 
		or: [self arguments anySatisfy: [:each | (self mappingFor: each) = aNode]]
%

category: 'testing'
method: RBMessageNode
isFirstCascaded
	^self isCascaded and: [parent messages first == self]
%

category: 'testing'
method: RBMessageNode
isKeyword
	^selectorParts first value last = $:
%

category: 'testing'
method: RBMessageNode
isMessage
	^true
%

category: 'testing'
method: RBMessageNode
isSelfSend
	^ self receiver isVariable and: [ self receiver name = 'self' ]
%

category: 'testing'
method: RBMessageNode
isSuperSend
	^ self receiver isVariable and: [ self receiver name = 'super' ]
%

category: 'testing'
method: RBMessageNode
isUnary
	^arguments isEmpty
%

category: 'testing'
method: RBMessageNode
lastIsReturn
	^ (#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifNil:ifNotNil: #ifNotNil:ifNil:) includes: self selector)
		and: [ arguments first isBlock and: [ arguments first body lastIsReturn 
		and: [ arguments last isBlock and: [ arguments last body lastIsReturn ] ] ] ]
%

category: 'matching'
method: RBMessageNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	self selector = aNode selector ifFalse: [^false].
	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].
	1 to: arguments size
		do: 
			[:i | 
			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary)
				ifFalse: [^false]].
	^true
%

category: 'testing'
method: RBMessageNode
needsParenthesis
	^parent isNil 
		ifTrue: [false]
		ifFalse: 
			[self precedence > parent precedence 
				or: [self precedence = parent precedence and: [self isUnary not]]]
%

category: 'accessing'
method: RBMessageNode
numArgs
	^self selector numArgs
%

category: 'copying'
method: RBMessageNode
postCopy
	super postCopy.
	self receiver: self receiver copy.
	self arguments: (self arguments collect: [ :each | each copy ])
%

category: 'accessing'
method: RBMessageNode
precedence
	^self isUnary 
		ifTrue: [1]
		ifFalse: [self isKeyword ifTrue: [3] ifFalse: [2]]
%

category: 'accessing'
method: RBMessageNode
receiver
	^receiver
%

category: 'accessing'
method: RBMessageNode
receiver: aValueNode 
	receiver := aValueNode.
	receiver parent: self
%

category: 'initialize-release'
method: RBMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	self receiver: aValueNode.
	selectorParts := keywordTokens.
	self arguments: valueNodes
%

category: 'accessing'
method: RBMessageNode
renameSelector: newSelector andArguments: varNodeCollection 
	self
		arguments: varNodeCollection;
		selector: newSelector
%

category: 'private-replacing'
method: RBMessageNode
replaceContainmentSourceWith: aNode 
	| originalNode needsParenthesis |
	needsParenthesis := aNode hasParentheses not and: [aNode needsParenthesis].
	originalNode := (self mappingFor: self receiver) = aNode 
				ifTrue: [self receiver]
				ifFalse: [self arguments detect: [:each | (self mappingFor: each) = aNode]].
	self
		addReplacement: (RBStringReplacement 
					replaceFrom: self start
					to: originalNode start - 1
					with: (needsParenthesis ifTrue: ['('] ifFalse: ['']));
		addReplacement: (RBStringReplacement 
					replaceFrom: originalNode stop + 1
					to: self stop
					with: (needsParenthesis ifTrue: [')'] ifFalse: ['']))
%

category: 'replacing'
method: RBMessageNode
replaceNode: aNode withNode: anotherNode 
	"If we're inside a cascade node and are changing the receiver, change all the receivers"

	receiver == aNode 
		ifTrue: 
			[self receiver: anotherNode.
			(parent notNil and: [parent isCascade]) 
				ifTrue: [parent messages do: [:each | each receiver: anotherNode]]].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'private-replacing'
method: RBMessageNode
replaceSourceWith: aNode 
	(self isContainmentReplacement: aNode) 
		ifTrue: [^self replaceContainmentSourceWith: aNode].
	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].
	^self replaceSourceWithMessageNode: aNode
%

category: 'private-replacing'
method: RBMessageNode
replaceSourceWithMessageNode: aNode 
	| isBinaryToKeyword |
	self numArgs = aNode numArgs ifFalse: [^super replaceSourceWith: aNode].
	self arguments with: aNode arguments
		do: [:old :new | (self mappingFor: old) = new ifFalse: [^super replaceSourceWith: aNode]].
	(self mappingFor: self receiver) = aNode receiver 
		ifFalse:
			[(self receiver isVariable and: [aNode receiver isVariable])
				ifFalse:
					[^super replaceSourceWith: aNode].
			self addReplacement:
				(RBStringReplacement
					replaceFrom: self receiver start
					to: self receiver stop
					with: aNode receiver name)].
	(isBinaryToKeyword := self isBinary and: [aNode isKeyword]) 
		ifTrue: 
			[(self hasParentheses not and: [self parent precedence <= aNode precedence]) 
				ifTrue: 
					[self
						addReplacement: (RBStringReplacement 
									replaceFrom: self start
									to: self start - 1
									with: '(');
						addReplacement: (RBStringReplacement 
									replaceFrom: self stop + 1
									to: self stop
									with: ')')]].
	self selectorParts with: aNode selectorParts
		do: 
			[:old :new | 
			old value ~= new value 
				ifTrue: 
					[self addReplacement: (RBStringReplacement 
								replaceFrom: old start
								to: old stop
								with: ((isBinaryToKeyword 
										and: [(self source at: old start - 1) isSqueakSeparator not]) 
											ifTrue: [' ' , new value]
											ifFalse: [new value]))]]
%

category: 'accessing'
method: RBMessageNode
selector
	^selector isNil
		ifTrue: [selector := self buildSelector]
		ifFalse: [selector]
%

category: 'accessing'
method: RBMessageNode
selector: aSelector 
	| keywords numArgs |
	keywords := aSelector keywords.
	numArgs := aSelector numArgs.
	numArgs == arguments size 
		ifFalse: 
			[self 
				error: 'Attempting to assign selector with wrong number of arguments.'].
	selectorParts := numArgs == 0 
				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]
				ifFalse: 
					[keywords first last = $: 
						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]
						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].
	selector := aSelector asSymbol
%

category: 'private'
method: RBMessageNode
selectorParts
	^ selectorParts
%

category: 'private'
method: RBMessageNode
selectorParts: tokenCollection 
	selectorParts := tokenCollection
%

category: 'accessing'
method: RBMessageNode
sentMessages
	^ super sentMessages
		add: self selector;
		yourself
%

category: 'accessing'
method: RBMessageNode
startWithoutParentheses
	^receiver start
%

category: 'accessing'
method: RBMessageNode
stopWithoutParentheses
	^arguments isEmpty 
		ifTrue: [selectorParts first stop]
		ifFalse: [arguments last stop]
%

! Class implementation for 'RBPatternMessageNode'

!		Class methods for 'RBPatternMessageNode'

category: 'instance creation'
classmethod: RBPatternMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	^(keywordTokens anySatisfy: [:each | each isPatternVariable]) 
		ifTrue: 
			[super 
				receiver: aValueNode
				selectorParts: keywordTokens
				arguments: valueNodes]
		ifFalse: 
			[RBMessageNode 
				receiver: aValueNode
				selectorParts: keywordTokens
				arguments: valueNodes]
%

!		Instance methods for 'RBPatternMessageNode'

category: 'matching'
method: RBPatternMessageNode
copyInContext: aDictionary 
	| selectors |
	self isList 
		ifTrue: [ ^ aDictionary at: self ].
	selectors := self isSelectorList 
		ifTrue: [ (aDictionary at: selectorParts first value) keywords ]
		ifFalse: [ self selectorParts collect: [ :each | aDictionary at: each value ] ].
	^ RBMessageNode new
		receiver: (self receiver copyInContext: aDictionary);
		selectorParts: (selectors collect: [ :each | 
			(each last = $: ifTrue: [ RBKeywordToken ] ifFalse: [ RBIdentifierToken ]) 
				value: each start: nil ]);
		arguments: (self copyList: self arguments inContext: aDictionary);
		yourself
%

category: 'testing-matching'
method: RBPatternMessageNode
isList
	^isCascadeList and: [parent notNil and: [parent isCascade]]
%

category: 'testing-matching'
method: RBPatternMessageNode
isPatternNode
	^true
%

category: 'testing-matching'
method: RBPatternMessageNode
isSelectorList
	^isList
%

category: 'matching'
method: RBPatternMessageNode
match: aNode inContext: aDictionary 
	aNode class == self matchingClass ifFalse: [^false].
	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].
	self isSelectorList 
		ifTrue: 
			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector]) 
				== aNode selector and: 
						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments]) 
							= aNode arguments]].
	^self matchArgumentsAgainst: aNode inContext: aDictionary
%

category: 'matching'
method: RBPatternMessageNode
matchArgumentsAgainst: aNode inContext: aDictionary 
	self arguments size = aNode arguments size
		ifFalse: [ ^ false ].
	(self matchSelectorAgainst: aNode inContext: aDictionary) 
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'private'
method: RBPatternMessageNode
matchingClass
	^RBMessageNode
%

category: 'matching'
method: RBPatternMessageNode
matchSelectorAgainst: aNode inContext: aDictionary 
	self selectorParts with: aNode selectorParts do: [ :first :second |
		| keyword |
		keyword := aDictionary
			at: first value
			ifAbsentPut: [ 
				first isPatternVariable 
					ifTrue: [ second value ]
					ifFalse: [ first value ] ].
		keyword = second value 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'initialize-release'
method: RBPatternMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	| message |
	super 
		receiver: aValueNode
		selectorParts: keywordTokens
		arguments: valueNodes.
	isCascadeList := isList := false.
	message := keywordTokens first value.
	2 to: message size
		do: 
			[:i | 
			| character |
			character := message at: i.
			character == self listCharacter 
				ifTrue: [isList := true]
				ifFalse: 
					[character == self cascadeListCharacter 
						ifTrue: [isCascadeList := true]
						ifFalse: [^self]]]
%

category: 'accessing'
method: RBPatternMessageNode
sentMessages
	^ super sentMessages
		remove: self selector ifAbsent: [ ];
		yourself
%

! Class implementation for 'RBVariableNode'

!		Class methods for 'RBVariableNode'

category: 'instance creation'
classmethod: RBVariableNode
identifierToken: anIdentifierToken 
	^(self new)
		identifierToken: anIdentifierToken;
		yourself
%

category: 'instance creation'
classmethod: RBVariableNode
named: aString 
	^self identifierToken: (RBIdentifierToken value: aString start: 0)
%

!		Instance methods for 'RBVariableNode'

category: 'comparing'
method: RBVariableNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	^self name = anObject name
%

category: 'visitor'
method: RBVariableNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptVariableNode: self
%

category: 'matching'
method: RBVariableNode
copyInContext: aDictionary 
	^ self class identifierToken: token copy removePositions
%

category: 'comparing'
method: RBVariableNode
equalTo: anObject withMapping: aDictionary 
	^self class = anObject class and: 
			[(aDictionary at: self name ifAbsentPut: [anObject name]) = anObject name]
%

category: 'comparing'
method: RBVariableNode
hash
	^self name hash
%

category: 'initialize-release'
method: RBVariableNode
identifierToken: anIdentifierToken 
	token := anIdentifierToken
%

category: 'testing'
method: RBVariableNode
isImmediateNode
	^true
%

category: 'testing'
method: RBVariableNode
isRead
	^ self isWrite not and: [ self isUsed ]
%

category: 'testing'
method: RBVariableNode
isVariable
	^true
%

category: 'testing'
method: RBVariableNode
isWrite
	^ self parent notNil and: [ self parent isAssignment and: [ self parent variable == self ] ]
%

category: 'accessing'
method: RBVariableNode
name
	^token value
%

category: 'testing'
method: RBVariableNode
needsParenthesis
	^false
%

category: 'accessing'
method: RBVariableNode
precedence
	^0
%

category: 'testing'
method: RBVariableNode
references: aVariableName 
	^self name = aVariableName
%

category: 'replacing'
method: RBVariableNode
replaceSourceFrom: aNode 
	self addReplacement: (RBStringReplacement 
				replaceFrom: aNode start
				to: aNode stop
				with: self name)
%

category: 'replacing'
method: RBVariableNode
replaceSourceWith: aNode
	self addReplacement: (RBStringReplacement 
				replaceFrom: self start
				to: self stop
				with: aNode formattedCode)
%

category: 'accessing'
method: RBVariableNode
startWithoutParentheses
	^token start
%

category: 'accessing'
method: RBVariableNode
stopWithoutParentheses
	^token stop
%

category: 'accessing'
method: RBVariableNode
token
	^ token
%

! Class implementation for 'RBPatternVariableNode'

!		Class methods for 'RBPatternVariableNode'

category: 'instance creation'
classmethod: RBPatternVariableNode
identifierToken: anIdentifierToken 
	^anIdentifierToken isPatternVariable 
		ifTrue: [super identifierToken: anIdentifierToken]
		ifFalse: [RBVariableNode identifierToken: anIdentifierToken]
%

!		Instance methods for 'RBPatternVariableNode'

category: 'matching'
method: RBPatternVariableNode
copyInContext: aDictionary 
	^ (aDictionary at: self) copy
%

category: 'initialize-release'
method: RBPatternVariableNode
identifierToken: anIdentifierToken 
	super identifierToken: anIdentifierToken.
	self initializePatternVariables
%

category: 'initialize-release'
method: RBPatternVariableNode
initializePatternVariables
	| name |
	name := self name.
	isAnything := isList := isLiteral := isStatement := recurseInto := false.
	2 to: name size
		do: 
			[:i | 
			| character |
			character := name at: i.
			character == self listCharacter 
				ifTrue: [isAnything := isList := true]
				ifFalse: 
					[character == self literalCharacter 
						ifTrue: [isLiteral := true]
						ifFalse: 
							[character == self statementCharacter 
								ifTrue: [isStatement := true]
								ifFalse: 
									[character == self recurseIntoCharacter 
										ifTrue: [recurseInto := true]
										ifFalse: [^self]]]]]
%

category: 'testing-matching'
method: RBPatternVariableNode
isAnything
	^isAnything
%

category: 'testing-matching'
method: RBPatternVariableNode
isList
	^isList
%

category: 'testing-matching'
method: RBPatternVariableNode
isLiteralNode
	^isLiteral
%

category: 'testing-matching'
method: RBPatternVariableNode
isPatternNode
	^true
%

category: 'testing-matching'
method: RBPatternVariableNode
isStatement
	^isStatement
%

category: 'matching'
method: RBPatternVariableNode
match: aNode inContext: aDictionary 
	self isAnything 
		ifTrue: [^(aDictionary at: self ifAbsentPut: [aNode]) = aNode].
	self isLiteralNode ifTrue: [^self matchLiteral: aNode inContext: aDictionary].
	self isStatement 
		ifTrue: [^self matchStatement: aNode inContext: aDictionary].
	aNode class == self matchingClass ifFalse: [^false].
	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode
%

category: 'private'
method: RBPatternVariableNode
matchingClass
	^RBVariableNode
%

category: 'matching'
method: RBPatternVariableNode
matchLiteral: aNode inContext: aDictionary 
	^aNode isLiteralNode
		and: [(aDictionary at: self ifAbsentPut: [aNode]) = aNode]
%

category: 'matching'
method: RBPatternVariableNode
matchStatement: aNode inContext: aDictionary 
	(aNode parent notNil and: [aNode parent isSequence]) ifFalse: [^false].
	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode
%

category: 'accessing'
method: RBPatternVariableNode
parent: aBRProgramNode 
	"Fix the case where '``@node' should match a single node, not a sequence node."

	super parent: aBRProgramNode.
	parent isSequence 
		ifTrue: 
			[(self isStatement or: [parent temporaries includes: self]) 
				ifFalse: [isList := false]]
%

category: 'testing-matching'
method: RBPatternVariableNode
recurseInto
	^recurseInto
%

! Class implementation for 'RBProgramNodeVisitor'

!		Class methods for 'RBProgramNodeVisitor'

category: 'instance creation'
classmethod: RBProgramNodeVisitor
new

	^self basicNew initialize
%

!		Instance methods for 'RBProgramNodeVisitor'

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptArrayNode: anArrayNode 
	anArrayNode children do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptAssignmentNode: anAssignmentNode 
	self visitNode: anAssignmentNode variable.
	self visitNode: anAssignmentNode value
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptBlockNode: aBlockNode 
	self visitArguments: aBlockNode arguments.
	self visitNode: aBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptCascadeNode: aCascadeNode 
	aCascadeNode messages do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptLiteralArrayNode: aRBLiteralArrayNode 
	aRBLiteralArrayNode contents do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptLiteralNode: aLiteralNode
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptMessageNode: aMessageNode 
	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 
		ifTrue: [self visitNode: aMessageNode receiver].
	aMessageNode arguments do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptMethodNode: aMethodNode 
	self visitArguments: aMethodNode arguments.
	aMethodNode pragmas
		do: [ :each | self visitNode: each ].
	self visitNode: aMethodNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptPatternBlockNode: aRBPatternBlockNode 
	self visitArguments: aRBPatternBlockNode arguments.
	self visitNode: aRBPatternBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	self visitArguments: aRBPatternWrapperBlockNode arguments.
	self visitNode: aRBPatternWrapperBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptPragmaNode: aPragmaNode
	aPragmaNode arguments do: [ :each | self visitNode: each ]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptQueryBlockNode: aBlockNode
  self visitArguments: aBlockNode arguments.
  self visitNode: aBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptReturnNode: aReturnNode 
	self visitNode: aReturnNode value
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptSequenceNode: aSequenceNode 
	self visitArguments: aSequenceNode temporaries.
	aSequenceNode statements do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptVariableNode: aVariableNode
%

category: 'initialize release'
method: RBProgramNodeVisitor
initialize
%

category: 'visiting'
method: RBProgramNodeVisitor
visitArgument: each 
	"Here to allow subclasses to detect arguments or temporaries."

	^self visitNode: each
%

category: 'visiting'
method: RBProgramNodeVisitor
visitArguments: aNodeCollection 
	^aNodeCollection do: [:each | self visitArgument: each]
%

category: 'visiting'
method: RBProgramNodeVisitor
visitNode: aNode 
	^aNode acceptVisitor: self
%

! Class implementation for 'RBConfigurableFormatter'

!		Class methods for 'RBConfigurableFormatter'

category: 'accessing'
classmethod: RBConfigurableFormatter
cascadedMessageInsideParentheses
	^ CascadedMessageInsideParentheses
%

category: 'accessing'
classmethod: RBConfigurableFormatter
cascadedMessageInsideParentheses: aBoolean
	CascadedMessageInsideParentheses := aBoolean
%

category: 'public'
classmethod: RBConfigurableFormatter
format: aParseTree 
	^self format: aParseTree withIndents: 0
%

category: 'public'
classmethod: RBConfigurableFormatter
format: aParseTree withIndents: anInteger 
	^ self new
		indent: anInteger;
		format: aParseTree
%

category: 'accessing'
classmethod: RBConfigurableFormatter
formatCommentWithStatements
	^ FormatCommentWithStatements
%

category: 'accessing'
classmethod: RBConfigurableFormatter
formatCommentWithStatements: aBoolean
	FormatCommentWithStatements := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentsForKeywords
	^ IndentsForKeywords
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentsForKeywords: anInteger
	IndentsForKeywords := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentString
	^ IndentString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentString: aString
	IndentString := aString
%

category: 'initialization'
classmethod: RBConfigurableFormatter
initialize
  InQueryBlock := false.
  CascadedMessageInsideParentheses := false.
  FormatCommentWithStatements := true.
  IndentString := '	'.
  IndentsForKeywords := 1.
  KeepBlockInMessage := true.
  LineUpBlockBrackets := false.
  MaxLineLength := 80.
  MethodSignatureOnMultipleLines := false.
  MinimumNewLinesBetweenStatements := 1.
  MultiLineMessages := #(#'ifTrue:ifFalse:' #'ifFalse:ifTrue:' #'ifTrue:' #'ifFalse:' #'on:do:' #'ensure:' #'ifCurtailed:').
  NewLineAfterCascade := true.
  NewLineBeforeFirstCascade := true.
  NewLineBeforeFirstKeyword := false.
  NewLinesAfterMethodComment := 2.
  NewLinesAfterMethodPattern := 1.
  NewLinesAfterTemporaries := 1.
  NumberOfArgumentsForMultiLine := 4.
  OneLineMessages := #(#'to:' #'to:do:' #'to:by:' #'to:by:do:').
  PeriodsAtEndOfBlock := false.
  PeriodsAtEndOfMethod := false.
  RetainBlankLinesBetweenStatements := true.
  StringFollowingReturn := ' '.
  StringInsideBlocks := ' '.
  StringInsideParentheses := ''.
  TraditionalBinaryPrecedence := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).
  UseTraditionalBinaryPrecedenceForParentheses := true
%

category: 'accessing'
classmethod: RBConfigurableFormatter
keepBlockInMessage
	^ KeepBlockInMessage
%

category: 'accessing'
classmethod: RBConfigurableFormatter
keepBlockInMessage: aBoolean
	KeepBlockInMessage := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
lineUpBlockBrackets
	^ LineUpBlockBrackets
%

category: 'accessing'
classmethod: RBConfigurableFormatter
lineUpBlockBrackets: aBoolean
	LineUpBlockBrackets := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
maxLineLength
	^ MaxLineLength
%

category: 'accessing'
classmethod: RBConfigurableFormatter
maxLineLength: anInteger
	MaxLineLength := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
methodSignatureOnMultipleLines
	^ MethodSignatureOnMultipleLines
%

category: 'accessing'
classmethod: RBConfigurableFormatter
methodSignatureOnMultipleLines: aBoolean
	MethodSignatureOnMultipleLines := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
minimumNewLinesBetweenStatements
	^ MinimumNewLinesBetweenStatements
%

category: 'accessing'
classmethod: RBConfigurableFormatter
minimumNewLinesBetweenStatements: anInteger
	MinimumNewLinesBetweenStatements := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineAfterCascade
	^ NewLineAfterCascade
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineAfterCascade: aBoolean
	NewLineAfterCascade := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstCascade
	^ NewLineBeforeFirstCascade
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstCascade: aBoolean
	NewLineBeforeFirstCascade := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstKeyword
	^ NewLineBeforeFirstKeyword
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstKeyword: aBoolean
	NewLineBeforeFirstKeyword := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodComment
	^ NewLinesAfterMethodComment
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodComment: anInteger
	NewLinesAfterMethodComment := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodPattern
	^ NewLinesAfterMethodPattern
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodPattern: anInteger
	NewLinesAfterMethodPattern := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterTemporaries
	^ NewLinesAfterTemporaries
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterTemporaries: anInteger
	NewLinesAfterTemporaries := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
numberOfArgumentsForMultiLine
	^ NumberOfArgumentsForMultiLine
%

category: 'accessing'
classmethod: RBConfigurableFormatter
numberOfArgumentsForMultiLine: anInteger
	NumberOfArgumentsForMultiLine := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAsTerminators
	^ PeriodsAtEndOfBlock and: [ PeriodsAtEndOfMethod ]
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAsTerminators: aBoolean
	PeriodsAtEndOfBlock := aBoolean.
	PeriodsAtEndOfMethod := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfBlock
	^ PeriodsAtEndOfBlock
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfBlock: aBoolean
	PeriodsAtEndOfBlock := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfMethod
	^ PeriodsAtEndOfMethod
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfMethod: aBoolean
	PeriodsAtEndOfMethod := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
retainBlankLinesBetweenStatements
	^ RetainBlankLinesBetweenStatements
%

category: 'accessing'
classmethod: RBConfigurableFormatter
retainBlankLinesBetweenStatements: aBoolean
	RetainBlankLinesBetweenStatements := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringFollowingReturn
	^ StringFollowingReturn
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringFollowingReturn: aString
	StringFollowingReturn := aString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideBlocks
	^ StringInsideBlocks
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideBlocks: aString
	StringInsideBlocks := aString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideParentheses
	^ StringInsideParentheses
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideParentheses: aString
	StringInsideParentheses := aString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
useTraditionalBinaryPrecedenceForParentheses
	^ UseTraditionalBinaryPrecedenceForParentheses
%

category: 'accessing'
classmethod: RBConfigurableFormatter
useTraditionalBinaryPrecedenceForParentheses: aBoolean
	UseTraditionalBinaryPrecedenceForParentheses := aBoolean
%

!		Instance methods for 'RBConfigurableFormatter'

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptArrayNode: anArrayNode
	self bracketWith: '{}' around: [ self formatArray: anArrayNode ]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptAssignmentNode: anAssignmentNode 
	self visitNode: anAssignmentNode variable.
	codeStream space; nextPutAll: anAssignmentNode assignmentOperator; space.
	self visitNode: anAssignmentNode value
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptBlockNode: aBlockNode
	self bracketWith: '[]' around: [self formatBlock: aBlockNode]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptCascadeNode: aCascadeNode 
	self visitNode: aCascadeNode receiver.
	self indentAround: 
			[NewLineBeforeFirstCascade ifTrue: [self newLine] ifFalse: [self space].
			aCascadeNode messages do: 
					[:each | 
					self indentAround: 
							[self 
								formatSelectorAndArguments: each
								firstSeparator: []
								restSeparator: ((self isMultiLineMessage: each) 
										ifTrue: [[self newLine]]
										ifFalse: [[self space]])]]
				separatedBy: 
					[codeStream nextPut: $;.
					NewLineAfterCascade ifTrue: [self newLine] ifFalse: [self space]]]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptLiteralArrayNode: aRBArrayLiteralNode 
	| brackets |
	codeStream nextPut: $#.
	brackets := aRBArrayLiteralNode isForByteArray 
				ifTrue: ['[]']
				ifFalse: ['()'].
	self bracketWith: brackets
		around: 
			[aRBArrayLiteralNode contents do: [:each | self visitNode: each]
				separatedBy: [self space]]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptLiteralNode: aLiteralNode 
	self writeString: aLiteralNode token rbStoreString
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptMessageNode: aMessageNode 
	self visitNode: aMessageNode receiver.
	self formatSelectorAndArguments: aMessageNode
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptMethodNode: aMethodNode 
	self formatMethodPatternFor: aMethodNode.
	self formatMethodBodyFor: aMethodNode
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptPatternBlockNode: aRBPatternBlockNode 
	codeStream nextPut: $`.
	self 
		bracketWith: '{}' 
		around: [self formatBlock: aRBPatternBlockNode]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	codeStream nextPut: $`.
	self 
		bracketWith: '{}' 
		around: [self formatBlock: aRBPatternWrapperBlockNode]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptPragmaNode: aPragmaNode
  codeStream nextPut: $<.
  aPragmaNode isProtected
    ifTrue: [ codeStream nextPutAll: 'protected ' ].
  self
    formatSelectorAndArguments: aPragmaNode
    firstSeparator: [ 
      aPragmaNode selector isInfix
        ifTrue: [ self space ] ]
    restSeparator: [ self space ].
  codeStream nextPut: $>
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptQueryBlockNode: aBlockNode
  self
    bracketWith: '{}'
    around: [ 
      [ 
      "query blocks are not nested"
      InQueryBlock := true.
      self formatBlock: aBlockNode ]
        ensure: [ InQueryBlock := false ] ]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptReturnNode: aReturnNode 
	codeStream
		nextPut: $^;
		nextPutAll: StringFollowingReturn.
	self visitNode: aReturnNode value
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptSequenceNode: aSequenceNode 
	self formatTemporariesFor: aSequenceNode.
	self formatSequenceCommentsFor: aSequenceNode.
	self formatSequenceNodeStatementsFor: aSequenceNode
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptVariableNode: aVariableNode 
	codeStream nextPutAll: aVariableNode name
%

category: 'private'
method: RBConfigurableFormatter
addNewLinesBeforeStatementStartingAt: anInteger 
	| newLines |
	newLines := MinimumNewLinesBetweenStatements 
				max: (RetainBlankLinesBetweenStatements 
						ifTrue: [self newLinesBeforeStartingAt: anInteger]
						ifFalse: [0]).
	newLines = 0 ifTrue: [self space] ifFalse: [self newLines: newLines]
%

category: 'private'
method: RBConfigurableFormatter
bracketWith: bracketString around: aBlock 
	bracketString isEmpty ifTrue: [^aBlock value].
	codeStream nextPut: bracketString first.
	^aBlock ensure: [codeStream nextPut: bracketString last]
%

category: 'private'
method: RBConfigurableFormatter
currentLineLength
	^codeStream position - lineStart
%

category: 'public interface'
method: RBConfigurableFormatter
format: aParseTree 
	originalSource := aParseTree source.
	self visitNode: aParseTree.
	^codeStream contents
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatArray: anArrayNode
	self formatSequenceCommentsFor: anArrayNode.
	self formatSequenceNodeStatementsFor: anArrayNode
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatBlock: aBlockNode
	(LineUpBlockBrackets and: [ self willBeMultiline: aBlockNode body ])
		ifTrue: [ self newLine ]
		ifFalse: [ codeStream nextPutAll: StringInsideBlocks ].
	self formatBlockArgumentsFor: aBlockNode.
	(self willBeMultiline: aBlockNode body)
		ifTrue: [ self newLine ].
	self visitNode: aBlockNode body.
	(LineUpBlockBrackets and: [ self willBeMultiline: aBlockNode body ])
		ifTrue: [ self newLine ]
		ifFalse: [ codeStream nextPutAll: StringInsideBlocks ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatBlockArgumentsFor: aBlockNode
	aBlockNode arguments isEmpty
		ifTrue: [ ^ self ].
	aBlockNode arguments
		do: [ :each | 
			codeStream nextPut: $:.
			self visitNode: each.
			FormatCommentWithStatements
				ifTrue: [ self formatCommentsFor: each ].
			self space ].
	codeStream nextPutAll: '| '
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatCommentsFor: aNode 
	originalSource isNil ifTrue: [^self].
	aNode comments do: 
			[:each | 
			codeStream
				space;
				nextPutAll: (originalSource copyFrom: each first to: each last)]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatMethodBodyFor: aMethodNode 
	self
		indentAround: 
			[self newLines: NewLinesAfterMethodPattern.
			self formatMethodCommentFor: aMethodNode.
			self formatPragmasFor: aMethodNode.
			self visitNode: aMethodNode body]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatMethodCommentFor: aMethodNode
	originalSource isNil ifTrue: [^self].
	(FormatCommentWithStatements
		ifTrue: [aMethodNode methodComments]
		ifFalse: [aMethodNode comments])
		do:
			[:each | 
			codeStream
				nextPutAll:
					(originalSource
						copyFrom: each first
						to: each last).
			self newLines: NewLinesAfterMethodComment]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatMethodPatternFor: aMethodNode 
	aMethodNode arguments isEmpty
		ifTrue: [codeStream nextPutAll: aMethodNode selector]
		ifFalse: 
			[self
				with: aMethodNode selectorParts
				and: aMethodNode arguments
				do: 
					[:key :arg | 
					codeStream nextPutAll: key value.
					self space.
					self visitNode: arg]
				separatedBy: 
					[MethodSignatureOnMultipleLines
						ifTrue: [self newLine]
						ifFalse: [self space]]]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatPragmasFor: aMethodNode
	aMethodNode pragmas do: [ :each | self visitNode: each; newLine ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSelectorAndArguments: aMessageNode
	| newLineBetweenArguments |
	newLineBetweenArguments := self isMultiLineMessage: aMessageNode.
	self
		indent:
			(newLineBetweenArguments
				ifTrue: [ IndentsForKeywords ]
				ifFalse: [ 0 ])
		around: [ 
			self
				formatSelectorAndArguments: aMessageNode
				firstSeparator:
					((newLineBetweenArguments or: [ NewLineBeforeFirstKeyword ])
						ifTrue: [ [ self newLine ] ]
						ifFalse: [ [ self space ] ])
				restSeparator:
					(newLineBetweenArguments
						ifTrue: [ [ self newLine ] ]
						ifFalse: [ [ self space ] ]) ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSelectorAndArguments: aMessageNode firstSeparator: firstBlock restSeparator: restBlock
	| separatorBlock |
	separatorBlock := firstBlock.
	aMessageNode isUnary
		ifTrue: [ 
			(self isLineTooLong: aMessageNode selector)
				ifTrue: [ self newLine ]
				ifFalse: [ separatorBlock value ].
			codeStream nextPutAll: aMessageNode selector ]
		ifFalse: [ 
			aMessageNode selectorParts
				with: aMessageNode arguments
				do: [ :selector :argument | 
					(self isLineTooLong: selector value)
						ifTrue: [ self newLine ]
						ifFalse: [ separatorBlock value ].
					separatorBlock := restBlock.
					self
						indentAround: [ 
							codeStream nextPutAll: selector value.
							(KeepBlockInMessage and: [ argument isBlock ])
								ifTrue: [ 
									self
										space;
										visitNode: argument ]
								ifFalse: [ 
									((self willBeMultiline: argument) or: [ self isLineTooLong: (self formattedSourceFor: argument) ])
										ifTrue: [ self newLine ]
										ifFalse: [ self space ].
									self visitNode: argument ] ] ] ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSequenceCommentsFor: aSequenceNode
	originalSource isNil ifTrue: [^self].
	aSequenceNode comments
		do:
			[:each | 
			codeStream
				nextPutAll:
					(originalSource
						copyFrom: each first
						to: each last).
			self newLine]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSequenceNodeStatementsFor: aSequenceNode 
	| statements |
	statements := aSequenceNode statements.
	statements isEmpty ifTrue: [^self].
	1 to: statements size
		do: 
			[:i | 
			self visitNode: (statements at: i).
			(i < statements size or: 
					[| parent |
					(parent := aSequenceNode parent) ifNil: [self class periodsAsTerminators]
						ifNotNil: 
							[ 
							parent isBlock 
								ifTrue: [self class periodsAtEndOfBlock]
								ifFalse: [self class periodsAtEndOfMethod]]]) 
				ifTrue: [codeStream nextPut: $.].
			self formatStatementCommentsFor: (statements at: i).
			i < statements size 
				ifTrue: 
					[self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start]]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatStatementCommentsFor: aStatementNode
	originalSource isNil ifTrue: [^self].
	FormatCommentWithStatements ifFalse: [^self].
	aStatementNode statementComments
		do:
			[:each | 
			codeStream
				tab;
				nextPutAll:
						(originalSource
								copyFrom: each first
								to: each last)]
%

category: 'private'
method: RBConfigurableFormatter
formattedSourceFor: aNode 
	^lookaheadCode at: aNode
		ifAbsentPut: [self class format: aNode withIndents: indent]
%

category: 'private'
method: RBConfigurableFormatter
formatTemporariesFor: aSequenceNode
	aSequenceNode temporaries isEmpty ifTrue: [^self].
	self
		bracketWith: '|'
		around:
			[self space.
			aSequenceNode temporaries
				do:
					[:each | 
					self visitNode: each.
					FormatCommentWithStatements ifTrue: [self formatCommentsFor: each].
					self space]].
	self newLines: NewLinesAfterTemporaries
%

category: 'initialize-release'
method: RBConfigurableFormatter
indent: anInteger
	indent := anInteger
%

category: 'private'
method: RBConfigurableFormatter
indent: anInteger around: aBlock 
	indent := indent + anInteger.
	^aBlock ensure: [indent := indent - anInteger]
%

category: 'private'
method: RBConfigurableFormatter
indentAround: aBlock 
	self indent: 1 around: aBlock
%

category: 'initialize-release'
method: RBConfigurableFormatter
initialize
	super initialize.
	lineStart := 0.
	indent := 0.
	lookaheadCode := IdentityDictionary new.
	codeStream := WriteStreamPortable on: String new
%

category: 'private'
method: RBConfigurableFormatter
isLineTooLong: aString 
	^ self currentLineLength + (aString indexOf: Character lf ifAbsent: [ aString size ]) >= MaxLineLength
%

category: 'private-formatting'
method: RBConfigurableFormatter
isMultiLineMessage: aMessageNode
	| messageStream |
	(MultiLineMessages includes: aMessageNode selector)
		ifTrue: [ ^ true ].
	(OneLineMessages includes: aMessageNode selector)
		ifTrue: [ ^ false ].
	(NumberOfArgumentsForMultiLine <= aMessageNode arguments size)
		ifTrue: [ ^ true ].
	(aMessageNode arguments 
		anySatisfy: [ :each | self indent: IndentsForKeywords + 1 around: [ self willBeMultiline: each ] ]) 
		ifTrue: [ ^ true ].
	aMessageNode isUnary
		ifTrue: [ ^ self isLineTooLong: aMessageNode selector ].
	messageStream := WriteStreamPortable on: String new.
	self  with: aMessageNode selectorParts and: aMessageNode arguments 
		do: [ :sel :arg | messageStream nextPutAll: sel value; space; nextPutAll: (self formattedSourceFor: arg) ]
		separatedBy: [ messageStream space ].
	^ self isLineTooLong: messageStream contents
%

category: 'private'
method: RBConfigurableFormatter
needsParenthesisFor: aNode
  | parent grandparent |
  aNode isValue
    ifFalse: [ ^ false ].
  parent := aNode parent ifNil: [ ^ false ].
  (CascadedMessageInsideParentheses
    and: [ aNode isMessage and: [ parent isMessage and: [ parent receiver == aNode ] ] ])
    ifTrue: [ 
      grandparent := parent parent.
      (grandparent notNil and: [ grandparent isCascade ])
        ifTrue: [ ^ true ] ].
  InQueryBlock
    ifTrue: [ 
      aNode isVariable
        ifTrue: [ 
          (aNode token isPath
            and: [ 
              parent isMessage
                and: [ parent receiver == aNode and: [ aNode parent selector == #'&' ] ] ])
            ifTrue: [ ^ true ] ] ].
  aNode precedence < parent precedence
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ parent isAssignment ])
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ aNode isCascade ])
    ifTrue: [ ^ true ].
  aNode precedence = 0
    ifTrue: [ ^ false ].
  aNode isMessage
    ifFalse: [ ^ true ].
  aNode precedence = parent precedence
    ifFalse: [ ^ true ].
  aNode isUnary
    ifTrue: [ ^ false ].
  aNode isKeyword
    ifTrue: [ ^ true ].
  parent receiver == aNode
    ifFalse: [ ^ true ].
  InQueryBlock
    ifTrue: [ ^ aNode receiver isMessage not and: [ aNode selector ~~ #'&' ] ].
  ^ UseTraditionalBinaryPrecedenceForParentheses
    and: [ self precedenceOf: parent selector greaterThan: aNode selector ]
%

category: 'private'
method: RBConfigurableFormatter
newLine
	self newLines: 1
%

category: 'private'
method: RBConfigurableFormatter
newLines: anInteger 
	anInteger + IndentString size = 0 ifTrue: [codeStream space].
	anInteger timesRepeat: [codeStream lf].
	lineStart := codeStream position.
	indent timesRepeat: [codeStream nextPutAll: IndentString]
%

category: 'private'
method: RBConfigurableFormatter
newLinesBeforeStartingAt: anIndex 
	| count cr lf index char |
	(anIndex isNil or: [anIndex > originalSource size]) ifTrue: [^0].
	cr := Character codePoint: 13.
	lf := Character codePoint: 10.
	count := 0.
	index := anIndex - 1.
	[index > 0 and: [(char := originalSource at: index) isSeparator]] 
		whileTrue: 
			[char == lf 
				ifTrue: 
					[count := count + 1.
					(originalSource at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].
			char == cr ifTrue: [count := count + 1].
			index := index - 1].
	^count
%

category: 'private'
method: RBConfigurableFormatter
precedenceOf: parentSelector greaterThan: childSelector 
	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 
	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"

	| childIndex parentIndex |
	childIndex := 0.
	parentIndex := 0.
	1 to: TraditionalBinaryPrecedence size
		do: 
			[:i | 
			((TraditionalBinaryPrecedence at: i) includes: parentSelector first) 
				ifTrue: [parentIndex := i].
			((TraditionalBinaryPrecedence at: i) includes: childSelector first) 
				ifTrue: [childIndex := i]].
	^childIndex < parentIndex
%

category: 'private'
method: RBConfigurableFormatter
space
	codeStream space
%

category: 'visiting'
method: RBConfigurableFormatter
visitNode: aNode
	| needsParenthesis |
	(lookaheadCode includesKey: aNode)
		ifTrue: [^self writeString: (lookaheadCode at: aNode)].
	needsParenthesis := self needsParenthesisFor: aNode.
	self
		bracketWith:
			(needsParenthesis
				ifTrue: ['()']
				ifFalse: [''])
		around:
			[needsParenthesis ifTrue: [codeStream nextPutAll: StringInsideParentheses].
			super visitNode: aNode.
			(FormatCommentWithStatements or: [aNode isMethod or: [aNode isSequence]])
				ifFalse: [self formatCommentsFor: aNode].
			needsParenthesis
				ifTrue: [codeStream nextPutAll: StringInsideParentheses]]
%

category: 'private'
method: RBConfigurableFormatter
willBeMultiline: aNode 
	^(self formattedSourceFor: aNode) includes: Character lf
%

category: 'utility'
method: RBConfigurableFormatter
with: firstCollection and: secondCollection do: aBlock separatedBy: separatorBlock 
	firstCollection isEmpty ifTrue: [^self].
	aBlock
		value: firstCollection first
		value: secondCollection first.
	2
		to: firstCollection size
		do: 
			[:i | 
			separatorBlock value.
			aBlock
				value: (firstCollection at: i)
				value: (secondCollection at: i)]
%

category: 'private'
method: RBConfigurableFormatter
writeString: aString 
	| index |
	index := aString lastIndexOf: Character lf startingAt: aString size ifAbsent: [0].
	codeStream nextPutAll: aString.
	index > 0 
		ifTrue: [lineStart := codeStream position - (aString size - index)]
%

! Class implementation for 'RBFormatter'

!		Instance methods for 'RBFormatter'

category: 'visitor-double dispatching'
method: RBFormatter
acceptArrayNode: anArrayNode
	codeStream nextPut: ${.
	anArrayNode statements isEmpty ifFalse: [
		anArrayNode statements size > 1
			ifTrue: [
				self indent: 1 while: [
					self indent.
					self formatStatementsFor: anArrayNode ].
				self indent ]
			ifFalse: [ self formatStatementsFor: anArrayNode ] ].
	codeStream nextPut: $}
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptAssignmentNode: anAssignmentNode 
	self indent: 2
		while: 
			[self visitNode: anAssignmentNode variable.
			codeStream space; nextPutAll: anAssignmentNode assignmentOperator; space.
			self visitNode: anAssignmentNode value]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptBlockNode: aBlockNode 
	self 
		acceptBlockNode: aBlockNode
		startBlockString: '['
		endBlockString: ']'
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString 
	| seqNode multiline formattedBody formatter |
	seqNode := aBlockNode body.
	formatter := (self copy)
				lineStart: 0;
				yourself.
	formattedBody := formatter format: seqNode.
	multiline := self lineLength + formattedBody size > self maxLineSize 
				or: [formatter isMultiLine].
	multiline ifTrue: [self indent].
	codeStream nextPutAll: startBlockString.
	aBlockNode arguments do: 
			[:each | 
			codeStream nextPut: $:.
			self visitNode: each.
			codeStream nextPut: $ ].
	aBlockNode arguments notEmpty 
		ifTrue: 
			[codeStream nextPutAll: '| '.
			multiline ifTrue: [self indent]].
	codeStream
		nextPutAll: formattedBody;
		nextPutAll: endBlockString
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptCascadeNode: aCascadeNode 
	| messages |
	messages := aCascadeNode messages.
	self visitNode: messages first receiver.
	self indentWhile: 
			[self 
				for: messages
				do: 
					[:each | 
					self
						indent;
						indentWhile: [self formatMessage: each cascade: true]]
				separatedBy: [codeStream nextPut: $;]]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptLiteralArrayNode: aRBArrayLiteralNode 
	codeStream nextPutAll: (aRBArrayLiteralNode isForByteArray 
				ifTrue: ['#[']
				ifFalse: ['#(']).
	self 
		for: aRBArrayLiteralNode contents
		do: [:each | self visitNode: each]
		separatedBy: [codeStream nextPut: $ ].
	codeStream 
		nextPut: (aRBArrayLiteralNode isForByteArray ifTrue: [$]] ifFalse: [$)])
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptLiteralNode: aLiteralNode 
	aLiteralNode token rbStoreOn: codeStream
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptMessageNode: aMessageNode 
	| newFormatter code |
	newFormatter := self copy.
	code := newFormatter format: aMessageNode receiver.
	codeStream nextPutAll: code.
	codeStream nextPut: $ .
	newFormatter isMultiLine
		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].
	self indent: (newFormatter isMultiLine ifTrue: [2] ifFalse: [1])
		while: [self formatMessage: aMessageNode cascade: false]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptMethodNode: aMethodNode 
	self formatMethodPatternFor: aMethodNode.
	self indentWhile: [
		self formatMethodCommentFor: aMethodNode indentBefore: true.
		self indent.
		self formatPragmasFor: aMethodNode.
		aMethodNode body statements notEmpty 
			ifTrue: [ self visitNode: aMethodNode body ] ]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptPatternBlockNode: aRBPatternBlockNode 
	self 
		acceptBlockNode: aRBPatternBlockNode
		startBlockString: '`{'
		endBlockString: '}'
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	self 
		acceptBlockNode: aRBPatternWrapperBlockNode
		startBlockString: '`{'
		endBlockString: '}'
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptPragmaNode: aPragmaNode
  codeStream nextPut: $<.
  aPragmaNode isProtected
    ifTrue: [ codeStream nextPutAll: 'protected ' ].
  aPragmaNode selector isInfix
    ifTrue: [ codeStream nextPut: $  ].
  self formatMessage: aPragmaNode cascade: false.
  codeStream nextPut: $>
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptQueryBlockNode: aBlockNode
  [ 
  inQueryBlock := true.
  self
    acceptQueryBlockNode: aBlockNode
    startBlockString: '{'
    endBlockString: '}' ]
    ensure: [ inQueryBlock := false ]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptQueryBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString
  | seqNode multiline formattedBody formatter |
  seqNode := aBlockNode body.
  formatter := self copy
    lineStart: 0;
    yourself.
  formattedBody := formatter format: seqNode.
  multiline := self lineLength + formattedBody size > self maxLineSize
    or: [ formatter isMultiLine ].
  multiline
    ifTrue: [ self indent ].
  codeStream nextPutAll: startBlockString.
  aBlockNode arguments
    do: [ :each | 
      codeStream nextPut: $:.
      self visitNode: each.
      codeStream nextPut: $  ].
  aBlockNode arguments notEmpty
    ifTrue: [ 
      codeStream nextPutAll: '| '.
      multiline
        ifTrue: [ self indent ] ].
  codeStream
    nextPutAll: formattedBody;
    nextPutAll: endBlockString
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptReturnNode: aReturnNode 
	codeStream nextPut: $^.
	self visitNode: aReturnNode value
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptSequenceNode: aSequenceNode 
	self formatMethodCommentFor: aSequenceNode indentBefore: false.
	self formatTemporariesFor: aSequenceNode.
	self formatStatementsFor: aSequenceNode
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptVariableNode: aVariableNode 
	codeStream nextPutAll: aVariableNode name
%

category: 'accessing'
method: RBFormatter
firstLineLength
	^firstLineLength isNil
		ifTrue: [codeStream position]
		ifFalse: [firstLineLength]
%

category: 'private'
method: RBFormatter
for: aValue do: doBlock separatedBy: separatorBlock 
	"This is implemented here since IBM Smalltalk doesn't implement a do:separatedBy: method"

	aValue isEmpty ifTrue: [^self].
	1 to: aValue size - 1
		do: 
			[:i | 
			doBlock value: (aValue at: i).
			separatorBlock value].
	doBlock value: aValue last
%

category: 'accessing'
method: RBFormatter
format: aNode 
	self visitNode: aNode.
	^codeStream contents
%

category: 'private-formatting'
method: RBFormatter
formatMessage: aMessageNode cascade: cascadeBoolean 
	| selectorParts arguments multiLine formattedArgs indentFirst firstArgLength length |
	selectorParts := aMessageNode selectorParts.
	arguments := aMessageNode arguments.
	formattedArgs := OrderedCollection new.
	multiLine := aMessageNode selector numArgs > self maximumArgumentsPerLine.
	length := aMessageNode selector size + arguments size + 1.
	firstArgLength := 0.
	self indentWhile: 
			[1 to: arguments size
				do: 
					[:i | 
					| formatter string |
					formatter := (self copy)
								lineStart: (selectorParts at: i) length negated;
								yourself.
					string := formatter format: (arguments at: i).
					formattedArgs add: string.
					i == 1 ifTrue: [firstArgLength := formatter firstLineLength].
					length := length + string size.
					multiLine := multiLine or: [formatter isMultiLine]]].
	multiLine := multiLine or: [length + self lineLength > self maxLineSize].
	indentFirst := cascadeBoolean not and: 
					[multiLine and: 
							[(self startMessageSendOnNewLine: aMessageNode) or: 
									[self lineLength + selectorParts first length + 2 + firstArgLength 
										> self maxLineSize]]].
	indentFirst ifTrue: [self indent].
	self 
		formatMessageSelector: selectorParts
		withArguments: formattedArgs
		multiline: multiLine
%

category: 'private-formatting'
method: RBFormatter
formatMessageSelector: selectorParts withArguments: formattedArgs multiline: multiLine 
	formattedArgs isEmpty 
		ifTrue: [codeStream nextPutAll: selectorParts first value]
		ifFalse: 
			[1 to: formattedArgs size
				do: 
					[:i | 
					(i ~= 1 and: [ multiLine not ])
						ifTrue: [codeStream nextPut: $ ].
					codeStream 
						nextPutAll: (selectorParts at: i) value;
						nextPut: $ ;
						nextPutAll: (formattedArgs at: i).
					(multiLine and: [i < formattedArgs size]) ifTrue: [self indent]]]
%

category: 'private-formatting'
method: RBFormatter
formatMethodCommentFor: aNode indentBefore: aBoolean 
	| source |
	source := aNode source.
	source isNil ifTrue: [^self].
	aNode methodComments do: 
			[:each | 
			aBoolean ifTrue: [self indent].
			codeStream
				nextPutAll: (aNode source copyFrom: each first to: each last);
				lf.
			aBoolean ifFalse: [self indent]]
%

category: 'private-formatting'
method: RBFormatter
formatMethodPatternFor: aMethodNode 
	| selectorParts arguments |
	selectorParts := aMethodNode selectorParts.
	arguments := aMethodNode arguments.
	arguments isEmpty 
		ifTrue: [codeStream nextPutAll: selectorParts first value]
		ifFalse: 
			[selectorParts with: arguments
				do: 
					[:selector :arg | 
					codeStream
						nextPutAll: selector value;
						nextPut: $ .
					self visitArgument: arg.
					codeStream nextPut: $ ]]
%

category: 'private-formatting'
method: RBFormatter
formatPragmasFor: aNode
	aNode pragmas do: [ :each | self visitNode: each; indent ]
%

category: 'private-formatting'
method: RBFormatter
formatStatementCommentFor: aNode 
	| source |
	source := aNode source.
	source isNil ifTrue: [^self].
	aNode statementComments do: 
			[:each | 
			| crs |
			crs := self newLinesFor: source startingAt: each first.
			(crs - 1 max: 0) timesRepeat: [codeStream lf].
			crs == 0 ifTrue: [codeStream tab] ifFalse: [self indent].
			codeStream nextPutAll: (source copyFrom: each first to: each last)]
%

category: 'private-formatting'
method: RBFormatter
formatStatementsFor: aSequenceNode 
	| statements |
	statements := aSequenceNode statements.
	statements isEmpty ifTrue: [^self].
	1 to: statements size - 1
		do: 
			[:i | 
			self visitNode: (statements at: i).
			codeStream nextPut: $..
			self formatStatementCommentFor: (statements at: i).
			self indent].
	self visitNode: statements last.
	self formatStatementCommentFor: statements last
%

category: 'private-formatting'
method: RBFormatter
formatTemporariesFor: aSequenceNode 
	| temps |
	temps := aSequenceNode temporaries.
	temps isEmpty ifTrue: [^self].
	codeStream nextPutAll: '| '.
	temps do: 
			[:each | 
			self visitArgument: each.
			codeStream nextPut: $ ].
	codeStream nextPut: $|.
	self indent
%

category: 'private'
method: RBFormatter
indent
	firstLineLength isNil ifTrue: [firstLineLength := codeStream position].
	codeStream lf.
	tabs timesRepeat: [codeStream tab].
	lineStart := codeStream position
%

category: 'private'
method: RBFormatter
indent: anInteger while: aBlock 
	tabs := tabs + anInteger.
	aBlock value.
	tabs := tabs - anInteger
%

category: 'private'
method: RBFormatter
indentWhile: aBlock 
	self indent: 1 while: aBlock
%

category: 'initialize-release'
method: RBFormatter
initialize
  super initialize.
  codeStream := WriteStreamPortable on: String new.
  tabs := 0.
  lineStart := 0.
  inQueryBlock := false
%

category: 'accessing'
method: RBFormatter
isMultiLine
	^firstLineLength notNil
%

category: 'accessing'
method: RBFormatter
lastLineLength
	^codeStream position - (lineStart max: 0)
%

category: 'private'
method: RBFormatter
lineLength
	^codeStream position - lineStart
%

category: 'private'
method: RBFormatter
lineStart: aPosition 
	lineStart := aPosition
%

category: 'private'
method: RBFormatter
maximumArgumentsPerLine
	^2
%

category: 'private'
method: RBFormatter
maxLineSize
	^75
%

category: 'private'
method: RBFormatter
needsParenthesisFor: aNode
  | parent grandparent |
  aNode isValue
    ifFalse: [ ^ false ].
  parent := aNode parent ifNil: [ ^ false ].
  (aNode isMessage and: [ parent isMessage and: [ parent receiver == aNode ] ])
    ifTrue: [ 
      grandparent := parent parent.
      (grandparent notNil and: [ grandparent isCascade ])
        ifTrue: [ ^ true ] ].
  inQueryBlock
    ifTrue: [ 
      aNode isLiteralNode
        ifTrue: [ 
          (parent isMessage
            and: [ parent receiver == aNode and: [ aNode parent selector == #'&' ] ])
            ifTrue: [ ^ true ] ].
      aNode isVariable
        ifTrue: [ 
          (aNode token isPath
            and: [ 
              parent isMessage
                and: [ parent receiver == aNode and: [ aNode parent selector == #'&' ] ] ])
            ifTrue: [ ^ true ] ] ].
  aNode precedence < parent precedence
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ parent isAssignment ])
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ aNode isCascade ])
    ifTrue: [ ^ true ].
  aNode precedence = 0
    ifTrue: [ ^ false ].
  aNode isMessage
    ifFalse: [ ^ true ].
  aNode precedence = parent precedence
    ifFalse: [ ^ true ].
  aNode isUnary
    ifTrue: [ ^ false ].
  aNode isKeyword
    ifTrue: [ ^ true ].
  parent receiver == aNode
    ifFalse: [ ^ true ].
  inQueryBlock
    ifTrue: [ ^ aNode receiver isMessage not and: [ aNode selector ~~ #'&' ] ].
  ^ self precedenceOf: parent selector greaterThan: aNode selector
%

category: 'private-formatting'
method: RBFormatter
newLinesFor: aString startingAt: anIndex 
	| count cr lf index char |
	cr := Character codePoint: 13.
	lf := Character codePoint: 10.
	count := 0.
	index := anIndex - 1.
	[index > 0 and: 
			[char := aString at: index.
			char isSeparator]] 
		whileTrue: 
			[char == lf 
				ifTrue: 
					[count := count + 1.
					(aString at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].
			char == cr ifTrue: [count := count + 1].
			index := index - 1].
	^count
%

category: 'copying'
method: RBFormatter
postCopy
	super postCopy.
	lineStart := self lineLength negated.
	codeStream := WriteStreamPortable on: String new.
	firstLineLength := nil
%

category: 'private'
method: RBFormatter
precedenceOf: parentSelector greaterThan: childSelector 
	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 
	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"

	| childIndex parentIndex operators |
	operators := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).
	childIndex := 0.
	parentIndex := 0.
	1 to: operators size
		do: 
			[:i | 
			((operators at: i) includes: parentSelector first) 
				ifTrue: [parentIndex := i].
			((operators at: i) includes: childSelector first) 
				ifTrue: [childIndex := i]].
	^childIndex < parentIndex
%

category: 'private'
method: RBFormatter
selectorsToLeaveOnLine
	^#(#to:do: #to:by: #to:by:do:)
%

category: 'private'
method: RBFormatter
selectorsToStartOnNewLine
	^#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse:)
%

category: 'testing'
method: RBFormatter
startMessageSendOnNewLine: aMessageNode 
	(self selectorsToStartOnNewLine includes: aMessageNode selector) 
		ifTrue: [^true].
	(self selectorsToLeaveOnLine includes: aMessageNode selector) 
		ifTrue: [^false].
	^aMessageNode selector numArgs > self maximumArgumentsPerLine
%

category: 'visiting'
method: RBFormatter
visitNode: aNode
  | parenthesis |
  parenthesis := self needsParenthesisFor: aNode.
  parenthesis
    ifTrue: [ codeStream nextPut: $( ].
  aNode acceptVisitor: self.
  parenthesis
    ifTrue: [ codeStream nextPut: $) ]
%

! Class implementation for 'RBParseTreeSearcher'

!		Class methods for 'RBParseTreeSearcher'

category: 'private'
classmethod: RBParseTreeSearcher
buildSelectorString: aSelector 
	| stream keywords |
	aSelector numArgs = 0 ifTrue: [^aSelector].
	stream := WriteStreamPortable on: String new.
	keywords := aSelector keywords.
	1 to: keywords size
		do: 
			[:i | 
			stream
				nextPutAll: (keywords at: i);
				nextPutAll: ' ``@arg';
				nextPutAll: i printString;
				nextPut: $ ].
	^stream contents
%

category: 'private'
classmethod: RBParseTreeSearcher
buildSelectorTree: aSelector 
	aSelector isEmpty ifTrue: [^nil].
	^RBParser parseRewriteExpression: '``@receiver ' 
				, (self buildSelectorString: aSelector)
		onError: [:err :pos | ^nil]
%

category: 'private'
classmethod: RBParseTreeSearcher
buildTree: aString method: aBoolean 
	^aBoolean 
		ifTrue: [RBParser parseRewriteMethod: aString]
		ifFalse: [RBParser parseRewriteExpression: aString]
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
getterMethod: aVarName 
	^(self new)
		matchesMethod: '`method ^' , aVarName do: [:aNode :ans | aNode selector];
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
justSendsSuper
	^ self new
		matchesAnyMethodOf: #(
			'`@method: `@args ^ super `@method: `@args' 
			'`@method: `@args super `@method: `@args')
		do: [ :node :answer | true ];
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
returnSetterMethod: aVarName 
	^(self new)
		matchesMethod: '`method: `Arg ^' , aVarName , ' := `Arg'
			do: [:aNode :ans | aNode selector];
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
setterMethod: aVarName 
	^(self new)
		matchesAnyMethodOf: (Array with: '`method: `Arg ' , aVarName , ' := `Arg'
					with: '`method: `Arg ^' , aVarName , ' := `Arg')
			do: [:aNode :ans | aNode selector];
		yourself
%

category: 'accessing'
classmethod: RBParseTreeSearcher
treeMatching: aString in: aParseTree 
	(self new)
		matches: aString do: [:aNode :answer | ^aNode];
		executeTree: aParseTree.
	^nil
%

category: 'accessing'
classmethod: RBParseTreeSearcher
treeMatchingStatements: aString in: aParseTree 
	| notifier tree |
	notifier := self new.
	tree := RBParser parseExpression: aString.
	tree isSequence 
		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].
	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).
	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').
	tree lastIsReturn 
		ifFalse: [tree addNode: (RBPatternVariableNode named: '`@.S2')].
	notifier matchesTree: tree
		do: [:aNode :answer | ^RBParser parseExpression: aString].
	notifier executeTree: aParseTree.
	^nil
%

!		Instance methods for 'RBParseTreeSearcher'

category: 'accessing'
method: RBParseTreeSearcher
addArgumentRule: aParseTreeRule 
	argumentSearches add: aParseTreeRule.
	aParseTreeRule owner: self
%

category: 'accessing'
method: RBParseTreeSearcher
addArgumentRules: ruleCollection 
	ruleCollection do: [:each | self addArgumentRule: each]
%

category: 'accessing'
method: RBParseTreeSearcher
addRule: aParseTreeRule 
	searches add: aParseTreeRule.
	aParseTreeRule owner: self
%

category: 'accessing'
method: RBParseTreeSearcher
addRules: ruleCollection 
	ruleCollection do: [:each | self addRule: each]
%

category: 'accessing'
method: RBParseTreeSearcher
answer
	^answer
%

category: 'initialize-release'
method: RBParseTreeSearcher
answer: anObject
	answer := anObject
%

category: 'testing'
method: RBParseTreeSearcher
canMatchMethod: aCompiledMethod
	| actualMessages |
	self messages isEmpty
		ifTrue: [ ^ true ].
	actualMessages := aCompiledMethod messages.
	^ self messages 
		anySatisfy: [ :each | actualMessages includes: each ]
%

category: 'accessing'
method: RBParseTreeSearcher
context
	^context
%

category: 'accessing'
method: RBParseTreeSearcher
executeMethod: aParseTree initialAnswer: anObject 
	answer := anObject.
	searches detect: [:each | (each performOn: aParseTree) notNil] ifNone: [].
	^answer
%

category: 'accessing'
method: RBParseTreeSearcher
executeTree: aParseTree 
	"Save our current context, in case someone is performing another search inside a match."

	| oldContext |
	oldContext := context.
	context := RBSmallDictionary new.
	self visitNode: aParseTree.
	context := oldContext.
	^answer
%

category: 'accessing'
method: RBParseTreeSearcher
executeTree: aParseTree initialAnswer: aValue 
	answer := aValue.
	^self executeTree: aParseTree
%

category: 'private'
method: RBParseTreeSearcher
foundMatch
%

category: 'testing'
method: RBParseTreeSearcher
hasRules
	^searches notEmpty
%

category: 'initialize-release'
method: RBParseTreeSearcher
initialize
	super initialize.
	context := RBSmallDictionary new.
	searches := OrderedCollection new.
	argumentSearches := OrderedCollection new: 0.
	answer := nil
%

category: 'private'
method: RBParseTreeSearcher
lookForMoreMatchesInContext: oldContext 
	oldContext keysAndValuesDo: 
			[:key :value | 
			(key isString not and: [key recurseInto]) 
				ifTrue: [value do: [:each | self visitNode: each]]]
%

category: 'searching'
method: RBParseTreeSearcher
matches: aString do: aBlock 
	self addRule: (RBSearchRule searchFor: aString thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyArgumentOf: stringCollection do: aBlock 
	stringCollection do: [:each | self matchesArgument: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyMethodOf: aStringCollection do: aBlock 
	aStringCollection do: [:each | self matchesMethod: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyOf: aStringCollection do: aBlock 
	aStringCollection do: [:each | self matches: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyTreeOf: treeCollection do: aBlock 
	treeCollection do: [:each | self matchesTree: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesArgument: aString do: aBlock 
	self addArgumentRule: (RBSearchRule searchFor: aString thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesArgumentTree: aBRProgramNode do: aBlock 
	self 
		addArgumentRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesMethod: aString do: aBlock 
	self addRule: (RBSearchRule searchForMethod: aString thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesTree: aBRProgramNode do: aBlock 
	self addRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)
%

category: 'accessing'
method: RBParseTreeSearcher
messages
	messages notNil ifTrue: [^messages].
	argumentSearches notEmpty ifTrue: [^messages := #()].
	messages := Set new.
	searches do: 
			[:each | 
			| searchMessages |
			searchMessages := each sentMessages.
			RBProgramNode optimizedSelectors 
				do: [:sel | searchMessages remove: sel ifAbsent: []].
			searchMessages isEmpty ifTrue: [^messages := #()].
			messages addAll: searchMessages].
	^messages := messages asArray
%

category: 'private'
method: RBParseTreeSearcher
performSearches: aSearchCollection on: aNode 
	| value |
	1 to: aSearchCollection size
		do: 
			[:i | 
			value := (aSearchCollection at: i) performOn: aNode.
			value notNil 
				ifTrue: 
					[self foundMatch.
					^value]].
	^nil
%

category: 'private'
method: RBParseTreeSearcher
recusivelySearchInContext
	"We need to save the matched context since the other searches might overwrite it."

	| oldContext |
	oldContext := context.
	context := RBSmallDictionary new.
	self lookForMoreMatchesInContext: oldContext.
	context := oldContext
%

category: 'visiting'
method: RBParseTreeSearcher
visitArgument: aNode 
	| value |
	value := self performSearches: argumentSearches on: aNode.
	^value isNil 
		ifTrue: 
			[aNode acceptVisitor: self.
			aNode]
		ifFalse: [value]
%

category: 'visiting'
method: RBParseTreeSearcher
visitNode: aNode 
	| value |
	value := self performSearches: searches on: aNode.
	^value isNil 
		ifTrue: 
			[aNode acceptVisitor: self.
			aNode]
		ifFalse: [value]
%

! Class implementation for 'RBParseTreeRewriter'

!		Class methods for 'RBParseTreeRewriter'

category: 'instance creation'
classmethod: RBParseTreeRewriter
removeTemporaryNamed: aName 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule replace: '| `@temps1 ' , aName , ' `@temps2 | ``@.Statements'
		with: '| `@temps1  `@temps2 | ``@.Statements'.
	^rewriteRule
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
rename: varName to: newVarName 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule
		replace: varName with: newVarName;
		replaceArgument: varName with: newVarName.
	^rewriteRule
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
rename: varName to: newVarName handler: aBlock 
	"Rename varName to newVarName, evaluating aBlock if there is a 
	temporary variable with the same name as newVarName. This 
	does not change temporary variables with varName."

	| rewriteRule |
	rewriteRule := self new.
	rewriteRule
		replace: varName with: newVarName;
		replaceArgument: newVarName
			withValueFrom: 
				[:aNode | 
				aBlock value.
				aNode].
	^rewriteRule
%

category: 'accessing'
classmethod: RBParseTreeRewriter
replace: code with: newCode in: aParseTree 
	^(self 
		replace: code
		with: newCode
		method: false)
		executeTree: aParseTree;
		tree
%

category: 'accessing'
classmethod: RBParseTreeRewriter
replace: code with: newCode in: aParseTree onInterval: anInterval 
	| rewriteRule |
	rewriteRule := self new.
	^rewriteRule
		replace: code
			with: newCode
			when: [:aNode | aNode intersectsInterval: anInterval];
		executeTree: aParseTree;
		tree
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
replace: code with: newCode method: aBoolean 
	| rewriteRule |
	rewriteRule := self new.
	aBoolean 
		ifTrue: [rewriteRule replaceMethod: code with: newCode]
		ifFalse: [rewriteRule replace: code with: newCode].
	^rewriteRule
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
replaceLiteral: literal with: newLiteral 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule replaceTree: (RBLiteralNode value: literal)
		withTree: (RBLiteralNode value: newLiteral).
	^rewriteRule
%

category: 'accessing'
classmethod: RBParseTreeRewriter
replaceStatements: code with: newCode in: aParseTree onInterval: anInterval 
	| tree replaceStmt |
	tree := self buildTree: code method: false.
	tree isSequence 
		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].
	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).
	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').
	tree lastIsReturn 
		ifTrue: [replaceStmt := '| `@temps | `@.S1. ^' , newCode]
		ifFalse: 
			[tree addNode: (RBPatternVariableNode named: '`@.S2').
			replaceStmt := '| `@temps | `@.S1. ' , newCode , '. `@.S2'].
	^self 
		replace: tree formattedCode
		with: replaceStmt
		in: aParseTree
		onInterval: anInterval
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
variable: aVarName getter: getMethod setter: setMethod 
	^self 
		variable: aVarName
		getter: getMethod
		setter: setMethod
		receiver: 'self'
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
variable: aVarName getter: getMethod setter: setMethod receiver: aString 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule
		replace: aVarName , ' := ``@object'
			with: aString , ' ' , setMethod , ' ``@object';
		replace: aVarName with: aString , ' ' , getMethod.
	^rewriteRule
%

!		Instance methods for 'RBParseTreeRewriter'

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptArrayNode: anArrayNode
	anArrayNode statements: (anArrayNode statements 
				collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptAssignmentNode: anAssignmentNode 
	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).
	anAssignmentNode value: (self visitNode: anAssignmentNode value)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptBlockNode: aBlockNode 
	aBlockNode arguments: (self visitArguments: aBlockNode arguments).
	aBlockNode body: (self visitNode: aBlockNode body)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptCascadeNode: aCascadeNode 
	| newMessages notFound |
	newMessages := OrderedCollection new: aCascadeNode messages size.
	notFound := OrderedCollection new: aCascadeNode messages size.
	aCascadeNode messages do: 
			[:each | 
			| newNode |
			newNode := self performSearches: searches on: each.
			newNode isNil 
				ifTrue: 
					[newNode := each.
					notFound add: newNode].
			newNode isMessage 
				ifTrue: [newMessages add: newNode]
				ifFalse: 
					[newNode isCascade 
						ifTrue: [newMessages addAll: newNode messages]
						ifFalse: 
							[Transcript
								show: 'Cannot replace message node inside of cascaded node with non-message node.';
								cr.
							newMessages add: each]]].
	notFound size = aCascadeNode messages size 
		ifTrue: 
			[| receiver |
			receiver := self visitNode: aCascadeNode messages first receiver.
			newMessages do: [:each | each receiver: receiver]].
	notFound 
		do: [:each | each arguments: (each arguments collect: [:arg | self visitNode: arg])].
	aCascadeNode messages: newMessages
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptLiteralArrayNode: aRBArrayLiteralNode 
	aRBArrayLiteralNode contents: (aRBArrayLiteralNode contents 
				collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptMessageNode: aMessageNode 
	aMessageNode receiver: (self visitNode: aMessageNode receiver).
	aMessageNode 
		arguments: (aMessageNode arguments collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptMethodNode: aMethodNode 
	aMethodNode arguments: (self visitArguments: aMethodNode arguments).
	aMethodNode pragmas: (aMethodNode pragmas 
		collect: [:each | self visitNode: each]).
	aMethodNode body: (self visitNode: aMethodNode body)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptPragmaNode: aPragmaNode 
	aPragmaNode arguments: (aPragmaNode arguments collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptReturnNode: aReturnNode 
	aReturnNode value: (self visitNode: aReturnNode value)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptSequenceNode: aSequenceNode 
	aSequenceNode 
		temporaries: (self visitArguments: aSequenceNode temporaries).
	aSequenceNode statements: (aSequenceNode statements 
				collect: [:each | self visitNode: each])
%

category: 'accessing'
method: RBParseTreeRewriter
executeTree: aParseTree 
	| oldContext |
	oldContext := context.
	context := RBSmallDictionary new.
	answer := false.
	tree := self visitNode: aParseTree.
	context := oldContext.
	^answer
%

category: 'private'
method: RBParseTreeRewriter
foundMatch
	answer := true
%

category: 'private'
method: RBParseTreeRewriter
lookForMoreMatchesInContext: oldContext 
	oldContext keysAndValuesDo: 
			[:key :value | 
			(key isString not and: [key recurseInto]) 
				ifTrue: 
					[oldContext at: key put: (value collect: [:each | self visitNode: each])]]
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString with: replaceString 
	self addRule: (RBStringReplaceRule searchFor: searchString
				replaceWith: replaceString)
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString with: replaceString when: aBlock 
	self addRule: (RBStringReplaceRule 
				searchFor: searchString
				replaceWith: replaceString
				when: aBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString withValueFrom: replaceBlock 
	self addRule: (RBBlockReplaceRule searchFor: searchString
				replaceWith: replaceBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString withValueFrom: replaceBlock when: conditionBlock 
	self addRule: (RBBlockReplaceRule 
				searchFor: searchString
				replaceWith: replaceBlock
				when: conditionBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString with: replaceString 
	self addArgumentRule: (RBStringReplaceRule searchFor: searchString
				replaceWith: replaceString)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString with: replaceString when: aBlock 
	self addArgumentRule: (RBStringReplaceRule 
				searchFor: searchString
				replaceWith: replaceString
				when: aBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString withValueFrom: replaceBlock 
	self addArgumentRule: (RBBlockReplaceRule searchFor: searchString
				replaceWith: replaceBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString withValueFrom: replaceBlock when: conditionBlock 
	self addArgumentRule: (RBBlockReplaceRule 
				searchFor: searchString
				replaceWith: replaceBlock
				when: conditionBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString with: replaceString 
	self addRule: (RBStringReplaceRule searchForMethod: searchString
				replaceWith: replaceString)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString with: replaceString when: aBlock 
	self addRule: (RBStringReplaceRule 
				searchForMethod: searchString
				replaceWith: replaceString
				when: aBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString withValueFrom: replaceBlock 
	self addRule: (RBBlockReplaceRule searchForMethod: searchString
				replaceWith: replaceBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString withValueFrom: replaceBlock when: conditionBlock 
	self addRule: (RBBlockReplaceRule 
				searchForMethod: searchString
				replaceWith: replaceBlock
				when: conditionBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceTree: searchTree withTree: replaceTree 
	self addRule: (RBStringReplaceRule searchForTree: searchTree
				replaceWith: replaceTree)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceTree: searchTree withTree: replaceTree when: aBlock 
	self addRule: (RBStringReplaceRule 
				searchForTree: searchTree
				replaceWith: replaceTree
				when: aBlock)
%

category: 'accessing'
method: RBParseTreeRewriter
tree
	^tree
%

category: 'visiting'
method: RBParseTreeRewriter
visitArguments: aNodeCollection 
	^aNodeCollection collect: [:each | self visitArgument: each]
%

! Class implementation for 'RBReadBeforeWrittenTester'

!		Class methods for 'RBReadBeforeWrittenTester'

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
isVariable: aString readBeforeWrittenIn: aBRProgramNode 
	^(self isVariable: aString writtenBeforeReadIn: aBRProgramNode) not
%

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
isVariable: aString writtenBeforeReadIn: aBRProgramNode 
	^(self readBeforeWritten: (Array with: aString) in: aBRProgramNode) 
		isEmpty
%

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
readBeforeWritten: varNames in: aParseTree 
	^(self new)
		checkNewTemps: false;
		initializeVars: varNames;
		executeTree: aParseTree;
		read
%

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
variablesReadBeforeWrittenIn: aParseTree 
	^(self new)
		executeTree: aParseTree;
		read
%

!		Instance methods for 'RBReadBeforeWrittenTester'

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptAssignmentNode: anAssignmentNode 
	self visitNode: anAssignmentNode value.
	self variableWritten: anAssignmentNode
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptBlockNode: aBlockNode 
	self processBlock: aBlockNode
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptMessageNode: aMessageNode 
	((#(#whileTrue: #whileFalse: #whileTrue #whileFalse) 
		includes: aMessageNode selector) and: [aMessageNode receiver isBlock]) 
		ifTrue: [self executeTree: aMessageNode receiver body]
		ifFalse: 
			[(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 
				ifTrue: [self visitNode: aMessageNode receiver]].
	((#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aMessageNode selector) 
		and: [aMessageNode arguments allSatisfy: [:each | each isBlock]]) 
			ifTrue: [^self processIfTrueIfFalse: aMessageNode].
	aMessageNode arguments do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptSequenceNode: aSequenceNode 
	self processStatementNode: aSequenceNode
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptVariableNode: aVariableNode 
	self variableRead: aVariableNode
%

category: 'initialize-release'
method: RBReadBeforeWrittenTester
checkNewTemps: aBoolean 
	checkNewTemps := aBoolean
%

category: 'private'
method: RBReadBeforeWrittenTester
copyDictionary: aDictionary 
	"We could send aDictionary the copy message, but that doesn't copy the associations."

	| newDictionary |
	newDictionary := Dictionary new: aDictionary size.
	aDictionary keysAndValuesDo: [ :key :value | newDictionary at: key put: value ].
	^ newDictionary
%

category: 'private'
method: RBReadBeforeWrittenTester
createScope
	scopeStack add: (self copyDictionary: scopeStack last)
%

category: 'private'
method: RBReadBeforeWrittenTester
currentScope
	^scopeStack last
%

category: 'accessing'
method: RBReadBeforeWrittenTester
executeTree: aParseTree 
	^self visitNode: aParseTree
%

category: 'initialize-release'
method: RBReadBeforeWrittenTester
initialize
	super initialize.
	scopeStack := OrderedCollection with: Dictionary new.
	read := Set new.
	checkNewTemps := true
%

category: 'initialize-release'
method: RBReadBeforeWrittenTester
initializeVars: varNames 
	varNames do: [:each | self currentScope at: each put: nil]
%

category: 'private'
method: RBReadBeforeWrittenTester
processBlock: aNode 
	| newScope |
	self createScope.
	self executeTree: aNode body.
	newScope := self removeScope.
	newScope keysAndValuesDo: 
			[:key :value | 
			(value == true and: [(self currentScope at: key) isNil]) 
				ifTrue: [self currentScope at: key put: value]]
%

category: 'private'
method: RBReadBeforeWrittenTester
processIfTrueIfFalse: aNode 
	| trueScope falseScope |
	self createScope.
	self executeTree: aNode arguments first body.
	trueScope := self removeScope.
	self createScope.
	self executeTree: aNode arguments last body.
	falseScope := self removeScope.
	self currentScope keysAndValuesDo: 
			[:key :value | 
			value isNil 
				ifTrue: 
					[(trueScope at: key) == (falseScope at: key) 
						ifTrue: [self currentScope at: key put: (trueScope at: key)]
						ifFalse: 
							[((trueScope at: key) == true or: [(falseScope at: key) == true]) 
								ifTrue: [self currentScope at: key put: true]]]]
%

category: 'private'
method: RBReadBeforeWrittenTester
processStatementNode: aNode 
	| temps |
	(checkNewTemps not or: [aNode temporaries isEmpty]) 
		ifTrue: 
			[aNode statements do: [:each | self executeTree: each].
			^self].
	self createScope.
	temps := aNode temporaries collect: [:each | each name].
	self initializeVars: temps.
	aNode statements do: [:each | self executeTree: each].
	self removeScope keysAndValuesDo: 
			[:key :value | 
			(temps includes: key) 
				ifTrue: [value == true ifTrue: [read add: key]]
				ifFalse: 
					[(self currentScope at: key) isNil 
						ifTrue: [self currentScope at: key put: value]]]
%

category: 'accessing'
method: RBReadBeforeWrittenTester
read
	self currentScope
		keysAndValuesDo: [:key :value | value == true ifTrue: [read add: key]].
	^read
%

category: 'private'
method: RBReadBeforeWrittenTester
removeScope
	^scopeStack removeLast
%

category: 'private'
method: RBReadBeforeWrittenTester
variableRead: aNode 
	(self currentScope includesKey: aNode name) 
		ifTrue: 
			[(self currentScope at: aNode name) isNil 
				ifTrue: [self currentScope at: aNode name put: true]]
%

category: 'private'
method: RBReadBeforeWrittenTester
variableWritten: aNode 
	(self currentScope includesKey: aNode variable name) 
		ifTrue: 
			[(self currentScope at: aNode variable name) isNil 
				ifTrue: [self currentScope at: aNode variable name put: false]]
%

! Class implementation for 'RBScanner'

!		Class methods for 'RBScanner'

category: 'accessing'
classmethod: RBScanner
classificationTable
	classificationTable isNil 
		ifTrue: [ self initializeClassificationTable ].
	^ classificationTable
%

category: 'class initialization'
classmethod: RBScanner
initialize
	self initializeClassificationTable
%

category: 'class initialization'
classmethod: RBScanner
initializeChars: characters to: aSymbol 
	characters do: [:c | classificationTable at: c asInteger put: aSymbol]
%

category: 'class initialization'
classmethod: RBScanner
initializeClassificationTable
  PatternVariableCharacter := $`.
  classificationTable := Array new: 255.
  self
    initializeChars: (((0 to: 255) collect: [ :v | Character codePoint: v ]) select: [ :each | each isLetter ])
    to: #'alphabetic'.
  self initializeUnderscore.
  self initializeChars: '01234567890' to: #'digit'.
  self initializeChars: '!%&*+,-/<=>?@\~|' to: #'binary'.
  classificationTable at: 177 put: #'binary'.	"plus-or-minus"
  classificationTable at: 183 put: #'binary'.	"centered dot"
  classificationTable at: 215 put: #'binary'.	"times"
  classificationTable at: 247 put: #'binary'.	"divide"
  self initializeChars: '().:;[]{}^' to: #'special'.
  self
    initializeChars:
      (((1 to: 255) collect: [ :v | Character codePoint: v ]) select: [ :each | each isSeparator ])
    to: #'separator'
%

category: 'class initialization'
classmethod: RBScanner
initializeUnderscore
  self classificationTable
    at: $_ asInteger
    put: #'alphabetic' 
"
      ((Scanner isLiteralSymbol: '_')
        ifTrue: [ #'alphabetic' ]
        ifFalse: [ #'special' ])
"
%

category: 'testing'
classmethod: RBScanner
isSelector: aSymbol 
	| scanner token |
	scanner := self basicNew.
	scanner on: aSymbol asString readStreamPortable.
	scanner step.
	token := scanner scanAnySymbol.
	token isLiteralToken ifFalse: [^false].
	token value isEmpty ifTrue: [^false].
	^scanner atEnd
%

category: 'testing'
classmethod: RBScanner
isVariable: aString 
	| scanner token |
	scanner := self on: aString readStreamPortable errorBlock: [:s :p | ^false].
	token := scanner next.
	token isIdentifier ifFalse: [^false].
	(token start = 1 and: [token stop = aString size]) ifFalse: [^false].
	^(aString includes: $.) not
%

category: 'instance creation'
classmethod: RBScanner
new
  ^ super new
%

category: 'instance creation'
classmethod: RBScanner
on: aStream 
	| str |
	str := self new on: aStream.
	str
		step;
		stripSeparators.
	^str
%

category: 'instance creation'
classmethod: RBScanner
on: aStream errorBlock: aBlock 
	| str |
	str := self new on: aStream.
	str
		errorBlock: aBlock;
		step;
		stripSeparators.
	^str
%

category: 'accessing'
classmethod: RBScanner
patternVariableCharacter
	^ PatternVariableCharacter
%

!		Instance methods for 'RBScanner'

category: 'testing'
method: RBScanner
atEnd
	^characterType = #eof
%

category: 'private'
method: RBScanner
classify: aCharacter 
	| index |
	aCharacter isNil ifTrue: [^nil].
	index := aCharacter asInteger.
	index == 0 ifTrue: [^#separator].
	index > 255 
		ifTrue: 
			[^aCharacter isLetter 
				ifTrue: [#alphabetic]
				ifFalse: [aCharacter isSqueakSeparator ifTrue: [#separator] ifFalse: [nil]]].
	^classificationTable at: index
%

category: 'accessing'
method: RBScanner
contents
	| contentsStream |
	contentsStream := WriteStreamPortable on: String new.
	[ self atEnd ]
		whileFalse: [ contentsStream nextPut: self next ].
	^ contentsStream contents
%

category: 'error handling'
method: RBScanner
errorBlock
	^errorBlock isNil ifTrue: [[:message :position | ]] ifFalse: [errorBlock]
%

category: 'accessing'
method: RBScanner
errorBlock: aBlock 
	errorBlock := aBlock
%

category: 'error handling'
method: RBScanner
errorPosition
	^stream position
%

category: 'accessing'
method: RBScanner
flush
%

category: 'accessing'
method: RBScanner
getComments
	| oldComments |
	comments isEmpty ifTrue: [^nil].
	oldComments := comments.
	comments := OrderedCollection new: 1.
	^oldComments
%

category: 'testing'
method: RBScanner
isReadable
	^true
%

category: 'testing'
method: RBScanner
isWritable
	^false
%

category: 'accessing'
method: RBScanner
next
	| token |
	buffer reset.
	tokenStart := stream position.
	token := characterType = #eof 
				ifTrue: 
					[RBToken start: tokenStart + 1	"The EOF token should occur after the end of input"]
				ifFalse: [self scanToken].
	self stripSeparators.
	token comments: self getComments.
	^token
%

category: 'accessing'
method: RBScanner
nextPut: anObject 
	"Provide an error notification that the receiver does not
	implement this message."

	self shouldNotImplement
%

category: 'initialize-release'
method: RBScanner
on: aStream 
	buffer := WriteStreamPortable on: String new.
	stream := aStream.
	classificationTable := self class classificationTable.
	comments := OrderedCollection new
%

category: 'private'
method: RBScanner
previousStepPosition
	^characterType = #eof 
		ifTrue: [stream position]
		ifFalse: [stream position - 1]
%

category: 'private-scanning'
method: RBScanner
scanAnySymbol
	characterType = #alphabetic ifTrue: [^self scanSymbol].
	characterType = #binary ifTrue: [^self scanBinary: RBLiteralToken].
	^RBToken new
%

category: 'private-scanning'
method: RBScanner
scanBinary: aClass 
	| val |
	buffer nextPut: currentCharacter.
	self step.
	[ characterType = #binary ] whileTrue: 
		[ buffer nextPut: currentCharacter.
		self step ].
	val := buffer contents.
	val := val asSymbol.
	^aClass value: val start: tokenStart
%

category: 'private-scanning'
method: RBScanner
scanIdentifierOrKeyword
  | name |
  self scanName.
  [ 
  currentCharacter = $.
    and: [ 'abcdefghijklmnopqrstuvwxyz*|#' includes: stream peek ] ]
    whileTrue: [ 
      buffer nextPut: currentCharacter.
      self step.
      self scanPathName.
      name := buffer contents.
      ^ RBPathToken value: name start: tokenStart ].
  (currentCharacter = $: and: [ stream peek ~= $= ])
    ifTrue: [ ^ self scanKeyword ].
  name := buffer contents.
  name = '_'
    ifTrue: [ ^ RBShortAssignmentToken start: tokenStart ].
  name = 'true'
    ifTrue: [ ^ RBLiteralToken value: true start: tokenStart stop: self previousStepPosition ].
  name = 'false'
    ifTrue: [ ^ RBLiteralToken value: false start: tokenStart stop: self previousStepPosition ].
  name = 'nil'
    ifTrue: [ ^ RBLiteralToken value: nil start: tokenStart stop: self previousStepPosition ].
  ^ RBIdentifierToken value: name start: tokenStart
%

category: 'private-scanning'
method: RBScanner
scanKeyword
	| outputPosition inputPosition name |
	[currentCharacter = $:] whileTrue: 
			[buffer nextPut: currentCharacter.
			outputPosition := buffer position.
			inputPosition := stream position.
			self step.	":"
			[characterType = #alphabetic] whileTrue: [self scanName]].
	buffer position: outputPosition.
	stream position: inputPosition.
	self step.
	name := buffer contents.
	^(name occurrencesOf: $:) == 1 
		ifTrue: [RBKeywordToken value: name start: tokenStart]
		ifFalse: 
			[RBMultiKeywordLiteralToken 
				value: name asSymbol
				start: tokenStart
				stop: tokenStart + name size - 1]
%

category: 'private-scanning'
method: RBScanner
scanLiteral
	self step.
	self stripSeparators.
	characterType = #alphabetic 
		ifTrue: [ ^ self scanSymbol ].
	characterType = #binary 
		ifTrue: [ ^ (self scanBinary: RBLiteralToken) stop: self previousStepPosition ].
	currentCharacter = $' 
		ifTrue: [ ^ self scanStringSymbol ].
	(currentCharacter = $( or: [ currentCharacter = $[ ]) 
		ifTrue: [ ^ self scanLiteralArrayToken].
	"Accept some strange literals like '#1', '# species' and '##species:'"
	characterType = #digit
		ifTrue: [ ^ self scanNumber ].
	currentCharacter = $#
		ifTrue: [ ^ self scanLiteral ].
	self scannerError: 'Expecting a literal type'
%

category: 'private-scanning'
method: RBScanner
scanLiteralArrayToken
	| token |
	token := RBLiteralArrayToken 
				value: (String with: $# with: currentCharacter)
				start: tokenStart.
	self step.
	^token
%

category: 'private-scanning'
method: RBScanner
scanLiteralCharacter
	| token |
	self step.	"$"
	token := RBLiteralToken 
				value: currentCharacter
				start: tokenStart
				stop: stream position.
	self step.	"char"
	^token
%

category: 'private-scanning'
method: RBScanner
scanLiteralString
	self step.
	
	[currentCharacter isNil 
		ifTrue: [self scannerError: 'Unmatched '' in string literal.'].
	currentCharacter = $' and: [self step ~= $']] 
			whileFalse: 
				[buffer nextPut: currentCharacter.
				self step].
	^RBLiteralToken 
		value: buffer contents
		start: tokenStart
		stop: self previousStepPosition
%

category: 'private-scanning'
method: RBScanner
scanName
	[characterType = #alphabetic or: [characterType = #digit]] whileTrue: 
			[buffer nextPut: currentCharacter.
			self step]
%

category: 'error handling'
method: RBScanner
scannerError: aString 
	"Evaluate the block. If it returns raise an error"

	self errorBlock value: aString value: self errorPosition.
	self error: aString
%

category: 'private-scanning'
method: RBScanner
scanNumber
	| start number stop string |
	start := stream position.
	stream position: start - 1.
	number := Number rwFromStream: stream.
	stop := stream position.
	stream position: start - 1.
	string := stream next: stop - start + 1.
	stream position: stop.
	self step.
	^RBNumberLiteralToken 
		value: number
		start: start
		stop: stop
		source: string
%

category: 'private-scanning'
method: RBScanner
scanPathName
  [ 
  (characterType = #'alphabetic' or: [ characterType = #'digit' ])
    or: [ 
      ((currentCharacter = $. or: [ currentCharacter = $| ])
        and: [ 'abcdefghijklmnopqrstuvwxyz' includes: stream peek ])
        or: [ 
          (currentCharacter = $. and: [ stream peek = $* ])
            or: [ currentCharacter = $* and: [ stream peek = $. ] ] ] ] ]
    whileTrue: [ 
      buffer nextPut: currentCharacter.
      self step ]
%

category: 'private-scanning'
method: RBScanner
scanPatternVariable
	buffer nextPut: currentCharacter.
	self step.
	currentCharacter = ${ 
		ifTrue: 
			[self step.
			^RBPatternBlockToken value: '`{' start: tokenStart].
	[characterType = #alphabetic] whileFalse: 
			[characterType = #eof 
				ifTrue: [self scannerError: 'Meta variable expected'].
			buffer nextPut: currentCharacter.
			self step].
	^self scanIdentifierOrKeyword
%

category: 'private-scanning'
method: RBScanner
scanSpecialCharacter
	| character |
	currentCharacter = $: 
		ifTrue: 
			[self step.
			^currentCharacter = $= 
				ifTrue: 
					[self step.
					RBAssignmentToken start: tokenStart]
				ifFalse: [RBSpecialCharacterToken value: $: start: tokenStart]].
	currentCharacter = $_ ifTrue:
		[ self step.  ^RBShortAssignmentToken start: tokenStart ].
	character := currentCharacter.
	self step.
	^RBSpecialCharacterToken value: character start: tokenStart
%

category: 'private-scanning'
method: RBScanner
scanStringSymbol
	| literalToken |
	literalToken := self scanLiteralString.
	literalToken value: literalToken value asSymbol.
	^literalToken
%

category: 'private-scanning'
method: RBScanner
scanSymbol
	[ characterType = #alphabetic or: [ currentCharacter = $: ] ] whileTrue: [
		self scanName.
		currentCharacter = $: ifTrue: [
			buffer nextPut: $:.
			self step ] ].
	^ RBLiteralToken 
		value: buffer contents asSymbol
		start: tokenStart
		stop: self previousStepPosition
%

category: 'accessing'
method: RBScanner
scanToken
	"fast-n-ugly. Don't write stuff like this. Has been found to cause cancer in laboratory rats. Basically a 
	case statement. Didn't use Dictionary because lookup is pretty slow."

	characterType = #alphabetic ifTrue: [^self scanIdentifierOrKeyword].
	(characterType = #digit 
		or: [currentCharacter = $- and: [(self classify: stream peek) = #digit]]) 
			ifTrue: [^self scanNumber].
	characterType = #binary ifTrue: [^self scanBinary: RBBinarySelectorToken].
	characterType = #special ifTrue: [^self scanSpecialCharacter].
	currentCharacter = $' ifTrue: [^self scanLiteralString].
	currentCharacter = $# ifTrue: [^self scanLiteral].
	currentCharacter = $$ ifTrue: [^self scanLiteralCharacter].
	^self scannerError: 'Unknown character'
%

category: 'private'
method: RBScanner
step
	stream atEnd 
		ifTrue: 
			[characterType := #eof.
			^currentCharacter := nil].
	currentCharacter := stream next.
	characterType := self classify: currentCharacter.
	^currentCharacter
%

category: 'private-scanning'
method: RBScanner
stripComment
	| start stop |
	start := stream position.
	[self step = $"] whileFalse: 
			[characterType = #eof
				ifTrue: [self scannerError: 'Unmatched " in comment.']].
	stop := stream position.
	self step.
	comments add: (start to: stop)
%

category: 'private-scanning'
method: RBScanner
stripSeparators
	
	[[characterType = #separator] whileTrue: [self step].
	currentCharacter = $"] 
			whileTrue: [self stripComment]
%

! Class implementation for 'RBPatternScanner'

!		Class methods for 'RBPatternScanner'

category: 'class initialization'
classmethod: RBPatternScanner
initialize
  "force initialization on load"

  "self initialize"

  super initialize
%

!		Instance methods for 'RBPatternScanner'

category: 'accessing'
method: RBPatternScanner
scanToken
	currentCharacter = PatternVariableCharacter 
		ifTrue: [^self scanPatternVariable].
	currentCharacter = $} ifTrue: [^self scanSpecialCharacter].
	^super scanToken
%

! Class implementation for 'RBTonelScanner'

!		Instance methods for 'RBTonelScanner'

category: 'private'
method: RBTonelScanner
peekTonelFor: aCharacterType value: aCharacterValue

	^ currentCharacter = aCharacterValue and: [ characterType =  aCharacterType ]
%

category: 'error handling'
method: RBTonelScanner
stream
	^stream
%

category: 'accessing'
method: RBTonelScanner
tonelNext
	"only used when parsing the tonel method selector line"

	| token |
(characterType == #special and: [currentCharacter = $[ ])
	ifFalse: [ 
		 characterType ~~ #eof
			ifTrue: [ self error: 'Cannot parse Tonel method body. Missing ''[''.' ] ].
	buffer reset.
	tokenStart := stream position.
	token := characterType = #eof 
				ifTrue: 
					[RBToken start: tokenStart + 1	"The EOF token should occur after the end of input"]
				ifFalse: [self scanToken].
	self stripSeparators.
"don't read comments"
	false ifTrue: [ token comments: self getComments ].
"skip the $[ and get next token"
	^self next
%

! Class implementation for 'RBSmallDictionary'

!		Class methods for 'RBSmallDictionary'

category: 'instance creation'
classmethod: RBSmallDictionary
new
	^ self new: 2
%

category: 'instance creation'
classmethod: RBSmallDictionary
new: anInteger 
	^ self basicNew initialize: anInteger
%

!		Instance methods for 'RBSmallDictionary'

category: 'accessing'
method: RBSmallDictionary
at: aKey
	"Answer the value associated with aKey. Raise an exception, if no such key is defined."

	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]
%

category: 'accessing'
method: RBSmallDictionary
at: aKey ifAbsent: aBlock
	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index ]
		ifTrue: [ aBlock value ]
%

category: 'accessing'
method: RBSmallDictionary
at: aKey ifAbsentPut: aBlock
	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index ]
		ifTrue: [ self privateAt: aKey put: aBlock value ]
%

category: 'accessing'
method: RBSmallDictionary
at: aKey put: aValue
	"Set the value of aKey to be aValue."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index put: aValue ]
		ifTrue: [ self privateAt: aKey put: aValue ]
%

category: 'accessing'
method: RBSmallDictionary
empty
	tally := 0
%

category: 'private'
method: RBSmallDictionary
errorKeyNotFound
	self error: 'Key not found'
%

category: 'private'
method: RBSmallDictionary
findIndexFor: aKey
	1 to: tally do: [ :index |
		(keys at: index) = aKey
			ifTrue: [ ^ index ] ].
	^ 0
%

category: 'private'
method: RBSmallDictionary
grow
	| newKeys newValues |
	newKeys := Array new: 2 * tally.
	newValues := Array new: 2 * tally.
	1 to: tally do: [ :index |
		newKeys at: index put: (keys at: index).
		newValues at: index put: (values at: index) ].
	keys := newKeys.
	values := newValues
%

category: 'testing'
method: RBSmallDictionary
includesKey: aKey
	"Answer whether the receiver has a key equal to aKey."

	^ (self findIndexFor: aKey) ~= 0
%

category: 'initialization'
method: RBSmallDictionary
initialize: anInteger
	tally := 0.
	keys := Array new: anInteger.
	values := Array new: anInteger
%

category: 'testing'
method: RBSmallDictionary
isEmpty
	^ tally = 0
%

category: 'accessing'
method: RBSmallDictionary
keys
	^ keys copyFrom: 1 to: tally
%

category: 'enumerating'
method: RBSmallDictionary
keysAndValuesDo: aBlock
	1 to: tally do: [ :index | aBlock value: (keys at: index) value: (values at: index) ]
%

category: 'enumerating'
method: RBSmallDictionary
keysDo: aBlock
	1 to: tally do: [ :each | aBlock value: (keys at: each) ]
%

category: 'copying'
method: RBSmallDictionary
postCopy
	super postCopy.
	keys := keys copy.
	values := values copy
%

category: 'private'
method: RBSmallDictionary
privateAt: aKey put: aValue
	tally = keys size ifTrue: [ self grow ].
	keys at: (tally := tally + 1) put: aKey.
	^ values at: tally put: aValue
%

category: 'removing'
method: RBSmallDictionary
removeKey: aKey
	"Remove aKey from the receiver, raise an exception if the element is missing."

	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]
%

category: 'removing'
method: RBSmallDictionary
removeKey: aKey ifAbsent: aBlock
	"Remove aKey from the receiver, evaluate aBlock if the element is missing."

	| index value |
	index := self findIndexFor: aKey.
	index = 0 ifTrue: [ ^ aBlock value ].
	value := values at: index.
	index to: tally - 1 do: [ :i |
		keys at: i put: (keys at: i + 1).
		values at: i put: (values at: i + 1) ].
	keys at: tally put: nil.
	values at: tally put: nil.
	tally := tally - 1.
	^ value
%

category: 'accessing'
method: RBSmallDictionary
size
	^ tally
%

category: 'accessing'
method: RBSmallDictionary
values
	^ values copyFrom: 1 to: tally
%

category: 'enumerating'
method: RBSmallDictionary
valuesDo: aBlock
	1 to: tally do: [ :index | aBlock value: (values at: index) ]
%

! Class implementation for 'RBStringReplacement'

!		Class methods for 'RBStringReplacement'

category: 'instance creation'
classmethod: RBStringReplacement
replaceFrom: startInteger to: stopInteger with: aString 
	^(self new)
		startPosition: startInteger;
		stopPosition: stopInteger;
		string: aString;
		yourself
%

!		Instance methods for 'RBStringReplacement'

category: 'accessing'
method: RBStringReplacement
startPosition
	^startPosition
%

category: 'initialize-release'
method: RBStringReplacement
startPosition: anInteger 
	startPosition := anInteger
%

category: 'accessing'
method: RBStringReplacement
stopPosition
	^stopPosition
%

category: 'initialize-release'
method: RBStringReplacement
stopPosition: anInteger 
	stopPosition := anInteger
%

category: 'accessing'
method: RBStringReplacement
string
	^string
%

category: 'initialize-release'
method: RBStringReplacement
string: aString 
	string := aString
%

! Class implementation for 'RBToken'

!		Class methods for 'RBToken'

category: 'instance creation'
classmethod: RBToken
start: anInterval 
	^self new start: anInterval
%

!		Instance methods for 'RBToken'

category: 'accessing'
method: RBToken
comments
	^comments
%

category: 'accessing'
method: RBToken
comments: anObject
	comments := anObject
%

category: 'testing'
method: RBToken
isAssignment
	^false
%

category: 'testing'
method: RBToken
isBinary
	^false
%

category: 'testing'
method: RBToken
isIdentifier
	^false
%

category: 'testing'
method: RBToken
isKeyword
	^false
%

category: 'testing'
method: RBToken
isLiteral
	^self isLiteralToken
%

category: 'testing'
method: RBToken
isLiteralArrayToken
	^false
%

category: 'testing'
method: RBToken
isLiteralToken
	^false
%

category: 'testing'
method: RBToken
isPath
  ^ false
%

category: 'testing'
method: RBToken
isPatternBlock
	^false
%

category: 'testing'
method: RBToken
isPatternVariable
	^false
%

category: 'testing'
method: RBToken
isSpecial
	^false
%

category: 'accessing'
method: RBToken
length
	^self subclassResponsibility
%

category: 'printing'
method: RBToken
printOn: aStream 
	aStream
		nextPut: $ ;
		nextPutAll: self class name
%

category: 'printing'
method: RBToken
rbStoreString

"Returns a string that, when evaluated, will recreate a copy of the
 receiver.  The default is to use storeOn: to create the description."

| stream str |
str := String new.
stream := WriteStreamPortable on: str.
self rbStoreOn: stream.
^str
%

category: 'accessing'
method: RBToken
removePositions
	sourcePointer := nil
%

category: 'accessing'
method: RBToken
start
	^ sourcePointer ifNil: [ 0 ]
%

category: 'initialize-release'
method: RBToken
start: anInteger 
	sourcePointer := anInteger
%

category: 'accessing'
method: RBToken
stop
	^ sourcePointer isNil 
		ifTrue: [ -1 ]
		ifFalse: [ self start + self length - 1 ]
%

! Class implementation for 'RBAssignmentToken'

!		Instance methods for 'RBAssignmentToken'

category: 'testing'
method: RBAssignmentToken
isAssignment
	^true
%

category: 'private'
method: RBAssignmentToken
length
	^2
%

! Class implementation for 'RBShortAssignmentToken'

!		Instance methods for 'RBShortAssignmentToken'

category: 'private'
method: RBShortAssignmentToken
length
	^ 1
%

! Class implementation for 'RBValueToken'

!		Class methods for 'RBValueToken'

category: 'instance creation'
classmethod: RBValueToken
value: aString start: anInteger 
	^self new value: aString start: anInteger
%

!		Instance methods for 'RBValueToken'

category: 'private'
method: RBValueToken
length
	^value size
%

category: 'printing'
method: RBValueToken
printOn: aStream
	super printOn: aStream.
	aStream nextPut: $(.
	value printOn: aStream.
	aStream nextPutAll: ')'
%

category: 'accessing'
method: RBValueToken
value
	^value
%

category: 'accessing'
method: RBValueToken
value: anObject
	value := anObject
%

category: 'initialize-release'
method: RBValueToken
value: aString start: anInteger 
	value := aString.
	sourcePointer := anInteger
%

! Class implementation for 'RBBinarySelectorToken'

!		Instance methods for 'RBBinarySelectorToken'

category: 'testing'
method: RBBinarySelectorToken
isBinary
	^true
%

! Class implementation for 'RBIdentifierToken'

!		Instance methods for 'RBIdentifierToken'

category: 'testing'
method: RBIdentifierToken
isIdentifier
	^true
%

category: 'testing'
method: RBIdentifierToken
isPatternVariable
	^value first = RBScanner patternVariableCharacter
%

! Class implementation for 'RBPathToken'

!		Instance methods for 'RBPathToken'

category: 'testing'
method: RBPathToken
isPath
  ^ true
%

! Class implementation for 'RBKeywordToken'

!		Instance methods for 'RBKeywordToken'

category: 'testing'
method: RBKeywordToken
isKeyword
	^true
%

category: 'testing'
method: RBKeywordToken
isPatternVariable
	^value first = RBScanner patternVariableCharacter
%

! Class implementation for 'RBLiteralArrayToken'

!		Instance methods for 'RBLiteralArrayToken'

category: 'testing'
method: RBLiteralArrayToken
isForByteArray
	^value last = $[
%

category: 'testing'
method: RBLiteralArrayToken
isLiteralArrayToken
	^true
%

! Class implementation for 'RBLiteralToken'

!		Class methods for 'RBLiteralToken'

category: 'instance creation'
classmethod: RBLiteralToken
value: anObject 
	| literal |
	literal := anObject class == Array 
				ifTrue: [anObject collect: [:each | self value: each]]
				ifFalse: [anObject].
	^self 
		value: literal
		start: nil
		stop: nil
%

category: 'instance creation'
classmethod: RBLiteralToken
value: aString start: anInteger stop: stopInteger 
	^(self new)
		value: aString
			start: anInteger
			stop: stopInteger;
		yourself
%

!		Instance methods for 'RBLiteralToken'

category: 'testing'
method: RBLiteralToken
isLiteralToken
	^true
%

category: 'testing'
method: RBLiteralToken
isMultiKeyword
	^false
%

category: 'private'
method: RBLiteralToken
length
	^stopPosition - self start + 1
%

category: 'printing'
method: RBLiteralToken
rbStoreOn: aStream
    value isSymbol
        ifTrue: [ 
            aStream nextPut: $#.
            value asString printOn: aStream.
            ^ self ].
    value class == Character
        ifTrue: [ 
            aStream
                nextPut: $$;
                nextPut: value.
            ^ self ].
    value rbStoreOn: aStream
%

category: 'accessing'
method: RBLiteralToken
realValue
	^value
%

category: 'accessing'
method: RBLiteralToken
stop: anObject 
	stopPosition := anObject
%

category: 'initialize-release'
method: RBLiteralToken
value: aString start: anInteger stop: stopInteger 
	value := aString.
	sourcePointer := anInteger.
	stopPosition := stopInteger
%

! Class implementation for 'RBMultiKeywordLiteralToken'

!		Instance methods for 'RBMultiKeywordLiteralToken'

category: 'testing'
method: RBMultiKeywordLiteralToken
isMultiKeyword
	^true
%

! Class implementation for 'RBNumberLiteralToken'

!		Class methods for 'RBNumberLiteralToken'

category: 'instance creation'
classmethod: RBNumberLiteralToken
value: aNumber start: anInteger stop: stopInteger source: sourceString 
	^(self 
		value: aNumber
		start: anInteger
		stop: stopInteger)
		source: sourceString;
		yourself
%

!		Instance methods for 'RBNumberLiteralToken'

category: 'printing'
method: RBNumberLiteralToken
rbStoreOn: aStream 
	aStream nextPutAll: source
%

category: 'accessing'
method: RBNumberLiteralToken
source
	^source
%

category: 'initialize-release'
method: RBNumberLiteralToken
source: aString 
	source := aString
%

! Class implementation for 'RBPatternBlockToken'

!		Instance methods for 'RBPatternBlockToken'

category: 'testing'
method: RBPatternBlockToken
isPatternBlock
	^true
%

! Class implementation for 'RBSpecialCharacterToken'

!		Instance methods for 'RBSpecialCharacterToken'

category: 'testing'
method: RBSpecialCharacterToken
isSpecial
	^true
%

category: 'private'
method: RBSpecialCharacterToken
length
	^1
%

! Class implementation for 'Rowan'

!		Class methods for 'Rowan'

category: 'public client services'
classmethod: Rowan
answeringServiceClass

	^ self platform answeringServiceClass
%

category: 'public'
classmethod: Rowan
automaticClassInitializationBlackList

	"Answer list of project names for which automatic class initialiation should be disabled."

	^ self platform automaticClassInitializationBlackList
%

category: 'public client services'
classmethod: Rowan
browserServiceClass

	^ self platform browserServiceClass
%

category: 'public client services'
classmethod: Rowan
classServiceClass

	^ self platform classServiceClass
%

category: 'public tools'
classmethod: Rowan
classTools

	^ self platform classTools
%

category: 'public'
classmethod: Rowan
clearAutomaticClassInitializationBlackList

	"Clear list of project names for which automatic class initialiation should be disabled."

	^ self platform clearAutomaticClassInitializationBlackList
%

category: 'public'
classmethod: Rowan
clearDefaultAutomaticClassInitializationBlackList

	"Clear default list of project names for which automatic class initialiation should be disabled.
		Individual users may override the black list."

	^ self platform clearAutomaticClassInitializationBlackList_default
%

category: 'public client services'
classmethod: Rowan
commandResultClass

	^ self platform commandResultClass
%

category: 'public'
classmethod: Rowan
configuration

	^configuration
%

category: 'public'
classmethod: Rowan
defaultAutomaticClassInitializationBlackList

	"Answer default list of project names for which automatic class initialiation should be disabled.
		Individual users may override the black list."

	^ self platform automaticClassInitializationBlackList_default
%

category: 'public tools'
classmethod: Rowan
gitTools

	^ self platform gitTools
%

category: 'public'
classmethod: Rowan
globalNamed: aName

	"Answer a global object with the given name.  If no object with the given name is found, returns nil."

	^ self platform globalNamed: aName
%

category: 'private'
classmethod: Rowan
image
	"Private to the Cypress system."

	^self platform image
%

category: 'public client services'
classmethod: Rowan
jadeServerClassNamed: className

	^ self platform jadeServerClassNamed: className
%

category: 'public client services'
classmethod: Rowan
loggingServiceClass

	^ self platform loggingServiceClass
%

category: 'public client services'
classmethod: Rowan
methodServiceClass

	^ self platform methodServiceClass
%

category: 'public'
classmethod: Rowan
packageNames

	"Return list of package names"

	^ self image packageNames
%

category: 'public client services'
classmethod: Rowan
packageServiceClass

	^ self platform packageServiceClass
%

category: 'public tools'
classmethod: Rowan
packageTools

	^self platform packageTools
%

category: 'private'
classmethod: Rowan
platform

	^ RwPlatform current
%

category: 'public'
classmethod: Rowan
platformConditionalAttributes

	"Return list of platform-specific conditional attributes for use by components"

	^ self platform platformConditionalAttributes
%

category: 'public'
classmethod: Rowan
projectNamed: aName

	"Answer a project with the given name.  If no project with the given name is found, signals error."

	^ self 
		projectNamed: aName 
			ifPresent: [:loadedProject | loadedProject ]
			ifAbsent: [ self error: 'The project ', aName printString, ' was not found' ]
%

category: 'public'
classmethod: Rowan
projectNamed: aName ifAbsent: absentBlock

	"Lookup a project with the given name, if found return the project. if not found evaluate the <absentBlock>."

	^ self 
		projectNamed: aName 
			ifPresent: [:loadedProject | loadedProject ]
			ifAbsent: absentBlock
%

category: 'public'
classmethod: Rowan
projectNamed: aName ifPresent: presentBlock

	"Lookup a project with the given name, if found evaluate the <presentBlock>. if not found return nil."

	^ self 
		projectNamed: aName 
			ifPresent: presentBlock
			ifAbsent: []
%

category: 'public'
classmethod: Rowan
projectNamed: aName ifPresent: presentBlock ifAbsent: absentBlock

	"Lookup a project with the given name, if found evaluate the <presentBlock>, if not evaluate the <absentBlock.."

	^ self platform 
		projectNamed: aName 
			ifPresent: presentBlock 
			ifAbsent: absentBlock
%

category: 'public'
classmethod: Rowan
projectNames

	"Return list of project names"

	^ self image projectNames
%

category: 'public'
classmethod: Rowan
projects
	"Return list of projects"

	^ self projectNames collect: [ :projectName | self projectNamed: projectName ]
%

category: 'public client services'
classmethod: Rowan
projectServiceClass

	^ self platform projectServiceClass
%

category: 'public tools'
classmethod: Rowan
projectTools

	^self platform projectTools
%

category: 'public client services'
classmethod: Rowan
serviceClass

	^ self platform serviceClass
%

category: 'public'
classmethod: Rowan
unpackagedName
	"Answer the name used for projects and packages that are not in a package ... unpackaged projects and packages are where pacakge things go by default."

	^ '(NONE)'
%

category: 'public'
classmethod: Rowan
unpackagedPackagePrefix
	"Answer the prefix used for naming unpackaged packages"

	^ self unpackagedProjectName , '-'
%

category: 'public'
classmethod: Rowan
unpackagedProjectName
	"Answer the name of the unpackaged project that manages unpackaged things"

	^ 'UnPackaged'
%

category: 'public'
classmethod: Rowan
version
	^ RwSemanticVersionNumber fromString: self versionString
%

category: 'public'
classmethod: Rowan
versionString
	^ '2.3.0'
%

! Class implementation for 'RowanCommandResult'

!		Class methods for 'RowanCommandResult'

category: 'accessing'
classmethod: RowanCommandResult
addResult: service
	service command: nil;
			commandArgs: nil. 
	self updateClientBoundServices: service.
	^service
%

category: 'accessing'
classmethod: RowanCommandResult
basicAddResult: service
	self results add: service
%

category: 'initailize'
classmethod: RowanCommandResult
initializeResults

	SessionTemps current at: #rowanCommandResults put: Array new.
%

category: 'instance creation'
classmethod: RowanCommandResult
new

	| inst |
	inst := super new initialize.
	self addResult: inst.
	^inst
%

category: 'accessing'
classmethod: RowanCommandResult
removeResult: aResult

	self results remove: aResult
%

category: 'accessing'
classmethod: RowanCommandResult
results

	"lazy initialize for a topaz session test" 
	^SessionTemps current at: #rowanCommandResults ifAbsentPut: [Array new]
%

category: 'private'
classmethod: RowanCommandResult
updateClientBoundServices: clientBoundService
	"We're about to add a service to the results collection. 
	That service will be sent to the client. Since services
	are not canonical, we need to do some housekeeping
	to ensure that we don't already have this service 
	somewhere in other client-bound services"
	(self results includes: clientBoundService) ifTrue:[
		self removeResult: clientBoundService].
	self basicAddResult: clientBoundService. 
	self results do:[:service |
		service updateInternalService: clientBoundService.
		clientBoundService updateInternalService: service].
%

!		Instance methods for 'RowanCommandResult'

category: 'accessing'
method: RowanCommandResult
command: anObject

	"results don't have commands"
%

category: 'accessing'
method: RowanCommandResult
commandArgs: anObject

	"results don't have commandArgs"
%

category: 'initialization'
method: RowanCommandResult
initialize
%

category: 'testing'
method: RowanCommandResult
isMethodService

	^false
%

category: 'private'
method: RowanCommandResult
rowanFixMe
%

category: 'accessing'
method: RowanCommandResult
updateInternalService: service
%

! Class implementation for 'RowanGsGeneralDependencySorter'

!		Class methods for 'RowanGsGeneralDependencySorter'

category: 'instance creation'
classmethod: RowanGsGeneralDependencySorter
on: someCandidates dependsOn: aOneArgBlock dependent: anotherOneArgBlock
	"Create an instance of the receiver capable for sorting the dependencies of someCandidates.
	 aOneArgBlock is used to evaluate the key of the object depended on for a candidate.
	 anotherOneArgBlock is used to evaluate the key of the candidate itself."

	^self new
		initializeOn: someCandidates dependsOn: aOneArgBlock dependent: anotherOneArgBlock;
		yourself.
%

!		Instance methods for 'RowanGsGeneralDependencySorter'

category: 'sorting - private'
method: RowanGsGeneralDependencySorter
determineGraphRoots
  ^ dependencyGraphs
    selectAssociations: [ :each | (candidateAliasMap includesKey: each key) not ]
%

category: 'initializing - private'
method: RowanGsGeneralDependencySorter
initializeOn: someCandidates dependsOn: aOneArgBlock dependent: anotherOneArgBlock

	candidates := someCandidates.
	dependsOnConverter := aOneArgBlock.
	dependentConverter := anotherOneArgBlock.
	individualDependencyMap := Dictionary new.
	dependencyGraphs := Dictionary new.
	candidateAliasMap := Dictionary new
%

category: 'sorting'
method: RowanGsGeneralDependencySorter
inOrder
  | sorted sortedRoots |
  sorted := OrderedCollection new.
  self mapCandidatesIntoGraphs.
  sortedRoots := SortedCollection sortBlock: [ :a :b | a key <= b key ].
  self determineGraphRoots associationsDo: [ :assoc | sortedRoots add: assoc ].
  sortedRoots do: [ :assoc | self transcribeGraph: assoc value into: sorted ].
  ^ sorted
%

category: 'sorting - private'
method: RowanGsGeneralDependencySorter
mapCandidatesIntoGraphs

	| dependsOnKey dependentKey |
	candidates do: 
			[:each |
			| individualDependency |
			dependsOnKey := dependsOnConverter value: each.
			dependentKey := dependentConverter value: each.
			candidateAliasMap at: dependentKey put: each.
			individualDependencyMap at: dependsOnKey ifAbsentPut: [Dictionary new].
			individualDependencyMap at: dependentKey ifAbsentPut: [Dictionary new].
			individualDependency := individualDependencyMap
						associationAt: dependsOnKey.
			(dependencyGraphs includesKey: dependsOnKey)
				ifFalse: [dependencyGraphs add: individualDependency].
			individualDependency value
				add: (individualDependencyMap associationAt: dependentKey)]
%

category: 'sorting - private'
method: RowanGsGeneralDependencySorter
transcribeGraph: subtree into: sorted
  (subtree keys asSortedCollection: [ :a :b | a <= b ])
    do: [ :name | | subsubtree |
      subsubtree := subtree at: name.
      sorted add: (candidateAliasMap at: name).
      self transcribeGraph: subsubtree into: sorted ]
%

! Class implementation for 'RowanInterface'

!		Class methods for 'RowanInterface'

category: 'instance creation'
classmethod: RowanInterface
newNamed: aName

	^ self new
		initializeForName: aName;
		yourself
%

!		Instance methods for 'RowanInterface'

category: 'accessing'
method: RowanInterface
classes

	| classes |
	classes := IdentitySet new.
	classes
		addAll: self extendedClasses;
		addAll: self definedClasses.
	^ classes
%

category: 'accessing'
method: RowanInterface
definedClasses

	^ self subclassResponsibility: #'definedClasses'
%

category: 'accessing'
method: RowanInterface
extendedClasses

	^ self subclassResponsibility: #'extendedClasses'
%

category: 'initialization'
method: RowanInterface
initializeForName: aName

	name := aName
%

category: 'accessing'
method: RowanInterface
name

	^ name
%

category: 'printing'
method: RowanInterface
printOn: aStream
	super printOn: aStream.
	self name
		ifNotNil: [:aString |
			aStream
				nextPutAll: ' for ';
				nextPutAll:  aString ]
%

category: 'accessing'
method: RowanInterface
project

	^ RwProject newNamed: self _loadedProject name
%

category: 'private'
method: RowanInterface
_loadedProject

	^ self subclassResponsibility: #'_loadedProject'
%

category: 'private'
method: RowanInterface
_projectTools

	^ Rowan projectTools
%

! Class implementation for 'RwAbstractProject'

!		Instance methods for 'RwAbstractProject'

category: 'transitions'
method: RwAbstractProject
defined
	self subclassResponsibility: #'defined'
%

category: 'accessing'
method: RwAbstractProject
project

	^ self
%

category: 'transitions'
method: RwAbstractProject
resolve
	self subclassResponsibility: #'resolve'
%

! Class implementation for 'RwAbstractUnloadedProject'

!		Instance methods for 'RwAbstractUnloadedProject'

category: 'accessing'
method: RwAbstractUnloadedProject
comment: aString
	self _resolvedProject comment: aString
%

category: 'accessing'
method: RwAbstractUnloadedProject
diskUrl: aString
	self _loadSpecification diskUrl: aString
%

category: 'accessing'
method: RwAbstractUnloadedProject
gemstoneSetDefaultSymbolDictNameTo: symbolDictName
	self _resolvedProject gemstoneSetDefaultSymbolDictNameTo: symbolDictName
%

category: 'accessing'
method: RwAbstractUnloadedProject
gitUrl: aString
	self _loadSpecification gitUrl: aString
%

category: 'transitions'
method: RwAbstractUnloadedProject
load
	"
		load only the receiver into the image. Required projects for the receiver are only loaded if they are not already 
			present in the image.

		To explicitly load the receiver AND required projects, construct a project set containing projects to be loaded 
			and send #load to the project set.
	"

	^ self _resolvedProject load
%

category: 'accessing'
method: RwAbstractUnloadedProject
packageFormat: aString
	^ self _resolvedProject packageFormat: aString
%

category: 'accessing'
method: RwAbstractUnloadedProject
packageNames
	^self _resolvedProject packageNames
%

category: 'actions'
method: RwAbstractUnloadedProject
packages
	^ self _resolvedProject packages
%

category: 'actions'
method: RwAbstractUnloadedProject
packages: aPackageDictionary
	self _resolvedProject packages: aPackageDictionary
%

category: 'accessing'
method: RwAbstractUnloadedProject
projectsHome
	^self _resolvedProject projectsHome
%

category: 'accessing'
method: RwAbstractUnloadedProject
projectsHome: aProjectHomeReferenceOrString
	self _resolvedProject projectsHome: aProjectHomeReferenceOrString
%

category: 'accessing'
method: RwAbstractUnloadedProject
repositoryResolutionPolicy
	^ self _loadSpecification repositoryResolutionPolicy
%

category: 'accessing'
method: RwAbstractUnloadedProject
repositoryResolutionPolicy: aSymbolOrNil
	self _loadSpecification repositoryResolutionPolicy: aSymbolOrNil
%

category: 'accessing'
method: RwAbstractUnloadedProject
specComment: aString
	self _loadSpecification comment: aString
%

category: 'accessing'
method: RwAbstractUnloadedProject
specComponentNames: anArray
	self _loadSpecification componentNames: anArray
%

category: 'accessing'
method: RwAbstractUnloadedProject
specName
	^ self _loadSpecification specName
%

category: 'testing'
method: RwAbstractUnloadedProject
useGit

	^self _resolvedProject useGit
%

category: 'private'
method: RwAbstractUnloadedProject
_loadSpecification
	^ self _resolvedProject _loadSpecification
%

category: 'private'
method: RwAbstractUnloadedProject
_resolvedProject
	^ resolvedProject
%

category: 'private'
method: RwAbstractUnloadedProject
_resolvedProject: aResolvedProject
	resolvedProject := aResolvedProject
%

! Class implementation for 'RwDefinedProject'

!		Class methods for 'RwDefinedProject'

category: 'instance creation'
classmethod: RwDefinedProject
fromLoadedProject: aLoadedProject
	^ (self newNamed: aLoadedProject name)
		_resolvedProject: aLoadedProject _loadedProject asDefinition;
		yourself
%

category: 'instance creation'
classmethod: RwDefinedProject
fromResolvedProject: aResolvedProject
	^ (self newNamed: aResolvedProject name)
		_resolvedProject: aResolvedProject _resolvedProject;
		yourself
%

category: 'instance creation'
classmethod: RwDefinedProject
newEmbeddedProjectNamed: aName
	| new spec |
	new := self new initializeForName: aName.
	spec := RwEmbeddedLoadSpecificationV2 new
		projectName: aName;
		yourself.
	new _resolvedProject _loadSpecification: spec.
	^ new
%

category: 'instance creation'
classmethod: RwDefinedProject
newNamed: aName

	^ self new
		initializeForName: aName;
		_resolvedProject;
		yourself
%

!		Instance methods for 'RwDefinedProject'

category: 'accessing'
method: RwDefinedProject
addComponentNamed: componentName toComponentNamed: toComponentName
	^ self _resolvedProject
		addComponentNamed: componentName
		toComponentNamed: toComponentName
%

category: 'components'
method: RwDefinedProject
addComponentStructureFor: componentBasename pathNameArray: pathNameArray conditionPathArray: conditionPathArray
	^ self
		addComponentStructureFor: componentBasename
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: ''
%

category: 'components'
method: RwDefinedProject
addComponentStructureFor: componentBasename pathNameArray: pathNameArray conditionPathArray: conditionPathArray comment: aString
	^ self _resolvedProject
		addComponentStructureFor: componentBasename
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: aString
%

category: 'components'
method: RwDefinedProject
addComponentStructureFor: componentBasename startingAtComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray
	^ self
		addComponentStructureFor: componentBasename
		startingAtComponentNamed: toComponentName
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: ''
%

category: 'components'
method: RwDefinedProject
addComponentStructureFor: componentBasename startingAtComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray comment: aString
	^ self _resolvedProject
		addComponentStructureFor: componentBasename
		startingAtComponentNamed: toComponentName
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: aString
%

category: 'accessing'
method: RwDefinedProject
addNewComponentNamed: componentName
	^ self _resolvedProject addNewComponentNamed: componentName
%

category: 'accessing'
method: RwDefinedProject
addNewComponentNamed: aComponentName comment: aString
	^ self _resolvedProject addNewComponentNamed: aComponentName comment: aString
%

category: 'accessing'
method: RwDefinedProject
addNewComponentNamed: aComponentName condition: condition
	^ self _resolvedProject
		addNewComponentNamed: aComponentName
		condition: condition
%

category: 'accessing'
method: RwDefinedProject
addNewComponentNamed: aComponentName condition: condition comment: aString
	^ self _resolvedProject
		addNewComponentNamed: aComponentName
		condition: condition
		comment: aString
%

category: 'accessing'
method: RwDefinedProject
addNewComponentNamed: aComponentName toComponentNamed: toComponentName condition: conditionPathArray
	^ self _resolvedProject
		addNewComponentNamed: aComponentName
		toComponentNamed: toComponentName
		condition: conditionPathArray
%

category: 'accessing'
method: RwDefinedProject
addNewComponentNamed: aComponentName toComponentNamed: toComponentName condition: conditionPathArray comment: aString
	^ self _resolvedProject
		addNewComponentNamed: aComponentName
		toComponentNamed: toComponentName
		condition: conditionPathArray
		comment: aString
%

category: 'accessing'
method: RwDefinedProject
addNewNestedComponentNamed: aComponentName comment: aString
	^ self _resolvedProject
		addNewNestedComponentNamed: aComponentName
		comment: aString
%

category: 'accessing'
method: RwDefinedProject
addPackageNamed: packageName
	"the package is expected to already be present in a component - used when reading packages from disk"

	^ self _resolvedProject addPackageNamed: packageName
%

category: 'accessing'
method: RwDefinedProject
addPackageNamed: packageName toComponentNamed: componentName
	^ self _resolvedProject
		addPackageNamed: packageName
		toComponentNamed: componentName
%

category: 'accessing'
method: RwDefinedProject
addPackageNamed: packageName toComponentNamed: componentName gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc
	^ self _resolvedProject
		addPackageNamed: packageName
		toComponentNamed: componentName
		gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc
%

category: 'accessing'
method: RwDefinedProject
addPackagesNamed: packageName toComponentNamed: componentName
	^ self _resolvedProject
		addPackagesNamed: packageName
		toComponentNamed: componentName
%

category: 'accessing'
method: RwDefinedProject
addPlatformComponentNamed: aComponentName toComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray
	^ self _resolvedProject
		addPlatformComponentNamed: aComponentName
		toComponentNamed: toComponentName
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
%

category: 'accessing'
method: RwDefinedProject
addPlatformComponentNamed: aComponentName toComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray comment: aString
	^ self _resolvedProject
		addPlatformComponentNamed: aComponentName
		toComponentNamed: toComponentName
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: aString
%

category: 'accessing'
method: RwDefinedProject
addPostloadDoitName: doitName withSource: doitSource toComponentNamed: aComponentName
	^ self _resolvedProject
		addPostloadDoitName: doitName
		withSource: doitSource
		toComponentNamed: aComponentName
%

category: 'accessing'
method: RwDefinedProject
addPreloadDoitName: doitName withSource: doitSource toComponentNamed: aComponentName
	^ self _resolvedProject
		addPreloadDoitName: doitName
		withSource: doitSource
		toComponentNamed: aComponentName
%

category: 'accessing'
method: RwDefinedProject
addProjectNamed: projectName toComponentNamed: toComponentName
	^ self _resolvedProject
		addProjectNamed: projectName
		toComponentNamed: toComponentName
%

category: 'accessing'
method: RwDefinedProject
addRawPackageNamed: packageName
	^ self _resolvedProject addRawPackageNamed: packageName
%

category: 'accessing'
method: RwDefinedProject
addSimpleNestedComponentNamed: aComponentName condition: condition comment: commentString
	^ self _resolvedProject
		addSimpleNestedComponentNamed: aComponentName
		condition: condition
		comment: commentString
%

category: 'accessing'
method: RwDefinedProject
addTopLevelComponentNamed: componentName
	^ self _resolvedProject addTopLevelComponentNamed: componentName
%

category: 'accessing'
method: RwDefinedProject
addTopLevelComponentNamed: componentName  condition: condition
	^ self _resolvedProject addTopLevelComponentNamed: componentName  condition: condition
%

category: 'accessing'
method: RwDefinedProject
componentNamed: componentName
	^ self _resolvedProject componentNamed: componentName
%

category: 'accessing'
method: RwDefinedProject
componentNamed: aComponentName ifAbsent: absentBlock
	^ self _resolvedProject componentNamed: aComponentName ifAbsent: absentBlock
%

category: 'accessing'
method: RwDefinedProject
componentsPath: aString
	self _projectSpecification componentsPath: aString
%

category: 'accessing'
method: RwDefinedProject
customConditionalAttributes
	^ self _loadSpecification customConditionalAttributes
%

category: 'accessing'
method: RwDefinedProject
customConditionalAttributes: anArray
	self _loadSpecification customConditionalAttributes: anArray
%

category: 'transitions'
method: RwDefinedProject
defined
	^ self
%

category: 'accessing'
method: RwDefinedProject
gemstoneSetDefaultSymbolDictNameForUser: userId to: symbolDictName
	self _resolvedProject
		gemstoneSetDefaultSymbolDictNameForUser: userId
		to: symbolDictName
%

category: 'accessing'
method: RwDefinedProject
gemstoneSetSymbolDictName: symbolDictName forPackageNamed: packageName
	self _resolvedProject
		gemstoneSetSymbolDictName: symbolDictName
		forPackageNamed: packageName
%

category: 'testing'
method: RwDefinedProject
isStrict
	^ self _resolvedProject isStrict
%

category: 'transitions'
method: RwDefinedProject
loadProjectSet
	"
		refresh the contents of the receiver from disk and create a project set that includes project definitions of
			required projects, also read from disk. Then load the entire project set.
	"

	^ self _resolvedProject loadProjectSet
%

category: 'accessing'
method: RwDefinedProject
loadSpecification

	^ self _resolvedProject loadSpecification
%

category: 'accessing'
method: RwDefinedProject
moveClassNamed: aClassName toPackageNamed: aPackageName
	^ self _resolvedProject moveClassNamed: aClassName toPackageNamed: aPackageName
%

category: 'accessing'
method: RwDefinedProject
movePackageNamed: aPackageName toComponentNamed: aComponentName
	^ self _resolvedProject
		movePackageNamed: aPackageName
		toComponentNamed: aComponentName
%

category: 'accessing'
method: RwDefinedProject
packageConvention: aString
	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	self _projectSpecification packageConvention: aString
%

category: 'accessing'
method: RwDefinedProject
packageNamed: aString
	^ self _resolvedProject packageNamed: aString
%

category: 'accessing'
method: RwDefinedProject
packageNamed: aString ifAbsent: absentBlock
	^ self _resolvedProject packageNamed: aString ifAbsent: absentBlock
%

category: 'accessing'
method: RwDefinedProject
packagesPath: aString
	self _projectSpecification packagesPath: aString
%

category: 'accessing'
method: RwDefinedProject
projectAlias: aString
	^ self _resolvedProject projectAlias: aString
%

category: 'accessing'
method: RwDefinedProject
projectsPath: aString
	self _projectSpecification projectsPath: aString
%

category: 'accessing'
method: RwDefinedProject
projectSpecFile: relativePathString
	^ self _resolvedProject projectSpecFile: relativePathString
%

category: 'accessing'
method: RwDefinedProject
projectSpecPath: aString
	self _projectSpecification projectSpecPath: aString
%

category: 'accessing'
method: RwDefinedProject
projectsRoot
	^ self _resolvedProject projectsRoot
%

category: 'transitions'
method: RwDefinedProject
read
	"return a RwDefinedProject with definitions read from disk"

	self _resolvedProject read
%

category: 'transitions'
method: RwDefinedProject
read: platformConditionalAttributes
	"return a RwDefinedProject with definitions read from disk, using the specificied conditional attributes"

	self _resolvedProject read: platformConditionalAttributes
%

category: 'transitions'
method: RwDefinedProject
readProjectComponentNames: componentNames
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return the receiver with a new set of definitions read from disk"

	self _resolvedProject readProjectComponentNames: componentNames
%

category: 'transitions'
method: RwDefinedProject
readProjectComponentNames: componentNames customConditionalAttributes: customConditionalAttributes
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return the receiver with a new set of definitions read from disk"

	self _resolvedProject
		readProjectComponentNames: componentNames
		customConditionalAttributes: customConditionalAttributes
%

category: 'transitions'
method: RwDefinedProject
readProjectComponentNames: componentNames platformConditionalAttributes: platformConditionalAttributes
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return the receiver with a new set of definitions read from disk"

	self _resolvedProject
		readProjectComponentNames: componentNames
		platformConditionalAttributes: platformConditionalAttributes
%

category: 'transitions'
method: RwDefinedProject
readProjectSet
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return a project definition set that will contain the project definition along with any dependent project definitions"

	self _resolvedProject readProjectSet
%

category: 'transitions'
method: RwDefinedProject
readProjectSet: platformConditionalAttributes
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return a project definition set that will contain the project definition along with any dependent project definitions"

	self _resolvedProject readProjectSet: platformConditionalAttributes
%

category: 'accessing'
method: RwDefinedProject
removeComponentNamed: aComponentName
	^ self _resolvedProject removeComponentNamed: aComponentName
%

category: 'accessing'
method: RwDefinedProject
removePackageNamed: packageName
	^ self _resolvedProject removePackageNamed: packageName
%

category: 'accessing'
method: RwDefinedProject
removePackageNamed: packageName fromComponentNamed: componentName
	^ self _resolvedProject
		removePackageNamed: packageName
		fromComponentNamed: componentName
%

category: 'accessing'
method: RwDefinedProject
renameComponentNamed: aComponentPath to: aComponentName
	^ self _resolvedProject renameComponentNamed: aComponentPath to: aComponentName
%

category: 'accessing'
method: RwDefinedProject
renamePackageNamed: packageName to: newPackageName
	^ self _resolvedProject renamePackageNamed: packageName to: newPackageName
%

category: 'accessing'
method: RwDefinedProject
repositoryRoot
	^ self _resolvedProject repositoryRoot
%

category: 'accessing'
method: RwDefinedProject
repoType: aSymbol
	"#disk, #git or #none"

	self _resolvedProject repoType: aSymbol
%

category: 'transitions'
method: RwDefinedProject
resolve
	^ RwResolvedProject fromDefinedProject: self
%

category: 'transitions'
method: RwDefinedProject
resolveStrict
	^ RwResolvedProject fromStrictDefinedProject: self
%

category: 'accessing'
method: RwDefinedProject
resolveWithParentProject: aResolvedRwProject
	"give embedded projects a chance to resolve cleanly"

	^ (RwResolvedProject newNamed: self name)
		_resolvedProject:
				(self _loadSpecification
						resolveWithParentProject: aResolvedRwProject _resolvedProject) resolve;
		yourself
%

category: 'accessing'
method: RwDefinedProject
revision: aString
	self _loadSpecification revision: aString
%

category: 'accessing'
method: RwDefinedProject
specName: aString
	self _loadSpecification specName: aString
%

category: 'accessing'
method: RwDefinedProject
specsPath: aString
	self _projectSpecification specsPath: aString
%

category: 'private'
method: RwDefinedProject
_gemstoneAllUsersName
	^ self _resolvedProject _gemstoneAllUsersName
%

category: 'private'
method: RwDefinedProject
_loadSpecification
	^ self _resolvedProject _loadSpecification
%

category: 'private'
method: RwDefinedProject
_projectRepository
	^ self _resolvedProject _projectRepository
%

category: 'private'
method: RwDefinedProject
_projectSpecification
	^ self _resolvedProject _projectSpecification
%

category: 'private'
method: RwDefinedProject
_resolvedProject
	^ resolvedProject
		ifNil: [ 
			resolvedProject := RwResolvedProjectV2 new
				projectName: self name;
				yourself ]
%

category: 'accessing'
method: RwDefinedProject
_validate: platformConfigurationAttributes
	^ self _resolvedProject _validate: platformConfigurationAttributes
%

! Class implementation for 'RwResolvedProject'

!		Class methods for 'RwResolvedProject'

category: 'instance creation'
classmethod: RwResolvedProject
fromDefinedProject: aDefinedProject
	^ (self newNamed: aDefinedProject name)
		_resolvedProject: aDefinedProject _resolvedProject resolve;
		yourself
%

category: 'instance creation'
classmethod: RwResolvedProject
fromStrictDefinedProject: aDefinedProject
	| createBlock oldPolicy |
	createBlock := [ 
	(self newNamed: aDefinedProject name)
		_resolvedProject: aDefinedProject _resolvedProject resolve;
		yourself ].
	aDefinedProject isStrict
		ifTrue: [ ^ createBlock value ].
	oldPolicy := aDefinedProject repositoryResolutionPolicy.
	[ 
	aDefinedProject repositoryResolutionPolicy: #'strict'.
	^ createBlock value ]
		ensure: [ aDefinedProject repositoryResolutionPolicy: oldPolicy ]
%

category: 'instance creation'
classmethod: RwResolvedProject
projectFromUrl: loadSpecUrl
	| loadSpec resolvedProject |
	loadSpec := RwSpecification fromUrl: loadSpecUrl.
	resolvedProject := loadSpec resolve.
	^ (self newNamed: resolvedProject name)
		_resolvedProject: resolvedProject resolve;
		yourself
%

category: 'instance creation'
classmethod: RwResolvedProject
projectFromUrl: loadSpecUrl diskUrl: urlString
	| loadSpec resolvedProject |
	loadSpec := (RwSpecification fromUrl: loadSpecUrl)
		diskUrl: urlString;
		projectsHome: urlString asRwUrl pathString asFileReference parent;
		yourself.
	resolvedProject := loadSpec resolve.
	^ (self newNamed: resolvedProject name)
		_resolvedProject: resolvedProject resolve;
		yourself
%

category: 'instance creation'
classmethod: RwResolvedProject
projectFromUrl: loadSpecUrl gitUrl: urlString
	| loadSpec resolvedProject |
	loadSpec := (RwSpecification fromUrl: loadSpecUrl)
		gitUrl: urlString;
		projectsHome: urlString asRwUrl pathString asFileReference parent;
		yourself.
	resolvedProject := loadSpec resolve.
	^ (self newNamed: resolvedProject name)
		_resolvedProject: resolvedProject resolve;
		yourself
%

category: 'instance creation'
classmethod: RwResolvedProject
projectFromUrl: loadSpecUrl projectsHome: projectsHome
	| loadSpec resolvedProject |
	loadSpec := (RwSpecification fromUrl: loadSpecUrl)
		projectsHome: projectsHome;
		yourself.
	resolvedProject := loadSpec resolve.
	^ (self newNamed: resolvedProject name)
		_resolvedProject: resolvedProject resolve;
		yourself
%

category: 'instance creation'
classmethod: RwResolvedProject
projectFromUrl: loadSpecUrl projectsHome: projectsHome componentNames: componentNames
	| loadSpec resolvedProject |
	loadSpec := (RwSpecification fromUrl: loadSpecUrl)
		projectsHome: projectsHome;
		componentNames: componentNames;
		yourself.
	resolvedProject := loadSpec resolve.
	^ (self newNamed: resolvedProject name)
		_resolvedProject: resolvedProject resolve;
		yourself
%

category: 'instance creation'
classmethod: RwResolvedProject
projectFromUrl: loadSpecUrl projectsHome: projectsHome componentNames: componentNames customConditionalAttributes: customConditionalAttributes
	| loadSpec resolvedProject |
	loadSpec := (RwSpecification fromUrl: loadSpecUrl)
		projectsHome: projectsHome;
		componentNames: componentNames;
		customConditionalAttributes: customConditionalAttributes;
		yourself.
	resolvedProject := loadSpec resolve.
	^ (self newNamed: resolvedProject name)
		_resolvedProject: resolvedProject resolve;
		yourself
%

category: 'instance creation'
classmethod: RwResolvedProject
projectFromUrl: loadSpecUrl projectsHome: projectsHome componentNames: componentNames platformConditionalAttributes: platformConditionalAttributes
	| loadSpec resolvedProject |
	loadSpec := (RwSpecification fromUrl: loadSpecUrl)
		projectsHome: projectsHome;
		componentNames: componentNames;
		yourself.
	resolvedProject := loadSpec resolve: platformConditionalAttributes.
	^ (self newNamed: resolvedProject name)
		_resolvedProject: resolvedProject resolve;
		yourself
%

category: 'instance creation'
classmethod: RwResolvedProject
projectFromUrl: loadSpecUrl projectsHome: projectsHome customConditionalAttributes: customConditionalAttributes
	| loadSpec resolvedProject |
	loadSpec := (RwSpecification fromUrl: loadSpecUrl)
		projectsHome: projectsHome;
		customConditionalAttributes: customConditionalAttributes;
		yourself.
	resolvedProject := loadSpec resolve.
	^ (self newNamed: resolvedProject name)
		_resolvedProject: resolvedProject resolve;
		yourself
%

category: 'instance creation'
classmethod: RwResolvedProject
projectFromUrl: loadSpecUrl readonlyDiskUrl: urlString
	| loadSpec resolvedProject |
	loadSpec := (RwSpecification fromUrl: loadSpecUrl)
		readonlyDiskUrl: urlString;
		projectsHome: urlString asRwUrl pathString asFileReference parent;
		yourself.
	resolvedProject := loadSpec resolve.
	^ (self newNamed: resolvedProject name)
		_resolvedProject: resolvedProject resolve;
		yourself
%

!		Instance methods for 'RwResolvedProject'

category: 'accessing'
method: RwResolvedProject
componentsRoot
	^ self _resolvedProject componentsRoot
%

category: 'transitions'
method: RwResolvedProject
defined
	^ RwDefinedProject fromResolvedProject: self
%

category: 'actions'
method: RwResolvedProject
export
	^ self _resolvedProject export
%

category: 'actions'
method: RwResolvedProject
exportComponents
	^ self _resolvedProject exportComponents
%

category: 'actions'
method: RwResolvedProject
exportLoadSpecification
	^ self _resolvedProject exportLoadSpecification
%

category: 'actions'
method: RwResolvedProject
exportPackages
	^ self _resolvedProject exportPackages
%

category: 'actions'
method: RwResolvedProject
exportPackages: diskProjectSetDefinition packagesRoot: packagesRoot packageFormat: packageFormat packageConvention: packageConvention
	^ self _resolvedProject
		exportPackages: diskProjectSetDefinition
		packagesRoot: packagesRoot
		packageFormat: packageFormat
		packageConvention: packageConvention
%

category: 'actions'
method: RwResolvedProject
exportProjects
	^ self _resolvedProject exportProjects
%

category: 'actions'
method: RwResolvedProject
exportProjectSpecification
	^ self _resolvedProject exportProjectSpecification
%

category: 'actions'
method: RwResolvedProject
exportTopazFormatTo: filePath
	^ self
		exportTopazFormatTo: filePath
		logClassCreation: false
		excludeClassInitializers: false
		excludeRemoveAllMethods: false
%

category: 'actions'
method: RwResolvedProject
exportTopazFormatTo: filePath logClassCreation: logClassCreation excludeClassInitializers: excludeClassInitializers excludeRemoveAllMethods: excludeRemoveAllMethods
	^ self _resolvedProject
		exportTopazFormatTo: filePath
		logClassCreation: logClassCreation
		excludeClassInitializers: excludeClassInitializers
		excludeRemoveAllMethods: excludeRemoveAllMethods
%

category: 'accessing'
method: RwResolvedProject
packagesRoot
	^ self _resolvedProject packagesRoot
%

category: 'accessing'
method: RwResolvedProject
projectRoots
	^ self _resolvedProject projectRoots
%

category: 'accessing'
method: RwResolvedProject
projectsRoot
	^ self _resolvedProject projectsRoot
%

category: 'actions'
method: RwResolvedProject
readPackageNames: packageNames
	^ self _resolvedProject readPackageNames: packageNames
%

category: 'actions'
method: RwResolvedProject
readPackageNamesBlock: packageNamesBlock
	^ self _resolvedProject readPackageNamesBlock: packageNamesBlock
%

category: 'accessing'
method: RwResolvedProject
repository
	^ self _resolvedProject repository
%

category: 'accessing'
method: RwResolvedProject
repositoryRoot
	^ self _resolvedProject repositoryRoot
%

category: 'transitions'
method: RwResolvedProject
resolve
	^ self
%

category: 'accessing'
method: RwResolvedProject
revision
	^ self _resolvedProject revision
%

category: 'accessing'
method: RwResolvedProject
revision: aString
	self _resolvedProject revision: aString
%

category: 'accessing'
method: RwResolvedProject
specsRoot
	^ self _resolvedProject specsRoot
%

category: 'transitions'
method: RwResolvedProject
write

	self _resolvedProject
		export;
		exportLoadSpecification
%

! Class implementation for 'RwProject'

!		Instance methods for 'RwProject'

category: 'actions'
method: RwProject
asDefinition

	^ self _loadedProject asDefinition
%

category: 'actions'
method: RwProject
audit
	"run audit on the receiver"

	^ self _loadedProject audit
%

category: 'properties'
method: RwProject
canCommit

	^ self _loadedProject canCommit
%

category: 'properties'
method: RwProject
checkout: revision
	^ self _loadedProject checkout: revision
%

category: 'properties'
method: RwProject
comment

	^ self _specification comment
%

category: 'querying'
method: RwProject
commitId

	^ self _loadedProject commitId
%

category: 'querying'
method: RwProject
commitLog: logLimit

	^ self _loadedProject commitLog: logLimit
%

category: 'querying'
method: RwProject
componentForPackageNamed: packageName
	"Answer nil if no component found"

	^ self _loadedProject componentForPackageNamed: packageName
%

category: 'components'
method: RwProject
componentNamed: componentName
	^ self loadedComponents componentNamed: componentName
%

category: 'accessing'
method: RwProject
currentBranchName

	| rootPath |
	self useGit
		ifFalse: [ ^ '' ].
	rootPath := self repositoryRootPath.
	rootPath ifNil: [ ^ '' ].
	^ Rowan gitTools gitBranchNameIn:rootPath
%

category: 'accessing'
method: RwProject
customConditionalAttributes
	^ self _loadSpecification customConditionalAttributes
%

category: 'accessing'
method: RwProject
customConditionalAttributes: anArray
	self _loadSpecification customConditionalAttributes: anArray
%

category: 'transitions'
method: RwProject
defined
	^ RwDefinedProject fromLoadedProject: self
%

category: 'accessing'
method: RwProject
definedClasses

	^ self _projectTools query classesForProjectNamed: self name
%

category: 'testing'
method: RwProject
existsOnDisk

	^ Rowan image 
		loadedProjectNamed: self name 
			ifPresent: [:loadedProject |
				self repositoryRoot
					ifNil: [ false ]
					ifNotNil: [:fileRef | fileRef exists ] ]
			ifAbsent: [ false ]
%

category: 'accessing'
method: RwProject
extendedClasses

	^ self _projectTools query classExtensionsForProjectNamed: self name
%

category: 'git support'
method: RwProject
gitCheckout: branchOrSha
	"git checkout a branch or sha"

	^ Rowan gitTools gitcheckoutIn: self repositoryRoot with: branchOrSha
%

category: 'git support'
method: RwProject
gitCommit: commitComment
	"git checkout a branch or sha"

	^ self _loadedProject resolvedProject commit: commitComment
%

category: 'git support'
method: RwProject
gitCreateBranch: branchName
	"git create a new branch"

	^ Rowan gitTools gitcheckoutIn: self repositoryRoot with: ' -b ', branchName
%

category: 'git support'
method: RwProject
gitLog: logLimit
	"return `git log` report"

	^ Rowan gitTools gitlogtool: 'HEAD' limit: logLimit gitRepoDirectory: self repositoryRoot pathString
%

category: 'git support'
method: RwProject
gitPullRemote: remoteName branch: branchName
	"git pull remote and branch name"

	^ Rowan gitTools
		gitpullIn: self repositoryRoot pathString
		remote: remoteName
		branch: branchName
%

category: 'git support'
method: RwProject
gitPushRemote: remoteName branch: branchName
	"git push remote and branch name"

	^ Rowan gitTools
		gitpushIn: self repositoryRoot pathString
		remote: remoteName
		branch: branchName
%

category: 'git support'
method: RwProject
gitShortStatus
	"`git status --short` returns an empty string if there is nothing to commit"

	^ Rowan gitTools gitstatusIn: self repositoryRoot pathString with: '--short'
%

category: 'git support'
method: RwProject
gitStatus
	"return standard `git status` report"

	^ Rowan gitTools gitstatusIn: self repositoryRoot pathString with: ''
%

category: 'testing'
method: RwProject
isDirty
	"a project is dirty if it has changes that are not written to disk, or it's packages 
		have changes that are not written to  disk."

	^ self _loadedProject isDirty
%

category: 'testing'
method: RwProject
isLoaded
	^ self _loadedProjectIfPresent: [ true ] ifAbsent: [ false ]
%

category: 'actions'
method: RwProject
load
	"
		load only the receiver into the image. Required projects for the receiver are only loaded if they are not already 
			present in the image.

		To explicitly load the receiver AND required projects, construct a project set containing projects to be loaded 
			and send #load to the project set.
	"

	^ self _loadedProject load
%

category: 'actions'
method: RwProject
load: instanceMigrator
	"
		load only the receiver into the image, using the specified instance migrator. Required projects for the receiver are only 
			loaded if they are not already present in the image.
	"

	^ self _loadedProject load: instanceMigrator
%

category: 'properties'
method: RwProject
loadedCommitId

	^ self _loadedProject loadedCommitId
%

category: 'properties'
method: RwProject
loadedConfigurationNames
	"Answer the list of configuration names that were explicitly specified when the project was loaded"

	^ self _loadedProject loadedConfigurationNames
%

category: 'properties'
method: RwProject
loadedGroupNames
	"Answer the list of group names that were explicitly specified when the project was loaded"

	^ self _loadedProject loadedGroupNames
%

category: 'components'
method: RwProject
loadedTopLevelComponents
	| lc |
	lc := self loadedComponents.
	^ self componentNames
		collect: [ :componentName | lc componentNamed: componentName ]
%

category: 'actions'
method: RwProject
loadProjectSet
	"
		refresh the contents of the receiver from disk and create a project set that includes project definitions of
			required projects, also read from disk. Then load the entire project set.
	"

	^ self _loadedProject loadProjectSet
%

category: 'actions'
method: RwProject
loadProjectSet: platformConditionalAttributes
	"
		refresh the contents of the receiver from disk and create a project set that includes project definitions of
			required projects, also read from disk. Then load the entire project set.

		Use the specified platform conditional attributes when reading the receiver from disk.
	"

	^ self _loadedProject loadProjectSet: platformConditionalAttributes
%

category: 'actions'
method: RwProject
loadProjectSet: platformConditionalAttributes instanceMigrator: instanceMigrator
	"
		refresh the contents of the receiver from disk and create a project set that includes project definitions of
			required projects, also read from disk. Then load the entire project set, using the specified 
			instance migrator.

		Use the specified platform conditional attributes when reading the receiver from disk.

		Use the instanceMigrator to handle new versions of any classes that may result from the load.
	"

	^ self _loadedProject
		loadProjectSet: platformConditionalAttributes
		instanceMigrator: instanceMigrator
%

category: 'querying'
method: RwProject
packageNamed: aString ifAbsent: absentBlock
	^ self packages
		detect: [ :package | package name = aString ]
		ifNone: absentBlock
%

category: 'accessing'
method: RwProject
packageNames

	^ self _loadedProject packageNames
%

category: 'accessing'
method: RwProject
packages

	^ self packageNames collect: [ :packageName | RwPackage newNamed: packageName ]
%

category: 'accessing'
method: RwProject
projectDefinitionPlatformConditionalAttributes

	^ self _loadedProject projectDefinitionPlatformConditionalAttributes
%

category: 'accessing'
method: RwProject
projectUrl

	"Return the projectUrl used to clone the project"

	^ self _loadedProject projectUrl
%

category: 'actions'
method: RwProject
reload
	"
		load the receiver AND required projects.
	"

	^ Rowan projectTools load loadProjectNamed: self name
%

category: 'properties'
method: RwProject
remote

	^ self _loadedProject remote
%

category: 'accessing'
method: RwProject
repositoryCommitId

	^ self _loadedProject repositoryCommitId
%

category: 'properties'
method: RwProject
repositoryRootPath

	^ self repositoryRoot pathString
%

category: 'actions'
method: RwProject
revert
	"
		read and reload only the receiver into the image. Required projects for the receiver are only loaded if they are not already 
			present in the image.

		To explicitly revert the receiver AND required projects, <TBD>.
	"

	"should replace places where a projectSet was created for the receiver"

	^ self error: 'Not yet implmented'
%

category: 'actions'
method: RwProject
revert: platformConditionalAttributes
	"
		read the reciever using the platformConditionalAttributes and reload only the receiver into the image. Required projects for the receiver are only 
			loaded if they are not already present in the image.
	"

	"should replace places where a projectSet was created for the receiver"

	^ self error: 'Not yet implmented'
%

category: 'actions'
method: RwProject
revert: platformConditionalAttributes  instanceMigrator: instanceMigrator
	"
		read the reciever using the platformConditionalAttributes and reload only the receiver into the image, using the specifiied instanceMigrator. Required projects for the 
			receiver are only loaded if they are not already present in the image.
	"

	"should replace places where a projectSet was created for the receiver"

	^ self error: 'Not yet implmented'
%

category: 'components'
method: RwProject
subcomponentsOf: componentName
	^ self subcomponentsOf: componentName ifNone: [ ^ {} ]
%

category: 'components'
method: RwProject
subcomponentsOf: componentName attributes: attributes ifNone: noneBlock
	^ self _loadedProject
		subcomponentsOf: componentName
		attributes: attributes
		ifNone: noneBlock
%

category: 'components'
method: RwProject
subcomponentsOf: componentName ifNone: noneBlock
	^ self  _loadedProject subcomponentsOf: componentName ifNone: noneBlock
%

category: 'actions'
method: RwProject
testSuite
	^ Rowan projectTools test testSuiteForProjectNamed: self name
%

category: 'components'
method: RwProject
topLevelComponents
	^ self loadedComponents components values
		select: [ :each | each class == RwSimpleProjectLoadComponentV2 ]
%

category: 'actions'
method: RwProject
unload
	"unload the loaded project (if present) from the image"

	^ self
		_loadedProjectIfPresent: [ :loadedProject | loadedProject unload ]
		ifAbsent: [  ]
%

category: 'testing'
method: RwProject
useGit

	^self _loadedProject useGit
%

category: 'private'
method: RwProject
_loadedProject

	^ Rowan image loadedProjectNamed: self name
%

category: 'private'
method: RwProject
_loadedProjectIfPresent: presentBlock ifAbsent: absentBlock

	^ Rowan image
		loadedProjectNamed: self name
		ifPresent: presentBlock
		ifAbsent: absentBlock
%

category: 'private'
method: RwProject
_loadSpecification
	^ self _loadedProject loadSpecification
%

category: 'private'
method: RwProject
_projectRepository
	^ self _loadedProject handle _projectRepository
%

category: 'private'
method: RwProject
_specification

	^ self _loadedProject specification
%

! Class implementation for 'RwPackage'

!		Instance methods for 'RwPackage'

category: 'accessing'
method: RwPackage
definedClasses

"	^ self _packageTools query classesForPackageNamed: self name"

	^ self error: 'not yet implemented'
%

category: 'accessing'
method: RwPackage
extendedClasses

"	^ self _packageTools query classExtensionsForPackageNamed: self name"

	^ self error: 'not yet implemented'
%

category: 'testing'
method: RwPackage
isDirty
	"a project is dirty if it has changes that are not written to disk, or it's packages 
		have changes that are not written to  disk."

	^ self _loadedPackage isDirty
%

category: 'testing'
method: RwPackage
isEmpty

	^ self _loadedPackage isEmpty
%

category: 'accessing'
method: RwPackage
project
	^ RwProject newNamed: self _loadedProject name
%

category: 'private'
method: RwPackage
_loadedPackage

	^ Rowan image loadedPackageNamed: self name
%

category: 'private'
method: RwPackage
_loadedProject

	^ self _loadedPackage loadedProject
%

! Class implementation for 'RowanService'

!		Class methods for 'RowanService'

category: 'autocommit'
classmethod: RowanService
autoCommit

	^SessionTemps current at: #'Jadeite_AutoCommit' ifAbsentPut: [false]
%

category: 'autocommit'
classmethod: RowanService
breakPointsAreEnabled

	^SessionTemps current at: #'Jadeite_BreakPointsAreEnabled' ifAbsentPut: [true]
%

category: 'autocommit'
classmethod: RowanService
flipAutoCommit
	| newValue |
	newValue := self autoCommit == #failed ifTrue:[false] ifFalse:[self autoCommit not].
	^self setAutoCommit: newValue
%

category: 'instance creation'
classmethod: RowanService
new

	^super new initialize
%

category: 'other'
classmethod: RowanService
rowanFixMe

	"send this message to see everywhere that GS_Jade should be fixed"
%

category: 'examples'
classmethod: RowanService
sampleService

	^self new sampleService
%

category: 'autocommit'
classmethod: RowanService
setAutoCommit: object

	^SessionTemps current at: #'Jadeite_AutoCommit' put: object
%

category: 'autocommit'
classmethod: RowanService
setBreakPointsAreEnabled: boolean
  ^ SessionTemps current at: #'Jadeite_BreakPointsAreEnabled' put: boolean
%

category: 'accessing'
classmethod: RowanService
version
  "change this method carefully and only at Jadeite release boundaries.
	Failure to do so will prevent logins"

  ^ 3092
%

!		Instance methods for 'RowanService'

category: 'other'
method: RowanService
answer: anObject

	| answeringService |
	answeringService := RowanAnsweringService new. 
	answeringService answer: anObject. 
	RowanCommandResult addResult: answeringService.
%

category: 'rowan'
method: RowanService
browserTool

	^self projectTools browser
%

category: 'commands support'
method: RowanService
classHierarchy: theClasses
  | superclassChains levels services hierarchies toExpand hierarchyServices |
  superclassChains := self superclassChainsFor: theClasses.
  hierarchies := self extendHierarchies: superclassChains.
  levels := self hierarchiesByLevel: hierarchies.
  services := Dictionary new.
  toExpand := Set new.
  self
    services: services
    from: levels
    expand: toExpand
    classes: theClasses.
  hierarchyServices := services reject: [ :array | array isEmpty ].
  hierarchyServices copy
    keysAndValuesDo: [ :key :value | 
      hierarchyServices
        at: key
        put:
          (value asSet asSortedCollection: [ :x :y | x name < y name ]) asArray ].
  ^ hierarchyServices
%

category: 'accessing'
method: RowanService
command

	^command
%

category: 'accessing'
method: RowanService
command: aSymbol

	command := aSymbol
%

category: 'accessing'
method: RowanService
commandArgs

	^commandArgs ifNil:[commandArgs := Array new]
%

category: 'accessing'
method: RowanService
commandArgs: anArray

	"for tests" 

	commandArgs := anArray
%

category: 'symbol dictionaries'
method: RowanService
createDefaultSymbolDictionary

	^self createSymbolDictionaryNamed: self defaultSymbolDictionaryName
%

category: 'samples'
method: RowanService
createSampleSymbolDictionary

	self removeSymbolDictionaryNamed: self sampleSymbolDictionaryName.
	self createSymbolDictionaryNamed: self sampleSymbolDictionaryName
%

category: 'symbol dictionaries'
method: RowanService
createSymbolDictionaryNamed: aName

	| dictionary size |
	dictionary := SymbolDictionary new.
	dictionary at: aName asSymbol put: dictionary.
	size := Rowan image symbolList size.
	System myUserProfile insertDictionary: dictionary at: size + 1.
	^ dictionary
%

category: 'symbol dictionaries'
method: RowanService
defaultSymbolDictionary

	^self symbolDictionaryNamed: self defaultSymbolDictionaryName
%

category: 'symbol dictionaries'
method: RowanService
defaultSymbolDictionaryName

	^'RowanProjects'
%

category: 'rowan'
method: RowanService
definitionClass

	^self subclassResponsibility
%

category: 'rowan'
method: RowanService
definitionClassName

	^self definitionClass name
%

category: 'replication'
method: RowanService
excludedInstVars

	^#( #organizer)
%

category: 'commands support'
method: RowanService
extendHierarchies: hierarchies
	
	"extend the hierarchies by one level
	of subclasses"

	| extendedHierarchies |
	extendedHierarchies := Array new. 
	hierarchies do:[:hierarchy |
		| theClass subclasses |
		theClass := hierarchy last. 
		(subclasses := organizer subclassesOf: theClass) isEmpty 
			ifTrue:[extendedHierarchies add: hierarchy]
			ifFalse:[
				subclasses do:[:sub |
					extendedHierarchies add: (hierarchy copy add: sub; yourself)
				]]].
	^extendedHierarchies
%

category: 'perform'
method: RowanService
handleDeletedService
  self updateType: #'removed:'.
  RowanCommandResult addResult: self
%

category: 'commands support'
method: RowanService
hierarchiesByLevel: hierarchies

	"Return dictionary of classes by level. 
	Example: 
		hierarchies - #(#(Object Collection Array) #(Object AbstractException Exception))
	Return: 
		#(#nil->#(Object) Object->#(Collection AbstractException) Collection->#(Array) AbstractException->#(Exception)
	"
	| levels |
	levels := hierarchies inject: Dictionary new into:[:dict :chain | 
		1 to: chain size do: [:index | 
			| cls theSuper classSet |
			cls := chain at: index.
			classSet := dict at: cls ifAbsentPut: [Array new].
			index = 1 
		ifTrue:[
			classSet := dict at: #'nil' ifAbsentPut: [Array new]. 
			((dict at: #'nil') includes: cls) ifFalse:[(dict at: #'nil') add: cls].
		]
		ifFalse:[
				theSuper := chain at: index - 1.
				((dict at: theSuper) includes: cls) ifFalse:[(dict at: theSuper) add: cls]
				]].
			dict].
	^levels
%

category: 'initialization'
method: RowanService
initialize
%

category: 'testing'
method: RowanService
isClassService

	^false
%

category: 'testing'
method: RowanService
isDictionaryService

	^false
%

category: 'testing'
method: RowanService
isMethodService

	^false
%

category: 'testing'
method: RowanService
isPackageService

	^false
%

category: 'testing'
method: RowanService
isProjectService

	^false
%

category: 'testing'
method: RowanService
isUpdating

	^command == #update
%

category: 'perform'
method: RowanService
isUpdatingButFoundToBeDeleted
  ^ self command == #'update' and: [ self wasDeleted ]
%

category: 'accessing'
method: RowanService
jadeiteServer

	^(Rowan jadeServerClassNamed: #JadeServer) theJadeiteServer
%

category: 'accessing'
method: RowanService
organizer: anOrganizer

	organizer := anOrganizer.
%

category: 'rowan'
method: RowanService
projectTools

	^Rowan projectTools
%

category: 'samples'
method: RowanService
removeSampleSymbolDictionary

	self removeSymbolDictionaryNamed: self sampleSymbolDictionaryName.
%

category: 'symbol dictionaries'
method: RowanService
removeSymbolDictionaryNamed: aName

	| index |
	index := Rowan image symbolList names indexOf: aName asSymbol.
	index ~= 0 ifTrue:[
		System myUserProfile removeDictionaryAt: index]
%

category: 'other'
method: RowanService
rowanFixMe
		
	"marker for all things broken in Rowan"
%

category: 'rowan'
method: RowanService
rowanLoadedPackageNames

	| stream packages |
	self rowanFixMe.	"handle modified package display"
	stream := WriteStream on: String new.
	packages := Rowan packageNames.
	packages do: 
					[:package |
					stream
						nextPutAll: package;
						tab;
						nextPut: ((RwPackage newNamed: package) isDirty ifTrue:[$Y] ifFalse:[$N]);
						tab;
						nextPutAll: package;
						lf].
	^stream contents
%

category: 'accessing'
method: RowanService
rowanProjectName

	"all services should be able to return a project name
	even if they are not truly packaged" 

	^nil
%

category: 'samples'
method: RowanService
sampleSymbolDictionaryName

	^'SampleSymbolDictionaryName'
%

category: 'perform'
method: RowanService
servicePerform: symbol withArguments: collection
  "each service updates itself after performing a command.
	Therefore, if the command is #update, don't run it here"

  SessionTemps current
    at: #'versionsVerified'
    ifAbsent: [ 
      SessionTemps current at: #'versionsVerified' put: false.
      self
        inform:
          'Version mismatch failure. Client version is older than server version.' ].
  symbol == #'update'
    ifTrue: [ ^ self ].
  ^ super perform: symbol withArguments: collection
%

category: 'commands support'
method: RowanService
services: services from: levels expand: toExpand classes: theClasses
  "In order to avoid the expense of creating duplicate services, we cache
them in the newServices temporary for look up"

  | newServices |
  newServices := Array new.
  theClasses
    do: [ :aClass | toExpand addAll: (organizer allSuperclassesOf: aClass) ].
  levels
    keysAndValuesDo: [ :key :value | 
      | newKey service |
      newKey := key = #'nil'
        ifTrue: [ #'nil' ]
        ifFalse: [ 
          service := newServices
            detect: [ :classService | classService name = key name ]
            ifNone: [ RowanClassService new classServiceFromOop: key asOop ].
          (toExpand includes: service theClass)
            ifTrue: [ service expand: true ]
            ifFalse: [ service expand: false ].
          service ].
      services
        at: newKey
        put:
          (value
            collect: [ :cls | 
              service := newServices
                detect: [ :classService | classService name = cls name ]
                ifNone: [ RowanClassService new classServiceFromOop: cls asOop ].
              (toExpand includes: service theClass)
                ifTrue: [ service expand: true ]
                ifFalse: [ service expand: false ].
              service ]) ]
%

category: 'replication'
method: RowanService
stonOn: stonWriter
    | instanceVariableNames |
    instanceVariableNames := self class allInstVarNames reject: [:iv | self excludedInstVars includes: iv].
    stonWriter writeObject: self
        streamMap: 
            [:dictionary |
            instanceVariableNames do: 
                    [:each |
                    (self instVarAt: (self class allInstVarNames indexOf: each asSymbol))
                        ifNotNil: [:value | dictionary at: each asSymbol put: value]
                        ifNil: [self stonShouldWriteNilInstVars ifTrue: [dictionary at: each asSymbol put: nil]]]]
%

category: 'replication'
method: RowanService
stonStringFor: anObject

	"return a string representing a complete object structure
	suitable for replicating on the client."

	^STON toString: anObject
%

category: 'private'
method: RowanService
stripOutUnicode: string
  | asciiString |
  asciiString := string
    collect: [ :char | 
      ((self validLowRangeCharacters includes: char) not
        and: [ char asciiValue < 32 or: [ char asciiValue > 255 ] ])
        ifTrue: [ $? ]
        ifFalse: [ char ] ].
  ^ asciiString
%

category: 'commands support'
method: RowanService
superclassChainsFor: behaviors
	organizer := ClassOrganizer new. 
	^behaviors collect:[:behavior | | supers |
			supers := organizer allSuperclassesOf: behavior. 
			supers add: behavior. 
			supers].
%

category: 'symbol dictionaries'
method: RowanService
symbolDictionaryNamed: aName

	| symbolList  index |
	symbolList := Rowan image symbolList.
	index :=symbolList names indexOf: aName asSymbol.
	^index ~= 0
		ifTrue:[
			symbolList at: index]
		ifFalse:[
			self createSymbolDictionaryNamed: aName].
%

category: 'initialization'
method: RowanService
update
%

category: 'update'
method: RowanService
updateInternalService: updatedService

	"no internally held services to update"
%

category: 'update'
method: RowanService
updateLatest
  "subclasses may want to special behavior to update themselves
	to their loaded version"

  self update
%

category: 'accessing'
method: RowanService
updateType: aSymbol

	updateType := aSymbol
%

category: 'accessing'
method: RowanService
userGlobals
  ^ Rowan image symbolList objectNamed: #'UserGlobals'
%

category: 'private'
method: RowanService
validLowRangeCharacters
  ^ Array with: Character lf with: Character tab
%

category: 'testing'
method: RowanService
wasDeleted

	^false
%

category: 'fileout'
method: RowanService
writeFileOutHeaderOn: stream
	"This method will write a fileout header onto the given file.
	Adapted from GBS - GbxBrowser>>writeFileOutHeaderOn:"

	| rawVer beVer cr |
	stream nextPutAll: 'fileformat utf8';
			cr. 
	rawVer := System _version.
	beVer := ''.
	cr := String with: Character cr.
	"Comment each newline"
	(rawVer subStrings: (Array with: Character lf)) do: [:line | beVer := beVer , '! ' , line , cr].
	stream
		nextPutAll: '!';
		cr;
		nextPutAll: '! From ';
		nextPutAll: beVer;
		cr;
		nextPutAll: '! On ';
		nextPutAll: Date today printString;
		nextPutAll: ', ';
		nextPutAll: Time now printString;
		cr;
		nextPutAll: '!';
		cr;
		flush
%

! Class implementation for 'RowanAnsweringService'

!		Instance methods for 'RowanAnsweringService'

category: 'private'
method: RowanAnsweringService
addLowerCaseSymbolsIn: theClass To: array
  array addAll: theClass selectors.
  array addAll: theClass class selectors.
  array addAll: theClass instVarNames.
  array addAll: theClass class instVarNames.
  array addAll: theClass classVarNames.
%

category: 'client commands'
method: RowanAnsweringService
allClassesStartingWith: string
  answer := SortedCollection new.
  organizer classes
    do: [ :cls | 
      (cls name beginsWith: string)
        ifTrue: [ answer add: cls name asString ] ].
  answer := answer asArray.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
allClassNames
  answer := SortedCollection new.
  answer addAll: (organizer classes collect: [ :cls | cls name asString ]).
  answer := answer asArray.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
allTestsIn: classServices
	answer := Array new. 
	classServices do:[:service | answer addAll: service allTests].
	RowanCommandResult addResult: self.
%

category: 'accessing'
method: RowanAnsweringService
answer

	^answer
%

category: 'Updating'
method: RowanAnsweringService
answer: anObject

	answer := anObject
%

category: 'client commands'
method: RowanAnsweringService
autoCommit

	answer := RowanService autoCommit. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
autocompleteSymbols
  | newClassNames newLowerCaseSymbols |
  newClassNames := Array new.
  newLowerCaseSymbols := Array new.
  organizer classes
    do: [ :cls | 
      newClassNames add: cls name asString.
      self addLowerCaseSymbolsIn: cls To: newLowerCaseSymbols ].
  newLowerCaseSymbols := newLowerCaseSymbols asSet asArray.
  SessionTemps current
    at: #'autocompleteSymbolCache'
    put: (Array with: newClassNames with: newLowerCaseSymbols).
  answer := Array
    with: newClassNames asOrderedCollection
    with: newLowerCaseSymbols asOrderedCollection.
  updateType := #'updateSymbols:'.
  RowanCommandResult addResult: self
%

category: 'client command support'
method: RowanAnsweringService
basicExec: aString context: oop
	answer := [true -> (aString evaluateInContext: (Object _objectForOop: oop) symbolList: Rowan image symbolList) asOop] 
		on: CompileError do: [:ex | 
			false -> ex errorDetails
	].
	answer key ifTrue:[(RowanService autoCommit == true) ifTrue:[System commitTransaction]].
	^answer
%

category: 'client command support'
method: RowanAnsweringService
basicMethodHistoryFor: methodService
  | rowanMethodHistory |
  rowanMethodHistory := self userGlobals
    at: #'RowanMethodHistory'
    ifAbsentPut: [ Dictionary new ].
  answer := (rowanMethodHistory at: methodService ifAbsentPut: [ Array new ])
    asOrderedCollection.
  answer
    addFirst: (rowanMethodHistory keys detect: [ :svc | svc = methodService ])
%

category: 'client command support'
method: RowanAnsweringService
basicPrintStringOf: oop toMaxSize: integer
  | object |
  object := Object _objectForOop: oop.
  ^ self basicPrintStringOfObject: object toMaxSize: integer
%

category: 'client command support'
method: RowanAnsweringService
basicPrintStringOfObject: object toMaxSize: integer
  "avoid the oop conversion when we already have the object"

  | printString |
  printString := self stripOutUnicode: object printString.
  printString := printString size > integer
    ifTrue: [ (printString copyFrom: 1 to: integer) , '...' ]
    ifFalse: [ printString ].
  ^ printString
%

category: 'client command support'
method: RowanAnsweringService
basicSortedSelectors
  | selectors |
  selectors := IdentitySet new.
  organizer classes
    do: [ :aClass | 
      | metaClass |
      metaClass := aClass.
      2
        timesRepeat: [ 
          | methodDictionary |
          methodDictionary := metaClass _fullMethodDictEnv0.
          methodDictionary
            valuesDo: [ :method | 
              | selector |
              selector := method selector.
              selector charSize = 1
                ifTrue: [ selectors add: selector ].
              method _selectorPool
                do: [ :sentSelector | 
                  sentSelector charSize = 1
                    ifTrue: [ selectors add: sentSelector ] ] ].
          metaClass := metaClass class ] ].
  ^ selectors asSortedCollection asArray
%

category: 'client command support'
method: RowanAnsweringService
basicSortedSymbols
  | sortedSymbols |
  sortedSymbols := SortedCollection new.
  ((AllUsers userWithId: #'SymbolUser') resolveSymbol: #'AllSymbols') value
    keysDo: [ :symbol | 
      symbol charSize = 1
        ifTrue: [ sortedSymbols add: symbol ] ].
  ^sortedSymbols asArray
%

category: 'client commands'
method: RowanAnsweringService
breakPointsAreEnabled
  answer := RowanService breakPointsAreEnabled.
  updateType := #'breakpointSettingChanged:'.
  RowanCommandResult addResult: self.
  ^ answer	"for testing"
%

category: 'client commands'
method: RowanAnsweringService
canAccessServiceClasses
  "Being able to see RowanLoggingService is a good
	indication that all of the service classes are visible"

  answer := [ '[RowanLoggingService] value. true.' evaluate ]
    on: Error
    do: [ :ex | false ].
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
classHasSubclasses: oop
  | behavior |
  behavior := Object _objectForOop: oop.
  answer := behavior subclasses notEmpty.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
clearAllBreaks
  | methodServices |
  methodServices := RowanQueryService new
    organizer: organizer;
    basicBreakpointMethods.
  GsNMethod clearAllBreaks.
  methodServices
    do: [ :methodService | RowanCommandResult addResult: methodService update ]
%

category: 'client commands'
method: RowanAnsweringService
clearMethodBreaks: methodServices
  methodServices
    do: [ :methodService | 
      methodService
        organizer: organizer;
        clearMethodBreaks ]
%

category: 'client commands'
method: RowanAnsweringService
disableAllBreaks
  | methodServices |
  methodServices := RowanQueryService new
    organizer: organizer;
    basicBreakpointMethods.
  GsNMethod _disableAllBreaks.
  methodServices
    do: [ :methodService | RowanCommandResult addResult: methodService update ]
%

category: 'client commands'
method: RowanAnsweringService
disableMethodBreaks: methodServices
  methodServices
    do: [ :methodService | 
      methodService
        organizer: organizer;
        disableMethodBreaks ]
%

category: 'client commands'
method: RowanAnsweringService
doClientAndServerVersionsMatch: clientVersion
  "Not to be sent through services so return an answer directly.
	Sent immediately after Jadeite login"

  SessionTemps current at: #'versionsVerified' put: false.
  clientVersion = RowanService version
    ifTrue: [ 
      answer := true.
      SessionTemps current at: #'versionsVerified' put: true ]
    ifFalse: [ 
      answer := clientVersion > RowanService version
        ifTrue: [ 
          'Client (' , clientVersion printString , ') is more recent than server ('
            , RowanService version printString , ')' ]
        ifFalse: [ 
          'Server (' , RowanService version printString , ') is more recent than client ('
            , clientVersion printString , ')' ] ].
  ^ answer
%

category: 'client commands'
method: RowanAnsweringService
enableAllBreaks
  | methodServices |
  methodServices := RowanQueryService new
    organizer: organizer;
    basicBreakpointMethods.
  GsNMethod _enableAllBreaks.
  methodServices
    do: [ :methodService | RowanCommandResult addResult: methodService update ]
%

category: 'client commands'
method: RowanAnsweringService
enableMethodBreaks: methodServices
  methodServices
    do: [ :methodService | 
      methodService
        organizer: organizer;
        enableMethodBreaks ]
%

category: 'client commands'
method: RowanAnsweringService
exec: aString

	"for command line service someday"
	answer := aString evaluate printString. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
exec: aString context: oop

	answer := self basicExec: aString context: oop. 
	RowanCommandResult addResult: self.

	"return answer for testing" 
	^answer
%

category: 'client commands'
method: RowanAnsweringService
exec: aString context: oop inWindow: handle
  answer := self exec: aString context: oop.
  answer key
    ifTrue: [ RowanBrowserService new saveRootObject: answer value windowHandle: handle ].	"return answer for testing"
  ^ answer
%

category: 'client commands'
method: RowanAnsweringService
exec: aString inFrame: level ofProcess: processOop context: oop
  | symbolList frameContents symbolDictionary process |
  symbolList := Rowan image symbolList.
  process := Object _objectForOop: processOop.
  process _isTerminated
    ifTrue: [ 
      RowanCommandResult addResult: self.
      ^ self ].
  frameContents := process _frameContentsAt: level.
  frameContents
    ifNotNil: [ 
      symbolDictionary := SymbolDictionary new.
      1 to: (frameContents at: 9) size do: [ :index | 
        ((frameContents at: 9) at: index) first = $.
          ifFalse: [ 
            symbolDictionary
              at: ((frameContents at: 9) at: index) asSymbol
              put: (frameContents at: 11 + index - 1) ] ].
      symbolList add: symbolDictionary before: symbolList first ].
  [ 
  answer := [ 
  true
    ->
      (aString evaluateInContext: (Object _objectForOop: oop) symbolList: symbolList)
        asOop ]
    on: CompileError
    do: [ :ex | false -> ex errorDetails ].
  answer key
    ifTrue: [ 
      RowanService autoCommit == true
        ifTrue: [ System commitTransaction ] ].
  RowanCommandResult addResult: self ]
    ensure: [ 
      1 to: (frameContents at: 9) size do: [ :index | 
        | argsAndTemps |
        argsAndTemps := frameContents at: 9.
        (argsAndTemps at: index) first = $.
          ifFalse: [ 
            | variableService |
            process
              _frameAt: level
              tempAt: index
              put: (symbolDictionary at: (argsAndTemps at: index)).
            variableService := RowanVariableService
              oop: (symbolDictionary at: (argsAndTemps at: index)) asOop
              key: (argsAndTemps at: index)
              value: (symbolDictionary at: (argsAndTemps at: index)) printString
              className: (frameContents at: 8) class name asString.
            RowanCommandResult addResult: variableService ] ].
      symbolList remove: symbolDictionary ].	"return answer for testing"
  ^ answer
%

category: 'client commands'
method: RowanAnsweringService
expressionSelector: string
  "try to uncover a selector in the string. 
	If it's not possible, return the string and 
	let the application do with it what it will"

  | messageNode |
  messageNode := [ RBParser parseExpression: string ]
    on: Error
    do: [ :ex | nil ].
  messageNode
    ifNil: [ 
      messageNode := [ RBParser parseExpression: string , ' #foo' ]
        on: Error
        do: [ :ex | nil ] ].
  messageNode
    ifNil: [ 
      messageNode := [ RBParser parseExpression: '#foo ' , string ]
        on: Error
        do: [ :ex | nil ] ].
  answer := messageNode
    ifNil: [ string ]
    ifNotNil: [ 
      messageNode isMessage
        ifTrue: [ messageNode buildSelector ]
        ifFalse: [ 
          messageNode isCascade
            ifTrue: [ messageNode messages first buildSelector]
            ifFalse: [ string ] ] ].
  RowanCommandResult addResult: self.
  ^ answer	"return answer for testing"
%

category: 'client commands'
method: RowanAnsweringService
flipTranscript
	self isTranscriptInstalled ifTrue:[
		self jadeiteServer uninstallTranscript]
	ifFalse:[
		self jadeiteServer installTranscript]
%

category: 'client commands'
method: RowanAnsweringService
initializeAutoCommit

	RowanService setAutoCommit: false
%

category: 'client commands'
method: RowanAnsweringService
initializeBreakPointsAreEnabled
  RowanService setBreakPointsAreEnabled: true
%

category: 'client commands'
method: RowanAnsweringService
interactionHandlerActive
  answer := SessionTemps current
    at: #'rowanServiceInteractionActive'
    ifAbsent: [ true ].
  RowanCommandResult addResult: self
%

category: 'testing'
method: RowanAnsweringService
isTranscriptInstalled

	^self transcriptObject == self jadeiteServer
%

category: 'client commands'
method: RowanAnsweringService
isVariable: oop
	| anObject |
	anObject := Object _objectForOop: oop. 
	answer := anObject class isVariable.
	RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
loadedPackageExists: packageName
	
	| actualName |
	actualName := Rowan image packageNames detect:[:loadedName | loadedName asLowercase = packageName asLowercase] ifNone:[]. 
	answer := (Rowan image loadedPackageNamed: actualName ifAbsent: []) notNil. 
	command := nil. 
	commandArgs := nil. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
lowercaseSelectorsMatching: lowercaseSymbol
  answer := self basicSortedSelectors
    select: [ :symbol | lowercaseSymbol sunitMatch: symbol asLowercase ].
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
methodHistoryFor: methodService
  self basicMethodHistoryFor: methodService.
  RowanCommandResult addResult: self.
  ^ answer	"for testing"
%

category: 'client commands'
method: RowanAnsweringService
methodReferenceCounts: methodServices
  answer := Array new.
  methodServices
    do: [ :methodService | answer add: (organizer sendersOf: methodService selector) first size ].
  RowanCommandResult addResult: self.
  ^ answer	"for testing"
%

category: 'client commands'
method: RowanAnsweringService
needsCommit

	answer := System needsCommit.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
newPackageNamed: packageName
  | packageService |
  packageService := RowanPackageService new name: packageName.
  packageService update.
  answer := packageService.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
printStringOf: oop toMaxSize: integer
  answer := self basicPrintStringOf: oop toMaxSize: integer.
  RowanCommandResult addResult: self.
  ^ answer
%

category: 'client commands'
method: RowanAnsweringService
printStringOfOops: oops toMaxSize: integer
  answer := Array new.
  oops
    do: [ :oop | answer add: (self basicPrintStringOf: oop toMaxSize: integer) ].
  RowanCommandResult addResult: self.
  ^ answer
%

category: 'client commands'
method: RowanAnsweringService
profile: block
  "not used yet. Utility method needs testing.
	Make sure block execution time is long enough - say 1 second. 
	Results may not be consistent

	Usage example: 
| block answeringService | 
block := [| browserService profMonitor |
		browserService := (RowanBrowserService new) .
		10 timesRepeat:[browserService packagesWithTests]]. 
answeringService := RowanAnsweringService new profile: block.
answeringService answer. "

  | time ns |
  time := System millisecondsToRun: block.
  ns := ProfMonitor computeInterval: time / 1000.
  answer := ProfMonitor monitorBlock: block intervalNs: ns.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
removeMethodHistoryFor: methodService
  | rowanMethodHistory |
  rowanMethodHistory := self userGlobals
    at: #'RowanMethodHistory'
    ifAbsentPut: [ Dictionary new ].
  rowanMethodHistory removeKey: methodService ifAbsent: [  ]
%

category: 'client commands'
method: RowanAnsweringService
resolveAsService: name
  | projectService packageService classService dictionaryService |
  projectService := RowanProjectService new name: name.
  projectService update projectIsLoaded
    ifTrue: [ 
      answer := projectService.
      ^ RowanCommandResult addResult: self ].
  packageService := RowanPackageService new name: name.
  packageService update projectName
    ifNotNil: [ 
      answer := packageService.
      ^ RowanCommandResult addResult: self ].
  dictionaryService := RowanDictionaryService new name: name.
  dictionaryService update classes notEmpty
    ifTrue: [ 
      answer := dictionaryService.
      ^ RowanCommandResult addResult: self ].
  classService := RowanClassService new name: name.
  classService update projectName
    ifNotNil: [ 
      answer := classService.
      ^ RowanCommandResult addResult: self ].
  answer := nil.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
runMethodTests: methodServices

	| behavior |
	methodServices do:[:methodService |
		(methodService selector asString matchPattern: #('test' $*)) ifTrue:[ 
			behavior := methodService classFromName. 
			behavior debug: methodService selector]].
	answer := true. 
	RowanCommandResult initializeResults. "squash any client updates during server test run"
	RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
selectorsMatching: lowercaseSymbol
  "assume we're passed a lower case symbol to avoid
	case sensitive misses"

  answer := self basicSortedSelectors
    select: [ :symbol | lowercaseSymbol sunitMatch: symbol asLowercase ].
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
selectorsMatchingPattern: pattern
  answer := self basicSortedSelectors.
  answer := answer select: [ :each | each _matchPatternNoCase: pattern ].
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
setAutoCommit: object

	answer := RowanService setAutoCommit: object.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
setBreakPointsAreEnabled: boolean
  boolean
    ifTrue: [ self enableAllBreaks ]
    ifFalse: [ self disableAllBreaks ].
  RowanService setBreakPointsAreEnabled: boolean.
  answer := boolean.
  updateType := #'breakpointSettingChanged:'.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
setEnableInteractionHandler: boolean
  SessionTemps current at: #'rowanServiceInteractionActive' put: boolean
%

category: 'client commands'
method: RowanAnsweringService
sortedSelectors
  answer := self basicSortedSelectors.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
sortedSymbols
  answer := self basicSortedSymbols. 
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
subclassCreationTemplate: className
	 (RowanClassService new name: className) subclassCreationTemplate.  "gives an answer for us"
%

category: 'client commands'
method: RowanAnsweringService
symbolExists: aSymbol
  answer := (Rowan image symbolList resolveSymbol: aSymbol) isNil not.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
symbolsMatching: string
  answer := self basicSortedSymbols
    select: [ :symbol | string sunitMatch: symbol ].
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
transcriptInstalled

	answer := self isTranscriptInstalled.
	RowanCommandResult addResult: self.
%

category: 'private'
method: RowanAnsweringService
transcriptObject
	
	^(SessionTemps current  at: #'TranscriptStream_SessionStream')
%

category: 'client commands'
method: RowanAnsweringService
turnOffTranscriptWrites

	self isTranscriptInstalled ifTrue:[
		self flipTranscript]
%

category: 'client commands'
method: RowanAnsweringService
updateAutocompleteSymbols
  | cache newClassNames newLowerCaseSymbols |
  cache := SessionTemps current
    at: #'autocompleteSymbolCache'
    ifAbsent: [ ^ self	"autocomplete not activated" ].
  newClassNames := Array new.
  newLowerCaseSymbols := Array new.
  organizer classes
    do: [ :cls | 
      (cache first includes: cls name asString)
        ifFalse: [ newClassNames add: cls name asString ].
      self addLowerCaseSymbolsIn: cls To: newLowerCaseSymbols ].
  (SessionTemps current at: #'autocompleteSymbolCache') first
    addAll: newClassNames.
  newLowerCaseSymbols := newLowerCaseSymbols asSet asArray.
  cache last
    do: [ :selector | 
      (newLowerCaseSymbols includes: selector)
        ifTrue: [ newLowerCaseSymbols remove: selector ] ].
  (SessionTemps current at: #'autocompleteSymbolCache') last
    addAll: newLowerCaseSymbols.
  answer := Array with: newClassNames with: newLowerCaseSymbols.
  updateType := #'updateSymbols:'.
  RowanCommandResult addResult: self
%

! Class implementation for 'RowanAutoCommitService'

!		Instance methods for 'RowanAutoCommitService'

category: 'client commands'
method: RowanAutoCommitService
autoCommit: boolean

	self class setAutoCommit: boolean.
	autoCommit := self class autoCommit. 
	updateType := #autoCommitUpdate:.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAutoCommitService
flipAutoCommit

	autoCommit := self class flipAutoCommit. 
	updateType := #autoCommitUpdate:.
	RowanCommandResult addResult: self.
%

! Class implementation for 'RowanBrowserService'

!		Instance methods for 'RowanBrowserService'

category: 'client commands'
method: RowanBrowserService
abortTransaction
  | autoCommitService autoCommitState |
  autoCommitState := RowanService autoCommit == #'failed'
    ifTrue: [ true ]
    ifFalse: [ RowanService autoCommit ].
  System abortTransaction.
  autoCommitService := RowanAutoCommitService new.
  autoCommitService autoCommit: autoCommitState.
  self updateProjects.
  self updateDictionaries
%

category: 'client commands'
method: RowanBrowserService
abortTransactionAndUpdateServices: services
  self abortTransaction.
  services
    do: [ :service | 
      "we just updated projects, package, & dictionary services"
      (service isProjectService not
        and: [ service isDictionaryService not and: [ service isPackageService not ] ])
        ifTrue: [ 
          service
            organizer: organizer;
            updateLatest ] ]
%

category: 'client commands'
method: RowanBrowserService
allClasses
	allClasses := self basicAllClasses.
	updateType := #classes. "#classes not used at the moment so no updates will be done"
	RowanCommandResult addResult: self
%

category: 'client commands support'
method: RowanBrowserService
basicAllClasses
  | theClasses |
  theClasses := SortedCollection sortBlock: [ :x :y | x name < y name ].
  theClasses
    addAll:
      (organizer classes
        collect: [ :class | 
          | service |
          service := RowanClassService new name: class name.
          service packageName: class rowanPackageName.
          service projectName: class rowanProjectName.
          service ]).
  ^ theClasses asArray
%

category: 'client commands'
method: RowanBrowserService
classHierarchy
	| theClasses |
	theClasses := allClasses collect:[:classService | classService theClass].
	hierarchyServices := self classHierarchy: theClasses. 
	updateType := #classHierarchyUpdate:browser:. 
	RowanCommandResult addResult: self.
%

category: 'private'
method: RowanBrowserService
classHierarchy: theClasses
  hierarchyServices := super classHierarchy: theClasses.
  ^ hierarchyServices
%

category: 'client commands'
method: RowanBrowserService
classHierarchyForDictionariesNamed: dictionaryNames
  | theClasses |
  theClasses := OrderedCollection new.
  dictionaryNames
    do: [ :dictionaryName | 
      (Rowan globalNamed: dictionaryName)
        keysAndValuesDo: [ :key :value | 
          value isClass
            ifTrue: [ theClasses add: value ] ] ].
  hierarchyServices := self classHierarchy: theClasses.
  updateType := #'classHierarchyUpdate:browser:'.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
classHierarchyForPackagesNamed: packageNames
  | theClasses |
  theClasses := OrderedCollection new.
  packageNames
    do: [ :packageName | 
      theClasses
        addAll:
          ((Rowan image loadedPackageNamed: packageName) loadedClasses 
            collect: [ :cls | cls handle]).
      theClasses
        addAll:
          ((Rowan image loadedPackageNamed: packageName) loadedClassExtensions
            collect: [ :cls | cls handle]) ].
  hierarchyServices := self classHierarchy: theClasses.
  updateType := #'classHierarchyUpdate:browser:'.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
compileClass: definitionString
  | anonymousMethod |
  self confirmDuplicateName: definitionString.
  anonymousMethod := definitionString
    _compileInContext: nil
    symbolList: Rowan image symbolList.
  SessionTemps current at: #'jadeiteCompileClassMethod' put: anonymousMethod
%

category: 'client commands support'
method: RowanBrowserService
confirmDuplicateName: definitionString
  | className |
  className := (definitionString subStrings at: 3) copyWithout: $'.
  (Rowan image symbolList resolveSymbol: className asSymbol)
    ifNotNil: [ 
      className = selectedClass
        ifFalse: [ 
          (self confirm: 'Class name is already an object. Continue?')
            ifFalse: [ ^ Error signal: 'Class not compiled. Name already exists.' ] ] ]
%

category: 'client commands'
method: RowanBrowserService
defaultClassHierarchy
	hierarchyServices := Dictionary new.   
	organizer hierarchy keysAndValuesDo: [:key :value |
		| classService |
		classService := key == #nil ifTrue:[#nil] ifFalse: [RowanClassService basicForClassNamed: key name].
		hierarchyServices at: classService put: (value collect:[:cls | RowanClassService basicForClassNamed: cls name]) asArray.
	].
	updateType := #classHierarchyUpdate:browser:. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanBrowserService
findRemovedServices: services

	services do:[:service | 
		service wasDeleted ifTrue:[
				service updateType: #removed:.
				RowanCommandResult addResult: service.
		]
	].
%

category: 'initialize'
method: RowanBrowserService
initialize
  super initialize.
  newCachedSelectors := Array new.
  newCachedClasses := Array new
%

category: 'accessing'
method: RowanBrowserService
newCachedClasses
	^newCachedClasses
%

category: 'accessing'
method: RowanBrowserService
newCachedClasses: object
	newCachedClasses := object
%

category: 'accessing'
method: RowanBrowserService
newCachedSelectors
	^newCachedSelectors
%

category: 'accessing'
method: RowanBrowserService
newCachedSelectors: object
	newCachedSelectors := object
%

category: 'window registry'
method: RowanBrowserService
openWindows

	"for testing"

	^SessionTemps current at: #rowanServicesWindowRegistry ifAbsent:[]
%

category: 'client commands'
method: RowanBrowserService
packagesWithTests
  organizer := ClassOrganizer new.	"when we call this method, our world has changed from a reload, etc."
  testPackages := Set new.
  testCount := 0.
  testPackages := Set new.
  testCount := 0.
  (organizer allSubclassesOf: TestCase)
    do: [ :sub | 
      | packageName testMethodCount |
      testMethodCount := (sub sunitSelectors
        select: [ :each | each beginsWith: 'test' ]) size.	"sending #testSelectors was slower"
      testCount := testCount + testMethodCount.
      testMethodCount > 0
        ifTrue: [ 
          packageName := sub rowanPackageName.
          packageName = Rowan unpackagedName
            ifFalse: [ 
              testPackages
                add:
                  (RowanPackageService new
                    name: packageName;
                    updateProjectName;
                    yourself) ].
          (Rowan image loadedClassExtensionsForClass: sub)
            do: [ :loadedThing | 
              testPackages
                add:
                  (RowanPackageService new
                    name: loadedThing loadedPackage name;
                    updateProjectName;
                    yourself)	"don't update the entire package for performance improvement" ] ] ].
  updateType := #'testPackages:'.
  testPackages := testPackages asArray.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
recompileMethodsAfterClassCompilation
  "compileClass: must be run first"

  | theClass classService packageService projectService |
  theClass := [ 
  [ (SessionTemps current at: #'jadeiteCompileClassMethod') _executeInContext: nil ]
    on: CompileWarning
    do: [ :ex | ex resume ] ]
    ensure: [ SessionTemps current at: #'jadeiteCompileClassMethod' put: nil ].
  classService := RowanClassService new name: theClass name.
  classService update.
  classService isNewClass: true.	"if nothing else, the dirty state of the package/project services
	should be updated. Would like a less heavy weight solution than this, though."
  packageService := RowanPackageService
    forPackageNamed: classService packageName.
  packageService update.
  projectService := RowanProjectService newNamed: packageService projectName.
  projectService update.
  packageService selectedClass: classService.
  RowanCommandResult addResult: classService.
  selectedClass := classService.
  updateType := #'none'.
  self updateSymbols: (Array with: theClass name asString).
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
releaseWindowHandle: integer
  | registry |
  Rowan loggingServiceClass current
    logComment: 'Release window with handle: ' , integer printString.
  registry := SessionTemps current
    at: #'rowanServicesWindowRegistry'
    ifAbsent: [ ^ self ].
  registry removeKey: integer ifAbsent: [  ]
%

category: 'client commands'
method: RowanBrowserService
reloadProjects: projectServices andUpdateServices: services
  | projectNames answeringService |
  services do: [ :service | service organizer: organizer ].
  projectServices do: [ :service | service organizer: organizer ].
  projectServices do: [ :projectService | projectService reloadProject ].
  projectNames := projectServices
    collect: [ :projectService | projectService name ].
  services
    do: [ :service | 
      (projectNames includes: service rowanProjectName)
        ifTrue: [ service updateLatest ] ].
  answeringService := RowanAnsweringService new organizer: organizer.
  answeringService updateAutocompleteSymbols
%

category: 'client commands'
method: RowanBrowserService
removeDictionariesNamed: dictionaryNames
	"remove from both transient & persistent symbol lists" 

	dictionaryNames do:[:dictionaryName | 
		| dictionaryNameSymbol |
		dictionaryNameSymbol := dictionaryName asSymbol.
		(Rowan image symbolList names includes: dictionaryNameSymbol) ifTrue:[
			Rowan image symbolList removeDictionaryNamed: dictionaryNameSymbol].
		(System myUserProfile symbolList names includes: dictionaryNameSymbol) ifTrue:[
			System myUserProfile symbolList removeDictionaryNamed: dictionaryNameSymbol]].
	self updateDictionaries.
%

category: 'client commands'
method: RowanBrowserService
removeMethods: methodServices

	| notRemoved |
	notRemoved := Array new. 
	removedMethods := Array new. 
	methodServices do: [:methodService |
		| classService |
		classService := RowanClassService forClassNamed: methodService className. 
		classService meta: methodService meta. 
		classService removeSelector: methodService selector ifAbsent:[notRemoved add: methodService].
		classService updatePackageProject.
		(notRemoved includes: methodService) ifFalse:[
			methodService updateType: #removed:.
			RowanCommandResult addResult: methodService]. 
		removedMethods add: methodService].
	notRemoved isEmpty ifFalse:[
		self error: 'These selectors were not removed - ', (notRemoved collect:[:ea | ea selector]) printString].
	updateType := #methodsRemoved:. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanBrowserService
saveRootObject: oop windowHandle: integer
  " a window has been opened on the client. Save the 
	root object of the window so it won't be recycled"

  | dictionary |
  dictionary := SessionTemps current
    at: #'rowanServicesWindowRegistry'
    ifAbsentPut: [ Dictionary new ].
  dictionary at: integer ifAbsentPut: [ Array new ].
  (dictionary at: integer) add: (Object _objectForOop: oop)
%

category: 'other'
method: RowanBrowserService
selectedClass

	^selectedClass
%

category: 'other'
method: RowanBrowserService
selectedClass: object

	selectedClass := object
%

category: 'perform'
method: RowanBrowserService
servicePerform: symbol withArguments: collection
	super perform: symbol withArguments: collection.
%

category: 'client commands'
method: RowanBrowserService
unloadProjectsNamed: array
  array
    do: [ :projectName | 
      | project |
      project := Rowan image loadedProjectNamed: projectName ifAbsent: [  ].
      project
        ifNotNil: [ Rowan projectTools delete deleteProjectNamed: projectName ] ].
  self updateProjects
%

category: 'update'
method: RowanBrowserService
update
	self updateProjects
%

category: 'client commands'
method: RowanBrowserService
updateDictionaries

	dictionaries := Rowan image symbolList names collect:[:name | RowanDictionaryService new name: name asString].
	dictionaries := dictionaries asOrderedCollection. 
	updateType ifNil: [updateType := OrderedCollection new]. 
	updateType add: #dictionaryListUpdate:.
	RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
updateProjects
  | sortedProjects |
  self packagesWithTests. "make sure tests are always updated" 
  sortedProjects := SortedCollection sortBlock: [ :a :b | a name < b name ].
  sortedProjects addAll: Rowan image loadedProjects.
  projects := sortedProjects
    collect: [ :project | RowanProjectService newNamed: project name ].
  updateType := Array with: updateType with: #'projectsUpdate:browser:'. "temporary hack" 
  RowanCommandResult addResult: self
%

category: 'update'
method: RowanBrowserService
updateSymbols: classNames
  newCachedClasses addAll: classNames.
  updateType := #'addCachedSymbols:'
%

! Class implementation for 'RowanClassService'

!		Class methods for 'RowanClassService'

category: 'instance creation'
classmethod: RowanClassService
basicForClassNamed: className 
	"Don't get method services. Efficient for classes with many methods"
	^self new basicForClassNamed: className
%

category: 'instance creation'
classmethod: RowanClassService
forClassNamed: className 

	^self new forClassNamed: className
%

category: 'instance creation'
classmethod: RowanClassService
forClassNamed: className meta: aBoolean

	| inst |
	inst := self forClassNamed: className subStrings first.
	inst meta: aBoolean.
	^inst
%

category: 'instance creation'
classmethod: RowanClassService
forClassNamed: className package: packageName

	| inst |
	inst := self forClassNamed: className.
	inst packageName: packageName.
	^inst
%

category: 'instance creation'
classmethod: RowanClassService
minimalForClassNamed: className 
	"Don't get method services. Efficient for classes with many methods"
	^self new minimalForClassNamed: className
%

!		Instance methods for 'RowanClassService'

category: 'comparing'
method: RowanClassService
= classService
	(classService class canUnderstand: #isClassService) ifFalse:[^false].
	^classService isClassService
			ifTrue: [  name asString = classService name asString and: [meta = classService meta]]
			ifFalse: [^false]
%

category: 'client commands'
method: RowanClassService
addCategory: string

	| theClass |

	theClass := self theClass.
	meta ifTrue:[theClass := theClass class]. 
	theClass addCategory: string.
%

category: 'constants'
method: RowanClassService
addSubclassWarningString

	^'Superclass is not packaged. Enter the desired package name'
%

category: 'client commands'
method: RowanClassService
allSubclassServices
  | subclassServices |
  subclassServices := self theClass subclasses asArray
    collect: [ :aClass | RowanClassService minimalForClassNamed: aClass name ].
  hierarchyServices := Dictionary new.
  hierarchyServices at: #'expand' put: subclassServices.
  (hierarchyServices at: #'expand')
    do: [ :classService | classService allSubclassServices ]
%

category: 'Accessing'
method: RowanClassService
allTests
  | allSelectors theClass |
  self isTestCase
    ifFalse: [ ^ Array new ].
  theClass := self theClass thisClass.
  theClass isAbstract
    ifTrue: [ ^ Array new ].
  allSelectors := self theClass thisClass allTestSelectors.
  ^ allSelectors
    collect: [ :selector | 
      | methodService |
      methodService := RowanMethodService
        forSelector: selector
        class: (theClass whichClassIncludesSelector: selector asString)
        meta: false
        organizer: organizer.
      methodService
        definedClassName: (theClass whichClassIncludesSelector: selector asString) name asString.	"may get changed in client"
      methodService ]
%

category: 'testing'
method: RowanClassService
arePackageAndProjectClean

	^self packageIsDirty not and:[self projectIsDirty not]
%

category: 'initialization'
method: RowanClassService
basicForClassNamed: className 

	| theClass |
	self name: className. 
	theClass := self theClass. 
	theClass isNil ifTrue:[oop := nil. ^self].
	self basicRefreshFrom: theClass.
%

category: 'initialization'
method: RowanClassService
basicRefreshFrom: theClass
	| classOrMeta theFilters |
	oop := theClass asOop.
	command := nil. 
	commandArgs := nil. 
	superclassName := theClass superClass ifNotNil:[:theSuper | theSuper name asString]. 
	comment := theClass rwComment. 
	organizer ifNil: [organizer := ClassOrganizer new]. "for Jade and tests"
	versions := theClass classHistory size.
	version := theClass classHistory indexOf: theClass.
	self setComment.
	template := self classCreationTemplate.
	theFilters := SortedCollection new.
	classOrMeta := meta == true ifTrue:[theClass class] ifFalse:[theClass].
	self initializeVariablesFor: classOrMeta. 
	self initializeCategoriesFor: classOrMeta.
	packageName := definedPackageName := classOrMeta rowanPackageName.
	self setDictionary: classOrMeta.
	projectName := classOrMeta rowanProjectName.
	instVarNames := classOrMeta instVarNames asArray. 
	self setIsTestCase.
	self updateIsExtension.
%

category: 'Accessing'
method: RowanClassService
behavior

	| behavior |
	behavior := self theClass. 
	meta == true ifTrue:[behavior := behavior class].
	^behavior
%

category: 'client commands'
method: RowanClassService
classComment: string
	| theClass |
	theClass := self theClass. 
	theClass rwComment: string.
%

category: 'rowan'
method: RowanClassService
classCreationTemplate
	
	^self browserTool classCreationTemplateForClass: self theClass hybridBrowser: true.
%

category: 'client commands'
method: RowanClassService
classHierarchy
	hierarchyServices := self classHierarchy: (Array with: self theClass). 
	RowanCommandResult addResult: self.
%

category: 'Accessing'
method: RowanClassService
classHierarchyNames

	| names |
	names := Array new. 
	hierarchyServices keys do:[:classService | 
		classService == #nil ifFalse:[names add: classService name]].
	^names
%

category: 'Accessing'
method: RowanClassService
classInstVarNames
	^classInstVarNames
%

category: 'Updating'
method: RowanClassService
classInstVarNames: newValue
	classInstVarNames := newValue
%

category: 'Accessing'
method: RowanClassService
classOrMeta

	^meta 
			ifTrue:[self theClass class] 
			ifFalse: [self theClass].
%

category: 'instance creation'
method: RowanClassService
classServiceFromOop: anOop
	| theClass className classService |
	theClass := Object _objectForOop: anOop. 
	className := theClass name. 
	classService := RowanClassService new name: className.
	^className asString = name asString ifTrue:[
			className asString = 'Object' 
				ifTrue:[
					classService basicRefreshFrom: theClass]
				ifFalse:[
					classService fastRefresh]]
		ifFalse:[
			classService minimalRefreshFrom: theClass]
%

category: 'Accessing'
method: RowanClassService
classType
	^classType
%

category: 'Updating'
method: RowanClassService
classType: newValue
	classType := newValue
%

category: 'Accessing'
method: RowanClassService
classVarNames
	^classVarNames
%

category: 'Updating'
method: RowanClassService
classVarNames: newValue
	classVarNames := newValue
%

category: 'Accessing'
method: RowanClassService
comment
	^comment
%

category: 'Updating'
method: RowanClassService
comment: newValue
	comment := newValue
%

category: 'constants'
method: RowanClassService
compileMethod: methodString behavior: aBehavior symbolList: aSymbolList inCategory: categorySymbol
	"returns (nil -> anArrayOfErrors) or (aGsNMethod -> compilerWarnings) or (aGsNMethod -> nil)"

	| method warnings |
	
	[ [ [ [ method := aBehavior rwCompileMethod: methodString category: categorySymbol.]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: false ]]
			on: CompileError
			do: [:ex | ^nil -> (ex gsArguments at: 1)]]
				on: CompileWarning
				do: 
					[:ex | 
					warnings := ex warningString.
					ex resume]]
					on: RwPerformingUnpackagedEditNotification
					do: [:ex | ex resume ] .
	^[(self compiledMethodAt: method key selector inClass: aBehavior) -> warnings] on: Error
		do: [:ex | ex return: method -> warnings]
%

category: 'client commands'
method: RowanClassService
copyClassTo: newClassName
  | newTemplate newClass newClassService index |
  (Rowan image symbolList resolveSymbol: newClassName)
    ifNotNil: [ ^ self inform: newClassName , ' already exists' ].
  index := template findPattern: (Array with: name) startingAt: 1.
  newTemplate := template copy.
  newTemplate removeFrom: index to: index + name size - 1.
  newTemplate insertAll: newClassName at: index.
  newClass := GsCurrentSession currentSession execute: newTemplate.
  newClassService := RowanClassService new name: newClassName.
  self theClass thisClass
    methodsDo: [ :selector :gsMethod | 
      newClassService
        compileMethod: gsMethod sourceString
        behavior: newClass
        symbolList: Rowan image symbolList
        inCategory:
          (self theClass thisClass categoryOfSelector: selector) asSymbol ].
  self theClass thisClass class
    methodsDo: [ :selector :gsMethod | 
      newClassService
        compileMethod: gsMethod sourceString
        behavior: newClass class
        symbolList: Rowan image symbolList
        inCategory:
          (self theClass thisClass class categoryOfSelector: selector) asSymbol ].
  newClassService update.
  (RowanPackageService new name: newClassService packageName) update.
  (RowanDictionaryService new name: dictionaryName) update
%

category: 'Updating'
method: RowanClassService
definedPackageName: newValue

	definedPackageName := newValue
%

category: 'Updating'
method: RowanClassService
expand: boolean

	expand := boolean
%

category: 'client commands'
method: RowanClassService
fastRefresh
	"pushes less information to ston so it's faster"

	| theClass |
	theClass := self theClass. 
	self refreshFrom: theClass. 
	methods do:[:service1 |
			service1 source: nil;
				stepPoints: Array new].
	visibleTests do:[:service2 |
			service2 source: nil;
				stepPoints: Array new.
			].
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanClassService
fileoutCategories: array
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	array do:[:category |
		self behavior fileOutCategory: category on: ws]. 
	answeringService answer: ws contents. 
	RowanCommandResult addResult: answeringService.
%

category: 'client commands'
method: RowanClassService
fileoutClass
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	ws nextPutAll: self behavior fileOutClass. 
	answeringService answer: ws contents. 
	RowanCommandResult addResult: answeringService.
%

category: 'client commands'
method: RowanClassService
fileoutMethods: array
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	array do:[:methodService |
		self behavior fileOutMethod: methodService selector on: ws]. 
	answeringService answer: ws contents. 
	RowanCommandResult addResult: answeringService.
%

category: 'Accessing'
method: RowanClassService
filters
	^filters
%

category: 'Updating'
method: RowanClassService
filters: newValue
	filters := newValue
%

category: 'initialization'
method: RowanClassService
forClassNamed: className 

	| theClass |
	self name: className. 
	theClass := self theClass. 
	self refreshFrom: theClass.
%

category: 'client commands'
method: RowanClassService
fullHierarchy
  | behavior sortedSubclasses |
  behavior := self theClass.
  hierarchyServices := Dictionary new.
  hierarchyServices at: #'expand' put: Array new.
  sortedSubclasses := behavior subclasses
    asSortedCollection: [ :x :y | x name < y name ].
  RowanCommandResult addResult: self.
  sortedSubclasses
    do: [ :subclass | 
      | classService |
      classService := (self classServiceFromOop: subclass asOop) meta: meta.
      (hierarchyServices at: #'expand') add: classService.
      classService allSubclassServices ]
%

category: 'comparing'
method: RowanClassService
hash
	^self name hash bitXor: meta hash
%

category: 'Accessing'
method: RowanClassService
hierarchyServices

	^hierarchyServices
%

category: 'initialization'
method: RowanClassService
initialize

	isExtension := false.
	selectedMethods := Array new.
	meta := false. "assume most of our work is on the instance side"
	selectedPackageServices := Array new.
	isNewClass := false.
	methods := Array new.
	isInSymbolList := true.
	categories := Array new.
%

category: 'initialization'
method: RowanClassService
initializeCategoriesFor: classOrMeta

	| theFilters |
	theFilters := SortedCollection new.
	classOrMeta env: 0 categorysDo: [:category :selector | theFilters add: category asString].
	categories := theFilters asOrderedCollection.
%

category: 'method history'
method: RowanClassService
initializeMethodHistoryFor: source
  "about to compile a method. If possible, ensure it's method history is setup."

  | rowanMethodHistory methodHistory selector methodService |
  rowanMethodHistory := self userGlobals
    at: #'RowanMethodHistory'
    ifAbsentPut: [ Dictionary new ].
  selector := [ (Rowan platform parseSelectorFrom: source) asSymbol ]
    on: CompileWarning
    do: [ :ex | ex resume ].
  selector = #'_____could_not_parse_selector_from_method_source_____'
    ifTrue: [ ^ self	"invalid source, continue and let save method fail" ]
    ifFalse: [ 
      | compiledMethod |
      compiledMethod := (Object _objectForOop: oop)
        compiledMethodAt: selector
        environmentId: 0
        otherwise: nil.
      compiledMethod
        ifNil: [ ^ self	"we'll create history after the method is compiled" ].
      methodService := RowanMethodService
        forSelector: selector
        class: self theClass
        meta: meta
        organizer: organizer.
      methodHistory := rowanMethodHistory
        at: methodService
        ifAbsentPut: [ Array new ] ]
%

category: 'initialization'
method: RowanClassService
initializeTestMethodsFor: aClass
	| testSelectors |
	(aClass inheritsFrom: TestCase) ifTrue:[
		aClass isAbstract ifTrue:[^self]. 
		testSelectors := aClass thisClass allTestSelectors.
		methods do:[:methodService | 
			methodService isTestMethod: (testSelectors includes: methodService selector)]].
%

category: 'initialization'
method: RowanClassService
initializeVariablesFor: classOrMeta

	| theFilters |
	theFilters := SortedCollection new.
	theFilters addAll: (classOrMeta allInstVarNames collect:[:instVar | instVar asString]).
	variables := theFilters asOrderedCollection.
%

category: 'Accessing'
method: RowanClassService
instVarNames
	^instVarNames
%

category: 'Updating'
method: RowanClassService
instVarNames: newValue
	instVarNames := newValue
%

category: 'testing'
method: RowanClassService
isClassService

	^true
%

category: 'Updating'
method: RowanClassService
isExtension: boolean

	isExtension := boolean
%

category: 'Updating'
method: RowanClassService
isNewClass: boolean
	isNewClass := boolean
%

category: 'testing'
method: RowanClassService
isPackageClean

	^self packageIsDirty not
%

category: 'testing'
method: RowanClassService
isProjectClean
  ^ self projectIsDirty not
%

category: 'Updating'
method: RowanClassService
isTestCase

	^isTestCase
%

category: 'Updating'
method: RowanClassService
isTestCase: aBoolean

	isTestCase := aBoolean
%

category: 'Accessing'
method: RowanClassService
meta

	^meta
%

category: 'Updating'
method: RowanClassService
meta: anObject

	meta := anObject
%

category: 'Accessing'
method: RowanClassService
methods

	"for testing"
	^methods
%

category: 'private'
method: RowanClassService
methodServiceFrom: gsNMethod in: behavior compiltationResult: compilationResult
	| methodService |

	methodService := RowanMethodService forGsNMethod: gsNMethod organizer: organizer. 
	methodService compilationWarnings: compilationResult value.
	^methodService
%

category: 'private'
method: RowanClassService
methodServicesFor: classOrMeta organizer: theOrganizer

	methods addAll: (classOrMeta selectors collect:[:sel | 
			RowanMethodService 
				forSelector: sel class: classOrMeta thisClass meta: meta organizer: theOrganizer])
%

category: 'private'
method: RowanClassService
methodsIn: theClass categories: theCategories

	| selectors |
	selectors := Array new. 
	theCategories do:[:category |
		selectors addAll: (theClass selectorsIn: category)]. 
	^methods select:[:methodService | selectors includes: methodService selector]
%

category: 'testing'
method: RowanClassService
methodsNamed: selector
	"For testing. Multiple because class could have both instance and class methods"

	^methods select:[:methodService | methodService selector = selector]
%

category: 'initialization'
method: RowanClassService
minimalForClassNamed: className 

	| theClass |
	self name: className. 
	theClass := self theClass. 
	self minimalRefreshFrom: theClass.
%

category: 'initialization'
method: RowanClassService
minimalRefreshFrom: theClass
	| classOrMeta  |
	command := nil. 
	commandArgs := nil. 
	versions := theClass classHistory size.
	version := theClass classHistory indexOf: theClass.
	oop := theClass asOop.
	classOrMeta := meta == true ifTrue:[theClass class] ifFalse:[theClass].
	packageName := definedPackageName := classOrMeta rowanPackageName.
	self setDictionary: classOrMeta.
	projectName := classOrMeta rowanProjectName.
	instVarNames := classOrMeta instVarNames asArray. 
	template := self classCreationTemplate.
	self initializeVariablesFor: classOrMeta. 
	self initializeCategoriesFor: classOrMeta.
	self setIsTestCase.
%

category: 'client commands'
method: RowanClassService
moveMethods: methodServices to: category
	| behavior |
	behavior := self classOrMeta.
	methodServices do: [:methodService | 
			behavior rwMoveMethod: methodService selector toCategory: category.
			methodService category: category].
	self update. 
	self selectedMethods: methodServices.
%

category: 'Accessing'
method: RowanClassService
name
	^name
%

category: 'Updating'
method: RowanClassService
name: newValue
	name := newValue asString
%

category: 'private'
method: RowanClassService
objectInBaseNamed: aString

	^Rowan image symbolList objectNamed: aString asSymbol
%

category: 'client commands'
method: RowanClassService
oneLevelClassHierarchy
  "good for expanding an existing hierarchy quickly"

  | behavior sortedSubclasses |
  behavior := self theClass.
  hierarchyServices := Dictionary new.
  hierarchyServices at: #'expand' put: Array new.
  sortedSubclasses := behavior subclasses
    asSortedCollection: [ :x :y | x name < y name ].
  sortedSubclasses
    do: [ :subclass | 
      | classService |
      classService := (self classServiceFromOop: subclass asOop) meta: meta.
      (hierarchyServices at: #'expand') add: classService ].
  RowanCommandResult addResult: self
%

category: 'Accessing'
method: RowanClassService
oop
	^oop
%

category: 'Updating'
method: RowanClassService
oop: newValue
	oop := newValue
%

category: 'testing'
method: RowanClassService
packageIsDirty

	| behavior |
	behavior := self theClass.
	behavior rowanPackageName =  Rowan unpackagedName ifTrue:[^true]. "avoid a refresh by assuming it's dirty" 
	^(RowanPackageService new name: behavior rowanPackageName) rowanDirty
%

category: 'Accessing'
method: RowanClassService
packageName
	
	^packageName
%

category: 'Updating'
method: RowanClassService
packageName: pkgName
	
	packageName := pkgName
%

category: 'Accessing'
method: RowanClassService
poolDictionaryNames
	^poolDictionaryNames
%

category: 'Updating'
method: RowanClassService
poolDictionaryNames: newValue
	poolDictionaryNames := newValue
%

category: 'printing'
method: RowanClassService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $:. 
	aStream nextPutAll: (name ifNil: [nil printString])
%

category: 'testing'
method: RowanClassService
projectIsDirty

	| behavior |
	behavior := self theClass.
	behavior rowanProjectName =  Rowan unpackagedName ifTrue:[^true]. "avoid a refresh by assuming it's dirty" 
	^(RowanProjectService new name: behavior rowanProjectName) rowanDirty
%

category: 'other'
method: RowanClassService
projectName

	^projectName
%

category: 'Updating'
method: RowanClassService
projectName: newValue
	projectName := newValue
%

category: 'initialization'
method: RowanClassService
refreshFrom: theClass
	| classOrMeta  |
	self basicRefreshFrom: theClass. 
	classOrMeta := meta == true ifTrue:[theClass class] ifFalse:[theClass].
	self refreshMethodsFor: classOrMeta
%

category: 'initialization'
method: RowanClassService
refreshMethodsFor: classOrMeta
	| gsNMethods |
	methods := SortedCollection sortBlock: [:x :y | x selector < y selector].
	self methodServicesFor: classOrMeta organizer: organizer.
	methods := methods asOrderedCollection.
	classOrMeta allInstVarNames do:[:instVar | 
			gsNMethods := organizer accessorsOf: instVar inClass: classOrMeta.
			gsNMethods do:[:gsNMethod |
				| service |
				service := methods detect:[:methodService | methodService selector = gsNMethod selector] ifNone:[].
				service ifNotNil:[
					service accessedInstVars add: instVar asString]
	]].
	self initializeTestMethodsFor: classOrMeta thisClass. 
	self setVisibleTests. "methods must be available"
%

category: 'client commands'
method: RowanClassService
removeCategories: theCategories
	| theClass  | 
	self refreshFrom: self theClass. 
	theClass := self theClass.
	meta ifTrue:[theClass := theClass class]. 
	theCategories do: [:category |
		theClass rwRemoveCategory: category.
		].
%

category: 'client commands'
method: RowanClassService
removeMethods: methodsToRemove

	| notRemoved |
	notRemoved := Array new. 
	methodsToRemove do: [:methodService |
		self removeSelector: methodService selector ifAbsent:[notRemoved add: methodService].
		(notRemoved includes: methodService) ifFalse:[
			methodService updateType: #removed:.
			RowanCommandResult addResult: methodService.
		]].
	self updateTests.
	notRemoved isEmpty ifFalse:[
		self error: 'These selectors were not removed - ', (notRemoved collect:[:svc | svc selector]) printString].
%

category: 'rowan'
method: RowanClassService
removeSelector: selector

	self browserTool removeMethod: selector forClassNamed: name asString isMeta: meta
%

category: 'rowan'
method: RowanClassService
removeSelector: selector ifAbsent: absentBlock
	| theClass |
	theClass := self theClass. 
	meta ifTrue: [theClass := theClass class].
	(theClass compiledMethodAt: selector otherwise: nil) isNil ifTrue:[ ^absentBlock value ].
	[self browserTool removeMethod: selector forClassNamed: name asString isMeta: meta]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ]
%

category: 'client commands'
method: RowanClassService
renameCategoryFrom: old to: new

	| affectedSelectors behavior |

	self update. 
	self addCategory: new. 
	behavior := self classOrMeta.
	affectedSelectors := behavior selectorsIn: old.
	methods := methods select:[:methodService | affectedSelectors includes: methodService selector].
	self moveMethods: methods to: new.
	self removeCategories: (Array with: old)
%

category: 'client commands'
method: RowanClassService
renameClass: oldClassName to: newClassName
  | references newMethods newClass oldClass |
  newMethods := Array new.
  oldClass := Rowan image resolveClassNamed: oldClassName.
  newClass := Rowan projectTools browser
    renameClassNamed: oldClassName
    to: newClassName.
  oop := newClass asOop.
  name := newClassName.
  self update.
  renamedName := oldClassName.
  self updateMethodsAfterRenameFrom: oldClassName to: newClassName.
  self updateSubclassesAfterRenameOf: newClass.
  references := organizer update referencesToObject: oldClass.
  references do: [ :method | 
    | newSource compileResult failedCompile methodService oldSource |
    failedCompile := false.
    oldSource := method sourceString.
    newSource := self
      replaceSubString: oldClassName
      in: oldSource
      with: newClassName.
    compileResult := [ 
    method inClass
      rwCompileMethod: newSource
      category: (method inClass categoryOfSelector: method selector) asSymbol ]
      on: CompileError
      do: [ :ex | 
        failedCompile := true.
        method ].
    methodService := RowanMethodService
      forGsNMethod: compileResult
      organizer: organizer.
    failedCompile
      ifTrue: [ methodService comparisonSource: oldClassName ]
      ifFalse: [ methodService comparisonSource: oldSource ].
    methodService failedCompile: failedCompile.
    methodService renamedName: oldClassName.
    newMethods add: methodService ].
  RowanCommandResult addResult: (RowanAnsweringService new answer: newMethods)
%

category: 'private'
method: RowanClassService
replaceSubString: old in: string with: new
	| offset newSource |
	newSource := string. 
	offset := 1. 	
	[(offset := newSource findString: old startingAt: offset) = 0] whileFalse:[
		newSource := newSource copyReplaceFrom: offset to: offset + old size - 1 with: new. 
		offset := offset + new size. 
	].
	^newSource
%

category: 'rowan'
method: RowanClassService
rowanProjectName

	^projectName
%

category: 'client commands'
method: RowanClassService
runClassTests: classService

	"if it errors, the client will handle the error. 
	If it passes, we return true and the client
	will display decent results." 
	| behavior |
	behavior := classService theClass. 
	self refreshFrom: behavior.
	self tests do:[:methodService |
			behavior debug: methodService selector]. 
	RowanCommandResult addResult: (RowanAnsweringService new answer: true).
%

category: 'client commands'
method: RowanClassService
runMethodTests: methodServices

	| behavior |
	behavior := self theClass.  
	methodServices do:[:methodService |
		(methodService selector asString matchPattern: #('test' $*)) ifTrue:[ 
			behavior debug: methodService selector]].
	RowanCommandResult addResult: (RowanAnsweringService new answer: true).
%

category: 'client commands'
method: RowanClassService
saveMethodSource: source category: category
  | behavior compilationResult gsNMethod updatedCategory methodService |
  meta
    ifNil: [ 
      behavior := Object _objectForOop: oop.
      meta := behavior isMeta ]
    ifNotNil: [ 
      behavior := meta
        ifTrue: [ self theClass class ]
        ifFalse: [ self theClass ] ].
  oop := behavior asOop.
  self initializeMethodHistoryFor: source.
  updatedCategory := category ifNil: [ 'other' ].
  compilationResult := self
    compileMethod: source
    behavior: behavior
    symbolList: Rowan image symbolList
    inCategory: updatedCategory asSymbol.
  (gsNMethod := compilationResult key) isNil
    ifTrue: [ 
      System
        signal: 1001
        args: (Array with: compilationResult value)
        signalDictionary: GemStoneError ].
  self update.
  methodService := self
    methodServiceFrom: gsNMethod
    in: behavior
    compiltationResult: compilationResult.
  RowanCommandResult addResult: methodService.
  RowanQueryService new
    organizer: ClassOrganizer new;
    hierarchyImplementorsOf: methodService selector
      inClass: methodService className.	"this will update hierarchy method indicators for client"
  self selectedMethods: (Array with: methodService).
  self updateDirtyState.
  self updateTests.
  self
    updateSymbols:
      gsNMethod _selectorPool asArray , (Array with: methodService selector).
  methodService addToMethodHistory
%

category: 'other'
method: RowanClassService
selectedMethods
	"client side selection. Used after a method compile" 
	^selectedMethods
%

category: 'Updating'
method: RowanClassService
selectedMethods: theMethods
	selectedMethods := theMethods
%

category: 'Accessing'
method: RowanClassService
selectedPackageServices
	^selectedPackageServices
%

category: 'Updating'
method: RowanClassService
selectedPackageServices: newValue
	selectedPackageServices := newValue
%

category: 'Accessing'
method: RowanClassService
selectors

	^methods collect:[:methodService | methodService selector]
%

category: 'perform'
method: RowanClassService
servicePerform: symbol withArguments: collection
  | wasClean |
  self isUpdatingButFoundToBeDeleted
    ifTrue: [ ^ self handleDeletedService ].
  wasClean := self isPackageClean.
  super servicePerform: symbol withArguments: collection.
  updateAfterCommand == false
    ifFalse: [ self update ]. 
  wasClean
    ifTrue: [ self updatePackageProject ]
%

category: 'Accessing'
method: RowanClassService
setComment
  comment := self theClass thisClass comment
%

category: 'private'
method: RowanClassService
setDictionary: classOrMeta
	| dictionaryList |
		dictionaryList := Rowan image symbolList dictionariesAndSymbolsOf: classOrMeta thisClass.
		dictionaryName := dictionaryList isEmpty 
		ifTrue:[String new]
		ifFalse:[dictionaryList first first name asString].
%

category: 'Updating'
method: RowanClassService
setIsTestCase

	isTestCase := self theClass isSubclassOf: TestCase
%

category: 'client commands'
method: RowanClassService
setIsTestCaseCommand

	self setIsTestCase.
%

category: 'client commands'
method: RowanClassService
setVisibleTests
	visibleTests := SortedCollection sortBlock: [:x :y | x selector < y selector]. 
	visibleTests addAll: self allTests.
	visibleTests := visibleTests asArray.
%

category: 'client commands'
method: RowanClassService
subclassCreationTemplate
  | answerService newClassPackageName |
  answerService := RowanAnsweringService new.
  newClassPackageName := self theClass rowanPackageName = Rowan unpackagedName
    ifTrue: [ self addSubclassWarningString ]
    ifFalse: [ self theClass rowanPackageName ].
  answerService
    answer:
      (self browserTool
        classCreationTemplateForSubclassOf: name
        className: 'NewSubclass'
        category: newClassPackageName).
  RowanCommandResult addResult: answerService
%

category: 'private'
method: RowanClassService
subclassServices: subclasses

	| sortedSubclasses |

	sortedSubclasses := SortedCollection sortBlock: [:x :y | x name < y name]. 
	sortedSubclasses addAll: subclasses. 
	^(sortedSubclasses collect:[:cls | (self classServiceFromOop: cls asOop) meta: meta]) asArray.
%

category: 'Accessing'
method: RowanClassService
subclassType
	^subclassType
%

category: 'Updating'
method: RowanClassService
subclassType: newValue
	subclassType := newValue
%

category: 'Accessing'
method: RowanClassService
superclassName
	^superclassName
%

category: 'Updating'
method: RowanClassService
superclassName: newValue
	superclassName := newValue
%

category: 'Accessing'
method: RowanClassService
template
	^template
%

category: 'Updating'
method: RowanClassService
template: newValue
	template := newValue
%

category: 'private'
method: RowanClassService
tests

	^methods select:[:methodService | methodService selector asString matchPattern: #('test' $*)]
%

category: 'instance creation'
method: RowanClassService
theClass
	| theClass |
	theClass := oop ifNil:[Rowan globalNamed: name] ifNotNil: [Object _objectForOop: oop].
	theClass isMeta ifTrue:[oop := theClass thisClass asOop]. 
	(Rowan globalNamed: name) ifNil:[isInSymbolList := false]. 
	theClass ifNil: [^nil]. 
	^theClass thisClass
%

category: 'updates'
method: RowanClassService
update

	self updateClass.
%

category: 'updates'
method: RowanClassService
updateClass

	"It's possible to have a nil class. For example, if we added & selected
	a class then aborted."

	| theClass |
	theClass := self theClass. 
	theClass isNil ifTrue:[oop := nil. ^self]. 
	theClass isBehavior ifFalse:[oop := theClass asOop. ^self].
	self refreshFrom: theClass.
	RowanCommandResult addResult: self
%

category: 'updates'
method: RowanClassService
updateDirtyState
	| projectService | 
	selectedPackageServices do:[:packageService | 
		packageService update. 
		RowanCommandResult addResult: packageService].
	projectService := RowanProjectService newNamed: self theClass rowanProjectName. 
	RowanCommandResult addResult: projectService.
%

category: 'initialization'
method: RowanClassService
updateIsExtension
  isExtension := ((selectedPackageServices
    collect: [ :packageService | packageService name ])
    includes: definedPackageName) not
%

category: 'updates'
method: RowanClassService
updateLatest
  oop := ((Rowan image symbolList resolveSymbol: name)
    ifNil: [ 
      wasRemoved := true.
      updateType := #'removedClass:'.
      RowanCommandResult addResult: self.
      ^ self ]) value asOop.
  super updateLatest
%

category: 'private'
method: RowanClassService
updateMethodsAfterRenameFrom: oldClassName to: newClassName
  methods
    do: [ :methodService | 
      methodService
        renamedName: oldClassName;
        className: newClassName. 
      RowanCommandResult addResult: methodService ]
%

category: 'updates'
method: RowanClassService
updatePackageProject
	| packageService projectService |

	packageService := RowanPackageService new name: packageName. 
	packageService update. 
	projectService := RowanProjectService new name: projectName. 
	projectService update.
%

category: 'private'
method: RowanClassService
updateSubclassesAfterRenameOf: newClass
  organizer := ClassOrganizer new.
  (organizer allSubclassesOf: newClass)
    do: [ :subclass | 
      | subclassService |
      subclassService := RowanClassService minimalForClassNamed: subclass name.
      RowanCommandResult addResult: subclassService ]
%

category: 'updates'
method: RowanClassService
updateSymbols: newSymbols
  | browserService |
  browserService := RowanBrowserService new.
  browserService newCachedSelectors addAll: newSymbols.
  browserService updateType: #'addCachedSymbols:'. 
  RowanCommandResult addResult: browserService
%

category: 'updates'
method: RowanClassService
updateTests
  "update the test browsers on certain operations"

  RowanBrowserService new packagesWithTests.
  (RowanPackageService new
    name: packageName;
    yourself) testClasses.
  RowanCommandResult addResult: self update
%

category: 'Accessing'
method: RowanClassService
version
	^version
%

category: 'Updating'
method: RowanClassService
version: newValue
	version := newValue
%

category: 'Accessing'
method: RowanClassService
versions
	^versions
%

category: 'Updating'
method: RowanClassService
versions: newValue
	versions := newValue
%

category: 'Accessing'
method: RowanClassService
visibleTests

	^visibleTests
%

category: 'testing'
method: RowanClassService
wasDeleted
	^(Rowan globalNamed: name) isNil
%

category: 'Accessing'
method: RowanClassService
wasRemoved: boolean

	wasRemoved := boolean
%

! Class implementation for 'RowanDebuggerService'

!		Instance methods for 'RowanDebuggerService'

category: 'debug string'
method: RowanDebuggerService
debugStringFrom: aString
  | debugStream newStream char peekChar |
  debugStream := ReadStream on: aString trimLeadingBlanks.
  [ 
  peekChar := debugStream peek.
  peekChar = Character tab
    or: [ peekChar = Character cr or: [ peekChar = Character lf ] ]	"trimLeadingBlanks doesn't look for tab or cr or lf" ]
    whileTrue: [ debugStream next ].
  debugStream contents isEmpty
    ifTrue: [ ^ 'nil halt.' ].
  newStream := WriteStream on: String new.
  (char := debugStream next) = $|
    ifTrue: [ 
      newStream nextPut: char.
      newStream
        nextPutAll: (debugStream upTo: $|);
        nextPut: $|;
        nextPut: Character space;
        nextPutAll: 'nil halt. ' ]
    ifFalse: [ 
      newStream
        nextPutAll: 'nil halt. ';
        nextPut: char ].
  newStream nextPutAll: debugStream upToEnd.
  ^ newStream contents
%

category: 'release'
method: RowanDebuggerService
releaseProcessOop: oop
  "not really releasing it. The client should have registered
	the process with the debugger window it opened before
	this is run"

  | jadeiteProcesses process |
  ((process := Object _objectForOop: oop) isKindOf: GsProcess)
    ifTrue: [ 
      jadeiteProcesses := SessionTemps current
        at: #'jadeiteProcesses'
        ifAbsentPut: [ Array new ].
      jadeiteProcesses remove: process ifAbsent: [  ] ]
%

category: 'release'
method: RowanDebuggerService
saveProcessOop: processOop
  | jadeiteProcesses process |
  process := Object _objectForOop: processOop.
  (process isKindOf: GsProcess)
    ifTrue: [ 
      jadeiteProcesses := SessionTemps current
        at: #'jadeiteProcesses'
        ifAbsentPut: [ Array new ].
      (jadeiteProcesses includes: process)
        ifFalse: [ 
          "tests may pass through this method twice"
          jadeiteProcesses add: process ] ]
%

category: 'perform'
method: RowanDebuggerService
servicePerform: symbol withArguments: collection
	^self perform: symbol withArguments: collection.
%

category: 'clientCommands'
method: RowanDebuggerService
terminateProcess: processOop
  | process |
  process := Object _objectForOop: processOop.
  (process isKindOf: GsProcess)
    ifFalse: [ ^ self ].
  RowanDebuggerService new releaseProcessOop: processOop.
  process terminate.
  (Delay forMilliseconds: 10) wait	"allow forked processes to finish"
%

category: 'updating'
method: RowanDebuggerService
update
  processes := OrderedCollection
    with:
      (RowanProcessService onActiveProcess: (Object _objectForOop: initialProcessOop)).
  ProcessorScheduler scheduler readyProcesses
    do: [ :each | processes add: (RowanProcessService new oop: each asOop; status: 'ready')]. 
  ProcessorScheduler scheduler suspendedProcesses
    do: [ :each | processes add: (RowanProcessService new oop: each asOop; status: 'suspended')]. 
  ProcessorScheduler scheduler waitingProcesses
    do: [ :each | processes add: (RowanProcessService new oop: each asOop; status: 'waiting')]. 
  RowanCommandResult addResult: self.
  self releaseProcessOop: initialProcessOop
%

! Class implementation for 'RowanDictionaryService'

!		Instance methods for 'RowanDictionaryService'

category: 'accessing'
method: RowanDictionaryService
classes
	^classes
%

category: 'accessing'
method: RowanDictionaryService
classes: object
	classes := object
%

category: 'client commands'
method: RowanDictionaryService
classHierarchy
	| theClasses |
	self update. 
	theClasses := classes collect:[:classService | classService theClass].
	"reuse behavior in package service for now" 
	hierarchyServices := (RowanPackageService new classes: classes) classHierarchy: theClasses. 
	RowanCommandResult addResult: self.
%

category: 'Updating'
method: RowanDictionaryService
defaultTemplate: newValue
	defaultTemplate := newValue
%

category: 'command support'
method: RowanDictionaryService
genericClassCreationTemplate

	^self browserTool classCreationTemplateForSubclassOf: 'Object' category: nil packageName: nil
%

category: 'initialization'
method: RowanDictionaryService
initialize

	self setDefaultTemplate
%

category: 'client commands'
method: RowanDictionaryService
insertAt: index

	| theDictionary |
	theDictionary := SymbolDictionary new. 
	theDictionary at: name asSymbol put: theDictionary. 
	System myUserProfile insertDictionary: theDictionary at: index. 
	RowanBrowserService new updateDictionaries.
%

category: 'testing'
method: RowanDictionaryService
isDictionaryService
  ^ true
%

category: 'accessing'
method: RowanDictionaryService
name
	^name
%

category: 'accessing'
method: RowanDictionaryService
name: object
	name := object
%

category: 'client commands'
method: RowanDictionaryService
removeClass: classService
	self removeClassNamed: classService name. 
	self setDefaultTemplate.
	classService updateType: #removedClass:.
	RowanCommandResult addResult: classService
%

category: 'client commands'
method: RowanDictionaryService
removeClassNamed: className

	self browserTool removeClassNamed: className.
%

category: 'client commands'
method: RowanDictionaryService
removeGlobalNamed: symbol
	| dictionary |
	dictionary := (System myUserProfile resolveSymbol: name asSymbol) value.
	dictionary ifNotNil: [
		dictionary removeKey: symbol ifAbsent:[]].
	self update.
%

category: 'perform'
method: RowanDictionaryService
servicePerform: symbol withArguments: collection
  self isUpdatingButFoundToBeDeleted
    ifTrue: [ ^ self handleDeletedService ].
  super servicePerform: symbol withArguments: collection.
  self update
%

category: 'client commands'
method: RowanDictionaryService
setDefaultTemplate

	defaultTemplate := self genericClassCreationTemplate.
%

category: 'updates'
method: RowanDictionaryService
update
  | dictionary sorted |
  classes := Array new.
  sorted := SortedCollection sortBlock: [ :x :y | x first < y first ].
  dictionary := Rowan image symbolList objectNamed: name.
  dictionary ifNil: [ ^ self ].
  (dictionary isKindOf: SymbolDictionary)
    ifFalse: [ ^ self ].
  dictionary
    keysAndValuesDo: [ :key :value | 
      value isClass
        ifTrue: [ 
          | classService |
          classService := RowanClassService new name: key asString.
          classService versions: value classHistory size.
          classService version: (value classHistory indexOf: value).
          classes add: classService ]
        ifFalse: [ 
          | printString theKey |
          printString := [ 
          value printString charSize > 1
            ifTrue: [ '<<unprintable string. charSize > 1>>' ]
            ifFalse: [ value printString ] ]
            on: Error
            do: [ :ex | 'unprintable string. Error - <' , ex printString , '>' ].
          key charSize = 1
            ifTrue: [ theKey := key ]
            ifFalse: [ theKey := '<<unprintable string. charSize > 1>>' ].
          sorted
            add:
              (Array
                with: name , '.' , theKey
                with: value class name
                with: value asOop
                with: printString) ] ].
  globals := sorted asArray.
  RowanCommandResult addResult: self
%

category: 'testing'
method: RowanDictionaryService
wasDeleted
  ^ (Rowan globalNamed: name) isNil
%

! Class implementation for 'RowanFrameService'

!		Class methods for 'RowanFrameService'

category: 'other'
classmethod: RowanFrameService
process: aGsProcess level: anInteger organizer: aClassOrganizer

	^self basicNew
		initializeProcess: aGsProcess level: anInteger organizer: aClassOrganizer;
		yourself
%

!		Instance methods for 'RowanFrameService'

category: 'other'
method: RowanFrameService
initializeProcess: aGsProcess level: anInteger organizer: aClassOrganizer
  "In 3.2.15 the server does some whacky things with IP, stepPoint, and nested methods.
	See http://kermit.gemtalksystems.com/bug?bug=45553 --JGF"

  | frameData gsNMethod homeMethodService |
  frameData := aGsProcess _frameContentsAt: anInteger.
  frameData isNil
    ifTrue: [ ^ self	"not sure if bad frame data is a 3.2.15 bug or not" ].
  oop := (frameData at: 8) asOop.
  gsNMethod := frameData at: 1.
  label := aGsProcess _reportAt: anInteger.
  method := RowanMethodService
    forGsNMethod: gsNMethod
    organizer: aClassOrganizer.
  homeMethodService := RowanMethodService
    forGsNMethod: gsNMethod homeMethod
    organizer: aClassOrganizer.
  method breakPoints: homeMethodService breakPoints.
  homeMethodSelector := gsNMethod homeMethod selector.
  homeMethodClassName := gsNMethod homeMethod inClass
    ifNotNil: [ :cls | 
      | className |
      className := cls name asString.
      classIsResolvable := (Rowan image
        resolveClassNamed: cls theNonMetaClass name asString) isNil not.
      className ].
  stepPoint := gsNMethod == gsNMethod homeMethod
    ifTrue: [ aGsProcess _stepPointAt: anInteger ]
    ifFalse: [ gsNMethod homeMethod _stepPointForMeth: gsNMethod ip: (frameData at: 2) ].
  vars := self varsFor: frameData
%

category: 'perform'
method: RowanFrameService
servicePerform: symbol withArguments: collection
	^self perform: symbol withArguments: collection.
%

category: 'other'
method: RowanFrameService
varsFor: anArray

	| keys list receiver values |
	receiver := anArray at: 10.
	values := OrderedCollection new.
	(Reflection classOf: receiver) name == #'ClientForwarder' ifTrue: [
		keys := OrderedCollection with: 'clientObject'.
		values add: receiver clientObject.
		receiver := '[aClientForwarder(' , (self oopOf: receiver) printString , ')]'.
	] ifFalse: [
		((receiver isKindOf: BlockClosure) or: [receiver isKindOf: Class]) ifTrue: [
			keys := OrderedCollection new.
		] ifFalse: [
			keys := receiver class allInstVarNames asOrderedCollection collect: [:each | '-' , each].
			1 to: keys size do: [:i |
				values add: (receiver instVarAt: i).
			].
		].
	].
	keys addFirst: #'receiver'.
	values addFirst: receiver.
	keys addAll: (anArray at: 9).
	keys := keys reject: [:each | each first == $.].
	values addAll: (anArray size >= 11
		ifTrue: [anArray copyFrom: 11 to: anArray size]
		ifFalse: [#()]).
	list := Array new.
	1 to: (keys size min: values size) do: [:i | | theOop key value valueClass | 
		key := keys at: i.
		value := values at: i.
		valueClass := value class.
		theOop := value asOop.
		value := [
			value printString.
		] on: Error do: [:ex | 
			ex return: '(' , value class name , ' printString error: ' , ex description , ')'. 
		].
		value size > 500 ifTrue: [value := (value copyFrom: 1 to: 500) , '...'].
		value := value collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$?] ifFalse: [char]].
		list add: (RowanVariableService oop: theOop key: key value: value className: valueClass name asString).
	].
	^list
%

! Class implementation for 'RowanInspectorService'

!		Instance methods for 'RowanInspectorService'

category: 'command support'
method: RowanInspectorService
addDynamicInstVars: anObject
  | dynamic dynamicSize |
  dynamic := anObject dynamicInstanceVariables.
  dynamicSize := dynamic size.
  1 to: dynamicSize do: [ :i | 
    objects
      add:
        ('--' , (self stripOutUnicode: (dynamic at: i)))
          -> (Reflection oopOf: (anObject dynamicInstVarAt: (dynamic at: i))) ]
%

category: 'command support'
method: RowanInspectorService
addFirstIndexedVars: anObject
  | max |
  self setIndexedSize: anObject.
  max := indexedSize min: maxIndexedVars.
  objects addAll: (self safeVariablesFrom: 1 to: max).
  visibleIndices := max
%

category: 'command support'
method: RowanInspectorService
addInstVars: anObject
  | namedSize |
  instVarNames := anObject class allInstVarNames.
  namedSize := instVarNames size.
  1 to: namedSize do: [ :i | 
    objects
      add:
        ('-' , (self stripOutUnicode: (instVarNames at: i) asString))
          -> (Reflection oopOf: (anObject instVarAt: i)) ]
%

category: 'client commands'
method: RowanInspectorService
addKey: keyString
  | newObject theObject |
  theObject := Object _objectForOop: oop.
  newObject := keyString
    evaluateInContext: theObject
    symbolList: Rowan image symbolList.
  theObject at: newObject ifAbsentPut: nil.
  selectionOop := newObject asOop.
  objects := OrderedCollection new.
  isOop := true.
  self inspect: oop
%

category: 'client commands'
method: RowanInspectorService
addObject: string after: index
  | newObject theObject |
  theObject := Object _objectForOop: oop.
  newObject := string
    evaluateInContext: theObject
    symbolList: Rowan image symbolList.
  theObject class isIndexable
    ifTrue: [ 
      | insertionCollection |
      insertionCollection := (theObject isKindOf: CharacterCollection)
        ifTrue: [ newObject ]
        ifFalse: [ Array with: newObject ].
      theObject insertAll: insertionCollection at: index + 1 ]
    ifFalse: [ theObject add: newObject ].
  selectionOop := newObject asOop.
  objects := OrderedCollection new.
  isOop := true.
  self inspect: oop.
  theObject class isIndexable
    ifTrue: [ self inspect: oop from: visibleIndices to: visibleIndices + 1 ]
%

category: 'client commands'
method: RowanInspectorService
executeThenInspect: string context: anOop inWindow: handle
  | answer |
  answer := RowanAnsweringService new basicExec: string context: anOop.
  answer key
    ifTrue: [ 
      RowanBrowserService new saveRootObject: answer value windowHandle: handle.
      self inspect: answer value ]
    ifFalse: [ 
      compileErrorArray := answer value.
      RowanCommandResult addResult: self ]
%

category: 'client commands'
method: RowanInspectorService
executeThenInspect: string inFrame: level process: processOop context: contextOop inWindow: handle
  | answer |
  answer := RowanAnsweringService new exec: string inFrame: level ofProcess: processOop context: contextOop.
  answer key
    ifTrue: [ 
      RowanBrowserService new saveRootObject: answer value windowHandle: handle.
      self inspect: answer value ]
    ifFalse: [ 
      compileErrorArray := answer value.
      RowanCommandResult addResult: self ]
%

category: 'initialization'
method: RowanInspectorService
initialize
  super initialize.
  objects := OrderedCollection new.
  instVarsAreRemovable := false.
  isUnordered := false
%

category: 'client commands'
method: RowanInspectorService
inspect: oopOrObject
  ^ self inspect: oopOrObject inWindow: nil
%

category: 'client commands'
method: RowanInspectorService
inspect: anOop from: indexStart to: indexStop
  | anObject stop |
  anObject := Object _objectForOop: anOop.
  stop := (indexStop min: indexedSize) min: self maxVariables.
  nextIndices := self safeVariablesFrom: indexStart to: stop.
  visibleIndices := stop.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanInspectorService
inspect: oopOrObject inWindow: handle
  | anObject |
  self setOopFrom: oopOrObject.
  handle
    ifNotNil: [ RowanBrowserService new saveRootObject: oop windowHandle: handle ].
  anObject := Object _objectForOop: oop.
  isVariable := anObject class isVariable.
  (self isClientForwarder: anObject)
    ifTrue: [ ^ self inspectClientForwarder: anObject ].
  className := anObject class name.
  myself := 'self' -> (self selfPrintString: anObject).
  (anObject isKindOf: Dictionary superclass)
    ifTrue: [ ^ objects addAll: (self inspectDictionary: anObject from: 1 to: maxIndexedVars) ].
  self addInstVars: anObject.
  self addDynamicInstVars: anObject.
  self addFirstIndexedVars: anObject.
  RowanCommandResult addResult: self
%

category: 'command support'
method: RowanInspectorService
inspectClientForwarder: anObject

	oop := Reflection oopOf: anObject. 
	myself := 'self' -> anObject clientObject printString. 
	RowanCommandResult addResult: self.
%

category: 'command support'
method: RowanInspectorService
inspectDictionary: aDictionary from: start to: stop
  | sortedKeys service |
  isDictionary := true.
  instVarsAreRemovable := true.
  self addInstVars: aDictionary.
  self addDynamicInstVars: aDictionary.
  service := RowanAnsweringService new.
  sortedKeys := (aDictionary keys
    collect: [ :key | 
      (service basicPrintStringOfObject: key toMaxSize: self maxPrintStringSize)
        -> key ]) asSortedCollection.
  visibleIndices := (sortedKeys size min: stop) min: self maxVariables.
  nextIndices := OrderedCollection new.
  (sortedKeys copyFrom: start to: visibleIndices)
    do: [ :assoc | 
      nextIndices
        add:
          assoc key
            ->
              (Array
                with: (Reflection oopOf: assoc value)
                with: (Reflection oopOf: (aDictionary at: assoc value))) ].
  indexedSize := aDictionary size.
  RowanCommandResult addResult: self.
  ^ nextIndices
%

category: 'testing'
method: RowanInspectorService
isClientForwarder: anObject

	^(Reflection classOf: anObject) name == #'ClientForwarder'
%

category: 'constants'
method: RowanInspectorService
maxPrintStringSize
  "currently matches Jadeite client"

  ^ 100000
%

category: 'constants'
method: RowanInspectorService
maxVariables
	"See Jadeite issue #668. Currently, 
	Dolphin doesn't seem to be able to 
	handle more than about 65k elements
	in a list
	https://github.com/GemTalk/Jadeite/issues/668#issuecomment-566795924" 
	
	^65000
%

category: 'client commands'
method: RowanInspectorService
nextIndexedVarsFrom: indexStart to: indexStop
  | stop anObject |
  anObject := Object _objectForOop: oop.
  (anObject isKindOf: Dictionary superclass)
    ifTrue: [ 
      ^ objects
        addAll:
          (self inspectDictionary: anObject from: indexStart to: indexStop) ].
  stop := (indexStop min: indexedSize) min: self maxVariables.
  nextIndices := self safeVariablesFrom: indexStart to: stop.
  visibleIndices := stop.
  RowanCommandResult addResult: self
%

category: 'accessing'
method: RowanInspectorService
oop: anInteger

	oop := anInteger
%

category: 'private'
method: RowanInspectorService
reinspect: theObject
  | formerlyVisible |
  formerlyVisible := visibleIndices.
  objects := OrderedCollection new.
  isOop := false.
  self inspect: theObject.
  (visibleIndices > 0 and: [ visibleIndices < formerlyVisible ])
    ifTrue: [ self inspect: oop from: visibleIndices to: formerlyVisible ]
%

category: 'client commands'
method: RowanInspectorService
removeDynamicInstVars: dynamicInstVarNames
  | theObject |
  theObject := Object _objectForOop: oop.
  dynamicInstVarNames
    do: [ :dynamicInstVar | theObject removeDynamicInstVar: dynamicInstVar ].
  self reinspect: theObject
%

category: 'client commands'
method: RowanInspectorService
removeIndexedInstVarsAt: indices
  | theObject removalObjects |
  theObject := Object _objectForOop: oop.
  removalObjects := indices collect: [ :index | theObject at: index ].
  removalObjects do: [ :removalObject | theObject remove: removalObject ].
  self reinspect: theObject
%

category: 'client commands'
method: RowanInspectorService
removeKeys: keyOops
  | theObject removalKey |
  theObject := Object _objectForOop: oop.
  keyOops
    do: [ :keyOop | 
      removalKey := Object _objectForOop: keyOop.
      theObject removeKey: removalKey.
      visibleIndices := visibleIndices - 1 max: 0 ].
  self reinspect: theObject
%

category: 'client commands'
method: RowanInspectorService
removeOop: elementOop
  | theObject removal |
  theObject := Object _objectForOop: oop.
  removal := Object _objectForOop: elementOop.
  theObject remove: removal.
  self reinspect: theObject
%

category: 'client commands'
method: RowanInspectorService
replaceElement: oldOop with: string
  | theObject newObject formerlyVisible oldObject |
  theObject := Object _objectForOop: oop.
  newObject := string
    evaluateInContext: theObject
    symbolList: Rowan image symbolList.
  oldObject := Object _objectForOop: oldOop.
  theObject remove: oldObject.
  theObject add: newObject.
  selectionOop := newObject asOop.
  formerlyVisible := visibleIndices.
  objects := OrderedCollection new.
  isOop := false.
  self inspect: theObject.
  visibleIndices > 0
    ifTrue: [ self inspect: oop from: visibleIndices to: formerlyVisible ]
%

category: 'command support'
method: RowanInspectorService
safeVariablesFrom: indexStart to: indexStop
  [ ^ self variablesFrom: indexStart to: indexStop ]
    on: Error
    do: [ :ex | 
      indexedSize := 0.
      instVarsAreRemovable := false.
      visibleIndices := 0 to: 0.
      nextIndices := 0 to: 0.
      isVariable := false.
      statusText := 'Error getting object contents: ' , ex description.
      ^ OrderedCollection new ]
%

category: 'client commands'
method: RowanInspectorService
save: string dynamicInstVar: instVarName
  | theObject newObject |
  theObject := Object _objectForOop: oop.
  newObject := string
    evaluateInContext: theObject
    symbolList: Rowan image symbolList.
  theObject dynamicInstVarAt: instVarName put: newObject.
  self reinspect: theObject
%

category: 'client commands'
method: RowanInspectorService
save: string indexedVarAt: index
  | theObject newObject formerlyVisible |
  theObject := Object _objectForOop: oop.
  newObject := string
    evaluateInContext: theObject
    symbolList: Rowan image symbolList.
  theObject at: index put: newObject.
  formerlyVisible := visibleIndices.
  objects := OrderedCollection new.
  isOop := false.
  self inspect: theObject.
  visibleIndices > 0
    ifTrue: [ self inspect: oop from: visibleIndices to: formerlyVisible ]
%

category: 'client commands'
method: RowanInspectorService
save: string namedInstVar: instVarName
  | theObject newObject instVarIndex |
  theObject := Object _objectForOop: oop.
  newObject := string
    evaluateInContext: theObject
    symbolList: Rowan image symbolList.
  instVarIndex := theObject class allInstVarNames indexOf: instVarName.
  theObject instVarAt: instVarIndex put: newObject.
  self reinspect: theObject
%

category: 'client commands'
method: RowanInspectorService
saveKey: keyOop value: string
  | theObject newObject key |
  theObject := Object _objectForOop: oop.
  newObject := string
    evaluateInContext: theObject
    symbolList: Rowan image symbolList.
  key := Object _objectForOop: keyOop.
  theObject at: key put: newObject.
  self reinspect: theObject
%

category: 'printing'
method: RowanInspectorService
selfPrintString: anObject
  ^ [ self stripOutUnicode: anObject printString ]
    on: Error
    do: [ :ex | 
      | printString |
      printString := 'Error printing object with oop ' , oop printString
        , '. Error text: ' , ex printString ]
%

category: 'private'
method: RowanInspectorService
setIndexedSize: anObject
  indexedSize := anObject class isVariable
    ifFalse: [ 0 ]
    ifTrue: [ 
      instVarsAreRemovable := true.
      (self shouldReferenceBySize: anObject)
        ifTrue: [ anObject size ]
        ifFalse: [ anObject _primitiveSize - anObject class allInstVarNames size ] ]
%

category: 'private'
method: RowanInspectorService
setOopFrom: oopOrObject
  oop := isOop
    ifTrue: [ oopOrObject ]
    ifFalse: [ Reflection oopOf: oopOrObject ]
%

category: 'testing'
method: RowanInspectorService
shouldReferenceBySize: anObject

	(anObject isKindOf: UnorderedCollection) ifTrue:[^true].
	(anObject isKindOf: MultiByteString) ifTrue:[^true]. 
	^false
%

category: 'command support'
method: RowanInspectorService
variablesFrom: indexStart to: indexStop
  | namedSize anObject indexedVars |
  indexedVars := OrderedCollection new.
  anObject := Object _objectForOop: oop.
  namedSize := anObject class allInstVarNames size.
  isUnordered := anObject isKindOf: UnorderedCollection.
  isUnordered
    ifTrue: [ 
      | sorted service |
      service := RowanAnsweringService new.
      sorted := (anObject
        collect: [ :var | 
          (service basicPrintStringOfObject: var toMaxSize: self maxPrintStringSize)
            -> (Reflection oopOf: var) ]) asSortedCollection: [:x :y | x key < y key]. 
      indexStart to: indexStop do: [ :i | indexedVars add: (sorted at: i) ] ]
    ifFalse: [ indexStart to: indexStop do: [ :i | indexedVars add: i printString -> (Reflection oopOf: (anObject at: i)) ] ].
  ^ indexedVars
%

! Class implementation for 'RowanLoggingService'

!		Class methods for 'RowanLoggingService'

category: 'accessing'
classmethod: RowanLoggingService
current

	"lazy initialize for a topaz session test" 
	^SessionTemps current at: #rowanLoggingService ifAbsentPut: [RowanLoggingService new]
%

category: 'accessing'
classmethod: RowanLoggingService
current: anObject

	SessionTemps current at: #rowanLoggingService put: anObject
%

!		Instance methods for 'RowanLoggingService'

category: 'accessing'
method: RowanLoggingService
fileName
	^fileName
%

category: 'accessing'
method: RowanLoggingService
fileName: object
	fileName := object
%

category: 'initialization'
method: RowanLoggingService
initialize

	super initialize. 
	isLogging := false.
%

category: 'client commands'
method: RowanLoggingService
logComment: string

	| stonString ws |
	isLogging ifFalse:[^self].
	comment := string.
	id := id + 1. 
	date := Date today.
	time := Time now.
	location := #server.
	stonString := STON toString: self.
	ws := FileStreamPortable 
				write: fileName
				mode: #append.
	[ws nextPutAll: stonString] ensure: [ws close].
	comment := nil "service may be reused. Clear comment"
%

category: 'accessing'
method: RowanLoggingService
logFileContents

	| rs |
	rs := [FileStreamPortable read: fileName] on: Error do:[:ex | ^String new].
	[^rs contents] ensure: [rs close]
%

category: 'client commands'
method: RowanLoggingService
logReceivedServices

	mode := #received.
	self class current: self. 
	self logServices
%

category: 'client commands'
method: RowanLoggingService
logSentServices

	mode := #sent.
	services := RowanCommandResult results copy asOrderedCollection.
	self logServices.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanLoggingService
logServices

	| stonString ws |
	isLogging ifFalse:[^self].
	id := id + 1. 
	date := Date today.
	time := Time now.
	location := #server.
	stonString := STON toString: self.
	ws := FileStreamPortable 
				write: fileName
				mode: #append.
	[ws nextPutAll: stonString] ensure: [ws close]
%

! Class implementation for 'RowanMethodService'

!		Class methods for 'RowanMethodService'

category: 'instance creation'
classmethod: RowanMethodService
forGsNMethod: aGsNMethod organizer: anOrganizer
	^self new
		initialize: aGsNMethod organizer: anOrganizer;
		yourself
%

category: 'instance creation'
classmethod: RowanMethodService
forSelector: sel class: theClass meta: boolean organizer: anOrganizer

	| service |
	service := self new. 
	service selector: sel;
		meta: boolean.
	service forClass: theClass organizer: anOrganizer.
	^service
%

category: 'utility'
classmethod: RowanMethodService
put: string onStreamWithoutUnicode: stream

	string do:[:char | 
			char asInteger > 255 ifTrue:[
				stream nextPutAll: '$\x', char asInteger asHexString]
			ifFalse:[
				stream nextPut: char
			]].
%

category: 'utility'
classmethod: RowanMethodService
removeUnicode: string

		| ws | 
		ws := WriteStream on: String new. 
		self put: string onStreamWithoutUnicode: ws. 
		^ws contents
%

category: 'utility'
classmethod: RowanMethodService
removeUnicodeFromSource: string

	"possibly a unicode string which is not yet 
	presentable in Jadeite."

	(string isKindOf: MultiByteString) ifTrue:[
		| ws | 
		ws := WriteStream on: String new. 
		ws nextPutAll: '''METHOD SOURCE CANNOT BE DISPLAYED
This method source contains unicode and is not displayable in Jadeite. 
An approximation of the source code is given printed below with $\x<char hex value>
replacing the actual unicode character.''';
			cr; 
			cr.
		self put: string onStreamWithoutUnicode: ws. 
		^ws contents]
	ifFalse:[
		^string].
%

category: 'instance creation'
classmethod: RowanMethodService
source: source selector: selector category: category className: className packageName: packageName meta: boolString

	| service |
	self rowanFixMe. "Need to include super and sub implementors"
	service := self new. 
	service 
		source: source;
		selector: selector;
		category: category asString;
		className: className;
		packageName: packageName;
		meta: boolString == true.
	^service
%

!		Instance methods for 'RowanMethodService'

category: 'comparing'
method: RowanMethodService
= methodService
	(methodService class canUnderstand: #isMethodService) ifFalse:[^false].
	methodService isMethodService ifFalse:[^false].
	^selector = methodService selector
		and: [className asString = methodService className asString and: [meta = methodService meta]]
%

category: 'Accessing'
method: RowanMethodService
accessedInstVars
  ^ accessedInstVars
%

category: 'Updating'
method: RowanMethodService
accessedInstVars: anArray
	accessedInstVars := anArray
%

category: 'rowan'
method: RowanMethodService
addOrUpdateMethod

		self browserTool  
                   addOrUpdateMethod: source
                   inProtocol: category
                   forClassNamed: self classService name
                   isMeta: meta
                   inPackageNamed: self classService packageName
%

category: 'method history'
method: RowanMethodService
addToMethodHistory
  | rowanMethodHistory methodHistory |
  rowanMethodHistory := self userGlobals
    at: #'RowanMethodHistory'
    ifAbsentPut: [ Dictionary new ].
  methodHistory := rowanMethodHistory at: self ifAbsentPut: [ Array new ].
  methodHistory add: self
%

category: 'client commands'
method: RowanMethodService
allReferences
  | methods |
  oop := self gsNMethod asOop.
  methods := organizer sendersOf: selector.
  references := methods first
    collect: [ :gsNMethod | self class forGsNMethod: gsNMethod organizer: organizer ].
  RowanCommandResult addResult: self
%

category: 'Accessing'
method: RowanMethodService
breakPoints

	^breakPoints
%

category: 'Accessing'
method: RowanMethodService
breakPoints: collection
  breakPoints := collection
%

category: 'initialization'
method: RowanMethodService
breakPointsFor: aGsNMethod
  "Answers an Array stepPoints"

  | theMethod |
  theMethod := aGsNMethod isMethodForBlock
    ifTrue: [ 
      isMethodForBlock := true.
      aGsNMethod homeMethod ]
    ifFalse: [ aGsNMethod ].
  homeMethodOop := theMethod asOop.
	^ self _initializeBreakPointsFor: theMethod
%

category: 'Accessing'
method: RowanMethodService
category
	^category
%

category: 'Updating'
method: RowanMethodService
category: newValue
	category := newValue asString
%

category: 'Accessing'
method: RowanMethodService
classFromName
  "the dictionary browser may have versions numbers in the name"

  | nameSymbol |
  nameSymbol := (className copyUpTo: Character space) asSymbol.
  ^ (System myUserProfile resolveSymbol: nameSymbol) value
%

category: 'Accessing'
method: RowanMethodService
className
	^className
%

category: 'Updating'
method: RowanMethodService
className: newValue
	className := newValue asString
%

category: 'Accessing'
method: RowanMethodService
classOrMeta

	^meta 
			ifTrue:[self classFromName class] 
			ifFalse: [self classFromName].
%

category: 'Accessing'
method: RowanMethodService
classService

	^classService ifNil:[classService := RowanClassService forClassNamed: className package: packageName]
%

category: 'Updating'
method: RowanMethodService
classService: newValue
	classService := newValue
%

category: 'client commands'
method: RowanMethodService
clearBreakAt: stepPoint
	| method |
	method := self isUnboundMethod 
			ifTrue:[(Object _objectForOop: oop) homeMethod] 
			ifFalse:[self gsNMethod].
	method clearBreakAtStepPoint: stepPoint.
	self update. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanMethodService
clearMethodBreaks
  self update.
  breakPoints do: [ :breakPoint | self clearBreakAt: breakPoint ]
%

category: 'Updating'
method: RowanMethodService
comparisonSource: string

	comparisonSource := string
%

category: 'Accessing'
method: RowanMethodService
compilationWarnings

	^compilationWarnings
%

category: 'Updating'
method: RowanMethodService
compilationWarnings: newValue
	compilationWarnings := newValue
%

category: 'client commands'
method: RowanMethodService
debugTest: testSelector inClassName: theClassName
  testResult := 'passed'.
  [ (Rowan image objectNamed: theClassName) debug: testSelector asSymbol ]
    on: Exception
    do: [ :ex | 
      RowanDebuggerService new saveProcessOop: GsProcess _current asOop.
      testResult := ex class = TestFailure
        ifTrue: [ 'failure' ]
        ifFalse: [ 
          (ex class isSubclassOf: Notification)
            ifTrue: [ 'passed' ]
            ifFalse: [ 'error' ] ].
      ex pass ].
  testRunClassName := theClassName.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanMethodService
debugTestAsFailure: testSelector inClassName: theClassName
  testResult := 'passed'.
  [ 
  ((Rowan image objectNamed: theClassName) selector: testSelector asSymbol)
    debugAsFailure ]
    on: Exception
    do: [ :ex | 
      RowanDebuggerService new saveProcessOop: GsProcess _current asOop.
      testResult := ex class = TestFailure
        ifTrue: [ 'failure' ]
        ifFalse: [ 
          (ex class isSubclassOf: Notification)
            ifTrue: [ 'passed' ]
            ifFalse: [ 'error' ] ].
      ex pass ].
  testRunClassName := theClassName.
  RowanCommandResult addResult: self
%

category: 'accessing'
method: RowanMethodService
definedClassName
	^definedClassName
%

category: 'accessing'
method: RowanMethodService
definedClassName: object
	definedClassName := object
%

category: 'Accessing'
method: RowanMethodService
definedPackage

	^definedPackage
%

category: 'rowan'
method: RowanMethodService
definitionClass

	^RwMethodDefinition
%

category: 'client commands'
method: RowanMethodService
disableBreakAt: stepPoint
	| method |
	method := self isUnboundMethod 
			ifTrue:[(Object _objectForOop: oop) homeMethod] 
			ifFalse:[self gsNMethod].
	method disableBreakAtStepPoint: stepPoint.
	self update. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanMethodService
disableMethodBreaks
  self update.
  breakPoints do: [ :breakPoint | self disableBreakAt: breakPoint ]
%

category: 'client commands'
method: RowanMethodService
enableBreakAt: stepPoint
	| method |
	method := self isUnboundMethod 
			ifTrue:[(Object _objectForOop: oop) homeMethod] 
			ifFalse:[self gsNMethod].
	method setBreakAtStepPoint: stepPoint.
	self update. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanMethodService
enableMethodBreaks
  self update.
  breakPoints do: [ :breakPoint | self enableBreakAt: breakPoint ]
%

category: 'Updating'
method: RowanMethodService
failedCompile: boolean	
	
	failedCompile := boolean
%

category: 'client commands'
method: RowanMethodService
fileout
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	ws nextPutAll: (self behavior fileOutMethod: selector asString environmentId: 0).
	answeringService answer: ws contents.
	RowanCommandResult addResult: answeringService.
%

category: 'Accessing'
method: RowanMethodService
firstReference: integer

	firstReference := integer
%

category: 'initialization'
method: RowanMethodService
forClass: theClass organizer: theOrganizer
  "assume meta and selector are set"

  | classOrMeta gsNMethod |
  organizer := theOrganizer.
  classOrMeta := meta
    ifTrue: [ theClass class ]
    ifFalse: [ theClass ].
  gsNMethod := classOrMeta compiledMethodAt: selector.
  definedPackage := gsNMethod rowanPackageName.
  oop := gsNMethod asOop.
  stepPoints := self stepPointsFor: gsNMethod.
  breakPoints := self breakPointsFor: gsNMethod.
  self updateSource: gsNMethod sourceString.
  category := (classOrMeta categoryOfSelector: selector) asString.
  className := theClass name asString.
  packageName := gsNMethod rowanPackageName.
  projectName := gsNMethod rowanProjectName.
  self setSupersAndSubsFor: classOrMeta.
  isExtension := self rowanIsExtension.
  self initializeTestMethodsFor: classOrMeta thisClass
%

category: 'Accessing'
method: RowanMethodService
gsNMethod

	^[self classOrMeta compiledMethodAt: selector ] on: Error do:[:ex | nil "removed method"]
%

category: 'comparing'
method: RowanMethodService
hash
  ^ (selector hash bitXor: className hash) bitXor: meta hash
%

category: 'Accessing'
method: RowanMethodService
hasSubs

	^hasSubs
%

category: 'Updating'
method: RowanMethodService
hasSubs: aBoolean

	hasSubs := aBoolean
%

category: 'Accessing'
method: RowanMethodService
hasSupers

	^hasSupers
%

category: 'Updating'
method: RowanMethodService
hasSupers: aBoolean

	hasSupers := aBoolean
%

category: 'initialization'
method: RowanMethodService
initialize

	super initialize. 
	hasSupers := false. 
	hasSubs := false.
	accessedInstVars := Array new.
	isTestMethod := false.
	failedCompile := false.
	isMethodForBlock := false.
	hasMethodHistory := true.
%

category: 'initialization'
method: RowanMethodService
initialize: aGsNMethod organizer: aClassOrganizer

	| inClass |
	oop := aGsNMethod asOop.
	definedPackage := aGsNMethod rowanPackageName. 
	selector := aGsNMethod selector.
	stepPoints := self stepPointsFor: aGsNMethod.
	breakPoints := self breakPointsFor: aGsNMethod.
	((inClass := aGsNMethod inClass) isNil or: [selector isNil]) ifTrue: [
		meta := false.
		self updateSource: aGsNMethod sourceString.
		hasSupers := false.
		hasSubs := false.
		organizer := aClassOrganizer. 
		inSelectedPackage := false.
		^self
	].
	meta := inClass isMeta.
	self 
		forClass: inClass thisClass 
		organizer: aClassOrganizer.
	self initializeTestMethodsFor: inClass thisClass.
	self setHasMethodHistory
%

category: 'initialization'
method: RowanMethodService
initializeTestMethodsFor: aClass
	| testSelectors |
	(aClass inheritsFrom: TestCase)
		ifTrue: [ 
			aClass isAbstract
				ifTrue: [ ^ self ].
			testSelectors := aClass thisClass allTestSelectors.
			isTestMethod := testSelectors includes: selector ]
%

category: 'testing'
method: RowanMethodService
isMethodService

	^true
%

category: 'testing'
method: RowanMethodService
isTestMethod

	^isTestMethod
%

category: 'Updating'
method: RowanMethodService
isTestMethod: boolean

	isTestMethod := boolean
%

category: 'testing'
method: RowanMethodService
isUnboundMethod

	(className notNil and: [selector notNil]) ifTrue:[^false].
	^(Object _objectForOop: oop) isKindOf: GsNMethod
%

category: 'Accessing'
method: RowanMethodService
meta
	^meta
%

category: 'Updating'
method: RowanMethodService
meta: aBoolean
	"allow nil parameter for now" 
	meta := aBoolean == true
%

category: 'Accessing'
method: RowanMethodService
method

	^self classFromName compiledMethodAt: selector otherwise: nil
%

category: 'Accessing'
method: RowanMethodService
methodDefinitions
	^methodDefinitions
%

category: 'Updating'
method: RowanMethodService
methodDefinitions: newValue
	methodDefinitions := newValue
%

category: 'Accessing'
method: RowanMethodService
name

	^selector
%

category: 'accessing'
method: RowanMethodService
oop
	^oop
%

category: 'accessing'
method: RowanMethodService
oop: object
	oop := object
%

category: 'Accessing'
method: RowanMethodService
packageName
	^packageName
%

category: 'Updating'
method: RowanMethodService
packageName: newValue
	packageName := newValue
%

category: 'printing'
method: RowanMethodService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $(;
				nextPutAll: (className ifNil:[nil printString]); 
				nextPutAll: '>>'; 
				nextPutAll: (selector ifNil:[nil printString]);
				nextPut: $)
%

category: 'client commands'
method: RowanMethodService
reformatSource
  source := (RBParser parseMethod: source) formattedCode.
  updateType := #'dontUpdateSystem'.	"let browser update the source"
  RowanCommandResult addResult: self
%

category: 'rowan'
method: RowanMethodService
removeSelector: sel class: clsName
	
	self rowanFixMe. "combine remove methods variants"
	self browserTool removeMethod: sel asSymbol forClassNamed: (clsName subStrings first) isMeta: (clsName subStrings size = 2)
%

category: 'Accessing'
method: RowanMethodService
renamedName
	^renamedName
%

category: 'Accessing'
method: RowanMethodService
renamedName: object
	renamedName := object
%

category: 'rowan'
method: RowanMethodService
rowanIsExtension

	^Rowan projectTools browser isExtensionMethod: selector asString forClassNamed: className asString isMeta: meta
%

category: 'rowan'
method: RowanMethodService
rowanProjectName

	^projectName
%

category: 'client commands'
method: RowanMethodService
runTest: testSelector inClassName: theClassName

	| sunitTestResult |
	sunitTestResult := (Rowan image objectNamed: theClassName) run: testSelector asSymbol.
	sunitTestResult errorCount > 0 ifTrue:[testResult := 'error']. 
	sunitTestResult failureCount > 0 ifTrue:[testResult := 'failure']. 
	sunitTestResult passedCount > 0 ifTrue:[testResult := 'passed']. 
	testRunClassName := theClassName. 
	RowanCommandResult addResult: self.
%

category: 'accessing'
method: RowanMethodService
searchString
	^searchString
%

category: 'accessing'
method: RowanMethodService
searchString: object
	searchString := object
%

category: 'Accessing'
method: RowanMethodService
selectedPackageServices

	^selectedPackageServices
%

category: 'Updating'
method: RowanMethodService
selectedPackageServices: collection

	selectedPackageServices := collection
%

category: 'Accessing'
method: RowanMethodService
selector

	^selector
%

category: 'Updating'
method: RowanMethodService
selector: aSymbol

	selector := aSymbol
%

category: 'perform'
method: RowanMethodService
servicePerform: symbol withArguments: collection
  | theCommand |
  self isUpdatingButFoundToBeDeleted
    ifTrue: [ ^ self handleDeletedService ].
  theCommand := command.
  super servicePerform: symbol withArguments: collection.
  theCommand = #'reformatSource'
    ifFalse: [ self update ]
%

category: 'client commands'
method: RowanMethodService
setBreakAt: stepPoint
  | method |
  method := self isUnboundMethod
    ifTrue: [ (Object _objectForOop: oop) homeMethod ]
    ifFalse: [ self gsNMethod ].
  method setBreakAtStepPoint: stepPoint.
  self class breakPointsAreEnabled
    ifFalse: [ self disableBreakAt: stepPoint ].
  self update.
  RowanCommandResult addResult: self
%

category: 'method history'
method: RowanMethodService
setHasMethodHistory
  | answeringService |
  answeringService := RowanAnsweringService new.
  hasMethodHistory := (answeringService basicMethodHistoryFor: self) answer size
    > 1.
%

category: 'initialization'
method: RowanMethodService
setSupersAndSubsFor: theClass

	| theSuper |
	theSuper := theClass superClass. 
	hasSupers := false. 
	[theSuper notNil and:[hasSupers not]] whileTrue:[
		hasSupers := theSuper selectors includes: selector.
		hasSupers ifTrue:[
			comparisonSource := theSuper sourceCodeAt: selector.
			superDisplayString := theSuper name, '>>', selector].
		theSuper := theSuper superClass].
	(organizer allSubclassesOf: theClass thisClass) do:[:cls |
		| aClass |
		aClass := theClass isMeta ifTrue:[cls class] ifFalse:[cls]. 
		(hasSubs := aClass includesSelector: selector) ifTrue:[
		^self]].
%

category: 'Accessing'
method: RowanMethodService
source

	^source
%

category: 'Updating'
method: RowanMethodService
source: string
	
	self updateSource: string
%

category: 'Accessing'
method: RowanMethodService
stepPoints

	"for testing"
	
	^stepPoints
%

category: 'Updating'
method: RowanMethodService
stepPoints: collection

	stepPoints := collection
%

category: 'initialization'
method: RowanMethodService
stepPointsFor: aGsNMethod
	"Answers an Array of Associations (offset -> selector) indexed by step point"

	|  selectors list |
	(selectors := aGsNMethod _sourceOffsetsOfSends) ifNil: [^#()].
	list := aGsNMethod homeMethod  _sourceOffsets.
	list := list collect: [:each |
		| index eachSelector |
		eachSelector := ''.
		index := selectors indexOf: each.
		0 < index ifTrue: [eachSelector := selectors at: index + 1].
		each -> eachSelector.
	].
	^list
%

category: 'Accessing'
method: RowanMethodService
testResult

	^testResult
%

category: 'updates'
method: RowanMethodService
update
	self isUnboundMethod ifFalse:[
		self wasRecycled ifTrue:[oop := self gsNMethod asOop].
		self wasDeleted ifTrue:[
			self updateType: #methodsRemoved:. 
			^RowanCommandResult addResult: self. ].  "removed method"
		oop ifNil: [oop := self gsNMethod asOop]].
	self 
		initialize: (Object _objectForOop: oop) 
		organizer: organizer.
	RowanCommandResult addResult: self.
%

category: 'updates'
method: RowanMethodService
updateLatest
  | theClass compiledMethod |
  theClass := (RowanClassService new name: className) theClass.
  theClass ifNil: [ ^ self ].
  compiledMethod := theClass compiledMethodAt: selector otherwise: nil.
  compiledMethod ifNil: [ ^ self ].
  oop := compiledMethod asOop.
  super updateLatest
%

category: 'private'
method: RowanMethodService
updateSource: string

	source := self class removeUnicodeFromSource: string
%

category: 'testing'
method: RowanMethodService
wasDeleted
	selector isNil ifTrue:[^false].
	^self gsNMethod isNil
%

category: 'testing'
method: RowanMethodService
wasRecycled
	(oop notNil and:[self gsNMethod asOop ~= oop]) ifTrue:[^true].
	^false
%

! Class implementation for 'RowanPackageService'

!		Class methods for 'RowanPackageService'

category: 'instance creation'
classmethod: RowanPackageService
forPackageNamed: aName

	| inst |
	inst := self new.  
	inst name: aName.
	aName isNil ifFalse:[
		inst isDirty. "lazy initialize"].
	inst setDefaultTemplate. 
	inst updateProjectName.
	^inst
%

!		Instance methods for 'RowanPackageService'

category: 'comparing'
method: RowanPackageService
= packageService
	(packageService isKindOf: RowanPackageService) ifFalse:[^false].
	^name = packageService name
%

category: 'testing'
method: RowanPackageService
arePackageAndProjectClean
  ^ self rowanDirty not and: [ self projectIsDirty not ]
%

category: 'rowan'
method: RowanPackageService
changes
   "diffForPackageName: not implemented yet"
 
 self error: 'this message is no longer supported'
%

category: 'other'
method: RowanPackageService
classes: collection

	classes := collection
%

category: 'client commands'
method: RowanPackageService
classHierarchy
	| theClasses |
	self update. 
	theClasses := classes collect:[:classService | classService theClass].
	hierarchyServices := self classHierarchy: theClasses. 
	RowanCommandResult addResult: self.
%

category: 'commands support'
method: RowanPackageService
classHierarchy: theClasses
  hierarchyServices := super classHierarchy: theClasses.
  ^ hierarchyServices
%

category: 'rowan'
method: RowanPackageService
createPackageNamed: aString inProject: projName
	| projectService | 
	name := aString.
	projectService := RowanProjectService new.
	projectDefinition := projectService createProjectNamed: projName.  
	projectDefinition addPackageNamed: name.
	self projectTools load loadProjectDefinition: projectDefinition.
%

category: 'Updating'
method: RowanPackageService
defaultTemplate: newValue
	defaultTemplate := newValue
%

category: 'rowan'
method: RowanPackageService
definition

	^(Rowan image loadedPackageNamed: name) asDefinition
%

category: 'rowan'
method: RowanPackageService
deletePackage

	self browserTool removePackageNamed: name.
%

category: 'rowan'
method: RowanPackageService
genericClassCreationTemplate

	^self browserTool classCreationTemplateForSubclassOf: 'Object' category: name packageName: nil
%

category: 'comparing'
method: RowanPackageService
hash
	^self name hash
%

category: 'Accessing'
method: RowanPackageService
hierarchyServices

	^hierarchyServices
%

category: 'rowan'
method: RowanPackageService
isDirty

	^isDirty := self rowanDirty
%

category: 'Updating'
method: RowanPackageService
isDirty: boolean

	isDirty := boolean
%

category: 'testing'
method: RowanPackageService
isPackageService

	^true
%

category: 'Accessing'
method: RowanPackageService
jadeite_testClasses

	"for testing" 
	^testClasses
%

category: 'rowan'
method: RowanPackageService
loadedClasses

	| loadedPackage |
	loadedPackage := Rowan image loadedPackageNamed: name ifAbsent:[^KeyValueDictionary new].
	^loadedPackage loadedClasses
%

category: 'rowan'
method: RowanPackageService
loadedClassExtensions

	| loadedPackage |
	loadedPackage := Rowan image loadedPackageNamed: name ifAbsent:[^KeyValueDictionary new].
	^loadedPackage loadedClassExtensions
%

category: 'rowan'
method: RowanPackageService
loadedClassHandles
	| loadedClasses |
	loadedClasses := self loadedClasses collect:[:loadedClass | loadedClass handle].
	loadedClasses addAll: (self loadedClassExtensions collect:[:extension | extension handle]).
	^loadedClasses
%

category: 'rowan'
method: RowanPackageService
loadedClassNames

	^self loadedClasses collect:[:loadedClass | loadedClass name]
%

category: 'Accessing'
method: RowanPackageService
name
	^name
%

category: 'Updating'
method: RowanPackageService
name: newValue
	name := newValue
%

category: 'Accessing'
method: RowanPackageService
packageName
	^name
%

category: 'Updating'
method: RowanPackageService
packageName: newValue
	name := newValue
%

category: 'printing'
method: RowanPackageService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $:. 
	aStream nextPutAll: (name ifNil: [nil printString])
%

category: 'Accessing'
method: RowanPackageService
projectDefinition
	^projectDefinition
%

category: 'Updating'
method: RowanPackageService
projectDefinition: newValue
	projectDefinition := newValue
%

category: 'testing'
method: RowanPackageService
projectIsDirty
  projectName ifNil: [ self updateProjectName ].
  ^ (RowanProjectService new name: projectName) rowanDirty
%

category: 'Accessing'
method: RowanPackageService
projectName
	^projectName
%

category: 'Updating'
method: RowanPackageService
projectName: newValue
	projectName := newValue
%

category: 'client commands'
method: RowanPackageService
removeClass: classService
  self removeClassNamed: classService name.
  self setDefaultTemplate.
  classService updateType: #'removedClass:'.
  classService wasRemoved: true.
  RowanCommandResult addResult: classService.
  RowanBrowserService new packagesWithTests	"sunit browser might need updated"
%

category: 'commands support'
method: RowanPackageService
removeClassNamed: className

	self browserTool removeClassNamed: className.
%

category: 'rowan'
method: RowanPackageService
rowanDirty

	^(RwPackage newNamed: name) isDirty
%

category: 'rowan'
method: RowanPackageService
rowanProjectName

	^projectName
%

category: 'other'
method: RowanPackageService
selectedClass
	
	^selectedClass
%

category: 'Accessing'
method: RowanPackageService
selectedClass: classService
	selectedClass := classService.
	classService selectedPackageServices: (Array with: self)
%

category: 'perform'
method: RowanPackageService
servicePerform: symbol withArguments: collection
  | wasClean |
  self isUpdatingButFoundToBeDeleted
    ifTrue: [ ^ self handleDeletedService ].
  wasClean := self arePackageAndProjectClean.
  super servicePerform: symbol withArguments: collection.
  self update.
  wasClean
    ifTrue: [ self updateProject ]
%

category: 'commands support'
method: RowanPackageService
services: services from: levels expand: toExpand
  ^ self
    services: services
    from: levels
    expand: toExpand
    classes: (classes collect: [ :classService | classService theClass ])
%

category: 'client commands'
method: RowanPackageService
setDefaultTemplate

	defaultTemplate := self genericClassCreationTemplate.
%

category: 'client commands'
method: RowanPackageService
testClasses
  organizer := ClassOrganizer new.
  testClasses := Set new.
  self loadedClasses
    valuesDo: [ :loadedClass | 
      | cls |
      cls := loadedClass handle.
      (cls inheritsFrom: TestCase)
        ifTrue: [ 
          cls isAbstract
            ifFalse: [ 
              | classService |
              classService := RowanClassService basicForClassNamed: cls name.
              testClasses add: classService ] ] ].
  self loadedClassExtensions
    valuesDo: [ :loadedClass | 
      | cls |
      cls := loadedClass handle.
      (cls inheritsFrom: TestCase)
        ifTrue: [ 
          cls isAbstract
            ifFalse: [ 
              | classService |
              classService := RowanClassService basicForClassNamed: cls name.
              testClasses add: classService ] ] ].
  updateType := #'testClasses:browser:'.
  testClasses := testClasses asArray.
  testClasses do: [ :classService | classService update ].
  RowanCommandResult addResult: self
%

category: 'updates'
method: RowanPackageService
update
	Rowan image loadedPackageNamed: name ifAbsent: [^self]. 
	classes := (self loadedClassNames keys collect:[:string | RowanClassService minimalForClassNamed: string]) asArray.
	classes addAll: (self loadedClassExtensions keys collect:[:string | 
		| classService | 
		classService := (RowanClassService minimalForClassNamed: string) 
			isExtension: true.
		(Rowan image loadedClassForClass: classService theClass ifAbsent:[]) 
			ifNotNil:[:cls | classService definedPackageName: cls packageName].
		classService]).
	classes do: [:clsService | clsService packageName: self name]. 
	self isDirty. 
	projectName := (Rowan image loadedPackageNamed: name) projectName.
	RowanCommandResult addResult: self
%

category: 'updates'
method: RowanPackageService
updateInternalService: updatedService

	"when sending services back to the client,
	verify any services held by this object are 
	updated. Services know what internal services
	they contain." 

	1 to: classes size do:[:index |
		| classesService |
		classesService := classes at: index. 
		classesService = updatedService ifTrue:[
			classes at: index put: updatedService
		]].
%

category: 'updates'
method: RowanPackageService
updateProject
	| projectService |

	projectService := RowanProjectService new name: projectName. 
	projectService update.
	RowanCommandResult addResult: projectService.
%

category: 'updates'
method: RowanPackageService
updateProjectName

	projectName := (Rowan image loadedPackageNamed: name) projectName.
%

category: 'testing'
method: RowanPackageService
wasDeleted

	^(Rowan image loadedPackageNamed: name
			ifAbsent: []) isNil
%

! Class implementation for 'RowanProcessService'

!		Class methods for 'RowanProcessService'

category: 'instance creation'
classmethod: RowanProcessService
new

	"in general use one of the other constructor methods.
	Needed for STON replication"
	^super new
%

category: 'instance creation'
classmethod: RowanProcessService
onActiveProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'active';
		yourself
%

category: 'instance creation'
classmethod: RowanProcessService
onReadyProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'ready';
		yourself
%

category: 'instance creation'
classmethod: RowanProcessService
onSuspendedProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'suspended';
		yourself
%

category: 'instance creation'
classmethod: RowanProcessService
onWaitingProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'waiting';
		yourself
%

!		Instance methods for 'RowanProcessService'

category: 'initialize'
method: RowanProcessService
initialize

	frames := Array new
%

category: 'initialize'
method: RowanProcessService
initialize: aGsProcess status: aString

	| theOrganizer |
	theOrganizer := ClassOrganizer new. 
	frames := Array new: aGsProcess stackDepth.
	1 to: aGsProcess stackDepth do: [:i | 
		frames at: i put: (RowanFrameService process: aGsProcess level: i organizer: theOrganizer).
	].
	oop := aGsProcess asOop.  
	status := aString.
%

category: 'accessing'
method: RowanProcessService
oop
	^oop
%

category: 'accessing'
method: RowanProcessService
oop: object
	oop := object
%

category: 'perform'
method: RowanProcessService
servicePerform: symbol withArguments: collection
	^self perform: symbol withArguments: collection.
%

category: 'accessing'
method: RowanProcessService
status
	^status
%

category: 'accessing'
method: RowanProcessService
status: object
	status := object
%

category: 'updating'
method: RowanProcessService
update

	self initialize: (Object _objectForOop: oop) status: 'suspended'.
	RowanCommandResult addResult: self.
%

! Class implementation for 'RowanProjectService'

!		Class methods for 'RowanProjectService'

category: 'instance creation'
classmethod: RowanProjectService
newNamed: aString

	| inst |
	inst := self new.
	inst name: aString.
	inst refresh.
	^inst
%

!		Instance methods for 'RowanProjectService'

category: 'comparing'
method: RowanProjectService
= projectService
	^projectService isProjectService ifTrue: [name = projectService name] ifFalse: [^false]
%

category: 'initialization'
method: RowanProjectService
basicRefresh
	name = Rowan unpackagedName ifTrue:[
		isLoaded := false.
		RowanBrowserService new updateDictionaries. ^self]. 
	(isLoaded := self projectIsLoaded) ifFalse:[
		existsOnDisk := false. 
		updateType := #removedProject:. 
		^RowanCommandResult addResult: self]. 
	isDirty := self isDirty. 
	self setExistsOnDisk.
	isSkew := self isSkew.
	sha := self rowanSha.
	branch := self rowanBranch.
	projectUrl := self rowanProjectUrl. 
	rowanProjectsHome := System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME' .
	isDiskDirty := self isGitDirty.
	RowanCommandResult addResult: self
%

category: 'accessing'
method: RowanProjectService
branch

	name isNil ifTrue:[^String new].
	^self rwProject currentBranchName
%

category: 'accessing'
method: RowanProjectService
branch: anObject

	branch := anObject
%

category: 'client commands'
method: RowanProjectService
changes

	| jadeServer projectNames |
	jadeServer := Rowan platform jadeServerClassNamed: #JadeServer. 
	changes := Array new. 
	projectNames := name ifNil: [ Rowan projectNames ] ifNotNil: [ { name } ].
	projectNames do: [:aProjectName | 
		(Rowan projectTools diff
			patchesForProjectNamed: aProjectName) do: [:assoc | 
				"key is packageName, value is a CypressPatch"
				| patch |
				patch := assoc value.
				changes add:(jadeServer new
					_mcDescriptionOfPatch: patch
					baseName: 'closest ancestor'
					alternateName: nil) ] ].
	self refresh.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanProjectService
checkout: branchName

	| project branches |

	project := self rwProject. 
	branches := Rowan gitTools gitcheckoutIn: project repositoryRootPath asFileReference with: branchName.
	^branches
%

category: 'client commands'
method: RowanProjectService
checkoutTag: tagName
  Rowan gitTools gitcheckoutIn: self repositoryRootPath with: tagName
%

category: 'client commands'
method: RowanProjectService
commitWithMessage: message
	
	Rowan projectTools write writeProjectNamed: name.
	Rowan projectTools commit
		commitProjectNamed: name
		message: message.
%

category: 'examples'
method: RowanProjectService
createProjectNamed: projectName 

	^self createProjectNamed: projectName in: self sampleSymbolDictionaryName.
%

category: 'examples'
method: RowanProjectService
createProjectNamed: projectName in: symbolDictionaryName

	self rowanFixMe. "Dale doesn't like Rowan projectNames"
	(Rowan projectNames includes: projectName) ifFalse:[
		self browserTool createGitPackageProjectNamed: projectName updateDefinition: [:pd | 
				pd defaultSymbolDictName: symbolDictionaryName; comment:  'Sample Rowan Project'] ].
%

category: 'replication'
method: RowanProjectService
excludedInstVars

	^ super excludedInstVars, #( #rwProject)
%

category: 'accessing'
method: RowanProjectService
existsOnDisk

	^existsOnDisk
%

category: 'comparing'
method: RowanProjectService
hash
	^self name hash
%

category: 'initialization'
method: RowanProjectService
initialize

	super initialize. 
	packages := Array new.
	isDiskDirty := false.
%

category: 'rowan'
method: RowanProjectService
isDirty
	name isNil
		ifTrue: [ ^ false ].
	^ self rwProject isDirty
%

category: 'accessing'
method: RowanProjectService
isDirty: aBoolean

	isDirty := aBoolean.
%

category: 'client commands'
method: RowanProjectService
isGitDirty
  "From https://github.com/GemTalk/Jadeite/issues/323#issuecomment-442545934"

  [ 
  ^ (Rowan gitTools gitstatusIn: self repositoryRootPath with: '--porcelain')
    isEmpty not ]
    on: Error
    do: [ :ignored | ^ false ]
%

category: 'rowan'
method: RowanProjectService
isSkew
	| repositorySha |
	name isNil ifTrue:[^false].
	self existsOnDisk ifFalse:[^false]. 
	repositorySha := [self repositorySha] on: Error do:[:ex | repositorySha := 'not on disk'].
	^self sha ~= repositorySha
%

category: 'client commands'
method: RowanProjectService
loadProjectNamed: aName

	[Rowan projectTools load loadProjectNamed: aName] 
		on: Warning
		do: [ :ex | Transcript cr; show: ex description. ex resume ].
	RowanBrowserService new updateProjects.
%

category: 'rowan'
method: RowanProjectService
log

	^self rwProject commitLog: 25
%

category: 'accessing'
method: RowanProjectService
name

	^name
%

category: 'accessing'
method: RowanProjectService
name: anObject

	name := anObject
%

category: 'client commands'
method: RowanProjectService
newGitProject: url root: rootPath useSsh: useSsh
	"set useSsh to false to clone using https:"

	Rowan projectTools clone
		cloneSpecUrl: url
		gitRootPath: rootPath
		useSsh: useSsh.
	(RowanBrowserService new organizer: organizer) updateProjects.
%

category: 'rowan'
method: RowanProjectService
packageNames
	"if no project is selected, return all package names"
	^name isNil ifTrue:[
		"list of visible packageNames for current user"
		Rowan image packageNames ]
	ifFalse:[
		"list of visible packageNames for current user and named project"
		Rowan image packageNamesForLoadedProjectNamed: name ]
%

category: 'rowan'
method: RowanProjectService
packageNameString
		"return a string showing the package names for a project"

	| ws packageNames |
	ws := WriteStream on: String new.
	ws
		nextPutAll: 'Packages for project: ' , name;
		cr.
	packageNames := Set new.
	packageNames addAll: (Rowan image loadedProjectNamed: name) packageNames.
	packageNames asSortedCollection do: 
			[:packageName |
			ws
				cr; 
				tab;
				nextPutAll: packageName
			].
	^ws contents
%

category: 'accessing'
method: RowanProjectService
packageServices

	^self packageNames collect:[:packageName | RowanPackageService forPackageNamed: packageName]
%

category: 'client commands'
method: RowanProjectService
performGitCommand: gitCommand with: argsString
  | project |
  project := RwProject newNamed: name.
  Rowan gitTools
    performGitCommand: gitCommand
    in: project repositoryRootPath
    with: argsString.
  RowanCommandResult addResult: self
%

category: 'printing'
method: RowanProjectService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $:. 
	aStream nextPutAll: (name ifNil: [nil printString])
%

category: 'testing'
method: RowanProjectService
projectIsLoaded

	^(Rowan image
		loadedProjectNamed: name
		ifAbsent: []) notNil
%

category: 'rowan'
method: RowanProjectService
projects

		^Rowan projectNames collect: 
			[:string |
			| service |
			service := self class new name: string. 
			service 
				sha: service rowanSha;
				branch: service rowanBranch;
				isDirty: service rowanDirty]
%

category: 'accessing'
method: RowanProjectService
projectUrl

	^projectUrl
%

category: 'accessing'
method: RowanProjectService
projectUrl: anObject

	projectUrl := anObject
%

category: 'client commands'
method: RowanProjectService
pullFromGit

	| project |
	project := self rwProject. 
	Rowan gitTools
		gitpullIn: project repositoryRootPath
		remote: project remote
		branch: project currentBranchName
%

category: 'client commands'
method: RowanProjectService
pushToGit

	| project |
	project := self rwProject. 
	Rowan gitTools
		gitpushIn: project repositoryRootPath
		remote: project remote
		branch: project currentBranchName
%

category: 'initialization'
method: RowanProjectService
refresh
	self basicRefresh. 
	isLoaded ifTrue:[
		packages := self packageServices].
%

category: 'client commands'
method: RowanProjectService
reloadProject
  [ Rowan projectTools load loadProjectNamed: name ]
    on: Warning
    do: [ :ex | 
      Transcript
        cr;
        show: ex description.
      ex resume ].
  self update.
  RowanCommandResult addResult: self.
  RowanBrowserService new packagesWithTests
%

category: 'rowan'
method: RowanProjectService
removeProjectNamed: projectName
   "remove project"
 
    (Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
      ifNotNil: [ :project | Rowan image _removeLoadedProject: project ]
%

category: 'rowan'
method: RowanProjectService
repositoryRootPath

	^(RwProject newNamed: name) repositoryRootPath
%

category: 'rowan'
method: RowanProjectService
repositorySha
	^ self rwProject repositoryCommitId
%

category: 'rowan'
method: RowanProjectService
rowanBranch
	
	name isNil ifTrue:[^String new].
	^ [  self rwProject currentBranchName ] on: Error do: [:ex | ^'ERROR getting repository branch' ]
%

category: 'rowan'
method: RowanProjectService
rowanDirty

	^(RwProject newNamed: name) isDirty
%

category: 'rowan'
method: RowanProjectService
rowanProjectName

	^name
%

category: 'rowan'
method: RowanProjectService
rowanProjectUrl

	^(RwProject newNamed: name) projectUrl
%

category: 'rowan'
method: RowanProjectService
rowanSha

	name isNil ifTrue:[^0].
	^(RwProject newNamed: name) loadedCommitId
%

category: 'rowan'
method: RowanProjectService
rowanSkew

	^self sha ~= self repositorySha
%

category: 'accessing'
method: RowanProjectService
rwProject
	^ rwProject ifNil: [ rwProject := RwProject newNamed: name ]
%

category: 'perform'
method: RowanProjectService
servicePerform: symbol withArguments: collection
  self isUpdatingButFoundToBeDeleted
    ifTrue: [ ^ self handleDeletedService ].
  super servicePerform: symbol withArguments: collection.
  self update
%

category: 'rowan'
method: RowanProjectService
setExistsOnDisk
	"might be a better test than #repositorySha for
	determining if a project exists on disk." 

	existsOnDisk := (RwProject newNamed: name) existsOnDisk.
%

category: 'accessing'
method: RowanProjectService
sha

	name isNil ifTrue:[^0].
	^self rwProject loadedCommitId
%

category: 'accessing'
method: RowanProjectService
sha: anObject

	"because skew is intimately associated with sha
	set it here" 
	sha := anObject.
	isSkew := self rowanSkew
%

category: 'rowan'
method: RowanProjectService
unload

	| loadedProject |
	loadedProject := Rowan image loadedProjects select:[:proj | proj name = name].
%

category: 'update'
method: RowanProjectService
update
	self refresh.
%

category: 'update'
method: RowanProjectService
updateInternalService: updatedService

	"when sending services back to the client,
	verify any services held by this object are 
	updated. Services know what internal services
	they contain." 

	1 to: packages size do:[:index |
		| packageService |
		packageService := packages at: index. 
		packageService = updatedService ifTrue:[
			packages at: index put: updatedService
		]].
%

category: 'testing'
method: RowanProjectService
wasDeleted
  ^ self projectIsLoaded not
%

category: 'client commands'
method: RowanProjectService
write
	Rowan projectTools write writeProjectNamed: name
%

category: 'accessing'
method: RowanProjectService
_isSkew

	^isSkew
%

! Class implementation for 'RowanQueryService'

!		Instance methods for 'RowanQueryService'

category: 'private'
method: RowanQueryService
basicBreakpointMethods
  | bpMethods bpArray |
  bpMethods := Array new.
  bpArray := (GsNMethod _breakReport: true) at: 2.
  bpArray do: [ :array | bpMethods add: (array at: 5) ].
  ^ (self methodServicesFrom: bpMethods) asSet asArray
%

category: 'queries'
method: RowanQueryService
breakPointMethods
  queryResults := self basicBreakpointMethods.
  self returnQueryToClient
%

category: 'queries'
method: RowanQueryService
browseClassReferences: className

	| methods |
	methods := organizer referencesTo: className asSymbol.
	queryResults := self methodServicesFrom: methods first.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
browseReferencesTo: symbol

	| methods |
	methods := organizer referencesTo: symbol.
	queryResults := self methodServicesFrom: methods first.
	self returnQueryToClient.
%

category: 'private'
method: RowanQueryService
defaultProjectLogSize

	^100
%

category: 'queries'
method: RowanQueryService
gitTagListUsing: projectService
  | answerString readStream |
  Rowan gitTools
    performGitCommand: 'fetch'
    in: projectService repositoryRootPath
    with: '--tags'.
  answerString := Rowan gitTools
    performGitCommand: 'tag'
    in: projectService repositoryRootPath
    with: '--sort=-taggerdate'.
  queryResults := Array new.
  readStream := ReadStream on: answerString.
  [ readStream atEnd ]
    whileFalse: [ queryResults add: (readStream upTo: Character lf) ].
  RowanCommandResult addResult: self
%

category: 'queries'
method: RowanQueryService
hierarchyImplementorsOf: selector inClass: className

	| methods behavior classes |
	behavior := Rowan globalNamed: className.
	classes := behavior allSuperclasses. 
	classes add: behavior. 
	classes addAll: (organizer allSubclassesOf: behavior). 
	methods := organizer implementorsOf: selector in: classes.
	queryResults := self methodServicesFrom: methods.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
hierarchySendersOf: selector inClass: className

	| methods behavior classes |
	behavior := Rowan globalNamed: className.
	classes := behavior allSuperclasses. 
	classes add: behavior. 
	classes addAll: (organizer allSubclassesOf: behavior). 
	methods := organizer sendersOf: selector in: classes.
	queryResults := self methodServicesFrom: methods first.
	self setFirstReferenceUsing: queryResults and: methods. 
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
implementorsOf: selector

	| methods |
	methods := organizer implementorsOf: selector asSymbol.
	queryResults := self methodServicesFrom: methods.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
instVarReaders: instVarName in: className
  | methods symbolAssociation theClasses |
  symbolAssociation := Rowan image symbolList resolveSymbol: className.
  symbolAssociation ifNil: [ ^ self ].
  theClasses := symbolAssociation value allSuperclasses.
  theClasses add: symbolAssociation value.
  theClasses addAll: (organizer allSubclassesOf: symbolAssociation value).
  methods := Array new.
  theClasses
    do: [ :theClass | 
      theClass
        methodsDo: [ :selector :method | 
          (method instVarsRead includes: instVarName asSymbol)
            ifTrue: [ methods add: method ] ] ].
  queryResults := self methodServicesFrom: methods.
  self returnQueryToClient
%

category: 'queries'
method: RowanQueryService
instVarWriters: instVarName in: className
  | methods symbolAssociation theClasses |
  symbolAssociation := Rowan image symbolList resolveSymbol: className.
  symbolAssociation ifNil: [ ^ self ].
  theClasses := symbolAssociation value allSuperclasses.
  theClasses add: symbolAssociation value.
  theClasses addAll: (organizer allSubclassesOf: symbolAssociation value).
  methods := Array new.
  theClasses
    do: [ :theClass | 
      theClass
        methodsDo: [ :selector :method | 
          (method instVarsWritten includes: instVarName asSymbol)
            ifTrue: [ methods add: method ] ] ].
  queryResults := self methodServicesFrom: methods.
  self returnQueryToClient
%

category: 'queries'
method: RowanQueryService
literalReferences: string

	| methods compilationResult |
	compilationResult := string evaluate.  
	methods := organizer referencesToLiteral: compilationResult.
	queryResults := self methodServicesFrom: methods first.
	self setFirstReferenceUsing: queryResults and: methods.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
methodsContaining: string
  | methods sorted |
  methods := organizer substringSearch: string.
  sorted := SortedCollection
    sortBlock: [ :x :y | 
      x className = y className
        ifTrue: [ x selector < y selector ]
        ifFalse: [ x className < y className ] ].
  1 to: methods first size do: [ :index | 
    | methodService |
    methodService := self methodServiceFrom: (methods first at: index).
    methodService
      firstReference: ((methods at: 2) at: index);   "<<<< FIX HERE"
      searchString: string.
    sorted add: methodService ].
  queryResults := sorted asArray.
  self returnQueryToClient
%

category: 'query support'
method: RowanQueryService
methodServiceFrom: method
  ^ (self methodServicesFrom: (Array with: method)) first
%

category: 'query support'
method: RowanQueryService
methodServicesFrom: methods

	| sorted | 
	sorted := SortedCollection sortBlock: [:x :y | x className = y className ifTrue:[x selector < y selector] ifFalse:[x className < y className]].
	sorted addAll: (methods collect:[:gsNMethod | 
			RowanMethodService forSelector: gsNMethod selector class: gsNMethod inClass thisClass meta: gsNMethod inClass isMeta organizer: organizer]).
	^sorted asArray
%

category: 'queries'
method: RowanQueryService
projectBranches: projectName

	| project  |
	project := (RwProject newNamed: projectName). 
	queryResults := Rowan gitTools gitbranchIn: project repositoryRootPath with: ''.
	RowanCommandResult addResult: self
%

category: 'queries'
method: RowanQueryService
projectLog: projectName

	queryResults := (Rowan projectNamed: projectName) commitLog: self defaultProjectLogSize.
	RowanCommandResult addResult: self.
%

category: 'queryResults'
method: RowanQueryService
queryResults

	"for tests. So far, not needed on server." 

	^queryResults
%

category: 'private'
method: RowanQueryService
returnQueryToClient

	queryResults do:[:service |
		RowanCommandResult addResult: service].
	RowanCommandResult addResult: self.
%

category: 'queries'
method: RowanQueryService
sendersOf: selector

	| methods |
	methods := organizer sendersOf: selector asSymbol.
	queryResults := self methodServicesFrom: methods first.
	self setFirstReferenceUsing: queryResults and: methods. 
	self returnQueryToClient.
%

category: 'queryResults'
method: RowanQueryService
setFirstReferenceUsing: results and: methods
  results
    do: [ :methodService | 
      | gsMethod index |
      gsMethod := methods first
        detect: [ :meth | 
          meth selector = methodService selector
            and: [ meth inClass thisClass name asString = methodService className ] ]
        ifNone: [ 
          methodService firstReference: nil.
          nil ].
      gsMethod
        ifNotNil: [ 
          index := methods first indexOf: gsMethod.
          methodService firstReference: (methods last at: index) ] ]
%

category: 'ston'
method: RowanQueryService
stonOn: stonWriter   
	| instanceVariableNames |
	instanceVariableNames := self class allInstVarNames reject: [:iv | self excludedInstVars includes: iv].
	stonWriter writeObject: self
		streamMap: 
			[:dictionary |
			instanceVariableNames do: 
					[:each |
					(self instVarAt: (self class allInstVarNames indexOf: each asSymbol))
						ifNotNil: [:value | dictionary at: each asSymbol put: value]
						ifNil: [self stonShouldWriteNilInstVars ifTrue: [dictionary at: each asSymbol put: nil]]]]
%

category: 'update'
method: RowanQueryService
updateInternalService: updatedService

	"when sending services back to the client,
	verify any services held by this object are 
	updated. Services know what internal services
	they contain." 
	1 to: queryResults size do:[:index |
		| service |
		service := queryResults at: index. 
		service = updatedService ifTrue:[ 
			queryResults at: index put: updatedService
		]].
%

! Class implementation for 'RowanVariableService'

!		Class methods for 'RowanVariableService'

category: 'other'
classmethod: RowanVariableService
oop: anInteger key: nameString value: valueString className: classNameString

	^self basicNew
		oop: anInteger key: nameString value: valueString className: classNameString;
		yourself
%

!		Instance methods for 'RowanVariableService'

category: 'other'
method: RowanVariableService
oop: anInteger key: nameString value: valueString className: classNameString

	oop := anInteger.
	key := nameString.
	value := valueString.
	className := classNameString.
%

! Class implementation for 'RwAbstractConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwAbstractConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwAbstractConfigurationPlatformAttributeMatcher
match: anObject

	self subclassResponsibility: #match:
%

category: 'matching'
method: RwAbstractConfigurationPlatformAttributeMatcher
matchString: aString

	self subclassResponsibility: #matchString:
%

category: 'matching'
method: RwAbstractConfigurationPlatformAttributeMatcher
matchVersion: anRwGemStoneVersionNumber

	self subclassResponsibility: #matchVersion:
%

category: 'accessing'
method: RwAbstractConfigurationPlatformAttributeMatcher
pattern: anObject
	pattern := anObject
%

category: 'accessing'
method: RwAbstractConfigurationPlatformAttributeMatcher
patternMatchBlock: aBlock
	patternMatchBlock := aBlock
%

! Class implementation for 'RwGemStoneVersionConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwGemStoneVersionConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwGemStoneVersionConfigurationPlatformAttributeMatcher
match: anObject

	^ anObject rwPlatformAttributeMatchForGemStoneVersion: self
%

category: 'matching'
method: RwGemStoneVersionConfigurationPlatformAttributeMatcher
matchString: aString

	^ false
%

category: 'matching'
method: RwGemStoneVersionConfigurationPlatformAttributeMatcher
matchVersion: aGemStoneVersion

	^ patternMatchBlock cull: pattern cull: aGemStoneVersion
%

! Class implementation for 'RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
matchVersion: aGemStoneVersion

	^ patternMatchBlock cull: pattern cull: aGemStoneVersion cull: pattern2
%

category: 'accessing'
method: RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
pattern2: anObject
	pattern2 := anObject
%

! Class implementation for 'RwStringConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwStringConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwStringConfigurationPlatformAttributeMatcher
match: anObject

	^ anObject rwPlatformAttributeMatchForString: self
%

category: 'matching'
method: RwStringConfigurationPlatformAttributeMatcher
matchString: aString

	^ patternMatchBlock cull: pattern cull: aString
%

category: 'matching'
method: RwStringConfigurationPlatformAttributeMatcher
matchVersion: aGemStoneVersion

	^ false
%

! Class implementation for 'RwAbstractProjectComponentVisitorV2'

!		Class methods for 'RwAbstractProjectComponentVisitorV2'

category: 'instance creation'
classmethod: RwAbstractProjectComponentVisitorV2
new

	^super new initialize
%

!		Instance methods for 'RwAbstractProjectComponentVisitorV2'

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
componentNames

	^ componentNames
%

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
componentsPath
	^ self subclassResponsibility: #'componentsPath'
%

category: 'initialization'
method: RwAbstractProjectComponentVisitorV2
initialize
	visitedComponentNames := Set new.
	projectNames := Set new.
	componentNames := Set new.
	readComponents := Dictionary new.
	readProjects := Dictionary new.
	platformConditionalAttributes := #().
	projectLoadSpecs := Set new.
	visitedComponents := Dictionary new
%

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
packageNames

	self subclassResponsibility: #packageNames
%

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
platformConditionalAttributes

	^ platformConditionalAttributes
%

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
platformConditionalAttributes: aColl

	platformConditionalAttributes := aColl
%

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
projectLoadSpecs

	^ projectLoadSpecs
%

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
projectNames

	^ projectNames
%

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
projectsPath
	^ self subclassResponsibility: #'projectsPath'
%

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
readComponents

	^ readComponents
%

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
readProjects

	^ readProjects
%

category: 'visiting'
method: RwAbstractProjectComponentVisitorV2
visit: aProjectLoadComponent

	^aProjectLoadComponent acceptVisitor: self
%

category: 'accessing'
method: RwAbstractProjectComponentVisitorV2
visitedComponents

	^ visitedComponents
%

category: 'visiting'
method: RwAbstractProjectComponentVisitorV2
visitLoadSpecification: aLoadSpecification

	self projectLoadSpecs add: aLoadSpecification
%

category: 'visiting'
method: RwAbstractProjectComponentVisitorV2
visitSimpleProjectLoadComponent: aSimpleProjectLoadComponent
	(visitedComponentNames includes: aSimpleProjectLoadComponent name)
		ifTrue: [ ^ self ].

	self _visited: aSimpleProjectLoadComponent.

	aSimpleProjectLoadComponent conditionalPropertyMatchers
		keysAndValuesDo: [ :platformMatchers :ignored | 
			(self _platformAttributeMatchIn: platformMatchers)
				ifTrue: [ 
					self
						_addPackageNames: aSimpleProjectLoadComponent packageNames
						for: aSimpleProjectLoadComponent.
					self componentNames addAll: aSimpleProjectLoadComponent componentNames.
					self projectNames addAll: aSimpleProjectLoadComponent projectNames ] ].

	(self
		_components: self componentsPath
		forProject: aSimpleProjectLoadComponent projectName)
		do: [ :component | 
			(visitedComponentNames includes: component name)
				ifFalse: [ component acceptNestedVisitor: self ] ].

	(self
		_projects: self projectsPath
		forProject: aSimpleProjectLoadComponent projectName)
		do: [ :projectSpec | projectSpec acceptVisitor: self ]
%

category: 'private'
method: RwAbstractProjectComponentVisitorV2
_addPackageNames: somePackageNames for: aComponent

	self subclassResponsibility: #_addPackageNames:for:
%

category: 'private'
method: RwAbstractProjectComponentVisitorV2
_matchPlatformAttributes: platformPatternMatcher

	self platformConditionalAttributes do: [:anObject |
		(platformPatternMatcher match: anObject) ifTrue: [ ^true ] ].
	^false
%

category: 'private'
method: RwAbstractProjectComponentVisitorV2
_platformAttributeMatchIn: platformMatchersList

	platformMatchersList do: [:platformPatternMatcher |
		(self _matchPlatformAttributes: platformPatternMatcher) 
			ifTrue: [ ^true ] ].
	^false
%

category: 'private'
method: RwAbstractProjectComponentVisitorV2
_visited: aComponent

	visitedComponentNames add:  aComponent name.
	visitedComponents at: aComponent name put: aComponent.
%

! Class implementation for 'RwResolvedProjectComponentVisitorV2'

!		Class methods for 'RwResolvedProjectComponentVisitorV2'

category: 'reading'
classmethod: RwResolvedProjectComponentVisitorV2
readProjectForResolvedProject: resolvedProject withComponentNames: componentNamesToRead platformConditionalAttributes: platformConditionalAttributes
	| visitor |
	visitor := self new
		_readComponentsForResolvedProject: resolvedProject
		withComponentNames: componentNamesToRead
		platformConditionalAttributes: platformConditionalAttributes.
	resolvedProject
		projectDefinitionSourceProperty:
				RwLoadedProject _projectDiskDefinitionSourceValue;
		projectDefinitionPlatformConditionalAttributes:
				platformConditionalAttributes copy;
		yourself.
	visitor visitedComponents
		keysAndValuesDo: [ :cName :cmp | resolvedProject components _addComponent: cmp ].
	^ visitor
%

category: 'reading'
classmethod: RwResolvedProjectComponentVisitorV2
readProjectSetForResolvedProject: resolvedProject withComponentNames: componentNamesToRead platformConditionalAttributes: platformConditionalAttributes
	| projectSetDefinition visitor projectVisitorQueue projectVisitedQueue |
	projectSetDefinition := RwProjectSetDefinition new.
	projectVisitedQueue := {}.
	projectVisitorQueue := {{resolvedProject.
	componentNamesToRead}}.
	[ projectVisitorQueue isEmpty ]
		whileFalse: [ 
			| nextDefArray rp cn |
			nextDefArray := projectVisitorQueue removeFirst.
			rp := nextDefArray at: 1.
			cn := nextDefArray at: 2.

			visitor := self
				readProjectForResolvedProject: rp
				withComponentNames: cn
				platformConditionalAttributes: platformConditionalAttributes.

			projectVisitedQueue
				addLast:
					{visitor.
					nextDefArray}.

			visitor projectLoadSpecs
				do: [ :loadSpec | 
					| theResolvedProject theLoadSpec |
					(Rowan projectNamed: loadSpec projectName ifAbsent: [  ])
						ifNotNil: [ :project | 
							"project is already present in image ... so use it"
							theLoadSpec := project _loadSpecification.
							theResolvedProject := theLoadSpec resolveWithParentProject: project	"give embedded projects a chance" ]
						ifNil: [ 
							"derive resolved project from the load spec"
							theResolvedProject := loadSpec resolveWithParentProject: rp.	"give embedded projects a chance"
							theLoadSpec := loadSpec ].
					projectVisitorQueue
						addLast:
							{theResolvedProject.
							(theLoadSpec componentNames)} ] ].
	projectVisitedQueue
		do: [ :visitedArray | 
			| ndf theVisitor theResolvedProject |
			theVisitor := visitedArray at: 1.
			ndf := visitedArray at: 2.
			theResolvedProject := ndf at: 1.
			theResolvedProject readPackageNames: theResolvedProject packageNames.
			projectSetDefinition addProject: theResolvedProject ].
	^ projectSetDefinition
%

category: 'instance creation'
classmethod: RwResolvedProjectComponentVisitorV2
resolvedProject: resolvedProject platformConditionalAttributes: platformConditionalAttributes
	^ self new
		platformConditionalAttributes: platformConditionalAttributes;
		resolvedProject: resolvedProject;
		yourself
%

!		Instance methods for 'RwResolvedProjectComponentVisitorV2'

category: 'accessing'
method: RwResolvedProjectComponentVisitorV2
componentsPath

	^ self resolvedProject componentsRoot
%

category: 'accessing'
method: RwResolvedProjectComponentVisitorV2
packageNames
	^ self resolvedProject packageNames
%

category: 'accessing'
method: RwResolvedProjectComponentVisitorV2
projectDefinition
	^ self resolvedProject _projectDefinition
%

category: 'accessing'
method: RwResolvedProjectComponentVisitorV2
projectsPath

	^ self resolvedProject projectsRoot
%

category: 'accessing'
method: RwResolvedProjectComponentVisitorV2
resolvedProject
	^ resolvedProject
%

category: 'accessing'
method: RwResolvedProjectComponentVisitorV2
resolvedProject: aResolvedProject
	resolvedProject := aResolvedProject
%

category: 'visiting'
method: RwResolvedProjectComponentVisitorV2
visit: aProjectLoadComponent

	^aProjectLoadComponent acceptVisitor: self
%

category: 'private'
method: RwResolvedProjectComponentVisitorV2
_addPackageNames: somePackageNames for: aComponent

	self projectDefinition addPackages: somePackageNames forComponent: aComponent
%

category: 'private'
method: RwResolvedProjectComponentVisitorV2
_readComponentsForResolvedProject: aResolvedProject withComponentNames: componentNamesToRead  platformConditionalAttributes: aPlatformConditionalAttributes
	| theComponentNames  |
	resolvedProject := aResolvedProject.
	platformConditionalAttributes := aPlatformConditionalAttributes.

	resolvedProject _projectDefinition components: RwResolvedLoadComponentsV2 new.	"build new list of components based on (potentially) new list of configNames"
	resolvedProject _projectDefinition packages: Dictionary new.	"bulid new list of packages as well"
	theComponentNames := componentNamesToRead isEmpty
		ifTrue: [ resolvedProject componentNames ]
		ifFalse: [ componentNamesToRead ].
	^ self _visitComponents: theComponentNames
%

category: 'private'
method: RwResolvedProjectComponentVisitorV2
_visitComponents: componentNamesToRead
	| projectName componentDirectory projectsDirectory |

	projectName := resolvedProject projectName.
	componentDirectory := resolvedProject componentsRoot.
	componentDirectory exists
		ifFalse: [ 
			^ self
				error:
					'No component directory (' , componentDirectory pathString printString
						, ') found for project ' , projectName printString ].
	projectsDirectory := resolvedProject projectsRoot.
	projectsDirectory exists
		ifFalse: [ 
			^ self
				error:
					'No projects directory (' , projectsDirectory pathString printString
						, ') found for project ' , projectName printString ].
	componentNamesToRead
		do: [ :componentName | 
			| component |
			component := self readComponents
				at: componentName
				ifAbsentPut: [ 
					RwAbstractRowanProjectLoadComponentV2
						fromComponentsDirectory: componentDirectory
						named: componentName ].
			component projectName: projectName.

			self visit: component	"expect all component names to represent loadable components - throw error if a nested component is encountered" ]
%

! Class implementation for 'RwAbstractProjectSetModificationVisitor'

!		Class methods for 'RwAbstractProjectSetModificationVisitor'

category: 'instance creation'
classmethod: RwAbstractProjectSetModificationVisitor
visit: aProjectSetModification
	^ self new visit: aProjectSetModification
%

!		Instance methods for 'RwAbstractProjectSetModificationVisitor'

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
addedClass: aClassModification
	currentClassDefinition := aClassModification after
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
addedClassExtension: aClassExtensionModification
	currentClassExtension := aClassExtensionModification after
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
addedMethod: aMethodModification
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
addedMethodExtension: aMethodExtensionModification
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
addedPackage: aPackageModification
	currentPackageDefinition := aPackageModification after
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
addedProject: aProjectModification
	currentProjectDefinition := aProjectModification after
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
changedClass: aClassModification
	currentClassDefinition := aClassModification after
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
changedClassExtension: aClassExtensionModification
	currentClassExtension := aClassExtensionModification after
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
changedMethod: aMethodModification
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
changedMethodExtension: aMethodExtensionModification
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
changedPackage: aPackageModification
	currentPackageDefinition := aPackageModification after
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
changedProject: aProjectModification
	currentProjectDefinition := aProjectModification after
%

category: 'accessing'
method: RwAbstractProjectSetModificationVisitor
currentClassDefinition
	^ currentClassDefinition
%

category: 'accessing'
method: RwAbstractProjectSetModificationVisitor
currentClassExtension
	^ currentClassExtension
%

category: 'accessing'
method: RwAbstractProjectSetModificationVisitor
currentPackageDefinition
	^ currentPackageDefinition
%

category: 'accessing'
method: RwAbstractProjectSetModificationVisitor
currentPackageDefinition: aRwPackageDefinition
	currentPackageDefinition := aRwPackageDefinition
%

category: 'accessing'
method: RwAbstractProjectSetModificationVisitor
currentProjectDefinition
	^ currentProjectDefinition
%

category: 'accessing'
method: RwAbstractProjectSetModificationVisitor
currentProjectDefinition: aRwComponentProjectDefinition
	currentProjectDefinition := aRwComponentProjectDefinition
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
deletedClass: aClassModification
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
deletedClassExtension: aClassExtensionModification
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
deletedMethod: aMethodModification
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
deletedMethodExtension: aMethodExtensionModification
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
deletedPackage: aPackageModification
%

category: 'actions'
method: RwAbstractProjectSetModificationVisitor
deletedProject: aProjectModification
%

category: 'public'
method: RwAbstractProjectSetModificationVisitor
visit: aProjectSetModification
	aProjectSetModification acceptVisitor: self
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitClassesModification: aClassesModification
	aClassesModification elementsModified do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitClassExtensionModification: aClassExtensionModification
	aClassExtensionModification isAddition
		ifTrue: [ 
			self addedClassExtension: aClassExtensionModification.
			aClassExtensionModification instanceMethodsModification acceptVisitor: self.
			aClassExtensionModification classMethodsModification acceptVisitor: self.
			^ self ].
	aClassExtensionModification isDeletion
		ifTrue: [ ^ self deletedClassExtension: aClassExtensionModification ].
	self changedClassExtension: aClassExtensionModification.
	aClassExtensionModification instanceMethodsModification acceptVisitor: self.
	aClassExtensionModification classMethodsModification acceptVisitor: self.
	^ self
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitClassExtensionsModification: aClassExtensionsModification
	aClassExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitClassModification: aClassModification
	aClassModification isAddition
		ifTrue: [ 
			self addedClass: aClassModification.
			aClassModification instanceMethodsModification acceptVisitor: self.
			aClassModification classMethodsModification acceptVisitor: self.
			^ self ].
	aClassModification isDeletion
		ifTrue: [ ^ self deletedClass: aClassModification ].
	self changedClass: aClassModification.
	aClassModification instanceMethodsModification acceptVisitor: self.
	aClassModification classMethodsModification acceptVisitor: self.
	^ self
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitExtensionMethodModification: aMethodExtensionModification
	aMethodExtensionModification isAddition
		ifTrue: [ ^ self addedMethodExtension: aMethodExtensionModification ].
	aMethodExtensionModification isDeletion
		ifTrue: [ ^ self deletedMethodExtension: aMethodExtensionModification ].
	^ self changedMethodExtension: aMethodExtensionModification
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitExtensionMethodsModification: aMethodExtensionsModification
	aMethodExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitMethodModification: aMethodModification
	aMethodModification isAddition
		ifTrue: [ ^ self addedMethod: aMethodModification ].
	aMethodModification isDeletion
		ifTrue: [ ^ self deletedMethod: aMethodModification ].
	^ self changedMethod: aMethodModification
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitMethodsModification: aMethodsModification
	aMethodsModification elementsModified do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitPackageModification: aPackageModification
	aPackageModification isAddition
		ifTrue: [ 
			self addedPackage: aPackageModification.
			aPackageModification classesModification acceptVisitor: self.
			aPackageModification classExtensionsModification acceptVisitor: self.
			^ self ].
	aPackageModification isDeletion
		ifTrue: [ ^ self deletedPackage: aPackageModification ].
	self changedPackage: aPackageModification.
	aPackageModification classesModification acceptVisitor: self.
	aPackageModification classExtensionsModification acceptVisitor: self.
	^ self
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitPackagesModification: aPackagesModification
	aPackagesModification elementsModified do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitProjecteSetModification: aProjectSetModification
	aProjectSetModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwAbstractProjectSetModificationVisitor
visitProjectModification: aProjectModification
	aProjectModification isAddition
		ifTrue: [ 
			self addedProject: aProjectModification.
			^ aProjectModification packagesModification acceptVisitor: self ].
	aProjectModification isDeletion
		ifTrue: [ ^ self deletedProject: aProjectModification ].
	self changedProject: aProjectModification.
	^ aProjectModification packagesModification acceptVisitor: self
%

! Class implementation for 'RwAbstractReaderWriterVisitor'

!		Class methods for 'RwAbstractReaderWriterVisitor'

category: 'accessing'
classmethod: RwAbstractReaderWriterVisitor
tonelClassLabel
	^ 'Class'
%

category: 'accessing'
classmethod: RwAbstractReaderWriterVisitor
tonelExtensionLabel
	^ 'Extension'
%

category: 'private'
classmethod: RwAbstractReaderWriterVisitor
_readObjectFrom: aFileReference

	aFileReference readStreamDo: [:stream |
		| reader |
		reader := STON reader on:  (ZnBufferedReadStream on:  stream).
		reader classes at: #'Package' put: Dictionary.
		^ reader next ]
%

category: 'private'
classmethod: RwAbstractReaderWriterVisitor
_repositoryPropertyDictFor: packagesRoot
	| propertiesFile |
	propertiesFile := packagesRoot / 'properties' , 'st'.
	propertiesFile exists
		ifFalse: [ 
			| propertiesDict |
			propertiesFile := packagesRoot / '.filetree'.
			propertiesFile exists
				ifFalse: [ 
					propertiesFile := packagesRoot / '.properties'.
					propertiesFile exists
						ifFalse: [ ^ Dictionary new ] ].
			propertiesDict := self _readObjectFrom: propertiesFile.
			propertiesDict at: #'format' put: 'filetree'.
			^ propertiesDict ].
	^ self _readObjectFrom: propertiesFile
%

!		Instance methods for 'RwAbstractReaderWriterVisitor'

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentClassDefinition

	^ currentClassDefinition
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentClassExtension

	^ currentClassExtension
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentPackageDefinition

	^ currentPackageDefinition
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentPackageDefinition: aRwPackageDefinition

	currentPackageDefinition := aRwPackageDefinition
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentProjectDefinition

	^ currentProjectDefinition
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentProjectDefinition: aRwComponentProjectDefinition

	currentProjectDefinition := aRwComponentProjectDefinition
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
defaultPackageFormat

	self subclassResponsibility: #defaultPackageFormat
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
packageConvention

	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	^ packageConvention ifNil: [ 
		| ppc dpc  |
		ppc := self currentProjectDefinition packageConvention.
		dpc := self _repositoryConventionFor: self packagesRoot.
		dpc ~= ppc
			ifTrue:  [ self error: 'Disk package convention ' , dpc printString, 
           ' does not match expected package convention ', ppc printString. ' for project ', self projectName printString ].
		packageConvention := ppc ]
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
packagesRoot

	^ self currentProjectDefinition packagesRoot
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
projectName

	^ self currentProjectDefinition projectName
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
validateClassCategory: aClassDefinition  forPackageNamed: packageName

	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	"signal an error if the protocol does not conform to the convention for the current project"

	self packageConvention = 'RowanHybrid'
		ifTrue: [ ^ self _validateRowanHybridClassCategoryConvention: aClassDefinition forPackageNamed: packageName ].
	self packageConvention = 'Monticello'
		ifTrue: [ ^ self _validateRowanMonticelloClassCategoryConvention: aClassDefinition forPackageNamed: packageName ].
	"Rowan - no convention ... any old protocol is fine"
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
validateMethodDefinitionProtocol: methodDef className: className isMeta: isMeta forPackageNamed:  packageName

	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	"signal an error if the protocol does not conform to the convention for the current project"

	self packageConvention = 'RowanHybrid'
		ifTrue: [ ^ self _validateRowanHybridProtocolConvention: methodDef className: className isMeta: isMeta forPackageNamed:  packageName ].
	self packageConvention = 'Monticello'
		ifTrue: [ ^ self _validateRowanMonticelloProtocolConvention:methodDef className: className isMeta: isMeta forPackageNamed:  packageName ].
	"Rowan - no convention ... any old protocol is fine"
%

category: 'private'
method: RwAbstractReaderWriterVisitor
_packageConvention: aString

	packageConvention := aString
%

category: 'private'
method: RwAbstractReaderWriterVisitor
_readObjectFrom: aFileReference

	^ self class _readObjectFrom: aFileReference
%

category: 'private'
method: RwAbstractReaderWriterVisitor
_repositoryConventionFor: packagesRoot

	^ (self _repositoryPropertyDictFor: packagesRoot) at: #convention ifAbsent: [ 'RowanHybrid'  ]
%

category: 'private'
method: RwAbstractReaderWriterVisitor
_repositoryFormatFor: packagesRoot

	^ (self _repositoryPropertyDictFor: packagesRoot) at: #format ifAbsent: [ self defaultPackageFormat ]
%

category: 'private'
method: RwAbstractReaderWriterVisitor
_repositoryPropertyDictFor: packagesRoot

	^ self class _repositoryPropertyDictFor: packagesRoot
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
_validateRowanHybridClassCategoryConvention: aClassDefinition forPackageNamed: packageName

	aClassDefinition category = packageName ifTrue: [ ^ self ].
	RwInvalidClassCategoryConventionErrorNotification 
		signalWithClassDefinition: aClassDefinition 
			packageName: packageName 
			packageConvention: 'RowanHybrid'
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
_validateRowanHybridProtocolConvention:  methodDef className: className isMeta: isMeta forPackageNamed:  packageName

	| canonProtocol expectedProtocol protocol |
	protocol := methodDef protocol.
	(protocol at: 1) = $*
		ifTrue: [
			currentClassDefinition
				ifNotNil: [
					"protocol should not start with $* for a non-extension method"
					RwExtensionProtocolNonExtensionMethodErrorNotification 
						signalWithMethodDefinition: methodDef
							className: className 
							isMeta: isMeta 
							packageName:  packageName
							packageConvention: 'RowanHybrid'.
					^ self ] ]
		ifFalse: [
			currentClassDefinition 
				ifNotNil:  [ 
					"protocol does not start with $* as expected"
					^ self ] ].			
	"validate conformance to convention for extension method"
	(protocol at: 1) = $*
		ifFalse: [
			"extension method protocol must start with a *"
			RwNonExtensionProtocolExtensionMethodErrorNotification
				signalWithMethodDefinition: methodDef
					className: className 
					isMeta: isMeta 
					packageName:  packageName
					packageConvention: 'RowanHybrid'.
			^ self  ].
	canonProtocol := protocol asLowercase.
	expectedProtocol := '*', packageName asLowercase.
	canonProtocol = expectedProtocol ifTrue: [ ^ self ].
	"protocol does not match package name"
	RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification
		signalWithMethodDefinition: methodDef
			className: className 
			isMeta: isMeta 
			packageName:  packageName
			packageConvention: 'RowanHybrid'
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
_validateRowanMonticelloClassCategoryConvention: aClassDefinition forPackageNamed: packageName
	(aClassDefinition category beginsWith: packageName)
		ifTrue: [ ^ self ].
	RwInvalidClassCategoryConventionErrorNotification
		signalWithClassDefinition: aClassDefinition
		packageName: packageName
		packageConvention: 'Monticello'
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
_validateRowanMonticelloProtocolConvention: methodDef className: className isMeta: isMeta forPackageNamed: packageName
	| canonProtocol expectedProtocol protocol |
	protocol := methodDef protocol.
	(protocol at: 1) = $*
		ifTrue: [ 
			currentClassDefinition
				ifNotNil: [ 
					"protocol should not start with $* for a non-extension method"
					RwExtensionProtocolNonExtensionMethodErrorNotification
						signalWithMethodDefinition: methodDef
						className: className
						isMeta: isMeta
						packageName: packageName
						packageConvention: 'Monticello'.
					^ self ] ]
		ifFalse: [ 
			currentClassDefinition
				ifNotNil: [ 
					"protocol does not start with $* as expected"
					^ self ] ].	"validate conformance to convention for extension method"
	(protocol at: 1) = $*
		ifFalse: [ 
			"extension method protocol must start with a *"
			RwNonExtensionProtocolExtensionMethodErrorNotification
				signalWithMethodDefinition: methodDef
				className: className
				isMeta: isMeta
				packageName: packageName
				packageConvention: 'Monticello'.
			^ self ].
	canonProtocol := protocol asLowercase.
	expectedProtocol := '*' , packageName asLowercase.
	(canonProtocol beginsWith: expectedProtocol)
		ifTrue: [ ^ self ].	"protocol does not match package name"
	RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification
		signalWithMethodDefinition: methodDef
		className: className
		isMeta: isMeta
		packageName: packageName
		packageConvention: 'Monticello'
%

! Class implementation for 'RwModificationWriterVisitor'

!		Class methods for 'RwModificationWriterVisitor'

category: 'accessing'
classmethod: RwModificationWriterVisitor
lineEnding
  "Answer the os-specific line endings"

  ^ String with: Character lf
%

!		Instance methods for 'RwModificationWriterVisitor'

category: 'actions'
method: RwModificationWriterVisitor
addedClass: aClassModification

	currentClassDefinition := aClassModification after.

	self processClass: aClassModification
%

category: 'actions'
method: RwModificationWriterVisitor
addedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification after.

	self processClassExtension: aClassExtensionModification
%

category: 'actions'
method: RwModificationWriterVisitor
addedPackage: aPackageModification

	currentPackageDefinition := aPackageModification after.
	self processPackage: aPackageModification
%

category: 'actions'
method: RwModificationWriterVisitor
addedProject: aProjectModification
	currentProjectDefinition := aProjectModification after.
	self processProject: aProjectModification
%

category: 'actions'
method: RwModificationWriterVisitor
changedClass: aClassModification

	currentClassDefinition := aClassModification after.

	self processClass: aClassModification
%

category: 'actions'
method: RwModificationWriterVisitor
changedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification after.

	self processClassExtension: aClassExtensionModification
%

category: 'actions'
method: RwModificationWriterVisitor
changedPackage: aPackageModification

	currentPackageDefinition := aPackageModification after.
	self processPackage: aPackageModification
%

category: 'actions'
method: RwModificationWriterVisitor
changedProject: aProjectModification

	currentProjectDefinition := aProjectModification after.
	self processProject: aProjectModification
%

category: 'actions'
method: RwModificationWriterVisitor
deletedClass: aClassModification

	self subclassResponsibility: #deletedClass:
%

category: 'actions'
method: RwModificationWriterVisitor
deletedClassExtension: aClassExtensionModification

	self subclassResponsibility: #deletedClassExtension:
%

category: 'actions'
method: RwModificationWriterVisitor
deletedPackage: aPackageModification

	self subclassResponsibility: #deletedPackage:
%

category: 'actions'
method: RwModificationWriterVisitor
deletedProject: aProjectModification

	"A deleted project means that the project was not inlcuded in the base project set definition ... we do not want to change anything on disk.
		So ignore the rest of the project"
%

category: 'exporting'
method: RwModificationWriterVisitor
export

	"noop ... directory-based formats written out as each element is visited"
%

category: 'class writing'
method: RwModificationWriterVisitor
processClass: aClassModification

	self subclassResponsibility: #processClass:
%

category: 'class writing'
method: RwModificationWriterVisitor
processClassExtension: aClassExtensionModification

	self subclassResponsibility: #processClassExtension:
%

category: 'package writing'
method: RwModificationWriterVisitor
processPackage: aPackageModification

	aPackageModification classesModification acceptVisitor: self.
	aPackageModification classExtensionsModification acceptVisitor: self
%

category: 'project writing'
method: RwModificationWriterVisitor
processProject: aProjectModification
 
	aProjectModification packagesModification acceptVisitor: self
%

category: 'public'
method: RwModificationWriterVisitor
visit: aPackageSetModification

	aPackageSetModification acceptVisitor: self.
	self export.
%

category: 'visiting'
method: RwModificationWriterVisitor
visitClassesModification: aClassesModification

	aClassesModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visiting'
method: RwModificationWriterVisitor
visitClassExtensionModification: aClassExtensionModification

	aClassExtensionModification isAddition
		ifTrue: [ ^ self addedClassExtension: aClassExtensionModification ] .
	aClassExtensionModification isDeletion
		ifTrue: [ ^ self deletedClassExtension: aClassExtensionModification ].
	^ self changedClassExtension: aClassExtensionModification
%

category: 'visiting'
method: RwModificationWriterVisitor
visitClassExtensionsModification: aClassExtensionsModification

	aClassExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwModificationWriterVisitor
visitClassModification: aClassModification

	aClassModification isAddition
		ifTrue: [ ^ self addedClass: aClassModification ] .
	aClassModification isDeletion
		ifTrue: [ ^ self deletedClass: aClassModification ].
(aClassModification instanceMethodsModification isEmpty and: [ aClassModification classMethodsModification isEmpty ])
	ifTrue: [
		"no instance or class modifications, check to see if the only Property modification is for 'gs_SymbolDictionary' "
		| propertiesModification elementsModified |
		propertiesModification := aClassModification propertiesModification.
		elementsModified := propertiesModification elementsModified.
		(elementsModified size = 1 and: [ (elementsModified at: 'gs_SymbolDictionary' ifAbsent: []) notNil])
			ifTrue: [
				"'gs_symbolDictionary' property is not written to disk, so we can skip this class"
				^ self ]].
	^ self changedClass: aClassModification
%

category: 'visiting'
method: RwModificationWriterVisitor
visitPackageModification: aPackageModification

	aPackageModification isAddition
		ifTrue: [ ^ self addedPackage: aPackageModification ] .
	aPackageModification isDeletion
		ifTrue: [ ^ self deletedPackage: aPackageModification ].
	^ self changedPackage: aPackageModification
%

category: 'visiting'
method: RwModificationWriterVisitor
visitPackagesModification: aPackagesModification

	aPackagesModification elementsModified do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwModificationWriterVisitor
visitProjecteSetModification: aProjectSetModification

	aProjectSetModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwModificationWriterVisitor
visitProjectModification: aProjectModification

	aProjectModification isAddition
		ifTrue: [ ^ self addedProject: aProjectModification ].
	aProjectModification isDeletion
		ifTrue: [ ^ self deletedProject: aProjectModification ].
	^ self changedProject: aProjectModification
%

category: 'private'
method: RwModificationWriterVisitor
_createFileNameMapForClassesOrPackages: aClassOrPackageDefinitionDictionary
 
  "answer a dictionary that maps each definition name to a filename that is guaranteed unique on case insensitive file systems"

  | map filenameMap |
  map := Dictionary new.
  aClassOrPackageDefinitionDictionary
    do: [ :cDef | 
      | nam col |
      "sort into bins by lowercase selector. "
      nam := cDef name asLowercase.
      col := map
        at: nam
        ifAbsentPut: [ OrderedCollection new ].
      col add: cDef ].
  filenameMap := Dictionary new.
  map values
	do: [ :col | 
	  | sortedCol |
	  col size = 1
		ifTrue: [ 
		  | def |
		  "no need to distinguish filename"
		  def := col at: 1.
		  filenameMap
			at: def name
			put: def name ]
		ifFalse: [ 
		  "tack on postfix to guarantee  file names are unique on case insensitive file systems"
		  sortedCol := col sorted: [ :a :b | a asString _unicodeLessThan: b asString ].
		  (1 to: sortedCol size) do: [ :index | 
			| def filename |
			def := sortedCol at: index.
			filename := def name.
			filename := filename , '..' , index printString.
			filenameMap at: def name put: filename ] ] ].
  ^ filenameMap
%

category: 'private'
method: RwModificationWriterVisitor
_newLine
	 ^ self class lineEnding
%

! Class implementation for 'RwGsModificationTopazWriterVisitorV2'

!		Instance methods for 'RwGsModificationTopazWriterVisitorV2'

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
bufferedStream

	^ bufferedStream ifNil: [ 
		| encodedStream |
		encodedStream := (self repositoryRootPath / self topazFilename, self filenameExtension) writeStreamEncoded: 'utf8'.
		bufferedStream := ZnBufferedWriteStream on: encodedStream ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
buildPackageNamesMap

	"If true, topazFilenamePackageNamesMap will be built from topazFilenameConfigsMap.
		If false, existing topazFilenamePackageNamesMap will be used"

	^ buildPackageNamesMap ifNil: [ buildPackageNamesMap := true ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
classDefinitions

	^ classDefinitions ifNil: [ classDefinitions := Dictionary new ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
classDefPackageNameMap

	^ classDefPackageNameMap ifNil: [ classDefPackageNameMap := Dictionary new ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
classExtensions

	^ classExtensions ifNil: [ classExtensions := Dictionary new ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
classExtPackageNameMap

	^ classExtPackageNameMap ifNil: [ classExtPackageNameMap := IdentityKeyValueDictionary new ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
classInitializationDefinitions

	^ classInitializationDefinitions
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
classSymbolDictionaryNames

	^ classSymbolDictionaryNames ifNil: [ classSymbolDictionaryNames := Dictionary new ]
%

category: 'actions'
method: RwGsModificationTopazWriterVisitorV2
deletededClass: aClassModification

	"a deleted class is ignored for topaz ... the deleted class is simply not written"
%

category: 'actions'
method: RwGsModificationTopazWriterVisitorV2
deletededClassExtension: aClassExtensionModification

	"a deleted class extension is ignored for topaz ... the deleted methods are simply not written"
%

category: 'actions'
method: RwGsModificationTopazWriterVisitorV2
deletededPackage: aPackageModification

	"a deleted package is ignored for topaz ... the deleted classes and methods are simply not written out"
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
excludeClassInitializers
	^ excludeClassInitializers ifNil: [ false ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
excludeClassInitializers: aBool
	excludeClassInitializers := aBool
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
excludeRemoveAllMethods
	^ excludeRemoveAllMethods ifNil: [ false ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
excludeRemoveAllMethods: aBool
	excludeRemoveAllMethods := aBool
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitorV2
export

	self fileNamesInFileInOrder do: [:filename | 
		| packageNames classDefinitionsInOrder classExtensionsInOrder classExtensionsList classDefinitionsList |
		packageNames := self topazFilenamePackageNamesMap at: filename.
		self _setBufferedStreamFor: filename.
		self bufferedStream nextPutAll: self topazFileHeader.

		classInitializationDefinitions := Set new. "per file record"
		classDefinitionsList := Set new.

		self classDefPackageNameMap keysAndValuesDo: [:className :packageName |
			(packageNames includes: packageName)
				ifTrue: [ classDefinitionsList add: (self classDefinitions at: className) ] ].

		classDefinitionsInOrder := (RowanGsGeneralDependencySorter
			on: classDefinitionsList
			dependsOn: [:candidate | candidate superclassName]
			dependent: [:candidate | candidate name]) inOrder.
		self exportClassDefinitions: classDefinitionsInOrder;
			exportMethodDefinitions: classDefinitionsInOrder.

		"consolidate the classExtensions for a class from multiple packages into a single definition"
		classExtensionsList := Set new. 
		self classExtensions keysAndValuesDo: [:classExtName :extSet |
			| extsInConfig |
			extsInConfig := Set new.
			extSet do: [:ext |
				| packageName |
				packageName := self classExtPackageNameMap at: ext.
				(packageNames includes: packageName)
					ifTrue: [ extsInConfig add: ext ] ].

			extsInConfig size <= 1 
				ifTrue: [ classExtensionsList addAll: extsInConfig ]
				ifFalse: [
					| ar def |
					ar := extsInConfig asArray.
					def := (ar at: 1) copy.
					2 to: ar size do: [:index |
						| d |
						d := (ar at: index).
						d classMethodDefinitions values do: [:m | def addClassMethodDefinition: m ].
						d instanceMethodDefinitions values do: [:m | def addInstanceMethodDefinition: m ] ].
					classExtensionsList add: def ] ].

		classExtensionsInOrder := classExtensionsList sort: [:a :b | a name <= b name ].
		self
			exportExtensionMethodDefinitions: classExtensionsInOrder.

		self exportClassInitializations.

		self bufferedStream nextPutAll: self topazFileFooter.

		self bufferedStream flush; close ].
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitorV2
exportClassDefinitions: classDefinitionsInOrder

	| stream |
	stream := self bufferedStream.
	classDefinitionsInOrder isEmpty not
		ifTrue: [ 
			stream
				nextPutAll: '! Class Declarations'; lf;
				nextPutAll: '! Generated file, do not Edit'; lf;
				lf ].
	classDefinitionsInOrder do: [:classDef | 
		self _fileOutClassDeclaration: classDef on: stream ].
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitorV2
exportClassInitializations
	| stream exclude |
	self classInitializationDefinitions isEmpty ifTrue: [ ^ self ].
	stream := self bufferedStream.
  exclude := self excludeClassInitializers.
  exclude ifTrue:[
    stream nextPutAll: '! Class Initialization Excluded by export visitor'; lf .
  ] ifFalse:[
	  stream 
		  nextPutAll: '! Class Initialization'; lf;
      lf;
		  nextPutAll: 'run'; lf.
  ].
	(self classInitializationDefinitions sort: [:a :b | a name <= b name ]) do: [ :classDef |
    exclude ifTrue:[ stream nextPutAll:'!  ' ].
		stream nextPutAll: classDef name, ' initialize.'; lf 
  ].
  exclude ifFalse:[
	  stream nextPutAll: 'true'; lf;
	  nextPutAll: '%'; lf .
  ].
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitorV2
exportExtensionMethodDefinitions: classDefinitionsInOrder

	self exportMethodDefinitions: classDefinitionsInOrder labeled: 'Class extensions'
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitorV2
exportMethodDefinitions: classDefinitionsInOrder

	self exportMethodDefinitions: classDefinitionsInOrder labeled: 'Class implementation'
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitorV2
exportMethodDefinitions: classDefinitionsInOrder labeled: label
	| stream |
	stream := self bufferedStream.
	classDefinitionsInOrder do: [:classDef | 
		| className |
		className := classDef name.
		(classDef classMethodDefinitions isEmpty not or: [ classDef instanceMethodDefinitions isEmpty not])
			ifTrue: [ 
				stream nextPutAll: '! ', label, ' for ', className printString; lf;
				lf ].
		classDef classMethodDefinitions isEmpty not
			ifTrue: [ 
				stream nextPutAll: '!		Class methods for ', className printString; lf;
				lf ].
		(classDef classMethodDefinitions values sort: [:a :b | a selector <= b selector ])
			do: [:methodDef |
				methodDef selector == #initialize
					ifTrue: [ self classInitializationDefinitions add: classDef ].
				self _fileOutMethod: methodDef forClass: className isMeta: true on: stream ].
		classDef instanceMethodDefinitions isEmpty not
			ifTrue: [ 
				stream nextPutAll: '!		Instance methods for ', className printString; lf;
				lf ].
		(classDef instanceMethodDefinitions values sort: [:a :b | a selector <= b selector ])
			do: [:methodDef |
				self _fileOutMethod: methodDef forClass: className isMeta: false on: stream ] ].
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
filenameExtension

	^ filenameExtension ifNil: ['gs' ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
filenameExtension: aString

	filenameExtension := aString
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
fileNamesInFileInOrder
	"Normally the order that fileins are created in does not matter"

	^ fileNamesInFileInOrder ifNil: [ self topazFilenamePackageNamesMap keys ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
fileNamesInFileInOrder: object
	fileNamesInFileInOrder := object
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
logCreation
	^logCreation ifNil: [ ^false ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
logCreation: object
	logCreation := object
%

category: 'class writing'
method: RwGsModificationTopazWriterVisitorV2
processClass: aClassModification

	| classDefinition symbolDictName clsName |
	classDefinition := aClassModification after.
	(self classDefinitions at: (clsName := classDefinition name) ifAbsent: []) ifNotNil: [ 
   self error: 'duplicate class definition for ', clsName printString, ' encountered.'].

	symbolDictName := self currentProjectDefinition symbolDictNameForPackageNamed: self currentPackageDefinition name.
	self classSymbolDictionaryNames at: classDefinition name put: symbolDictName.
	self classDefinitions at: classDefinition name put: classDefinition.

	self classDefPackageNameMap at: classDefinition name put: currentPackageDefinition name.

	"no need to visit any further as the class definition records the instance and class methods"
%

category: 'class writing'
method: RwGsModificationTopazWriterVisitorV2
processClassExtension: aClassExtensionModification

	| classExtension |
	classExtension := aClassExtensionModification after.
	(self classExtensions at: classExtension name ifAbsentPut: [ Set new ])
		add: classExtension.

	self classExtPackageNameMap at: classExtension put: currentPackageDefinition name.

	"no need to visit any further as the class etension records the instance and class methods"
%

category: 'project writing'
method: RwGsModificationTopazWriterVisitorV2
processProject: aProjectModification
	self buildPackageNamesMap
		ifTrue: [ 
			| readTool |
			topazFilenamePackageNamesMap := self topazFilenamePackageNamesMap.
			readTool := Rowan projectTools readV2.
			self topazFilenameComponentMap
				keysAndValuesDo: [ :filename :componentAndPlatformConditionalAttributesMap | 
					| componentNames platformConditionalAttributes visitor packageNames componentAndPlatformConditionalAttributes |
					componentAndPlatformConditionalAttributes := componentAndPlatformConditionalAttributesMap
						at: currentProjectDefinition name
						ifAbsent: [ 
							{{}.
							{}} ].
					componentAndPlatformConditionalAttributes
						ifNotNil: [ 
							componentNames := componentAndPlatformConditionalAttributes at: 1.
							platformConditionalAttributes := componentAndPlatformConditionalAttributes
								at: 2.
							componentNames isEmpty
								ifFalse: [ 
									currentProjectDefinition componentsRoot exists
										ifTrue: [ 
											"read the project from disk, if it is present on disk"
											visitor := readTool
												readProjectForResolvedProject: currentProjectDefinition
												withComponentNames: componentNames
												platformConditionalAttributes: platformConditionalAttributes ] ].
							packageNames := visitor
								ifNil: [ 
									self topazFilenameComponentMap size > 1
										ifTrue: [ 
											self
												error:
													'unable to read project components for project '
														, currentProjectDefinition name printString
														, '. Multiple output files likely to have the same contents.' ].
									currentProjectDefinition packageNames ]
								ifNotNil: [ visitor packageNames ].
							(topazFilenamePackageNamesMap at: filename ifAbsentPut: [ Set new ])
								addAll: packageNames ] ] ].
	aProjectModification packagesModification acceptVisitor: self
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
repositoryRootPath

	^ repositoryRootPath
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
repositoryRootPath: aStringOrFileReference 

	repositoryRootPath := aStringOrFileReference asFileReference.
	repositoryRootPath exists ifFalse: [ self error: 'The repository root path must exist: ', repositoryRootPath pathString printString ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFileFooter
	^ topazFileFooter ifNil: [ '' ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFileFooter: object
	topazFileFooter := object
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFileHeader

	^ topazFileHeader ifNil: [ '' ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFileHeader: aString

	topazFileHeader := aString
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFilename

	^ topazFilename
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFilename: aString

	topazFilename := aString
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFilenameComponentMap

	^ topazFilenameComponentMap
		ifNil: [ topazFilenameComponentMap := Dictionary new at: self topazFilename put: Dictionary new; yourself ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFilenameComponentMap: aDictionary

	"keys are topaz file names, values are a dictionary:
		whose keys are project names and values are two slot array with component name list and customConditionalAttributes. 
			The component names and customConditionalAttributes are resolved to a list of packages that will be written to the named file.

			If the component/customConditionalAttributes list is empty, the default component and customConditionalAttributes for the project will be used.
			If either (or both) of the slots contain empty array, then the corresponding project default will be used."

	"If topazFilenamePackageNamesMap is explicitly set, then the contents of topazFilenameComponentMap will be ignored."

	buildPackageNamesMap := true.
	topazFilenameComponentMap := aDictionary
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFilenamePackageNamesMap

	^ topazFilenamePackageNamesMap ifNil: [ topazFilenamePackageNamesMap := Dictionary new ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFilenamePackageNamesMap: aDictionary

	"keys are topaz file names, values are a collection of package names"

	"if topazFilenameConfigsMap is being used, then the topazFilenamePackageNamesMap is generated automatically,
		based on the project configurations."

	"If you explicitly set topazFilenamePackageNamesMap then contents of topazFilenameConfigsMap will be ignored."

	buildPackageNamesMap := false.
	topazFilenamePackageNamesMap := aDictionary
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitorV2
topazFileReference

	^ self repositoryRootPath / self topazFilename, self filenameExtension
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitorV2
_fileOutClassDeclaration: classDefinition on: aStream
	| optionsString reservedOopString hasClassInstVars |
	aStream
		nextPutAll: 'doit';
		lf;
		nextPutAll: '(' , classDefinition superclassName;
		lf.
	hasClassInstVars := self
		_writeClassTypeMessage: classDefinition
		on: aStream
		hasInstanceVariables: [ 
			aStream
				nextPutAll:
						'	instVarNames: #( ' , (self _stringForVariables: classDefinition instVarNames)
								, ' )';
				lf ].
	optionsString := String new.
	classDefinition gs_options isEmpty
		ifFalse: [ 
			optionsString := ' ' , (self _symbolsForVariables: classDefinition gs_options)
				, ' ' ].
	self logCreation
		ifTrue: [ 
			"for verbose logging during filein and upgrade"
			optionsString addAll: ' #logCreation ' ].
	reservedOopString := ''.
	classDefinition gs_reservedOop isEmpty
		ifFalse: [ 
			| strm |
			strm := WriteStream on: String new.
			strm
				nextPutAll: '	reservedOop: ' , classDefinition gs_reservedOop;
				lf.
			reservedOopString := strm contents ].
	aStream
		nextPutAll:
				'	classVars: #( ' , (self _stringForVariables: classDefinition classVarNames)
						, ' )';
		lf.
	hasClassInstVars
		ifTrue: [ 
			aStream
				nextPutAll:
						'	classInstVars: #( '
								, (self _stringForVariables: classDefinition classInstVarNames) , ' )';
				lf ].
	aStream
		nextPutAll: '	poolDictionaries: #()';
		lf;
		nextPutAll:
				'	inDictionary: ' , (self classSymbolDictionaryNames at: classDefinition name);
		lf;
		nextPutAll: '	options: #(' , optionsString , ')';
		lf;
		nextPutAll: reservedOopString;
		nextPutAll: ')';
		lf;
		nextPutAll: '		category: ' , classDefinition category printString , ';';
		lf;
		yourself.
	classDefinition comment isEmpty
		ifFalse: [ 
			aStream
				nextPutAll: '		comment: ' , classDefinition comment printString , ';';
				lf;
				yourself ].
	aStream
		nextPutAll: '		immediateInvariant.';
		lf;
		nextPutAll: 'true.';
		lf;
		nextPutAll: '%';
		lf;
		lf.
	self _fileoutRemoveAllMethodsFor: classDefinition name on: aStream
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitorV2
_fileOutMethod: methodDefinition forClass: className isMeta: isMeta on: aStream

	aStream
		nextPutAll: 'category: ', methodDefinition protocol printString; lf;
		nextPutAll: (isMeta ifTrue: ['classmethod: '] ifFalse: ['method: ']), className; lf;
		nextPutAll: methodDefinition source.
	methodDefinition source last = Character lf
		ifFalse: [aStream lf].
	aStream nextPutAll: '%'; lf;
		lf
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitorV2
_fileoutRemoveAllMethodsFor: className on: aStream
	self excludeRemoveAllMethods
		ifFalse: [ 
			aStream
				nextPutAll: 'removeallmethods ' , className;
				lf;
				nextPutAll: 'removeallclassmethods ' , className;
				lf;
				lf ]
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitorV2
_setBufferedStreamFor: filename

	^ self _setBufferedStreamFor: filename extension: self filenameExtension
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitorV2
_setBufferedStreamFor: filename extension: extension

	| encodedStream |
	encodedStream := (self repositoryRootPath / filename, extension) writeStreamEncoded: 'utf8'.
	bufferedStream := ZnBufferedWriteStream on: encodedStream
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitorV2
_stringForVariables: variableList

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	variableList do: [:each | stream nextPutAll: each]
		separatedBy: [stream space].
	^stream contents
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitorV2
_symbolsForVariables: variableList

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	variableList do: [:each | stream nextPutAll: each asSymbol printString ]
		separatedBy: [stream space].
	^stream contents
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitorV2
_writeClassTypeMessage: classDefinition on: aStream hasInstanceVariables: instanceVariableBlock
	| classType classTypeMessage hasInstanceVariables hasReservedOop hasClassInstVars |
	hasInstanceVariables := true.
	hasReservedOop := classDefinition gs_reservedOop isEmpty not.
	hasClassInstVars := true.
	classType := classDefinition subclassType.
	classType = 'variable'
		ifTrue: [ 
			classTypeMessage := hasReservedOop
				ifTrue: [ '_newKernelIndexableSubclass:' ]
				ifFalse: [ 'indexableSubclass: ' ] ]
		ifFalse: [ 
			classType = 'byteSubclass'
				ifTrue: [ 
					classTypeMessage := hasReservedOop
						ifTrue: [ '_newKernelByteSubclass:' ]
						ifFalse: [ 'byteSubclass: ' ].
					hasClassInstVars := hasInstanceVariables := false ]
				ifFalse: [ 
					(classType = '' or: [ classType = 'immediate' ])
						ifTrue: [ 
							classTypeMessage := hasReservedOop
								ifTrue: [ '_newKernelSubclass:' ]
								ifFalse: [ 'subclass: ' ] ]
						ifFalse: [ self error: 'unknown subclass type: ' , classType ] ] ].
	aStream
		tab;
		nextPutAll: classTypeMessage , classDefinition name asString printString;
		lf.
	hasInstanceVariables
		ifTrue: [ instanceVariableBlock value ].
	^ hasClassInstVars
%

! Class implementation for 'RwModificationCypressFamilyWriterVisitor'

!		Class methods for 'RwModificationCypressFamilyWriterVisitor'

category: 'accessing'
classmethod: RwModificationCypressFamilyWriterVisitor
orderedDictionaryClass
  "Answer the platform-specific OrderedDictionary-compatible class"

  ^ GsTonelOrderedDictionary
%

!		Instance methods for 'RwModificationCypressFamilyWriterVisitor'

category: 'actions'
method: RwModificationCypressFamilyWriterVisitor
deletedPackage: aPackageModification

	currentPackageDefinition := aPackageModification before.

	self _packageSourceDir ensureDeleteAll.	"delete the whole package directory"
%

category: 'package writing'
method: RwModificationCypressFamilyWriterVisitor
packageExtension

	^ ''
%

category: 'package writing'
method: RwModificationCypressFamilyWriterVisitor
processPackage: aPackageModification

	classDefFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification after classDefinitions.
	classExtFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification after classExtensions.
	classDefBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification before classDefinitions.
	classExtBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification before classExtensions.

	super processPackage: aPackageModification
%

category: 'class writing'
method: RwModificationCypressFamilyWriterVisitor
_commentOf: aClassDefinition
	^ (aClassDefinition comment 
		copyReplaceAll: '"' 
		with: '""')
		withLineEndings: self _newLine
%

category: 'package writing'
method: RwModificationCypressFamilyWriterVisitor
_packageSourceDir

	| filename |
	filename := packageDefFileNameMap 
		at:  self currentPackageDefinition name 
		ifAbsent: [
			"in the case of package removal, need to use the before package map"
			packageDefBeforeFileNameMap at: self currentPackageDefinition name ].
	^ self packageExtension isEmpty
		ifTrue: [ self _projectSourceDir /filename ]
		ifFalse: [ self _projectSourceDir /filename, self packageExtension ]
%

category: 'project writing'
method: RwModificationCypressFamilyWriterVisitor
_projectSourceDir

	^ self currentProjectDefinition packagesRoot
%

category: 'private'
method: RwModificationCypressFamilyWriterVisitor
_toJSON: anObject
	^ (STON toJsonStringPretty: anObject)
		withLineEndings: self _newLine
%

category: 'private'
method: RwModificationCypressFamilyWriterVisitor
_toSTON: anObject
	^ (String streamContents: [ :stream | 
		(TonelSTONWriter on: stream) nextPut: anObject ])
		withLineEndings: self _newLine
%

! Class implementation for 'RwModificationFiletreeWriterVisitor'

!		Class methods for 'RwModificationFiletreeWriterVisitor'

category: 'initialization'
classmethod: RwModificationFiletreeWriterVisitor
initialize
	"self initialize"
    specials := self initializeSpecials
%

category: 'initialization'
classmethod: RwModificationFiletreeWriterVisitor
initializeSpecials

    | map |
    map := Dictionary new.
    map
		at: $! put: 'bang';
        at: $+ put: 'plus';
        at: $- put: 'minus';
        at: $= put: 'equals';
        at: $< put: 'less';
        at: $> put: 'more';
        at: $% put: 'percent';
        at: $& put: 'and';
        at: $| put: 'pipe';
        at: $* put: 'star';
        at: $/ put: 'slash';
        at: $\ put: 'backslash';
        at: $~ put: 'tilde';
        at: $? put: 'wat';
        at: $, put: 'comma';
        at: $@ put: 'at'.
    map keys do: [ :key | map at: (map at: key) put: key ].
    ^ map
%

category: 'accessing'
classmethod: RwModificationFiletreeWriterVisitor
selectorSpecials

	^ specials ifNil: [ specials := self initializeSpecials ]
%

!		Instance methods for 'RwModificationFiletreeWriterVisitor'

category: 'actions'
method: RwModificationFiletreeWriterVisitor
addedMethod: aMethodModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodModification after.

	"create instance/class directory as needed ... write method source file"
	 (aMethodModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st')
		writeStreamDo: [:aStream |
		aStream 
			<< methodDefinition protocol
			<< self _newLine
			<< (methodDefinition source withLineEndings: self _newLine) ]
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
addedMethodExtension: aMethodExtensionModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodExtensionModification after.

	"create instance/class directory as needed ... write method source file"
	 (aMethodExtensionModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassExtensionDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceExtensionDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st')
		writeStreamDo: [:aStream |
		aStream 
			<< methodDefinition protocol
			<< self _newLine
			<< (methodDefinition source withLineEndings: self _newLine) ]
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
addedPackage: aPackageModification

	| packageProperties |
	currentPackageDefinition := aPackageModification after.

	"create package directory and properties.json file"
	self _packageSourceDir ensureCreateDirectory.
	(self _packageSourceDir /  'properties.json')
		writeStreamDo: [:aStream |
		aStream 
			<< '{'
			<< self  _newLine
			<< '	 }'].

	packageProperties := self _filetreePackagePropertyDictFor: aPackageModification.
	(packageProperties at:  'noMethodMetaData' ifAbsent: []) = self noMethodMetaData
		ifFalse: [
			"Rowan can read filetree repositories with methodMetaData, but does write method metadata"
			self error: 'method metadata not supported.' ].
	(packageProperties at:  'separateMethodMetaAndSource' ifAbsent: []) = self separateMethodMetaAndSource
		ifFalse: [
			"Rowan can read filetree repositories with separateMethodMetaAndSource, but does write separateMethodMetaAndSource"
			self error: 'separateMethodMetaAndSource not supported.' ].
	(packageProperties at:  'useCypressPropertiesFile' ifAbsent: []) = self useCypressPropertiesFile
		ifFalse: [
			"Rowan can read filetree repositories without CypressPropertiesFile, but does write without useCypressPropertiesFile"
			self error: 'only useCypressPropertiesFile not supported.' ].

	self processPackage: aPackageModification
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
changedMethod: aMethodModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodModification after.

	"create instance/class directory as needed ... write method source file"
	 (aMethodModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st')
		writeStreamDo: [:aStream |
		aStream 
			<< methodDefinition protocol
			<< self _newLine
			<< (methodDefinition source withLineEndings: self _newLine) ]
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
changedMethodExtension: aMethodExtensionModification

	self error: 'not yet implemented'
%

category: 'accessing'
method: RwModificationFiletreeWriterVisitor
defaultPackageFormat

	^ 'filetree'
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
deletedClass: aClassModification

	currentClassDefinition := aClassModification before.

	self _classSourceDir ensureDeleteAll
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
deletedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification before.

	self _classExtensionSourceDir ensureDeleteAll
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
deletedMethod: aMethodModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodModification before.

	"delete method source file"
	 (aMethodModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector
				ifAbsent: [ classBeforeFileNameMap at: methodDefinition selector ].
			methodDir := self _methodClassDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector
				ifAbsent: [ instanceBeforeFileNameMap at: methodDefinition selector ].
			methodDir := self _methodInstanceDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st') ensureDelete
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
deletedMethodExtension: aMethodExtensionModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodExtensionModification before.

	"create instance/class directory as needed ... write method source file"
	 (aMethodExtensionModification isMeta
		ifTrue: [
			methodFileName := classBeforeFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassExtensionDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceBeforeFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceExtensionDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st') ensureDelete
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
monticelloMetadata
	"monticello metadata  --- for writing metadataless is the only supported format"

	^ monticelloMetadata ifNil: [ monticelloMetadata := 'false' ]
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
noMethodMetaData

	^ noMethodMetaData ifNil: [ noMethodMetaData := true ]
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
packageExtension

	^ packageExtension ifNil: [ packageExtension := 'package' ]
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
processClass: aClassModification

	"create class directory and class defintion structure"

	self _classSourceDir ensureCreateDirectory.

	(self _classSourceDir /  'README.md')
		writeStreamDo: [:aStream |
		aStream 
			<< (self _commentOf: self currentClassDefinition) ].

	(self _classSourceDir /  'properties.json')
		writeStreamDo: [:aStream |
			aStream 
				<< (self _typeClassDefinitionOf: self currentClassDefinition)
				<< self _newLine ].

	instanceFileNameMap  := self _createFileNameMapForMethods: aClassModification after instanceMethodDefinitions.
	classFileNameMap := self _createFileNameMapForMethods: aClassModification after classMethodDefinitions.
	instanceBeforeFileNameMap  := self _createFileNameMapForMethods: aClassModification before instanceMethodDefinitions.
	classBeforeFileNameMap := self _createFileNameMapForMethods: aClassModification before classMethodDefinitions.

	currentClassDefinition instanceMethodDefinitions isEmpty
		ifTrue: [  self _methodInstanceDir ensureDeleteAll ]
		ifFalse: [ aClassModification instanceMethodsModification acceptVisitor: self ].
	currentClassDefinition classMethodDefinitions isEmpty
		ifTrue: [  self _methodClassDir ensureDeleteAll ]
		ifFalse: [ aClassModification classMethodsModification acceptVisitor: self ]
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
processClassExtension: aClassExtensionModification

	"create class extension directory and defintion structure"

	(currentClassExtension instanceMethodDefinitions isEmpty and: [ currentClassExtension classMethodDefinitions isEmpty ])
		ifTrue: [ self _classExtensionSourceDir ensureDeleteAll ]
		ifFalse: [ 
			self _classExtensionSourceDir ensureCreateDirectory.
			(self _classExtensionSourceDir /  'properties.json')
				writeStreamDo: [:aStream |
					aStream 
						<< (self _classExtensionOf: self currentClassExtension)
						<< self _newLine ].

			instanceFileNameMap  := self _createFileNameMapForMethods: aClassExtensionModification after instanceMethodDefinitions.
			classFileNameMap := self _createFileNameMapForMethods: aClassExtensionModification after classMethodDefinitions.
			instanceBeforeFileNameMap  := self _createFileNameMapForMethods: aClassExtensionModification before instanceMethodDefinitions.
			classBeforeFileNameMap := self _createFileNameMapForMethods: aClassExtensionModification before classMethodDefinitions.

			aClassExtensionModification instanceMethodsModification acceptVisitor: self.
			aClassExtensionModification classMethodsModification acceptVisitor: self ]
%

category: 'project writing'
method: RwModificationFiletreeWriterVisitor
processProject: aProjectModification

	| projectProperties |

	packageDefFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification after packages.
	packageDefBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification before packages.

	"confirm that the project source is written in Tonel format"
	(self _repositoryFormatFor:  aProjectModification after packagesRoot) = 'filetree' ifFalse: [ self error: 'expected tonel format repository' ].

	projectProperties := self _filetreeProjectPropertyDictFor: aProjectModification.
	packageExtension := projectProperties at: 'packageExtension' ifAbsent: [ self packageExtension ].
	(packageExtension beginsWith: '.')
		ifTrue: [
			"properties file includes leading $., so strip it"
			packageExtension := packageExtension copyFrom: 2 to: packageExtension size ].
	(projectProperties at: 'Metadata' ifAbsent: [ 'true' ])  = 'true'
		ifTrue: [
			"Rowan can read filetree repositories with Monticello metadata, but cannot write Monticello metadata"
			self error: 'Monticello metadata not supported.' ].

	super processProject: aProjectModification.
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
separateMethodMetaAndSource

	^ separateMethodMetaAndSource ifNil: [ separateMethodMetaAndSource := false ]
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
useCypressPropertiesFile

	^ useCypressPropertiesFile ifNil: [ useCypressPropertiesFile := true ]
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitor
visitExtensionMethodModification: aMethodExtensionModification

	aMethodExtensionModification isAddition
		ifTrue: [ ^ self addedMethodExtension: aMethodExtensionModification ] .
	aMethodExtensionModification isDeletion
		ifTrue: [ ^ self deletedMethodExtension: aMethodExtensionModification ].
	^ self changedMethodExtension: aMethodExtensionModification
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitor
visitExtensionMethodsModification: aMethodExtensionsModification

	aMethodExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitor
visitMethodModification: aMethodModification

	aMethodModification isAddition
		ifTrue: [ ^ self addedMethod: aMethodModification ] .
	aMethodModification isDeletion
		ifTrue: [ ^ self deletedMethod: aMethodModification ].
	^ self changedMethod: aMethodModification
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitor
visitMethodsModification: aMethodsModification

	aMethodsModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
_classExtensionOf: aClassExtension
	"order is alphabetical"

	| definition |
	definition := self class orderedDictionaryClass new.

	definition at: #name put: aClassExtension name.

	^ self _toJSON: definition
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
_classExtensionSourceDir

	| filename |
	filename := classExtFileNameMap 
		at:  self currentClassExtension name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classExtBeforeFileNameMap at: self currentClassExtension name ].
	^ self _packageSourceDir / filename, 'extension'
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
_classSourceDir

	| filename |
	filename := classDefFileNameMap 
		at:  self currentClassDefinition name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classDefBeforeFileNameMap at: self currentClassDefinition name ].
	^ self _packageSourceDir / filename, 'class'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_createFileNameMapForMethods: aMethodDefinitionDictionary
  "https://github.com/dalehenrich/filetree/issues/92"

  "answer a dictionary that maps each definition selector to a filename that is guaranteed unique on case insensitive file systems"

  | map filenameMap |
  map := Dictionary new.
  aMethodDefinitionDictionary
    do: [ :mDef | 
      | sel col |
      "sort into bins by lowercase selector. "
      sel := mDef selector asLowercase.
      col := map
        at: sel
        ifAbsentPut: [ OrderedCollection new ].
      col add: mDef ].
  filenameMap := Dictionary new.
  map values
	do: [ :col | 
	  | sortedCol |
	  col size = 1
		ifTrue: [ 
		  | def |
		  "no need to distinguish filename"
		  def := col at: 1.
		  filenameMap
			at: def selector
			put: (self _methodFileNameFor: def) ]
		ifFalse: [ 
		  "tack on postfix to guarantee  file names are unique on case insensitive file systems"
		  sortedCol := col sorted: [ :a :b | a asString _unicodeLessThan: b asString ].
		  (1 to: sortedCol size) do: [ :index | 
			| def filename |
			def := sortedCol at: index.
			filename := self _methodFileNameFor: def.
			filename := filename , '..' , index printString.
			filenameMap at: def selector put: filename ] ] ].
  ^ filenameMap
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
_filetreePackagePropertyDictFor: aPackageModification

	| propertiesFile |
	propertiesFile := self _packageSourceDir /  '.filetree'.
	propertiesFile exists
		ifFalse: [
			"create default properties file"
			propertiesFile
				writeStreamDo: [:aStream |
				aStream 
					<< (self _toJSON:
 					(self class orderedDictionaryClass new
						add: 'noMethodMetaData' -> self noMethodMetaData;
						add: 'separateMethodMetaAndSource' -> self separateMethodMetaAndSource;
						add: 'useCypressPropertiesFile' -> self useCypressPropertiesFile;
						yourself))
					<< self  _newLine ] ].
	^ self _readObjectFrom: propertiesFile
%

category: 'project writing'
method: RwModificationFiletreeWriterVisitor
_filetreeProjectPropertyDictFor: aProjectModification

	| propertiesFile |
	propertiesFile := self _projectSourceDir /  '.filetree'.
	propertiesFile exists
		ifFalse: [
			"create default properties file"
			propertiesFile
				writeStreamDo: [:aStream |
				| dict |
				dict := (self class orderedDictionaryClass new)
					at: 'packageExtension' put: '.', self packageExtension;
					at: 'Metadata' put: self monticelloMetadata;
					yourself.
				aStream 
					<< (self _toJSON: dict )
					<< self  _newLine ] ].
	^ self _readObjectFrom: propertiesFile
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_methodClassDir

	^ self _classSourceDir / 'class'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_methodClassExtensionDir

	^ self _classExtensionSourceDir / 'class'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_methodFileNameFor: aMethodDefinition
	| selector |
	selector := aMethodDefinition selector.
	^ (selector includes: $:)
	ifTrue: [ 
	  selector
		collect: [ :each | 
		  each = $:
			ifTrue: [ $. ]
			ifFalse: [ each ] ] ]
	ifFalse: [ 
	  (self class selectorSpecials includes: selector first)
		ifFalse: [ selector ]
		ifTrue: [ 
		  | output specials |
		  specials := self class selectorSpecials.
		  output := WriteStream on: String new.
		  output nextPut: $^.
		  selector
			do: [ :each | 
			  output
				nextPutAll:
				  ((specials includes: each)
					ifTrue: [ specials at: each ]
					ifFalse: [ each asString ]) ]
			separatedBy: [ output nextPut: $. ].
		  output contents ] ]
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_methodInstanceDir

	^ self _classSourceDir / 'instance'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_methodInstanceExtensionDir

	^ self _classExtensionSourceDir / 'instance'
%

category: 'private'
method: RwModificationFiletreeWriterVisitor
_toJSON: anObject
	| str |
	str := WriteStreamPortable on: String new.
	anObject _writeCypressJsonOn: str.
	^ str contents
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
_typeClassDefinitionOf: aClassDefinition
	"order is alphabetical"

	| definition |
	definition := self class orderedDictionaryClass new.

	definition 		
		at: #category put: aClassDefinition category.

	definition at: #classinstvars put: (aClassDefinition classInstVarNames) asArray.

	definition at: #classvars put: (aClassDefinition classVarNames) asArray.

	(aClassDefinition gs_constraints)
		ifNotEmpty: [:gs_constraints | definition at: #'gs_constraints' put: gs_constraints asArray ].

	(aClassDefinition gs_options)
		ifNotEmpty: [:gs_options | definition at: #'gs_options' put: gs_options asArray ].

	definition at: #commentStamp put: ''.

	definition at: #instvars put: (aClassDefinition instVarNames) asArray.

	(aClassDefinition gs_reservedOop)
		ifNotEmpty: [:gs_reservedOop | definition at: #'gs_reservedoop' put: gs_reservedOop asString ].

	definition at: #name put: aClassDefinition name.

	definition at: #pools put: ((aClassDefinition poolDictionaryNames) collect: [:each | each asString]) asArray.

	definition at: #super put: aClassDefinition superclassName.

	definition at: #type put: aClassDefinition classType.

	^ self _toJSON: definition
%

! Class implementation for 'RwModificationTonelWriterVisitor'

!		Class methods for 'RwModificationTonelWriterVisitor'

category: 'accessing'
classmethod: RwModificationTonelWriterVisitor
classLabel
	^ 'Class'
%

!		Instance methods for 'RwModificationTonelWriterVisitor'

category: 'actions'
method: RwModificationTonelWriterVisitor
addedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification after.

	self processClassExtension: aClassExtensionModification
%

category: 'actions'
method: RwModificationTonelWriterVisitor
addedPackage: aPackageModification

	currentPackageDefinition := aPackageModification after.

	"create package directory and package.st file"
	self _packageSourceDir ensureCreateDirectory.
	(self _packageSourceDir /  'package.st')
		writeStreamDo: [:aStream |
		aStream 
			<< 'Package ' 
			<< (self _toSTON: { #name ->  currentPackageDefinition name } asDictionary) 
			<< self  _newLine ].

	self processPackage: aPackageModification
%

category: 'accessing'
method: RwModificationTonelWriterVisitor
defaultPackageFormat

	^ 'tonel'
%

category: 'actions'
method: RwModificationTonelWriterVisitor
deletedClass: aClassModification

	currentClassDefinition := aClassModification before.

	self _classSourceFile ensureDelete
%

category: 'actions'
method: RwModificationTonelWriterVisitor
deletedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification before.

	self _classExtensionSourceFile ensureDelete
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
processClass: aClassModification

	"write out the class definition"

	self _classSourceFile
		writeStreamDo: [:aStream |
			self _writeClassDefinition: currentClassDefinition on: aStream.
			self _writeClassSideMethodDefinitions: currentClassDefinition on: aStream.
			self _writeInstanceSideMethodDefinitions: currentClassDefinition on: aStream ]
%

category: 'class extension writing'
method: RwModificationTonelWriterVisitor
processClassExtension: aClassExtensionModification

	"write out the class definition"

	(currentClassExtension instanceMethodDefinitions isEmpty and: [ currentClassExtension classMethodDefinitions isEmpty ])
		ifTrue: [ self _classExtensionSourceFile ensureDelete ]
		ifFalse: [ 
			self _classExtensionSourceFile
				writeStreamDo: [:aStream |
					self _writeClassExtension: currentClassExtension on: aStream.
					self _writeClassSideMethodDefinitions: currentClassExtension on: aStream.
					self _writeInstanceSideMethodDefinitions: currentClassExtension on: aStream ] ]
%

category: 'project writing'
method: RwModificationTonelWriterVisitor
processProject: aProjectModification
	"confirm that the project source is written in Tonel format"

	| format propertiesFile |
	packageDefFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification after packages.
	packageDefBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification before packages.

	(format := self _repositoryFormatFor:  aProjectModification after packagesRoot) = 'tonel' ifFalse: [ self error: 'expected tonel format repository, instead format is ', format printString ].

	propertiesFile := aProjectModification after packagesRoot /  'properties.st'.
	propertiesFile exists
		ifFalse: [
			propertiesFile writeStreamDo: [ :fileStream | 
				fileStream 
					nextPutAll: '{ #format : ' , format printString , '}';
					lf;
					nextPutAll: '{ #convention : ' , currentProjectDefinition packageConvention printString , '}';
					yourself ] ].

	super processProject: aProjectModification.
%

category: 'private'
method: RwModificationTonelWriterVisitor
skipComment: aStream
  "I assume I'm on top of the begining of a comment"
  aStream skip: 1.
  [ aStream atEnd not 
    and: [ aStream next ~= $" or: [ aStream peek = $" ] ] ]
  whileTrue.  
%

category: 'private'
method: RwModificationTonelWriterVisitor
skipSeparators: aStream
  [ aStream peek isSeparator ]
    whileTrue: [ aStream skip: 1 ]. 
%

category: 'class extension writing'
method: RwModificationTonelWriterVisitor
_classExtensionSourceFile

	| filename |
	filename := classExtFileNameMap 
		at:  self currentClassExtension name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classExtBeforeFileNameMap at: self currentClassExtension name ].
	^ self _packageSourceDir / (filename, '.extension.st')
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_classSourceFile

	| filename |
	filename := classDefFileNameMap 
		at:  self currentClassDefinition name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classDefBeforeFileNameMap at: self currentClassDefinition name ].
	^ self _packageSourceDir / (filename, '.class.st')
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_hasCommentOf: aClassDefinition 

	| comment |
	comment := aClassDefinition comment.
	^ comment notNil and: [ comment ~= '' ]
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_hasShebangOf: aClassDefinition 

	^  aClassDefinition shebang notNil
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_methodDefinitionOf: aMethodDefinition
	^ self _toSTON: (self class orderedDictionaryClass new 
		at: #category put: aMethodDefinition protocol; 
		yourself)
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_selectorIsComplete: keywords in: aString
	| start |
	
	start := 1.
	keywords do: [ :each | | index | 
		index := aString 
			findString: each 
			startingAt: start 
			caseSensitive: true.
		index = 0 ifTrue: [ ^ false ].
		start := index + each size ].
	^ true
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_shebangOf: aClassDefinition

	^ aClassDefinition shebang
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_splitMethodSource: aMethodDefinition into: aBlock
	| keywords source declaration |
	
	keywords := aMethodDefinition selector asSymbol keywords.
	source := aMethodDefinition source readStream.
	"Skip spaces"
	(source peek isSeparator) ifTrue: [ self skipSeparators: source ].
	"Skip comments"
	(source peek = $") ifTrue: [ self skipComment: source ]. 
	"Parse declaration"
	declaration := String new writeStreamPortable.
	[ (self _selectorIsComplete: keywords in: declaration originalContents) not 
		or: [ ':+-/\*~<>=@,%|&?!' includes: declaration contents trimRight last ] ]
	whileTrue: [ 
		"get separators"
		[ source atEnd not and: [ source peek isSeparator ] ]
			whileTrue: [ declaration nextPut: source next ].
		"take next word"
		[ source atEnd not and: [ source peek isSeparator not ] ]
			whileTrue: [ declaration nextPut: source next ] ].
	aBlock 
		value: (declaration contents trimLeft withLineEndings: self _newLine)
		value: (source upToEnd withLineEndings: self _newLine)
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_typeClassDefinitionOf: aClassDefinition
	| definition |
	
	definition := self class orderedDictionaryClass new 
		at: #name put: aClassDefinition name; 
		at: #superclass put: aClassDefinition superclassName;
		yourself.

	aClassDefinition classType = 'normal' ifFalse: [ 
		definition at: #type put: aClassDefinition classType ].
	
	(aClassDefinition instVarNames)
		ifNotEmpty: [ :vars | definition at: #instVars put: vars asArray ].

	(aClassDefinition classVarNames)
		ifNotEmpty: [ :vars | definition at: #classVars put: vars asArray ].
		
	((aClassDefinition poolDictionaryNames) collect: [:each | each asString])
		ifNotEmpty: [ :vars | definition at: #pools put: vars asArray ].
		
	(aClassDefinition classInstVarNames)
		ifNotEmpty: [ :vars | definition at: #classInstVars put: vars asArray ].

	(aClassDefinition gs_constraints)
		ifNotEmpty: [:gs_constraints | definition at: #'gs_constraints' put: gs_constraints asArray ].

	(aClassDefinition gs_options)
		ifNotEmpty: [:gs_options | definition at: #'gs_options' put: gs_options asArray ].

	(aClassDefinition gs_reservedOop)
		ifNotEmpty: [:gs_reservedOop | definition at: #'gs_reservedoop' put: gs_reservedOop asString ].

	definition 		
		at: #category put: aClassDefinition category.
	
	^ self _toSTON: definition
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_typeOfClass: aClassDefinition
	^ self class classLabel
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_writeClassDefinition: aClassDefinition on: aStream
	| nl |
	nl := self _newLine.
	
	(self _hasShebangOf: aClassDefinition)
		ifTrue: [ aStream << '#!' << (self _shebangOf: aClassDefinition) << nl ].
	(self _hasCommentOf: aClassDefinition) 
		ifTrue: [ 
			aStream 
				<< '"' << nl
				<< (self _commentOf: aClassDefinition) << nl
				<< '"' << nl ].
	aStream
		<< (self _typeOfClass: aClassDefinition) 
		<< ' ' << (self _typeClassDefinitionOf: aClassDefinition ) << nl
%

category: 'class extension writing'
method: RwModificationTonelWriterVisitor
_writeClassExtension: aClassExtension on: aStream

	aStream << 'Extension '
				<< (self _toSTON: {(#'name' -> aClassExtension name)} asDictionary) << self _newLine.
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_writeClassSideMethodDefinitions: aClassDefinition on: aStream
	((aClassDefinition classMethodDefinitions values )
		sortWithBlock: [ :a :b | a selector _unicodeLessThan: b selector ])
		do: [ :each | 
			self _writeMethodDefinition: each classDefinition: aClassDefinition isMeta: true on: aStream ]
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_writeInstanceSideMethodDefinitions: aClassDefinition on: aStream
	((aClassDefinition instanceMethodDefinitions values )
		sortWithBlock: [ :a :b | a selector _unicodeLessThan: b selector ])
		do: [ :each | 
			self _writeMethodDefinition: each classDefinition: aClassDefinition isMeta: false on: aStream ]
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_writeMethodDefinition: aMethodDefinition  classDefinition: aClassDefinition isMeta: isMeta on: aStream
	| nl |
	
	nl := self _newLine.
	self 
		_splitMethodSource: aMethodDefinition 
		into: [ :methodDeclaration :methodBody | | fullClassName |
			fullClassName :=aClassDefinition name  , (isMeta ifTrue: [' class'] ifFalse: ['']).
			aStream 
				<< nl 
				<< (self _methodDefinitionOf: aMethodDefinition) << nl 
				<< fullClassName << ' >> ' << methodDeclaration 
				<< ' [' << methodBody << nl << ']' << nl ]
%

! Class implementation for 'RwModificationCypressFamilyWriterVisitorV2'

!		Class methods for 'RwModificationCypressFamilyWriterVisitorV2'

category: 'accessing'
classmethod: RwModificationCypressFamilyWriterVisitorV2
orderedDictionaryClass
  "Answer the platform-specific OrderedDictionary-compatible class"

  ^ GsTonelOrderedDictionary
%

!		Instance methods for 'RwModificationCypressFamilyWriterVisitorV2'

category: 'actions'
method: RwModificationCypressFamilyWriterVisitorV2
deletedPackage: aPackageModification

	currentPackageDefinition := aPackageModification before.

	self _packageSourceDir ensureDeleteAll.	"delete the whole package directory"
%

category: 'package writing'
method: RwModificationCypressFamilyWriterVisitorV2
packageExtension

	^ ''
%

category: 'accessing'
method: RwModificationCypressFamilyWriterVisitorV2
packagesRoot
	^ packagesRoot
%

category: 'accessing'
method: RwModificationCypressFamilyWriterVisitorV2
packagesRoot: aFileReference
	packagesRoot := aFileReference
%

category: 'package writing'
method: RwModificationCypressFamilyWriterVisitorV2
processPackage: aPackageModification

	classDefFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification after classDefinitions.
	classExtFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification after classExtensions.
	classDefBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification before classDefinitions.
	classExtBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification before classExtensions.

	super processPackage: aPackageModification
%

category: 'class writing'
method: RwModificationCypressFamilyWriterVisitorV2
_commentOf: aClassDefinition
	^ aClassDefinition comment withLineEndings: self _newLine
%

category: 'package writing'
method: RwModificationCypressFamilyWriterVisitorV2
_packageSourceDir

	| filename |
	filename := packageDefFileNameMap 
		at:  self currentPackageDefinition name 
		ifAbsent: [
			"in the case of package removal, need to use the before package map"
			packageDefBeforeFileNameMap at: self currentPackageDefinition name ].
	^ self packageExtension isEmpty
		ifTrue: [ self _projectSourceDir /filename ]
		ifFalse: [ self _projectSourceDir /filename, self packageExtension ]
%

category: 'project writing'
method: RwModificationCypressFamilyWriterVisitorV2
_projectSourceDir
	^ self packagesRoot
%

category: 'private'
method: RwModificationCypressFamilyWriterVisitorV2
_toJSON: anObject
	^ (STON toJsonStringPretty: anObject)
		withLineEndings: self _newLine
%

category: 'private'
method: RwModificationCypressFamilyWriterVisitorV2
_toSTON: anObject
	^ (String streamContents: [ :stream | 
		(TonelSTONWriter on: stream) nextPut: anObject ])
		withLineEndings: self _newLine
%

! Class implementation for 'RwModificationFiletreeWriterVisitorV2'

!		Class methods for 'RwModificationFiletreeWriterVisitorV2'

category: 'initialization'
classmethod: RwModificationFiletreeWriterVisitorV2
initialize
	"self initialize"
    specials := self initializeSpecials
%

category: 'initialization'
classmethod: RwModificationFiletreeWriterVisitorV2
initializeSpecials

    | map |
    map := Dictionary new.
    map
		at: $! put: 'bang';
        at: $+ put: 'plus';
        at: $- put: 'minus';
        at: $= put: 'equals';
        at: $< put: 'less';
        at: $> put: 'more';
        at: $% put: 'percent';
        at: $& put: 'and';
        at: $| put: 'pipe';
        at: $* put: 'star';
        at: $/ put: 'slash';
        at: $\ put: 'backslash';
        at: $~ put: 'tilde';
        at: $? put: 'wat';
        at: $, put: 'comma';
        at: $@ put: 'at'.
    map keys do: [ :key | map at: (map at: key) put: key ].
    ^ map
%

category: 'accessing'
classmethod: RwModificationFiletreeWriterVisitorV2
selectorSpecials

	^ specials ifNil: [ specials := self initializeSpecials ]
%

!		Instance methods for 'RwModificationFiletreeWriterVisitorV2'

category: 'actions'
method: RwModificationFiletreeWriterVisitorV2
addedMethod: aMethodModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodModification after.

	"create instance/class directory as needed ... write method source file"
	 (aMethodModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st')
		writeStreamDo: [:aStream |
		aStream 
			<< methodDefinition protocol
			<< self _newLine
			<< (methodDefinition source withLineEndings: self _newLine) ]
%

category: 'actions'
method: RwModificationFiletreeWriterVisitorV2
addedMethodExtension: aMethodExtensionModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodExtensionModification after.

	"create instance/class directory as needed ... write method source file"
	 (aMethodExtensionModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassExtensionDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceExtensionDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st')
		writeStreamDo: [:aStream |
		aStream 
			<< methodDefinition protocol
			<< self _newLine
			<< (methodDefinition source withLineEndings: self _newLine) ]
%

category: 'actions'
method: RwModificationFiletreeWriterVisitorV2
addedPackage: aPackageModification

	| packageProperties |
	currentPackageDefinition := aPackageModification after.

	"create package directory and properties.json file"
	self _packageSourceDir ensureCreateDirectory.
	(self _packageSourceDir /  'properties.json')
		writeStreamDo: [:aStream |
		aStream 
			<< '{'
			<< self  _newLine
			<< '	 }'].

	packageProperties := self _filetreePackagePropertyDictFor: aPackageModification.
	(packageProperties at:  'noMethodMetaData' ifAbsent: []) = self noMethodMetaData
		ifFalse: [
			"Rowan can read filetree repositories with methodMetaData, but does write method metadata"
			self error: 'method metadata not supported.' ].
	(packageProperties at:  'separateMethodMetaAndSource' ifAbsent: []) = self separateMethodMetaAndSource
		ifFalse: [
			"Rowan can read filetree repositories with separateMethodMetaAndSource, but does write separateMethodMetaAndSource"
			self error: 'separateMethodMetaAndSource not supported.' ].
	(packageProperties at:  'useCypressPropertiesFile' ifAbsent: []) = self useCypressPropertiesFile
		ifFalse: [
			"Rowan can read filetree repositories without CypressPropertiesFile, but does write without useCypressPropertiesFile"
			self error: 'only useCypressPropertiesFile not supported.' ].

	self processPackage: aPackageModification
%

category: 'actions'
method: RwModificationFiletreeWriterVisitorV2
changedMethod: aMethodModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodModification after.

	"create instance/class directory as needed ... write method source file"
	 (aMethodModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st')
		writeStreamDo: [:aStream |
		aStream 
			<< methodDefinition protocol
			<< self _newLine
			<< (methodDefinition source withLineEndings: self _newLine) ]
%

category: 'actions'
method: RwModificationFiletreeWriterVisitorV2
changedMethodExtension: aMethodExtensionModification

	self addedMethodExtension: aMethodExtensionModification
%

category: 'accessing'
method: RwModificationFiletreeWriterVisitorV2
defaultPackageFormat

	^ 'filetree'
%

category: 'actions'
method: RwModificationFiletreeWriterVisitorV2
deletedClass: aClassModification

	currentClassDefinition := aClassModification before.

	self _classSourceDir ensureDeleteAll
%

category: 'actions'
method: RwModificationFiletreeWriterVisitorV2
deletedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification before.

	self _classExtensionSourceDir ensureDeleteAll
%

category: 'actions'
method: RwModificationFiletreeWriterVisitorV2
deletedMethod: aMethodModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodModification before.

	"delete method source file"
	 (aMethodModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector
				ifAbsent: [ classBeforeFileNameMap at: methodDefinition selector ].
			methodDir := self _methodClassDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector
				ifAbsent: [ instanceBeforeFileNameMap at: methodDefinition selector ].
			methodDir := self _methodInstanceDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st') ensureDelete
%

category: 'actions'
method: RwModificationFiletreeWriterVisitorV2
deletedMethodExtension: aMethodExtensionModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodExtensionModification before.

	"create instance/class directory as needed ... write method source file"
	 (aMethodExtensionModification isMeta
		ifTrue: [
			methodFileName := classBeforeFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassExtensionDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceBeforeFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceExtensionDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st') ensureDelete
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitorV2
monticelloMetadata
	"monticello metadata  --- for writing metadataless is the only supported format"

	^ monticelloMetadata ifNil: [ monticelloMetadata := 'false' ]
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitorV2
noMethodMetaData

	^ noMethodMetaData ifNil: [ noMethodMetaData := true ]
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitorV2
packageExtension

	^ packageExtension ifNil: [ packageExtension := 'package' ]
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitorV2
processClass: aClassModification

	"create class directory and class defintion structure"

	self _classSourceDir ensureCreateDirectory.

	(self _classSourceDir /  'README.md')
		writeStreamDo: [:aStream |
		aStream 
			<< (self _commentOf: self currentClassDefinition) ].

	(self _classSourceDir /  'properties.json')
		writeStreamDo: [:aStream |
			aStream 
				<< (self _typeClassDefinitionOf: self currentClassDefinition)
				<< self _newLine ].

	instanceFileNameMap  := self _createFileNameMapForMethods: aClassModification after instanceMethodDefinitions.
	classFileNameMap := self _createFileNameMapForMethods: aClassModification after classMethodDefinitions.
	instanceBeforeFileNameMap  := self _createFileNameMapForMethods: aClassModification before instanceMethodDefinitions.
	classBeforeFileNameMap := self _createFileNameMapForMethods: aClassModification before classMethodDefinitions.

	currentClassDefinition instanceMethodDefinitions isEmpty
		ifTrue: [  self _methodInstanceDir ensureDeleteAll ]
		ifFalse: [ aClassModification instanceMethodsModification acceptVisitor: self ].
	currentClassDefinition classMethodDefinitions isEmpty
		ifTrue: [  self _methodClassDir ensureDeleteAll ]
		ifFalse: [ aClassModification classMethodsModification acceptVisitor: self ]
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitorV2
processClassExtension: aClassExtensionModification

	"create class extension directory and defintion structure"

	(currentClassExtension instanceMethodDefinitions isEmpty and: [ currentClassExtension classMethodDefinitions isEmpty ])
		ifTrue: [ self _classExtensionSourceDir ensureDeleteAll ]
		ifFalse: [ 
			self _classExtensionSourceDir ensureCreateDirectory.
			(self _classExtensionSourceDir /  'properties.json')
				writeStreamDo: [:aStream |
					aStream 
						<< (self _classExtensionOf: self currentClassExtension)
						<< self _newLine ].

			instanceFileNameMap  := self _createFileNameMapForMethods: aClassExtensionModification after instanceMethodDefinitions.
			classFileNameMap := self _createFileNameMapForMethods: aClassExtensionModification after classMethodDefinitions.
			instanceBeforeFileNameMap  := self _createFileNameMapForMethods: aClassExtensionModification before instanceMethodDefinitions.
			classBeforeFileNameMap := self _createFileNameMapForMethods: aClassExtensionModification before classMethodDefinitions.

			aClassExtensionModification instanceMethodsModification acceptVisitor: self.
			aClassExtensionModification classMethodsModification acceptVisitor: self ]
%

category: 'project writing'
method: RwModificationFiletreeWriterVisitorV2
processProject: aProjectModification

	| projectProperties |

	packageDefFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification after packages.
	packageDefBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification before packages.

	"confirm that the project source is written in Tonel format"
	(self _repositoryFormatFor: self packagesRoot) = 'filetree' ifFalse: [ self error: 'expected tonel format repository' ].

	projectProperties := self _filetreeProjectPropertyDictFor: aProjectModification.
	packageExtension := projectProperties at: 'packageExtension' ifAbsent: [ self packageExtension ].
	(packageExtension beginsWith: '.')
		ifTrue: [
			"properties file includes leading $., so strip it"
			packageExtension := packageExtension copyFrom: 2 to: packageExtension size ].
	(projectProperties at: 'Metadata' ifAbsent: [ 'true' ])  = 'true'
		ifTrue: [
			"Rowan can read filetree repositories with Monticello metadata, but cannot write Monticello metadata"
			self error: 'Monticello metadata not supported.' ].

	super processProject: aProjectModification.
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitorV2
separateMethodMetaAndSource

	^ separateMethodMetaAndSource ifNil: [ separateMethodMetaAndSource := false ]
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitorV2
useCypressPropertiesFile

	^ useCypressPropertiesFile ifNil: [ useCypressPropertiesFile := true ]
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitorV2
visitExtensionMethodModification: aMethodExtensionModification

	aMethodExtensionModification isAddition
		ifTrue: [ ^ self addedMethodExtension: aMethodExtensionModification ] .
	aMethodExtensionModification isDeletion
		ifTrue: [ ^ self deletedMethodExtension: aMethodExtensionModification ].
	^ self changedMethodExtension: aMethodExtensionModification
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitorV2
visitExtensionMethodsModification: aMethodExtensionsModification

	aMethodExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitorV2
visitMethodModification: aMethodModification

	aMethodModification isAddition
		ifTrue: [ ^ self addedMethod: aMethodModification ] .
	aMethodModification isDeletion
		ifTrue: [ ^ self deletedMethod: aMethodModification ].
	^ self changedMethod: aMethodModification
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitorV2
visitMethodsModification: aMethodsModification

	aMethodsModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitorV2
_classExtensionOf: aClassExtension
	"order is alphabetical"

	| definition |
	definition := self class orderedDictionaryClass new.

	definition at: #name put: aClassExtension name.

	^ self _toJSON: definition
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitorV2
_classExtensionSourceDir

	| filename |
	filename := classExtFileNameMap 
		at:  self currentClassExtension name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classExtBeforeFileNameMap at: self currentClassExtension name ].
	^ self _packageSourceDir / filename, 'extension'
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitorV2
_classSourceDir

	| filename |
	filename := classDefFileNameMap 
		at:  self currentClassDefinition name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classDefBeforeFileNameMap at: self currentClassDefinition name ].
	^ self _packageSourceDir / filename, 'class'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitorV2
_createFileNameMapForMethods: aMethodDefinitionDictionary
  "https://github.com/dalehenrich/filetree/issues/92"

  "answer a dictionary that maps each definition selector to a filename that is guaranteed unique on case insensitive file systems"

  | map filenameMap |
  map := Dictionary new.
  aMethodDefinitionDictionary
    do: [ :mDef | 
      | sel col |
      "sort into bins by lowercase selector. "
      sel := mDef selector asLowercase.
      col := map
        at: sel
        ifAbsentPut: [ OrderedCollection new ].
      col add: mDef ].
  filenameMap := Dictionary new.
  map values
	do: [ :col | 
	  | sortedCol |
	  col size = 1
		ifTrue: [ 
		  | def |
		  "no need to distinguish filename"
		  def := col at: 1.
		  filenameMap
			at: def selector
			put: (self _methodFileNameFor: def) ]
		ifFalse: [ 
		  "tack on postfix to guarantee  file names are unique on case insensitive file systems"
		  sortedCol := col sorted: [ :a :b | a asString _unicodeLessThan: b asString ].
		  (1 to: sortedCol size) do: [ :index | 
			| def filename |
			def := sortedCol at: index.
			filename := self _methodFileNameFor: def.
			filename := filename , '..' , index printString.
			filenameMap at: def selector put: filename ] ] ].
  ^ filenameMap
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitorV2
_filetreePackagePropertyDictFor: aPackageModification

	| propertiesFile |
	propertiesFile := self _packageSourceDir /  '.filetree'.
	propertiesFile exists
		ifFalse: [
			"create default properties file"
			propertiesFile
				writeStreamDo: [:aStream |
				aStream 
					<< (self _toJSON:
 					(self class orderedDictionaryClass new
						add: 'noMethodMetaData' -> self noMethodMetaData;
						add: 'separateMethodMetaAndSource' -> self separateMethodMetaAndSource;
						add: 'useCypressPropertiesFile' -> self useCypressPropertiesFile;
						yourself))
					<< self  _newLine ] ].
	^ self _readObjectFrom: propertiesFile
%

category: 'project writing'
method: RwModificationFiletreeWriterVisitorV2
_filetreeProjectPropertyDictFor: aProjectModification

	| propertiesFile |
	propertiesFile := self _projectSourceDir /  '.filetree'.
	propertiesFile exists
		ifFalse: [
			"create default properties file"
			propertiesFile
				writeStreamDo: [:aStream |
				| dict |
				dict := (self class orderedDictionaryClass new)
					at: 'packageExtension' put: '.', self packageExtension;
					at: 'Metadata' put: self monticelloMetadata;
					yourself.
				aStream 
					<< (self _toJSON: dict )
					<< self  _newLine ] ].
	^ self _readObjectFrom: propertiesFile
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitorV2
_methodClassDir

	^ self _classSourceDir / 'class'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitorV2
_methodClassExtensionDir

	^ self _classExtensionSourceDir / 'class'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitorV2
_methodFileNameFor: aMethodDefinition
	| selector |
	selector := aMethodDefinition selector.
	^ (selector includes: $:)
	ifTrue: [ 
	  selector
		collect: [ :each | 
		  each = $:
			ifTrue: [ $. ]
			ifFalse: [ each ] ] ]
	ifFalse: [ 
	  (self class selectorSpecials includes: selector first)
		ifFalse: [ selector ]
		ifTrue: [ 
		  | output specials |
		  specials := self class selectorSpecials.
		  output := WriteStream on: String new.
		  output nextPut: $^.
		  selector
			do: [ :each | 
			  output
				nextPutAll:
				  ((specials includes: each)
					ifTrue: [ specials at: each ]
					ifFalse: [ each asString ]) ]
			separatedBy: [ output nextPut: $. ].
		  output contents ] ]
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitorV2
_methodInstanceDir

	^ self _classSourceDir / 'instance'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitorV2
_methodInstanceExtensionDir

	^ self _classExtensionSourceDir / 'instance'
%

category: 'private'
method: RwModificationFiletreeWriterVisitorV2
_toJSON: anObject
	| str |
	str := WriteStreamPortable on: String new.
	anObject _writeCypressJsonOn: str.
	^ str contents
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitorV2
_typeClassDefinitionOf: aClassDefinition
	"order is alphabetical"

	| definition |
	definition := self class orderedDictionaryClass new.

	definition 		
		at: #category put: aClassDefinition category.

	definition at: #classinstvars put: (aClassDefinition classInstVarNames) asArray.

	definition at: #classvars put: (aClassDefinition classVarNames) asArray.

	(aClassDefinition gs_constraints)
		ifNotEmpty: [:gs_constraints | definition at: #'gs_constraints' put: gs_constraints asArray ].

	(aClassDefinition gs_options)
		ifNotEmpty: [:gs_options | definition at: #'gs_options' put: gs_options asArray ].

	definition at: #commentStamp put: ''.

	definition at: #instvars put: (aClassDefinition instVarNames) asArray.

	(aClassDefinition gs_reservedOop)
		ifNotEmpty: [:gs_reservedOop | definition at: #'gs_reservedoop' put: gs_reservedOop asString ].

	definition at: #name put: aClassDefinition name.

	definition at: #pools put: ((aClassDefinition poolDictionaryNames) collect: [:each | each asString]) asArray.

	definition at: #super put: aClassDefinition superclassName.

	definition at: #type put: aClassDefinition classType.

	^ self _toJSON: definition
%

! Class implementation for 'RwModificationTonelWriterVisitorV2'

!		Class methods for 'RwModificationTonelWriterVisitorV2'

category: 'accessing'
classmethod: RwModificationTonelWriterVisitorV2
classLabel
	^ 'Class'
%

!		Instance methods for 'RwModificationTonelWriterVisitorV2'

category: 'actions'
method: RwModificationTonelWriterVisitorV2
addedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification after.

	self processClassExtension: aClassExtensionModification
%

category: 'actions'
method: RwModificationTonelWriterVisitorV2
addedPackage: aPackageModification
	| packageProperties exportedPackageProperties |
	currentPackageDefinition := aPackageModification after.

	packageProperties := currentPackageDefinition properties.
	exportedPackageProperties := self class orderedDictionaryClass new.
	exportedPackageProperties at: #'name' put: (packageProperties at: 'name').
	(packageProperties at: 'comment' ifAbsent: [  ])
		ifNotNil: [ :comment | exportedPackageProperties at: #'comment' put: comment ].
	(packageProperties keys
		reject: [ :key | key = 'name' or: [ key = 'gs_SymbolDictionary' ] ]) asArray
		sort
		do: [ :key | exportedPackageProperties at: key asSymbol put: (packageProperties at: key) ].

	self _packageSourceDir ensureCreateDirectory.
	self _packageSourceDir / 'package.st'
		writeStreamDo: [ :aStream | 
			aStream << 'Package ' << (self _toSTON: exportedPackageProperties)
				<< self _newLine ].

	self processPackage: aPackageModification
%

category: 'accessing'
method: RwModificationTonelWriterVisitorV2
defaultPackageFormat

	^ 'tonel'
%

category: 'actions'
method: RwModificationTonelWriterVisitorV2
deletedClass: aClassModification

	currentClassDefinition := aClassModification before.

	self _classSourceFile ensureDelete
%

category: 'actions'
method: RwModificationTonelWriterVisitorV2
deletedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification before.

	self _classExtensionSourceFile ensureDelete
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
processClass: aClassModification

	"write out the class definition"

	self _classSourceFile
		writeStreamDo: [:aStream |
			self _writeClassDefinition: currentClassDefinition on: aStream.
			self _writeClassSideMethodDefinitions: currentClassDefinition on: aStream.
			self _writeInstanceSideMethodDefinitions: currentClassDefinition on: aStream ]
%

category: 'class extension writing'
method: RwModificationTonelWriterVisitorV2
processClassExtension: aClassExtensionModification

	"write out the class definition"

	(currentClassExtension instanceMethodDefinitions isEmpty and: [ currentClassExtension classMethodDefinitions isEmpty ])
		ifTrue: [ self _classExtensionSourceFile ensureDelete ]
		ifFalse: [ 
			self _classExtensionSourceFile
				writeStreamDo: [:aStream |
					self _writeClassExtension: currentClassExtension on: aStream.
					self _writeClassSideMethodDefinitions: currentClassExtension on: aStream.
					self _writeInstanceSideMethodDefinitions: currentClassExtension on: aStream ] ]
%

category: 'project writing'
method: RwModificationTonelWriterVisitorV2
processProject: aProjectModification
	"confirm that the project source is written in Tonel format"

	| format propertiesFile |
	packageDefFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification after packages.
	packageDefBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification before packages.

	(format := self _repositoryFormatFor: self packagesRoot) = 'tonel' ifFalse: [ self error: 'expected tonel format repository, instead format is ', format printString ].

	propertiesFile := self packagesRoot /  'properties.st'.
	propertiesFile exists
		ifFalse: [
			propertiesFile writeStreamDo: [ :fileStream | 
				fileStream 
					nextPutAll: '{ #format : ' , format printString , '}';
					lf;
					nextPutAll: '{ #convention : ' , currentProjectDefinition packageConvention printString , '}';
					yourself ] ].

	super processProject: aProjectModification.
%

category: 'private'
method: RwModificationTonelWriterVisitorV2
skipComment: aStream
  "I assume I'm on top of the begining of a comment"
  aStream skip: 1.
  [ aStream atEnd not 
    and: [ aStream next ~= $" or: [ aStream peek = $" ] ] ]
  whileTrue.  
%

category: 'private'
method: RwModificationTonelWriterVisitorV2
skipSeparators: aStream
  [ aStream peek isSeparator ]
    whileTrue: [ aStream skip: 1 ]. 
%

category: 'class extension writing'
method: RwModificationTonelWriterVisitorV2
_classExtensionSourceFile

	| filename |
	filename := classExtFileNameMap 
		at:  self currentClassExtension name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classExtBeforeFileNameMap at: self currentClassExtension name ].
	^ self _packageSourceDir / (filename, '.extension.st')
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_classSourceFile

	| filename |
	filename := classDefFileNameMap 
		at:  self currentClassDefinition name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classDefBeforeFileNameMap at: self currentClassDefinition name ].
	^ self _packageSourceDir / (filename, '.class.st')
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_commentOf: aClassDefinition
	^ (aClassDefinition comment 
		copyReplaceAll: '"' 
		with: '""')
		withLineEndings: self _newLine
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_hasCommentOf: aClassDefinition 

	| comment |
	comment := aClassDefinition comment.
	^ comment notNil and: [ comment ~= '' ]
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_hasShebangOf: aClassDefinition 

	^  aClassDefinition shebang notNil
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_methodDefinitionOf: aMethodDefinition
	| excludedMethodProperties methodProperties exportedProperties |
	excludedMethodProperties := #('_gsFileOffset' '_gsFileName' 'category' 'protocol' 'selector').
	exportedProperties := self class orderedDictionaryClass new
		at: #'category' put: aMethodDefinition protocol;
		yourself.
	methodProperties := aMethodDefinition properties.
	(methodProperties keys
		reject: [ :each | excludedMethodProperties includes: each ]) asArray sort
		do: [ :key | exportedProperties at: key asSymbol put: (methodProperties at: key) ].
	^ self _toSTON: exportedProperties
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_selectorIsComplete: keywords in: aString
	| start |
	
	start := 1.
	keywords do: [ :each | | index | 
		index := aString 
			findString: each 
			startingAt: start 
			caseSensitive: true.
		index = 0 ifTrue: [ ^ false ].
		start := index + each size ].
	^ true
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_shebangOf: aClassDefinition

	^ aClassDefinition shebang
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_splitMethodSource: aMethodDefinition into: aBlock
	| keywords source declaration |
	
	keywords := aMethodDefinition selector asSymbol keywords.
	source := aMethodDefinition source readStream.
	"Skip spaces"
	(source peek isSeparator) ifTrue: [ self skipSeparators: source ].
	"Skip comments"
	(source peek = $") ifTrue: [ self skipComment: source ]. 
	"Parse declaration"
	declaration := String new writeStreamPortable.
	[ (self _selectorIsComplete: keywords in: declaration originalContents) not 
		or: [ ':+-/\*~<>=@,%|&?!' includes: declaration contents trimRight last ] ]
	whileTrue: [ 
		"get separators"
		[ source atEnd not and: [ source peek isSeparator ] ]
			whileTrue: [ declaration nextPut: source next ].
		"take next word"
		[ source atEnd not and: [ source peek isSeparator not ] ]
			whileTrue: [ declaration nextPut: source next ] ].
	aBlock 
		value: (declaration contents trimLeft withLineEndings: self _newLine)
		value: (source upToEnd withLineEndings: self _newLine)
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_typeClassDefinitionOf: aClassDefinition
	| definition |
	
	definition := self class orderedDictionaryClass new 
		at: #name put: aClassDefinition name; 
		at: #superclass put: aClassDefinition superclassName;
		yourself.

	aClassDefinition classType = 'normal' ifFalse: [ 
		definition at: #type put: aClassDefinition classType ].
	
	(aClassDefinition instVarNames)
		ifNotEmpty: [ :vars | definition at: #instVars put: vars asArray ].

	(aClassDefinition classVarNames)
		ifNotEmpty: [ :vars | definition at: #classVars put: vars asArray ].
		
	((aClassDefinition poolDictionaryNames) collect: [:each | each asString])
		ifNotEmpty: [ :vars | definition at: #pools put: vars asArray ].
		
	(aClassDefinition classInstVarNames)
		ifNotEmpty: [ :vars | definition at: #classInstVars put: vars asArray ].

	(aClassDefinition gs_constraints)
		ifNotEmpty: [:gs_constraints | definition at: #'gs_constraints' put: gs_constraints asArray ].

	(aClassDefinition gs_options)
		ifNotEmpty: [:gs_options | definition at: #'gs_options' put: gs_options asArray ].

	(aClassDefinition gs_reservedOop)
		ifNotEmpty: [:gs_reservedOop | definition at: #'gs_reservedoop' put: gs_reservedOop asString ].

	definition 		
		at: #category put: aClassDefinition category.
	
	^ self _toSTON: definition
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_typeOfClass: aClassDefinition
	^ self class tonelClassLabel
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_writeClassDefinition: aClassDefinition on: aStream
	| nl |
	nl := self _newLine.
	
	(self _hasShebangOf: aClassDefinition)
		ifTrue: [ aStream << '#!' << (self _shebangOf: aClassDefinition) << nl ].
	(self _hasCommentOf: aClassDefinition) 
		ifTrue: [ 
			aStream 
				<< '"' << nl
				<< (self _commentOf: aClassDefinition) << nl
				<< '"' << nl ].
	aStream
		<< (self _typeOfClass: aClassDefinition) 
		<< ' ' << (self _typeClassDefinitionOf: aClassDefinition ) << nl
%

category: 'class extension writing'
method: RwModificationTonelWriterVisitorV2
_writeClassExtension: aClassExtension on: aStream

	aStream << 'Extension '
				<< (self _toSTON: {(#'name' -> aClassExtension name)} asDictionary) << self _newLine.
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_writeClassSideMethodDefinitions: aClassDefinition on: aStream
	((aClassDefinition classMethodDefinitions values )
		sortWithBlock: [ :a :b | a selector _unicodeLessThan: b selector ])
		do: [ :each | 
			self _writeMethodDefinition: each classDefinition: aClassDefinition isMeta: true on: aStream ]
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_writeInstanceSideMethodDefinitions: aClassDefinition on: aStream
	((aClassDefinition instanceMethodDefinitions values )
		sortWithBlock: [ :a :b | a selector _unicodeLessThan: b selector ])
		do: [ :each | 
			self _writeMethodDefinition: each classDefinition: aClassDefinition isMeta: false on: aStream ]
%

category: 'class writing'
method: RwModificationTonelWriterVisitorV2
_writeMethodDefinition: aMethodDefinition  classDefinition: aClassDefinition isMeta: isMeta on: aStream
	| nl |
	
	nl := self _newLine.
	self 
		_splitMethodSource: aMethodDefinition 
		into: [ :methodDeclaration :methodBody | | fullClassName |
			fullClassName :=aClassDefinition name  , (isMeta ifTrue: [' class'] ifFalse: ['']).
			aStream 
				<< nl 
				<< (self _methodDefinitionOf: aMethodDefinition) << nl 
				<< fullClassName << ' >> ' << methodDeclaration 
				<< ' [' << methodBody << nl << ']' << nl ]
%

! Class implementation for 'RwModificationPharoTonelFormatV1WriterVisitorV2'

!		Instance methods for 'RwModificationPharoTonelFormatV1WriterVisitorV2'

category: 'actions'
method: RwModificationPharoTonelFormatV1WriterVisitorV2
addedPackage: aPackageModification
	| packageProperties exportedPackageProperties |
	currentPackageDefinition := aPackageModification after.

	packageProperties := currentPackageDefinition properties.
	exportedPackageProperties := self class orderedDictionaryClass new.
	exportedPackageProperties at: #'name' put: (packageProperties at: 'name') asSymbol.
	(packageProperties at: 'comment' ifAbsent: [  ])
		ifNotNil: [ :comment | exportedPackageProperties at: #'comment' put: comment ].
	(packageProperties keys
		reject: [ :key | key = 'name' or: [ key = 'gs_SymbolDictionary' ] ]) asArray
		sort
		do: [ :key | exportedPackageProperties at: key asSymbol put: (packageProperties at: key) ].

	self _packageSourceDir ensureCreateDirectory.
	self _packageSourceDir / 'package.st'
		writeStreamDo: [ :aStream | 
			aStream << 'Package ' << (self _toSTON: exportedPackageProperties)
				<< self _newLine ].

	self processPackage: aPackageModification
%

category: 'class writing'
method: RwModificationPharoTonelFormatV1WriterVisitorV2
_methodDefinitionOf: aMethodDefinition
	| excludedMethodProperties methodProperties exportedProperties |
	excludedMethodProperties := #('_gsFileOffset' '_gsFileName' 'category' 'protocol' 'selector').
	exportedProperties := self class orderedDictionaryClass new
		at: #'category' put: aMethodDefinition protocol asSymbol;
		yourself.
	methodProperties := aMethodDefinition properties.
	(methodProperties keys
		reject: [ :each | excludedMethodProperties includes: each ]) asArray sort
		do: [ :key | exportedProperties at: key asSymbol put: (methodProperties at: key) asSymbol].
	^ self _toSTON: exportedProperties
%

category: 'private'
method: RwModificationPharoTonelFormatV1WriterVisitorV2
_toSTON: anObject
	^ (String streamContents: [ :stream | 
		(PharoTonelV1STONWriter on: stream) nextPut: anObject ])
		withLineEndings: self _newLine
%

category: 'class writing'
method: RwModificationPharoTonelFormatV1WriterVisitorV2
_typeClassDefinitionOf: aClassDefinition
	| definition |
	
	definition := self class orderedDictionaryClass new 
		at: #name put: aClassDefinition name asSymbol; 
		at: #superclass put: aClassDefinition superclassName asSymbol;
		yourself.

	aClassDefinition classType = 'normal' ifFalse: [ 
		definition at: #type put: aClassDefinition classType asSymbol ].
	
	(aClassDefinition instVarNames)
		ifNotEmpty: [ :vars | definition at: #instVars put: (vars asArray collect: [:each | each asSymbol]) ].

	(aClassDefinition classVarNames)
		ifNotEmpty: [ :vars | definition at: #classVars put: (vars asArray collect: [:each | each asSymbol]) ].
		
	((aClassDefinition poolDictionaryNames) collect: [:each | each asString])
		ifNotEmpty: [ :vars | definition at: #pools put: vars asArray ].
		
	(aClassDefinition classInstVarNames)
		ifNotEmpty: [ :vars | definition at: #classInstVars put: (vars asArray collect: [:each | each asSymbol])].

	(aClassDefinition gs_constraints)
		ifNotEmpty: [:gs_constraints | definition at: #'gs_constraints' put: gs_constraints asArray ].

	(aClassDefinition gs_options)
		ifNotEmpty: [:gs_options | definition at: #'gs_options' put: gs_options asArray ].

	(aClassDefinition gs_reservedOop)
		ifNotEmpty: [:gs_reservedOop | definition at: #'gs_reservedoop' put: gs_reservedOop asString ].

	definition 		
		at: #category put: aClassDefinition category asSymbol.
	
	^ self _toSTON: definition
%

category: 'class extension writing'
method: RwModificationPharoTonelFormatV1WriterVisitorV2
_writeClassExtension: aClassExtension on: aStream

	aStream << 'Extension '
				<< (self _toSTON: {(#'name' -> aClassExtension name)} asDictionary) << self _newLine.
%

! Class implementation for 'RwRepositoryComponentProjectReaderVisitor'

!		Instance methods for 'RwRepositoryComponentProjectReaderVisitor'

category: 'class reading'
method: RwRepositoryComponentProjectReaderVisitor
compileWhileReading
  ^ (self dynamicInstVarAt: #compileWhileReading) ifNil:[ false ]
%

category: 'class reading'
method: RwRepositoryComponentProjectReaderVisitor
compileWhileReading: aBoolean
  self dynamicInstVarAt: #compileWhileReading put: aBoolean 
%

category: 'tonel parser'
method: RwRepositoryComponentProjectReaderVisitor
newClassDefinitionFrom: anArray
	| metadata |
	metadata := anArray sixth.
	currentClassExtension := nil.
	currentClassDefinition := RwClassDefinition
		newForClassNamed: (metadata at: #'name') asString
		super:
			(metadata at: #'superclass' ifAbsent: [ metadata at: #'super' ]) asString
		instvars: (metadata at: #'instvars' ifAbsent: [ #() ])
		classinstvars: (metadata at: #'classinstvars' ifAbsent: [ #() ])
		classvars: (metadata at: #'classvars' ifAbsent: [ #() ])
		category: (metadata at: #'category' ifAbsent: [  ])
		comment: (anArray second )
		pools: (metadata at: #'pools' ifAbsent: [ #() ])
		type: (metadata at: #'type' ifAbsent: [ #'normal' ]) asSymbol.
	^ currentClassDefinition
		gs_options: (metadata at: #'gs_options' ifAbsent: [ #() ]);
		gs_reservedOop: (metadata at: #'gs_reservedoop' ifAbsent: [ '' ]);
		gs_constraints: (metadata at: #'gs_constraints' ifAbsent: [ #() ]);
		shebang: (metadata at: #'shebang' ifAbsent: [  ]);
		yourself
%

category: 'tonel parser'
method: RwRepositoryComponentProjectReaderVisitor
newClassExtensionDefinitionFrom: anArray
	| className |
	className := ((anArray sixth) at: #name) asString.
	currentClassDefinition := nil.
	^currentClassExtension := currentPackageDefinition
		classExtensionDefinitionNamed: className 
		ifAbsent: [ currentPackageDefinition addClassExtensionNamed: className ].
%

category: 'package reading'
method: RwRepositoryComponentProjectReaderVisitor
packageExtension

	^ self subclassResponsibility: #packageExtension
%

category: 'accessing'
method: RwRepositoryComponentProjectReaderVisitor
packageNames

	^ packageNames
%

category: 'accessing'
method: RwRepositoryComponentProjectReaderVisitor
packageNames: anArray

	packageNames := anArray
%

category: 'accessing'
method: RwRepositoryComponentProjectReaderVisitor
packageNamesBlock
	^ packageNamesBlock
		ifNil: [ [ :packageName | self packageNames includes: packageName ] ]
%

category: 'accessing'
method: RwRepositoryComponentProjectReaderVisitor
packageNamesBlock: object
	packageNamesBlock := object
%

category: 'class reading'
method: RwRepositoryComponentProjectReaderVisitor
readClassesFor: packageName packageRoot: packageRoot

	^ self subclassResponsibility: #readClassesFor:packageRoot:
%

category: 'package reading'
method: RwRepositoryComponentProjectReaderVisitor
readPackages: packagesRoot
	| trace |
	trace := Rowan projectTools trace.
	packagesRoot directories
		do: [ :packageDir | 
			(self _packageNameFromPackageDir: packageDir ifAbsent: [  ])
				ifNil: [ 
					trace
						trace:
							'--- skip reading ' , packageDir printString
								, ' not a tonel package directory (missing or malformed package.st file' ]
				ifNotNil: [ :packageName | 
					trace
						trace:
							'--- reading package ' , packageName asString , ' dir ' , packageDir asString.
					packageDir extension = self packageExtension
						ifFalse: [ trace trace: '      skipped readClasses, extension does not match' ]
						ifTrue: [ 
							(self packageNamesBlock value: packageName)
								ifTrue: [ self readClassesFor: packageName packageRoot: packageDir ]
								ifFalse: [ trace trace: '      skipped readClasses, packageName rejected' ] ] ] ]
%

category: 'public'
method: RwRepositoryComponentProjectReaderVisitor
visit: anObject

	anObject acceptVisitor: self.
%

category: 'visiting'
method: RwRepositoryComponentProjectReaderVisitor
visitComponentProjectDefinition: aRwComponentProjectDefinition

	self currentProjectDefinition: aRwComponentProjectDefinition.
	aRwComponentProjectDefinition packages: Dictionary new.
	self visit: aRwComponentProjectDefinition projectRef
%

category: 'visiting'
method: RwRepositoryComponentProjectReaderVisitor
visitResolvedProjectV2: aRwResolvedProjectV2

	self currentProjectDefinition: aRwResolvedProjectV2.
	aRwResolvedProjectV2 _projectDefinition packages: Dictionary new.
	self readPackages: aRwResolvedProjectV2 packagesRoot
%

category: 'package reading'
method: RwRepositoryComponentProjectReaderVisitor
_packageNameFromPackageDir: packageDir ifAbsent: absentBlock

	"this is not really correct, but it works as a fallback (filetree does not have independent package name)"

	^ packageDir basenameWithoutExtension
%

! Class implementation for 'RwRepositoryResolvedProjectFiletreeReaderVisitorV2'

!		Class methods for 'RwRepositoryResolvedProjectFiletreeReaderVisitorV2'

category: 'class directory reading'
classmethod: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
readClassDirectories: directoryArray

	^ self readClassDirectories: directoryArray  projectName: '___READ_CLASS_Project___' packageName: '___READ_CLASS_Package___'
%

category: 'class directory reading'
classmethod: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
readClassDirectories: directoryArray projectName: projectName packageName: packageName
	| visitor resolvedProject packageDefinition |
	resolvedProject := RwResolvedProjectV2 new
		projectName: projectName;
		packageConvention: 'Rowan';
		gemstoneSetDefaultSymbolDictNameTo: 'Globals';
		yourself.

	resolvedProject
		addNewComponentNamed: 'Core'
		comment: 'Temporary project to hold class definitions read from disk'.

	1 to: directoryArray size do: [ :index | 
		| directory |
		directory := directoryArray at: index.
		packageDefinition := resolvedProject
			addPackageNamed: packageName , '_' , index asString
			toComponentNamed: 'Core'.
		visitor := self new
			currentProjectDefinition: resolvedProject;
			currentPackageDefinition: packageDefinition;
			_packageConvention: 'Rowan';
			yourself.
		visitor readClassDirectory: directory inPackage: packageDefinition name ].
	^ resolvedProject
%

category: 'class directory reading'
classmethod: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
readClassDirectory: directory

	^ self readClassDirectories: {directory}
%

category: 'class directory reading'
classmethod: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
readClassDirectory: directory projectName: projectName packageName: packageName

	^ self readClassDirectories: {directory} projectName: projectName packageName: packageName
%

!		Instance methods for 'RwRepositoryResolvedProjectFiletreeReaderVisitorV2'

category: 'accessing'
method: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
packageExtension

	^ packageExtension 
		ifNil: [ 
			| ext |
			ext := (self _filetreeRepositoryPropertyDictFor: currentProjectDefinition packagesRoot) at: 'packageExtension'.
			packageExtension := ext copyFrom: 2 to: ext size ]
%

category: 'class reading'
method: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
readClassDirectory: classDirectory inPackage: packageName

	| classDirectoryReference classProperties classComment normalizedMetadata classDef |
	classDirectoryReference := classDirectory asFileReference.
	classProperties :=  self _readObjectFrom: classDirectoryReference / 'properties' , 'json'.
	classComment := (classDirectoryReference / 'README' , 'md') contents.
	normalizedMetadata := Dictionary new.
	classProperties keysAndValuesDo: [:key :value |
		normalizedMetadata at: key asLowercase asSymbol put: value ].
	classDef :=	self newClassDefinitionFrom: {
		nil.
		classComment isEmpty ifTrue: [ nil ] ifFalse: [ classComment ]. 
		nil. 
		normalizedMetadata at: 'type' ifAbsent: ['normal']. 
		nil. 
		normalizedMetadata
	}.
	self validateClassCategory: classDef forPackageNamed: packageName.
	(currentProjectDefinition packageNamed: packageName)
		addClassDefinition: currentClassDefinition.

	self readMethodDirectories: classDirectoryReference forClassDefinition: classDef inPackage: packageName
%

category: 'class reading'
method: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
readClassesFor: packageName packageRoot: packageRoot

	currentPackageDefinition := currentProjectDefinition 
		packageNamed: packageName 
		ifAbsent: [ currentProjectDefinition addRawPackageNamed: packageName ].
	packageRoot directories do: [:directory |
		| directoryExtension |
		directoryExtension := directory extension.
		directoryExtension = 'class'
			ifTrue: [ self readClassDirectory: directory inPackage: packageName ]
			ifFalse: [
				directoryExtension = 'extension'
					ifTrue: [ self readClassExtensionDirectory: directory  inPackage: packageName ] ] ]
%

category: 'class reading'
method: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
readClassExtensionDirectory: classExtensionDirectory inPackage: packageName

	| classExtensionProperties className package |
	classExtensionProperties :=  self _readObjectFrom: classExtensionDirectory / 'properties' , 'json'.
	className := classExtensionProperties at: 'name'.
	package := currentProjectDefinition packageNamed: packageName.
	currentClassDefinition := nil.
	currentClassExtension := package 
		classExtensionDefinitionNamed: className 
		ifAbsent: [ package addClassExtensionNamed: className ].

	self readMethodDirectories: classExtensionDirectory forClassDefinition: currentClassExtension inPackage: packageName
%

category: 'method reading'
method: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
readMethodDirectories: classDirectory forClassDefinition: classDefinition inPackage: packageName

	(self readMethodDirectory: classDirectory / 'instance' forClassDefinition: classDefinition isClassMeta: false inPackage: packageName) do: [:methodDefinition |
		classDefinition addInstanceMethodDefinition: methodDefinition ].
	(self readMethodDirectory: classDirectory / 'class' forClassDefinition: classDefinition isClassMeta: true inPackage: packageName) do: [:methodDefinition |
		classDefinition addClassMethodDefinition: methodDefinition ]
%

category: 'method reading'
method: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
readMethodDirectory: methodDirectory forClassDefinition: classDefinition isClassMeta: isClassMeta inPackage: packageName

	| methodDefinitions methodDefinitionStream |
	methodDefinitions := {}.
	methodDirectory exists ifFalse: [ ^ methodDefinitions ].

	methodDefinitionStream := methodDefinitions writeStreamPortable.
	methodDirectory files do: [:file |
		file extension = 'st'
			ifTrue: [ 
				| protocol methodSource methodStream methodDef offset |
				methodStream := file contents  readStreamPortable.
				protocol := methodStream nextLine.
        offset := methodStream position .
				methodSource := methodStream upToEnd.
				methodDef := RwMethodDefinition newForSource: methodSource protocol: protocol.
        methodDef offset: offset inFile: file pathString .
				self 
					validateMethodDefinitionProtocol: methodDef 
						className: classDefinition name
						isMeta: isClassMeta 
						forPackageNamed:  packageName.
				methodDefinitionStream nextPut: methodDef ] ].

	^ methodDefinitions
%

category: 'other'
method: RwRepositoryResolvedProjectFiletreeReaderVisitorV2
_filetreeRepositoryPropertyDictFor: aPackagesRoot

	^ self _readObjectFrom: aPackagesRoot / '.filetree'
%

! Class implementation for 'RwRepositoryResolvedProjectTonelReaderVisitorV2'

!		Class methods for 'RwRepositoryResolvedProjectTonelReaderVisitorV2'

category: 'class file reading'
classmethod: RwRepositoryResolvedProjectTonelReaderVisitorV2
lineNumberStringForMethod: anRwMethodDefinition
  "used when handling STONReaderError,  TonelParseError, CompileError, CompileWarning"
	(anRwMethodDefinition propertyAt:'_gsFileOffset' ifAbsent: nil) ifNotNil:[:offset |
		 (anRwMethodDefinition propertyAt:'_gsFileName' ifAbsent: nil) ifNotNil:[:fName | 
			 ^ self lineNumberStringForOffset: offset fileName: fName
			] 
	].
  ^ '  (Unable to determine line )' .
%

category: 'class file reading'
classmethod: RwRepositoryResolvedProjectTonelReaderVisitorV2
lineNumberStringForOffset: offset fileName: fName
  | res |
  res :='  (Unable to determine line number)' .
  [ | fRef |
    fRef := fName asFileReference .
    fRef readStreamDo:[ :fStream |  | buf lf lNum |
      buf := fStream contents .
      buf size > offset ifTrue:[ buf size: offset ].
      lNum := 1 + (buf occurrencesOf: (lf := Character lf)) .
      res := '', lf , ' near line ' , lNum asString , lf , ' in file ', fName .
    ]
  ] on: Error do:[:ex | "ignore" ].
  ^ res
%

category: 'class file reading'
classmethod: RwRepositoryResolvedProjectTonelReaderVisitorV2
readClassFile: file

	^ self readClassFiles: { file }
%

category: 'class file reading'
classmethod: RwRepositoryResolvedProjectTonelReaderVisitorV2
readClassFile: file projectName: projectName packageName: packageName

	^ self readClassFiles: { file } projectName: projectName packageName: packageName
%

category: 'class file reading'
classmethod: RwRepositoryResolvedProjectTonelReaderVisitorV2
readClassFiles: fileArray

	^ self readClassFiles: fileArray projectName: '___READ_CLASS_Project___' packageName: '___READ_CLASS_Package___'
%

category: 'class file reading'
classmethod: RwRepositoryResolvedProjectTonelReaderVisitorV2
readClassFiles: fileArray projectName: projectName packageName: packageName
	| visitor resolvedProject packageDefinition |
	resolvedProject := RwResolvedProjectV2 new
		projectName: projectName;
		packageConvention: 'Rowan';
		gemstoneSetDefaultSymbolDictNameTo: 'Globals';
		yourself.
	resolvedProject
		addNewComponentNamed: 'Core'
		comment: 'Temporary project to hold class definitions read from disk'.
	1 to: fileArray size do: [ :index | 
		| file |
		file := fileArray at: index.
		packageDefinition := resolvedProject
			addPackageNamed: packageName , '_' , index asString
			toComponentNamed: 'Core'.
		visitor := self new
			currentProjectDefinition: resolvedProject;
			currentPackageDefinition: packageDefinition;
			_packageConvention: 'Rowan';
			yourself.
		visitor readClassFile: file inPackage: packageDefinition name ].
	^ resolvedProject
%

!		Instance methods for 'RwRepositoryResolvedProjectTonelReaderVisitorV2'

category: 'class reading'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
checkMethodDefinitions: aClassDef
  | cls clsName methBlk fakeMethDict pkgName |

  self compileWhileReading ifFalse:[ ^ self "do nothing"  ].

  clsName := aClassDef  name asSymbol .
  (pkgName := currentPackageDefinition name) = 'Filein1C' ifTrue:[ 
     "lookup in GemStone_Legacy_Streams first"
     cls := GemStone_Legacy_Streams at: clsName otherwise: nil.
  ].
  cls ifNil:[   
    (cls := System myUserProfile resolveSymbol: clsName ) ifNil:[
       "creating the class not implemented yet"
       Warning signal:'class ' , clsName , ' not found by name lookup'.
       ^ self "can't check syntax on the methods until class is defined"
    ].
  ].
  cls := cls"anAssociation" value.
  methBlk := [ :methDef "a RwMethodDefinition" |
    [
      cls compileMethod: methDef source
      dictionaries: System myUserProfile symbolList
      category: methDef protocol asSymbol
      intoMethodDict: fakeMethDict
      intoCategories: nil
      environmentId:  0
    ] on: ( CompileError , CompileWarning ) do:[:ex | 
      ex addText: (RwRepositoryResolvedProjectTonelReaderVisitorV2 lineNumberStringForMethod: methDef ).
      ex pass
    ]
  ].
  fakeMethDict := GsMethodDictionary new .
  aClassDef instanceMethodDefinitions do: methBlk .
  cls := cls class .
  fakeMethDict := GsMethodDictionary new .
  aClassDef classMethodDefinitions do: methBlk .
%

category: 'class reading'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
classExtensionFileExtensions

	^ #( 'extension' 'st' )
%

category: 'class reading'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
classFileExtensions

	^ #( 'class' 'st' )
%

category: 'tonel parser'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
definitionForType: aString
  aString = self class tonelClassLabel
    ifTrue: [ ^ #class ].
  aString = self class tonelExtensionLabel
    ifTrue: [ ^ #classExtension ].
  RwTonelParseError signal: 'Unknown type declaration.'
%

category: 'tonel parser'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
newMethodDefinitionForClassNamed: className classIsMeta: meta selector: selector category: protocol source: source

	| methodDef |
	methodDef := RwMethodDefinition
		newForSelector: selector 
			protocol: protocol 
			source: source.
	self 
		validateMethodDefinitionProtocol: methodDef 
			className: className
			isMeta: meta
			forPackageNamed: self currentPackageDefinition name.
	^ methodDef
%

category: 'tonel parser'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
newTypeDefinitionFrom: anArray
  | typeClass |
  typeClass := self definitionForType: anArray fourth.
  typeClass == #class
    ifTrue: [ ^  self newClassDefinitionFrom: anArray ].
  typeClass == #classExtension
	ifTrue: [ ^ self newClassExtensionDefinitionFrom: anArray ].
  ^ self error: 'unexpected typeClass: ', typeClass printString
%

category: 'package reading'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
packageExtension

	^ ''
%

category: 'class reading'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
readClassesFor: packageName packageRoot: packageRoot
	| classFileExtensions classExtensionFileExtensions trace |
	trace := Rowan projectTools trace.
	currentPackageDefinition := currentProjectDefinition
		packageNamed: packageName
		ifAbsent: [ currentProjectDefinition addRawPackageNamed: packageName ].
	classExtensionFileExtensions := self classExtensionFileExtensions.
	classFileExtensions := self classFileExtensions.
	packageRoot files
		do: [ :file | 
			| fileExtensions |
			trace trace: '--- reading class ' , file asString.
			fileExtensions := file extensions asArray.
			fileExtensions = classFileExtensions
				ifTrue: [ self readClassFile: file inPackage: packageName ]
				ifFalse: [ 
					fileExtensions = classExtensionFileExtensions
						ifTrue: [ self readClassExtensionFile: file inPackage: packageName ] ] ]
%

category: 'class reading'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
readClassExtensionFile: file inPackage: packageName

	| fileReference |
	fileReference := file asFileReference.
	fileReference readStreamDo: [:fileStream | | stream |
		[ | definitions |
		  stream := ZnBufferedReadStream on: fileStream. "wrap with buffered stream to bypass https://github.com/GemTalk/FileSystemGs/issues/9"
		  stream sizeBuffer: fileReference size. "part of workaround for GemTalk/FileSystemGs#9"
		  definitions := (RwTonelParser on: stream forReader: self) start.
		  ((definitions at: 2) at: 1) do: [:mDef |
			  currentClassExtension addClassMethodDefinition: mDef ].
		  ((definitions at: 2) at: 2) do: [:mDef |
			  currentClassExtension addInstanceMethodDefinition: mDef ] .
      self checkMethodDefinitions: currentClassExtension .
    ] on: ( STONReaderError , RwTonelParseError) do:[:ex |
      ex addText: (self class lineNumberStringForOffset: stream position fileName: fileReference fullName).
      ex pass .
    ].
  ].
%

category: 'class reading'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
readClassFile: file inPackage: packageName
	| fileReference |
	fileReference := file asFileReference.
	fileReference
		readStreamDo: [ :fileStream | 
			| stream |
			[ 
			| definitions clsDef projectDef |
			"wrap with buffered stream to bypass https://github.com/GemTalk/FileSystemGs/issues/9"
			stream := ZnBufferedReadStream on: fileStream.
			stream sizeBuffer: fileReference size.	"part of workaround for GemTalk/FileSystemGs#9"
			definitions := (RwTonelParser on: stream forReader: self) start.
			clsDef := currentClassDefinition
				ifNotNil: [ :def | 
					currentClassExtension
						ifNotNil: [ Error signal: 'both a class definition and extension in file ' , file name ].
					def ]
				ifNil: [ currentClassExtension ].
			self validateClassCategory: clsDef forPackageNamed: packageName.
			((definitions at: 2) at: 1)
				do: [ :mDef | clsDef addClassMethodDefinition: mDef ].
			((definitions at: 2) at: 2)
				do: [ :mDef | clsDef addInstanceMethodDefinition: mDef ].
			self checkMethodDefinitions: clsDef.
			projectDef := currentProjectDefinition packageNamed: packageName.
			currentClassDefinition ifNotNil: [ projectDef addClassDefinition: clsDef ]	"ifNil:[ projectDef addClassExtensionDefinition: clsDef]." ]
				on: STONReaderError , RwTonelParseError
				do: [ :ex | 
					ex
						addText:
							(self class
								lineNumberStringForOffset: stream position
								fileName: fileReference fullName).
					ex pass ] ]
%

category: 'package reading'
method: RwRepositoryResolvedProjectTonelReaderVisitorV2
_packageNameFromPackageDir: packageDir ifAbsent: absentBlock
	"package.st file is REQUIRED for the to be a legal tonel package directory"

	| tonelPackageFile |
	tonelPackageFile := packageDir / 'package' , 'st'.
	tonelPackageFile exists
		ifFalse: [ ^ absentBlock value ].
	^ ((self _readObjectFrom: tonelPackageFile)
		at: #'name'
		ifAbsent: [ ^ absentBlock value ]) asString
%

! Class implementation for 'RwAbstractResolvedObjectV2'

!		Class methods for 'RwAbstractResolvedObjectV2'

category: 'instance creation'
classmethod: RwAbstractResolvedObjectV2
new

	^ self basicNew initialize
%

!		Instance methods for 'RwAbstractResolvedObjectV2'

category: 'accessing'
method: RwAbstractResolvedObjectV2
addSimpleComponentNamed: aComponentName condition: condition comment: commentString
	self subclassResponsibility: #'addSimpleComponentNamed:condition:comment:'
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
comment
	^ self subclassResponsibility: #'comment'
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
comment: aString
	^ self subclassResponsibility: #'comment:'
%

category: 'project specification'
method: RwAbstractResolvedObjectV2
componentNames
	^ self _loadSpecification componentNames
%

category: 'project specification'
method: RwAbstractResolvedObjectV2
componentNames: anArray
	self _loadSpecification componentNames: anArray
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
componentsRoot
	^ self repositoryRoot / self _projectSpecification componentsPath
%

category: 'exporting'
method: RwAbstractResolvedObjectV2
exportLoadSpecification
	self _loadSpecification exportTo: self specsRoot
%

category: 'exporting'
method: RwAbstractResolvedObjectV2
exportProjectSpecification
	self _projectSpecification exportTo: self repositoryRoot
%

category: 'package properties'
method: RwAbstractResolvedObjectV2
gemstoneSetSymbolDictName: symbolDictName forPackageNamed: packageName
	self subclassResponsibility: #'gemstoneSetSymbolDictName:forPackageNamed:'
%

category: 'package properties'
method: RwAbstractResolvedObjectV2
gemstoneSymbolDictNameForPackageNamed: packageName
	self subclassResponsibility: #'gemstoneSymbolDictNameForPackageNamed:'
%

category: 'project specification'
method: RwAbstractResolvedObjectV2
groupNames: anArray
	self _loadSpecification groupNames: anArray
%

category: 'initialization'
method: RwAbstractResolvedObjectV2
initialize
	"repository must be explicitly created"

	projectSpecification := RwProjectSpecificationV2 new.
	loadSpecification := RwLoadSpecificationV2 new.
%

category: 'testing'
method: RwAbstractResolvedObjectV2
isStrict
	^ self _loadSpecification isStrict
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
packagesRoot
	^ self repositoryRoot / self _projectSpecification packagesPath
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
platformConditionalAttributes

	^ self _loadSpecification customConditionalAttributes
%

category: 'copying'
method: RwAbstractResolvedObjectV2
postCopy
	super postCopy.
	projectRepository := projectRepository copy.
	loadSpecification := loadSpecification copy.
	projectSpecification := projectSpecification copy
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectAlias
	^ self _loadSpecification projectAlias ifNil: [ self projectName ]
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectAlias: aString
	self _loadSpecification projectAlias: aString
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectName
	projectSpecification
		ifNil: [ 
			loadSpecification ifNil: [ ^ self _projectDefinition projectName ].
			^ self _loadSpecification projectName ].
	^ self _projectSpecification projectName
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectName: aString
	self _loadSpecification projectName: aString.
	self _projectSpecification projectName: aString
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectRoots
	^ {(self componentsRoot).
	(self packagesRoot).
	(self specsRoot).
	(self projectsRoot)}
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectsHome
	^ self _loadSpecification projectsHome
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectsHome: aProjectHomeReferenceOrString
	self _loadSpecification projectsHome: aProjectHomeReferenceOrString
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectSpecFile
	"relative path to the project specification file - default: rowan/project.ston"

	^ self _loadSpecification projectSpecFile
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectSpecFile: relativePathString
	"relative path to the project specification file - default: rowan/project.ston"

	| path |
	path := Path from: relativePathString .
	self _projectSpecification projectSpecPath: path parent pathString.
	self _projectSpecification specName: path base.
	self _loadSpecification projectSpecFile: relativePathString
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectSpecPath: aString
	"full path to the project specification file - default rowan/project.ston"

	self _projectSpecification projectSpecPath: aString.
	self _loadSpecification
		projectSpecFile:
			((Path from: aString) / self _projectSpecification specName , 'ston') pathString
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
projectsRoot
	^ self repositoryRoot / self _projectSpecification projectsPath
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
repositoryRoot
	^ self _projectRepository repositoryRoot
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
repositoryRoot: aFileReferenceOrString
	^ self _projectRepository repositoryRoot: aFileReferenceOrString
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
requiredProjectRoots

	^ {(self componentsRoot).
	(self packagesRoot).
	(self specsRoot).
	(self projectsRoot)}
%

category: 'accessing'
method: RwAbstractResolvedObjectV2
specsRoot
	^ self repositoryRoot / self _projectSpecification specsPath
%

category: 'private'
method: RwAbstractResolvedObjectV2
_gemstoneAllUsersName
	^ self _loadSpecification _gemstoneAllUsersName
%

category: 'private'
method: RwAbstractResolvedObjectV2
_loadSpecification
	"load specification should not be accessed directly -- Rowan private state"

	^ loadSpecification
%

category: 'private'
method: RwAbstractResolvedObjectV2
_loadSpecification: object
	"load specification should not be accessed directly -- Rowan private state"

	loadSpecification := object
%

category: 'private'
method: RwAbstractResolvedObjectV2
_projectRepository
	self subclassResponsibility: #'_projectRepository'
%

category: 'private'
method: RwAbstractResolvedObjectV2
_projectRepository: object
	"project repository should not be accessed directly -- Rowan private state"

	projectRepository := object
%

category: 'private'
method: RwAbstractResolvedObjectV2
_projectSpecification
	"project specification should not be accessed directly -- Rowan private state"

	"lazy initialization, since project specification must be read from disk during resolve
		if it is present on disk"

	^ projectSpecification
		ifNil: [ 
			| projectSpecFileRef pName |
			projectSpecFileRef := self repositoryRoot / self projectSpecFile.
			pName := self projectName.	"projectSpecification is involved in default logic for projectName"
			projectSpecification := projectSpecFileRef exists
				ifTrue: [ RwSpecification fromFile: projectSpecFileRef ]
				ifFalse: [ 
					Rowan projectTools trace trace: '--- creating new project spec. The project spec file ', projectSpecFileRef pathString printString, ' does not exist'.
					RwProjectSpecificationV2 new ].
			projectSpecification
				projectName: pName;
				yourself ]
%

category: 'private'
method: RwAbstractResolvedObjectV2
_projectSpecification: object
	"project specification should not be accessed directly -- Rowan private state"

	projectSpecification := object
%

category: 'private'
method: RwAbstractResolvedObjectV2
_validate
	"ensure that the receiver's specifications contain valid information ... 
		the specs must be able to stand on their own, when they are written to disk, so there is a 
		responsiblity for them to have valid data"

	^ self _validate: self platformConditionalAttributes
%

category: 'private'
method: RwAbstractResolvedObjectV2
_validate: platformConfigurationAttributes
	"ensure that the receiver's specifications contain valid information ... 
		the specs must be able to stand on their, when they are written to disk, so there is a 
		responsiblity for them to have valid data"

	self _projectSpecification _validate.
	self _loadSpecification _validate.
	^ true
%

! Class implementation for 'RwAbstractResolvedProjectV2'

!		Instance methods for 'RwAbstractResolvedProjectV2'

category: 'testing'
method: RwAbstractResolvedProjectV2
canCommit
	^ self _projectRepository canCommit
%

category: 'project definition'
method: RwAbstractResolvedProjectV2
commit: message
	"commit the repository associated with receiver ..."

	self _projectRepository canCommit
		ifFalse: [ 
			| msg |
			msg := 'repository for project ' , self projectName printString
				, ' does not support commit operations.'.
			self inform: msg.
			^ msg ].
	^ self _projectRepository doCommit: message
%

category: 'accessing'
method: RwAbstractResolvedProjectV2
customConditionalAttributes
	"get the custom conditional attributes"

	^ self _loadSpecification customConditionalAttributes
%

category: 'accessing'
method: RwAbstractResolvedProjectV2
customConditionalAttributes: anArray
	"set the custom conditional attributes"

	^ self _loadSpecification customConditionalAttributes: anArray
%

category: 'accessing'
method: RwAbstractResolvedProjectV2
loadSpecification
	^ RwResolvedLoadSpecificationV2 new
		_projectDefinition: projectDefinition;
		_projectRepository: projectRepository;
		_loadSpecification: loadSpecification;
		_projectSpecification: projectSpecification;
		_projectStructure: projectStructure;
		yourself
%

category: 'accessing'
method: RwAbstractResolvedProjectV2
packageConvention
	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	^ self _projectSpecification packageConvention
%

category: 'accessing'
method: RwAbstractResolvedProjectV2
packageConvention: aString
	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	self _projectSpecification packageConvention: aString
%

category: 'accessing'
method: RwAbstractResolvedProjectV2
platformConditionalAttributes
	^ self projectDefinitionPlatformConditionalAttributes
		ifNil: [ super platformConditionalAttributes , Rowan platformConditionalAttributes ]
%

category: 'copying'
method: RwAbstractResolvedProjectV2
postCopy
	super postCopy.
	projectDefinition := projectDefinition copy.
	projectStructure := projectStructure copy
%

category: 'accessing'
method: RwAbstractResolvedProjectV2
projectDefinition
	^ RwResolvedProjectV2 new
		_projectDefinition: projectDefinition;
		_projectRepository: projectRepository;
		_loadSpecification: loadSpecification;
		_projectSpecification: projectSpecification;
		_projectStructure: projectStructure;
		yourself
%

category: 'accessing'
method: RwAbstractResolvedProjectV2
projectSpecification
	^ RwResolvedProjectSpecificationV2 new
		_projectDefinition: projectDefinition;
		_projectRepository: projectRepository;
		_loadSpecification: loadSpecification;
		_projectSpecification: projectSpecification;
		_projectStructure: projectStructure;
		yourself
%

category: 'accessing'
method: RwAbstractResolvedProjectV2
repository
	^ RwResolvedRepositoryV2 new
		_projectDefinition: projectDefinition;
		_projectRepository: projectRepository;
		_loadSpecification: loadSpecification;
		_projectSpecification: projectSpecification;
		_projectStructure: projectStructure;
		yourself
%

category: 'testing'
method: RwAbstractResolvedProjectV2
repositoryExists
	^ self _projectRepository repositoryExists
%

category: 'private'
method: RwAbstractResolvedProjectV2
_projectDefinition
	"project definition should not be accessed directly -- Rowan private state"

	^ projectDefinition
%

category: 'private'
method: RwAbstractResolvedProjectV2
_projectDefinition: object
	"project definition should not be accessed directly -- Rowan private state"

	projectDefinition := object
%

category: 'private'
method: RwAbstractResolvedProjectV2
_projectRepository
	^ projectRepository
		ifNil: [ 
			projectRepository := self gitUrl
				ifNotNil: [ :urlString | 
					RwGitRepositoryDefinitionV2
						newNamed: self projectAlias
						projectsHome: self projectsHome
						repositoryUrl: urlString
						revision: self _loadSpecification revision ]
				ifNil: [ 
					self _loadSpecification svnUrl
						ifNotNil: [ :urlString | Error signal: 'Svn repositories not supported, yet' ]
						ifNil: [ 
							self _loadSpecification mercurialUrl
								ifNotNil: [ :urlString | Error signal: 'Mercurial repositories not supported, yet' ]
								ifNil: [ 
									self _loadSpecification diskUrl
										ifNotNil: [ :urlString | 
											RwDiskRepositoryDefinitionV2
												newNamed: self projectAlias
												projectsHome: self projectsHome
												repositoryUrl: urlString ]
										ifNil: [ 
											self _loadSpecification readonlyDiskUrl
												ifNotNil: [ :urlString | 
													RwReadOnlyDiskRepositoryDefinitionV2
														newNamed: self projectAlias
														projectsHome: self projectsHome
														repositoryUrl: urlString ]
												ifNil: [ 
													"without an explicit repository url in the load specificaction, we have 
												to fall back to using the repoType in the project specification. If the 
												logic that follows fails, then a git or disk url should be explicitly specified
												in the load spec before resolving."
													projectSpecification
														ifNil: [ 
															"without a project specification, we are probably in the process 
														of being created by resolving a load specification If we were
														created from from scratch, the project specification is 
														initialized!"
															self _loadSpecification repositoryRoot exists
																ifTrue: [ 
																	| gitHome gitTool repositoryRootPath |
																	"since the repository root does exist, we will attach as a 
																disk project or git project, depending upon whether or git is present
																and the git home is equal to the repositoryRoot"
																	gitTool := Rowan projectTools git.
																	repositoryRootPath := self _loadSpecification repositoryRoot
																		pathString.
																	^ projectRepository := ((gitTool
																		gitPresentIn: repositoryRootPath)
																		and: [ 
																			(gitHome := (gitTool gitrevparseShowTopLevelIn: repositoryRootPath) trimBoth)
																				asFileReference = self _loadSpecification repositoryRoot ])
																		ifTrue: [ 
																			RwGitRepositoryDefinitionV2
																				newNamed: self projectAlias
																				projectsHome: self projectsHome
																				repositoryUrl: ''
																				revision: self _loadSpecification revision ]
																		ifFalse: [ 
																			RwDiskRepositoryDefinitionV2
																				newNamed: self projectAlias
																				projectsHome: self projectsHome
																				repositoryUrl: self diskUrl ] ] ].
													projectSpecification
														ifNil: [ 
															RwNoRepositoryDefinitionV2
																newNamed: self projectAlias
																projectsHome: nil
																repositoryUrl: nil ]
														ifNotNil: [ 
															self _projectSpecification repoType == #'git'
																ifTrue: [ 
																	RwGitRepositoryDefinitionV2
																		newNamed: self projectAlias
																		projectsHome: self projectsHome
																		repositoryUrl: ''
																		revision: self _loadSpecification revision ]
																ifFalse: [ 
																	self _projectSpecification repoType == #'disk'
																		ifTrue: [ 
																			RwDiskRepositoryDefinitionV2
																				newNamed: self projectAlias
																				projectsHome: self projectsHome
																				repositoryUrl: self diskUrl ]
																		ifFalse: [ 
																			"#none"
																			RwNoRepositoryDefinitionV2
																				newNamed: self projectAlias
																				projectsHome: nil
																				repositoryUrl: nil ] ] ] ] ] ] ] ].
			projectRepository ]
%

category: 'private'
method: RwAbstractResolvedProjectV2
_projectStructure
	"project structure should not be accessed directly -- Rowan private state"

	^ projectStructure
%

category: 'private'
method: RwAbstractResolvedProjectV2
_projectStructure: object
	"project structure should not be accessed directly -- Rowan private state"

	projectStructure := object
%

category: 'private'
method: RwAbstractResolvedProjectV2
_validate: platformConfigurationAttributes
	"ensure that the receiver's specifications contain valid information ... 
		the specs must be able to stand on their, when they are written to disk, so there is a 
		responsiblity for them to have valid data"

	super _validate: platformConfigurationAttributes.
	self _projectDefinition _validate: platformConfigurationAttributes.
	^ true
%

! Class implementation for 'RwResolvedLoadSpecificationV2'

!		Instance methods for 'RwResolvedLoadSpecificationV2'

category: 'accessing'
method: RwResolvedLoadSpecificationV2
comment
	^ self _loadSpecification comment
%

category: 'accessing'
method: RwResolvedLoadSpecificationV2
comment: aString
	self _loadSpecification comment: aString
%

category: 'accessing'
method: RwResolvedLoadSpecificationV2
componentNames
	"list of components to be loaded"

	^ self _loadSpecification componentNames
%

category: 'accessing'
method: RwResolvedLoadSpecificationV2
componentNames: anArray
	"list of components to be loaded"

	self _loadSpecification componentNames: anArray
%

category: 'actions'
method: RwResolvedLoadSpecificationV2
export
	self specsRoot ensureCreateDirectory.
	self exportLoadSpecification
%

category: 'printing'
method: RwResolvedLoadSpecificationV2
printOn: aStream
	super printOn: aStream.
	loadSpecification
		ifNotNil: [ 
			aStream
				nextPutAll: ' for ';
				nextPutAll: self _loadSpecification specName ]
%

category: 'accessing'
method: RwResolvedLoadSpecificationV2
revision
	^ self _loadSpecification revision
%

category: 'accessing'
method: RwResolvedLoadSpecificationV2
revision: aString
	self _loadSpecification revision: aString
%

category: 'accessing'
method: RwResolvedLoadSpecificationV2
specName
	^ self _loadSpecification specName
%

category: 'accessing'
method: RwResolvedLoadSpecificationV2
specName: aString
	self _loadSpecification specName: aString
%

! Class implementation for 'RwResolvedProjectSpecificationV2'

!		Instance methods for 'RwResolvedProjectSpecificationV2'

category: 'accessubg'
method: RwResolvedProjectSpecificationV2
componentsPath
	^self _projectSpecification componentsPath
%

category: 'accessubg'
method: RwResolvedProjectSpecificationV2
componentsPath: aString
	self _projectSpecification componentsPath: aString
%

category: 'actions'
method: RwResolvedProjectSpecificationV2
export
	self exportProjectSpecification
%

category: 'accessubg'
method: RwResolvedProjectSpecificationV2
packagesPath
	^self _projectSpecification packagesPath
%

category: 'accessubg'
method: RwResolvedProjectSpecificationV2
packagesPath: aString
	self _projectSpecification packagesPath: aString
%

category: 'printing'
method: RwResolvedProjectSpecificationV2
printOn: aStream
	super printOn: aStream.
	projectSpecification
		ifNotNil: [ 
			aStream
				nextPutAll: ' for ';
				nextPutAll: self _projectSpecification specName ]
%

category: 'accessubg'
method: RwResolvedProjectSpecificationV2
projectsPath
	^self _projectSpecification projectsPath
%

category: 'accessubg'
method: RwResolvedProjectSpecificationV2
projectsPath: aString
	self _projectSpecification projectsPath: aString
%

category: 'accessubg'
method: RwResolvedProjectSpecificationV2
specsPath
	^self _projectSpecification specsPath
%

category: 'accessubg'
method: RwResolvedProjectSpecificationV2
specsPath: aString
	self _projectSpecification specsPath: aString
%

! Class implementation for 'RwResolvedProjectV2'

!		Class methods for 'RwResolvedProjectV2'

category: 'instance creation'
classmethod: RwResolvedProjectV2
basicLoadSpecification: anRwLoadSpecificationV2
	"resolve ensures that the project directory already exists on disk (cloned for git projects) or created on disk for new projects
		answer  the project definition specified by the receiver and any dependent projects"

	"if the project directory already exists on disk, then read the project definition(s) from disk"

	| loadSpecification projectDefinition |
	loadSpecification := anRwLoadSpecificationV2 copy.
	projectDefinition := RwProjectDefinitionV2 basicNew
		properties:
				(Dictionary new
						add: 'name' -> loadSpecification projectName;
						yourself);
		packages: Dictionary new;
		components: RwResolvedLoadComponentsV2 new;
		projectDefinitionSourceProperty: RwLoadedProject _projectModifiedProjectSourceValue;
		yourself.
	^ self basicNew
		_projectDefinition: projectDefinition;
		_loadSpecification: loadSpecification;
		yourself
%

category: 'instance creation'
classmethod: RwResolvedProjectV2
loadSpecification: anRwLoadSpecificationV2
	"resolve ensures that the project directory already exists on disk (cloned for git projects) or created on disk for new projects
		answer  the project definition specified by the receiver and any dependent projects"

	"if the project directory already exists on disk, then read the project definition(s) from disk"

	^(self basicLoadSpecification: anRwLoadSpecificationV2)
		resolve
%

category: 'instance creation'
classmethod: RwResolvedProjectV2
loadSpecification: anRwLoadSpecificationV2 platformAttributes: platformAttributes
	"resolve ensures that the project directory already exists on disk (cloned for git projects) or created on disk for new projects
		answer  the project definition specified by the receiver and any dependent projects"

	"if the project directory already exists on disk, then read the project definition(s) from disk"

	^ (self basicLoadSpecification: anRwLoadSpecificationV2)
		resolve: platformAttributes
%

category: 'instance creation'
classmethod: RwResolvedProjectV2
loadSpecificationProjectSet: anRwLoadSpecificationV2
	"resolve ensures that the project directory already exists on disk (cloned for git projects) or created on disk for new projects
		answer  the project definition specified by the receiver and any dependent projects"

	"if the project directory already exists on disk, then read the project definition(s) from disk"

	^(self basicLoadSpecification: anRwLoadSpecificationV2)
		resolveProjectSet
%

category: 'instance creation'
classmethod: RwResolvedProjectV2
loadSpecificationProjectSet: anRwLoadSpecificationV2 platformAttributes: platformAttributes
	"resolve ensures that the project directory already exists on disk (cloned for git projects) or created on disk for new projects
		answer  the project definition specified by the receiver and any dependent projects"

	"if the project directory already exists on disk, then read the project definition(s) from disk"

	^ (self basicLoadSpecification: anRwLoadSpecificationV2)
		resolveProjectSet: platformAttributes
%

!		Instance methods for 'RwResolvedProjectV2'

category: 'visiting'
method: RwResolvedProjectV2
acceptVisitor: aVisitor
	^ aVisitor visitResolvedProjectV2: self
%

category: 'project definition'
method: RwResolvedProjectV2
addComponentNamed: componentName toComponentNamed: toComponentName
	^ self _projectDefinition
		addComponentNamed: componentName
		toComponentNamed: toComponentName
%

category: 'project definition'
method: RwResolvedProjectV2
addComponentStructureFor: componentBasename pathNameArray: pathNameArray conditionPathArray: conditionPathArray comment: aString
	^ self _projectDefinition
		addComponentStructureFor: componentBasename
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: aString
%

category: 'project definition'
method: RwResolvedProjectV2
addComponentStructureFor: componentBasename startingAtComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray comment: aString
	^ self _projectDefinition
		addComponentStructureFor: componentBasename
		startingAtComponentNamed: toComponentName
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: aString
%

category: 'project definition'
method: RwResolvedProjectV2
addNewComponentNamed: componentName
	^ self _projectDefinition addNewComponentNamed: componentName
%

category: 'project definition'
method: RwResolvedProjectV2
addNewComponentNamed: aComponentName comment: aString
	^ self _projectDefinition addNewComponentNamed: aComponentName comment: aString
%

category: 'project definition'
method: RwResolvedProjectV2
addNewComponentNamed: aComponentName condition: condition
	^ self _projectDefinition addNewComponentNamed: aComponentName condition: condition
%

category: 'project definition'
method: RwResolvedProjectV2
addNewComponentNamed: aComponentName condition: condition comment: aString
	^ self _projectDefinition addNewComponentNamed: aComponentName condition: condition comment: aString
%

category: 'project definition'
method: RwResolvedProjectV2
addNewComponentNamed: componentName toComponentNamed: toComponentName condition: conditionPathArray
	^ self
		addNewComponentNamed: componentName
		toComponentNamed: toComponentName
		condition: conditionPathArray
		comment: ''
%

category: 'project definition'
method: RwResolvedProjectV2
addNewComponentNamed: componentName toComponentNamed: toComponentName condition: conditionPathArray comment: aString
	^ self _projectDefinition
		addNewComponentNamed: componentName
		toComponentNamed: toComponentName
		condition: conditionPathArray
		comment: aString
%

category: 'project definition'
method: RwResolvedProjectV2
addNewNestedComponentNamed: aComponentName comment: aString
	^ self _projectDefinition
		addNewNestedComponentNamed: aComponentName
		comment: aString
%

category: 'project definition'
method: RwResolvedProjectV2
addPackageNamed: packageName
	"the package is expected to already be present in a component - used when reading packages from disk"

	^ self _projectDefinition addPackageNamed: packageName
%

category: 'project definition'
method: RwResolvedProjectV2
addPackageNamed: packageName toComponentNamed: componentName
	^ self _projectDefinition
		addPackageNamed: packageName
		toComponentNamed: componentName
%

category: 'project definition'
method: RwResolvedProjectV2
addPackageNamed: packageName toComponentNamed: componentName gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc
	^ self _projectDefinition
		addPackageNamed: packageName
		toComponentNamed: componentName
		gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc
%

category: 'project definition'
method: RwResolvedProjectV2
addPackagesNamed: packageNames toComponentNamed: componentName 
	^ self _projectDefinition
		addPackagesNamed: packageNames
		toComponentNamed: componentName
%

category: 'project definition'
method: RwResolvedProjectV2
addPlatformComponentNamed: aComponentName toComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray
	^ self
		addPlatformComponentNamed: aComponentName
		toComponentNamed: toComponentName
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: ''
%

category: 'project definition'
method: RwResolvedProjectV2
addPlatformComponentNamed: aComponentName toComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray comment: aString
	^ self _projectDefinition
		addPlatformComponentNamed: aComponentName
		toComponentNamed: toComponentName
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: aString
%

category: 'project definition'
method: RwResolvedProjectV2
addPlatformNestedComponentNamed: aComponentName condition: conditionArray comment: commentString
	^ self _projectDefinition
		addPlatformNestedComponentNamed: aComponentName
		condition: conditionArray
		comment: commentString
%

category: 'accessing'
method: RwResolvedProjectV2
addPostloadDoitName: doitName withSource: doitSource toComponentNamed: aComponentName
	| component |
	component := self componentNamed: aComponentName.
	component postloadDoitName: doitName.
	component doitDict at: doitName put: doitSource
%

category: 'accessing'
method: RwResolvedProjectV2
addPreloadDoitName: doitName withSource: doitSource toComponentNamed: aComponentName
	| component |
	component := self componentNamed: aComponentName.
	component preloadDoitName: doitName.
	component doitDict at: doitName put: doitSource
%

category: 'project definition'
method: RwResolvedProjectV2
addProjectNamed:projectName toComponentNamed: componentName 
	^ self _projectDefinition
		addProjectNamed:projectName
		toComponentNamed: componentName
%

category: 'project definition'
method: RwResolvedProjectV2
addRawPackageNamed: packageName
	"not sure I like how this is used ... the component structure needs to be kept in sync with packages, so this is not quite the route to go, unless we ensure that the component has an entry for the package"

	"see similar comment in addPackages:forComponent: and _addComponent"

	^ self _projectDefinition addRawPackageNamed: packageName
%

category: 'project definition'
method: RwResolvedProjectV2
addSimpleComponentNamed: aComponentName comment: commentString
	^ self _projectDefinition
		addSimpleComponentNamed: aComponentName
		condition: 'common'
		comment: commentString
%

category: 'project definition'
method: RwResolvedProjectV2
addSimpleComponentNamed: aComponentName condition: condition comment: commentString
	^ self _projectDefinition
		addSimpleComponentNamed: aComponentName
		condition: condition
		comment: commentString
%

category: 'project definition'
method: RwResolvedProjectV2
addSimpleNestedComponentNamed: aComponentName condition: condition  comment: commentString
	^ self _projectDefinition
		addSimpleNestedComponentNamed: aComponentName
		condition: condition
		comment: commentString
%

category: 'project definition'
method: RwResolvedProjectV2
addTopLevelComponentNamed: componentName
	self _loadSpecification addTopLevelComponentNamed: componentName.
	^ self _projectDefinition addNewComponentNamed: componentName
%

category: 'project definition'
method: RwResolvedProjectV2
addTopLevelComponentNamed: componentName condition: condition
	self _loadSpecification addTopLevelComponentNamed: componentName.
	^ self _projectDefinition
		addNewComponentNamed: componentName
		condition: condition
%

category: 'actions'
method: RwResolvedProjectV2
checkout: aCommittish
	^ self _projectRepository checkout: aCommittish
%

category: 'project definition'
method: RwResolvedProjectV2
comment
	^ self _projectDefinition comment
%

category: 'project definition'
method: RwResolvedProjectV2
comment: aString
	self _projectDefinition comment: aString
%

category: 'querying'
method: RwResolvedProjectV2
commitId
	^ self _projectRepository commitId
%

category: 'querying'
method: RwResolvedProjectV2
commitLog: logLimit
	^ self _projectRepository commitLog: logLimit
%

category: 'accessing'
method: RwResolvedProjectV2
compileWhileReading
	"true means compile method defs while reading tonel files for immediate detection of syntax errors"

	^ (self dynamicInstVarAt: #'compileWhileReading') ifNil: [ false ]
%

category: 'accessing'
method: RwResolvedProjectV2
compileWhileReading: aBoolean
	"true means compile method defs while reading tonel files for immediate detection of syntax errors"

	self dynamicInstVarAt: #'compileWhileReading' put: aBoolean
%

category: 'querying'
method: RwResolvedProjectV2
componentForPackageNamed: packageName
	"Answer nil if no component found"

	^ self _projectDefinition componentForPackageNamed: packageName
%

category: 'project definition'
method: RwResolvedProjectV2
componentNamed: aComponentName
	^ self _projectDefinition componentNamed: aComponentName
%

category: 'project definition'
method: RwResolvedProjectV2
componentNamed: aComponentName ifAbsent: absentBlock
	^ self _projectDefinition componentNamed: aComponentName ifAbsent: absentBlock
%

category: 'project definition'
method: RwResolvedProjectV2
components
	^ self _projectDefinition components
%

category: 'accessing'
method: RwResolvedProjectV2
componentsWithDoits
	^ self _projectDefinition components componentsWithDoits
%

category: 'copying'
method: RwResolvedProjectV2
copyForLoadedProject
	"project definition is not part of the copy for loaded projects"

	^ RwResolvedProjectV2 new
		_projectRepository: projectRepository copy;
		_loadSpecification: loadSpecification copy;
		_projectSpecification: projectSpecification copy;
		_projectStructure: projectDefinition components copy;
		yourself
%

category: '-- loader compat --'
method: RwResolvedProjectV2
diskRepositoryRoot: repositoryRootPathString
	projectRepository := self _projectRepository
		diskRepositoryRoot: repositoryRootPathString
%

category: 'load specification'
method: RwResolvedProjectV2
diskUrl
	^ self _loadSpecification diskUrl
%

category: 'load specification'
method: RwResolvedProjectV2
diskUrl: anUrlString
	self _loadSpecification diskUrl: anUrlString
%

category: 'actions'
method: RwResolvedProjectV2
export
	Rowan projectTools writeV2 writeResolvedProject: self
%

category: 'exporting'
method: RwResolvedProjectV2
exportComponents
	self components export: self componentsRoot
%

category: 'exporting'
method: RwResolvedProjectV2
exportPackages
	| projectSetDefinition |
	projectSetDefinition := [ 
	RwProjectSetDefinition new
		addProject: self copy read;
		yourself ]
		on: Error
		do: [ :ignored | RwProjectSetDefinition new ].
	self
		exportPackages: projectSetDefinition
		packagesRoot: self packagesRoot
		packageFormat: self packageFormat
		packageConvention: self packageConvention
%

category: 'exporting'
method: RwResolvedProjectV2
exportPackages: diskProjectSetDefinition packagesRoot: packagesRoot packageFormat: packageFormat packageConvention: packageConvention
	| projectSetDefinition visitor projectSetModification writerVisitorClass |
	packagesRoot / 'properties' , 'st'
		writeStreamDo: [ :fileStream | 
			fileStream
				nextPutAll: '{ ';
				lf;
				tab;
				nextPutAll: '#format : ' , packageFormat printString , ',';
				lf;
				tab;
				nextPutAll: '#convention : ' , packageConvention printString;
				lf;
				nextPutAll: '}';
				lf ].	"write out packages"
	writerVisitorClass := packageFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitorV2 ]
		ifFalse: [ RwModificationFiletreeWriterVisitorV2 ].
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: self.
	projectSetModification := projectSetDefinition
		compareAgainstBase: diskProjectSetDefinition.
	visitor := writerVisitorClass new
		packagesRoot: packagesRoot;
		yourself.

	visitor visit: projectSetModification
%

category: 'exporting'
method: RwResolvedProjectV2
exportProjects
	self projectNames do: [ :projectName | self error: 'not yet implemented' ].
	self projectNames isEmpty
		ifTrue: [ 
			"add README.md as placeholder to ensure that the directory is preserved by git"
			self projectsRoot / 'README' , 'md' writeStreamDo: [ :fileStream |  ] ]
%

category: 'exporting'
method: RwResolvedProjectV2
exportProjectSpecification
	self _projectSpecification exportTo: self repositoryRoot
%

category: 'exporting'
method: RwResolvedProjectV2
exportTopazFormatTo: filePath logClassCreation: logClassCreation excludeClassInitializers: excludeClassInitializers excludeRemoveAllMethods: excludeRemoveAllMethods
	| projectSetDefinition projectSetModification visitor fileReference |
	fileReference := filePath asFileReference.
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: self.
	projectSetModification := projectSetDefinition
		compareAgainstBase: RwProjectSetDefinition new.
	visitor := RwGsModificationTopazWriterVisitorV2 new
		logCreation: logClassCreation;
		excludeClassInitializers: excludeClassInitializers;
		excludeRemoveAllMethods: excludeRemoveAllMethods;
		repositoryRootPath: fileReference parent;
		topazFilename: fileReference base;
		filenameExtension: fileReference extension;
		yourself.
	visitor visit: projectSetModification
%

category: 'exporting'
method: RwResolvedProjectV2
exportTopazFormatTo: filePath logClassCreation: logClassCreation excludeClassInitializers: excludeClassInitializers excludeRemoveAllMethods: excludeRemoveAllMethods usingPackageNamesMap: packageNamesMap
	| projectSetDefinition projectSetModification visitor fileReference |
	fileReference := filePath asFileReference.
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: self.
	projectSetModification := projectSetDefinition
		compareAgainstBase: RwProjectSetDefinition new.
	visitor := RwGsModificationTopazWriterVisitorV2 new
		logCreation: logClassCreation;
		excludeClassInitializers: excludeClassInitializers;
		excludeRemoveAllMethods: excludeRemoveAllMethods;
		repositoryRootPath: fileReference parent;
		topazFilename: fileReference base;
		topazFilenamePackageNamesMap: packageNamesMap;
		yourself.
	visitor visit: projectSetModification
%

category: '-- loader compat --'
method: RwResolvedProjectV2
gitRepositoryRoot: repositoryRootPathString
	projectRepository := self _projectRepository
		gitRepositoryRoot: repositoryRootPathString
		revision: self _loadSpecification revision
%

category: 'load specification'
method: RwResolvedProjectV2
gitUrl
	^ self _loadSpecification gitUrl
%

category: 'load specification'
method: RwResolvedProjectV2
gitUrl: anUrlString
	self _loadSpecification gitUrl: anUrlString
%

category: 'initialization'
method: RwResolvedProjectV2
initialize
	"repository must be explicitly created"

	super initialize.
	projectDefinition := RwProjectDefinitionV2 new
%

category: 'project definition'
method: RwResolvedProjectV2
isEmpty
	^ self _projectDefinition isEmpty
%

category: 'project definition'
method: RwResolvedProjectV2
key
	^ self projectName
%

category: 'actions'
method: RwResolvedProjectV2
load
	"
		load only the receiver into the image. Required projects for the receiver are only loaded if they are not already 
			present in the image.

		To explicitly load the receiver AND required projects, construct a project set containing projects to be loaded 
			and send #load to the project set.
	"

	self _validate: self platformConditionalAttributes.
	^ Rowan projectTools loadV2 loadProjectDefinition: self projectDefinition
%

category: 'actions'
method: RwResolvedProjectV2
load: instanceMigrator
	"
		load only the receiver into the image, using the specified instance migrator. Required projects for the receiver are only 
			loaded if they are not already present in the image.
	"

	self _validate: self platformConditionalAttributes.
	^ Rowan projectTools loadV2
		loadProjectDefinition: self
		instanceMigrator: instanceMigrator
%

category: 'project definition'
method: RwResolvedProjectV2
loadedCommitId
	^ self _projectSpecification loadedCommitId
%

category: 'actions'
method: RwResolvedProjectV2
loadProjectSet
	"
		refresh the contents of the receiver from disk and create a project set that includes project definitions of
			required projects, also read from disk. Then load the entire project set.
	"

	self _validate: self platformConditionalAttributes.
	^ Rowan projectTools loadV2
		loadProjectSetDefinition:
			(self readProjectSet: self platformConditionalAttributes)
%

category: 'actions'
method: RwResolvedProjectV2
loadProjectSet: platformConditionalAttributes
	"
		refresh the contents of the receiver from disk and create a project set that includes project definitions of
			required projects, also read from disk. Then load the entire project set.

		Use the specified platform conditional attributes when reading the receiver from disk.
	"

	self _validate: self platformConditionalAttributes.
	^ Rowan projectTools loadV2
		loadProjectSetDefinition: (self readProjectSet: platformConditionalAttributes)
%

category: 'actions'
method: RwResolvedProjectV2
loadProjectSet: platformConditionalAttributes instanceMigrator: instanceMigrator
	"
		refresh the contents of the receiver from disk and create a project set that includes project definitions of
			required projects, also read from disk. Then load the entire project set, using the specified 
			instance migrator.

		Use the specified platform conditional attributes when reading the receiver from disk.

		Use the instanceMigrator to handle new versions of any classes that may result from the load.
	"

	self _validate: self platformConditionalAttributes.
	^ Rowan projectTools loadV2
		loadProjectSetDefinition: (self readProjectSet: platformConditionalAttributes)
		instanceMigrator: instanceMigrator
%

category: 'project definition'
method: RwResolvedProjectV2
moveClassNamed: aClassName toPackageNamed: aPackageName
	| thePackage |
	thePackage := self
		packageNamed: aPackageName
		ifAbsent: [ self error: 'No package found name ' , aPackageName printString ].
	(self packageForClassNamed: aClassName)
		ifNil: [ self error: 'No class definition found for ' , aClassName printString ]
		ifNotNil: [ :package | 
			| classDef |
			classDef := package removeClassNamed: aClassName.
			classDef
				moveToPackageNamed: aPackageName
				packageConvention: self packageConvention.
			thePackage addClassDefinition: classDef ]
%

category: 'project definition'
method: RwResolvedProjectV2
movePackageNamed: aPackageName toComponentNamed: aComponentName
	^ self _projectDefinition
		movePackageNamed: aPackageName
		toComponentNamed: aComponentName
%

category: 'project definition'
method: RwResolvedProjectV2
movePackageNamed: aPackageName toComponentNamed: aComponentName asPackageName: newPackageName
	^ self _projectDefinition
		movePackageNamed: aPackageName
		toComponentNamed: aComponentName
		asPackageName: newPackageName
%

category: '-- loader compat --'
method: RwResolvedProjectV2
name
	"sender in loader code that's shared between RwComponentProjectDefinition and RwResolvedProjectV2, 
		should use projectAlias, but need to wait until we're no longer using RwComponentProjectDefinition"

	^ self projectName
%

category: 'querying'
method: RwResolvedProjectV2
packageForClassNamed: className
	"Answer nil if no class found"

	^ self _projectDefinition packageForClassNamed: className
%

category: 'project definition'
method: RwResolvedProjectV2
packageFormat
	^ self _projectSpecification packageFormat
%

category: 'project definition'
method: RwResolvedProjectV2
packageFormat: aString
	^ self _projectSpecification packageFormat: aString
%

category: 'project definition'
method: RwResolvedProjectV2
packageFormatIfAbsent: absentBlock
	^ self _projectSpecification packageFormatIfAbsent: absentBlock
%

category: 'project definition'
method: RwResolvedProjectV2
packageNamed: aString
	^ self _projectDefinition packageNamed: aString
%

category: 'project definition'
method: RwResolvedProjectV2
packageNamed: aString ifAbsent: absentBlock

	^ self _projectDefinition packageNamed: aString ifAbsent: absentBlock
%

category: 'project definition'
method: RwResolvedProjectV2
packageNames
	^ self _projectDefinition packageNames
%

category: 'project definition'
method: RwResolvedProjectV2
packages
	^ self _projectDefinition packages
%

category: 'project definition'
method: RwResolvedProjectV2
packages: aPackageDictionary
	^ self _projectDefinition packages: aPackageDictionary
%

category: 'printing'
method: RwResolvedProjectV2
printOn: aStream
	super printOn: aStream.
	projectDefinition
		ifNotNil: [ 
			aStream
				nextPutAll: ' for ';
				nextPutAll: self _projectDefinition projectName ]
%

category: 'project definition'
method: RwResolvedProjectV2
projectDefinitionPlatformConditionalAttributes
	^ self _projectDefinition projectDefinitionPlatformConditionalAttributes
%

category: 'project definition'
method: RwResolvedProjectV2
projectDefinitionPlatformConditionalAttributes: platformConditionalAttributes
	self _projectDefinition projectDefinitionPlatformConditionalAttributes: platformConditionalAttributes
%

category: 'project definition'
method: RwResolvedProjectV2
projectDefinitionSourceProperty
	^ self _projectDefinition projectDefinitionSourceProperty
%

category: 'project definition'
method: RwResolvedProjectV2
projectDefinitionSourceProperty: sourceKeyOrNil
	self _projectDefinition projectDefinitionSourceProperty: sourceKeyOrNil
%

category: 'accessing'
method: RwResolvedProjectV2
projectName: aString
	super projectName: aString.
	self _projectDefinition projectName: aString
%

category: 'accessing'
method: RwResolvedProjectV2
projectNames
	"not yet implemented"

	^ #()
%

category: 'project definition'
method: RwResolvedProjectV2
projectUrl
	^ self _loadSpecification projectUrl
%

category: 'actions'
method: RwResolvedProjectV2
read
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return the receiver with a new set of definitions read from disk"

	self repositoryExists
		ifTrue: [ ^ self readProjectComponentNames: self componentNames ]
%

category: 'actions'
method: RwResolvedProjectV2
read: platformConditionalAttributes
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return the receiver with a new set of definitions read from disk"

	^ self
		readProjectComponentNames: self componentNames
		platformConditionalAttributes: platformConditionalAttributes
%

category: '-- loader compat --'
method: RwResolvedProjectV2
readOnlyRepositoryRoot: repositoryRootPathString commitId: commitId
	projectRepository := self _projectRepository
		readOnlyRepositoryRoot: repositoryRootPathString
		commitId: commitId.

	(self loadedCommitId ifNil: [ true ] ifNotNil: [ :aString | aString isEmpty ])
		ifTrue: [ self _projectSpecification loadedCommitId: commitId ]
%

category: 'project definition'
method: RwResolvedProjectV2
readPackageNames: packageNames
	| format visitorClass |
	format := self
		packageFormatIfAbsent: [ 
			| formatFromDisk |
			formatFromDisk := (RwAbstractReaderWriterVisitor
				_repositoryPropertyDictFor: self packagesRoot)
				at: #'format'
				ifAbsent: [ 'tonel' ].
			self packageFormat: formatFromDisk.
			formatFromDisk ].
	self _projectDefinition packages: Dictionary new.
	visitorClass := format = 'tonel'
		ifTrue: [ RwRepositoryResolvedProjectTonelReaderVisitorV2 ]
		ifFalse: [ RwRepositoryResolvedProjectFiletreeReaderVisitorV2 ].
	^ visitorClass new
		compileWhileReading: self compileWhileReading;
		packageNames: packageNames;
		visit: self
%

category: 'project definition'
method: RwResolvedProjectV2
readPackageNamesBlock: packageNamesBlock
	| format visitorClass |
	format := self
		packageFormatIfAbsent: [ 
			| formatFromDisk |
			formatFromDisk := (RwAbstractReaderWriterVisitor
				_repositoryPropertyDictFor: self packagesRoot)
				at: #'format'
				ifAbsent: [ 'tonel' ].
			self packageFormat: formatFromDisk.
			formatFromDisk ].
	self _projectDefinition packages: Dictionary new.
	visitorClass := format = 'tonel'
		ifTrue: [ RwRepositoryResolvedProjectTonelReaderVisitorV2 ]
		ifFalse: [ RwRepositoryResolvedProjectFiletreeReaderVisitorV2 ].
	^ visitorClass new
		compileWhileReading: self compileWhileReading;
		packageNamesBlock: packageNamesBlock;
		visit: self
%

category: 'actions'
method: RwResolvedProjectV2
readProjectComponentNames: componentNames
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return the receiver with a new set of definitions read from disk"

	^ self
		readProjectComponentNames: componentNames
		platformConditionalAttributes: self platformConditionalAttributes
%

category: 'actions'
method: RwResolvedProjectV2
readProjectComponentNames: componentNames customConditionalAttributes: customConditionalAttributes
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return the receiver with a new set of definitions read from disk"

	self componentNames: componentNames.	"record the list of component names used to create this instance of the project definition"
	self _loadSpecification
		customConditionalAttributes: customConditionalAttributes.	"record customConditionalAttributes in load spec"
	self projectDefinitionPlatformConditionalAttributes: nil.	"reset project platformConditionalAttributes"
	^ Rowan projectTools readV2
		readProjectForResolvedProject: self
		withComponentNames: componentNames
		platformConditionalAttributes:
			(self platformConditionalAttributes , customConditionalAttributes) asSet asArray
%

category: 'actions'
method: RwResolvedProjectV2
readProjectComponentNames: componentNames platformConditionalAttributes: platformConditionalAttributes
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return the receiver with a new set of definitions read from disk"

	self componentNames: componentNames. "record the list of component names used to create this instance of the project definition"
	^ Rowan projectTools readV2
		readProjectForResolvedProject: self
		withComponentNames: componentNames
		platformConditionalAttributes: platformConditionalAttributes
%

category: 'actions'
method: RwResolvedProjectV2
readProjectSet
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return a project definition set that will contain the project definition along with any dependent project definitions"

	^ self readProjectSetComponentNames: self componentNames
%

category: 'actions'
method: RwResolvedProjectV2
readProjectSet: platformConditionalAttributes
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return a project definition set that will contain the project definition along with any dependent project definitions"

	^ self
		readProjectSetComponentNames: self componentNames
		platformConditionalAttributes: platformConditionalAttributes
%

category: 'actions'
method: RwResolvedProjectV2
readProjectSetComponentNames: componentNames
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return a project definition set that will contain the project definition along with any dependent project definitions"

	^ self
		readProjectSetComponentNames: componentNames
		platformConditionalAttributes: self platformConditionalAttributes
%

category: 'actions'
method: RwResolvedProjectV2
readProjectSetComponentNames: componentNames platformConditionalAttributes: platformConditionalAttributes
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the current load specification"

	"return a project definition set that will contain the project definition along with any dependent project definitions"

	^ Rowan projectTools readV2
		readProjectSetForResolvedProject: self
		withComponentNames: componentNames
		platformConditionalAttributes: platformConditionalAttributes
%

category: 'project definition'
method: RwResolvedProjectV2
removeComponentNamed: aComponentName
	^ self _projectDefinition removeComponentNamed: aComponentName
%

category: 'project definition'
method: RwResolvedProjectV2
removePackageNamed: packageName
	(self componentForPackageNamed: packageName) removePackageNamed: packageName.
	^ self _projectDefinition removePackageNamed: packageName
%

category: 'project definition'
method: RwResolvedProjectV2
removePackageNamed: packageName fromComponentNamed: componentName
	^ self _projectDefinition
		removePackageNamed: packageName
		fromComponentNamed: componentName
%

category: 'project definition'
method: RwResolvedProjectV2
removeProjectNamed: aProjectName
	^ self _projectDefinition removeProjectNamed: aProjectName
%

category: 'project definition'
method: RwResolvedProjectV2
renameComponentNamed: aComponentPath to: aComponentName
	^ self _projectDefinition
		renameComponentNamed: aComponentPath
		to: aComponentName
%

category: 'project definition'
method: RwResolvedProjectV2
renamePackageNamed: packageName to: newPackageName
	| thePackageDef theComponent |
	theComponent := self componentForPackageNamed: packageName.
	thePackageDef := self removePackageNamed: packageName.
	thePackageDef
		renameTo: newPackageName
		packageConvention: self packageConvention.
	self _projectDefinition _addPackage: thePackageDef.
	self _projectDefinition
		movePackageNamed: packageName
		toComponentNamed: theComponent name
		asPackageName: newPackageName.
	^ thePackageDef
%

category: '-- loader compat --'
method: RwResolvedProjectV2
repositoryCommitId
	^ self _projectRepository commitId
%

category: 'project specification'
method: RwResolvedProjectV2
repoType: aSymbol
	"#disk, #git or #none"

	self _projectSpecification repoType: aSymbol
%

category: 'accessing'
method: RwResolvedProjectV2
requiredProjectNames
	^ self requiredProjectNames: self platformConditionalAttributes
%

category: 'accessing'
method: RwResolvedProjectV2
requiredProjectNames: platformConditionalAttributes
	| requiredProjectNames |
	requiredProjectNames := Set new.
	self components
		conditionalComponentsStartingWith: self componentNames
		platformConditionalAttributes: platformConditionalAttributes
		do: [ :aComponent | requiredProjectNames addAll: aComponent projectNames ].
	^ requiredProjectNames
%

category: 'actions'
method: RwResolvedProjectV2
resolve
	"resolve the projectSpecation (clone remote repo or connect to existing repo on disk) and read 
		project from disk, if project is present on disk"

	self _projectRepository resolve
		ifTrue: [ 
			self _projectRepository checkAndUpdateRepositoryRevision: self.
			self _checkProjectDirectoryStructure
				ifTrue: [ 
					"update project definition from disk"
					self read.
					self
						projectDefinitionSourceProperty:
							RwLoadedProject _projectLoadedDefinitionSourceWithDependentProjectsValue ] ]
%

category: 'actions'
method: RwResolvedProjectV2
resolve: platformConfigurationAttributes
	"resolve the projectSpecation (clone remote repo or connect to existing repo on disk) and read 
		project from disk, if project is present on disk"

	self _projectRepository resolve
		ifTrue: [ 
			self _projectRepository checkAndUpdateRepositoryRevision: self.
			self _checkProjectDirectoryStructure
				ifTrue: [ 
					"update project definition from disk"
					self read: platformConfigurationAttributes ] ]
%

category: 'actions'
method: RwResolvedProjectV2
resolveProjectSet
	"resolve the loadSpecation (clone remote repo or connect to existing repo on disk) and read 
		project set from disk, if project is present on disk (project set will include required projects)"

	self _projectRepository resolve
		ifTrue: [ 
			self _projectRepository checkAndUpdateRepositoryRevision: self.
			self _checkProjectDirectoryStructure
				ifTrue: [ 
					"read project and required projects from disk"
					^ self readProjectSet ] ].
	^ RwProjectSetDefinition new
		addProject: self;
		yourself
%

category: 'actions'
method: RwResolvedProjectV2
resolveProjectSet: platformConfigurationAttributes
	"resolve the loadsSpecation (clone remote repo or connect to existing repo on disk) and read 
		project set from disk, if project is present on disk (includes required projects)t"

	self _projectRepository resolve
		ifTrue: [ 
			self _projectRepository checkAndUpdateRepositoryRevision: self.
			self _checkProjectDirectoryStructure
				ifTrue: [ 
					"update project definition from disk"
					^ self readProjectSet: platformConfigurationAttributes ] ].
	^ RwProjectSetDefinition new
		addProject: self;
		yourself
%

category: 'load specification'
method: RwResolvedProjectV2
revision
	^ self _loadSpecification revision
%

category: 'load specification'
method: RwResolvedProjectV2
revision: aRevisionString
	^ self _loadSpecification revision: aRevisionString
%

category: '-- loader compat --'
method: RwResolvedProjectV2
symbolDictNameForPackageNamed: aPackageName
	"sender in loader code that's shared between RwComponentProjectDefinition and RwResolvedProjectV2, 
		should use gemstoneSymbolDictNameForPackageNamed:, but need to wait until we're no longer 
		using RwComponentProjectDefinition"

	^ self gemstoneSymbolDictNameForPackageNamed: aPackageName
%

category: 'project definition'
method: RwResolvedProjectV2
updateLoadedCommitId
	self _projectSpecification loadedCommitId: self _projectRepository commitId
%

category: 'testing'
method: RwResolvedProjectV2
useGit
	^ self _projectRepository useGit
%

category: 'private'
method: RwResolvedProjectV2
_checkProjectDirectoryStructure
	"answer true if the basic project directory structure is present"

	self requiredProjectRoots
		do: [ :fileRef | 
			fileRef exists
				ifFalse: [ ^ false ] ].
	^ true
%

category: 'private'
method: RwResolvedProjectV2
_loadTool

	^ self _projectDefinition _loadTool
%

! Class implementation for 'RwResolvedRepositoryV2'

!		Instance methods for 'RwResolvedRepositoryV2'

category: 'repository'
method: RwResolvedRepositoryV2
branches
	^ self _projectRepository branches
%

category: 'repository'
method: RwResolvedRepositoryV2
checkout: aCommittish
	^ self _projectRepository checkout: aCommittish
%

category: 'repository'
method: RwResolvedRepositoryV2
commitId
	^ self _projectRepository commitId
%

category: 'repository'
method: RwResolvedRepositoryV2
createBranch: branchName
	^ self _projectRepository createBranch: branchName
%

category: 'repository'
method: RwResolvedRepositoryV2
fetch
	^ self _projectRepository fetch
%

category: 'printing'
method: RwResolvedRepositoryV2
printOn: aStream
	super printOn: aStream.
	projectRepository
		ifNotNil: [ 
			aStream
				nextPutAll: ' for ';
				nextPutAll: self _projectRepository name ]
%

category: 'repository'
method: RwResolvedRepositoryV2
pull: remoteName branch: branchName
	^ self _projectRepository pull: remoteName branch: branchName
%

category: 'repository'
method: RwResolvedRepositoryV2
push: remoteName branch: branchName
	^ self _projectRepository push: remoteName branch: branchName
%

category: 'repository'
method: RwResolvedRepositoryV2
remote
	^ self _projectRepository remote
%

! Class implementation for 'RwAbstractTool'

!		Class methods for 'RwAbstractTool'

category: 'commands'
classmethod: RwAbstractTool
git

	^ RwGitTool new
%

!		Instance methods for 'RwAbstractTool'

category: 'class lookup'
method: RwAbstractTool
definitionsForClassExtensionNamed: className ifFound: foundBlock ifAbsent: absentBlock

	"validate loaded class extension registry structure"

	^ Rowan image
		loadedClassExtensionsNamed: className
		ifFound: [ :loadedClassExtensionSet | 
			loadedClassExtensionSet
				do: [ :loadedClassExtension | 
					| loadedPackage projectDef packageDef classExtensionDef |
					loadedPackage := loadedClassExtension loadedPackage.
					projectDef := loadedPackage loadedProject asDefinition.
					packageDef := projectDef packageNamed: loadedPackage name.
					classExtensionDef := packageDef classExtensions
						at: loadedClassExtension name.
					foundBlock value: classExtensionDef value: packageDef value: projectDef ].
			^ self ]
		ifAbsent: absentBlock
%

category: 'class lookup'
method: RwAbstractTool
definitionsForClassNamed: className ifFound: foundBlock ifAbsent: absentBlock

	Rowan image
		loadedClassNamed: className
		ifFound: [ :loadedClass | 
			| loadedPackage projectDef packageDef classDef |
			loadedPackage := loadedClass loadedPackage.
			projectDef := loadedPackage loadedProject asDefinition.
			packageDef := projectDef packageNamed: loadedPackage name.
			classDef := packageDef classDefinitions at: loadedClass name.
			^ foundBlock value: classDef value: packageDef value: projectDef ]
		ifAbsent: absentBlock
%

category: 'class lookup'
method: RwAbstractTool
definitionsForMethod: selector inClassNamed: className isMeta: isMeta ifFound: foundBlock ifAbsent: absentBlock

	^ Rowan image
		loadedMethod: selector
		inClassNamed: className
		isMeta: isMeta
		ifFound: [ :loadedMethod | 
			| loadedPackage loadedClass projectDef packageDef classDef classExtensionDef |
			loadedPackage := loadedMethod loadedPackage.
			loadedClass := loadedMethod loadedClass.
			projectDef := loadedPackage loadedProject asDefinition.
			packageDef := projectDef packageNamed: loadedPackage name.
			loadedClass isLoadedClass
				ifTrue: [ classDef := packageDef classDefinitions at: loadedClass name ]
				ifFalse: [ classExtensionDef := packageDef classExtensions at: loadedClass name ].
			foundBlock
				value: loadedMethod asDefinition
				value: classDef
				value: classExtensionDef
				value: packageDef
				value: projectDef.
			^ self ]
		ifAbsent: absentBlock
%

! Class implementation for 'RwClassTool'

!		Class methods for 'RwClassTool'

category: 'commands'
classmethod: RwClassTool
clas
  ^ RwClsDiffTool new
%

! Class implementation for 'RwClsCommonAuditTool'

!		Instance methods for 'RwClsCommonAuditTool'

category: 'audit'
method: RwClsCommonAuditTool
auditClass: aLoadedClassOrExtension
	| aClass |
	(self auditGlobalFor: aLoadedClassOrExtension)
		ifTrue: [ 
			"audit class details, since there are no issues with the class itself"
			aClass := aLoadedClassOrExtension handle.
			self auditLoadedClassProperties: aLoadedClassOrExtension forClass: aClass.
			self auditCompiledMethods: aLoadedClassOrExtension forClass: aClass.
			aLoadedClassOrExtension
				loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClass :aLoadedMethod | 
					self
						auditLoadedMethod: aLoadedMethod
						forBehavior: aClass
						loadedClass: loadedClass ]
				loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClass :aLoadedMethod | 
					self
						auditLoadedMethod: aLoadedMethod
						forBehavior: aClass class
						loadedClass: loadedClass ] ].
	^ self theAuditDetails
%

category: 'audit'
method: RwClsCommonAuditTool
auditCompiledMethods: aLoadedClassOrExtension forClass: aClass
	self subclassResponsibility: #'auditCompiledMethods:forClass:'
%

category: 'audit'
method: RwClsCommonAuditTool
auditLoadedMethod: aLoadedMethod forBehavior: aBehavior loadedClass: aLoadedClassOrExtension
	(aBehavior compiledMethodAt: aLoadedMethod name otherwise: nil)
		ifNil: [ 
			self theAuditDetails
				add:
					((RwAuditMethodDetail
						for: aLoadedClassOrExtension
						message:
							'Missing compiled method: ' , aBehavior printString , '>>'
								, aLoadedMethod selector)
						reason: #'missingCompiledMethod';
						loadedMethod: aLoadedMethod;
						behavior: aBehavior;
						yourself) ]
		ifNotNil: [ :aMethod | 
			| expected actual |
			((expected := aLoadedMethod methodCategory)
				equalsNoCase: (actual := aBehavior categoryOfSelector: aMethod selector))
				ifFalse: [ 
					self theAuditDetails
						add:
							((RwAuditMethodDetail
								for: aLoadedClassOrExtension
								message:
									'Mismatched method category (expected: ' , expected printString , ' actual: '
										, actual printString , '): ' , aBehavior printString , '>>'
										, aLoadedMethod selector)
								reason: #'differentMethodCategory';
								loadedMethod: aLoadedMethod;
								method: aMethod;
								loadedCategory: actual;
								category: expected;
								behavior: aBehavior;
								yourself) ].
			aMethod == aLoadedMethod handle
				ifFalse: [ 
					self theAuditDetails
						add:
							((RwAuditMethodDetail
								for: aLoadedClassOrExtension
								message:
									'Compiled method is not identical to loaded method: ' , aBehavior printString
										, '>>' , aLoadedMethod selector)
								reason: #'methodsNotIdentical';
								loadedMethod: aLoadedMethod;
								method: aMethod;
								behavior: aBehavior;
								yourself) ] ]
%

category: 'audit'
method: RwClsCommonAuditTool
auditRowanHybridCategory: category forBehavior: aBehavior loadedClass: aLoadedClass
	| aPackage |
	"must be an extension. Do basic checks"
	aPackage := category copyFrom: 2 to: category size.
	(category notEmpty and: [ category first == $* ])
		ifTrue: [ 
			"must be an extension category. See if package exists"
			(aPackage asLowercase isEquivalent: aBehavior rowanPackageName asLowercase)
				ifTrue: [ 
					"aLoadedClass name , ' #' , category asString -> 'Extension category name can not be same as class package' "
					self theAuditDetails
						add:
							((RwAuditMethodCategoryDetail
								for: aLoadedClass
								message:
									'For class (' , aBehavior printString , ') extension category name <' , category
										, '>  must not match class package name ('
										, aBehavior rowanPackageName , ').')
								reason: #'rowanHybridExtensionCategoryMatchesClassPackage';
								category: category;
								behavior: aBehavior;
								yourself) ] ]
		ifFalse: [ 
			aLoadedClass isLoadedClassExtension
				ifTrue: [ 
					self theAuditDetails
						add:
							((RwAuditMethodCategoryDetail
								for: aLoadedClass
								message:
									'For class (' , aBehavior printString , ') extension category name <' , category
										, '>  must begin with a `*`.')
								reason: #'rowanHybridExtensionCategoryFormatError';
								category: category;
								behavior: aBehavior;
								yourself) ] ]
%

category: 'audit'
method: RwClsCommonAuditTool
auditSelector: aSelector inCategory: category forBehavior: aBehavior loadedClass: aLoadedClass
	"every method in a packaged class is expected to be packaged (i.e. have a loaded method)"

	| compiledMethod |
	(compiledMethod := aBehavior compiledMethodAt: aSelector otherwise: nil)
		ifNil: [ 
			"interesting anomaly, but not necessarily a Rowan corruption issue ... category dictionary is not correct"
			GsFile
				gciLogServer:
					'**NOTE** no method or loaded method found for selector '
						, aSelector printString , 'in category ' , category , ' for class '
						, aBehavior printString.
			^ self ].
	Rowan image
		loadedMethodForMethod: compiledMethod
		ifAbsent: [ 
			| notification |
			notification := (RwAuditMethodErrorNotification
				method: aSelector
				isMeta: aBehavior isMeta
				inClassNamed: aBehavior theNonMetaClass name
				isClassExtension: aLoadedClass isLoadedClassExtension
				intoPackageNamed: aLoadedClass loadedPackage name)
				description: 'Missing loaded method';
				reason: #'missingLoadedMethod';
				yourself.
			notification signal
				ifTrue: [ 
					"record audit detail"
					self theAuditDetails
						add:
							((RwAuditMethodDetail
								for: aLoadedClass
								message:
									'Missing loaded method: ' , aBehavior printString , '>>' , aSelector)
								reason: #'missingLoadedMethod';
								loadedMethod: nil;
								method: compiledMethod;
								selector: aSelector;
								behavior: aBehavior;
								yourself) ].
			^ self ]
%

category: 'accessing'
method: RwClsCommonAuditTool
theAuditDetails
	^ theAuditDetails ifNil: [ theAuditDetails := Array new ]
%

! Class implementation for 'RwClsAuditTool'

!		Instance methods for 'RwClsAuditTool'

category: 'audit'
method: RwClsAuditTool
auditCategory: category forBehavior: aBehavior loadedClass: aLoadedClass
	| packageConvention |
	packageConvention := aLoadedClass loadedProject packageConvention.

	^ packageConvention = 'RowanHybrid'
		ifTrue: [ 
			self
				auditRowanHybridCategory: category
				forBehavior: aBehavior
				loadedClass: aLoadedClass ]
%

category: 'audit'
method: RwClsAuditTool
auditCompiledMethods: aLoadedClass forClass: aClass
	"full audit of class methods. Every method should be packaged (have a loaded method)"

	aClass
		categorysDo: [ :category :selectors | 
			self auditCategory: category forBehavior: aClass loadedClass: aLoadedClass.
			selectors
				do: [ :aSelector | 
					self
						auditSelector: aSelector
						inCategory: category
						forBehavior: aClass
						loadedClass: aLoadedClass ] ].
	aClass class
		categorysDo: [ :category :selectors | 
			self auditCategory: category forBehavior: aClass class loadedClass: aLoadedClass.
			selectors
				do: [ :aSelector | 
					self
						auditSelector: aSelector
						inCategory: category
						forBehavior: aClass class
						loadedClass: aLoadedClass ] ]
%

category: 'audit'
method: RwClsAuditTool
auditGlobalFor: aLoadedClass
	"answer true if there are no audit issues with the class"

	(Rowan globalNamed: aLoadedClass name)
		ifNil: [ 
			"there is no matching Class for LoadedClass"
			self theAuditDetails
				add:
					(RwAuditClassDetail
						for: aLoadedClass
						reason: #'missingGemStoneClassForLoadedClass'
						message: 'Missing gemstone class for loaded class: ' , aLoadedClass name).
			^ false ]
		ifNotNil: [ :theClass | 
			theClass == aLoadedClass handle
				ifFalse: [ 
					"the loadedClass is for a different version of the current class installed in symbol dictionaries"
					self theAuditDetails
						add:
							(RwAuditClassDetail
								for: aLoadedClass
								reason: #'classesNotIdentical'
								message:
									'Installed class is not identical to the loaded class: ' , aLoadedClass name).
					^ false ] ].
	^ true
%

category: 'audit'
method: RwClsAuditTool
auditLoadedClassProperties: aLoadedClass forClass: aClass
	"Check #( 'instvars', 'superclass', 'classinstvars',  'gs_SymbolDictionary', 'comment', 'classvars', 'pools', 'category')"

	| aDict superclassName classProperty varNames |
	superclassName := aClass superclass
		ifNil: [ 'nil' ]
		ifNotNil: [ :superCls | superCls name ].
	(aLoadedClass classSuperclass isEquivalent: superclassName)
		ifFalse: [ 
			self theAuditDetails
				add:
					((RwAuditClassPropertyDetail
						for: aLoadedClass
						message:
							'For class ' , aLoadedClass name , ' superclass (' , superclassName
								, ') is different from loaded class (' , aLoadedClass classSuperclass
								, ')')
						reason: #'differentSuperclass';
						loadedPropertyValue: aLoadedClass classSuperclass;
						classPropertyValue: superclassName;
						class: aClass;
						yourself) ].
	aLoadedClass classInstVarNames
		= (varNames := aClass instVarNames collect: [ :e | e asString ])
		ifFalse: [ 
			self theAuditDetails
				add:
					((RwAuditClassPropertyDetail
						for: aLoadedClass
						message:
							'For class ' , aLoadedClass name , ' instVarNames changed in compiled class ('
								, varNames printString , ') v loaded class ('
								, aLoadedClass classInstVarNames printString , ')')
						reason: #'differentClassInstVars';
						loadedPropertyValue: aLoadedClass classInstVarNames;
						classPropertyValue: aClass instVarNames;
						class: aClass;
						yourself) ].
	aLoadedClass classClassVarNames
		=
			(classProperty := ((aClass.classVars ifNil: [ SymbolDictionary new ]) keys
				collect: [ :e | e asString ]) asSortedCollection asArray)
		ifFalse: [ 
			self theAuditDetails
				add:
					((RwAuditClassPropertyDetail
						for: aLoadedClass
						message:
							'For class ' , aLoadedClass name , ' classVars changed in compiled class ('
								, classProperty printString , ') v loaded class ('
								, aLoadedClass classClassVarNames printString , ')')
						reason: #'differentClassVars';
						loadedPropertyValue: aLoadedClass classClassVarNames;
						classPropertyValue: classProperty;
						class: aClass;
						yourself) ].
	aLoadedClass classPoolDictionaries
		=
			(classProperty := (aClass.poolDictionaries ifNil: [ Array new ])
				collect: [ :e | e asString ])
		ifFalse: [ 
			self theAuditDetails
				add:
					((RwAuditClassPropertyDetail
						for: aLoadedClass
						message:
							'For class ' , aLoadedClass name
								, ' poolDictionaries changed in compiled class v loaded class')
						reason: #'differentPoolDictionaries';
						loadedPropertyValue: aLoadedClass classPoolDictionaries;
						classPropertyValue: classProperty;
						class: aClass;
						yourself) ].
	(aLoadedClass classComment isEquivalent: aClass rwComment)
		ifFalse: [ 
			self theAuditDetails
				add:
					((RwAuditClassPropertyDetail
						for: aLoadedClass
						message:
							'For class ' , aLoadedClass name , ' comment has changed in compiled class ('
								, aClass rwComment printString , ') v loaded class ('
								, aLoadedClass classComment printString , ')')
						reason: #'differentComment';
						loadedPropertyValue: aLoadedClass classComment;
						classPropertyValue: aClass rwComment;
						class: aClass;
						yourself) ].
	aLoadedClass classCategory
		= (classProperty := aClass _classCategory ifNil: [ '' ])
		ifFalse: [ 
			self theAuditDetails
				add:
					((RwAuditClassPropertyDetail
						for: aLoadedClass
						message:
							'For class ' , aLoadedClass name
								, ' class category has changed in compiled class (' , classProperty
								, ') v loaded class (' , aLoadedClass classCategory , ')')
						reason: #'differentCategory';
						loadedPropertyValue: aLoadedClass classCategory;
						classPropertyValue: classProperty;
						class: aClass;
						yourself) ].
	(aDict := System myUserProfile
		resolveSymbol: aLoadedClass classSymbolDictionaryName asSymbol)
		ifNil: [ 
			self theAuditDetails
				add:
					((RwAuditClassPropertyDetail
						for: aLoadedClass
						message:
							'For class ' , aLoadedClass name , ' unable to find SymbolDictionary '
								, aLoadedClass classSymbolDictionaryName)
						reason: #'missingSymbolDictionary';
						loadedPropertyValue: aLoadedClass classSymbolDictionaryName;
						class: aClass;
						yourself) ]
		ifNotNil: [ :smbd | 
			smbd value
				at: aLoadedClass name asSymbol
				ifAbsent: [ 
					self theAuditDetails
						add:
							((RwAuditClassPropertyDetail
								for: aLoadedClass
								message:
									'Class (' , aLoadedClass name , ') not found in symbol dictionary ('
										, aLoadedClass classSymbolDictionaryName asSymbol
										, ') of loaded class')
								reason: #'missingClassInSymbolDictionary';
								loadedPropertyValue: aLoadedClass classSymbolDictionaryName;
								classPropertyValue:
										(GsCurrentSession currentSession symbolList
												dictionariesAndSymbolsOf: aClass theNonMetaClass);
								class: aClass;
								yourself) ] ]
%

! Class implementation for 'RwClsExtensionAuditTool'

!		Instance methods for 'RwClsExtensionAuditTool'

category: 'audit'
method: RwClsExtensionAuditTool
auditCompiledMethods: aLoadedClassExtension forClass: aClass
	| categories |
	aLoadedClassExtension loadedProject packageConvention = 'RowanHybrid'
		ifTrue: [ 
			| extensionCategoryName |
			extensionCategoryName := aLoadedClassExtension loadedPackage asExtensionName.
			{aClass.
			(aClass class)}
				do: [ :aBehavior | 
					| categoryDict |
					categoryDict := aBehavior rwMethodCategories.
					categories := categoryDict
						ifNil: [ #() ]
						ifNotNil: [ :catDict | catDict keys ].
					(categories
						detect: [ :each | each asString equalsNoCase: extensionCategoryName ]
						ifNone: [  ])
						ifNotNil: [ :aCategory | 
							self
								auditRowanHybridCategory: aCategory
								forBehavior: aBehavior
								loadedClass: aLoadedClassExtension.
							aClass rowanPackageName = Rowan unpackagedName
								ifTrue: [ 
									"In an unpackaged class, we must audit the extension categories.
										Every selector in the extension category is expected to be be 
										packaged for RowanHybrid. Packaged class is covered by 
										RwNewClsAuditTool >> auditCompiledMethods:forClass:"
									(categoryDict at: aCategory)
										do: [ :aSelector | 
											self
												auditSelector: aSelector
												inCategory: aCategory
												forBehavior: aBehavior
												loadedClass: aLoadedClassExtension ] ] ]
						ifNil: [ 
							(aBehavior isMeta
								ifTrue: [ aLoadedClassExtension loadedClassMethods ]
								ifFalse: [ aLoadedClassExtension loadedInstanceMethods ]) notEmpty
								ifTrue: [ 
									self theAuditDetails
										add:
											((RwAuditMethodCategoryDetail
												for: aLoadedClassExtension
												message:
													'Missing '
														,
															(aBehavior isMeta
																ifTrue: [ 'class' ]
																ifFalse: [ 'instance' ]) , ' method extension category named '
														, extensionCategoryName , ' for: ' , aLoadedClassExtension name)
												reason: #'missingExtensionCategory';
												category: extensionCategoryName;
												behavior: aBehavior;
												yourself) ] ] ] ]
		ifFalse: [ 
			aLoadedClassExtension loadedProject packageConvention = 'Rowan'
				ifTrue: [ 
					"extension methods may be inter-mixed with non-extension methods in the same category, so category-based audit is not useful
						but, we do want to make sure that empty loaded class extensions aren't floating around"
					aLoadedClassExtension isEmpty
						ifTrue: [ 
							self theAuditDetails
								add:
									(RwAuditClassDetail
										for: aLoadedClassExtension
										reason: #'emptyLoadedClassExtension'
										message:
											'The loaded class extension is empty for: ' , aLoadedClassExtension name) ] ]
				ifFalse: [ 
					aLoadedClassExtension loadedProject packageConvention = 'Monticello'
						ifTrue: [ self error: 'Monticlello package conventions not yet supported' ].
					self
						error:
							'Unknonwn package convention'
								, aLoadedClassExtension loadedProject packageConvention printString ] ]
%

category: 'audit'
method: RwClsExtensionAuditTool
auditGlobalFor: aLoadedClassExtension
	"answer true if there are no audit issues with the class"

	(Rowan globalNamed: aLoadedClassExtension name)
		ifNil: [ 
			self theAuditDetails
				add:
					(RwAuditClassDetail
						for: aLoadedClassExtension
						reason: #'missingGemStoneClassForLoadedClassExtension'
						message:
							' Class does not exists for loaded class extension: '
								, aLoadedClassExtension name).
			^ false ]
		ifNotNil: [ :theClass | 
			theClass == aLoadedClassExtension handle
				ifFalse: [ 
					"the loadedClassExtension is for a different version of the current class installed in symbol dictionaries"
					self theAuditDetails
						add:
							(RwAuditClassDetail
								for: aLoadedClassExtension
								reason: #'classesNotIdentical'
								message:
									'Installed class is not identical to the loaded class: '
										, aLoadedClassExtension name).
					^ false ] ].
	^ true
%

category: 'audit'
method: RwClsExtensionAuditTool
auditLoadedClassProperties: aLoadedClassExtension forClass: aClass
	"noop for loaded class extensions ... no properties to audit"
%

! Class implementation for 'RwGitTool'

!		Instance methods for 'RwGitTool'

category: 'smalltalk api'
method: RwGitTool
gitaddIn: gitRepoPath with: args

	^ self performGitCommand: 'add' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitbranchIn: gitRepoPath with: args

	^ self performGitCommand: 'branch' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitBranchNameIn: gitRepoPath
	"return current branch for git repository located at gitPath"

	| command result |
	command := 'set -e; cd ' , gitRepoPath , ';git branch | sed -n ''/\* /s///p'''.
	result := self performOnServer: command logging: self _shouldLog.
	^ result trimWhiteSpace
%

category: 'smalltalk api'
method: RwGitTool
gitcheckoutIn: gitRootReference with: args
	^ self performGitCommand: 'checkout' in: gitRootReference pathString with: args
%

category: 'smalltalk api'
method: RwGitTool
gitcloneIn: gitRootPath with: args

	^ self gitcloneIn: gitRootPath with: args logging: self _shouldLog
%

category: 'smalltalk api'
method: RwGitTool
gitcloneIn: gitRootPath with: gitArgs logging: logging

	| commandBase command gitCommand |
	gitCommand := 'clone'.
	commandBase := 'set -e; cd ' , gitRootPath , '; git ' , gitCommand , ' '.
	command := commandBase , gitArgs.
	^ self performOnServer: command logging: logging
%

category: 'smalltalk api'
method: RwGitTool
gitcommitIn: gitRepoPath with: args

	^ self performGitCommand: 'commit' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitcommitShaIn: gitRepoPath

	| result |
	gitRepoPath ifNil: [ ^ '' ].
	result := self gitlogIn: gitRepoPath with: ' -1 --pretty=format:%h '.
	(result beginsWith: 'fatal:')
		ifTrue: [ ^ nil ].
	^ result trimWhiteSpace
%

category: 'smalltalk api'
method: RwGitTool
gitfetchIn: gitRootReference with: args
	^ self performGitCommand: 'fetch' in: gitRootReference pathString with: args
%

category: 'smalltalk api'
method: RwGitTool
gitinitIn: dirPath with: args

	| command |
	command := 'set -e; cd ' , dirPath , '; git init ' , args.
	^ self performOnServer: command logging: self _shouldLog
%

category: 'smalltalk api'
method: RwGitTool
gitlogFull: commitish limit: limit gitRepoDirectory: gitRepoPath

	| commitLog |
	commitLog := self
		gitlogIn: gitRepoPath
		with: ' -' , limit printString , ' ' , commitish.
	^ commitLog
%

category: 'smalltalk api'
method: RwGitTool
gitlogIn: gitRepoPath with: args

	^ self performGitCommand: 'log' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitlogtool: commitish limit: limit gitRepoDirectory: gitRepoPath

	^ self
		gitlogIn: gitRepoPath
		with:
			'--date=relative --format="%h %cd %s" -' , limit printString , ' ' , commitish
%

category: 'smalltalk api'
method: RwGitTool
gitPresentIn: gitRepoPath

	| gitHome command cdResponse |
	[ 
	gitHome := self gitrevparseShowTopLevelIn: gitRepoPath.
	command := 'set -e; cd ' , gitRepoPath , '; pwd'.
	cdResponse := self performOnServer: command logging: self _shouldLog ]
		on: Error
		do: [ :ex | ^ false ].
	^ (self readlink: gitHome) = (self readlink: cdResponse)
%

category: 'smalltalk api'
method: RwGitTool
gitpullIn: gitRepoPath

	^ self gitpullIn: gitRepoPath with: ''
%

category: 'smalltalk api'
method: RwGitTool
gitpullIn: gitRepoPath remote: remoteName branch: branchName

	^ self gitpullIn: gitRepoPath with: remoteName , ' ' , branchName
%

category: 'smalltalk api'
method: RwGitTool
gitpullIn: gitRepoPath with: args

	^ self performGitCommand: 'pull' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitpushIn: gitRepoPath remote: remoteName branch: branchName

	^ self gitpushIn: gitRepoPath with: remoteName , ' ' , branchName
%

category: 'smalltalk api'
method: RwGitTool
gitpushIn: gitRepoPath with: args

	^ self performGitCommand: 'push' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitrevparseShowTopLevelIn: dirPath

	| command |
	command := 'set -e; cd ' , dirPath , '; git rev-parse --show-toplevel'.
	^ self performOnServer: command logging: self _shouldLog
%

category: 'smalltalk api'
method: RwGitTool
gitstatusIn: gitRepoPath with: args

	^ self performGitCommand: 'status' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
isGitHome: homeReferenceOrPath
	"Answer true if the given homeReferenceOrPath is the home directory for a git repository"

	| homeFileReference expandedHomePath expandedGitRootPath |
	homeFileReference := homeReferenceOrPath asFileReference.
	(self gitPresentIn: homeFileReference pathString)
		ifFalse: [ 
			"early check needed to protect gitrevparseShowTopLevelIn: call"
			^ false ].
	expandedHomePath := self readlink: homeFileReference pathString.
	expandedGitRootPath := self
		readlink:
			(self gitrevparseShowTopLevelIn: homeFileReference pathString) trimBoth.
	^ (self gitPresentIn: expandedGitRootPath)
		and: [ expandedHomePath = expandedGitRootPath ]
%

category: 'private'
method: RwGitTool
performGitCommand: gitCommand in: gitRepoPath with: gitArgs

	^ self
		performGitCommand: gitCommand
		in: gitRepoPath
		worktree: gitRepoPath
		with: gitArgs
		logging: self _shouldLog
%

category: 'private'
method: RwGitTool
performGitCommand: gitCommand in: gitRepoPath worktree: workTreePath with: gitArgs logging: logging

	"unconditional cd to work-tree because of git pull problem with git prior to 1.7.7.2"

	| commandBase command |
	commandBase := 'set -e; cd ' , workTreePath , '; git --git-dir ' , gitRepoPath
		, '/.git --work-tree ' , workTreePath , ' ' , gitCommand , ' '.
	command := commandBase , gitArgs.
	^ self performOnServer: command logging: logging
%

category: 'private'
method: RwGitTool
performOnServer: commandLine
	^ self performOnServer: commandLine logging: self _shouldLog
%

category: 'private'
method: RwGitTool
performOnServer: commandLine logging: logging
  | result |
  result := self
    performOnServer: commandLine
    status: [ :performOnServerStatusArray | 
      "Array of 5 elements: 
       raw status Integer, 
       child process status Integer (after WEXITSTATUS macro applied), 
       result String (or nil if operation failed) ,
       error string from script file write, fork, or result file read ,
       errno value, a SmallInteger from file write, fork, or file read"
      (performOnServerStatusArray at: 1) ~~ 0
        ifTrue: [ 
          | message |
          message := 'performOnServer: ' , commandLine printString , ' stdout: '
            , (performOnServerStatusArray at: 3) printString
            , ' failed with status: '
            , (performOnServerStatusArray at: 1) printString , ' errno: '
            , (performOnServerStatusArray at: 5) printString , ' errStr: '
            , (performOnServerStatusArray at: 4) asString.
          self error: message ].
      performOnServerStatusArray at: 3 ].
  logging
    ifTrue: [ 
      Transcript
        cr;
        show: commandLine printString;
        cr;
        show: result ].
  ^ result
%

category: 'private'
method: RwGitTool
_mktempCommand
	^ (System gemVersionReport at: 'osName') = 'Darwin'
		ifTrue: [ '/usr/bin/mktemp -t commitMessage' ]
		ifFalse: [ '/bin/mktemp --tmpdir commitMessage.XXXX' ]
%

category: 'private'
method: RwGitTool
_shouldLog
	^ Rowan projectTools trace isTracing
%

! Class implementation for 'RwPackageTool'

!		Class methods for 'RwPackageTool'

category: 'commands'
classmethod: RwPackageTool
adopt
  ^ RwPkgAdoptTool new
%

category: 'commands'
classmethod: RwPackageTool
create
  ^ RwPkgCreateTool new
%

category: 'commands'
classmethod: RwPackageTool
disown
  ^ RwPkgDisownTool new
%

category: 'commands'
classmethod: RwPackageTool
load
  ^ RwPkgLoadTool new
%

! Class implementation for 'RwPkgAdoptTool'

!		Instance methods for 'RwPkgAdoptTool'

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClass: theClass classExtension: classExtension instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName
	"adopt the methods for class named <className> and it's methods into the package named <packageName>, 
		if it is not a <classExtension>, adopt the class into the package as well."

	"Ignore packaged instance and class methods"

	| loadedPackage loadedProject packageSymDictName theSymbolDictionary registry theBehavior className |
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.
	className := theClass name asString.

	packageSymDictName := (loadedProject symbolDictNameForPackageNamed: packageName)
		asSymbol.
	theSymbolDictionary := Rowan image symbolDictNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	classExtension
		ifFalse: [ 
			[ 
			registry
				addClassAssociation: (theSymbolDictionary associationAt: theClass name)
				forClass: theClass
				toPackageNamed: packageName ]
				on: RwExistingAssociationWithSameKeyNotification
				do: [ :ex | ex resume ] ].

	theBehavior := theClass.
	instanceSelectors
		do: [ :methodSelector | 
			| theCompiledMethod |
			theCompiledMethod := (theBehavior
				compiledMethodAt: methodSelector
				otherwise: nil)
				ifNil: [ 
					(RwAdoptMissingMethodErrorNotification
						method: methodSelector
						isMeta: false
						inClassNamed: className
						isClassExtension: classExtension
						intoPackageNamed: packageName) signal.
					"skip adoption of this method"
					nil ].
			theCompiledMethod
				ifNotNil: [ 
					registry
						adoptCompiledMethod: theCompiledMethod
						classExtension: classExtension
						for: theBehavior
						protocol: (theBehavior categoryOfSelector: methodSelector)
						toPackageNamed: packageName ] ].

	theBehavior := theClass class.
	classSelectors
		do: [ :methodSelector | 
			| theCompiledMethod |
			theCompiledMethod := (theBehavior
				compiledMethodAt: methodSelector
				otherwise: nil)
				ifNil: [ 
					(RwAdoptMissingMethodErrorNotification
						method: methodSelector
						isMeta: true
						inClassNamed: className
						isClassExtension: classExtension
						intoPackageNamed: packageName) signal.
					"skip adoption of this method"
					nil ].
			theCompiledMethod
				ifNotNil: [ 
					registry
						adoptCompiledMethod: theCompiledMethod
						classExtension: classExtension
						for: theBehavior
						protocol: (theBehavior categoryOfSelector: methodSelector)
						toPackageNamed: packageName ] ]
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClass: theClass intoPackageNamed: packageName
	"adopt the class named <className> and it's methods into the package named <packageName>"

	"Ignore packaged instance and class methods"

	self
		adoptClass: theClass
		classExtension: false
		instanceSelectors: theClass selectors
		classSelectors: theClass class selectors
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassExtension: theClass instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName
	"adopt extension methods for the class named <className> into the package named <packageName>"

	^ self
		adoptClass: theClass
		classExtension: true
		instanceSelectors: instanceSelectors
		classSelectors: classSelectors
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassExtensionNamed: className  instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName

	"adopt extension methods for the class named <className> into the package named <packageName>"

	self 
		adoptClassNamed: className 
		classExtension: true 
		instanceSelectors: instanceSelectors 
		classSelectors: classSelectors 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassNamed: className classExtension: classExtension instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName
	"adopt the methods for class named <className> and it's methods into the package named <packageName>, 
		if it is not a <classExtension>, adopt the class into the package as well."

	"Ignore packaged instance and class methods"

	| loadedPackage loadedProject packageSymDictName theClass theSymbolDictionary |
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	packageSymDictName := (loadedProject symbolDictNameForPackageNamed: packageName)
		asSymbol.
	theSymbolDictionary := Rowan image symbolDictNamed: packageSymDictName.

	theClass := theSymbolDictionary
		at: className asSymbol
		ifAbsent: [ 
			(RwAdoptMissingClassErrorNotification
				classNamed: className
				isClassExtension: classExtension
				intoPackageNamed: packageName) signal.
			"if exception resumed then we'll skip the adopt operation for this class"
			^ self ].

	^ self adoptClass: theClass classExtension: classExtension instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassNamed: className  instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName

	"adopt the class named <className> and it's methods into the package named <packageName>"

	"Ignore packaged instance and class methods"
	
	self 
		adoptClassNamed: className 
		classExtension: false 
		instanceSelectors: instanceSelectors 
		classSelectors: classSelectors 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassNamed: className  intoPackageNamed: packageName

	"adopt the class named <className> and it's methods into the package named <packageName>"

	"Ignore packaged instance and class methods"

	| theClass |

	theClass := Rowan globalNamed: className.
	self 
		adoptClassNamed: className 
		instanceSelectors: theClass selectors 
		classSelectors: theClass class selectors 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptMethod: methodSelector inClassNamed: className  isMeta: isMeta intoPackageNamed: packageName

	"adopt the method <methodSelector> in class named <className> and it's methods into the package named <packageName>"

	| theClass theBehavior protocolString  |
	theClass := Rowan globalNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].
	protocolString := (theBehavior categoryOfSelector: methodSelector asSymbol) asString. 
	self 
		adoptMethod: methodSelector 
		protocol: protocolString 
		inClassNamed: className  
		isMeta: isMeta 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptMethod: methodSelector protocol: protocolString inClassNamed: className  isMeta: isMeta intoPackageNamed: packageName

	"adopt the method <methodSelector> in class named <className> and it's methods into the package named <packageName>.
		move the method into protocol <protocolString> "

	| loadedPackage loadedProject packageSymDictName theClass theSymbolDictionary registry 
		theBehavior theCompiledMethod |
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	packageSymDictName := loadedProject symbolDictNameForPackageNamed: packageName.

	theClass := Rowan globalNamed: className.
	theSymbolDictionary := Rowan image symbolDictNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].

	theCompiledMethod := theBehavior compiledMethodAt: methodSelector.

	theCompiledMethod rowanProjectName = Rowan unpackagedName
		ifFalse: [ self error: 'The method ', className printString, '>>', methodSelector asString, ' is already packaged ... no need to adopt' ].

	theClass  rowanPackageName ~= packageName
		ifTrue: [ 
			registry
				addExtensionCompiledMethod: theCompiledMethod 
				for: theBehavior 
				protocol: protocolString 
				toPackageNamed: packageName ]
		ifFalse: [ 
			registry
				adoptCompiledMethod: theCompiledMethod 
				classExtension: false
				for: theBehavior 
				protocol: protocolString
				toPackageNamed: packageName ].
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolDictionary: symbolDictionary intoPackageNamed: packageName

	"create loaded classes in the loaded package <packageName> for the unpackaged classes in <symbolDictionary>"

	symbolDictionary keysAndValuesDo: [:className :object |
		object isBehavior
			ifTrue: [ 
				object rowanPackageName = Rowan unpackagedName
					ifTrue: [ self adoptClassNamed: className asString intoPackageNamed: packageName ] ] ]
.
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolDictionaryNamed: symDictName intoPackageNamed: packageName

	"create loaded classes in the loaded package <packageName> for the unpackaged classes in the symbol dictionary named <symDictName>"

	^ self adoptSymbolDictionary: (Rowan image symbolDictNamed: symDictName) intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolList: symbolList excluding: excludedSymbolDictionaries intoPackagesNamed: packageNameMap

	"create loaded classes for the unpackaged classes in each of the symbol dictionaries in symbolList, except for those listed in
		<excludedSymbolDictionaries>. The loaded classes should be created in the package associated with the name of the symbol 
		dictionary in <packageNameMap>"

	symbolList do: [:symbolDict |
		(excludedSymbolDictionaries includes: symbolDict)
			ifFalse: [ self adoptSymbolDictionary: symbolDict intoPackageNamed: (packageNameMap at: symbolDict name asString) ] ]
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolList: symbolList excludingSymbolDictsNamed: excludedSymbolDictionaryNames intoPackagesNamed: packageNameMap

	"create loaded classes for the unpackaged classes in each of the symbol dictionaries in symbolList, except for those named in
		<excludedSymbolDictionaryNames>. The loaded classes should be created in the package associated with the name of the symbol 
		dictionary in <packageNameMap>"

	symbolList do: [:symbolDict |
		| symDictName |
		symDictName := symbolDict name asString.
		(excludedSymbolDictionaryNames includes: symDictName)
			ifFalse: [ self adoptSymbolDictionary: symbolDict intoPackageNamed: (packageNameMap at: symDictName) ] ]
%

! Class implementation for 'RwPkgDisownTool'

!		Instance methods for 'RwPkgDisownTool'

category: 'classes'
method: RwPkgDisownTool
disownClass: theClass
	"Remove the specified class and all of it's packaged instance and class methods from the loaded things. Methods that are not in the same package as
		the class are not disowned. "

	"The classes and methods are not removed from the system"

	| packageName loadedPackage loadedProject packageSymDictName theSymbolDictionary registry className |
	className := theClass name asString.
	theClass rowanProjectName = Rowan unpackagedName
		ifTrue: [ 
			self
				error:
					'The class ' , className printString
						, ' is not packaged ... cannot disown an unpackaged class' ].
	packageName := theClass rowanPackageName.
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	packageSymDictName := loadedProject symbolDictNameForPackageNamed: packageName.

	theSymbolDictionary := Rowan image symbolDictNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	registry disownClass: theClass
%

category: 'classes'
method: RwPkgDisownTool
disownClassExtensionMethodsInClassNamed: className forPackageNamed: packageName

	"Remove the extension methods in the named class for the named package"

	"The methods are not removed from the system"

	"use:
		Rowan packageTools adopt
			adoptClassExtensionNamed: className  instanceSelectors: <instanceSelectors> classSelectors: <classSelectors> intoPackageNamed: packageName
	to restore the classes and methods to the loaded things"

	| loadedPackage loadedProject loadedClassExtension packageSymDictName theClass theSymbolDictionary registry |
	theClass := Rowan globalNamed: className.

	loadedClassExtension := (Rowan image loadedClassExtensionsForClass: theClass) 
		detect: [:classExtension |  classExtension loadedPackage name = packageName ]
		ifNone: [ self error: 'No class extensions for the package ' , packageName printString, ' found in the class ' , className printString ].

	loadedPackage := loadedClassExtension loadedPackage.
	loadedProject := loadedPackage loadedProject.

	packageSymDictName := loadedProject symbolDictNameForPackageNamed: packageName.

	theSymbolDictionary := Rowan image symbolDictNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	registry disownClassExtensions: theClass forLoadedPackage: loadedPackage
%

category: 'classes'
method: RwPkgDisownTool
disownClassNamed: className
	"Remove the specified class and all of it's packaged instance and class methods from the loaded things. Methods that are not in the same package as
		the class are not disowned. "

	"The classes and methods are not removed from the system"

	"use:
		Rowan packageTools adopt
			adoptClassNamed: className classExtension: classExtension instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: <packageName>
	to restore the classes and methods to the loaded things"

	self disownClass: (Rowan globalNamed: className)
%

category: 'methods'
method: RwPkgDisownTool
disownMethod: methodSelector inClassNamed: className isMeta: isMeta

	"remove the specified method from the loaded things. The method becomes unpackaged, but is not remove the system."

	"use:
		Rowan packageTools adopt
			adoptMethod: methodSelector inClassNamed: className  isMeta: isMeta intoPackageNamed: <packageName>
	to restore the specified method to the loaded things"

	| packageName loadedPackage loadedProject packageSymDictName theClass theSymbolDictionary registry 
		theBehavior theCompiledMethod |
	theClass := Rowan globalNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].
	theCompiledMethod := theBehavior compiledMethodAt: methodSelector.

	theCompiledMethod rowanProjectName = Rowan unpackagedName
		ifTrue: [ self error: 'The method ', className printString, '>>', methodSelector asString, ' is not packaged ... no need to disown' ].

	packageName := theCompiledMethod rowanPackageName.
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	packageSymDictName := loadedProject symbolDictNameForPackageNamed: packageName.

	theSymbolDictionary := Rowan image symbolDictNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	registry _doDeleteCompiledMethodFromLoadedThings: theCompiledMethod for: theBehavior
%

category: 'packages'
method: RwPkgDisownTool
disownPackageNamed: packageName

	"Remove the classes and methods managed by the package from the loaded things."

	"The classes and methods are not removed from the system"

	"Use the adopt tool to restore the classes and methods to the loaded things"

	| loadedPackage registry |

	loadedPackage := Rowan image loadedPackageNamed: packageName.
	registry :=Rowan image loadedRegistryForPackageNamed: packageName.

	loadedPackage loadedClasses values
		do: [:loadedClass | 
			| class |
			class := Rowan globalNamed: loadedClass key.
			loadedClass disownFromLoaded: registry.
			registry unregisterLoadedClass: loadedClass forClass: class ].

	loadedPackage loadedClassExtensions values 
		do: [:loadedClassExtension | 
			| class |
			class := Rowan globalNamed: loadedClassExtension key.
			loadedClassExtension disownFromLoaded: registry ].

	registry deletePackage: packageName
%

! Class implementation for 'RwPkgAuditToolV2'

!		Instance methods for 'RwPkgAuditToolV2'

category: 'other'
method: RwPkgAuditToolV2
auditForPackage: loadedPackage
	"audit dirty packages"

	| res loadedPackageRegistry packageSymbolDictionaryName registrySymbolDictionaryName packageAuditDetail |
	res := RwAuditReport for: loadedPackage.
	packageAuditDetail := {}.
	loadedPackageRegistry := Rowan image
		loadedRegistryForPackageNamed: loadedPackage name
		ifAbsent: [ 
			packageAuditDetail
				add:
					(RwAuditDetail
						for: loadedPackage
						reason: #'loadedPackageNotInRegistry'
						message:
							'The loaded package ' , loadedPackage name printString
								, ' is not found in a package registry') ].
	packageSymbolDictionaryName := loadedPackage packageSymbolDictionaryName.
	registrySymbolDictionaryName := loadedPackageRegistry _symbolDictionary name
		asString.
	registrySymbolDictionaryName = packageSymbolDictionaryName
		ifFalse: [ 
			packageAuditDetail
				add:
					(RwAuditDetail
						for: loadedPackage
						reason: #'loadedPackageInWrongRegistry'
						message:
							'The loaded package ' , loadedPackage name printString
								, ' is registered in the wrong symbol dictionary ('
								, registrySymbolDictionaryName printString
								, '). It is expected to be registered in '
								, packageSymbolDictionaryName printString) ].
	loadedPackage
		loadedClassesDo: [ :aLoadedClass | 
			| classSymbolDictName |
			classSymbolDictName := aLoadedClass classSymbolDictionaryName.
			classSymbolDictName = packageSymbolDictionaryName
				ifFalse: [ 
					packageAuditDetail
						add:
							((RwAuditPackageClassSymbolDictionaryDetail
								for: loadedPackage
								message:
									'The loaded class symbol dictionary name ' , classSymbolDictName printString
										, ' does not match the loaded package symbol dictionary name '
										, packageSymbolDictionaryName printString)
								reason: #'differentSymbolDictionaryForClassAndPackage';
								loadedClass: aLoadedClass;
								classSymbolDictionaryName: classSymbolDictName;
								packageSymbolDictionaryName: packageSymbolDictionaryName;
								yourself) ].
			(self auditLoadedClass: aLoadedClass)
				ifNotEmpty: [ :aColl | res at: aLoadedClass name put: aColl ] ]
		loadedClassExtensionsDo: [ :aLoadedClass | 
			| classEtensionSymbolDictionaryName |
			classEtensionSymbolDictionaryName := loadedPackageRegistry _symbolDictionary
				name asString.
			classEtensionSymbolDictionaryName = packageSymbolDictionaryName
				ifFalse: [ 
					packageAuditDetail
						add:
							((RwAuditPackageClassSymbolDictionaryDetail
								for: loadedPackage
								message:
									'The loaded extension class symbol dictionary name '
										, classEtensionSymbolDictionaryName printString
										, ' does not match the loaded package symbol dictionary name '
										, packageSymbolDictionaryName printString)
								reason: #'differentSymbolDictionaryForClassExtensionAndPackage';
								loadedClass: aLoadedClass;
								classSymbolDictionaryName: classEtensionSymbolDictionaryName;
								packageSymbolDictionaryName: packageSymbolDictionaryName;
								yourself) ].
			(self auditLoadedClassExtension: aLoadedClass)
				ifNotEmpty: [ :aColl | res at: aLoadedClass name put: aColl ] ].
	packageAuditDetail
		ifNotEmpty: [ :aColl | res at: loadedPackage name put: aColl ].
	^ res
%

category: 'other'
method: RwPkgAuditToolV2
auditForPackageNamed: packageName
	
	^self auditForPackage: (Rowan image loadedPackageNamed: packageName).
%

category: 'other'
method: RwPkgAuditToolV2
auditLoadedClass: aLoadedClass
	"look for methods compiled into class without Rowan API"

	^ RwClsAuditTool new auditClass: aLoadedClass
%

category: 'other'
method: RwPkgAuditToolV2
auditLoadedClassExtension: aLoadedClass
"look for methods compiled into class without Rowan API"

	^ RwClsExtensionAuditTool new auditClass: aLoadedClass
%

! Class implementation for 'RwProjectTool'

!		Class methods for 'RwProjectTool'

category: 'commands'
classmethod: RwProjectTool
adopt

	^ RwPrjAdoptTool new
%

category: 'commands'
classmethod: RwProjectTool
audit

	^RwPrjAuditTool new
%

category: 'commands'
classmethod: RwProjectTool
clone

	^RwPrjCloneTool new
%

category: 'commands'
classmethod: RwProjectTool
commit

	^RwPrjCommitTool new
%

category: 'commands'
classmethod: RwProjectTool
delete

	^ RwPrjDeleteTool new
%

category: 'commands'
classmethod: RwProjectTool
diff

	^ RwPrjDiffTool new
%

category: 'commands'
classmethod: RwProjectTool
disown

	^ RwPrjDisownTool new
%

category: 'commands'
classmethod: RwProjectTool
edit

	^ RwPrjEditTool new
%

category: 'commands'
classmethod: RwProjectTool
query

	^ RwPrjQueryTool new
%

category: 'commands'
classmethod: RwProjectTool
test

	^RwPrjTestTool new
%

category: 'commands'
classmethod: RwProjectTool
trace

	^RwPrjTraceTool new
%

!		Instance methods for 'RwProjectTool'

category: 'smalltalk api'
method: RwProjectTool
repositoryUrl
  ^ self specification repositoryUrl
%

! Class implementation for 'RwPrjAdoptTool'

!		Instance methods for 'RwPrjAdoptTool'

category: 'smalltalk api'
method: RwPrjAdoptTool
adoptProjectDefinition: projectDefinition

	| pkgAdoptTool |
	pkgAdoptTool := Rowan packageTools adopt.
	projectDefinition packages valuesDo: [:packageDef |
		packageDef classDefinitions valuesDo: [:classDef |
			pkgAdoptTool
				adoptClassNamed: classDef name 
				instanceSelectors: classDef instanceMethodDefinitions keys 
				classSelectors: classDef classMethodDefinitions keys 
				intoPackageNamed: packageDef name].
		packageDef classExtensions valuesDo: [:classDef |
			pkgAdoptTool
				adoptClassExtensionNamed: classDef name 
				instanceSelectors: classDef instanceMethodDefinitions keys 
				classSelectors: classDef classMethodDefinitions keys 
				intoPackageNamed: packageDef name ] ]
%

category: 'smalltalk api'
method: RwPrjAdoptTool
adoptProjectSetDefinition: projectSetDefinitionToAdopt

	projectSetDefinitionToAdopt projects do: [:projectDef |
		self adoptProjectDefinition: projectDef ]
%

! Class implementation for 'RwPrjAuditTool'

!		Instance methods for 'RwPrjAuditTool'

category: 'other'
method: RwPrjAuditTool
auditAll
	
	^self auditAllForUser: System myUserProfile userId
%

category: 'other'
method: RwPrjAuditTool
auditAllForUser: aUserId
| res |
	res := StringKeyValueDictionary new.
			(Rowan image  _loadedProjectRegistryForUserId: aUserId) keysAndValuesDo: [:prjName :aLoadedProject |
				(self auditForProject: aLoadedProject) ifNotEmpty: [:aColl | res at: prjName put: aColl]
	].
	^res
%

category: 'other'
method: RwPrjAuditTool
auditForProject: aLoadedProject
"audit loaded project"

	| res |

	res := RwAuditReport for: aLoadedProject.
	"self _log: '==============Auditing project ', aLoadedProject name."
		aLoadedProject loadedPackages values do: [:e | (Rowan packageTools audit auditForPackage: e) 
				ifNotEmpty: [:aColl | res at: e name put: aColl]].	
	^res
%

category: 'other'
method: RwPrjAuditTool
auditForProjectNamed: aProjectName

	^self auditForProject: (Rowan image loadedProjectNamed: aProjectName)
%

category: 'other'
method: RwPrjAuditTool
auditForProjectsNamed: aCol
"audit all named projects"
	
	| res |
	res := Array new.
		aCol do: [:prjName | res addAll: (self auditForProjectNamed: prjName )	].
	^res
%

category: 'other'
method: RwPrjAuditTool
auditProjectsNamed: aCol
"audit all named projects"
	
	| res |
	res := Array new.
		aCol do: [:prjName | res addAll: (self auditForProjectNamed: prjName )	].
	^res
%

! Class implementation for 'RwPrjBrowserToolV2'

!		Instance methods for 'RwPrjBrowserToolV2'

category: 'class browsing'
method: RwPrjBrowserToolV2
addOrUpdateClassDefinition: className type: type superclass: superclassName instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: category packageName: packageName constraints: constraintsArray options: optionsArray

	| loadedPackage loadedProject loadedClass theOptions theConstraints |
	loadedPackage := self
		_loadedPackageNamed: packageName
		ifAbsent: [ self error: 'No package named ' , packageName printString , ' found' ].
	loadedProject := loadedPackage loadedProject.
	anArrayOfPoolDicts isEmpty
		ifFalse: [ self error: 'poolDictionaries not supported yet' ].
	loadedClass := self _loadedClassNamed: className ifAbsent: [  ].
	theOptions := optionsArray collect: [:each | each asString ].
	(constraintsArray isKindOf: Array)
		ifTrue: [
			theConstraints := {}.
			constraintsArray do: [:ar |
				(ar isKindOf: Array)
					ifTrue: [ theConstraints add: { (ar at: 1) asString . (ar at: 2) name asString } ]
					ifFalse: [ theConstraints add: ar name asString ] ] ]
		ifFalse: [
			theConstraints := constraintsArray
				ifNil: [ #() ]
				ifNotNil: [ constraintsArray ]].
	loadedClass
		ifNil: [ 
			| classDef |
			"create a new class"
			classDef := RwClassDefinition
				newForClassNamed: className
				super: superclassName
				instvars: (anArrayOfStrings collect: [ :each | each asString ])
				classinstvars: (anArrayOfClassInstVars collect: [ :each | each asString ])
				classvars: (anArrayOfClassVars collect: [ :each | each asString ])
				category: category
				comment: nil
				pools: #()
				type: type.
			classDef gs_options: theOptions.
			classDef gs_constraints: theConstraints.
			self createClass: classDef inPackageNamed: packageName ]
		ifNotNil: [ 
			self class edit
				definitionsForClassNamed: className
				ifFound: [ :classDef :packageDef :projectDef | 
					| classProjectDef projectSetDef |
					classProjectDef := projectDef.
					projectSetDef := RwProjectSetDefinition new.
					projectSetDef addProject: classProjectDef.
					classDef
						superclassName: superclassName;
						instVarNames: (anArrayOfStrings collect: [ :each | each asString ]);
						classVarNames: (anArrayOfClassVars collect: [ :each | each asString ]);
						classInstVarNames: (anArrayOfClassInstVars collect: [ :each | each asString ]);
						gs_options: theOptions;
						gs_constraints: theConstraints;
						category: category;
						yourself.
					loadedClass packageName = packageName
						ifFalse: [ 
							| thePackageDef |
							"move class to another package"
							packageDef removeClassDefinition: classDef.
							thePackageDef := classProjectDef
								packageNamed: packageName
								ifAbsent: [ 
									| packageProjectDef |
									"loadedPackage in a different project"
									packageProjectDef := loadedPackage loadedProject asDefinition.
									projectSetDef addProject: packageProjectDef.
									packageProjectDef packageNamed: packageName ].
							thePackageDef addClassDefinition: classDef ].
					self class load loadProjectSetDefinition: projectSetDef ]
				ifAbsent: [ 
					"shouldn't happen ... loadedClass known to exist"
					self error: 'unexpected missing class ' , className printString ] ].
	^ (self _loadedClassNamed: className ifAbsent: [  ]) handle currentVersion
%

category: 'class browsing'
method: RwPrjBrowserToolV2
addOrUpdateClassDefinition: className type: type superclass: superclassName instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: category packageName: packageName options: optionsArray

	^ self 
		addOrUpdateClassDefinition: className
		type: type 
		superclass: superclassName 
		instVarNames: anArrayOfStrings 
		classVars: anArrayOfClassVars 
		classInstVars: anArrayOfClassInstVars 
		poolDictionaries: anArrayOfPoolDicts 
		category: category 
		packageName: packageName 
		constraints: #() 
		options: optionsArray
%

category: 'method browsing'
method: RwPrjBrowserToolV2
addOrUpdateMethod: methodSource dictionaries: aSymbolList inProtocol: protocol forClassNamed: className isMeta: isMeta inPackageNamed: packageName
	"If the method is already installed in a different package, remove the method from that package.
	 If package name matches the name of the package of the class definition, then add the method 
		to the class definition.
	 If there is no matching class extension or the package name does not match, add the method 
		to a class extension in the named package.
	 Return the resulting compiled method"

	| projectTools loadedPackage classExtensionDef methodDef updateBlock projectDefinition packageDefinition projectSetDefinition loadedMethodToBeRemoved packageConvention |
	projectSetDefinition := RwProjectSetDefinition new.

	methodDef := RwMethodDefinition newForSource: methodSource protocol: protocol.
	loadedMethodToBeRemoved := self
		_loadedMethod: methodDef selector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ 
			"no pre-existing method for this selector installed"
			 ].

	projectTools := Rowan projectTools.
	updateBlock := [ :cDef :pDef | 
	loadedMethodToBeRemoved
		ifNil: [ 
			"no method needs to be remove, just add the method to the class or extension def"
			isMeta
				ifTrue: [ cDef addClassMethodDefinition: methodDef ]
				ifFalse: [ cDef addInstanceMethodDefinition: methodDef ] ]
		ifNotNil: [ :loadedMethod | 
			| loadedPackageForMethod |
			loadedPackageForMethod := loadedMethod loadedPackage.
			loadedPackageForMethod name = packageName
				ifTrue: [ 
					"loaded method being updated in same package, sjust update the method def"
					isMeta
						ifTrue: [ cDef updateClassMethodDefinition: methodDef ]
						ifFalse: [ cDef updateInstanceMethodDefinition: methodDef ] ]
				ifFalse: [ 
					| loadedClassOrExtension projectDef packageDef crDef |
					"loaded method in different package than new version of method"
					projectDef := loadedPackageForMethod loadedProject asDefinition.
					projectDef name = pDef name
						ifTrue: [ 
							"both packages are in same project"
							projectDef := pDef ]
						ifFalse: [ 
							"each package in a different project, will need to load loaded method project as well"
							projectSetDefinition addProject: projectDef ].
					packageDef := projectDef packageNamed: loadedPackageForMethod name.
					loadedClassOrExtension := loadedMethod loadedClass.
					crDef := loadedClassOrExtension isLoadedClass
						ifTrue: [ packageDef classDefinitions at: loadedClassOrExtension name ]
						ifFalse: [ packageDef classExtensions at: loadedClassOrExtension name ].	"remove the method from one package and add it to the other"
					isMeta
						ifTrue: [ 
							crDef removeClassMethod: methodDef selector.
							cDef addClassMethodDefinition: methodDef ]
						ifFalse: [ 
							crDef removeInstanceMethod: methodDef selector.
							cDef addInstanceMethodDefinition: methodDef ] ] ].
	projectSetDefinition addProject: pDef.
	projectTools load
		loadProjectSetDefinition: projectSetDefinition
		symbolList: aSymbolList.
	(self _loadedMethod: methodDef selector inClassNamed: className isMeta: isMeta)
		handle ].

	self
		definitionsForClassNamed: className
		ifFound: [ :classDef :packageDef :projectDef | 
			packageDef name = packageName
				ifTrue: [ 
					packageConvention := projectDef packageConvention.
					packageConvention = 'Rowan'
						ifTrue: [ 
							"method protocol is not restricted"
							 ]
						ifFalse: [ 
							packageConvention = 'RowanHybrid'
								ifTrue: [ 
									(protocol equalsNoCase: '*' , packageName)
										ifTrue: [ 
											self
												error:
													'The supplied method protocol ' , protocol printString
														,
															' does not follow the expected package convention for ''RowanHybrid''. The protocol indicates an extension method for the package in which the class resides, which is not an extension method' ] ]
								ifFalse: [ self error: 'Unsupported packageConvention ' , packageConvention printString ] ].
					^ updateBlock value: classDef value: projectDef ]
				ifFalse: [ 
					"the named package is different from the class definition package"
					 ] ]
		ifAbsent: [ 
			"no loaded class definition, so we probably need to add a class extension"
			 ].
	loadedPackage := Rowan image
		loadedPackageNamed: packageName
		ifAbsent: [ self error: 'A package named ' , packageName printString , ' was not found.' ].

	projectDefinition := loadedPackage loadedProject asDefinition.
	packageDefinition := projectDefinition packageNamed: packageName.

	packageConvention := projectDefinition packageConvention.
	packageConvention = 'Rowan'
		ifTrue: [ 
			"method protocol is not restricted"
			 ]
		ifFalse: [ 
			packageConvention = 'RowanHybrid'
				ifTrue: [ 
					| expectedProtocol |
					expectedProtocol := loadedPackage asExtensionName.
					(expectedProtocol equalsNoCase: protocol)
						ifFalse: [ 
							self
								error:
									'The supplied method protocol ' , protocol printString
										, ' does not follow the expected package convention '
										, expectedProtocol printString , ' for ''RowanHybrid''' ] ]
				ifFalse: [ self error: 'Unsupported packageConvention ' , packageConvention printString ] ].

	classExtensionDef := packageDefinition classExtensions
		at: className
		ifAbsent: [ 
			"no existing class extension definition ... create a new one"
			classExtensionDef := RwClassExtensionDefinition newForClassNamed: className.

			packageDefinition addClassExtensionDefinition: classExtensionDef.
			classExtensionDef ].

	^ updateBlock value: classExtensionDef value: projectDefinition
%

category: 'method browsing'
method: RwPrjBrowserToolV2
addOrUpdateMethod: methodSource inProtocol: hybridPackageName forClassNamed: className isMeta: isMeta
	"If the method is already installed in a different package, remove the method from that package.
	 If package name matches the name of the package of the class definition, then add the method 
		to the class definition.
	 If there is no matching class extension or the package name does not match, add the method 
		to a class extension in the named package.
	 Return the resulting compiled method"

	"a hybrid package name has a leading '*' followed by the name of a package ... 
 		where the hybrid package name is not expected to preserve case"

	"this method is only needed for the transition from Oscar 3.x to Oscar 4.0 (Rowan V2 aware Jadeite"

	| methodDef loadedProject loadedPackage couldBeHybrid hybridLoadedPackage hybridLoadedProject loadedClass |
	couldBeHybrid := (hybridPackageName at: 1) = $*.
	couldBeHybrid
		ifTrue: [ 
			hybridLoadedPackage := Rowan image
				loadedHybridPackageNamed: hybridPackageName
				ifAbsent: [  ].
			hybridLoadedPackage
				ifNotNil: [ 
					| pkgConvention |
					hybridLoadedProject := hybridLoadedPackage loadedProject.
					pkgConvention := hybridLoadedProject packageConvention.
					(pkgConvention = 'RowanHybrid' or: [ pkgConvention = 'Monticello' ])
						ifTrue: [ 
							| classPackageName "everything is cool" |
							classPackageName := (Rowan image objectNamed: className) rowanPackageName.
							classPackageName = hybridLoadedPackage name
								ifTrue: [ 
									"https://github.com/GemTalk/Rowan/issues/802"
									self
										error:
											'extension category name ' , hybridPackageName printString
												, '  must not match class package name (' , classPackageName , ')' ] ]
						ifFalse: [ 
							"the project associated with the hybridPackageName _is NOT_ using the `RowanHybrid` package convention - questionable use of hybrid convention in a non-hybrid project"
							hybridLoadedProject := nil ] ] ].
	methodDef := RwMethodDefinition
		newForSource: methodSource
		protocol: hybridPackageName.
	(self
		_loadedMethod: methodDef selector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [  ])
		ifNil: [ 
			"new method extract project information from the class"
			(Rowan image loadedClassNamed: className ifAbsent: [  ])
				ifNil: [ 
					"unpackaged class?"
					couldBeHybrid
						ifTrue: [ 
							hybridLoadedPackage
								ifNil: [ 
									self
										error:
											'A package for package name ' , hybridPackageName printString
												, ' was not found.' ].
							hybridLoadedProject
								ifNil: [ 
									self
										error:
											'Attempt to add a method to an unpackaged class ' , className printString
												, ', while using `hybrid-style` method protocol '
												, hybridPackageName printString
												,
													' for a project that does not use the `RowanHybrid` package convention.' ].
							loadedPackage := hybridLoadedPackage.
							loadedProject := hybridLoadedProject ]
						ifFalse: [ 
							| theBehavior |
							"Adding unpackaged method to an unpackaged class - if permitted"
							theBehavior := Rowan image objectNamed: className.
							isMeta
								ifTrue: [ theBehavior := theBehavior class ].
							RwPerformingUnpackagedEditNotification
								signal:
									'Attempt to add or modify an unpackage method in the class '
										, className printString
										, '. The modification will not be tracked by Rowan'.
							^ theBehavior
								compileMethod: methodSource
								dictionaries: Rowan image symbolList
								category: hybridPackageName
								environmentId: 0	"Notification resumed, so continue with add/modify" ] ]
				ifNotNil: [ :theLoadedClass | 
					loadedClass := theLoadedClass.
					couldBeHybrid
						ifTrue: [ 
							hybridLoadedPackage
								ifNil: [ 
									self
										error:
											'A package for package name ' , hybridPackageName printString
												, ' was not found.' ].
							hybridLoadedProject
								ifNil: [ 
									self
										error:
											'Attempt to add a method to an unpackaged class ' , className printString
												, ', while using `hybrid-style` method protocol '
												, hybridPackageName printString ].
							loadedPackage := hybridLoadedPackage.
							loadedProject := hybridLoadedProject ]
						ifFalse: [ 
							"new method for packaged class, so add method to the class' package"
							loadedProject := theLoadedClass loadedProject.
							loadedPackage := theLoadedClass loadedPackage ] ] ]
		ifNotNil: [ :loadedMethod | 
			| isHybrid |
			"change to existing loaded method - keep in mind that the method could be being moved between packages via protocol change"
			loadedProject := loadedMethod loadedProject.
			loadedClass := loadedMethod loadedClass.
			isHybrid := loadedProject packageConvention = 'RowanHybrid'.
			couldBeHybrid
				ifTrue: [ 
					"protocol has leading *"
					hybridLoadedPackage
						ifNil: [ 
							"questionable use of hybrid protocol in a non-RowanHybrid project, but legal"
							loadedPackage := loadedMethod loadedPackage ]
						ifNotNil: [ 
							isHybrid
								ifTrue: [ 
									"the current project for the method is using the `RowanHybrid` package convention"
									hybridLoadedProject
										ifNil: [ 
											"VERY questionable use of hybrid protocol, package matching the hyybrid protocol was found, but the project of the package is not using `RowanHybrid` package convention, while the current project _IS_ using hybrid protocol --- ILLEGAL"
											self
												error:
													'Attempt to use RowanHybrid convention ' , hybridPackageName printString
														, ' for a package ' , hybridLoadedPackage name printString
														, ' that belongs to a project '
														, hybridLoadedPackage loadedProject name printString
														, '  that is not using `RowanHybrid` package convention.' ]
										ifNotNil: [ 
											"moving from one hybrid package to another (or same) hybrid package"
											loadedPackage := hybridLoadedPackage.
											loadedProject := hybridLoadedProject ] ]
								ifFalse: [ 
									"the current project is NOT using the `RowanHybrid` package convention"
									hybridLoadedProject
										ifNil: [ 
											"Questionable use of hybrid protocol, package matching the hyybrid protocol was found, but the project of the package is not using `RowanHybrid` package convention"
											"USE THE CURRENT PACKAGE AND PROJECT"
											loadedPackage := loadedMethod loadedPackage ]
										ifNotNil: [ 
											"moving from current package to a hybrid project and package"
											loadedPackage := hybridLoadedPackage.
											loadedProject := hybridLoadedProject ] ] ] ]
				ifFalse: [ 
					"use the existing package for method"
					loadedPackage := loadedMethod loadedPackage ] ].

	loadedPackage loadedProject == loadedProject
		ifFalse: [ 
			self
				error:
					'internal error - the expected loaded project ' , loadedProject name printString
						, ' does not match the actual loaded project '
						, loadedPackage loadedProject name printString , ' of the package '
						, loadedPackage name printString , ' for the method ' , loadedClass name
						,
							(isMeta
								ifTrue: [ ' class ' ]
								ifFalse: [ '' ]) , '>>' , methodDef selector ].

	^ self
		addOrUpdateMethodDefinition: methodDef
		forClassNamed: className
		isMeta: isMeta
		inLoadedPackage: loadedPackage
%

category: 'method browsing'
method: RwPrjBrowserToolV2
addOrUpdateMethod: methodSource inProtocol: protocol forClassNamed: className isMeta: isMeta inPackageNamed: packageName
	"If the method is already installed in a different package, remove the method from that package.
	 If package name matches the name of the package of the class definition, then add the method 
		to the class definition.
	 If there is no matching class extension or the package name does not match, add the method 
		to a class extension in the named package.
	 Return the resulting compiled method"

	^ self
		addOrUpdateMethod: methodSource
		dictionaries: Rowan image symbolList
		inProtocol: protocol
		forClassNamed: className
		isMeta: isMeta
		inPackageNamed: packageName
%

category: 'method browsing'
method: RwPrjBrowserToolV2
addOrUpdateMethodDefinition: methodDef forClassNamed: className isMeta: isMeta inLoadedPackage: loadedPackage
	"If the method is already installed in a different package, remove the method from that package.
	 If package name matches the name of the package of the class definition, then add the method 
		to the class definition.
	 If there is no matching class extension or the package name does not match, add the method 
		to a class extension in the named package.
	 Return the resulting compiled method"

	| projectTools classExtensionDef updateBlock projectDefinition packageDefinition projectSetDefinition loadedMethodToBeRemoved |
	projectSetDefinition := RwProjectSetDefinition new.

	loadedMethodToBeRemoved := self
		_loadedMethod: methodDef selector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ 
			"no pre-existing method for this selector installed"
			 ].

	projectTools := Rowan projectTools.
	updateBlock := [ :cDef :pDef | 
	loadedMethodToBeRemoved
		ifNil: [ 
			"no method needs to be remove, just add the method to the class or extension def"
			isMeta
				ifTrue: [ cDef addClassMethodDefinition: methodDef ]
				ifFalse: [ cDef addInstanceMethodDefinition: methodDef ] ]
		ifNotNil: [ :loadedMethod | 
			| loadedPackageForMethod |
			loadedPackageForMethod := loadedMethod loadedPackage.
			loadedPackageForMethod == loadedPackage
				ifTrue: [ 
					"loaded method being updated in same package, sjust update the method def"
					isMeta
						ifTrue: [ cDef updateClassMethodDefinition: methodDef ]
						ifFalse: [ cDef updateInstanceMethodDefinition: methodDef ] ]
				ifFalse: [ 
					| loadedClassOrExtension projectDef packageDef crDef |
					"loaded method in different package than new version of method"
					projectDef := loadedPackageForMethod loadedProject asDefinition.
					projectDef name = pDef name
						ifTrue: [ 
							"both packages are in same project"
							projectDef := pDef ]
						ifFalse: [ 
							"each package in a different project, will need to load loaded method project as well"
							projectSetDefinition addProject: projectDef ].
					packageDef := projectDef packageNamed: loadedPackageForMethod name.
					loadedClassOrExtension := loadedMethod loadedClass.
					crDef := loadedClassOrExtension isLoadedClass
						ifTrue: [ packageDef classDefinitions at: loadedClassOrExtension name ]
						ifFalse: [ packageDef classExtensions at: loadedClassOrExtension name ].	"remove the method from one package and add it to the other"
					isMeta
						ifTrue: [ 
							crDef removeClassMethod: methodDef selector.
							cDef addClassMethodDefinition: methodDef ]
						ifFalse: [ 
							crDef removeInstanceMethod: methodDef selector.
							cDef addInstanceMethodDefinition: methodDef ] ] ].
	projectSetDefinition addProject: pDef.
	projectTools load loadProjectSetDefinition: projectSetDefinition.
	(self _loadedMethod: methodDef selector inClassNamed: className isMeta: isMeta)
		handle ].

	self
		definitionsForClassNamed: className
		ifFound: [ :classDef :packageDef :projectDef | 
			packageDef name = loadedPackage name
				ifTrue: [ ^ updateBlock value: classDef value: projectDef ]
				ifFalse: [ 
					"the named package is different from the class definition package"
					 ] ]
		ifAbsent: [ 
			"no loaded class definition, so we probably need to add a class extension"
			 ].
	projectDefinition := loadedPackage loadedProject asDefinition.
	packageDefinition := projectDefinition packageNamed: loadedPackage name.

	classExtensionDef := packageDefinition classExtensions
		at: className
		ifAbsent: [ 
			"no existing class extension definition ... create a new one"
			classExtensionDef := RwClassExtensionDefinition newForClassNamed: className.

			packageDefinition addClassExtensionDefinition: classExtensionDef.
			classExtensionDef ].

	^ updateBlock value: classExtensionDef value: projectDefinition
%

category: 'package browsing'
method: RwPrjBrowserToolV2
addPackageNamed: packageName toComponentNamed: componentName andProjectNamed: projectName
	| projectDefinition |
	projectDefinition := self _projectNamed: projectName.
	projectDefinition addPackageNamed: packageName toComponentNamed: componentName.
	projectDefinition load
%

category: 'package browsing'
method: RwPrjBrowserToolV2
addPackageNamed: packageName toProjectNamed: projectName

	^ self addPackageNamed: packageName toComponentNamed: 'Core' andProjectNamed: projectName
%

category: 'project browsing'
method: RwPrjBrowserToolV2
addRowanSymbolDictionariesToPersistentSymbolList

	self addRowanSymbolDictionariesToPersistentSymbolListFor: System myUserProfile
%

category: 'project browsing'
method: RwPrjBrowserToolV2
addRowanSymbolDictionariesToPersistentSymbolListFor: userProfile

	| systemUser |
	systemUser := AllUsers userWithId: 'SystemUser'.
	self _rowanSymbolDictionaryNames do: [:symDictName |
		| aSymbolDictionary anIndex |
		aSymbolDictionary := systemUser objectNamed: symDictName.
		anIndex := userProfile symbolList size + 1.
		userProfile
			insertDictionary: aSymbolDictionary at: anIndex ]
%

category: 'project browsing'
method: RwPrjBrowserToolV2
addRowanSymbolDictionariesToTransientSymbolList
  | systemUser |
  systemUser := AllUsers userWithId: 'SystemUser'.
  self _rowanSymbolDictionaryNames
    do: [ :symDictName | 
      | aSymbolDictionary anIndex transient |
      transient := GsSession currentSession symbolList.
      aSymbolDictionary := systemUser objectNamed: symDictName.
      anIndex := transient size + 1.
      transient insertObject: aSymbolDictionary at: anIndex ]
%

category: 'class browsing'
method: RwPrjBrowserToolV2
classCreationTemplateForClass: aClass

	^ self classCreationTemplateForClass: aClass hybridBrowser: false
%

category: 'class browsing'
method: RwPrjBrowserToolV2
classCreationTemplateForClass: aClass hybridBrowser: hybridBrowser

	| result anArray lfsp newByteSubclass civs superClass className thePackageName nonRowanClass |
	result := String new.
	superClass := aClass superclass.
	className := aClass name asString.
	superClass
		ifNil: [ result addAll: 'nil' ]
		ifNotNil: [ result addAll: superClass name asString ].
	lfsp := Character lf asString tab.
	newByteSubclass := false.
	thePackageName := aClass rowanPackageName.
	nonRowanClass := thePackageName = Rowan unpackagedName.
	(aClass isBytes _and: [ superClass isBytes not ])
		ifTrue: [ 
			nonRowanClass
				ifTrue: [ result addAll: ' byteSubclass: ''' ]
				ifFalse: [ result addAll: ' rwByteSubclass: ''' ].
			result
				addAll: className;
				addLast: $'.
			newByteSubclass := true ]
		ifFalse: [ 
			(aClass isIndexable and: [superClass isIndexable not])
				ifTrue: [ 
					nonRowanClass
						ifTrue: [ result addAll: ' indexableSubclass: ''' ]
						ifFalse: [ result addAll: ' rwIndexableSubclass: ''' ].
					result
						addAll: className;
						addLast: $' ]
				ifFalse: [ 
					nonRowanClass
						ifTrue: [ result addAll: ' subclass: ''' ]
						ifFalse: [ result addAll: ' rwSubclass: ''' ].
					result
						addAll: className;
						addLast: $' ] ].
	newByteSubclass
		ifFalse: [ 
			result
				addAll: lfsp;
				addAll: 'instVarNames: #(';
				addAll: (aClass _instVarNamesWithSeparator: lfsp , '                 ');
				add: $) ].
	result
		addAll: lfsp;
		addLast: 'classVars: #('.
	aClass _sortedClassVarNames
		do: [ :aKey | 
			result addLast: $ .
			(aKey includesValue: $')
				ifTrue: [ result addAll: aKey _asSource ]
				ifFalse: [ result addAll: aKey ] ].
	result addLast: $).
	result
		addAll: lfsp;
		addLast: 'classInstVars: #('.
	civs := aClass class allInstVarNames.
	civs removeFrom: 1 to: aClass class superClass instSize.
	civs
		do: [ :civName | 
			result addLast: $ .
			(civName includesValue: $')
				ifTrue: [ result addAll: civName _asSource ]
				ifFalse: [ result addAll: civName ] ].
	result addLast: $).
	result
		addAll: lfsp;
		addAll: 'poolDictionaries: '.
	result addAll: '#()'.	"ignored for now"
	nonRowanClass
		ifTrue: [ 
			"if the class is unpackaged, then we need to provide for the specification of symbol dictionary into which the class will be installed"
			result
				addAll: lfsp;
				addAll: 'inDictionary: '.
			anArray := Rowan image symbolList dictionariesAndSymbolsOf: aClass.
			anArray isEmpty
				ifTrue: [ result addAll: '''''' ]
				ifFalse: [ result addAll: ((anArray at: 1) at: 1) name asString ] ]
		ifFalse: [ 
			result
				addAll: lfsp;
				addAll: 'category: '.
			result addAll: aClass category printString.
			(hybridBrowser and: [ thePackageName = aClass category ])
				ifFalse: [ 
					result
						addAll: lfsp;
						addAll: 'packageName: '.
					result addAll: thePackageName printString ] ].
	aClass _hasConstraints
		ifTrue: [ 
			result
				add: lfsp;
				add: aClass _rwDefinitionOfConstraints ].
	result
		add: lfsp;
		add: aClass _rwOptionsForDefinition.
	result add: Character lf.
	^ result
%

category: 'class browsing'
method: RwPrjBrowserToolV2
classCreationTemplateForSubclassOf: superclassName category: category

	^ self
		classCreationTemplateForSubclassOf: superclassName
		category: category
		packageName: nil
%

category: 'class browsing'
method: RwPrjBrowserToolV2
classCreationTemplateForSubclassOf: superclassName category: category packageName: packageName

	^ self
		classCreationTemplateForSubclassOf: superclassName
		className: 'NameOfSubclass'
		category: category
		packageName: packageName
%

category: 'class browsing'
method: RwPrjBrowserToolV2
classCreationTemplateForSubclassOf: superclassName className: className category: category

	^ self
		classCreationTemplateForSubclassOf: superclassName
		className: className
		category: category
		packageName: nil
%

category: 'class browsing'
method: RwPrjBrowserToolV2
classCreationTemplateForSubclassOf: superclassName className: className category: category packageName: packageName

	^ self
		classCreationTemplateForSubclassOf: superclassName
		className: className
		type: 'normal'
		category: category
		packageName: packageName
%

category: 'class browsing'
method: RwPrjBrowserToolV2
classCreationTemplateForSubclassOf: superclassName className: className type: classType category: category packageName: packageNameOrNil

	"classType may be 'normal', 'byteSubclass', or 'variable'"

	| result lfsp superClass |
	result := String new.
	superClass := Rowan image objectNamed: superclassName.
	result addAll: superclassName.
	lfsp := Character lf asString tab.
	classType = 'normal'
		ifTrue: [ result addAll: ' rwSubclass: ' ].
	classType = 'variable'
		ifTrue: [ result addAll: ' rwIndexableSubclass: ' ].
	classType = 'byteSubclass'
		ifTrue: [ result addAll: ' rwByteSubclass: ' ].
	result addAll: className printString.
	classType ~= 'byteSubclass'
		ifTrue: [ 
			result
				addAll: lfsp;
				addAll: 'instVarNames: #()' ].
	result
		addAll: lfsp;
		addLast: 'classVars: #()';
		addAll: lfsp;
		addLast: 'classInstVars: #()';
		addAll: lfsp;
		addAll: 'poolDictionaries: #()'.
	result
		addAll: lfsp;
		addAll: 'category: ';
		addAll: category printString.
	packageNameOrNil
		ifNotNil: [ 
			result
				addAll: lfsp;
				addAll: 'packageName: '.
			result addAll: packageNameOrNil printString ].
	result
		add: lfsp;
		add: 'options: #()';
		add: Character lf.
	^ result
%

category: 'class browsing'
method: RwPrjBrowserToolV2
classCreationTemplateForSubclassOf: superclassName className: className type: classType instanceVariablesString: instanceVariablesString classVariablesString: classVariablesString classInstanceVariablesString: classInstanceVariablesString poolDictionariesString: poolDictionariesString 
comment: comment category: category

	"classType may be 'normal', 'byteSubclass', or 'variable'"

	| result lfsp |
	result := String new.
	lfsp := Character lf asString tab.
	comment isEmpty 
		ifFalse: [ 
			result 
				addAll: '(';
				addAll: lfsp ].
	result
		addAll: superclassName.
	classType = 'normal'
		ifTrue: [ result addAll: ' rwSubclass: ' ].
	classType = 'variable'
		ifTrue: [ result addAll: ' rwIndexableSubclass: ' ].
	classType = 'byteSubclass'
		ifTrue: [ result addAll: ' rwByteSubclass: ' ].
	result addAll: className.
	classType ~= 'byteSubclass'
		ifTrue: [ 
			result
				addAll: lfsp;
				addAll: 'instVarNames: #(' , instanceVariablesString , ')' ].
	result
		addAll: lfsp;
		addLast: 'classVars: #(' , classVariablesString , ')';
		addAll: lfsp;
		addLast: 'classInstVars: #(' , classInstanceVariablesString , ')';
		addAll: lfsp;
		addAll: 'poolDictionaries: #(' , poolDictionariesString , ')'.
	result
		addAll: lfsp;
		addAll: 'category: ';
		addAll: category.
	result
		add: lfsp;
		add: 'options: #()';
		add: Character lf.
	comment isEmpty 
		ifFalse: [ 
			result 
				addAll: ') ';
				addAll: lfsp;
				addAll: 'comment: ';
				addAll: comment;
				addAll: lfsp ].
	^ result
%

category: 'definition updating'
method: RwPrjBrowserToolV2
classNamed: className updateDefinition: updateBlock

	^ self
		classNamed: className
		updateDefinition: updateBlock
		ifAbsent: [ 
			self
				error:
					'expected class definition for class ' , className printString , ' not found.' ]
%

category: 'definition updating'
method: RwPrjBrowserToolV2
classNamed: className updateDefinition: updateBlock ifAbsent: absentBlock

	| projectDefinition classDefinition |
	self class edit
		definitionsForClassNamed: className
		ifFound: [ :classDef :packageDef :projectDef | 
			projectDefinition := projectDef.
			classDefinition := classDef ]
		ifAbsent: [ ^ absentBlock value ].

	updateBlock value: classDefinition.
	self class load loadProjectDefinition: projectDefinition
%

category: 'class browsing'
method: RwPrjBrowserToolV2
copyClassNamed: className to: newName

	"anser the new copy of the class"

	| projectSetDefinition |
	projectSetDefinition := self _copyClassDefinitionNamed: className to: newName.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	^ Rowan globalNamed: newName
%

category: 'class browsing'
method: RwPrjBrowserToolV2
createClass: classDefinition inPackageNamed: packageName
	| loadedPackage projectDefinition |
	loadedPackage := Rowan image
		loadedPackageNamed: packageName
		ifAbsent: [ self error: 'The package named ' , packageName printString , ' was not found' ].
	projectDefinition := loadedPackage loadedProject asDefinition.

	Rowan projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

	projectDefinition load
%

category: 'project browsing'
method: RwPrjBrowserToolV2
exposeRowanToolsSymbolDictionary

	| transient size dict |
	transient := Rowan image symbolList.
	size := transient size.
	dict := (AllUsers userWithId: 'SystemUser') objectNamed: 'RowanTools'.
	transient insertObject: dict at: size + 1.
%

category: 'method browsing'
method: RwPrjBrowserToolV2
isExtensionMethod: methodSelector forClassNamed: className isMeta: isMeta

	"Answer true if the specified method is a Rowan extension method"

	| loadedMethod loadedClassOrExtension loadedPackage |

	loadedMethod := self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ 
			"No loaded method found ... it is not an extension method"
			^ false ].
	loadedPackage := loadedMethod loadedPackage.

	loadedClassOrExtension := loadedPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- no class or extension for ' , className printString
						, ' in package ' , loadedPackage name printString , '.' ].

	^loadedClassOrExtension isLoadedClassExtension
%

category: 'class browsing'
method: RwPrjBrowserToolV2
moveClassNamed: className toPackage: packageName
	"Move class to <packageName>, whether or not it has been packaged. The methods in the class that are in the
		original package of the class are also moved to the new package. If the class was originally unpackaged,
		then only unpackaged methods (class and instance side) are moved to the new package."

	| class |
	class := Rowan globalNamed: className.
	(self _loadedClassNamed: className ifAbsent: [  ])
		ifNil: [ 
			| instanceSelectors classSelectors classPackageName |
			"unpackaged class"
			classPackageName := Rowan unpackagedName.
			instanceSelectors := Set new.
			classSelectors := Set new.
			class
				methodsDo: [ :selector :method | 
					method rowanPackageName = classPackageName
						ifTrue: [ instanceSelectors add: selector ] ].
			class class
				methodsDo: [ :selector :method | 
					method rowanPackageName = classPackageName
						ifTrue: [ classSelectors add: selector ] ].
			Rowan packageTools adopt
				adoptClassNamed: className
				instanceSelectors: instanceSelectors
				classSelectors: classSelectors
				intoPackageNamed: packageName ]
		ifNotNil: [ :loadedClass | 
			| destinationLoadedPackage sourceLoadedPackage projectSetDefinition projectDef packageDef clsDef destProjectDef srcPackageDef srcClsDef destPackageDef |
			"packaged class"
			destinationLoadedPackage := Rowan image loadedPackageNamed: packageName.
			sourceLoadedPackage := loadedClass loadedPackage.
			destinationLoadedPackage name = sourceLoadedPackage name
				ifTrue: [ 
					"class is already in the desired package, never mind"
					^ self ].
			projectSetDefinition := RwProjectSetDefinition new.
			projectDef := sourceLoadedPackage loadedProject asDefinition.
			packageDef := projectDef packageNamed: sourceLoadedPackage name.
			clsDef := packageDef classDefinitions at: className.

			projectSetDefinition addProject: projectDef.
			destinationLoadedPackage loadedProject name = projectDef name
				ifTrue: [ destProjectDef := projectDef ]
				ifFalse: [ 
					"class is moving to a different project"
					destProjectDef := destinationLoadedPackage loadedProject asDefinition.
					projectSetDefinition addProject: destProjectDef ].

			srcPackageDef := projectDef packageNamed: sourceLoadedPackage name.
			srcClsDef := srcPackageDef removeClassNamed: className.

			destPackageDef := destProjectDef packageNamed: destinationLoadedPackage name.
			(destPackageDef classDefinitions at: className ifAbsent: [  ])
				ifNotNil: [ 
					self
						error:
							'A class definition for the class ' , className printString
								, ' already exists in the destination package '
								, packageName printString ].

			destPackageDef classDefinitions at: className put: srcClsDef.

			Rowan projectTools load loadProjectSetDefinition: projectSetDefinition ]
%

category: 'method browsing'
method: RwPrjBrowserToolV2
moveMethod: methodSelector forClassNamed: className isMeta: isMeta toPackage: packageName
	"Move the method into <packageName>, whether or not it has been packaged"

	(self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [  ])
		ifNil: [ 
			"adopt an unpackaged method into the named package"
			Rowan packageTools adopt
				adoptMethod: methodSelector
				inClassNamed: className
				isMeta: isMeta
				intoPackageNamed: packageName ]
		ifNotNil: [ :loadedMethodToBeMoved | 
			| srcLoadedMethodPackage srcLoadedClassPackage srcLoadedClassOrExtension projectDef packageDef clsDef projectSetDefinition destinationLoadedPackage methodDef beh category |
			"Move a packaged method to another package"
			beh := Rowan globalNamed: className.
			isMeta
				ifTrue: [ beh := beh class ].
			category := beh categoryOfSelector: methodSelector asSymbol.
			destinationLoadedPackage := Rowan image loadedPackageNamed: packageName.
			srcLoadedMethodPackage := loadedMethodToBeMoved loadedPackage.
			srcLoadedClassOrExtension := srcLoadedMethodPackage
				classOrExtensionForClassNamed: className
				ifAbsent: [ 
					self
						error:
							'Internal error -- no class or extension for ' , className printString
								, ' in package ' , srcLoadedMethodPackage name printString , '.' ].

			projectSetDefinition := RwProjectSetDefinition new.
			projectDef := srcLoadedMethodPackage loadedProject asDefinition.
			packageDef := projectDef packageNamed: srcLoadedMethodPackage name.
			clsDef := srcLoadedClassOrExtension isLoadedClass
				ifTrue: [ packageDef classDefinitions at: className ]
				ifFalse: [ packageDef classExtensions at: className ].

			projectSetDefinition addProject: projectDef.
			destinationLoadedPackage name = srcLoadedMethodPackage name
				ifTrue: [ 
					"method is not moving to a different package, only need to change the protocol for the method"
					methodDef := isMeta
						ifTrue: [ clsDef classMethodDefinitions at: methodSelector ]
						ifFalse: [ clsDef instanceMethodDefinitions at: methodSelector ].
					methodDef protocol: category ]
				ifFalse: [ 
					| destProjectDef "method is moving to a different package" destPackageDef destClsDef srcPackageDef srcClsDef |
					destinationLoadedPackage loadedProject name = projectDef name
						ifTrue: [ destProjectDef := projectDef ]
						ifFalse: [ 
							"method is moving to a different project"
							destProjectDef := destinationLoadedPackage loadedProject asDefinition.
							projectSetDefinition addProject: destProjectDef ].
					srcPackageDef := projectDef packageNamed: srcLoadedMethodPackage name.
					srcClsDef := srcLoadedClassOrExtension isLoadedClass
						ifTrue: [ srcPackageDef classDefinitions at: className ]
						ifFalse: [ srcPackageDef classExtensions at: className ].

					destPackageDef := destProjectDef
						packageNamed: destinationLoadedPackage name.

					destClsDef := srcLoadedClassPackage == destinationLoadedPackage
						ifTrue: [ 
							"method is not an extension method ... add the method to the class definition"
							destPackageDef classDefinitions
								at: className
								ifAbsent: [ 
									self
										error:
											'internal error - class ' , className printString
												, ' not found in expected package '
												, destinationLoadedPackage name printString ] ]
						ifFalse: [ 
							"method is to be added as an extension method"
							destPackageDef classExtensions
								at: className
								ifAbsentPut: [ RwClassExtensionDefinition newForClassNamed: className ] ].
					isMeta
						ifTrue: [ 
							methodDef := srcClsDef classMethodDefinitions at: methodSelector.
							methodDef protocol: category.
							destClsDef addClassMethodDefinition: methodDef.
							srcClsDef removeClassMethod: methodSelector ]
						ifFalse: [ 
							methodDef := srcClsDef instanceMethodDefinitions at: methodSelector.
							methodDef protocol: category.
							destClsDef addInstanceMethodDefinition: methodDef.
							srcClsDef removeInstanceMethod: methodSelector ] ].

			Rowan projectTools load loadProjectSetDefinition: projectSetDefinition ]
%

category: 'method browsing'
method: RwPrjBrowserToolV2
moveMethod: methodSelector forClassNamed: className isMeta: isMeta toProtocol: hybridPackageName

	"hybridPackageName is expected to be an existing protocol in className"

	| loadedMethodToBeMoved srcLoadedMethodPackage srcLoadedClassPackage srcLoadedClassOrExtension projectDef packageDef 
		clsDef projectSetDefinition destinationLoadedPackage methodDef |

	loadedMethodToBeMoved := self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ ].

	destinationLoadedPackage := (hybridPackageName at: 1) = $*
		ifTrue: [ 
			Rowan image
				loadedHybridPackageNamed: hybridPackageName
				ifAbsent: [ 
					self
						error:
							'A package for hybrid package name ' , hybridPackageName printString
								, ' was not found.' ] ]
		ifFalse: [ 
			| lc |
			lc := self
				_loadedClassNamed: className
				ifAbsent: [].
			lc 
				ifNil: [
					loadedMethodToBeMoved
						ifNil: [ 
							"unpackaged method moved to unpackaged category"
							^ (Rowan image objectNamed: className) _moveMethod: methodSelector toCategory: hybridPackageName ].
				RwPerformingUnpackagedEditNotification signal: 'Attempt to move a packaged method to an unpackaged class ', className printString, '. The unpackaged method will not be tracked by Rowan'.
				"Notification resumed, so continue with move"
				"Move packaged method to unpackaged category"
				"Disown the method, then move it to proper category" 
				Rowan packageTools disown disownMethod: methodSelector inClassNamed: className isMeta: isMeta.
				^ (Rowan image objectNamed: className) _moveMethod: methodSelector toCategory: hybridPackageName ].
			"use the loaded package for the class that contains the method"
			srcLoadedClassPackage := lc loadedPackage ].

	loadedMethodToBeMoved
		ifNil: [
			| instanceSelectors classSelectors res |
			"Moving an unpackaged method to a package in an unpackage class"
			"Move the method to the proper category and then adopt the method"
			isMeta
				ifTrue: [
					instanceSelectors := {}.
					classSelectors := { methodSelector } ]
				ifFalse: [
					instanceSelectors := { methodSelector }.
					classSelectors := {} ].
			res := (Rowan image objectNamed: className) _moveMethod: methodSelector toCategory: hybridPackageName.
			Rowan packageTools adopt
				adoptClassNamed: className 
				classExtension: true
				instanceSelectors: instanceSelectors 
				classSelectors: classSelectors 
				intoPackageNamed: destinationLoadedPackage name.
			^ res ].

	"Moving a packaged method to another package"
	srcLoadedMethodPackage := loadedMethodToBeMoved loadedPackage.
	srcLoadedClassOrExtension := srcLoadedMethodPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- no class or extension for ' , className printString
						, ' in package ' , srcLoadedMethodPackage name printString , '.' ].

	projectSetDefinition := RwProjectSetDefinition new.
	projectDef := srcLoadedMethodPackage loadedProject asDefinition.
	packageDef := projectDef packageNamed: srcLoadedMethodPackage name.
	clsDef := srcLoadedClassOrExtension isLoadedClass
		ifTrue: [ packageDef classDefinitions at: className ]
		ifFalse: [ packageDef classExtensions at: className ].

	projectSetDefinition addProject: projectDef.
	destinationLoadedPackage name = srcLoadedMethodPackage name
		ifTrue: [
			"method is not moving to a different package, only need to change the protocol for the method"

			methodDef := isMeta
				ifTrue: [ clsDef classMethodDefinitions at: methodSelector ]
				ifFalse: [ clsDef instanceMethodDefinitions at: methodSelector ].
			methodDef protocol: hybridPackageName ]
		ifFalse: [
			"method is moving to a different package"

			| destProjectDef destPackageDef destClsDef srcPackageDef  srcClsDef |
			destinationLoadedPackage loadedProject name = projectDef name 
				ifTrue: [ destProjectDef := projectDef ]
				ifFalse: [ 
					"method is moving to a different project"
					destProjectDef := destinationLoadedPackage loadedProject asDefinition.
					projectSetDefinition addProject: destProjectDef ].
			srcPackageDef := projectDef packageNamed: srcLoadedMethodPackage name.
			srcClsDef := srcLoadedClassOrExtension isLoadedClass
				ifTrue: [ srcPackageDef classDefinitions at: className ]
				ifFalse: [ srcPackageDef classExtensions at: className ].

			destPackageDef := destProjectDef packageNamed: destinationLoadedPackage name. 

			destClsDef := srcLoadedClassPackage == destinationLoadedPackage
				ifTrue: [
					"method is not an extension method ... add the method to the class definition"
					destPackageDef 
						classDefinitions 
							at: className 
							ifAbsent: [ 
								self error: 'internal error - class ', 
									className printString , 
									' not found in expected package ', 
									destinationLoadedPackage name printString ] ]
				ifFalse: [ 
					"method is to be added as an extension method" 
					destPackageDef classExtensions at: className ifAbsentPut: [ RwClassExtensionDefinition newForClassNamed: className ] ].
			isMeta
				ifTrue: [
					methodDef := srcClsDef classMethodDefinitions at: methodSelector.
					methodDef protocol: hybridPackageName.
					destClsDef addClassMethodDefinition: methodDef.
					srcClsDef removeClassMethod: methodSelector ]
				ifFalse: [ 
					methodDef := srcClsDef instanceMethodDefinitions at: methodSelector.
					methodDef protocol: hybridPackageName.
					destClsDef addInstanceMethodDefinition: methodDef.
					srcClsDef removeInstanceMethod: methodSelector ] ].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.
%

category: 'project browsing'
method: RwPrjBrowserToolV2
projectNamed: projectName

	^ self _projectNamed: projectName
%

category: 'definition updating'
method: RwPrjBrowserToolV2
projectNamed: projectName updateDefinition: updateBlock

	| projectDefinition |
	projectDefinition := self _projectNamed: projectName.
	updateBlock value: projectDefinition.
	self class load loadProjectDefinition: projectDefinition
%

category: 'definition updating'
method: RwPrjBrowserToolV2
projectsNamed: projectNames updateDefinition: updateBlock

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectNames
		do: [ :projectName | 
			| projectDefinition |
			projectDefinition := self _projectNamed: projectName.
			updateBlock value: projectDefinition.
			projectSetDefinition addProject: projectDefinition ].
	self class load loadProjectSetDefinition: projectSetDefinition
%

category: 'class browsing'
method: RwPrjBrowserToolV2
removeClassNamed: className

	| projectSetDefinition loadedClass loadedClassProjectDef  loadedClassProjectDefName loadedClassExtensions |
	projectSetDefinition := RwProjectSetDefinition new.

	loadedClass := self _loadedClassNamed: className ifAbsent: [ ].
	loadedClassExtensions := #(). "only apply if the class itself is not managed by Rowan"

	loadedClass 
		ifNil: [
			"Give developer a chance to handle and abort the removal of unpackaged class"
			RwPerformingUnpackagedEditNotification signal: 'Attempt to remove an unpackaged class ', className printString, '. The removal will not be tracked by Rowan'.
			"Notification resumed, so continue with removal ... actual removal is performed below"
				loadedClassExtensions := self _loadedClassExtensionsNamed: className ifAbsent: [ #() ] ]
		ifNotNil: [
			| loadedPackage projectDef packageDef classDef |
			loadedPackage := loadedClass loadedPackage.
			projectDef := loadedClass loadedProject asDefinition.
			packageDef := projectDef packageNamed: loadedPackage name.
			classDef := packageDef classDefinitions at: loadedClass name.
			packageDef removeClassDefinition: classDef.
			projectSetDefinition addProject: projectDef.
			loadedClassProjectDef := projectDef.
			loadedClassProjectDefName := projectDef name ].

	loadedClassExtensions
		do: [ :loadedClassExtension | 
			| loadedClassExtensionPackage ceProjectDef cePackageDef |
			loadedClassExtensionPackage := loadedClassExtension loadedPackage.
			ceProjectDef := loadedClassExtension loadedProject asDefinition.
			ceProjectDef name = loadedClassProjectDefName
				ifTrue: [
					"extensions defined in same project as the class itself, entry already exists in projectSetDefinition"
					ceProjectDef := loadedClassProjectDef ]
				ifFalse: [ projectSetDefinition addProject: ceProjectDef ].
			cePackageDef := ceProjectDef packageNamed: loadedClassExtensionPackage name.
			cePackageDef
				removeClassExtensionDefinition:
					(cePackageDef classExtensions at: loadedClassExtension name) ].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass 
		ifNil: [
			"need to do the actual removal of the unpackaged class after Rowan has done it's job"
			| theClass |
			theClass := Rowan image objectNamed: className.
			(Rowan image symbolList dictionariesAndSymbolsOf: theClass)
				do: [:ar | | dict key |
					"brute force removal of the class from system dictionaries"
					dict := ar at: 1.	
					key := ar at: 2.
					dict removeKey: key ] ]
%

category: 'method browsing'
method: RwPrjBrowserToolV2
removeMethod: methodSelector forClassNamed: className isMeta: isMeta

	"Remove the given method selector from the class named className"

	| loadedMethodToBeRemoved loadedPackage loadedClassOrExtension projectDef packageDef crDef |
	loadedMethodToBeRemoved := self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [
			| theBehavior |
			theBehavior := Rowan globalNamed: className.
			isMeta ifTrue: [ theBehavior := theBehavior class ].
			RwPerformingUnpackagedEditNotification signal: 'Attempt to remove an unpackaged method from the class ', className printString, '. The removal will not be tracked by Rowan'.
			"Notification resumed, so continue with removal"
			^ theBehavior removeSelector: methodSelector ].
	loadedPackage := loadedMethodToBeRemoved loadedPackage.
	loadedClassOrExtension := loadedPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- no class or extension for ' , className printString
						, ' in package ' , loadedPackage name printString , '.' ].
	projectDef := loadedPackage loadedProject asDefinition.
	packageDef := projectDef packageNamed: loadedPackage name.
	crDef := loadedClassOrExtension isLoadedClass
		ifTrue: [ packageDef classDefinitions at: loadedClassOrExtension name ]
		ifFalse: [ packageDef classExtensions at: loadedClassOrExtension name ].
	isMeta
		ifTrue: [ crDef removeClassMethod: methodSelector ]
		ifFalse: [ crDef removeInstanceMethod: methodSelector ].
	Rowan projectTools load loadProjectDefinition: projectDef
%

category: 'package browsing'
method: RwPrjBrowserToolV2
removePackageNamed: packageName

	| loadedPackage projectDef |
	loadedPackage := self _loadedPackageNamed: packageName.
	projectDef := loadedPackage loadedProject asDefinition.
	projectDef removePackageNamed: loadedPackage name.

	Rowan projectTools load loadProjectDefinition: projectDef
%

category: 'class browsing'
method: RwPrjBrowserToolV2
removeProtocol: hybridPackageName fromClassNamed: className isMeta: isMeta

	"hybridPackageName is expected to be an existing protocol in className, that may or may not be empty"

	| projectSetDefinition loadedClass theClass theBehavior loadedPackage |
	projectSetDefinition := RwProjectSetDefinition new.

	loadedClass := self _loadedClassNamed: className ifAbsent: [ ].

	loadedPackage := (hybridPackageName at: 1) = $*
		ifTrue: [ 
			Rowan image
				loadedHybridPackageNamed: hybridPackageName
				ifAbsent: [ 
					self
						error:
							'A package for hybrid package name ' , hybridPackageName printString
								, ' was not found.' ] ]
		ifFalse: [ loadedClass loadedPackage ].

	theClass := Rowan image objectNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].

	(((theBehavior selectorsIn: hybridPackageName)
		collect: [:methodSelector |
			self
				_loadedMethod: methodSelector
				inClassNamed: className
				isMeta: isMeta
				ifAbsent: [
					RwPerformingUnpackagedEditNotification signal: 'Attempt to remove an unpackaged method from the class ', className printString, '. The removal will not be tracked by Rowan'.
					"Notification resumed, so continue with removal"
					(Rowan image objectNamed: className) removeSelector: methodSelector.
					nil "no loaded method involved" ] ]) select: [:each | each notNil ])
			do: [:loadedMethodToBeRemoved |
				| loadedClassOrExtension projectDef crDef packageDef methodSelector | 

				methodSelector := loadedMethodToBeRemoved selector.
				loadedPackage == loadedMethodToBeRemoved loadedPackage
					ifFalse: [ self error: 'Internal error -- the loaded package of a method to be removed does not match the expected loaded package' ].
				loadedClassOrExtension := loadedPackage
					classOrExtensionForClassNamed: className
					ifAbsent: [ 
						self
							error:
								'Internal error -- no class or extension for ' , className printString
									, ' in package ' , loadedPackage name printString , '.' ].
				projectDef := projectSetDefinition
					projectNamed: loadedPackage loadedProject name
					ifAbsent: [ 
						projectDef := loadedPackage loadedProject asDefinition.
						projectSetDefinition addProject: projectDef.
						projectDef ].
				packageDef := projectDef packageNamed: loadedPackage name.
				crDef := loadedClassOrExtension isLoadedClass
					ifTrue: [ packageDef classDefinitions at: loadedClassOrExtension name ]
					ifFalse: [ packageDef classExtensions at: loadedClassOrExtension name ].
				isMeta
					ifTrue: [ crDef removeClassMethod: methodSelector ]
					ifFalse: [ crDef removeInstanceMethod: methodSelector ] ].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"Rowan does not automatically remove empty method categories ... just removes methods,
		we need to clean up after Rowan is done."
	theBehavior removeCategory: hybridPackageName asSymbol
%

category: 'class browsing'
method: RwPrjBrowserToolV2
renameClassNamed: className to: newName

	"During renameClassNamed:to: a class is created with the new name and all methods 
		are copied from the old class to the new class. If there are subclasses of the old class,
		the subclasses are moved under the new class, then the old class is removed. It is
		recommended that before renaming a class, you should find references to the class 
		and be prepared to edit the methods once the rename is complete.

	Worry about the fact that any references to the original class that may be in methods in 
		the class itself or in subclass methods will error out, if recompiled 
	"

	"anser the new copy of the class"

	| projectSetDefinition loadedClass loadedPackage loadedProject projectDef packageDef |
"1. find references to the original class [not yet implemented]"

"2. copy class to renamed class"
	projectSetDefinition := self _copyClassDefinitionNamed: className to: newName.

	loadedClass := self 
		_loadedClassNamed: className 
		ifAbsent: [  self error: 'No loaded class named: ', className printString , ' found.' ].

"3. remove original class definition"
	loadedPackage := loadedClass loadedPackage.
	loadedProject := loadedPackage loadedProject.
	projectDef := projectSetDefinition projectNamed: loadedProject name ifAbsent: [ self error: 'No loaded project named: ', loadedProject printString , ' found.'].
	packageDef := projectDef packageNamed: loadedPackage name.

	packageDef removeClassNamed: className.

"4. change superclass for all subclasses of original class to renamed class"
	(Rowan globalNamed: className) subclasses do: [:subclass |
		| subclassName classDef  |
		subclassName := subclass name asString.
		loadedClass := self 
			_loadedClassNamed: subclassName
			ifAbsent: [  self error: 'No loaded class named: ', subclassName printString , ' found.' ].

		loadedPackage := loadedClass loadedPackage.
		loadedProject := loadedPackage loadedProject.
		projectDef := projectSetDefinition 
			projectNamed: loadedProject name 
			ifAbsent: [ 
				| pDef |
				pDef := loadedPackage loadedProject asDefinition.
				projectSetDefinition addProject: pDef.
				pDef ].
		packageDef := projectDef packageNamed: loadedPackage name.
		classDef := packageDef classDefinitions at: subclassName.
		classDef superclassName: newName ].

"load projectSetDefinition & do rename"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	^ Rowan globalNamed: newName
%

category: 'class browsing'
method: RwPrjBrowserToolV2
unpackageClass: class
	"Unpackage the given class and all methods in the class that in the same package, 
		while leaving the class installed in the image"

	| loadedClass loadedPackage |
	loadedClass := Rowan image
		loadedClassForClass: class
		ifAbsent: [ 
			"the class is not packaged, so we are done"
			^ self ].
	loadedClass loadedInstanceMethods values
		do: [ :loadedMethod | 
			loadedClass removeLoadedMethod: loadedMethod.
			loadedMethod unpackageMethod ].
	loadedClass loadedClassMethods values
		do: [ :loadedMethod | 
			loadedClass removeLoadedMethod: loadedMethod.
			loadedMethod unpackageMethod ].

	loadedPackage := loadedClass loadedPackage.
	loadedPackage removeLoadedClass: loadedClass.
	RwGsSymbolDictionaryRegistry_ImplementationV2
		unregisterLoadedClass: loadedClass
		forClass: class
%

category: 'class browsing'
method: RwPrjBrowserToolV2
unpackageClassNamed: className
	"Unpackage the given class and all methods in the class that in the same package, 
		while leaving the class installed in the image"

	| theClass |
	theClass := Rowan globalNamed: className.
	theClass
		ifNil: [ self error: 'No class named ' , className printString , ' found' ].
	self unpackageClass: theClass
%

category: 'method browsing'
method: RwPrjBrowserToolV2
unpackageMethod: method
	"unpackage the given method, while leaving the method installed in the image"

	| loadedMethod loadedClassOrExtension loadedPackage packageName |
	packageName := method rowanPackageName.
	packageName = Rowan unpackagedName
		ifTrue: [ 
			"already unpackaged, nothing else to do"
			^ self ].
	loadedMethod := Rowan image loadedMethodForMethod: method.
	loadedPackage := loadedMethod loadedPackage.
	loadedClassOrExtension := loadedMethod loadedClass.
	loadedClassOrExtension isLoadedClassExtension
		ifTrue: [ 
			loadedClassOrExtension isEmpty
				ifTrue: [ 
					RwGsSymbolDictionaryRegistry_ImplementationV2
						unregisterLoadedClassExtension: loadedClassOrExtension
						forClass: loadedClassOrExtension handle.
					loadedPackage removeLoadedClassExtension: loadedClassOrExtension ] ].
	loadedMethod unpackageMethod
%

category: 'method browsing'
method: RwPrjBrowserToolV2
unpackageMethod: methodSelector forClassNamed: className isMeta: isMeta
	"unpackage the given method, while leaving the method installed in the image"

	| theBehavior theMethod |
	theBehavior := Rowan globalNamed: className.
	isMeta
		ifTrue: [ theBehavior := theBehavior class ].
	theMethod := theBehavior compiledMethodAt: methodSelector.
	self unpackageMethod: theMethod
%

category: 'class browsing'
method: RwPrjBrowserToolV2
updateClassCategory: aString forClassNamed: className 

	"update the category of the named class"

	| loadedClass projectDefinition packageDefinition classDefinition |
	loadedClass := Rowan image 
		loadedClassNamed: className 
		ifAbsent: [
			RwPerformingUnpackagedEditNotification signal: 'Attempt to add or modify a category for the class ', className printString, '. The modification will not be tracked by Rowan'.
			"Notification resumed, so continue with add/modify"
			^ (Rowan globalNamed: className) category: aString ].

	projectDefinition := loadedClass loadedProject asDefinition.
	packageDefinition := projectDefinition packageNamed: loadedClass loadedPackage name.
	classDefinition := packageDefinition classDefinitions at: loadedClass name.
	classDefinition category: aString.

	self class load loadProjectDefinition: projectDefinition.
%

category: 'class browsing'
method: RwPrjBrowserToolV2
updateClassComment: aString forClassNamed: className 

	"update the comment of the named class"

	| loadedClass projectDefinition packageDefinition classDefinition |
	loadedClass := Rowan image 
		loadedClassNamed: className 
		ifAbsent: [
			RwPerformingUnpackagedEditNotification signal: 'Attempt to add or modify a comment for the class ', className printString, '. The modification will not be tracked by Rowan'.
			"Notification resumed, so continue with add/modify"
			^ (Rowan globalNamed: className) comment: aString ].

	projectDefinition := loadedClass loadedProject asDefinition.
	packageDefinition := projectDefinition packageNamed: loadedClass loadedPackage name.
	classDefinition := packageDefinition classDefinitions at: loadedClass name.
	classDefinition comment: aString.

	self class load loadProjectDefinition: projectDefinition.
%

category: 'private'
method: RwPrjBrowserToolV2
_copyClassDefinitionNamed: className to: newName

	"answer a projectSetDefinition that includes the copied class definition"

	| loadedClass classDef loadedPackage projectDef packageDef  projectSetDefinition |
	(self _loadedClassNamed: newName ifAbsent:  [])
		ifNotNil: [ self error: 'There is already a class named ', newName printString, ' in the system.' ].
	loadedClass := self 
		_loadedClassNamed: className 
		ifAbsent: [  self error: 'No loaded class named: ', className printString , ' found.' ].
	projectSetDefinition := RwProjectSetDefinition new.
	loadedPackage := loadedClass loadedPackage.
	projectDef := loadedPackage loadedProject asDefinition.
	packageDef := projectDef packageNamed: loadedPackage name.
	classDef := loadedClass asDefinition.
	classDef name: newName.
	packageDef addClassDefinition: classDef.
	projectSetDefinition addProject: projectDef.

	(self _loadedClassExtensionsNamed: className ifAbsent: [ #() ])
		do: [:loadedClassExtension | 
			| classExtDef loadedProject |
			loadedPackage := loadedClassExtension loadedPackage.
			loadedProject := loadedPackage loadedProject.
			projectDef := projectSetDefinition
				projectNamed: loadedPackage loadedProject name
				ifAbsent: [ 
					projectDef := loadedProject asDefinition.
					projectSetDefinition addProject: projectDef.
					projectDef ].

			packageDef := projectDef packageNamed: loadedPackage name.
			classExtDef := loadedClassExtension asDefinition.
			classExtDef name: newName.
			packageDef addClassExtensionDefinition: classExtDef ].

	^ projectSetDefinition
%

category: 'private'
method: RwPrjBrowserToolV2
_loadedClassExtensionsNamed: className ifAbsent: absentBlock

	^ Rowan image
		loadedClassExtensionsNamed: className
		ifFound: [ :loadedClassExtensionSet | ^ loadedClassExtensionSet ]
		ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserToolV2
_loadedClassNamed: className ifAbsent: absentBlock

	^ Rowan image loadedClassNamed: className ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserToolV2
_loadedMethod: methodSelector inClassNamed: className isMeta: isMeta

	^ self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ 
			self
				error:
					'No loaded method for ' , methodSelector printString , ' was found for class '
						, className printString ]
%

category: 'private'
method: RwPrjBrowserToolV2
_loadedMethod: methodSelector inClassNamed: className isMeta: isMeta ifAbsent: absentBlock

	^ Rowan image
		loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifFound: [ :loadedMethod | ^ loadedMethod ]
		ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserToolV2
_loadedPackageNamed: packageName

	^ self
		_loadedPackageNamed: packageName
		ifAbsent: [ self error: 'No package named ' , packageName printString , ' found' ]
%

category: 'private'
method: RwPrjBrowserToolV2
_loadedPackageNamed: packageName ifAbsent: absentBlock

	^ Rowan image loadedPackageNamed: packageName ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserToolV2
_loadedProjectNamed: projectName

	^ Rowan image
		loadedProjectNamed: projectName
		ifAbsent: [ self error: 'No project named ' , projectName printString , ' found' ]
%

category: 'private'
method: RwPrjBrowserToolV2
_projectNamed: projectName

	^ (self _loadedProjectNamed: projectName) asDefinition
%

category: 'private'
method: RwPrjBrowserToolV2
_rowanSymbolDictionaryNames

	^ #( #RowanKernel #RowanLoader #RowanTools )
%

! Class implementation for 'RwPrjCloneTool'

!		Instance methods for 'RwPrjCloneTool'

category: 'smalltalk api'
method: RwPrjCloneTool
cloneRepository: aRwGitRepositoryDefinition
	| gitTool response remoteUrl cloneOption checkout |
	self
		_validateForGitRepository: aRwGitRepositoryDefinition
		ifDone: [ :msg | 
			"done block is invoked when it is not necessary to perform further processing. Typically,
		the clone is already present."
			^ msg ].
	gitTool := Rowan gitTools.
	remoteUrl := aRwGitRepositoryDefinition remoteUrl , ' '.
	cloneOption := ' --no-checkout '.
	checkout := aRwGitRepositoryDefinition committish.
	checkout ifNil: [ cloneOption := '' ].
	response := gitTool
		gitcloneIn: aRwGitRepositoryDefinition repositoryRoot parent pathString
		with:
			cloneOption , remoteUrl , aRwGitRepositoryDefinition repositoryRoot pathString.
	checkout
		ifNotNil: [ 
			gitTool := Rowan gitTools.
			gitTool
				gitcheckoutIn: aRwGitRepositoryDefinition repositoryRoot
				with: checkout ]
%

category: 'private'
method: RwPrjCloneTool
_validateForGitRepository: aRwGitRepositoryDefinition ifDone: doneBlock

	| gitTool response command cdResponse gitRepoPath |
	gitTool := Rowan gitTools.
	gitRepoPath := aRwGitRepositoryDefinition repositoryRoot.

	gitRepoPath exists
		ifTrue: [ 
			[ 
			"if gitRepoDir exists and it is a git repo, then make sure that the clone is for the target
		project ... if not error out of here."
			response := gitTool gitrevparseShowTopLevelIn: gitRepoPath pathString.
			command := 'set -e; cd ' , gitRepoPath pathString , '; pwd'.
			cdResponse := gitTool performOnServer: command.
			(self readlink: response) = (self readlink: cdResponse)
				ifTrue: [ 
					| msg |
					msg := 'A clone for '
						, aRwGitRepositoryDefinition name printString , ' already exists in '
						, gitRepoPath pathString printString , ', so the clone operation is being skipped'
						, '
The project project has been registered with Rowan at the existing location .'.
					doneBlock value: msg ] 
				ifFalse: [ self error: 'expected repository path does not match gitrevparse result.' ]]
				on: Error
				do: [ :ignored | 
					self
						error:
							'Expected a git repository to present in the directory: '
								, gitRepoPath pathString printString ] ].
	gitRepoPath parent ensureCreateDirectory
%

! Class implementation for 'RwPrjCommitTool'

!		Instance methods for 'RwPrjCommitTool'

category: 'smalltalk api'
method: RwPrjCommitTool
commitProjectNamed: projectName message: messageString

	"commit repository ... packages must be written out independently with write tool"

	| loadedProject projectDefinition |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	projectDefinition := loadedProject asDefinition.
	projectDefinition commit: messageString
%

! Class implementation for 'RwPrjCreateToolV2'

!		Instance methods for 'RwPrjCreateToolV2'

category: 'project repository creation'
method: RwPrjCreateToolV2
createResolvedProjectRepository: resolvedRepository
	"Create create new repository on `disk`, based on the given resolved project, if it does not already exist."

	resolvedRepository repositoryRoot ensureCreateDirectory.
	resolvedRepository projectRoots do: [ :path | path ensureCreateDirectory ]
%

! Class implementation for 'RwPrjDeleteTool'

!		Instance methods for 'RwPrjDeleteTool'

category: 'delete project definitions'
method: RwPrjDeleteTool
deleteProjectDefinition: projectDefinition

	"Remove the classes and methods managed by the project definition."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects the delete will fail ... deleteProjectDefinitionSet: to delete multiple projects"

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

	^ self deleteProjectSetDefinition: projectSetDefinition
%

category: 'delete projects by name'
method: RwPrjDeleteTool
deleteProjectNamed: projectName

	"Remove the classes and methods managed by the project from the loaded things."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects the delete will fail ... deleteProjectDefinitionSet: to delete multiple projects"

	| loadedProject |

	loadedProject := Rowan image loadedProjectNamed: projectName.

	^ self deleteProjectDefinition: loadedProject asDefinition
%

category: 'delete project definitions'
method: RwPrjDeleteTool
deleteProjectSetDefinition: projectSetDefinitionToDelete
	"Remove the classes and methods managed by the listed project definitions."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will fail ... 
		add projects containing  subclasses to the <projectSetDefinitionToDelete> ."

	| loadedProjectSet loadTool |
	loadedProjectSet := projectSetDefinitionToDelete deriveLoadedThings.

	projectSetDefinitionToDelete definitions
		do: [ :projectDef | 
			loadTool := projectDef _loadTool.
			projectDef packageNames
				do: [ :packageName | projectDef removePackageNamed: packageName ] ].
	loadTool loadProjectSetDefinition: projectSetDefinitionToDelete.

	loadedProjectSet
		do: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ifAbsent: [  ] ]
%

category: 'delete project definitions'
method: RwPrjDeleteTool
forceDeleteProjectDefinition: projectDefinition

	"Remove the classes and methods managed by the project definition."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will NOT fail."

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

	^ self forceDeleteProjectSetDefinition: projectSetDefinition
%

category: 'delete projects by name'
method: RwPrjDeleteTool
forceDeleteProjectNamed: projectName

	"Remove the classes and methods managed by the project from the loaded things."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will NOT fail."

	| loadedProject |

	loadedProject := Rowan image loadedProjectNamed: projectName.

	^ self forceDeleteProjectDefinition: loadedProject asDefinition
%

category: 'delete project definitions'
method: RwPrjDeleteTool
forceDeleteProjectSetDefinition: projectSetDefinitionToDelete

	"Remove the classes and methods managed by the listed project definitions."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will NOT fail."

	| loadedProjectSet classesToDelete methodsToDelete mySymbolList |
	loadedProjectSet := projectSetDefinitionToDelete deriveLoadedThings.

	classesToDelete := IdentitySet new.
	methodsToDelete := IdentityKeyValueDictionary new.

	loadedProjectSet do: [:theLoadedProject |
		theLoadedProject 
			loadedPackagesDo: [ :loadedProject :loadedPackage | "ignored" ] 
			loadedClassedDo: [ :loadedProject :loadedPackage :loadedClass | 
				"collect the classes defined in the project"
				classesToDelete add: loadedClass handle currentVersion ] 
			loadedClassExtensionsDo: [:loadedProject :loadedPackage :loadedClassExtension | "ignored" ] 
			loadedInstanceMethodsDo: [:loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod |
				loadedClassOrClassExtension isLoadedClassExtension
					ifTrue: [ 
						"collect extension instance methods"
						((methodsToDelete at: loadedClassOrClassExtension handle currentVersion ifAbsentPut: [Dictionary new]) 
							at: 'instance' ifAbsentPut: [ IdentitySet new ]) add: loadedMethod handle selector ] ] 
			loadedClassMethodsDo: [:loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
				loadedClassOrClassExtension isLoadedClassExtension
					ifTrue: [ 
						"collect extension class methods"
						((methodsToDelete at: loadedClassOrClassExtension handle currentVersion ifAbsentPut: [Dictionary new]) 
							at: 'class' ifAbsentPut: [ IdentitySet new ]) add: loadedMethod handle selector ] ] ].
	classesToDelete do: [:class | 
		"remove any classes that are going to be deleted from methodsToDelete"
		methodsToDelete removeKey: class ifAbsent: [ ] ].

	loadedProjectSet do: [:theLoadedProject |
		"remove the methods, classes, packages and projects from loaded things"
		Rowan projectTools disown disownProjectNamed: theLoadedProject name ].

	mySymbolList := System myUserProfile symbolList. "persistent symbol list"
	classesToDelete do: [:class |
		"remove classes from system"
		(mySymbolList dictionariesAndSymbolsOf: class) do: [:ar |
			GsFile gciLogServer: 'Forcibly delete class ', class name asString printString.
			(ar at: 1) removeKey: (ar at: 2) ] ].

	methodsToDelete keysAndValuesDo: [:class :selectorDict |
		| behavior |
		"remove extension methods from the classes remaining in system"
		GsFile gciLogServer: 'Forcibly remove extension methods from class ', class name asString printString.
		GsFile gciLogServer: '	instance'.
		(selectorDict at: 'instance' ifAbsent: [ #() ]) do: [:selector |
			GsFile gciLogServer: '		', selector asString printString.
			class removeSelector: selector ].
		behavior := class class.
		GsFile gciLogServer: '	class'.
		(selectorDict at: 'class' ifAbsent: [ #() ]) do: [:selector |
			GsFile gciLogServer: '		', selector asString printString.
			behavior removeSelector: selector ] ].
%

! Class implementation for 'RwPrjDiffTool'

!		Instance methods for 'RwPrjDiffTool'

category: 'smalltalk api'
method: RwPrjDiffTool
patchesForProjectDefinition: imageProjectDefinition

	| imagePackageDefinitions diskProjectSet diskProject diskPackageDefinitionMaps |
	imagePackageDefinitions := imageProjectDefinition packages values.
	[ diskProjectSet :=  imageProjectDefinition readProjectSet ]
		on: RwInvalidCategoryProtocolConventionErrorNotification
		do: [:ex | ex resume ].
	diskProject := diskProjectSet projectNamed: imageProjectDefinition name.
	diskPackageDefinitionMaps := diskProject packages.
	^ imagePackageDefinitions collect: [:packageDefinition |
		| imageSnapshot diskPackageDefinition diskSnapshot |
		imageSnapshot := (RwCypressPackageStructure fromPackage: packageDefinition ) snapshot.
		diskPackageDefinition := diskPackageDefinitionMaps at: packageDefinition name.
		diskSnapshot := (RwCypressPackageStructure fromPackage: diskPackageDefinition ) snapshot.
		packageDefinition name -> (CypressPatch fromBase: diskSnapshot toTarget: imageSnapshot) ]
%

category: 'smalltalk api'
method: RwPrjDiffTool
patchesForProjectNamed: projectName

	| imageProject |
	imageProject := Rowan image loadedProjectNamed: projectName.
	^ self patchesForProjectDefinition: imageProject asDefinition
%

! Class implementation for 'RwPrjDisownTool'

!		Instance methods for 'RwPrjDisownTool'

category: 'projects'
method: RwPrjDisownTool
disownProjectNamed: projectName

	"Remove the classes and methods managed by the project from the loaded things."

	"The classes and methods are not removed from the system"

	"Use the adopt tool to restore the classes and methods to the loaded things"

	| loadedProject disownTool |

	loadedProject := Rowan image loadedProjectNamed: projectName.

	disownTool := Rowan packageTools disown.
	loadedProject loadedPackages 
		do: [:loadedPackage |
			disownTool disownPackageNamed: loadedPackage name ].

	Rowan image _removeLoadedProject: loadedProject
%

! Class implementation for 'RwPrjEditTool'

!		Instance methods for 'RwPrjEditTool'

category: 'class editing'
method: RwPrjEditTool
addClass: classDefinition inPackageNamed: packageName inProject: projectDefinition
	"Add the given class definition to the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition addClassDefinition: classDefinition.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
addClass: classDefinition inPackageNamed: packageName inProjectNamed: projectName

	"Add the given class definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

category: 'class extension editting'
method: RwPrjEditTool
addClassExtension: classExtensionDefinition inPackageNamed: packageName inProject: projectDefinition
	"Add the given class extension definition to the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
removeClass: classDefinition fromPackageNamed: packageName inProject: projectDefinition
	"Remove the given class definition from the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition removeClassDefinition: classDefinition.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
removeClassNamed: className fromPackageNamed: packageName inProject: projectDefinition
	"Remove the named class definition from the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition removeClassNamed: className.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
updateOrAddClass: classDefinition inPackageNamed: packageName inProject: projectDefinition
	"Update or add the given class definition to the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition updateClassDefinition: classDefinition.
	^ projectDefinition
%

! Class implementation for 'RwPrjLoadToolV2'

!		Instance methods for 'RwPrjLoadToolV2'

category: 'load project definitions'
method: RwPrjLoadToolV2
loadProjectDefinition: projectDefinition
	^ self
		loadProjectDefinition: projectDefinition
		platformConfigurationAttributes: projectDefinition platformConditionalAttributes
		instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project definitions'
method: RwPrjLoadToolV2
loadProjectDefinition: projectDefinition instanceMigrator: instanceMigrator
	^ self
		loadProjectDefinition: projectDefinition
		platformConfigurationAttributes: projectDefinition platformConditionalAttributes
		instanceMigrator: instanceMigrator
%

category: 'load project definitions'
method: RwPrjLoadToolV2
loadProjectDefinition: projectDefinition platformConfigurationAttributes: platformConfigurationAttributes
	"read the configurations for <projectDefinition> to develop the list of dependent projects"

	^ self
		loadProjectDefinition: projectDefinition
		platformConfigurationAttributes: platformConfigurationAttributes
		instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project definitions'
method: RwPrjLoadToolV2
loadProjectDefinition: projectDefinition platformConfigurationAttributes: platformConfigurationAttributes instanceMigrator: instanceMigrator
	"read the configurations for <projectDefinition> to develop the list of dependent projects"

	^ self
		loadProjectDefinition: projectDefinition
		platformConfigurationAttributes: platformConfigurationAttributes
		instanceMigrator: instanceMigrator
		symbolList: Rowan image symbolList
%

category: 'load project definitions'
method: RwPrjLoadToolV2
loadProjectDefinition: projectDefinition platformConfigurationAttributes: platformConfigurationAttributes instanceMigrator: instanceMigrator symbolList: symbolList
	"read the configurations for <projectDefinition> to develop the list of dependent projects"

	| projectSetDefinition requiredProjectNames |
	projectSetDefinition := RwProjectSetDefinition new
		addProject: projectDefinition;
		yourself.
	(requiredProjectNames := projectDefinition
		requiredProjectNames: platformConfigurationAttributes) isEmpty
		ifFalse: [ 
			| absentProjectNames |
			"if required projects are not already present in the image, then they must be loaded at this time"
			absentProjectNames := requiredProjectNames
				select: [ :projectName | Rowan projectNamed: projectName ifPresent: [ false ] ifAbsent: [ true ] ].
			absentProjectNames isEmpty
				ifFalse: [ 
					projectSetDefinition := projectDefinition
						readProjectSet: platformConfigurationAttributes ] ].
	^ self
		loadProjectSetDefinition: projectSetDefinition
		instanceMigrator: instanceMigrator
		symbolList: symbolList
%

category: 'load project by name'
method: RwPrjLoadToolV2
loadProjectNamed: projectName
	| projectSet  res |
	projectSet := Rowan projectTools readV2
		readProjectSetForProjectNamed: projectName.
	res := self loadProjectSetDefinition: projectSet.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSet.
	^ res
%

category: 'load project by name'
method: RwPrjLoadToolV2
loadProjectNamed: projectName customConditionalAttributes: customConditionalAttributes
	| platformConditionalAttributes project |
	project := RwProject newNamed: projectName.
	platformConditionalAttributes := project platformConditionalAttributes copy
		asSet.
	platformConditionalAttributes addAll: customConditionalAttributes.
	^ self
		loadProjectNamed: projectName
		platformConditionalAttributes: platformConditionalAttributes
%

category: 'load project by name'
method: RwPrjLoadToolV2
loadProjectNamed: projectName platformConditionalAttributes: platformConditionalAttributes
	| projectSet res |
	projectSet := Rowan projectTools readV2
		readProjectSetForProjectNamed: projectName
		platformConditionalAttributes: platformConditionalAttributes.
	res := self loadProjectSetDefinition: projectSet.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSet.
	^ res
%

category: 'load project definitions'
method: RwPrjLoadToolV2
loadProjectSetDefinition: projectSetDefinitionToLoad

	^ self
		loadProjectSetDefinition: projectSetDefinitionToLoad
		instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project definitions'
method: RwPrjLoadToolV2
loadProjectSetDefinition: projectSetDefinition instanceMigrator: instanceMigrator
	"NOTE: when loading a definition into a stone, the loaded things are not marked as non-dirty ... dirty state is relative to the disk image for a
		project and a definition can have come from anywhere"

	^ self
		loadProjectSetDefinition: projectSetDefinition
		instanceMigrator: instanceMigrator
		symbolList: Rowan image symbolList
%

category: 'load project definitions'
method: RwPrjLoadToolV2
loadProjectSetDefinition: projectSetDefinition instanceMigrator: instanceMigrator symbolList: symbolList
	"NOTE: when loading a definition into a stone, the loaded things are not marked as non-dirty ... dirty state is relative to the disk image for a
		project and a definition can have come from anywhere"

	^ self
		_doProjectSetLoad: projectSetDefinition
		instanceMigrator: instanceMigrator
		symbolList: symbolList
		originalProjectSet: projectSetDefinition
		processedClassNames: Set new
%

category: 'load project definitions'
method: RwPrjLoadToolV2
loadProjectSetDefinition: projectSetDefinitionToLoad symbolList: symbolList
	^ self
		loadProjectSetDefinition: projectSetDefinitionToLoad
		instanceMigrator: Rowan platform instanceMigrator
		symbolList: symbolList
%

category: 'utilities'
method: RwPrjLoadToolV2
markProjectSetNotDirty: projectSetDefinition
	"This method should only be used when the projectSetDefinitions have been read from disk - mark them not dirty. Not dirty means that the loaded things match the code on disk."

	projectSetDefinition deriveLoadedThings
		do: [ :loadedProject | 
			loadedProject markNotDirty.
			loadedProject loadedPackages
				valuesDo: [ :loadedPackage | loadedPackage markNotDirty ] ]
%

category: 'private'
method: RwPrjLoadToolV2
_doProjectSetLoad: projectSetDefinition instanceMigrator: instanceMigrator symbolList: symbolList originalProjectSet: originalProjectSet processedClassNames: processedClassNames
	| copiedProjectSetDef theClassName theClass projectDef theLoadedProject loadedClass packageDef |
	[ 
	^ self
		_loadProjectSetDefinition: projectSetDefinition
		instanceMigrator: instanceMigrator
		symbolList: symbolList ]
		on: RwExistingVisitorAddingExistingClassNotification
		do: [ :ex | 
			| theProjectName |
			theClassName := ex classDefinition name.
			(processedClassNames includes: theClassName)
				ifTrue: [ ex resume ].
			theClass := ex class.
			theClass isBehavior
				ifFalse: [ ex pass ].
			theProjectName := theClass rowanProjectName.
			theProjectName = Rowan unpackagedName
				ifTrue: [ self error: 'Unexpected unpackaged class ' , theClass name asString printString ]
				ifFalse: [ theLoadedProject := Rowan image loadedProjectNamed: theProjectName ].
			theLoadedProject
				ifNil: [ 
					"the loaded project should not be nil - if it is, pass the notification"
					ex pass ].
			(originalProjectSet projectNamed: theLoadedProject name ifAbsent: [  ])
				ifNotNil: [ 
					"If the loadedProject is in the originalProjectSet, then is likely to be a class move - resume and let the chips fall where they may"
					ex resume ].
			copiedProjectSetDef := projectSetDefinition copy.	"a project in the original project set is taking ownership of an already  loaded class,
					remove the class from the original project's package and attempt a reload"
			projectDef := copiedProjectSetDef
				projectNamed: theLoadedProject name
				ifAbsent: [ 
					projectDef := theLoadedProject asDefinition.
					copiedProjectSetDef addProject: projectDef.
					projectDef ].
			loadedClass := Rowan image
				loadedClassForClass: theClass
				ifAbsent: [ self error: 'No loaded class for classs ' , theClassName printString ].
			packageDef := projectDef packageNamed: loadedClass loadedPackage name.
			packageDef removeClassNamed: theClassName.
			processedClassNames add: theClassName ].	"trim the stack"
	^ self
		_doProjectSetLoad: copiedProjectSetDef
		instanceMigrator: instanceMigrator
		symbolList: symbolList
		originalProjectSet: originalProjectSet
		processedClassNames: processedClassNames
%

category: 'private'
method: RwPrjLoadToolV2
_loadProjectSetDefinition: projectSetDefinitionToLoad instanceMigrator: instanceMigrator symbolList: symbolList
	| loadedProjectSet loadedProjectDefinitionSet diff loadedProjects |
	loadedProjectSet := projectSetDefinitionToLoad deriveLoadedThings.
	loadedProjectDefinitionSet := loadedProjectSet asProjectDefinitionSet.
	projectSetDefinitionToLoad definitions
		keysAndValuesDo: [ :projectName :projectDefinition | 
			projectDefinition packages
				keysAndValuesDo: [ :packageName :packageDefinition | 
					| symdictName |
					"set the target symbol dictionary name for each incoming package definition"
					symdictName := projectDefinition gemstoneSymbolDictNameForPackageNamed: packageName.
						packageDefinition gs_symbolDictionary: symdictName.
						packageDefinition classDefinitions values do: [:classDef | classDef gs_symbolDictionary: symdictName ] ] ].
	diff := projectSetDefinitionToLoad
		compareAgainstBaseForLoader: loadedProjectDefinitionSet.
	diff isEmpty
		ifFalse: [ 
			| componentsWithDoits |
			componentsWithDoits := diff componentsWithDoits.
			componentsWithDoits do: [ :component | component executePreloadDoit ].
			Rowan image applyModification_V2: diff instanceMigrator: instanceMigrator symbolList: symbolList.
			componentsWithDoits do: [ :component | component executePostloadDoit ] ].
	loadedProjects := Array new.
	projectSetDefinitionToLoad definitions
		do: [ :projectDef | 
			| theLoadedProject |
			loadedProjects add: (RwProject newNamed: projectDef name).
			theLoadedProject := Rowan image loadedProjectNamed: projectDef name.
			theLoadedProject handle _projectStructure: projectDef components copy.
			theLoadedProject handle _loadSpecification: projectDef _loadSpecification copy.
			theLoadedProject handle _projectRepository: projectDef _projectRepository copy.
			theLoadedProject handle projectDefinitionPlatformConditionalAttributes: projectDef projectDefinitionPlatformConditionalAttributes.
			(projectDef projectDefinitionSourceProperty
				= RwLoadedProject _projectDiskDefinitionSourceValue
				or: [ 
					projectDef projectDefinitionSourceProperty
						= RwLoadedProject _projectLoadedDefinitionSourceWithDependentProjectsValue ])
				ifTrue: [ 
					theLoadedProject
						updateLoadedCommitId;
						markNotDirty.
					theLoadedProject loadedPackages
						valuesDo: [ :loadedPackage | loadedPackage markNotDirty ] ] ].
	^ loadedProjects
%

! Class implementation for 'RwPrjQueryTool'

!		Instance methods for 'RwPrjQueryTool'

category: 'smalltalk API'
method: RwPrjQueryTool
classesForProjectNamed: projectName

	| loadedProject classes |
	classes := IdentitySet new.
	loadedProject := Rowan image loadedProjectNamed: projectName.
	loadedProject loadedPackages
		do: [ :loadedPackage | 
			loadedPackage loadedClasses values
				do: [ :rowanLoadedClass | classes add: rowanLoadedClass handle ] ].
	^ classes
%

category: 'smalltalk API'
method: RwPrjQueryTool
classExtensionsForProjectNamed: projectName

	| loadedProject classExtensions |
	classExtensions := IdentitySet new.
	loadedProject := Rowan image loadedProjectNamed: projectName.
	loadedProject loadedPackages
		do: [ :loadedPackage | 
			loadedPackage loadedClassExtensions values
				do: [ :rowanLoadedClass | classExtensions add: rowanLoadedClass handle ] ].
	^ classExtensions
%

! Class implementation for 'RwPrjReadToolV2'

!		Instance methods for 'RwPrjReadToolV2'

category: 'read resolved projects'
method: RwPrjReadToolV2
readProjectForResolvedProject: resolvedProject withComponentNames: componentNames
	"read packages and project metadata into projectDefinition ... return the resolvedProject"

	^ self
		readProjectForResolvedProject: resolvedProject
		withComponentNames: componentNames
		platformConditionalAttributes: resolvedProject platformConditionalAttributes
%

category: 'read resolved projects'
method: RwPrjReadToolV2
readProjectForResolvedProject: resolvedProject withComponentNames: componentNames platformConditionalAttributes: platformConditionalAttributes
	RwResolvedProjectComponentVisitorV2
		readProjectForResolvedProject: resolvedProject
		withComponentNames: componentNames
		platformConditionalAttributes: platformConditionalAttributes.
	resolvedProject readPackageNames: resolvedProject packageNames.
	^ resolvedProject
%

category: 'read loaded projects'
method: RwPrjReadToolV2
readProjectSetForProjectNamed: projectName
	^ (Rowan image loadedProjectNamed: projectName) asDefinition readProjectSet
%

category: 'read loaded projects'
method: RwPrjReadToolV2
readProjectSetForProjectNamed: projectName platformConditionalAttributes: platformConditionalAttributes
	^ (Rowan image loadedProjectNamed: projectName) asDefinition
		readProjectSet: platformConditionalAttributes
%

category: 'read resolved projects'
method: RwPrjReadToolV2
readProjectSetForResolvedProject: resolvedProject withComponentNames: componentNames 
	"read packages and project metadata into projectDefinition ... return a project definition
		set that contains projectDefinition and any dependent projects"

	^ self
		readProjectSetForResolvedProject: resolvedProject
		withComponentNames: componentNames
		platformConditionalAttributes: resolvedProject platformConditionalAttributes
%

category: 'read resolved projects'
method: RwPrjReadToolV2
readProjectSetForResolvedProject: resolvedProject withComponentNames: componentNames platformConditionalAttributes: platformConditionalAttributes
	^ RwResolvedProjectComponentVisitorV2
		readProjectSetForResolvedProject: resolvedProject
		withComponentNames: componentNames
		platformConditionalAttributes: platformConditionalAttributes
%

! Class implementation for 'RwPrjReconcileToolV2'

!		Instance methods for 'RwPrjReconcileToolV2'

category: 'smalltalk api'
method: RwPrjReconcileToolV2
reconcileGlobalClassExtensionsForProjectDefinitionSet: projectDefinitionSet globalsUserId: globalsUserId
	projectDefinitionSet projects
		do: [ :projectDef | 
			| movedClassExtensions originalPackageNames |
			movedClassExtensions := Set new.
			originalPackageNames := projectDef packageNames.
			projectDef packages values
				do: [ :packageDef | 
					packageDef classExtensions values
						do: [ :classDef | 
							(Globals at: classDef name asSymbol ifAbsent: [  ])
								ifNotNil: [ 
									"the class extension is for a class that is Globals, so it needs to be moved to a new Globals extension package"
									movedClassExtensions
										add:
											{classDef.
											packageDef.
											projectDef} ] ] ].
			movedClassExtensions
				do: [ :ar | 
					| theClassDef packageDef theProjectDef newPackageName |
					theClassDef := ar at: 1.
					packageDef := ar at: 2.
					theProjectDef := ar at: 3.
					newPackageName := packageDef name , '-Globals'.
					self
						_moveClassExtension: theClassDef
						toNewPackageNamed: packageDef name , '-Globals'
						clonedFrom: packageDef
						inProject: theProjectDef.
					theProjectDef
						gemstoneSetSymbolDictNameForUser: globalsUserId
						to: 'Globals'
						forPackageNamed: newPackageName ] ]
%

category: 'smalltalk api'
method: RwPrjReconcileToolV2
reconcileProjectDefinitionSet: projectDefinitionSet
	| movedClassExtensions packageNameToSymbolDictNameMap currentUserId |
	movedClassExtensions := Set new.
	packageNameToSymbolDictNameMap := Dictionary new.
	currentUserId := Rowan image currentUserId.
	projectDefinitionSet projects
		do: [ :projectDef | 
			projectDef packages values
				do: [ :packageDef | 
					packageDef classDefinitions values
						do: [ :classDef | 
							self
								_checkExpectedSymbolDictForClassDefinition: classDef
								packageDef: packageDef
								projectDef: projectDef
								classNotFound: [ :theClassDef | self error: 'The class ' , theClassDef name printString , ' not found' ]
								ifCorrect: [ :theClassDef :actualSymDictName | 
									(packageNameToSymbolDictNameMap
										at: packageDef name
										ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol ]
								ifIncorrect: [ :theClassDef :expectedSymDictName :actualSymDictName | 
									"the class is defined in the actualSymDictName and that's where the package should be loaded"
									(packageNameToSymbolDictNameMap
										at: packageDef name
										ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol ] ].
					packageDef classExtensions values
						do: [ :classDef | 
							self
								_checkExpectedSymbolDictForClassDefinition: classDef
								packageDef: packageDef
								projectDef: projectDef
								classNotFound: [ :theClassDef | 
									self
										error:
											'The class to be extended ' , theClassDef name printString , ' not found' ]
								ifCorrect: [ :theClassDef :actualSymDictName | 
									(packageNameToSymbolDictNameMap
										at: packageDef name
										ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol ]
								ifIncorrect: [ :theClassDef :expectedSymDictName :actualSymDictName | 
									"the class extension is in the actualSymDictName and that's where the package should be loaded"
									movedClassExtensions
										add:
											{theClassDef.
											packageDef.
											actualSymDictName.
											projectDef} ] ] ].
			movedClassExtensions
				do: [ :ar | 
					| theClassDef packageDef actualSymDictName theProjectDef newPackageDef defaultSymDictName |
					theClassDef := ar at: 1.
					packageDef := ar at: 2.
					actualSymDictName := (ar at: 3) asString.
					theProjectDef := ar at: 4.
					defaultSymDictName := theProjectDef
						gemstoneDefaultSymbolDictNameForUser: currentUserId.

					newPackageDef := self
						_moveClassExtension: theClassDef
						toNewPackageClonedFrom: packageDef
						inSymbolDictionary: actualSymDictName
						inProject: theProjectDef.
					(theProjectDef gemstoneSymbolDictNameForPackageNamed: newPackageDef name)
						= defaultSymDictName
						ifTrue: [ 
							actualSymDictName ~= defaultSymDictName
								ifTrue: [ 
									"Only need to set the sym dict name, if the sym dict name is not the default"
									theProjectDef
										gemstoneSetSymbolDictNameForUser: currentUserId
										to: actualSymDictName
										forPackageNamed: newPackageDef name ] ]
						ifFalse: [ 
							(theProjectDef
								gemstoneSymbolDictNameForPackageNamed: newPackageDef name
								forUser: currentUserId) ~= actualSymDictName
								ifTrue: [ 
									self
										error:
											'mismatched symbol dictionary names for the package '
												, newPackageDef name printString ].

							theProjectDef
								gemstoneSetSymbolDictNameForUser: currentUserId
								to: actualSymDictName
								forPackageNamed: newPackageDef name ] ] ]
%

category: 'private'
method: RwPrjReconcileToolV2
_checkExpectedSymbolDictForClassDefinition: classDef packageDef: packageDef projectDef: projectDef classNotFound: classNotFoundBlock ifCorrect: correctBlock ifIncorrect: incorrectBlock
	| class ar symDict expectedSymDictName actualSymDictName |
	class := Rowan globalNamed: classDef name.
	class
		ifNil: [ classNotFoundBlock value: classDef ]
		ifNotNil: [ 
			ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
			ar size > 1
				ifTrue: [ 
					self
						error:
							'The class ' , classDef name printString , ' is in multiple symbol dictionaries' ].
			symDict := ar first at: 1.
			actualSymDictName := symDict name asString.
			expectedSymDictName := projectDef
				symbolDictNameForPackageNamed: packageDef name.
			expectedSymDictName = actualSymDictName
				ifTrue: [ correctBlock value: classDef value: actualSymDictName ]
				ifFalse: [ 
					incorrectBlock
						value: classDef
						value: expectedSymDictName
						value: actualSymDictName ] ]
%

category: 'private'
method: RwPrjReconcileToolV2
_moveClassExtension: theClassExtension toNewPackageClonedFrom: packageDef inSymbolDictionary: expectedSymDictName inProject: projectDef

	| newPackageName newPackageDef |
	newPackageName := packageDef name, '-ext-', expectedSymDictName.
	newPackageDef := projectDef 
		packageNamed: newPackageName 
		ifAbsent: [ 
			| component  |
			component := projectDef componentForPackageNamed: packageDef name.
			projectDef addPackageNamed: newPackageName toComponentNamed: component name ].
	packageDef removeClassExtensionDefinition: theClassExtension.
	newPackageDef addClassExtensionDefinition: theClassExtension.
	"update the method categories --- hybrid only ... but that is what we're doing"
	theClassExtension instanceMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	theClassExtension classMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	^ newPackageDef
%

category: 'private'
method: RwPrjReconcileToolV2
_moveClassExtension: theClassExtension toNewPackageNamed: newPackageName clonedFrom: packageDef inProject: projectDef

	| newPackageDef |
	newPackageDef := projectDef 
		packageNamed: newPackageName 
		ifAbsent: [ 
			| component  |
			component := projectDef componentForPackageNamed: packageDef name.
			projectDef addPackageNamed: newPackageName toComponentNamed: component name ].
	packageDef removeClassExtensionDefinition: theClassExtension.
	newPackageDef addClassExtensionDefinition: theClassExtension.
	"update the method categories --- hybrid only ... but that is what we're doing"
	theClassExtension instanceMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	theClassExtension classMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	^ newPackageDef
%

! Class implementation for 'RwPrjTestTool'

!		Instance methods for 'RwPrjTestTool'

category: 'smalltalk api'
method: RwPrjTestTool
testSuiteForProjectNamed: projectName

	| suite |
	suite := TestSuite named: projectName , ' tests'.
	self _addTestsForProjectNamed: projectName toTestSuite: suite.
	^ suite
%

category: 'smalltalk api'
method: RwPrjTestTool
testSuiteForProjectsNamed: projectNames

	| suite strm |
	strm := WriteStream on: String new.
	projectNames do: [:projectName | strm nextPutAll: projectName; space ].
	strm nextPutAll:  'tests'.
	suite := TestSuite named: strm contents.
	projectNames do: [:projectName | self _addTestsForProjectNamed: projectName toTestSuite: suite ].
	^ suite
%

category: 'private'
method: RwPrjTestTool
_addTestsForProjectNamed: projectName toTestSuite: suite

	| loadedProject |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	loadedProject loadedPackages
		do: [ :loadedPackage | 
			loadedPackage loadedClasses values
				do: [ :rowanLoadedClass | 
					| cl |
					cl := rowanLoadedClass handle.
					(cl inheritsFrom: TestCase)
						ifTrue: [ 
							cl isAbstract
								ifFalse: [ suite addTests: cl suite tests ] ] ] ].
	^ suite
%

! Class implementation for 'RwPrjTraceTool'

!		Instance methods for 'RwPrjTraceTool'

category: 'testing'
method: RwPrjTraceTool
isTracing
	^ (SessionTemps current at: #'ROWAN_TRACE' otherwise: nil) == #'gciLogServer'
%

category: 'tracing'
method: RwPrjTraceTool
startTracing
	SessionTemps current at: #'ROWAN_TRACE' put: #'gciLogServer'
%

category: 'tracing'
method: RwPrjTraceTool
stopTracing
	SessionTemps current removeKey: #'ROWAN_TRACE' ifAbsent: []
%

category: 'tracing'
method: RwPrjTraceTool
trace: message
	self isTracing
		ifTrue: [ GsFile gciLogServer: message ]
%

! Class implementation for 'RwPrjWriteToolV2'

!		Instance methods for 'RwPrjWriteToolV2'

category: 'write'
method: RwPrjWriteToolV2
writeProjectNamed: projectName

	| loadedProject projectDefinition |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	projectDefinition := loadedProject asDefinition.
	self writeResolvedProject: projectDefinition.
	"loaded project and loaded packages written to disk - mark them not dirty"
	loadedProject markNotDirty.
	loadedProject loadedPackages valuesDo: [:loadedPackage | loadedPackage markNotDirty ].
%

category: 'write'
method: RwPrjWriteToolV2
writeResolvedProject: resolvedProject
	Rowan projectTools createV2
		createResolvedProjectRepository: resolvedProject repository.
	resolvedProject
		exportProjectSpecification;
		exportProjects;
		exportComponents;
		exportPackages
%

category: 'write'
method: RwPrjWriteToolV2
writeResolvedProjectPharoTonelFormatV1: resolvedProject
	Rowan projectTools createV2
		createResolvedProjectRepository: resolvedProject repository.
	resolvedProject
		exportProjectSpecification;
		exportProjects;
		exportComponents;
		exportPharoTonelFormatV1Packages
%

! Class implementation for 'RwAuditDetail'

!		Class methods for 'RwAuditDetail'

category: 'other'
classmethod: RwAuditDetail
for: anObject message: aString	
"add error to results. print to file"
	
	^self new owner: anObject; 
			message: aString; 
			notify; 
			yourself
%

category: 'other'
classmethod: RwAuditDetail
for: anObject reason: aSymbol message: aString
	"add error to results. print to file"

	^ self new
		owner: anObject;
		reason: aSymbol;
		message: aString;
		notify;
		yourself
%

!		Instance methods for 'RwAuditDetail'

category: 'other'
method: RwAuditDetail
matches: aString
"see if my messages matches expected string"

	^self message matchPattern: {$* . aString . $*}
%

category: 'other'
method: RwAuditDetail
message

	^message
%

category: 'other'
method: RwAuditDetail
message: aString

	message := aString
%

category: 'other'
method: RwAuditDetail
notify

	GsFile gciLogServer: self message.
	Notification signal: self message.
%

category: 'other'
method: RwAuditDetail
owner
	^owner
%

category: 'other'
method: RwAuditDetail
owner: anObject

	owner := anObject
%

category: 'other'
method: RwAuditDetail
printOn: aStream

	aStream 
			nextPutAll: '---------------';
			nextPutAll: self owner name asString.
	self owner isMeta ifTrue: [aStream space; nextPutAll: 'class'].
	aStream
			nextPutAll: '>>';
			nextPutAll: self message
%

category: 'accessing'
method: RwAuditDetail
reason
	^reason
%

category: 'accessing'
method: RwAuditDetail
reason: aSymbol
	reason := aSymbol
%

category: 'accessing'
method: RwAuditDetail
selector
	"non-method audit detail"

	^ nil
%

! Class implementation for 'RwAuditClassDetail'

!		Instance methods for 'RwAuditClassDetail'

category: 'accessing'
method: RwAuditClassDetail
behavior
	^behavior
%

category: 'accessing'
method: RwAuditClassDetail
behavior: object
	behavior := object
%

category: 'accessing'
method: RwAuditClassDetail
loadedClass
	^ self owner
%

! Class implementation for 'RwAuditClassPropertyDetail'

!		Instance methods for 'RwAuditClassPropertyDetail'

category: 'accessing'
method: RwAuditClassPropertyDetail
behavior
	^ self class
%

category: 'accessing'
method: RwAuditClassPropertyDetail
class
	^class
%

category: 'accessing'
method: RwAuditClassPropertyDetail
class: object
	class := object
%

category: 'accessing'
method: RwAuditClassPropertyDetail
classPropertyValue
	^classPropertyValue
%

category: 'accessing'
method: RwAuditClassPropertyDetail
classPropertyValue: object
	classPropertyValue := object
%

category: 'accessing'
method: RwAuditClassPropertyDetail
loadedClass
	^ self owner
%

category: 'accessing'
method: RwAuditClassPropertyDetail
loadedPropertyValue
	^loadedPropertyValue
%

category: 'accessing'
method: RwAuditClassPropertyDetail
loadedPropertyValue: object
	loadedPropertyValue := object
%

! Class implementation for 'RwAuditMethodCategoryDetail'

!		Instance methods for 'RwAuditMethodCategoryDetail'

category: 'accessing'
method: RwAuditMethodCategoryDetail
behavior
	^behavior
%

category: 'accessing'
method: RwAuditMethodCategoryDetail
behavior: object
	behavior := object
%

category: 'accessing'
method: RwAuditMethodCategoryDetail
category
	^category
%

category: 'accessing'
method: RwAuditMethodCategoryDetail
category: object
	category := object
%

category: 'accessing'
method: RwAuditMethodCategoryDetail
loadedClass
	^ self owner
%

! Class implementation for 'RwAuditMethodDetail'

!		Instance methods for 'RwAuditMethodDetail'

category: 'accessing'
method: RwAuditMethodDetail
behavior
	^behavior
%

category: 'accessing'
method: RwAuditMethodDetail
behavior: object
	behavior := object
%

category: 'accessing'
method: RwAuditMethodDetail
category
	^category
%

category: 'accessing'
method: RwAuditMethodDetail
category: object
	category := object
%

category: 'accessing'
method: RwAuditMethodDetail
loadedCategory
	^ loadedCategory ifNil: [ self loadedMethod methodCategory ]
%

category: 'accessing'
method: RwAuditMethodDetail
loadedCategory: object
	loadedCategory := object
%

category: 'accessing'
method: RwAuditMethodDetail
loadedClassOrClassExtension
	^ self owner
%

category: 'accessing'
method: RwAuditMethodDetail
loadedMethod
	^loadedMethod
%

category: 'accessing'
method: RwAuditMethodDetail
loadedMethod: object
	loadedMethod := object
%

category: 'accessing'
method: RwAuditMethodDetail
method
	^method
%

category: 'accessing'
method: RwAuditMethodDetail
method: object
	method := object
%

category: 'accessing'
method: RwAuditMethodDetail
selector
	^selector ifNil: [ self loadedMethod selector ]
%

category: 'accessing'
method: RwAuditMethodDetail
selector: object
	selector := object
%

! Class implementation for 'RwAuditPackageClassSymbolDictionaryDetail'

!		Instance methods for 'RwAuditPackageClassSymbolDictionaryDetail'

category: 'accessing'
method: RwAuditPackageClassSymbolDictionaryDetail
classSymbolDictionaryName
	^classSymbolDictionaryName
%

category: 'accessing'
method: RwAuditPackageClassSymbolDictionaryDetail
classSymbolDictionaryName: object
	classSymbolDictionaryName := object
%

category: 'accessing'
method: RwAuditPackageClassSymbolDictionaryDetail
loadedClass
	^loadedClass
%

category: 'accessing'
method: RwAuditPackageClassSymbolDictionaryDetail
loadedClass: object
	loadedClass := object
%

category: 'accessing'
method: RwAuditPackageClassSymbolDictionaryDetail
loadedPackage
	^ self owner
%

category: 'accessing'
method: RwAuditPackageClassSymbolDictionaryDetail
packageSymbolDictionaryName
	^packageSymbolDictionaryName
%

category: 'accessing'
method: RwAuditPackageClassSymbolDictionaryDetail
packageSymbolDictionaryName: object
	packageSymbolDictionaryName := object
%

! Class implementation for 'RwBasicProjectLoadComponentV2'

!		Instance methods for 'RwBasicProjectLoadComponentV2'

category: 'accessing'
method: RwBasicProjectLoadComponentV2
conditionalPackageMapSpecs
	"duplication of subclass implementation until we've moved to V2.1, since this method is 
		used during project load and superclass methods removed before subclass methods added.
		This duplication will go away, once this obsolete class is removed (planned for v2.1)."

	^ conditionalPackageMapSpecs
		ifNil: [ conditionalPackageMapSpecs := Dictionary new ]
%

category: 'accessing'
method: RwBasicProjectLoadComponentV2
conditionalPackageMapSpecs: aDict
	"duplication of subclass implementation until we've moved to V2.1, since this method is 
		used during project load and superclass methods removed before subclass methods added.
		This duplication will go away, once this obsolete class is removed (planned for v2.1)."

	 conditionalPackageMapSpecs := aDict
%

category: 'accessing'
method: RwBasicProjectLoadComponentV2
conditionalPackageMapSpecsAtGemStoneUserId: userId
	"duplication of subclass implementation until we've moved to V2.1, since this method is 
		used during project load and superclass methods removed before subclass methods added.
		This duplication will go away, once this obsolete class is removed (planned for v2.1)."

	^ (self conditionalPackageMapSpecs
		at: 'gemstone'
		ifAbsent: [ ^ Dictionary new ]) at: userId ifAbsent: [ ^ Dictionary new ]
%

! Class implementation for 'RwAbstractSimpleProjectLoadComponentV2'

!		Instance methods for 'RwAbstractSimpleProjectLoadComponentV2'

category: 'accessing'
method: RwAbstractSimpleProjectLoadComponentV2
packageNames
	"duplication of subclass implementation until we've moved to V2.1, since this method is 
		used during project load and superclass methods removed before subclass methods added.
		This duplication will go away, once this obsolete class is removed (planned for v2.1)."

	^ packageNames
%

category: 'accessing'
method: RwAbstractSimpleProjectLoadComponentV2
packageNames: anArray
 packageNames := anArray
%

! Class implementation for 'RwAbstractRowanProjectLoadComponentV2'

!		Class methods for 'RwAbstractRowanProjectLoadComponentV2'

category: 'instance creation'
classmethod: RwAbstractRowanProjectLoadComponentV2
fromComponentsDirectory: componentsDirectory named: componentName
	| component url |
	url := 'file:' , (componentsDirectory / componentName , 'ston') pathString.
	component := self fromUrl: url.
	component _readDoitsFrom: componentsDirectory.
	component _validateDoits.
	^ component
%

category: 'instance creation'
classmethod: RwAbstractRowanProjectLoadComponentV2
fromUrl: specNameOrUrl

	"self fromUrl: 'file:/home/dhenrich/rogue/_homes/rogue/_home/shared/repos/RowanSample1/configs/Default.ston'"

	| url |
	url := specNameOrUrl asRwUrl.
	url scheme isNil
		ifTrue: [ self error: 'scheme must be file: or https:' ].
	url scheme = 'file'
		ifTrue: [ ^ self fromFile: url pathForFile ].
	url scheme asString = 'https'
		ifTrue: [ 
self error: 'not yet supported'.
"
			| client response |
			GsSecureSocket disableCertificateVerificationOnClient.
			client := (Rowan globalNamed: 'ZnClient') new.
			response := client
				beOneShot;
				enforceHttpSuccess: true;
				get: url.
			^ self _readStonFrom: response decodeFromUTF8
" ].
	self error: 'Unknown scheme: ' , url scheme printString
%

category: 'instance creation'
classmethod: RwAbstractRowanProjectLoadComponentV2
new

	^self basicNew initialize
%

category: 'instance creation'
classmethod: RwAbstractRowanProjectLoadComponentV2
newNamed: aName

	^ self new
		name: aName;
		yourself
%

category: 'instance creation'
classmethod: RwAbstractRowanProjectLoadComponentV2
newNamed: aName for: projectName
	"this method should not exist"

	^ (self newNamed: aName)
		projectName: projectName;
		yourself
%

category: 'private'
classmethod: RwAbstractRowanProjectLoadComponentV2
_gemstoneSupportedPackagePropertyNames
	^ #('methodEnv' 'symbolDictName' 'useSessionMethodsForExtensions')
%

category: 'pattern matching'
classmethod: RwAbstractRowanProjectLoadComponentV2
_platformPatternMatcherFor: pattern
	" Returns an instance of RwAbstractConfigurationPlatformAttributeMatcher:
		RwStringConfigurationPlatformAttributeMatcher,
		RwGemStoneVersionConfigurationPlatformAttributeMatcher,
		or RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
	"

	| versionPattern gsVersion1 gsVersion2 |
	(pattern beginsWith: 'gs')
		ifFalse: [ 
			"simple equality match"
			^ RwStringConfigurationPlatformAttributeMatcher new
				pattern: pattern;
				patternMatchBlock: [ :a :b | a = b ];
				yourself ].	"GemStone version pattern"
	versionPattern := (pattern copyFrom: 3 to: pattern size) substrings: '.'.
	(versionPattern last beginsWith: '[')
		ifTrue: [ 
			| vpSize rangePattern dashIndex |
			"range pattern"
			vpSize := versionPattern size.
			gsVersion1 := RwGemStoneVersionNumber new: vpSize.
			1 to: vpSize - 1 do: [ :index | gsVersion1 at: index put: (versionPattern at: index) asInteger ].
			gsVersion1 at: vpSize put: 0.
			rangePattern := (versionPattern at: vpSize) trimBoth.
			((rangePattern at: 1) = $[ and: [ (rangePattern at: rangePattern size) = $] ])
				ifFalse: [ 
					self
						error:
							'Poorly formed GemStone version range pattern ' , rangePattern printString
								, ' in ' , pattern printString ].
			rangePattern := rangePattern copyFrom: 2 to: rangePattern size - 1.
			dashIndex := rangePattern indexOf: $-.
			dashIndex <= 1
				ifTrue: [ 
					self
						error:
							'Invalid version range pattern missing range begin' , rangePattern printString
								, ' in ' , pattern printString ].
			gsVersion1
				at: vpSize
				put: (rangePattern copyFrom: 1 to: dashIndex - 1) asInteger.
			dashIndex = rangePattern size
				ifTrue: [ 
					"open range"
					gsVersion2 := gsVersion1 copyFrom: 1 to: gsVersion1 size - 1.
					gsVersion2 at: gsVersion2 size put: (gsVersion2 at: gsVersion2 size) + 1.
					^ RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher new
						pattern: gsVersion1;
						pattern2: gsVersion2;
						patternMatchBlock: [ :a :b :c | a <= b & (b < c) ];
						yourself ]
				ifFalse: [ 
					"closed range"
					gsVersion2 := gsVersion1 copy.
					gsVersion2
						at: vpSize
						put:
							(rangePattern copyFrom: dashIndex + 1 to: rangePattern size) asInteger + 1.
					^ RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher new
						pattern: gsVersion1;
						pattern2: gsVersion2;
						patternMatchBlock: [ :a :b :c | a <= b & (b < c) ];
						yourself ] ].
	versionPattern last = 'x'
		ifTrue: [ 
			" 'gs', <gemstone-version-number> , '.x'"
			"match all values in x field"
			gsVersion1 := ((pattern copyFrom: 3 to: pattern size - 2) , '.0')
				asRwGemStoneVersionNumber.
			gsVersion2 := gsVersion1 copyFrom: 1 to: gsVersion1 size - 1.
			gsVersion2 at: gsVersion2 size put: (gsVersion2 at: gsVersion2 size) + 1.
			^ RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher new
				pattern: gsVersion1;
				pattern2: gsVersion2;
				patternMatchBlock: [ :a :b :c | a <= b & (b < c) ];
				yourself ]
		ifFalse: [ 
			"specific version number match, use ="
			pattern asRwGemStoneVersionNumber.	"sanity check to make sure that the original pattern is a valid version number"
			^ RwGemStoneVersionConfigurationPlatformAttributeMatcher new
				pattern: (pattern copyFrom: 3 to: pattern size) asRwGemStoneVersionNumber;
				patternMatchBlock: [ :a :b | a = b ];
				yourself ]
%

category: 'private'
classmethod: RwAbstractRowanProjectLoadComponentV2
_readStonFrom: stream
	| reader component |
	(reader := STONReader on: stream) allowComplexMapKeys: true.
	component := reader next
		initializeForImport;
		yourself.
	component validate.	"validate when reading from disk, since hand editting could create inconsistencies"
	^ component
%

!		Instance methods for 'RwAbstractRowanProjectLoadComponentV2'

category: 'comparing'
method: RwAbstractRowanProjectLoadComponentV2
= aRwProjectLoadComponentV2
	(aRwProjectLoadComponentV2 isKindOf: self class)
		ifFalse: [ ^ false ].
	^ ((((self name = aRwProjectLoadComponentV2 name
		and: [ self comment = aRwProjectLoadComponentV2 comment ])
		and: [ 
			self conditionalPackageMapSpecs
				= aRwProjectLoadComponentV2 conditionalPackageMapSpecs ])
		and: [ self condition = aRwProjectLoadComponentV2 condition ])
		and: [ self packageNames = aRwProjectLoadComponentV2 packageNames ])
		and: [ self componentNames = aRwProjectLoadComponentV2 componentNames ]
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
addComponentNamed: aComponentName 
	"avoid duplicates and keep the list sorted"
	self componentNames add: aComponentName.
	componentNames := componentNames asSet asArray sort
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
addComponentNames: aComponentNames
	"add component names"

	self componentNames addAll: aComponentNames.
	componentNames := componentNames asSet asArray sort
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
addPackageNames: aPackageNames
	"add packages to default conditional/group if applicable"

	self packageNames addAll: aPackageNames.
	packageNames := packageNames asSet asArray sort
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
addProjectNamed: aProjectName
	self subclassResponsibility: #'addProjectNamed:'
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
basename
	^ (self name subStrings: $/) last
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
comment

   ^comment
%

category: 'initialization'
method: RwAbstractRowanProjectLoadComponentV2
comment: anObject

   comment := anObject
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
componentNames

	^ componentNames
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
condition
	^condition
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
condition: aString
	aString isString
		ifFalse: [ self error: 'The condition is constrained to be a string' ].
	condition := aString
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
conditionalPackageMapSpecs

	^ conditionalPackageMapSpecs ifNil: [ conditionalPackageMapSpecs := Dictionary new ]
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
conditionalPackageMapSpecsAtGemStoneUserId: userId 

	^ ((self conditionalPackageMapSpecs at: 'gemstone' ifAbsent: [ ^ Dictionary new ])
		at: userId ifAbsent: [ ^ Dictionary new ])
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
conditionalPackageMapSpecsAtGemStoneUserId: userId andPackageName: packageName setSymbolDictNameTo: symbolDictName
	| dict |
	dict := (((self conditionalPackageMapSpecs
		at: 'gemstone'
		ifAbsentPut: [ Dictionary new ]) at: userId ifAbsentPut: [ Dictionary new ])
		at: #'packageNameToPlatformPropertiesMap'
		ifAbsentPut: [ Dictionary new ])
		at: packageName
		ifAbsentPut: [ Dictionary new ].
	symbolDictName
		ifNil: [ dict removeKey: 'symbolDictName' ifAbsent: [  ] ]
		ifNotNil: [ dict at: 'symbolDictName' put: symbolDictName asString ]
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
conditionalPackageMapSpecsAtGemStoneUserId: userId andPackageName: packageName setUseSessionMethodsForExtensions: aBool
	| dict |
	dict := (((self conditionalPackageMapSpecs
		at: 'gemstone'
		ifAbsentPut: [ Dictionary new ]) at: userId ifAbsentPut: [ Dictionary new ])
		at: #'packageNameToPlatformPropertiesMap'
		ifAbsentPut: [ Dictionary new ])
		at: packageName
		ifAbsentPut: [ Dictionary new ].
	aBool
		ifNil: [ dict removeKey: 'useSessionMethodsForExtensions' ifAbsent: [  ] ]
		ifNotNil: [ dict at: 'useSessionMethodsForExtensions' put: aBool ]
%

category: 'private'
method: RwAbstractRowanProjectLoadComponentV2
conditionalPropertyMatchers
	| conditionalPropertyMatchers |
	conditionalPropertyMatchers := Dictionary new
		at: {(self _platformPatternMatcherFor: self condition)} put: {};
		yourself.
	^ conditionalPropertyMatchers
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
doitDict
	^doitDict
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
doitDict: object
	doitDict := object
%

category: 'ston'
method: RwAbstractRowanProjectLoadComponentV2
excludedInstVars
	^ #()
%

category: 'doits'
method: RwAbstractRowanProjectLoadComponentV2
executePostloadDoit
	self postloadDoitName
		ifNotNil: [ (self doitDict at: self postloadDoitName) evaluate ]
%

category: 'doits'
method: RwAbstractRowanProjectLoadComponentV2
executePreloadDoit
	self preloadDoitName
		ifNotNil: [ (self doitDict at: self preloadDoitName) evaluate ]
%

category: 'exporting'
method: RwAbstractRowanProjectLoadComponentV2
exportDoitsToUrl: directoryUrl
	| doitsRoot url |
	url := directoryUrl asRwUrl.
	url schemeName = 'file'
		ifTrue: [ 
			doitsRoot := url pathForDirectory asFileReference.
			{(self preloadDoitName).
			(self postloadDoitName)}
				do: [ :doitName | 
					doitName
						ifNotNil: [ 
							(self doitDict at: doitName ifAbsent: [  ])
								ifNotNil: [ :doitString | 
									| fileRef |
									fileRef := doitsRoot / doitName , 'st'.
									fileRef exists
										ifFalse: [ fileRef ensureCreateFile ].
									fileRef
										writeStreamDo: [ :fileStream | fileStream nextPutAll: doitString ] ] ] ] ]
		ifFalse: [ self error: 'unsupported url scheme ' , url schemeName printString ]
%

category: 'exporting'
method: RwAbstractRowanProjectLoadComponentV2
exportToUrl: directoryUrl
	self exportDoitsToUrl: directoryUrl.
	^ self copy initializeForExport
		_exportToUrl: directoryUrl;
		yourself
%

category: 'testing'
method: RwAbstractRowanProjectLoadComponentV2
hasDoits
	^ preloadDoitName notNil or: [ postloadDoitName notNil ]
%

category: 'comparing'
method: RwAbstractRowanProjectLoadComponentV2
hash
	| hashValue |
	hashValue := self name hash.
	hashValue := hashValue bitXor: self comment hash.
	hashValue := hashValue bitXor: self conditionalPackageMapSpecs hash.
	hashValue := hashValue bitXor: self packageNames hash.
	^ hashValue bitXor: self componentNames hash
%

category: 'initialization'
method: RwAbstractRowanProjectLoadComponentV2
initialize
	comment := ''.
	doitDict := Dictionary new.
	condition := 'common'.
	packageNames := {}.
	componentNames := {}
%

category: 'initialization'
method: RwAbstractRowanProjectLoadComponentV2
initializeForExport
	"if spec is to be exported, clear out any of the fields that represent state that should 
	not be shared"

	"for export, the keys in the dictionaries of the structures need to be put into canonical order"

	doitDict := projectName := nil.
	conditionalPackageMapSpecs
		ifNotNil: [ 
			conditionalPackageMapSpecs isEmpty
				ifTrue: [ 
					"don't export this field if it is empty ..."
					conditionalPackageMapSpecs := nil ]
				ifFalse: [ 
					| orderedConditionalPackageMapSpecs |
					orderedConditionalPackageMapSpecs := self class orderedDictionaryClass new.
					(conditionalPackageMapSpecs keys asSortedCollection: [ :a :b | a <= b ])
						do: [ :platformName | 
							| orderedPlatformMap platformMap |
							platformMap := conditionalPackageMapSpecs at: platformName.
							orderedPlatformMap := platformName = 'gemstone'
								ifTrue: [ self _canonicalizeGemStonePackageMapSpecs: platformMap ]
								ifFalse: [ self error: 'Unknown platform name ' , platformName printString ].
							orderedPlatformMap isEmpty
								ifFalse: [ orderedConditionalPackageMapSpecs at: platformName put: orderedPlatformMap ] ].
					conditionalPackageMapSpecs := orderedConditionalPackageMapSpecs ] ]
%

category: 'initialization'
method: RwAbstractRowanProjectLoadComponentV2
initializeForImport

	"if spec has been imported, clear out any of the fields that represent state that should 
	not be shared"

	projectName := nil
%

category: 'ston'
method: RwAbstractRowanProjectLoadComponentV2
instVarNamesInOrderForSton

	^ self class allInstVarNames
%

category: 'matching'
method: RwAbstractRowanProjectLoadComponentV2
matchesAttributes: attributes
	self conditionalPropertyMatchers
		keysAndValuesDo: [ :platformMatchers :ignored | ^ self _platformAttributeMatchIn: platformMatchers for: attributes ]
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
name

   ^name
%

category: 'initialization'
method: RwAbstractRowanProjectLoadComponentV2
name: anObject

   name := anObject
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
packageNames

	^ packageNames
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
packageNamesForPlatformConfigurationAttributes: platformConfigurationAttributes
	"Answer the collection of package names defined in the receiver."

	| allDefinedPackageNames matchers |
	allDefinedPackageNames := Set new.
	matchers := self conditionalPropertyMatchers.
	platformConfigurationAttributes
		do: [ :anObject | 
			matchers
				keysAndValuesDo: [ :ar :ignored | 
					ar
						do: [ :matcher | 
							(matcher match: anObject)
								ifTrue: [ allDefinedPackageNames addAll: self packageNames ] ] ] ].
	^ allDefinedPackageNames
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
postloadDoitName
	^postloadDoitName
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
postloadDoitName: object
	postloadDoitName := object
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
preloadDoitName
	^preloadDoitName
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
preloadDoitName: object
	preloadDoitName := object
%

category: 'printing'
method: RwAbstractRowanProjectLoadComponentV2
printOn: aStream
	super printOn: aStream.
	aStream
		space;
		nextPutAll: name.
	projectName ifNotNil: [ aStream nextPutAll: ' for project ' , projectName ]
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
projectName

   ^projectName
%

category: 'initialization'
method: RwAbstractRowanProjectLoadComponentV2
projectName: anObject

   projectName := anObject
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
referencePath
	^ Path from: self name
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
removeComponentNamed: aComponentName
	self componentNames remove: aComponentName ifAbsent: [  ]
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
removePackageNamed: aPackageName
	self conditionalPackageMapSpecs
		keysAndValuesDo: [ :platformPattern :packageMapSpecsMap | 
			packageMapSpecsMap
				keysAndValuesDo: [ :userId :packageMapSpecs | 
					(packageMapSpecs at: #'packageNameToPlatformPropertiesMap')
						removeKey: aPackageName
						ifAbsent: [  ] ] ].
	self packageNames remove: aPackageName ifAbsent: [  ]
%

category: 'accessing'
method: RwAbstractRowanProjectLoadComponentV2
removeProjectNamed: aProjectName
	self subclassResponsibility: #'removeProjectNamed:'
%

category: 'ston'
method: RwAbstractRowanProjectLoadComponentV2
stonOn: stonWriter
	| instanceVariableNames allInstanceVariableNames |
	instanceVariableNames := self instVarNamesInOrderForSton
		reject: [ :iv | self excludedInstVars includes: iv ].
	allInstanceVariableNames := self class allInstVarNames.
	stonWriter
		writeObject: self
		streamMap: [ :dictionary | 
			instanceVariableNames
				do: [ :each | 
					(self instVarAt: (allInstanceVariableNames indexOf: each asSymbol))
						ifNotNil: [ :value | dictionary at: each asSymbol put: value ]
						ifNil: [ 
							self stonShouldWriteNilInstVars
								ifTrue: [ dictionary at: each asSymbol put: nil ] ] ] ]
%

category: 'validation'
method: RwAbstractRowanProjectLoadComponentV2
validate
	"ensure that the data structures within the receiver contain valid information:
		1. only packages defined in the receiver may be referenced in the reciever
		2. platform implementation is responsible for validating platform structures"

	| allDefinedPackageNames |
	self name ifNil: [ self error: 'name is nil' ].
	allDefinedPackageNames := self _validatedPackageNames.
	self conditionalPackageMapSpecs
		keysAndValuesDo: [ :platformName :platformPropertiesMap | 
			(RwSpecification _supportedPlatformNames includes: platformName)
				ifFalse: [ 
					Error
						signal:
							'Unknown platform name ' , platformName printString
								, ' in conditional package map specs' ].
			platformName = 'gemstone'
				ifTrue: [ self _validateGemStonePlatform: allDefinedPackageNames userIdMap: platformPropertiesMap ] ].
	^ true
%

category: 'private'
method: RwAbstractRowanProjectLoadComponentV2
_canonicalizeGemStonePackageMapSpecs: userMap
	| orderedUserMap |
	orderedUserMap := self class orderedDictionaryClass new.
	(userMap keys asSortedCollection: [ :a :b | a <= b ])
		do: [ :userName | 
			| attributeMap orderedAttributeMap |
			attributeMap := userMap at: userName.
			orderedAttributeMap := self class orderedDictionaryClass new.
			(attributeMap keys asSortedCollection: [ :a :b | a <= b ])
				do: [ :attributeName | 
					| packageMap orderedPackageMap |
					packageMap := attributeMap at: attributeName.
					orderedPackageMap := self class orderedDictionaryClass new.
					(packageMap keys asSortedCollection: [ :a :b | a <= b ])
						do: [ :packageName | 
							(packageMap at: packageName) isEmpty
								ifFalse: [ orderedPackageMap at: packageName put: (packageMap at: packageName) ] ].
					orderedPackageMap isEmpty
						ifFalse: [ orderedAttributeMap at: attributeName put: orderedPackageMap ] ].
			orderedAttributeMap isEmpty
				ifFalse: [ orderedUserMap at: userName put: orderedAttributeMap ] ].
	^ orderedUserMap
%

category: 'matching'
method: RwAbstractRowanProjectLoadComponentV2
_platformAttributeMatchIn: platformMatchersList for: attributes
	platformMatchersList
		do: [ :platformPatternMatcher | 
			attributes
				do: [ :anObject | 
					(platformPatternMatcher match: anObject)
						ifTrue: [ ^ true ] ] ].
	^ false
%

category: 'private'
method: RwAbstractRowanProjectLoadComponentV2
_platformPatternMatcherFor: pattern
	^ self class _platformPatternMatcherFor: pattern
%

category: 'doits'
method: RwAbstractRowanProjectLoadComponentV2
_readDoitsFrom: componentsRoot
	| fileRef |
	preloadDoitName
		ifNotNil: [ 
			fileRef := componentsRoot / preloadDoitName , 'st'.
			fileRef exists
				ifTrue: [ 
					fileRef
						readStreamDo: [ :fileStream | self doitDict at: preloadDoitName put: fileStream contents ] ]
				ifFalse: [ self error: '"no doit file ' , preloadDoitName printString , ' found"' ] ].
	postloadDoitName
		ifNotNil: [ 
			fileRef := componentsRoot / postloadDoitName , 'st'.

			fileRef exists
				ifTrue: [ 
					fileRef
						readStreamDo: [ :fileStream | self doitDict at: postloadDoitName put: fileStream contents ] ]
				ifFalse: [ self error: '"no doit file ' , postloadDoitName printString , ' found"' ] ]
%

category: 'validation'
method: RwAbstractRowanProjectLoadComponentV2
_validateDoits
	self preloadDoitName
		ifNotNil: [ 
			((self doitDict
				at: self preloadDoitName
				ifAbsent: [ 
					self
						error:
							'Expected doit for ' , self preloadDoitName printString , ' to exist.' ])
				isKindOf: CharacterCollection)
				ifFalse: [ 
					self
						error:
							'Doit for ' , self preloadDoitName printString , ' is not a CharacterCollection' ] ].
	self postloadDoitName
		ifNotNil: [ 
			((self doitDict
				at: self postloadDoitName
				ifAbsent: [ 
					self
						error:
							'Expected doit for ' , self postloadDoitName printString , ' to exist.' ])
				isKindOf: CharacterCollection)
				ifFalse: [ 
					self
						error:
							'Doit for ' , self postloadDoitName printString
								, ' is not a CharacterCollection' ] ]
%

category: 'validation'
method: RwAbstractRowanProjectLoadComponentV2
_validatedPackageNames
	"answer the validated set of package names"

	self subclassResponsibility: #'_validatedPackageNames'
%

category: 'validation'
method: RwAbstractRowanProjectLoadComponentV2
_validateGemStonePlatform: allDefinedPackageNames userIdMap: userIdMap
	"ensure that the data structures within the receiver contain valid information:
		1. only packages defined in the receiver may be referenced in the reciever
		2. platform implementation is responsible for validating platform structures"

	userIdMap
		keysAndValuesDo: [ :userId :platformPropertiesMap | 
			platformPropertiesMap
				keysAndValuesDo: [ :key :packagePropertiesMap | 
					key == #'packageNameToPlatformPropertiesMap'
						ifFalse: [ Error signal: 'Unknown platformPropertiesMap key ' , key printString ].
					packagePropertiesMap
						keysAndValuesDo: [ :packageName :packageProperties | 
							(allDefinedPackageNames includes: packageName)
								ifFalse: [ 
									Error
										signal:
											'Undefined package name ' , packageName printString
												, ' used in plaform properties map' ].
							packageProperties
								keysDo: [ :packagePropertyName | 
									(self class _gemstoneSupportedPackagePropertyNames
										includes: packagePropertyName)
										ifFalse: [ Error signal: 'Unknown package property name ' , packagePropertyName printString ] ] ] ] ]
%

! Class implementation for 'RwSimpleProjectLoadComponentV2'

!		Instance methods for 'RwSimpleProjectLoadComponentV2'

category: 'comparing'
method: RwSimpleProjectLoadComponentV2
= aRwSimpleProjectLoadComponentV2
	^ super = aRwSimpleProjectLoadComponentV2
		and: [ self projectNames = aRwSimpleProjectLoadComponentV2 projectNames ]
%

category: 'visiting'
method: RwSimpleProjectLoadComponentV2
acceptNestedVisitor: aVisitor

	^ self acceptVisitor: aVisitor
%

category: 'visiting'
method: RwSimpleProjectLoadComponentV2
acceptVisitor: aVisitor
	^ aVisitor visitSimpleProjectLoadComponent: self
%

category: 'accessing'
method: RwSimpleProjectLoadComponentV2
addProjectNamed: aProjectName
	self projectNames add: aProjectName.
	projectNames := projectNames asSet asArray sort
%

category: 'accessing'
method: RwSimpleProjectLoadComponentV2
conditionalPropertyMatchers
	| conditionalPropertyMatchers |
	conditionalPropertyMatchers := Dictionary new
		at: {(self _platformPatternMatcherFor: self condition)} put: {};
		yourself.
	^ conditionalPropertyMatchers
%

category: 'comparing'
method: RwSimpleProjectLoadComponentV2
hash
	^ super hash bitXor: self projectNames hash
%

category: 'initialization'
method: RwSimpleProjectLoadComponentV2
initialize
	super initialize.
	projectNames := {}
%

category: 'ston'
method: RwSimpleProjectLoadComponentV2
instVarNamesInOrderForSton
	^ #(#'name' #'projectName' #'condition' #'preloadDoitName' #'postloadDoitName' #'projectNames' #'componentNames' #'packageNames' #'conditionalPackageMapSpecs' #'comment')
%

category: 'accessing'
method: RwSimpleProjectLoadComponentV2
projectNames
	^projectNames
%

category: 'accessing'
method: RwSimpleProjectLoadComponentV2
removeProjectNamed: aProjectName
	self projectNames remove: aProjectName ifAbsent: [  ]
%

category: 'validation'
method: RwSimpleProjectLoadComponentV2
_validatedPackageNames
	"answer the validated set of package names"

	^ self packageNames asSet
%

! Class implementation for 'RwSimpleNestedProjectLoadComponentV2'

!		Instance methods for 'RwSimpleNestedProjectLoadComponentV2'

category: 'visiting'
method: RwSimpleNestedProjectLoadComponentV2
acceptNestedVisitor: aVisitor
	^ aVisitor visitSimpleProjectLoadComponent: self
%

category: 'visiting'
method: RwSimpleNestedProjectLoadComponentV2
acceptVisitor: aVisitor
	^ self
		error:
			'nested component cannot be used as a top-level configuration. The receiver is nested inside of top-level components'
%

! Class implementation for 'RwPlatformNestedProjectLoadComponentV2'

!		Instance methods for 'RwPlatformNestedProjectLoadComponentV2'

category: 'accessing'
method: RwPlatformNestedProjectLoadComponentV2
addComponentNamed: aComponentName
	self
		error:
			'a platform nested component may only reference package names'
%

category: 'accessing'
method: RwPlatformNestedProjectLoadComponentV2
addProjectNamed: aProjectName
	self
		error:
			'a platform nested component may only reference package names'
%

category: 'accessing'
method: RwPlatformNestedProjectLoadComponentV2
componentNames
	"a platform nested component may only reference package names --- OR conditionals may only be used by a leaf node"

	^ #()
%

category: 'accessing'
method: RwPlatformNestedProjectLoadComponentV2
condition: anArray
	anArray _isArray
		ifFalse: [ self error: 'The condition is constrained to be an array' ].
	condition := anArray
%

category: 'accessing'
method: RwPlatformNestedProjectLoadComponentV2
conditionalPropertyMatchers
	| conditionalPropertyMatchers |
	conditionalPropertyMatchers := Dictionary new
		at:
				(self condition
						collect: [ :aCondition | self _platformPatternMatcherFor: aCondition ])
			put: {};
		yourself.
	^ conditionalPropertyMatchers
%

category: 'initialization'
method: RwPlatformNestedProjectLoadComponentV2
initialize
	super initialize.
	componentNames := projectNames := nil
%

category: 'initialization'
method: RwPlatformNestedProjectLoadComponentV2
initializeForExport
	"if spec is to be exported, clear out any of the fields that represent state that should 
	not be shared"

	"for export, the keys in the dictionaries of the structures need to be put into canonical order"

	super initializeForExport.
	projectNames := componentNames := nil
%

category: 'accessing'
method: RwPlatformNestedProjectLoadComponentV2
projectNames
	"a platform nested component may only reference package names --- OR conditionals may only be used by a leaf node"

	^ #()
%

! Class implementation for 'RwClassAdditionOrRemoval'

!		Class methods for 'RwClassAdditionOrRemoval'

category: 'instance creation'
classmethod: RwClassAdditionOrRemoval
packageDefinition: aPackageDefinition classKey: aClassKey classesModification: aClassesModification

	^(self new)
		packageDefinition: aPackageDefinition;
		classKey: aClassKey;
		classesModification: aClassesModification;
		yourself
%

category: 'instance creation'
classmethod: RwClassAdditionOrRemoval
projectDefinition: aProjectDefinition packageDefinition: aPackageDefinition classKey: aClassKey classesModification: aClassesModification

	^(self new)
		projectDefinition: aProjectDefinition;
		packageDefinition: aPackageDefinition;
		classKey: aClassKey;
		classesModification: aClassesModification;
		yourself
%

!		Instance methods for 'RwClassAdditionOrRemoval'

category: 'Accessing'
method: RwClassAdditionOrRemoval
classesModification
	^classesModification
%

category: 'Updating'
method: RwClassAdditionOrRemoval
classesModification: newValue
	classesModification := newValue
%

category: 'Accessing'
method: RwClassAdditionOrRemoval
classKey
	^classKey
%

category: 'Updating'
method: RwClassAdditionOrRemoval
classKey: newValue
	classKey := newValue
%

category: 'Accessing'
method: RwClassAdditionOrRemoval
packageDefinition
	^packageDefinition
%

category: 'Updating'
method: RwClassAdditionOrRemoval
packageDefinition: newValue
	packageDefinition := newValue
%

category: 'Accessing'
method: RwClassAdditionOrRemoval
projectDefinition
	^projectDefinition
%

category: 'Updating'
method: RwClassAdditionOrRemoval
projectDefinition: newValue
	projectDefinition := newValue
%

! Class implementation for 'RwConfiguration'

!		Instance methods for 'RwConfiguration'

category: 'accessing'
method: RwConfiguration
packageInfoSource
	^packageInfoSource
%

category: 'accessing'
method: RwConfiguration
packageInfoSource: newValue
	"Valid values for GemStone are #Cypress, #Category, #SymbolDictionary"

	packageInfoSource := newValue
%

! Class implementation for 'RwDefinition'

!		Class methods for 'RwDefinition'

category: 'instance creation'
classmethod: RwDefinition
new

	^(super new)
		initialize;
		yourself
%

!		Instance methods for 'RwDefinition'

category: 'private'
method: RwDefinition
addDefinition: aDefinition to: aDictionary

	| key |
	key := aDefinition key.
	(aDictionary includesKey: key) ifTrue: [
     | nam |
     nam := [ ' in ' , self name ] on: Error do:[:ex | '' ].
     self error: 'Duplicate definition of ', key , nam .
   ].
	^ aDictionary at: key put: aDefinition
%

category: 'converting'
method: RwDefinition
asDefinition
  ^ self
%

category: 'comparing'
method: RwDefinition
compareAgainstBase: aDefinition
	"Diff myself for changes against the given base definition. 
	Answer a Modification, which might be empty if there are no changes."

	self subclassResponsibility
%

category: 'comparing'
method: RwDefinition
compareAgainstBaseForNewClassUnmanagedVersion: aBaseDefinition

	"Diff myself for changes against the given base definition. 
	Answer a Modification, which might be empty if there are no changes."

	"Filter the definition to include changes that are only applicable to new unmanaged class versions"

	self subclassResponsibility
%

category: 'comparing'
method: RwDefinition
compareAgainstBaseForNewClassVersion: aBaseDefinition

	"Diff myself for changes against the given base definition. 
	Answer a Modification, which might be empty if there are no changes."

	"Filter the definition to include changes that are only applicable to new class versions"

	self subclassResponsibility
%

category: 'comparing'
method: RwDefinition
compareDictionary: myDictionary againstBaseDictionary: baseDictionary into: anElementsModification elementClass: elementClass

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys do: 
			[:key |
			| before after modification |
			before := baseDictionary at: key ifAbsent: [elementClass new].
			after := myDictionary at: key ifAbsent: [elementClass new].
			modification := after compareAgainstBase: before.
			modification isEmpty
				ifFalse: [anElementsModification addElementModification: modification]]
%

category: 'initialization'
method: RwDefinition
initialize

	properties := Dictionary new
%

category: 'testing'
method: RwDefinition
isEmpty
	"Answer true if this definition does not actually define anything.
	All definitions are expected to have at least a name property."

	^properties isEmpty
%

category: 'properties'
method: RwDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container."

	self subclassResponsibility
%

category: 'copying'
method: RwDefinition
postCopy

	| oldProperties |
	super postCopy.
	oldProperties := properties.
	properties := Dictionary new.
	oldProperties keysAndValuesDo: [:key :value| properties at: key put: value copy ]
%

category: 'printing'
method: RwDefinition
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' for ';
		nextPutAll: (self key ifNil: ['nil'])
%

category: 'accessing'
method: RwDefinition
properties

	^properties
%

category: 'accessing'
method: RwDefinition
properties: propertiesDictionary

	properties := propertiesDictionary
%

category: 'accessing'
method: RwDefinition
propertyAt: aKey

	^properties at: aKey
%

category: 'accessing'
method: RwDefinition
propertyAt: aKey ifAbsent: absentBlock

	^properties at: aKey ifAbsent: absentBlock
%

category: 'properties'
method: RwDefinition
propertyAt: aKey put: aValue

	^properties at: aKey put: aValue
%

category: 'private'
method: RwDefinition
removeDefinition: aDefinition from: aDictionary

	| key |
	key := aDefinition key.
	aDictionary
		removeKey: key
		ifAbsent: [ self error: 'no definition for ' , key printString , ' found' ]
%

category: 'private'
method: RwDefinition
removeKey: key from: aDictionary
	^ self
		removeKey: key
		from: aDictionary
		ifAbsent: [ self error: 'no definition for ' , key printString , ' found' ]
%

category: 'private'
method: RwDefinition
removeKey: key from: aDictionary ifAbsent: absentBlock
	^ aDictionary removeKey: key ifAbsent: absentBlock
%

category: 'properties'
method: RwDefinition
removeProperty: propertyName

	properties removeKey: propertyName ifAbsent: []
%

category: 'private'
method: RwDefinition
updateDefinition: aDefinition in: aDictionary

	| key |
	key := aDefinition key.
	aDictionary at: key put: aDefinition
%

category: 'private'
method: RwDefinition
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue

	^ propertyValue = baseValue
%

! Class implementation for 'RwAbstractClassDefinition'

!		Class methods for 'RwAbstractClassDefinition'

category: 'instance creation'
classmethod: RwAbstractClassDefinition
withProperties: propertiesDictionary classMethodDefinitions: classMethodDefinitions instanceMethodDefinitions: instanceMethodDefinitions

	^(self basicNew)
		properties: propertiesDictionary;
		classMethodDefinitions: classMethodDefinitions;
		instanceMethodDefinitions: instanceMethodDefinitions;
		yourself
%

!		Instance methods for 'RwAbstractClassDefinition'

category: 'accessing'
method: RwAbstractClassDefinition
addClassMethod: methodSource protocol: protocol

	^self addClassMethodDefinition: (RwMethodDefinition newForSource: methodSource protocol: protocol)
%

category: 'accessing'
method: RwAbstractClassDefinition
addClassMethodDefinition: aMethodDefinition

	^ self addDefinition: aMethodDefinition to: classMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
addInstanceMethod: methodSource protocol: protocol

	^self addInstanceMethodDefinition: (RwMethodDefinition newForSource: methodSource protocol: protocol)
%

category: 'accessing'
method: RwAbstractClassDefinition
addInstanceMethodDefinition: aMethodDefinition

	^ self addDefinition: aMethodDefinition to: instanceMethodDefinitions
%

category: 'private'
method: RwAbstractClassDefinition
addMethodDefinition: aMethodDefinition to: aDictionary

	| selector |
	selector := aMethodDefinition propertyAt: 'selector'.
	(aDictionary includesKey: selector)
		ifTrue: [self error: 'Duplicate selector in behavior'].
	aDictionary at: selector put: aMethodDefinition
%

category: 'accessing'
method: RwAbstractClassDefinition
classMethodDefinitions

	^classMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
classMethodDefinitions: dictionaryOfDefinitions

	classMethodDefinitions := dictionaryOfDefinitions
%

category: 'comparing'
method: RwAbstractClassDefinition
compareAgainstBase: aDefinition

	^self compareAgainstBase: aDefinition using:  self _modificationClass
%

category: 'comparing'
method: RwAbstractClassDefinition
compareAgainstBase: aDefinition using: aModificationClass

	| modification instanceMethodsModification classMethodsModification className |
	modification := aModificationClass before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	className := self _classNameForCompare: aDefinition.
	instanceMethodsModification := self _methodsModificationClass
		extendedClassName: className.
	classMethodsModification := self _methodsModificationClass
		extendedClassName: className.
	self
		compareDictionary: instanceMethodDefinitions
		againstBaseDictionary: aDefinition instanceMethodDefinitions
		into: instanceMethodsModification
		elementClass: RwMethodDefinition
		isMeta: false.
	self
		compareDictionary: classMethodDefinitions
		againstBaseDictionary: aDefinition classMethodDefinitions
		into: classMethodsModification
		elementClass: RwMethodDefinition
		isMeta: true.
	modification
		instanceMethodsModification: instanceMethodsModification;
		classMethodsModification: classMethodsModification.
	^ modification
%

category: 'comparing'
method: RwAbstractClassDefinition
compareAgainstBaseForNewClassUnmanagedVersion: aDefinition
	"all unchanged and unremoved methods need to be applied to the patch"

	^ self
		compareAgainstBase: aDefinition
		using: RwClassUnmanagedModification
%

category: 'comparing'
method: RwAbstractClassDefinition
compareAgainstBaseForNewClassVersion: aDefinition
	"all unchanged and unremoved methods need to be applied to the patch"

	^ self
		compareAgainstBaseForNewClassVersion: aDefinition
		using: self _modificationClass
%

category: 'comparing'
method: RwAbstractClassDefinition
compareAgainstBaseForNewClassVersion: aDefinition using: modificationClass

	"all unchanged and unremoved methods need to be applied to the patch"

	| modification instanceMethodsModification classMethodsModification |
	modification := modificationClass before: aDefinition after: self.
	instanceMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	classMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	self
		compareDictionary: instanceMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition instanceMethodDefinitions
		into: instanceMethodsModification
		elementClass: RwMethodDefinition
		isMeta: false.
	self
		compareDictionary: classMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition classMethodDefinitions
		into: classMethodsModification
		elementClass: RwMethodDefinition
		isMeta: true.
	modification
		instanceMethodsModification: instanceMethodsModification;
		classMethodsModification: classMethodsModification.
	^ modification
%

category: 'comparing'
method: RwAbstractClassDefinition
compareDictionary: myDictionary againstBaseDictionary: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys do: 
			[:key |
			| before after modification |
			before := baseDictionary at: key ifAbsent: [elementClass new].
			after := myDictionary at: key ifAbsent: [elementClass new].
			modification := after compareAgainstBase: before.
			modification 
				isMeta: isClassMeta;
				classDefinition: self.
			modification isEmpty
				ifFalse: [anElementsModification addElementModification: modification]]
%

category: 'comparing'
method: RwAbstractClassDefinition
compareDictionary: myDictionary againstBaseDictionaryForNewClassVersion: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys
		do: [ :key | 
			(baseDictionary
				at: key
				ifAbsent: [ 
					"additions do not apply for new class version - the original modification should not be changed"
					 ])
				ifNotNil: [ :before | 
					(myDictionary
						at: key
						ifAbsent: [ 
							"deletions do not apply for new class version - the original modification should not be changed"
							 ])
						ifNotNil: [ :after | 
							| modification |
							modification := after compareAgainstBaseForNewClassVersion: before.
							modification
								isMeta: isClassMeta;
								classDefinition: self.
							modification isEmpty
								ifFalse: [ anElementsModification addElementModification: modification ] ] ] ]
%

category: 'initialization'
method: RwAbstractClassDefinition
initialize

	super initialize.
	classMethodDefinitions := Dictionary new.
	instanceMethodDefinitions := Dictionary new
%

category: 'accessing'
method: RwAbstractClassDefinition
instanceMethodDefinitions

	^instanceMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
instanceMethodDefinitions: dictionaryOfDefinitions

	instanceMethodDefinitions := dictionaryOfDefinitions
%

category: 'testing'
method: RwAbstractClassDefinition
isClassExtension
	^ false
%

category: 'testing'
method: RwAbstractClassDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & classMethodDefinitions isEmpty
		& instanceMethodDefinitions isEmpty
%

category: 'private'
method: RwAbstractClassDefinition
key

	^properties at: 'name' ifAbsent: [nil]
%

category: 'accessing'
method: RwAbstractClassDefinition
moveToPackageNamed: aPackageName packageConvention: aPackageConvention
	self subclassResponsibility: #'moveToPackageNamed:packageConvention:'
%

category: 'accessing'
method: RwAbstractClassDefinition
name: aString

	properties at: 'name' put: aString
%

category: 'copying'
method: RwAbstractClassDefinition
postCopy

	| oldDefs |
	super postCopy.
	oldDefs := classMethodDefinitions.
	classMethodDefinitions := Dictionary new.
	oldDefs keysAndValuesDo: [:key :value | classMethodDefinitions at: key put: value copy ].
	oldDefs := instanceMethodDefinitions.
	instanceMethodDefinitions := Dictionary new.
	oldDefs keysAndValuesDo: [:key :value | instanceMethodDefinitions at: key put: value copy ].
%

category: 'accessing'
method: RwAbstractClassDefinition
removeClassMethod: selector
	^ self
		removeClassMethod: selector
		ifAbsent: [ self error: 'No method definition for ' , selector printString , ' found.' ]
%

category: 'accessing'
method: RwAbstractClassDefinition
removeClassMethod: selector ifAbsent: absentBlock
	| definition |
	definition := classMethodDefinitions
		at: selector
		ifAbsent: [ absentBlock value ].
	self removeDefinition: definition from: classMethodDefinitions.
	^ definition
%

category: 'accessing'
method: RwAbstractClassDefinition
removeInstanceMethod: selector
	^ self
		removeInstanceMethod: selector
		ifAbsent: [ self error: 'No method definition for ' , selector printString , ' found.' ]
%

category: 'accessing'
method: RwAbstractClassDefinition
removeInstanceMethod: selector ifAbsent: absentBlock
	| definition |
	definition := instanceMethodDefinitions
		at: selector
		ifAbsent: [ ^ absentBlock value ].
	self removeDefinition: definition from: instanceMethodDefinitions.
	^ definition
%

category: 'accessing'
method: RwAbstractClassDefinition
updateClassMethodDefinition: aMethodDefinition

	self updateDefinition: aMethodDefinition in: classMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
updateInstanceMethod: methodSource protocol: protocol

	^self updateInstanceMethodDefinition: (RwMethodDefinition newForSource: methodSource protocol: protocol)
%

category: 'accessing'
method: RwAbstractClassDefinition
updateInstanceMethodDefinition: aMethodDefinition

	self updateDefinition: aMethodDefinition in: instanceMethodDefinitions
%

category: 'private'
method: RwAbstractClassDefinition
_classNameForCompare: aDefinition

	^ self key ifNil: [ aDefinition key ]
%

category: 'private'
method: RwAbstractClassDefinition
_methodsModificationClass

	self subclassResponsibility: #'__methodsModificationClass'
%

category: 'private'
method: RwAbstractClassDefinition
_modificationClass

	self subclassResponsibility: #'_modificationClass'
%

! Class implementation for 'RwClassDefinition'

!		Class methods for 'RwClassDefinition'

category: 'instance creation'
classmethod: RwClassDefinition
newForClassNamed: className super: superClassName category: category

	^ self 
		newForClassNamed: className 
		super: superClassName 
		instvars: #() 
		classinstvars: #() 
		classvars: #() 
		category: category 
		comment: nil 
		pools: #() 
		type: 'normal'
%

category: 'instance creation'
classmethod: RwClassDefinition
newForClassNamed: className super: superClassName category: category comment: comment

	^ self 
		newForClassNamed: className 
		super: superClassName 
		instvars: #() 
		classinstvars: #() 
		classvars: #() 
		category: category 
		comment: comment 
		pools: #() 
		type: 'normal'
%

category: 'instance creation'
classmethod: RwClassDefinition
newForClassNamed: className super: superClassName instvars: instvars
	^ self
		newForClassNamed: className
		super: superClassName
		instvars: instvars
		classinstvars: #()
		classvars: #()
		category: nil
		comment: nil
		pools: #()
		type: 'normal'
%

category: 'instance creation'
classmethod: RwClassDefinition
newForClassNamed: className super: superClassName instvars: instvars category: category

	^ self 
		newForClassNamed: className 
		super: superClassName 
		instvars: instvars
		classinstvars: #() 
		classvars: #() 
		category: category 
		comment: nil 
		pools: #() 
		type: 'normal'
%

category: 'instance creation'
classmethod: RwClassDefinition
newForClassNamed: className super: superClassName instvars: instvars classinstvars: classinstvars classvars: classvars category: category comment: comment pools: pools type: type
	| propertiesDictionary |
	propertiesDictionary := Dictionary new.
	category
		ifNotNil: [ 
			propertiesDictionary
				at: 'category' put: category asString;
				yourself ].
	propertiesDictionary
		at: 'classinstvars' put: (classinstvars collect: [ :each | each asString ]);
		at: 'classvars' put: (classvars collect: [ :each | each asString ]);
		at: 'instvars' put: (instvars collect: [ :each | each asString ]);
		at: 'name' put: className asString;
		at: 'pools' put: pools;
		at: 'superclass' put: superClassName asString;
		at: 'type' put: type asString.
	comment ifNotNil: [ propertiesDictionary at: 'comment' put: comment ].
	^ self
		withProperties: propertiesDictionary
		classMethodDefinitions: Dictionary new
		instanceMethodDefinitions: Dictionary new
%

!		Instance methods for 'RwClassDefinition'

category: 'accessing'
method: RwClassDefinition
classType
	"Legal types are normal, variable, and byteSubclass."

	^self propertyAt: 'type' ifAbsent: ['normal']
%

category: 'accessing'
method: RwClassDefinition
classVarNames
  ^ properties at: 'classvars'
%

category: 'accessing'
method: RwClassDefinition
classVarNames: anArrayOfClassVarNames

	^ properties at: 'classvars' put: anArrayOfClassVarNames
%

category: 'accessing'
method: RwClassDefinition
comment: aString
  properties at: 'comment' put: aString
%

category: 'accessing'
method: RwClassDefinition
instVarNames

	^ properties at: 'instvars'
%

category: 'accessing'
method: RwClassDefinition
instVarNames: arrayOfInstanceVariableNames

	^ properties at: 'instvars' put: arrayOfInstanceVariableNames
%

category: 'accessing'
method: RwClassDefinition
moveToPackageNamed: newPackageName packageConvention: thePackageConvention
	thePackageConvention = 'Rowan'
		ifTrue: [ ^ self ].
	thePackageConvention = 'Monticello'
		ifTrue: [ self error: 'not yet implemented' ].
	thePackageConvention ~= 'RowanHybrid'
		ifTrue: [ self error: 'unknown package convention' ].
	self category: newPackageName
%

category: 'accessing'
method: RwClassDefinition
shebang

	^ self propertyAt: 'shebang' ifAbsent: []
%

category: 'accessing'
method: RwClassDefinition
shebang: aStringOrNil

	aStringOrNil ifNil: [ ^ self properties removeKey: 'shebang' ifAbsent: [] ].
	^ self propertyAt: 'shebang' put: aStringOrNil
%

category: 'accessing'
method: RwClassDefinition
superclassName

	^self propertyAt: 'superclass' ifAbsent: [self propertyAt: 'super']
%

category: 'accessing'
method: RwClassDefinition
superclassName: aString

	^ self propertyAt: 'superclass' put: aString
%

category: 'utility'
method: RwClassDefinition
_removeSubclassesDisallowed
  "Only for use in building definitions for bootstap of the base image.
   image bootstrap code responsible for setting subclassesDisallowed on
   appropriate classes after they are all defined."
  | propertyName oldValue newValue |
  propertyName := 'gs_options'.
  oldValue := self propertyAt: propertyName ifAbsent:[ #() ].
  oldValue isEmpty ifFalse:[
     newValue := oldValue reject:[:x | x = 'subclassesDisallowed'].
     self propertyAt: propertyName put: newValue
  ]
%

! Class implementation for 'RwClassExtensionDefinition'

!		Class methods for 'RwClassExtensionDefinition'

category: 'instance creation'
classmethod: RwClassExtensionDefinition
newForClassNamed: className

	| propertiesDictionary |
	propertiesDictionary := Dictionary new
		at: 'name' put: className;
		yourself.
	^ self
		withProperties: propertiesDictionary
		classMethodDefinitions: Dictionary new
		instanceMethodDefinitions: Dictionary new
%

!		Instance methods for 'RwClassExtensionDefinition'

category: 'comparing'
method: RwClassExtensionDefinition
compareDictionary: myDictionary againstBaseDictionary: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys
		do: [ :key | 
			| before after modification |
			before := baseDictionary at: key ifAbsent: [ elementClass new ].
			after := myDictionary at: key ifAbsent: [ elementClass new ].
			modification := after compareExtensionMethodsAgainstBase: before.
			modification
				isMeta: isClassMeta;
				classDefinition: self.
			modification isEmpty
				ifFalse: [ anElementsModification addElementModification: modification ] ]
%

category: 'testing'
method: RwClassExtensionDefinition
isClassExtension
	^ true
%

category: 'accessing'
method: RwClassExtensionDefinition
moveToPackageNamed: newPackageName packageConvention: thePackageConvention
	thePackageConvention = 'Rowan'
		ifTrue: [ ^ self ].
	thePackageConvention = 'Monticello'
		ifTrue: [ self error: 'not yet implemented' ].
	thePackageConvention ~= 'RowanHybrid'
		ifTrue: [ self error: 'unknown package convention' ].
	self instanceMethodDefinitions
		valuesDo: [ :methodDef | methodDef protocol: '*' , newPackageName asLowercase ].
	self classMethodDefinitions
		valuesDo: [ :methodDef | methodDef protocol: '*' , newPackageName asLowercase ]
%

category: 'private'
method: RwClassExtensionDefinition
_classNameForCompare: aDefinition

	^ self key ifNil: 
		[ | cName |
		cName := aDefinition key.
		self name: cName.
		cName ]
%

! Class implementation for 'RwAbstractProjectDefinitionV2'

!		Instance methods for 'RwAbstractProjectDefinitionV2'

category: 'properties'
method: RwAbstractProjectDefinitionV2
comment

	^ comment
%

category: 'properties'
method: RwAbstractProjectDefinitionV2
comment: aString

	comment := aString
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
componentNamed: aComponentName

	^ self componentNamed: aComponentName ifAbsent: [ self error: 'The component named ', aComponentName printString, ' was not found' ]
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
componentNamed: aComponentName ifAbsent: absentBlock
	^ self components componentNamed: aComponentName ifAbsent: absentBlock
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
components
	^ components
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
components: aComponentDefinitionDictionary
	components := aComponentDefinitionDictionary
%

category: 'initialization'
method: RwAbstractProjectDefinitionV2
initialize
	super initialize.
	packages := Dictionary new.
	components := RwResolvedLoadComponentsV2 new
%

category: 'testing'
method: RwAbstractProjectDefinitionV2
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & packages isEmpty
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
packageNamed: aString

	^ self
		packageNamed: aString
		ifAbsent: [ self error: 'A package named ' , aString printString , ' was not found.' ]
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
packageNamed: aString ifAbsent: absentBlock

	^ self packages at: aString ifAbsent: absentBlock
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
packageNames
  ^ self packages keys asArray
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
packages

	^packages
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
packages: aPackageDefinitionDictionary

	packages := aPackageDefinitionDictionary
%

category: 'copying'
method: RwAbstractProjectDefinitionV2
postCopy

	| oldPackages |
	super postCopy.
	oldPackages := packages.
	packages := Dictionary new.
	oldPackages keysAndValuesDo: [:key : value | packages at: key put: value copy ] .
%

category: 'properties'
method: RwAbstractProjectDefinitionV2
projectDefinitionPlatformConditionalAttributes
	^ properties
		at: RwLoadedProject _projectDefinitionPlatformConditionalAttributesKey
		ifAbsent: [  ]
%

category: 'properties'
method: RwAbstractProjectDefinitionV2
projectDefinitionPlatformConditionalAttributes: platformConditionalAtttributesOrNil
	platformConditionalAtttributesOrNil
		ifNil: [ 
			^ properties
				removeKey:
					RwLoadedProject _projectDefinitionPlatformConditionalAttributesKey
				ifAbsent: [  ] ].
	^ properties
		at: RwLoadedProject _projectDefinitionPlatformConditionalAttributesKey
		put: platformConditionalAtttributesOrNil
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
removeComponentNamed: aComponentName
	^ self components removeComponentNamed: aComponentName
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
removePackage: aPackageDefinition
	| key |
	key := aPackageDefinition key.
	(packages includesKey: key)
		ifFalse: [ self error: 'Package not present.' ].
	^ packages removeKey: key
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
removePackageNamed: packageName
	^ self removePackage: (self packageNamed: packageName)
%

category: 'accessing'
method: RwAbstractProjectDefinitionV2
removeProjectNamed: aProjectName
	^ self components removeProjectNamed: aProjectName
%

category: 'properties'
method: RwAbstractProjectDefinitionV2
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ self repositoryRootPath asFileReference
%

category: 'private'
method: RwAbstractProjectDefinitionV2
_addPackage: aPackageDefinition
	^ self
		_addPackage: aPackageDefinition
		ifPresent: [ self error: 'Duplicate package' ]
%

category: 'private'
method: RwAbstractProjectDefinitionV2
_addPackage: aPackageDefinition ifPresent: presentBlock
	| key |
	key := aPackageDefinition key.
	(packages includesKey: key)
		ifTrue: [ ^ presentBlock value ].
	^ packages at: key put: aPackageDefinition
%

category: 'private'
method: RwAbstractProjectDefinitionV2
_projectDefinition
	^ self
%

! Class implementation for 'RwProjectDefinitionV2'

!		Instance methods for 'RwProjectDefinitionV2'

category: 'visiting'
method: RwProjectDefinitionV2
acceptVisitor: aVisitor

	^ aVisitor visitComponentProjectDefinition: self
%

category: 'accessing'
method: RwProjectDefinitionV2
addComponentNamed: componentName toComponentNamed: toComponentName
	^ self components
		addComponentNamed: componentName
		toComponentNamed: toComponentName
%

category: 'accessing'
method: RwProjectDefinitionV2
addComponentStructureFor: componentBasename pathNameArray: pathNameArray conditionPathArray: conditionPathArray comment: aString
	"assume that componentBasename is a top-level component"

	^ self
		addComponentStructureFor: componentBasename
		startingAtComponentNamed: componentBasename
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: aString
%

category: 'accessing'
method: RwProjectDefinitionV2
addComponentStructureFor: componentBasename startingAtComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray comment: aString
	"return the path name of the new component"

	| theComponentName toComponent path compositePath condition |
	toComponent := self componentNamed: toComponentName.
	condition := conditionPathArray last.
	path := RelativePath withAll: pathNameArray.
	1 to: pathNameArray size - 1 do: [ :pathIndex | 
		| segmentName intermediateComponentName |
		"ensure that we have the appropriate intermediate component structure"
		segmentName := pathNameArray at: pathIndex.
		compositePath := compositePath
			ifNil: [ Path * segmentName ]
			ifNotNil: [ compositePath / segmentName ].
		intermediateComponentName := (compositePath / componentBasename) pathString.
		toComponent := self components
			componentNamed: intermediateComponentName
			ifAbsent: [ 
				| newComponent |
				newComponent := self components
					addSimpleNestedComponentNamed: intermediateComponentName
					condition: (conditionPathArray at: pathIndex)
					comment: ''.
				toComponent addComponentNamed: intermediateComponentName.
				newComponent ] ].
	theComponentName := (path / componentBasename) pathString.
	condition _isArray
		ifTrue: [ 
self components componentNamed: theComponentName
ifAbsent: [
			self components
				addPlatformNestedComponentNamed: theComponentName
				condition: condition
				comment: aString ]]
		ifFalse: [
self components componentNamed: theComponentName
ifAbsent: [
			self components
				addSimpleNestedComponentNamed: theComponentName
				condition: condition
				comment: aString] ].
	toComponent addComponentNamed: theComponentName.
	^ theComponentName
%

category: 'accessing'
method: RwProjectDefinitionV2
addNewComponentNamed: aComponentName
	^ self addNewComponentNamed: aComponentName condition: 'common' comment: ''
%

category: 'accessing'
method: RwProjectDefinitionV2
addNewComponentNamed: aComponentName comment: aString
	^ self addNewComponentNamed: aComponentName condition: 'common' comment: aString
%

category: 'accessing'
method: RwProjectDefinitionV2
addNewComponentNamed: aComponentName condition: condition
	^ self components
		addSimpleComponentNamed: aComponentName
		condition: condition
%

category: 'accessing'
method: RwProjectDefinitionV2
addNewComponentNamed: aComponentName condition: condition comment: aString
	^ self components
		addSimpleComponentNamed: aComponentName
		condition: condition
		comment: aString
%

category: 'accessing'
method: RwProjectDefinitionV2
addNewComponentNamed: aComponentName toComponentNamed: toComponentName condition: conditionPathArray
	"return the path name of the new component"

	^ self
		addNewComponentNamed: aComponentName
		toComponentNamed: toComponentName
		pathNameArray: conditionPathArray
		conditionPathArray: conditionPathArray
%

category: 'accessing'
method: RwProjectDefinitionV2
addNewComponentNamed: aComponentName toComponentNamed: toComponentName condition: conditionPathArray comment: aString
	"return the path name of the new component"

	^ self
		addNewComponentNamed: aComponentName
		toComponentNamed: toComponentName
		pathNameArray: conditionPathArray
		conditionPathArray: conditionPathArray
		comment: aString
%

category: 'accessing'
method: RwProjectDefinitionV2
addNewComponentNamed: aComponentName toComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray
	"return the path name of the new component"

	^ self
		addNewComponentNamed: aComponentName
		toComponentNamed: toComponentName
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: ''
%

category: 'accessing'
method: RwProjectDefinitionV2
addNewComponentNamed: aComponentName toComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray comment: aString
	"return the path name of the new component"

	| theComponentName toComponent path compositePath |
	toComponent := self componentNamed: toComponentName.
	path := RelativePath withAll: pathNameArray.
	1 to: pathNameArray size - 1 do: [ :pathIndex | 
		| segmentName intermediateComponentName |
		"ensure that we have the appropriate intermediate component structure"
		segmentName := pathNameArray at: pathIndex.
		compositePath := compositePath
			ifNil: [ Path * segmentName ]
			ifNotNil: [ compositePath / segmentName ].
		intermediateComponentName := (compositePath / aComponentName) pathString.
		toComponent := self components
			componentNamed: intermediateComponentName
			ifAbsent: [ 
				| newComponent |
				newComponent := self components
					addSimpleNestedComponentNamed: intermediateComponentName
					condition: (conditionPathArray at: pathIndex)
					comment: ''.
				toComponent addComponentNamed: intermediateComponentName.
				newComponent ] ].
	theComponentName := (path / aComponentName) pathString.
	self components
		addSimpleNestedComponentNamed: theComponentName
		condition: conditionPathArray last
		comment: aString.
	toComponent addComponentNamed: theComponentName.
	^ theComponentName
%

category: 'accessing'
method: RwProjectDefinitionV2
addNewNestedComponentNamed: aComponentName comment: aString
	^ self components
		addSimpleNestedComponentNamed: aComponentName
		condition: 'common'
		comment: aString
%

category: 'accessing'
method: RwProjectDefinitionV2
addPackageNamed: packageName
	"the package is expected to already be present in a component - used when reading packages from disk"

	| package |
	(self components componentForPackageNamed: packageName)
		ifNil: [ 
			self
				error:
					'The package ' , packageName printString
						, ' must already be present in a component' ].
	package := RwPackageDefinition newNamed: packageName.
	self
		_addPackage: package
		ifPresent: [ 
			"no problem ... just update the component"
			 ].
	^ package
%

category: 'accessing'
method: RwProjectDefinitionV2
addPackageNamed: packageName toComponentNamed: componentName
	| package |
	self components
		componentNamed: componentName
		ifAbsent: [ self error: 'The component ' , componentName printString , ' is undefined' ].
	package := RwPackageDefinition newNamed: packageName.
	self
		_addPackage: package
		ifPresent: [ 
			"no problem ... just update the component"
			 ].
	self components addPackageNamed: packageName toComponentNamed: componentName.
	^ package
%

category: 'accessing'
method: RwProjectDefinitionV2
addPackageNamed: packageName toComponentNamed: componentName gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc
	| package |
	self components
		componentNamed: componentName
		ifAbsent: [ self error: 'The component ' , componentName printString , ' is undefined' ].
	package := RwPackageDefinition newNamed: packageName.
	self
		_addPackage: package
		ifPresent: [ 
			"no problem ... just update the component"
			 ].
	self components
		addPackageNamed: packageName
		toComponentNamed: componentName
		gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc.
	^ package
%

category: 'accessing'
method: RwProjectDefinitionV2
addPackages: somePackageNames forComponent: aComponent
	"not sure I like how this is used ... the component structure needs to be kept in sync with packages, so this is not quite the route to go, unless we ensure that the component has an entry for the package"

	"see similar comment in addRawPackageNamed: _addComponent"

	"should be sent from the component visitor ... not unexpected to have a duplicate, but the new
		component --- presumably freshly read from disk --- wins"

	self components _addComponent: aComponent.
	somePackageNames asSet
		do: [ :packageName | self _addPackage: (RwPackageDefinition newNamed: packageName) ]
%

category: 'accessing'
method: RwProjectDefinitionV2
addPackagesNamed: packageNames toComponentNamed: componentName
	^ packageNames
		collect: [ :packageName | self addPackageNamed: packageName toComponentNamed: componentName ]
%

category: 'accessing'
method: RwProjectDefinitionV2
addPlatformComponentNamed: aComponentName toComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray
	"return the path name of the new component"

	^ self
		addPlatformComponentNamed: aComponentName
		toComponentNamed: toComponentName
		pathNameArray: pathNameArray
		conditionPathArray: conditionPathArray
		comment: ''
%

category: 'accessing'
method: RwProjectDefinitionV2
addPlatformComponentNamed: aComponentName toComponentNamed: toComponentName pathNameArray: pathNameArray conditionPathArray: conditionPathArray comment: aString
	"return the path name of the new component"

	| theComponentName toComponent path compositePath condition |
	toComponent := self componentNamed: toComponentName.
	condition := conditionPathArray last.
	path := RelativePath withAll: pathNameArray.
	1 to: pathNameArray size - 1 do: [ :pathIndex | 
		| segmentName intermediateComponentName |
		"ensure that we have the appropriate intermediate component structure"
		segmentName := pathNameArray at: pathIndex.
		compositePath := compositePath
			ifNil: [ Path * segmentName ]
			ifNotNil: [ compositePath / segmentName ].
		intermediateComponentName := (compositePath / aComponentName) pathString.
		toComponent := self components
			componentNamed: intermediateComponentName
			ifAbsent: [ 
				| newComponent |
				newComponent := self components
					addSimpleNestedComponentNamed: intermediateComponentName
					condition: (conditionPathArray at: pathIndex)
					comment: ''.
				toComponent addComponentNamed: intermediateComponentName.
				newComponent ] ].
	theComponentName := (path / aComponentName) pathString.
	self components
		addPlatformNestedComponentNamed: theComponentName
		condition: condition
		comment: ''.
	toComponent addComponentNamed: theComponentName.
	^ theComponentName
%

category: 'accessing'
method: RwProjectDefinitionV2
addPlatformNestedComponentNamed: aComponentName condition: conditionArray comment: commentString
	^ self components
		addPlatformNestedComponentNamed: aComponentName
		condition: conditionArray
		comment: commentString
%

category: 'accessing'
method: RwProjectDefinitionV2
addProjectNamed: projectName toComponentNamed: toComponentName
	^ self components
		addProjectNamed: projectName
		toComponentNamed: toComponentName
%

category: 'accessing'
method: RwProjectDefinitionV2
addRawPackageNamed: packageName
	"not sure I like how this is used ... the component structure needs to be kept in sync with packages, so this is not quite the route to go, unless we ensure that the component has an entry for the package"

	"see similar comment in addPackages:forComponent: and _addComponent"

	^ self _addPackage: (RwPackageDefinition newNamed: packageName)
%

category: 'accessing'
method: RwProjectDefinitionV2
addSimpleComponentNamed: aComponentName condition: condition comment: commentString
	^ self components
		addSimpleComponentNamed: aComponentName
		condition: condition
		comment: commentString
%

category: 'accessing'
method: RwProjectDefinitionV2
addSimpleNestedComponentNamed: aComponentName condition: condition comment: commentString
	^ self components
		addSimpleNestedComponentNamed: aComponentName
		condition: condition
		comment: commentString
%

category: 'querying'
method: RwProjectDefinitionV2
componentForPackageNamed: packageName
	"Answer nil if no component found"

	^ self components componentForPackageNamed: packageName
%

category: 'actions'
method: RwProjectDefinitionV2
create
	"write the project structure to disk, if it doesn't already exist"

	Rowan projectTools create
		createComponentProject: self.
%

category: 'properties'
method: RwProjectDefinitionV2
key
	"Answer an object that can be used to uniquely identify myself in the context of my container."

	^self projectName
%

category: 'actions'
method: RwProjectDefinitionV2
load
	"load the receiver into the image"

	^ self _loadTool loadProjectDefinition: self
%

category: 'actions'
method: RwProjectDefinitionV2
load: instanceMigrator
	"load the receiver into the image"

	^ self _loadTool loadProjectDefinition: self instanceMigrator: instanceMigrator
%

category: 'accessing'
method: RwProjectDefinitionV2
movePackageNamed: aPackageName toComponentNamed: aComponentName
	self
		movePackageNamed: aPackageName
		toComponentNamed: aComponentName
		asPackageName: aPackageName
%

category: 'accessing'
method: RwProjectDefinitionV2
movePackageNamed: aPackageName toComponentNamed: aComponentName asPackageName: newPackageName
	self components removePackageNamed: aPackageName.
	self components
		addPackageNamed: newPackageName
		toComponentNamed: aComponentName
%

category: 'querying'
method: RwProjectDefinitionV2
packageForClassNamed: className
	"Answer nil if no class found"

	self packages
		do: [ :package | 
			(package classDefinitions includesKey: className)
				ifTrue: [ ^ package ] ].
	^ nil
%

category: 'properties'
method: RwProjectDefinitionV2
projectName
	^ self propertyAt: 'name' ifAbsent: [ nil ]
%

category: 'properties'
method: RwProjectDefinitionV2
projectName: aString
	self propertyAt: 'name' put: aString
%

category: 'accessing'
method: RwProjectDefinitionV2
removePackage: aPackageDefinition
	self components removePackageNamed: aPackageDefinition name.
	^ super removePackage: aPackageDefinition
%

category: 'accessing'
method: RwProjectDefinitionV2
removePackageNamed: packageName fromComponentNamed: componentName
	"do not remove package from defintion, remove it from the named component only. 
		Use removePackage:, if you want the package completely removed from definition"

	| component |
	component := self componentNamed: componentName.
	component removePackageNamed: packageName.
	^ component
%

category: 'accessing'
method: RwProjectDefinitionV2
renameComponentNamed: aComponentPath to: aComponentName
	^ self components renameComponentNamed: aComponentPath to: aComponentName
%

category: 'accessing'
method: RwProjectDefinitionV2
renamePackageNamed: packageName to: newPackageName
	| theComponent |
	theComponent := self componentForPackageNamed: packageName.
	self
		movePackageNamed: packageName
		toComponentNamed: theComponent name
		asPackageName: newPackageName
%

category: 'temporary compat'
method: RwProjectDefinitionV2
repositoryRootPath

	^ self repositoryRoot fullName
%

category: 'actions'
method: RwProjectDefinitionV2
_deleteTool

	^ Rowan projectTools delete
%

category: 'actions'
method: RwProjectDefinitionV2
_loadTool

	^ Rowan projectTools loadV2
%

category: 'private'
method: RwProjectDefinitionV2
_validate: platformConfigurationAttributes
	"ensure that the data structures within the receiver contain valid information"

	"make sure that list of packages is consistent between components and project definition
		It's okay to have a definition that is not managed by a component.
		It's NOT okay to have component package that is not defined."

	| definitionPackageNames componentPackageNames missingFromComponent errorMessage |
	definitionPackageNames := self packageNames asSet.
	componentPackageNames := self components _validate: platformConfigurationAttributes.
	missingFromComponent := componentPackageNames - definitionPackageNames.
	missingFromComponent isEmpty
		ifTrue: [ ^ true ].
	errorMessage := WriteStream on: String new.
	errorMessage
		nextPutAll: 'Component references package(s) that are not defined';
		lf.
	errorMessage
		tab;
		nextPutAll:
				'The following packages are defined, but not referenced in a component:';
		lf.
	missingFromComponent
		do: [ :packageName | 
			errorMessage
				tab;
				tab;
				nextPutAll: packageName;
				lf ].
	self error: errorMessage contents
%

! Class implementation for 'RwAbstractRepositoryDefinitionV2'

!		Class methods for 'RwAbstractRepositoryDefinitionV2'

category: 'instance creation'
classmethod: RwAbstractRepositoryDefinitionV2
newNamed: repositoryName projectsHome: aFileReference repositoryUrl: aRepositoryUrlString
	^ self new
		name: repositoryName;
		projectsHome: aFileReference;
		repositoryUrl: aRepositoryUrlString;
		yourself
%

!		Instance methods for 'RwAbstractRepositoryDefinitionV2'

category: 'comparing'
method: RwAbstractRepositoryDefinitionV2
= anObject
	^ self projectsHome = anObject projectsHome
		and: [ 
			self repositoryRoot = anObject repositoryRoot
				and: [ self repositoryUrl = anObject repositoryUrl ] ]
%

category: 'actions'
method: RwAbstractRepositoryDefinitionV2
checkAndUpdateRepositoryRevision: aRwProjectLoadSpecificationV2
	"noop"
%

category: 'actions'
method: RwAbstractRepositoryDefinitionV2
diskRepositoryRoot: repositoryRootPathString
	^ RwDiskRepositoryDefinitionV2
		newNamed: self name
		projectsHome: self projectsHome
		repositoryUrl: 'file:' , repositoryRootPathString
%

category: 'actions'
method: RwAbstractRepositoryDefinitionV2
gitRepositoryRoot: repositoryRootPathString revision: aString
	| urlString |
	urlString := 'file:' , repositoryRootPathString.
	^ RwGitRepositoryDefinitionV2
		newNamed: self name
		projectsHome: self projectsHome
		repositoryUrl: urlString
		revision: aString
%

category: 'comparing'
method: RwAbstractRepositoryDefinitionV2
hash
	| hashValue |
	hashValue := self projectsHome hash.
	hashValue := hashValue bitXor: self repositoryRoot hash.
	hashValue := hashValue bitXor: self repositoryUrl hash.
	^ hashValue
%

category: 'accessing'
method: RwAbstractRepositoryDefinitionV2
key

	^properties at: 'name' ifAbsent: [nil]
%

category: 'accessing'
method: RwAbstractRepositoryDefinitionV2
name

	^ self key
%

category: 'accessing'
method: RwAbstractRepositoryDefinitionV2
name: aString 

	properties at: 'name' put: aString
%

category: 'accessing'
method: RwAbstractRepositoryDefinitionV2
projectsHome
	^ projectsHome
%

category: 'accessing'
method: RwAbstractRepositoryDefinitionV2
projectsHome: aFileReference
	projectsHome := aFileReference
%

category: 'actions'
method: RwAbstractRepositoryDefinitionV2
readOnlyRepositoryRoot: repositoryRootPathString commitId: commitId
	| urlString repo |
	urlString := 'file:' , repositoryRootPathString.
	repo := RwReadOnlyDiskRepositoryDefinitionV2
		newNamed: self name
		projectsHome: self projectsHome
		repositoryUrl: urlString.
	repo commitId: commitId.
	^ repo
%

category: 'accessing'
method: RwAbstractRepositoryDefinitionV2
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ repositoryRoot
		ifNil: [ 
			repositoryUrl
				ifNotNil: [ :urlString | 
					| url |
					url := urlString asRwUrl.
					url scheme = 'file'
						ifTrue: [ ^ repositoryRoot := url pathString ] ].
			repositoryRoot := self projectsHome / self name ]
%

category: 'accessing'
method: RwAbstractRepositoryDefinitionV2
repositoryRoot: pathStringOrReference
	repositoryRoot := pathStringOrReference
%

category: 'accessing'
method: RwAbstractRepositoryDefinitionV2
repositoryUrl
	^ repositoryUrl
%

category: 'accessing'
method: RwAbstractRepositoryDefinitionV2
repositoryUrl: anUrlString
	repositoryUrl := anUrlString
%

category: 'actions'
method: RwAbstractRepositoryDefinitionV2
resolve
	self subclassResponsibility: #'resolve'
%

category: 'accessing'
method: RwAbstractRepositoryDefinitionV2
revision

	^ ''
%

category: 'testing'
method: RwAbstractRepositoryDefinitionV2
useGit
	^ false
%

! Class implementation for 'RwDiskRepositoryDefinitionV2'

!		Class methods for 'RwDiskRepositoryDefinitionV2'

category: 'instance creation'
classmethod: RwDiskRepositoryDefinitionV2
newNamed: repositoryName projectsHome: aFileReference repositoryUrl: aRepositoryUrlString
	^ self new
		name: repositoryName;
		projectsHome: aFileReference;
		repositoryUrl: aRepositoryUrlString;
		yourself
%

!		Instance methods for 'RwDiskRepositoryDefinitionV2'

category: 'testing'
method: RwDiskRepositoryDefinitionV2
canCommit

	^ false
%

category: 'actions'
method: RwDiskRepositoryDefinitionV2
checkAndUpdateRepositoryRevision: aRwProjectLoadSpecificationV2
	"noop"
%

category: 'actions'
method: RwDiskRepositoryDefinitionV2
clone

	"attach to existing cloned disk structure or clone project from remote repository"

	"who wins? resolve or clone"

	self subclassResponsibility: #clone
%

category: 'accessing'
method: RwDiskRepositoryDefinitionV2
commitId
	^ ''
%

category: 'accessing'
method: RwDiskRepositoryDefinitionV2
commitLog: logLimit

	^ ''
%

category: 'actions'
method: RwDiskRepositoryDefinitionV2
create

	self error: 'not yet implemented'
%

category: 'actions'
method: RwDiskRepositoryDefinitionV2
diskRepositoryRoot: repositoryRootPathString
	self
		repositoryUrl: 'file:' , repositoryRootPathString;
		repositoryRoot: repositoryRootPathString
%

category: 'actions'
method: RwDiskRepositoryDefinitionV2
doCommit: message

	"noop by default"
%

category: 'testing'
method: RwDiskRepositoryDefinitionV2
repositoryExists

	^ self repositoryRoot exists
%

category: 'accessing'
method: RwDiskRepositoryDefinitionV2
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ repositoryRoot
		ifNil: [ 
			repositoryUrl
				ifNotNil: [ :urlString | 
					| url |
					url := urlString asRwUrl.
					url scheme = 'file'
						ifTrue: [ ^ repositoryRoot := url pathString asFileReference ] ].
			repositoryRoot := self projectsHome / self name ]
%

category: 'accessing'
method: RwDiskRepositoryDefinitionV2
repositoryRoot: pathStringOrReference
	repositoryRoot := pathStringOrReference asFileReference
%

category: 'actions'
method: RwDiskRepositoryDefinitionV2
resolve
	"attach to existing repository structure"

	"answer true if attaching to an existing repository"

	self repositoryRoot exists
		ifFalse: [ self repositoryRoot ensureCreateDirectory ].
	^ true
%

! Class implementation for 'RwGitRepositoryDefinitionV2'

!		Class methods for 'RwGitRepositoryDefinitionV2'

category: 'instance creation'
classmethod: RwGitRepositoryDefinitionV2
newNamed: repositoryName projectsHome: aFileReference repositoryUrl: aRepositoryUrlString revision: revision
	^ self new
		name: repositoryName;
		projectsHome: aFileReference;
		repositoryUrl: aRepositoryUrlString;
		committish: revision;
		yourself
%

!		Instance methods for 'RwGitRepositoryDefinitionV2'

category: 'comparing'
method: RwGitRepositoryDefinitionV2
= anObject
	"remote remoteUrl committish"

	^ super = anObject
		and: [ 
			self remote = anObject remote
				and: [ 
					self remoteUrl = anObject remoteUrl
						and: [ self committish = anObject committish ] ] ]
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
branches
	"return an array of branch names for the receiver"

	| str line branches remotesPrefix |
	self fetch.
	str := ReadStream
		on: (Rowan gitTools gitbranchIn: self repositoryRoot pathString with: '--all').
	branches := {}.
	remotesPrefix := 'remotes/origin/'.
	[ str atEnd ]
		whileFalse: [ 
			line := str nextLine trimBlanks.
			(line at: 1) = $*
				ifTrue: [ 
					"ignore current branch"
					 ]
				ifFalse: [ 
					| index |
					index := line findString: remotesPrefix startingAt: 1.
					index > 0
						ifTrue: [ line := (line copyFrom: index + remotesPrefix size to: line size) trimBlanks ].
					(line findString: 'HEAD' startingAt: 1) = 0
						ifTrue: [ branches add: line ] ] ].
	^ branches
%

category: 'testing'
method: RwGitRepositoryDefinitionV2
canCommit

	^ true
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
checkAndUpdateRepositoryRevision: aRwProjectLoadSpecificationV2
	| revision |
	revision := aRwProjectLoadSpecificationV2 revision.
	self currentBranch = revision
		ifTrue: [ ^ self ].
	(aRwProjectLoadSpecificationV2 isStrict
		or: [ 
			RwAllowChangeRepositoryRevisionOnResolveNotification
				signal: aRwProjectLoadSpecificationV2 ])
		ifTrue: [ 
			self fetch.
			self checkout: revision ]
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
checkout: aCommittish
	Rowan gitTools gitcheckoutIn: self repositoryRoot with: aCommittish
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
clone

	"attach to existing cloned disk structure or clone project from remote repository"

	"who wins? resolve or clone"

	Rowan projectTools clone
		cloneRepository: self
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
commitId
	^ [ 
	| gitHome gitTools |
	gitTools := Rowan gitTools.
	gitHome := (gitTools gitrevparseShowTopLevelIn: self repositoryRoot pathString)
		trimBoth.
	gitTools gitcommitShaIn: gitHome ]
		on: Error
		do: [ :ignored | 
			"most likely no commits yet"
			'' ]
%

category: 'loading'
method: RwGitRepositoryDefinitionV2
commitLog: logLimit

	^ Rowan gitTools gitlogtool: 'HEAD' limit: logLimit gitRepoDirectory: self repositoryRoot pathString
%

category: 'accessing'
method: RwGitRepositoryDefinitionV2
committish
	^ committish ifNil: [ '' ]
%

category: 'accessing'
method: RwGitRepositoryDefinitionV2
committish: aString

	committish := aString
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
createBranch: branchName
	Rowan gitTools gitcheckoutIn: self repositoryRoot with: '-b ' , branchName
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
currentBranch
	| result |
	result := Rowan gitTools gitBranchNameIn: self repositoryRoot pathString.
	(result findString: '(HEAD' startingAt: 1) > 0
		ifTrue: [ 
			"if detached head, return the sha of the commit"
			^ Rowan gitTools gitcommitShaIn: self repositoryRoot pathString ].
	^ result
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
doCommit: message
	| gitTool gitRootPath commitMessageFileName status |
	gitTool := Rowan gitTools.
	gitRootPath := self repositoryRoot pathString.
	(gitTool gitstatusIn: gitRootPath with: '--short') isEmpty
		ifTrue: [ 
			| msg |
			msg := 'Nothing to commit'.
			Transcript
				cr;
				show: '==============';
				cr;
				show: msg.
			self inform: msg.
			^ msg ].
	commitMessageFileName := gitTool createTmpFileWith: message.
	gitTool gitaddIn: gitRootPath with: '-A .'.
	gitTool gitcommitIn: gitRootPath with: '--file=' , commitMessageFileName.
	status := gitTool gitlogIn: gitRootPath with: '-1'.
	Transcript
		cr;
		show: '==============';
		cr;
		show: status.
	^ status
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
fetch
	Rowan gitTools gitfetchIn: self repositoryRoot with: self remote
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
gitRepositoryRoot: repositoryRootPathString revision: aString
	self
		repositoryUrl: 'file:' , repositoryRootPathString;
		repositoryRoot: repositoryRootPathString;
		committish: aString
%

category: 'comparing'
method: RwGitRepositoryDefinitionV2
hash
	| hashValue |
	hashValue := super hash.
	hashValue := hashValue bitXor: self remote hash.
	hashValue := hashValue bitXor: self remoteUrl hash.
	hashValue := hashValue bitXor: self committish hash.
	^ hashValue
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
pull: remoteName branch: branchName
	Rowan gitTools
		gitpullIn: self repositoryRoot pathString
		remote: remoteName
		branch: branchName
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
push: remoteName branch: branchName
	Rowan gitTools
		gitpushIn: self repositoryRoot pathString
		remote: remoteName
		branch: branchName
%

category: 'accessing'
method: RwGitRepositoryDefinitionV2
remote
	^ remote ifNil: [ 'origin' ]
%

category: 'accessing'
method: RwGitRepositoryDefinitionV2
remote: remoteName
	remote := remoteName
%

category: 'accessing'
method: RwGitRepositoryDefinitionV2
remoteUrl
	^ remoteUrl ifNil: [ remoteUrl := self repositoryUrl ]
%

category: 'accessing'
method: RwGitRepositoryDefinitionV2
remoteUrl: aRemoteUrlString

	^ remoteUrl := aRemoteUrlString
%

category: 'accessing'
method: RwGitRepositoryDefinitionV2
repositoryUrl: aRepositoryUrlStrng
	super repositoryUrl: aRepositoryUrlStrng.
	self remoteUrl: aRepositoryUrlStrng
%

category: 'actions'
method: RwGitRepositoryDefinitionV2
resolve
	"attach to existing repository structure or clone"

	"answer true if attaching to an existing repository"

	| url |
	url := self repositoryUrl.
	^ (url isEmpty or: [ url asRwUrl scheme = 'file' ])
		ifTrue: [ 
			| gitTool "Creatr a new git repository in repository root" |
			gitTool := Rowan projectTools git.
			self repositoryRoot ensureCreateDirectory.
			(gitTool gitPresentIn: self repositoryRoot pathString)
				ifTrue: [ true ]
				ifFalse: [ 
					"create a git repository"
					gitTool gitinitIn: self repositoryRoot pathString with: ''.
					false ] ]
		ifFalse: [ 
			"clone from remote"
			self clone.
			true ]
%

category: 'accessing'
method: RwGitRepositoryDefinitionV2
revision
	^ [ Rowan gitTools gitcommitShaIn: self repositoryRoot pathString ]
		on: Error
		do: [ :ignored | 
			"most likely no commits yet"
			'' ]
%

category: 'testing'
method: RwGitRepositoryDefinitionV2
useGit
	^ true
%

! Class implementation for 'RwNoRepositoryDefinitionV2'

!		Instance methods for 'RwNoRepositoryDefinitionV2'

category: 'testing'
method: RwNoRepositoryDefinitionV2
repositoryExists
	^ false
%

category: 'accessing'
method: RwNoRepositoryDefinitionV2
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ nil
%

category: 'actions'
method: RwNoRepositoryDefinitionV2
resolve
	"nothing on disk"

	^ false
%

! Class implementation for 'RwReadOnlyDiskRepositoryDefinitionV2'

!		Instance methods for 'RwReadOnlyDiskRepositoryDefinitionV2'

category: 'accessing'
method: RwReadOnlyDiskRepositoryDefinitionV2
commitId
	^ commitId ifNil: [ '' ]
%

category: 'accessing'
method: RwReadOnlyDiskRepositoryDefinitionV2
commitId: aString
	commitId := aString
%

category: 'actions'
method: RwReadOnlyDiskRepositoryDefinitionV2
readOnlyRepositoryRoot: repositoryRootPathString commitId: aString
	self
		repositoryUrl: 'file:' , repositoryRootPathString;
		commitId: aString
%

category: 'accessing'
method: RwReadOnlyDiskRepositoryDefinitionV2
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ repositoryRoot
		ifNil: [ 
			repositoryUrl
				ifNil: [ self error: 'For a readonly repository, the repositoryUrl must be defined' ]
				ifNotNil: [ :urlString | 
					^ (SessionTemps current
						at: self _sessionTempsKey
						ifAbsentPut: [ 
							| url |
							url := urlString asRwUrl.
							url scheme = 'file'
								ifFalse:
									[ self error: 'For a readonly repository, the reposityUrl must be a file: url' ].
										url pathString ]) asFileReference ] ]
%

category: 'accessing'
method: RwReadOnlyDiskRepositoryDefinitionV2
repositoryRoot: pathStringOrReference
	SessionTemps current removeKey: self _sessionTempsKey ifAbsent: [  ].
%

category: 'accessing'
method: RwReadOnlyDiskRepositoryDefinitionV2
repositoryUrl: urlString
	SessionTemps current removeKey: self _sessionTempsKey ifAbsent: [  ].
	super repositoryUrl: urlString
%

category: 'private'
method: RwReadOnlyDiskRepositoryDefinitionV2
_sessionTempsKey
	^ sesstionTempsKey
		ifNil: [ sesstionTempsKey := ('rwReadOnlyRepositoryKey_' , self asOop printString) asSymbol ]
%

! Class implementation for 'RwDefinitionSetDefinition'

!		Instance methods for 'RwDefinitionSetDefinition'

category: 'accessing'
method: RwDefinitionSetDefinition
addDefinition: aDefinition

	| key |
	key := aDefinition key.
	(definitions includesKey: key)
		ifTrue: [ self error: 'Duplicate definition ' ].
	definitions at: key put: aDefinition
%

category: 'accessing'
method: RwDefinitionSetDefinition
definitionNames

	^ self definitions keys asArray
%

category: 'accessing'
method: RwDefinitionSetDefinition
definitions

	^ definitions
%

category: 'accessing'
method: RwDefinitionSetDefinition
definitionWithKey: aKey ifAbsent: absentBlock

	^ definitions at: aKey ifAbsent: absentBlock
%

category: 'deriving'
method: RwDefinitionSetDefinition
deriveLoadedThings

	self subclassResponsibility: #'deriveLoadedThings'
%

category: 'enumerating'
method: RwDefinitionSetDefinition
do: aBlock

	^ self definitions do: aBlock
%

category: 'initialization'
method: RwDefinitionSetDefinition
initialize

	super initialize.
	definitions := Dictionary new
%

category: 'testing'
method: RwDefinitionSetDefinition
isEmpty

	"Answer true if this definition does not actually define anything."

	^ super isEmpty & definitions isEmpty
%

category: 'properties'
method: RwDefinitionSetDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container.
	But PackageSets have no container, so we don't expect them to have a key."

	^nil
%

category: 'accessing'
method: RwDefinitionSetDefinition
keys

	^ definitions keys
%

category: 'copying'
method: RwDefinitionSetDefinition
postCopy

	super postCopy.
	definitions := definitions copy
%

category: 'printing'
method: RwDefinitionSetDefinition
printOn: aStream

	aStream nextPutAll: self asString
%

category: 'accessing'
method: RwDefinitionSetDefinition
size

	^ definitions size
%

! Class implementation for 'RwPackageSetDefinition'

!		Instance methods for 'RwPackageSetDefinition'

category: 'accessing'
method: RwPackageSetDefinition
addPackage: aDefinition

	self addDefinition: aDefinition
%

category: 'deriving'
method: RwPackageSetDefinition
deriveLoadedThings

	^ RwEntitySet
		withAll:
			((self definitionNames
				collect: [ :packageName | Rowan image loadedPackageNamed: packageName ifAbsent: [  ] ])
				select: [ :each | each notNil ])
%

category: 'accessing'
method: RwPackageSetDefinition
packageNames

	^ self definitionNames
%

category: 'accessing'
method: RwPackageSetDefinition
packages

	^ self definitions
%

! Class implementation for 'RwProjectSetDefinition'

!		Instance methods for 'RwProjectSetDefinition'

category: 'accessing'
method: RwProjectSetDefinition
addProject: aDefinition

	self addDefinition: aDefinition
%

category: 'deriving'
method: RwProjectSetDefinition
deriveLoadedThings

	"extract the loaded projects that correspond to the project defintions held by the receiver"

	^ RwEntitySet
		withAll:
			((self definitionNames
				collect: [ :projectName | Rowan image loadedProjectNamed: projectName ifAbsent: [  ] ])
				select: [ :each | each notNil ])
%

category: 'actions'
method: RwProjectSetDefinition
load

	^ Rowan projectTools load loadProjectSetDefinition: self
%

category: 'accessing'
method: RwProjectSetDefinition
projectNamed: projectName

	^ self 
		projectNamed: projectName
		ifAbsent: [ self error: 'No project named ', projectName printString , ' found.']
%

category: 'accessing'
method: RwProjectSetDefinition
projectNamed: projectName ifAbsent: absentBlock

	^ self definitionWithKey: projectName ifAbsent: absentBlock
%

category: 'accessing'
method: RwProjectSetDefinition
projectNames

	^ self definitionNames
%

category: 'accessing'
method: RwProjectSetDefinition
projects

	^ self definitions
%

! Class implementation for 'RwMethodDefinition'

!		Class methods for 'RwMethodDefinition'

category: 'instance creation'
classmethod: RwMethodDefinition
newForSelector: selector protocol: protocol source: source

	^ self
		withProperties:
			(Dictionary with: 'selector' -> selector with: 'protocol' -> protocol asString)
		source: source
%

category: 'instance creation'
classmethod: RwMethodDefinition
newForSource: methodSource protocol: protocol

	| selector |
	selector := Rowan platform parseSelectorFrom: methodSource.
	^ self
		newForSelector: selector asSymbol
		protocol: protocol
		source: methodSource
%

category: 'instance creation'
classmethod: RwMethodDefinition
withProperties: propertiesDictionary source: sourceString 

	^(self basicNew)
		properties: propertiesDictionary;
		source: sourceString;
		yourself
%

!		Instance methods for 'RwMethodDefinition'

category: 'testing'
method: RwMethodDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & source isNil
%

category: 'private'
method: RwMethodDefinition
key

	^properties at: 'selector' ifAbsent: [nil]
%

category: 'accessing'
method: RwMethodDefinition
offset: anInteger inFile: aFileName
  "these properties are used when handling a CompileError or
   a tonel parse error."
  properties at:'_gsFileOffset' put: anInteger .
  properties at:'_gsFileName' put: aFileName .
%

category: 'accessing'
method: RwMethodDefinition
protocol

	^properties at: 'protocol'
%

category: 'accessing'
method: RwMethodDefinition
protocol: aString

	properties at: 'protocol' put: aString
%

category: 'accessing'
method: RwMethodDefinition
selector

	^properties at: 'selector'
%

category: 'accessing'
method: RwMethodDefinition
source

	^source
%

category: 'accessing'
method: RwMethodDefinition
source: sourceString

	source := sourceString
%

category: 'private'
method: RwMethodDefinition
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue

	({'_gsFileOffset'. '_gsFileName' } includes: propertyKey)
		ifTrue: [ 
		"_gsFileOffset' '_gsFileName' are informational properties so any differences can be ignored "
		^ true ].
	^ super _compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue
%

! Class implementation for 'RwPackageDefinition'

!		Class methods for 'RwPackageDefinition'

category: 'instance creation'
classmethod: RwPackageDefinition
newNamed: packageName

	^ self
		withProperties: (Dictionary with: 'name' -> packageName)
		classDefinitions: Dictionary new
		classExtensions: Dictionary new
%

category: 'instance creation'
classmethod: RwPackageDefinition
withProperties: properties classDefinitions: classDefinitions classExtensions: classExtensionDefinitions

	^(self basicNew)
		properties: properties;
		classDefinitions: classDefinitions;
		classExtensions: classExtensionDefinitions;
		yourself
%

!		Instance methods for 'RwPackageDefinition'

category: 'accessing'
method: RwPackageDefinition
addClassDefinition: aClassDefinition

	^ self addDefinition: aClassDefinition to: classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
addClassExtensionDefinition: aClassExtensionDefinition

	^ self addDefinition: aClassExtensionDefinition to: classExtensions
%

category: 'accessing'
method: RwPackageDefinition
addClassExtensionNamed: className

	^ self addClassExtensionDefinition: (RwClassExtensionDefinition newForClassNamed: className)
%

category: 'accessing'
method: RwPackageDefinition
addClassNamed: className super: superclassName category: categryName

	^ self addClassDefinition: (RwClassDefinition newForClassNamed: className super: superclassName  category: categryName)
%

category: 'accessing'
method: RwPackageDefinition
addClassNamed: className super: superclassName category: categryName comment: comment

	^ self addClassDefinition: (RwClassDefinition newForClassNamed: className super: superclassName  category: categryName comment: comment)
%

category: 'accessing'
method: RwPackageDefinition
addClassNamed: className super: superclassName instvars: instvars
	^ self
		addClassDefinition:
			(RwClassDefinition
				newForClassNamed: className
				super: superclassName
				instvars: instvars)
%

category: 'accessing'
method: RwPackageDefinition
addClassNamed: className super: superclassName instvars: instvars category: category comment: comment
	^ self
		addClassDefinition:
			(RwClassDefinition
				newForClassNamed: className
				super: superclassName
				instvars: instvars
				classinstvars: #()
				classvars: #()
				category: category
				comment: comment
				pools: #()
				type: 'normal')
%

category: 'accessing'
method: RwPackageDefinition
addClassNamed: className super: superclassName instvars: instvars classinstvars: classinstvars classvars: classvars category: category comment: comment
	^ self
		addClassDefinition:
			(RwClassDefinition
				newForClassNamed: className
				super: superclassName
				instvars: instvars
				classinstvars: classinstvars
				classvars: classvars
				category: category
				comment: comment
				pools: #()
				type: 'normal')
%

category: 'accessing'
method: RwPackageDefinition
addClassNamed: className super: superclassName instvars: instvars classinstvars: classinstvars classvars: classvars category: category comment: comment pools: pools
	^ self
		addClassDefinition:
			(RwClassDefinition
				newForClassNamed: className
				super: superclassName
				instvars: instvars
				classinstvars: classinstvars
				classvars: classvars
				category: category
				comment: comment
				pools: pools
				type: 'normal')
%

category: 'accessing'
method: RwPackageDefinition
addClassNamed: className super: superclassName instvars: instvars classinstvars: classinstvars classvars: classvars category: category comment: comment pools: pools type: type
	^ self
		addClassDefinition:
			(RwClassDefinition
				newForClassNamed: className
				super: superclassName
				instvars: instvars
				classinstvars: classinstvars
				classvars: classvars
				category: category
				comment: comment
				pools: pools
				type: type)
%

category: 'accessing'
method: RwPackageDefinition
classDefinitionNamed: className

	^ self classDefinitionNamed: className ifAbsent: [ self error: 'No class definition found with the name ', className printString ]
%

category: 'accessing'
method: RwPackageDefinition
classDefinitionNamed: className ifAbsent: absentBlock

	^ self classDefinitions at: className ifAbsent: absentBlock
%

category: 'accessing'
method: RwPackageDefinition
classDefinitions

	^classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
classDefinitions: classDefinitionDictionary

	classDefinitions := classDefinitionDictionary
%

category: 'accessing'
method: RwPackageDefinition
classExtensionDefinitionNamed: className

	^ self classExtensionDefinitionNamed: className ifAbsent: [ self error: 'No class extension definition found with the name ', className printString ]
%

category: 'accessing'
method: RwPackageDefinition
classExtensionDefinitionNamed: className ifAbsent: absentBlock

	^ self classExtensions at: className ifAbsent: absentBlock
%

category: 'accessing'
method: RwPackageDefinition
classExtensions

	^classExtensions
%

category: 'accessing'
method: RwPackageDefinition
classExtensions: classExtensionDefinitionsDictionary

	classExtensions := classExtensionDefinitionsDictionary
%

category: 'initialization'
method: RwPackageDefinition
initialize

	super initialize.
	classDefinitions := Dictionary new.
	classExtensions := Dictionary new
%

category: 'testing'
method: RwPackageDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & classDefinitions isEmpty & classExtensions isEmpty
%

category: 'properties'
method: RwPackageDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container."

	^self propertyAt: 'name' ifAbsent: [nil]
%

category: 'accessing'
method: RwPackageDefinition
moveClassNamed: className modifyClassDefinition: classDefinitionBlock toPackage: packageDefinition
	| classDefinition |
	classDefinition := self removeKey: className from: classDefinitions.
	classDefinitionBlock cull: classDefinition.
	packageDefinition addClassDefinition: classDefinition
%

category: 'accessing'
method: RwPackageDefinition
moveClassNamed: className toPackage: packageDefinition
	self
		moveClassNamed: className
		modifyClassDefinition: [  ]
		toPackage: packageDefinition
%

category: 'copying'
method: RwPackageDefinition
postCopy

	| oldDefs |
	super postCopy.
	oldDefs := classDefinitions.
	classDefinitions := Dictionary new.
	oldDefs keysAndValuesDo: [:key :value | classDefinitions at: key put: value copy ].
	oldDefs := classExtensions.
	classExtensions := Dictionary new.
	oldDefs keysAndValuesDo: [:key :value | classExtensions at: key put: value copy ].
%

category: 'accessing'
method: RwPackageDefinition
removeClassDefinition: aClassDefinition

	self removeDefinition: aClassDefinition from: classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
removeClassExtensionDefinition: aClassExtension

	self removeDefinition: aClassExtension from: classExtensions
%

category: 'accessing'
method: RwPackageDefinition
removeClassExtensionDefinitionNamed: className

	self removeKey: className from: classExtensions
%

category: 'accessing'
method: RwPackageDefinition
removeClassNamed: className
	^ self removeKey: className from: classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
removeClassNamed: className ifAbsent: absentBlock

	self removeKey: className from: classDefinitions ifAbsent: absentBlock
%

category: 'accessing'
method: RwPackageDefinition
renameTo: newPackageName packageConvention: thePackageConvention
	self propertyAt: 'name' put: newPackageName.
	thePackageConvention = 'Rowan'
		ifTrue: [ ^ self ].
	thePackageConvention = 'Monticello'
		ifTrue: [ self error: 'not yet implemented' ].
	thePackageConvention ~= 'RowanHybrid'
		ifTrue: [ self error: 'unknown package convention' ].
	self classDefinitions
		valuesDo: [ :classDef | 
			classDef
				moveToPackageNamed: newPackageName
				packageConvention: thePackageConvention ].
	self classExtensions
		valuesDo: [ :classDef | 
			classDef
				moveToPackageNamed: newPackageName
				packageConvention: thePackageConvention ]
%

category: 'accessing'
method: RwPackageDefinition
updateClassDefinition: aClassDefinition

	self updateDefinition: aClassDefinition in: classDefinitions
%

! Class implementation for 'RwElementsModification'

!		Class methods for 'RwElementsModification'

category: 'instance creation'
classmethod: RwElementsModification
new

	^self basicNew initialize
%

!		Instance methods for 'RwElementsModification'

category: 'modifications'
method: RwElementsModification
addElementModification: aModification

	aModification isEmpty
		ifFalse: [elementsModified at: aModification key put: aModification]
%

category: 'Accessing'
method: RwElementsModification
elementsModified
	^elementsModified
%

category: 'initialization'
method: RwElementsModification
initialize

	elementsModified := Dictionary new
%

category: 'testing'
method: RwElementsModification
isEmpty

	^elementsModified isEmpty
%

category: 'Accessing'
method: RwElementsModification
modificationOf: aKey

	^elementsModified at: aKey
%

category: 'printing'
method: RwElementsModification
printOn: aStream

	super printOn: aStream.
	self isEmpty ifTrue: [aStream nextPutAll: ' (empty)']
%

category: 'Accessing'
method: RwElementsModification
removeModificationOf: aKey

	elementsModified removeKey: aKey
%

! Class implementation for 'RwClassesModification'

!		Instance methods for 'RwClassesModification'

category: 'visiting'
method: RwClassesModification
acceptVisitor: aVisitor

	^aVisitor visitClassesModification: self
%

! Class implementation for 'RwClassExtensionsModification'

!		Instance methods for 'RwClassExtensionsModification'

category: 'visiting'
method: RwClassExtensionsModification
acceptVisitor: aVisitor

	^aVisitor visitClassExtensionsModification: self
%

! Class implementation for 'RwEntitySetModification'

!		Instance methods for 'RwEntitySetModification'

category: 'accessing'
method: RwEntitySetModification
movedClasses

	^ movedClasses
%

category: 'accessing'
method: RwEntitySetModification
movedMethods

	^ movedMethods
%

category: 'accessing'
method: RwEntitySetModification
movedPackages

	^ movedPackages
%

! Class implementation for 'RwPackageSetModification'

!		Instance methods for 'RwPackageSetModification'

category: 'visiting'
method: RwPackageSetModification
acceptVisitor: aVisitor

	^aVisitor visitPackageSetModification: self
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsAddedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> true -> newMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> false -> newMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsAddedByPackageModification: packageModification toDictionary: dictionary

	self
		addMethodsAddedByClassesOrExtensionsModification: packageModification
				classesModification
		inPackage: packageModification after
		toDictionary: dictionary.
	self
		addMethodsAddedByClassesOrExtensionsModification: packageModification
				classExtensionsModification
		inPackage: packageModification after
		toDictionary: dictionary
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsRemovedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> true -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification before
										methodKey: oldMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> false -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: oldMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsRemovedByPackageModification: packageModification toDictionary: dictionary

	self
		addMethodsRemovedByClassesOrExtensionsModification: packageModification
				classesModification
		inPackage: packageModification before
		toDictionary: dictionary.
	self
		addMethodsRemovedByClassesOrExtensionsModification: packageModification
				classExtensionsModification
		inPackage: packageModification before
		toDictionary: dictionary
%

category: 'enumerating'
method: RwPackageSetModification
classesModificationAndPackageModificationAndProjectModificationDo: aBlock

	"enumerate the classesModification in the packagesModification in the projectModification in the receiver.
		The classesModification, packageModification are arguments to the block. "

	elementsModified
		do: [ :packageModification | aBlock cull: packageModification classesModification cull: packageModification  ]
%

category: 'enumerating'
method: RwPackageSetModification
classesModificationAndPackageModificationDo: aBlock

	"enumerate the classesModification in the packagesModification in the receiver.
		The classesModification and ppackageModification are arguments to the block. "

	elementsModified
		do: [ :packageModification | aBlock cull: packageModification classesModification cull: packageModification  ]
%

category: 'private - moves'
method: RwPackageSetModification
findAddedClasses

	| addedClasses |
	addedClasses := Dictionary new.
	elementsModified do: 
			[:packageModification |
			| classesModification |
			classesModification := packageModification classesModification.
			classesModification elementsModified do: 
					[:classModification |
					classModification before isEmpty
						ifTrue: 
							[| newClass |
							newClass := classModification after.
							addedClasses at: newClass key
								put: (RwClassAdditionOrRemoval
										packageDefinition: packageModification before
										classKey: newClass key
										classesModification: classesModification)]]].
	^addedClasses
%

category: 'private - moves'
method: RwPackageSetModification
findAddedMethods
	"Answer a dictionary of added methods."

	| addedMethods |
	addedMethods := Dictionary new.
	elementsModified do: 
			[:packageModification |
			self addMethodsAddedByPackageModification: packageModification
				toDictionary: addedMethods].
	^addedMethods
%

category: 'private - moves'
method: RwPackageSetModification
findRemovedClasses

	| removedClasses |
	removedClasses := Dictionary new.
	elementsModified do: 
			[:packageModification |
			| classesModification |
			classesModification := packageModification classesModification.
			classesModification elementsModified do: 
					[:classModification |
					classModification after isEmpty
						ifTrue: 
							[| oldClass |
							oldClass := classModification before.
							removedClasses at: oldClass key
								put: (RwClassAdditionOrRemoval
										packageDefinition: packageModification after
										classKey: oldClass key
										classesModification: classesModification)]]].
	^removedClasses
%

category: 'private - moves'
method: RwPackageSetModification
findRemovedMethods
	"Answer a dictionary of removed methods."

	| removedMethods |
	removedMethods := Dictionary new.
	elementsModified do: 
			[:packageModification |
			self addMethodsRemovedByPackageModification: packageModification
				toDictionary: removedMethods].
	^removedMethods
%

category: 'initialization'
method: RwPackageSetModification
initialize

	super initialize.
	movedClasses := Set new.
	movedMethods := Set new
%

category: 'private - moves'
method: RwPackageSetModification
updateForClassMoveFrom: removal to: addition
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition classModification |
	oldDefinition := (removal classesModification
				modificationOf: removal classKey) before.
	newDefinition := (addition classesModification
				modificationOf: addition classKey) after.

	"Delete the removal and the addition."
	removal classesModification removeModificationOf: removal classKey.
	addition classesModification removeModificationOf: addition classKey.

	"Record the move."
	movedClasses add: (RwClassMove
				classBefore: oldDefinition
				classAfter: newDefinition
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition).

	"Does the class have other modifications that need to be recorded?"
	classModification := newDefinition compareAgainstBase: oldDefinition.
	classModification isEmpty
		ifFalse: 
			[addition classesModification addElementModification: classModification]
%

category: 'moves'
method: RwPackageSetModification
updateForClassMoves

	| classAdditions classRemovals |
	classAdditions := self findAddedClasses.
	classRemovals := self findRemovedClasses.

	"Any keys that match between added and removed should be considered a move."
	classAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := classRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [self updateForClassMoveFrom: removal to: addition]]
%

category: 'private - moves'
method: RwPackageSetModification
updateForMethodMoveFrom: removal to: addition
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition methodModification |
	oldDefinition := (removal methodsModification
				modificationOf: removal methodKey) before.
	newDefinition := (addition methodsModification
				modificationOf: addition methodKey) after.

	"Delete the removal and the addition."
	removal methodsModification removeModificationOf: removal methodKey.
	addition methodsModification removeModificationOf: addition methodKey.

	"Record the move."
	movedMethods add: (RwMethodMove
				methodBefore: oldDefinition
				methodAfter: newDefinition
				classOrExtensionBefore: removal classDefinitionOrExtension
				classOrExtensionAfter: addition classDefinitionOrExtension
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition
				isMeta: addition isMeta).

	"Does the method have other modifications that need to be recorded?"
	methodModification := newDefinition compareAgainstBase: oldDefinition.
	methodModification isEmpty
		ifFalse: 
			[addition methodsModification addElementModification: methodModification]
%

category: 'moves'
method: RwPackageSetModification
updateForMethodMoves
	"Methods that have been moved between packages will initially show up as a remove and an add rather than a move.
	Find moved methods and correct the structure."

	| methodAdditions methodRemovals |
	methodAdditions := self findAddedMethods.
	methodRemovals := self findRemovedMethods.	"Any keys that match between added and removed should be considered a move."
	methodAdditions
		keysAndValuesDo: [ :key :addition | 
			| removal |
			removal := methodRemovals at: key ifAbsent: [ nil ].
			removal ifNotNil: [ self updateForMethodMoveFrom: removal to: addition ] ]
%

! Class implementation for 'RwProjectSetModification'

!		Instance methods for 'RwProjectSetModification'

category: 'visiting'
method: RwProjectSetModification
acceptVisitor: aVisitor

	^ aVisitor visitProjecteSetModification: self
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsAddedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package inProject: project toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before key
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> true -> newMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before key
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> false -> newMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsAddedByPackageModification: packageModification inProject: projectModification toDictionary: dictionary

	packageModification after key notNil
	ifTrue: [ 
		"ignore additions for packages that have been removed"
		self
			addMethodsAddedByClassesOrExtensionsModification: packageModification
					classesModification
			inPackage: packageModification after
			inProject: projectModification after
			toDictionary: dictionary.
		self
			addMethodsAddedByClassesOrExtensionsModification: packageModification
					classExtensionsModification
			inPackage: packageModification after
			inProject: projectModification after
			toDictionary: dictionary]
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsRemovedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package inProject: project toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after key
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> true -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification before
										methodKey: oldMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after key
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> false -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: oldMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsRemovedByPackageModification: packageModification inProject: projectModification toDictionary: dictionary

	packageModification before key notNil
	ifTrue: [ 
		"ignore removals for packages that have been added"
		self
			addMethodsRemovedByClassesOrExtensionsModification: packageModification
					classesModification
			inPackage: packageModification before
			inProject: projectModification before
			toDictionary: dictionary.
		self
			addMethodsRemovedByClassesOrExtensionsModification: packageModification
					classExtensionsModification
			inPackage: packageModification before
			inProject: projectModification before
			toDictionary: dictionary ]
%

category: 'enumerating'
method: RwProjectSetModification
classesModificationAndPackageModificationAndProjectModificationDo: aBlock

	"enumerate the classesModification in the packagesModification in the projectModification in the receiver.
		The classesModification, packageModification, and projectModification are arguments to the block. "

	elementsModified
		do: [ :projectModification | 
			projectModification packagesModification elementsModified
				do: [ :packageModification | aBlock cull: packageModification classesModification cull: packageModification cull: projectModification ] ]
%

category: 'private - moves'
method: RwProjectSetModification
findAddedClasses

	| addedClasses |
	addedClasses := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				| classesModification |
				classesModification := packageModification classesModification.
				classesModification elementsModified do: 
						[:classModification |
						classModification before isEmpty
							ifTrue: 
								[| newClass |
								newClass := classModification after.
								addedClasses at: newClass key
									put: (RwClassAdditionOrRemoval
											projectDefinition: projectModification after
											packageDefinition: packageModification after
											classKey: newClass key
											classesModification: classesModification)]]]].
	^addedClasses
%

category: 'private - moves'
method: RwProjectSetModification
findAddedMethods
	"Answer a dictionary of added methods."

	| addedMethods |
	addedMethods := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				self addMethodsAddedByPackageModification: packageModification
					inProject: projectModification
					toDictionary: addedMethods] ].
	^addedMethods
%

category: 'private - moves'
method: RwProjectSetModification
findAddedPackages
	| addedPackages |
	addedPackages := Dictionary new.
	elementsModified
		do: [ :projectModification | 
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified
				do: [ :packageModification | 
					packageModification before isEmpty
						ifTrue: [ 
							| newPackage |
							newPackage := packageModification after.
							addedPackages
								at: newPackage key
								put:
									(RwPackageAdditionOrRemoval
										projectDefinition: projectModification after
										packageDefinition: packageModification after
										packageKey: newPackage key
										packagesModification: packagesModification) ] ] ].
	^ addedPackages
%

category: 'private - moves'
method: RwProjectSetModification
findRemovedClasses

	| removedClasses |
	removedClasses := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				| classesModification |
				classesModification := packageModification classesModification.
				classesModification elementsModified do: 
						[:classModification |
						classModification after isEmpty
							ifTrue: 
								[| oldClass |
								oldClass := classModification before.
								removedClasses at: oldClass key
									put: (RwClassAdditionOrRemoval
											projectDefinition: projectModification before
											packageDefinition: packageModification before
											classKey: oldClass key
											classesModification: classesModification)]]]].
	^removedClasses
%

category: 'private - moves'
method: RwProjectSetModification
findRemovedMethods
	"Answer a dictionary of removed methods."

	| removedMethods |
	removedMethods := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				self addMethodsRemovedByPackageModification: packageModification
					inProject: projectModification
					toDictionary: removedMethods]].
	^removedMethods
%

category: 'private - moves'
method: RwProjectSetModification
findRemovedPackages
	| removedPackages |
	removedPackages := Dictionary new.
	elementsModified
		do: [ :projectModification | 
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified
				do: [ :packageModification | 
					packageModification after isEmpty
						ifTrue: [ 
							| oldPackage |
							oldPackage := packageModification before.
							removedPackages
								at: oldPackage key
								put:
									(RwPackageAdditionOrRemoval
										projectDefinition: projectModification before
										packageDefinition: packageModification before
										packageKey: oldPackage key
										packagesModification: packagesModification) ] ] ].
	^ removedPackages
%

category: 'initialization'
method: RwProjectSetModification
initialize
	super initialize.
	movedPackages := Set new.
	movedClasses := Set new.
	movedMethods := Set new
%

category: 'testing'
method: RwProjectSetModification
isEmpty
	^ super isEmpty and: [ movedClasses isEmpty and: [ movedMethods isEmpty ] ]
%

category: 'private - moves'
method: RwProjectSetModification
updateForClassMoveFrom: removal to: addition
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition classModification |
	removal
		ifNil: [ 
			"not a move"
			^ self ].
	addition
		ifNil: [ 
			"not a move"
			^ self ].
	oldDefinition := (removal classesModification modificationOf: removal classKey)
		before.
	newDefinition := (addition classesModification
		modificationOf: addition classKey) after.	"Delete the removal and the addition."
	removal classesModification removeModificationOf: removal classKey.
	addition classesModification removeModificationOf: addition classKey.	"Record the move."
	movedClasses
		add:
			(RwClassMove
				classBefore: oldDefinition
				classAfter: newDefinition
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition
				projectBefore: removal projectDefinition
				projectAfter: addition projectDefinition).	"Does the class have other modifications that need to be recorded?"
	classModification := newDefinition compareAgainstBase: oldDefinition.
	classModification isEmpty
		ifFalse: [ addition classesModification addElementModification: classModification ]
%

category: 'moves'
method: RwProjectSetModification
updateForClassMoves

	| classAdditions classRemovals |
	classAdditions := self findAddedClasses.
	classRemovals := self findRemovedClasses.

	"Any keys that match between added and removed should be considered a move."
	classAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := classRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [self updateForClassMoveFrom: removal to: addition]]
%

category: 'private - moves'
method: RwProjectSetModification
updateForMethodMoveFrom: removal to: addition isMeta: isMeta
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition methodModification |
	removal
		ifNil: [ 
			"not a move"
			^ self ].
	addition
		ifNil: [ 
			"not a move"
			^ self ].
	oldDefinition := (removal methodsModification modificationOf: removal methodKey)
		before.
	newDefinition := (addition methodsModification
		modificationOf: addition methodKey) after.
	"Delete the removal and the addition."
	removal methodsModification removeModificationOf: removal methodKey.
	addition methodsModification removeModificationOf: addition methodKey.
	"Record the move."
	movedMethods
		add:
			(RwMethodMove
				methodBefore: oldDefinition
				methodAfter: newDefinition
				classOrExtensionBefore: removal classDefinitionOrExtension
				classOrExtensionAfter: addition classDefinitionOrExtension
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition
				projectBefore: removal projectDefinition
				projectAfter: addition projectDefinition
				isMeta: addition isMeta).
	"Does the method have other modifications that need to be recorded?"
	methodModification := newDefinition compareAgainstBase: oldDefinition.
	methodModification
		isMeta: isMeta;
		classDefinition: addition classDefinitionOrExtension.
	methodModification isEmpty
		ifFalse: [ addition methodsModification addElementModification: methodModification ]
%

category: 'moves'
method: RwProjectSetModification
updateForMethodMoves
	"Methods that have been moved between packages will initially show up as a remove and an add rather than a move.
	Find moved methods and correct the structure."

	| methodAdditions methodRemovals |
	methodAdditions := self findAddedMethods.
	methodRemovals := self findRemovedMethods.
	"Any keys that match between added and removed should be considered a move."
	methodAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := methodRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [ self updateForMethodMoveFrom: removal to: addition isMeta: key key value]]
%

category: 'private - moves'
method: RwProjectSetModification
updateForPackageMoveFrom: removal to: addition
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition packageModification |
	removal
		ifNil: [ 
			"not a move"
			^ self ].
	addition
		ifNil: [ 
			"not a move"
			^ self ].
	oldDefinition := (removal packagesModification
		modificationOf: removal packageKey) before.
	newDefinition := (addition packagesModification
		modificationOf: addition packageKey) after.
	removal packagesModification removeModificationOf: removal packageKey.	"Delete the removal."
	addition packagesModification removeModificationOf: addition packageKey.	"Delete theaddition."

	movedPackages
		add:
			(RwPackageMove
				packageBefore: oldDefinition
				packageAfter: newDefinition
				projectBefore: removal projectDefinition
				projectAfter: addition projectDefinition).	"Record the move."
	packageModification := newDefinition compareAgainstBase: oldDefinition.
	packageModification isEmpty
		ifFalse: [ 
			"Does the package have other modifications that need to be recorded?"
			addition packagesModification addElementModification: packageModification ]
%

category: 'moves'
method: RwProjectSetModification
updateForPackageMoves

	| packageAdditions packageRemovals |
	packageAdditions := self findAddedPackages.
	packageRemovals := self findRemovedPackages.

	"Any keys that match between added and removed should be considered a move."
	packageAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := packageRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [self updateForPackageMoveFrom: removal to: addition]]
%

! Class implementation for 'RwMethodsModification'

!		Class methods for 'RwMethodsModification'

category: 'instance creation'
classmethod: RwMethodsModification
extendedClassName: ignored

	^ self new
%

!		Instance methods for 'RwMethodsModification'

category: 'visiting'
method: RwMethodsModification
acceptVisitor: aVisitor

	^aVisitor visitMethodsModification: self
%

category: 'merging'
method: RwMethodsModification
mergeForExistingClassWith: anExistingMethodsModification

	"merge anExistingMethodsModification modifictions into the receiver"

	anExistingMethodsModification elementsModified
		keysAndValuesDo: [ :selector :anExistingMethodModification | 
			"anExistingMethodsModification contains any new  or modified methods that 
				were applied to this class and they all need to be brought forward 
				along with the forced new versions of methods (those not changed or removed)"
			(elementsModified at: selector ifAbsent: [  ])
				ifNil: [
					"added method"
					elementsModified at: selector put: anExistingMethodModification ]
				ifNotNil: [
					 "modified method"
					elementsModified 
						at: selector 
						put: anExistingMethodModification asMethodModificationForNewClassVersion] ]
%

category: 'merging'
method: RwMethodsModification
mergeForNewClassVersionWith: aMethodsModification

	"merge aMethodsModification modifictions into the receiver"

	"add all method modifications to the receiver, there should be no selector overlap, if there is 
		the receiver wins --- but for now we'll error out. "

	aMethodsModification elementsModified
		keysAndValuesDo: [ :selector :aMethodModification | 
			(elementsModified at: selector ifAbsent: [  ])
				ifNil: [elementsModified at: selector put: aMethodModification]
				ifNotNil: [ :existingMethodModification | 
					existingMethodModification mergeForNewClassVersionWith: aMethodModification ] ]
%

! Class implementation for 'RwExtensionMethodsModification'

!		Class methods for 'RwExtensionMethodsModification'

category: 'instance creation'
classmethod: RwExtensionMethodsModification
extendedClassName: aString

	^ self new
		extendedClassName: aString;
		yourself
%

!		Instance methods for 'RwExtensionMethodsModification'

category: 'visiting'
method: RwExtensionMethodsModification
acceptVisitor: aVisitor

	^ aVisitor visitExtensionMethodsModification: self
%

category: 'modifications'
method: RwExtensionMethodsModification
addElementModification: aModification

	aModification isEmpty
		ifFalse: [ 
			| anExtensionModification |
			anExtensionModification := aModification asExtensionMethodModification.
			anExtensionModification extendedClassName: self extendedClassName.
			elementsModified at: anExtensionModification key put: anExtensionModification ]
%

category: 'accessing'
method: RwExtensionMethodsModification
extendedClassName

   ^extendedClassName
%

category: 'accessing'
method: RwExtensionMethodsModification
extendedClassName: anObject

	extendedClassName := anObject
%

! Class implementation for 'RwPackagesModification'

!		Instance methods for 'RwPackagesModification'

category: 'visiting'
method: RwPackagesModification
acceptVisitor: aVisitor

	^ aVisitor visitPackagesModification: self
%

! Class implementation for 'RwPropertiesModification'

!		Instance methods for 'RwPropertiesModification'

category: 'visiting'
method: RwPropertiesModification
acceptVisitor: aVisitor

	^aVisitor visitPropertiesModification: self
%

! Class implementation for 'RwSourceModification'

!		Instance methods for 'RwSourceModification'

category: 'visiting'
method: RwSourceModification
acceptVisitor: aVisitor

	^aVisitor visitSourceModification: self
%

! Class implementation for 'RwEntitySet'

!		Class methods for 'RwEntitySet'

category: 'instance creation'
classmethod: RwEntitySet
withAll: somePackageRefs

	^(self new)
		initialize;
		addAll: somePackageRefs;
		yourself
%

!		Instance methods for 'RwEntitySet'

category: 'accessing'
method: RwEntitySet
addAll: aRwDefinitionOrRwLoadedThingCollection

	aRwDefinitionOrRwLoadedThingCollection
		do: [ :entity | entities at: entity name put: entity ].
	^ aRwDefinitionOrRwLoadedThingCollection
%

category: 'definitions'
method: RwEntitySet
asDefinitionSet

	| result |
	result := RwDefinitionSetDefinition new.
	entities do: [ :entity | result addDefinition: entity asDefinition ].
	^ result
%

category: 'definitions'
method: RwEntitySet
asPackageDefinitionSet

	| result |
	result := RwPackageSetDefinition new.
	entities do: [ :entity | result addDefinition: entity asDefinition ].
	^ result
%

category: 'definitions'
method: RwEntitySet
asProjectDefinitionSet

	| result |
	result := RwProjectSetDefinition new.
	entities do: [ :entity | result addDefinition: entity asDefinition ].
	^ result
%

category: 'enumeration'
method: RwEntitySet
do: aBlock

	^ entities do: aBlock
%

category: 'accessing'
method: RwEntitySet
entities

	^ entities
%

category: 'initialization'
method: RwEntitySet
initialize

	entities := Dictionary new
%

category: 'accessing'
method: RwEntitySet
size

	^ entities size
%

! Class implementation for 'RwGsImage'

!		Class methods for 'RwGsImage'

category: 'querying'
classmethod: RwGsImage
addLoadedProject: aRwLoadedProject

	"Register a project"

	| projectName projectRegistry |
	aRwLoadedProject projectOwnerId: self currentUserId.
	projectName := aRwLoadedProject name.
	projectRegistry := self
		_loadedProjectRegistryForUserId: aRwLoadedProject projectOwnerId.
	projectRegistry
		at: projectName
		ifAbsent: [ ^ projectRegistry at: projectName put: aRwLoadedProject ].
	self
		error:
			'There is already a project named ' , projectName printString , ' registered'
%

category: 'testing'
classmethod: RwGsImage
canWrite: anObject

	^ System canWrite: anObject
%

category: 'querying'
classmethod: RwGsImage
currentUserId

	^ GsCurrentSession currentSession userProfile userId
%

category: 'operations'
classmethod: RwGsImage
ensureSessionMethodsEnabled

	"Ensure that session methods are enabled for the current user."

	GsPackagePolicy current enabled
		ifFalse: [ GsPackagePolicy current enable ].
%

category: 'querying'
classmethod: RwGsImage
loadedClassExtensionsNamed: className ifFound: foundBlock ifAbsent: absentBlock

	"scan the symbol list for a RwLoadedClassExtension instances of the given name"

	| class found |
	class := self objectNamed: className.
	class ifNil: [ ^ absentBlock value ].
	
	found := self loadedClassExtensionsForClass: class.
	found isEmpty
		ifFalse: [ ^ foundBlock value: found ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedClassNamed: className

	^ self
		loadedClassNamed: className
		ifAbsent: [ self error: 'loaded class named ' , className printString , ' not found.' ]
%

category: 'querying'
classmethod: RwGsImage
loadedClassNamed: className ifAbsent: absentBlock

	^ self
		loadedClassNamed: className
		ifFound: [ :loadedClass | ^ loadedClass ]
		ifAbsent: absentBlock
%

category: 'querying'
classmethod: RwGsImage
loadedHybridPackageNamed: aHybridName ifAbsent: absentBlock

	"scan the symbol list a RwLoadedPackage instance of the given hybrid name"

	"a hybrid package name has a leading '*' followed by the name of a package ... 
		where the hybrid package name is not expected to preserve case"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry loadedHybridPackageNamed: aHybridName ifAbsent: [  ])
						ifNotNil: [ :loadedPackage | ^ loadedPackage ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedMethodForMethod: compiledMethod

	"scan the symbol list for a RwLoadedMethod instances for the given compiled method"

	^ self
		loadedMethodForMethod: compiledMethod
		ifAbsent: [ 
			self
				error:
					'No loadedMethod found for the compiled method ' , compiledMethod printString ]
%

category: 'querying'
classmethod: RwGsImage
loadedPackageNamed: aString

	^ self
		loadedPackageNamed: aString
		ifAbsent: [ self error: 'No loaded package named ' , aString printString , ' found' ]
%

category: 'querying'
classmethod: RwGsImage
loadedPackageNamed: aName ifAbsent: absentBlock

	"scan the symbol list a RwLoadedPackage instance of the given name"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry loadedPackageNamed: aName ifAbsent: [  ])
						ifNotNil: [ :loadedPackage | ^ loadedPackage ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedProjectNamed: aString

	^ self
		loadedProjectNamed: aString
		ifPresent: [:loadedProject | loadedProject ]
		ifAbsent: [ self error: 'No loaded project named ' , aString printString , ' found' ]
%

category: 'querying'
classmethod: RwGsImage
loadedProjectNamed: aString ifAbsent: absentBlock

	"Look up a loaded project in the loaded project registry"

	^ self
		loadedProjectNamed: aString
		ifPresent: [:loadedProject | loadedProject ]
		ifAbsent: absentBlock
%

category: 'querying'
classmethod: RwGsImage
loadedProjectNamed: aString ifPresent: presentBlock ifAbsent: absentBlock

	"Look up a loaded project in the loaded project registry"

	| loadedProject |
	loadedProject := self _loadedProjectRegistry
		at: aString
		ifAbsent: [
			| matchingProjects |
			matchingProjects := self loadedProjects select: [:each | each name = aString ].
			matchingProjects size > 1 ifTrue: [ self error: 'Multiple projects with same name available from symbol dictionaries in symbol list' ].
			matchingProjects size = 0 ifTrue: [ ^ absentBlock value ].
			matchingProjects any ].
	^ presentBlock cull: loadedProject
%

category: 'querying'
classmethod: RwGsImage
loadedProjects

	"Return the list of loaded projects based on the packages that are visible in the current transient symbol list."

	| loadedProjects |
	loadedProjects := (self _loadedProjectRegistryForUserId: self currentUserId) values asIdentitySet. "list of projects created by current user"
	(self symbolList select: [:symDict | 
		symDict rowanSymbolDictionaryRegistry notNil])
		do: [:symDict | 
			"visible loaded packages"
			symDict rowanSymbolDictionaryRegistry packageRegistry values 
				do: [:loadedPackage | 
					"visible loaded projects"
					loadedProjects add: loadedPackage loadedProject ] ].
	^loadedProjects
%

category: 'querying'
classmethod: RwGsImage
loadedRegistryForPackageNamed: aName
	"scan the symbol list for a RwLoadedPackage instance of the given name and return the registry"

	^ self
		loadedRegistryForPackageNamed: aName
		ifAbsent: [ self error: 'The package ' , aName printString , ' was not found' ]
%

category: 'querying'
classmethod: RwGsImage
loadedRegistryForPackageNamed: aName ifAbsent: absentBlock
	"scan the symbol list for a RwLoadedPackage instance of the given name and return the registry"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry loadedPackageNamed: aName ifAbsent: [  ])
						ifNotNil: [ :loadedPackage | ^ registry ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
newOrExistingSymbolDictionaryNamed: dictName

	"If the current session's transient symbol list includes a dictionary with the given name, answer it.
	Otherwise, create one, add it to the beginning of both transient and persistent symbol lists, and 
	answer it."

	| symbolName  symbolList symbolDict |
	symbolName := dictName asSymbol.
	symbolList := self symbolList.
	symbolDict := symbolList
		detect: [ :each | (each at: symbolName ifAbsent: [ nil ]) == each ]
		ifNone: [ 
			| newDict size |
			newDict := SymbolDictionary new
				name: symbolName;
				objectSecurityPolicy: symbolList objectSecurityPolicy;
				yourself.
			size := System myUserProfile symbolList size.
			System myUserProfile insertDictionary: newDict at: size + 1.
			newDict ].
	symbolDict rowanSymbolDictionaryRegistry
		ifNil: [ self symbolDictionaryRegistryClass installIn: symbolDict ].
	^ symbolDict
%

category: 'querying'
classmethod: RwGsImage
objectNamed: aSymbol

	"Returns the first object in the current session's symbol list that has the given
 name.  If no object with the given name is found, returns nil."

	^ self symbolList objectNamed: aSymbol
%

category: 'querying'
classmethod: RwGsImage
packageNames

	"Return list of package names. All sytem projects are visible, but not all packages of visible projects
		are visible."

	| packageNames visiblePackageNames |
	packageNames := Set new.
	visiblePackageNames := Set new.
	(self symbolList select: [:symDict | 
		symDict rowanSymbolDictionaryRegistry notNil])
		do: [:symDict | 
			visiblePackageNames 
				addAll: symDict rowanSymbolDictionaryRegistry packageRegistry keys ].
	self loadedProjects
		do: [ :loadedProject | 
			loadedProject packageNames do: [:packageName |
				(visiblePackageNames includes: packageName) ifTrue: [ packageNames add: packageName ] ] ].
	^ packageNames asArray
%

category: 'querying'
classmethod: RwGsImage
packageNamesForLoadedProjectNamed: projectName

	"Return list of package names for the loaded project with the given name. All sytem projects are visible, but not all packages of visible projects
		are visible."

	| packageNames visiblePackageNames |
	packageNames := Set new.
	visiblePackageNames := Set new.
	(self symbolList select: [:symDict | 
		symDict rowanSymbolDictionaryRegistry notNil])
		do: [:symDict | 
			visiblePackageNames 
				addAll: symDict rowanSymbolDictionaryRegistry packageRegistry keys ].
	(self loadedProjectNamed: projectName) packageNames do: [:packageName |
				(visiblePackageNames includes: packageName) ifTrue: [ packageNames add: packageName ] ].
	^ packageNames asArray
%

category: 'cypress (old)'
classmethod: RwGsImage
projectNames

	"Return list of project names"

	^ (self loadedProjects collect: [ :loadedProject | loadedProject name ]) asArray
%

category: 'querying'
classmethod: RwGsImage
resolveClassNamed: aName

	"If the given name is bound to a class in the environment of the current session, 
	answer that class. Otherwise, answer nil."

	| resolved |
	resolved := self objectNamed: aName.
	^ (resolved isBehavior and: [ resolved isMeta not ])
		ifTrue: [ resolved ]
		ifFalse: [ nil ]
%

category: 'querying'
classmethod: RwGsImage
resolveName: aName

	"Searches the current session's symbol list for an Association whose key is equal to
 aString, and returns that Association.  If no such Association is found in the
 symbol list, returns nil. Uses the current session's transient copy of the symbol list."

	^ GsCurrentSession currentSession resolveSymbol: aName asSymbol
%

category: 'querying'
classmethod: RwGsImage
symbolDictNamed: symbolDictName
	"Search symbol list for a symbol dictionary with the given name"

	^ self
		symbolDictNamed: symbolDictName
		ifAbsent: [ 
			self
				error:
					'No symbol dictionary with the name ' , symbolDictName printString , ' found.' ]
%

category: 'querying'
classmethod: RwGsImage
symbolDictNamed: symbolDictName ifAbsent: absentBlock
	"Search symbol list for a symbol dictionary with the given name"

	| symbolDictNameSymbol |
	symbolDictNameSymbol := symbolDictName asSymbol.
	^ self symbolList
		detect: [ :each | (each at: symbolDictNameSymbol ifAbsent: [ nil ]) == each ]
		ifNone: absentBlock
%

category: 'querying'
classmethod: RwGsImage
symbolList

	"Answer the current session (transient) symbol list"

	^ GsCurrentSession currentSession symbolList
%

category: 'private'
classmethod: RwGsImage
_loadedProjectRegistry

	^ self _loadedProjectRegistryForUserId: self currentUserId
%

category: 'private'
classmethod: RwGsImage
_loadedProjectRegistryForUserId: aUserId

	| userProfile userPlatformDict |
	userProfile := AllUsers userWithId: aUserId.
	(userProfile defaultObjectSecurityPolicy ifNil: [true] ifNotNil: [:x |x currentUserCanRead])
		ifFalse: [
			"do not have permissions to read objects created by <aUserId>"
			^ nil ].
	userPlatformDict := RwPlatform _userPlatformDictionaryForUser: aUserId.
	^ userPlatformDict
		at: #'RwGsLoadedProjectRegistry'
		ifAbsent: [ 
			(self currentUserId = aUserId)
				ifFalse: [ ^ nil ].
			userPlatformDict at: #'RwGsLoadedProjectRegistry' put: StringKeyValueDictionary new ]
%

category: 'querying'
classmethod: RwGsImage
_removeLoadedProject: aRwLoadedProject

	"note that it is not safe to just remove a loaded project from the registry, however this method is supplied as a convenience for tests"

	^ self 
		_removeLoadedProject: aRwLoadedProject 
		ifAbsent: [ self error: 'The specified project was not found in the loaded project registry.' ]
%

category: 'querying'
classmethod: RwGsImage
_removeLoadedProject: aRwLoadedProject ifAbsent: absentBlock

	"note that it is not safe to just remove a loaded project from the registry, however this method is supplied as a convenience for tests"

	| projectName projectRegistry |
	projectName := aRwLoadedProject name.
	projectRegistry := self
		_loadedProjectRegistryForUserId: aRwLoadedProject projectOwnerId.
	(projectRegistry 
		at: projectName 
		ifAbsent: [ ^ absentBlock value ]) == aRwLoadedProject
			ifFalse: [ 
				self
					error:
						'The specified project is not identical to the loaded project in the registry.' ].
	projectRegistry removeKey: projectName
%

! Class implementation for 'RwGsImagePatchVisitor_V2'

!		Class methods for 'RwGsImagePatchVisitor_V2'

category: 'instance creation'
classmethod: RwGsImagePatchVisitor_V2
new

	^super new initialize
%

!		Instance methods for 'RwGsImagePatchVisitor_V2'

category: 'private'
method: RwGsImagePatchVisitor_V2
addAddedPackage: aPackageDefinition

	currentPackage := aPackageDefinition.
	patchSet addAddedPackage: currentPackage inProject: currentProject.
%

category: 'private'
method: RwGsImagePatchVisitor_V2
addAddedProject: aProjectDefinition

	currentProject := aProjectDefinition.
	patchSet addAddedProject: currentProject
%

category: 'private'
method: RwGsImagePatchVisitor_V2
addDeletedPackage: aPackageDefinition

	currentPackage := aPackageDefinition.
	patchSet addDeletedPackage: currentPackage inProject: currentProject
%

category: 'private'
method: RwGsImagePatchVisitor_V2
addDeletedProject: aProjecteDefinition

	self error: 'not yet implemented'
%

category: 'initialization'
method: RwGsImagePatchVisitor_V2
initialize

	patchSet := RwGsPatchSet_V2 new
%

category: 'accessing'
method: RwGsImagePatchVisitor_V2
patchSet
	^patchSet
%

category: 'public'
method: RwGsImagePatchVisitor_V2
visit: aPackageSetModification

	^aPackageSetModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitClassesModification: aClassesModification

	aClassesModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitClassExtensionModification: aClassExtensionModification

	aClassExtensionModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassExtensionModification after.
	aClassExtensionModification instanceMethodsModification acceptVisitor: self.
	aClassExtensionModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitClassExtensionsModification: aClassExtensionsModification

	aClassExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitClassModification: aClassModification

	aClassModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassModification after.
	aClassModification instanceMethodsModification acceptVisitor: self.
	aClassModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitClassModificationForcingNewVersion: aClassModification

	aClassModification
		addModificationForcingNewClassVersionToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassModification after.
	aClassModification instanceMethodsModification acceptVisitor: self.
	aClassModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitExtensionMethodModification: anExtensionMethodModification

	anExtensionMethodModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitExtensionMethodModificationForNewClassVersion: aMethodModification

	aMethodModification
		addExtensionModificationToPatchSetForNewClassVersion: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitExtensionMethodsModification: anExtensionMethodsModification

	anExtensionMethodsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitMethodModification: aMethodModification

	aMethodModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitMethodModificationForNewClassVersion: aMethodModification

	aMethodModification
		addModificationToPatchSetForNewClassVersion: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitMethodsModification: aMethodsModification

	aMethodsModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitPackageModification: aPackageModification
	| propertiesModification beforePackage |
	aPackageModification isAddition
		ifTrue: [ self addAddedPackage: aPackageModification after ].
	currentPackage := aPackageModification after.
	beforePackage := aPackageModification before.
	aPackageModification isDeletion
		ifTrue: [ 
			self addDeletedPackage: aPackageModification before.
			currentPackage := beforePackage ].
	aPackageModification isModification
		ifTrue: [ 
			propertiesModification := aPackageModification propertiesModification.
			(propertiesModification elementsModified includesKey: 'gs_SymbolDictionary')
				ifTrue: [ 
					currentPackage classDefinitions
						keysAndValuesDo: [ :className :afterClassDef | 
							beforePackage classDefinitions
								at: className
								ifPresent: [ :beforeClassDef | 
									patchSet
										addClassMove:
											(RwClassMove
												classBefore: beforeClassDef
												classAfter: afterClassDef
												packageBefore: beforePackage
												packageAfter: currentPackage
												projectBefore: currentProject
												projectAfter: currentProject) ] ].
					patchSet addMovedPackage: currentPackage inProject: currentProject ] ].
	aPackageModification classesModification acceptVisitor: self.
	aPackageModification classExtensionsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitPackageSetModification: aPackageSetModification

	aPackageSetModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitPackagesModification: aPackagesModification

	aPackagesModification elementsModified do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitProjecteSetModification: aProjectSetModification

	aProjectSetModification movedPackages do: [:movedPackage | 
		movedPackage addMovedPackageToPatchSet: patchSet ].
	aProjectSetModification movedClasses do: [:movedClass | 
		movedClass addMovedClassToPatchSet: patchSet ].
	aProjectSetModification movedMethods do: [:movedMethod | 
		movedMethod addMovedMethodToPatchSet: patchSet ].
	aProjectSetModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitProjectModification: aProjectModification

	| propertiesModification |
	aProjectModification isAddition
		ifTrue: [ 
			self addAddedProject: aProjectModification after.
			aProjectModification packagesModification acceptVisitor: self.
			^ self ].
	aProjectModification isDeletion
		ifTrue: [ 
			self addDeletedProject: aProjectModification before.
			aProjectModification packagesModification acceptVisitor: self.
			^ self ].
	currentProject := aProjectModification after.
	propertiesModification := aProjectModification propertiesModification.
	propertiesModification isEmpty
		ifFalse: [ 
			"https://github.com/dalehenrich/Rowan/issues/180"
			| modifiedProperties |
			modifiedProperties := String new.
			propertiesModification elementsModified keys do: [:key | modifiedProperties add: ' '; add: key printString ].
			self error: 'internal error - unexpected non-empty project properties modification:', modifiedProperties, '. See Issue #180'  ].
	aProjectModification packagesModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitPropertiesModification: aPropertiesModification

	self error: 'internal error - not yet implemented'
%

category: 'visting'
method: RwGsImagePatchVisitor_V2
visitSourceModification: aSourceModification

	self error: 'internal error - not yet implemented'
%

! Class implementation for 'RwGsInstanceMigrator'

!		Class methods for 'RwGsInstanceMigrator'

category: 'instance creation'
classmethod: RwGsInstanceMigrator
aggressiveMigration

	^ self new
		maxThreads: SystemRepository _aggressiveMaxThreadCount;
		maxCpuPercentage: 95;
		yourself
%

category: 'instance creation'
classmethod: RwGsInstanceMigrator
conservativeMigration

	^ self new
%

category: 'instance creation'
classmethod: RwGsInstanceMigrator
noMigration

	^ self new
		migrationEnabled: false;
		yourself
%

!		Instance methods for 'RwGsInstanceMigrator'

category: 'accessing'
method: RwGsInstanceMigrator
maxCpuPercentage

	^ maxCpuPercentage ifNil: [ 90 ]
%

category: 'accessing'
method: RwGsInstanceMigrator
maxCpuPercentage: anObject

   maxCpuPercentage := anObject
%

category: 'accessing'
method: RwGsInstanceMigrator
maxThreads

	^ maxThreads ifNil: [ 2 ]
%

category: 'accessing'
method: RwGsInstanceMigrator
maxThreads: anObject

   maxThreads := anObject
%

category: 'migration'
method: RwGsInstanceMigrator
migrateInstancesOf: aClassArray

	| instancesArray classCount |
	self migrationEnabled
		ifFalse: [ ^ self ].
	System commit.
	instancesArray := SystemRepository
		listInstances: aClassArray
		limit: 0
		toDirectory: nil
		withMaxThreads: self maxThreads
		maxCpuUsage: self maxCpuPercentage
		memoryOnly: false.
	classCount := 1.
	1 to: instancesArray size by: 2 do: [ :index | 
		| class instances history instanceCount |
		class := aClassArray at: classCount.
		instanceCount := instancesArray at: index.
		instances := instancesArray at: index + 1.
		history := class classHistory.
		instanceCount > 0
			ifTrue: [ class migrateInstances: instances to: history last ].
		[ 1 < history size ] whileTrue: [ | cl | cl := history first. cl classHistory removeVersion: cl ].
		classCount := classCount + 1 ]
%

category: 'accessing'
method: RwGsInstanceMigrator
migrationEnabled

	^ migrationEnabled ifNil: [ true ]
%

category: 'accessing'
method: RwGsInstanceMigrator
migrationEnabled: anObject

   migrationEnabled := anObject
%

! Class implementation for 'RwGsDeferredInstanceMigrator'

!		Instance methods for 'RwGsDeferredInstanceMigrator'

category: 'accessing'
method: RwGsDeferredInstanceMigrator
classesToMigrate

	^ classesToMigrate
%

category: 'migration'
method: RwGsDeferredInstanceMigrator
migrateInstancesOf: aClassArray

	"Record the list of classes with new class versions"

	classesToMigrate := aClassArray
%

! Class implementation for 'RwGsPatchSet_V2'

!		Class methods for 'RwGsPatchSet_V2'

category: 'private - method initialization order'
classmethod: RwGsPatchSet_V2
classPatchesInReverseHierarchyOrder: classPatches tempSymbols: tempSymbols

	"Returns acollection of the specified classPatches ordered in reverse superclass order"

	| order toBeOrdered processed aClass patchMap |
	patchMap := IdentityKeyValueDictionary new.
	classPatches do: [:classPatch |
		| class |
		class := tempSymbols
				at: classPatch className
				ifAbsent: [ self error: 'Cannot find class to update constraints for.' ].
		patchMap at: class put: classPatch ].
	toBeOrdered := patchMap keys asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[ (aClass := self _anyElementOf: toBeOrdered ifEmpty: [ nil ]) isNil ]
		whileFalse: [ 
			self
				_orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed ].
  ^ ((order collect: [:orderedClass | patchMap at: orderedClass ifAbsent: []]) select: [:patch | patch notNil ]) reverse
%

category: 'accessing'
classmethod: RwGsPatchSet_V2
lookupSymbolDictName: symDictName in: symbolList
	^ self
		lookupSymbolDictName: symDictName
		in: symbolList
		ifAbsent: [ 
			self
				error:
					'the symbol dictionary named ' , symDictName asString printString
						, ' was not found in the symbol list' ]
%

category: 'accessing'
classmethod: RwGsPatchSet_V2
lookupSymbolDictName: symDictName in: symbolList ifAbsent: absentBlock
	^ symbolList
		detect: [ :each | (each at: symDictName ifAbsent: [ nil ]) == each ]
		ifNone: absentBlock
%

category: 'private - method initialization order'
classmethod: RwGsPatchSet_V2
methodPatchesInInitializationOrder: methodPatches

	"Returns acollection of the specified methodPatches ordered in superclass order, which is sufficient for initialization order."

	| order toBeOrdered processed aClass patchMap |
	patchMap := IdentityKeyValueDictionary new.
	methodPatches do: [:methodPatch |
		patchMap at: methodPatch behavior thisClass put: methodPatch ].
	toBeOrdered := patchMap keys asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[ (aClass := self _anyElementOf: toBeOrdered ifEmpty: [ nil ]) isNil ]
		whileFalse: [ 
			self
				_orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed ].
  ^ (order collect: [:orderedClass | patchMap at: orderedClass ifAbsent: []]) select: [:patch | patch notNil ]
%

category: 'instance creation'
classmethod: RwGsPatchSet_V2
new

	^super new initialize
%

category: 'accessing'
classmethod: RwGsPatchSet_V2
resolveSymbolDictWith: assocation in: symbolList
| res aDict |
res := { } .
1 to: symbolList size do:[ :j |
  (aDict := symbolList at: j) ifNotNil:[
    aDict associationsDo:[ :assoc |
      assoc == assocation ifTrue:[ res add: aDict]
    ].
  ].
].
^ res
%

category: 'private - method initialization order'
classmethod: RwGsPatchSet_V2
_anyElementOf: aCollection ifEmpty: aBlock
	aCollection do: [ :each | ^ each ].
	^ aBlock value
%

category: 'private - method initialization order'
classmethod: RwGsPatchSet_V2
_orderBySuperclass: aClass from: toBeOrdered into: order ignoring: processed
  "Private. Add to 'order', superclasses first, aClass and any of its superclasses 
	that appear in 'toBeOrdered' but do not appear in 'processed'.
	Remove from 'toBeOrdered' any class added to 'ordered'.
	Any class seen, add to 'processed' whether or not added to 'order'."

  | superclass |
  superclass := aClass superclass.
  superclass isNil | (processed includes: superclass)
    ifFalse: [ 
      self
        _orderBySuperclass: superclass
        from: toBeOrdered
        into: order
        ignoring: processed ].
  processed add: aClass.
  (toBeOrdered includes: aClass)
    ifTrue: [ 
      toBeOrdered remove: aClass.
      order add: aClass ]
%

!		Instance methods for 'RwGsPatchSet_V2'

category: 'building'
method: RwGsPatchSet_V2
addAddedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedClasses
		add:
			((self _classAdditionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'private - applying'
method: RwGsPatchSet_V2
addAddedClassesToTempSymbols
	"Just need the names for now, they don't need to resolve to anything in particular."

	addedClasses do: [:patch | 
		| key |
		key :=  patch className asSymbol.
		(tempSymbols includesKey: key) ifTrue: [ self error: 'Encountered an existing association for a new class ', key asString ].
		tempSymbols at: key put: nil ].
%

category: 'building'
method: RwGsPatchSet_V2
addAddedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedMethods
		add:
			((self _methodAdditionPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addAddedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedMethods
		add:
			((self _methodAdditionPatchClass
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addAddedPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedPackages
		add:
			((self _packageAdditionPatchClass for: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addAddedProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedProjects
		add: (self _projectAdditionPatchClass for: aProjectDefinition) yourself
%

category: 'building'
method: RwGsPatchSet_V2
addAddedUnmanagedClass: aClassDefinition oldClassVersion: aClass inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedUnmanagedClasses
		add:
			((self _classUnmanagedAdditionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				oldClassVersion: aClass
				yourself)
%

category: 'private - applying'
method: RwGsPatchSet_V2
addAndUpdateLoadedPackages
	"Update the LoadedPackages to reflect the results of this patchSet. Does not update the other loadedThings."

	addedPackages
		do: [:packageAdditionPatch | packageAdditionPatch createLoadedPackage]
%

category: 'private - applying'
method: RwGsPatchSet_V2
addAndUpdateLoadedProjects

	"Update the LoadedProjects to reflect the results of this patchSet. Does not update the other loadedThings."

	addedProjects
		do: [ :projectAdditionPatch | projectAdditionPatch createLoadedProject ].
	projectsWithPropertyChanges do: [ :patch | "patch updateLoadedProject" self error: 'Not yet implmented' ]
%

category: 'modification dispatching'
method: RwGsPatchSet_V2
addClassModification: aRwClassModification toPatchSetInPackage: aPackage inProject: aProjectDefinition
	"Double dispatch from aRwClassModification ... needed to isolate the loader methods from meaningful changes 
		while updating the loader using the loader"

	aRwClassModification isAddition
		ifTrue: [ 
			| symDictName className |
			"https://github.com/dalehenrich/Rowan/issues/210 - make sure that the added classes are not already loaded
				in a project that is not included in this load"
			className := aRwClassModification after name.
			symDictName := aProjectDefinition
				symbolDictNameForPackageNamed: aPackage name.
			Rowan image newOrExistingSymbolDictionaryNamed: symDictName.
			(Rowan globalNamed: aRwClassModification after name)
				ifNotNil: [ :class | 
					(Rowan image loadedClassForClass: class ifAbsent: [  ])
						ifNil: [ 
							| theClassDefinition theClassModification |
							"no loaded class exists for the class"
							theClassDefinition := class
								rwClassDefinitionInSymbolDictionaryNamed: symDictName.
							theClassModification := aRwClassModification after
								compareAgainstBase: theClassDefinition.
							theClassModification isEmpty
								ifTrue: [ 
									self
										addAddedUnmanagedClass: aRwClassModification after
										oldClassVersion: class
										inPackage: aPackage
										inProject: aProjectDefinition ]
								ifFalse: [ 
									aRwClassModification before: theClassDefinition.
									self
										addPatchedUnmanagedClassNewVersion: aRwClassModification
										inPackage: aPackage
										inProject: aProjectDefinition ].
							(aRwClassModification propertiesModification elementsModified
								at: 'gs_constraints'
								ifAbsent: [  ])
								ifNotNil: [ :constraints | 
									"arrange to add constraints to a newly created class - constraints not created during class creation"
									self
										addPatchedClassConstraints: aRwClassModification after
										inPackage: aPackage
										inProject: aProjectDefinition ].
							^ self ]
						ifNotNil: [ 
							"if the class is packaged, then it must be in another project, signal notification"
							(RwExistingVisitorAddingExistingClassNotification new
								class: class;
								classDefinition: aRwClassModification after;
								yourself) signal ] ].
			self
				addAddedClass: aRwClassModification after
				inPackage: aPackage
				inProject: aProjectDefinition.
			(aRwClassModification propertiesModification elementsModified
				at: 'gs_constraints'
				ifAbsent: [  ])
				ifNotNil: [ :constraints | 
					"arrange to add constraints to a newly created class - constraints not created during class creation"
					self
						addPatchedClassConstraints: aRwClassModification after
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	aRwClassModification isDeletion
		ifTrue: [ 
			self
				addDeletedClass: aRwClassModification before
				inPackage: aPackage
				inProject: aProjectDefinition ].
	aRwClassModification isModification
		ifTrue: [ 
			RwGsClassVersioningPatchV2
				addPatchedClassModification: aRwClassModification
				inPackage: aPackage
				inProject: aProjectDefinition
				toPatchSet: self.
			(aRwClassModification propertiesModification elementsModified
				at: 'gs_constraints'
				ifAbsent: [  ])
				ifNotNil: [ :constraints | 
					"arrange to add constraints to a newly created class - constraints not created during class creation"
					self
						addPatchedClassConstraints: aRwClassModification after
						inPackage: aPackage
						inProject: aProjectDefinition ] ]
%

category: 'building'
method: RwGsPatchSet_V2
addClassMove: aRwClassMove

	movedClasses add: aRwClassMove
%

category: 'private - applying'
method: RwGsPatchSet_V2
addCreatedClassesAndVersionsToSymbolList: newClassesByNameSymbolList
	addedClasses
		do: [ :patch | patch addToNewClassesByNameSymbolList: newClassesByNameSymbolList ].
	addedUnmanagedClasses
		do: [ :patch | patch addToNewClassesByNameSymbolList: newClassesByNameSymbolList ].
	classesWithClassVariableChanges
		do: [ :patch | patch addToNewClassesByNameSymbolList: newClassesByNameSymbolList ].
	classesWithNewVersions
		do: [ :patch | patch addToNewClassesByNameSymbolList: newClassesByNameSymbolList ]
%

category: 'building'
method: RwGsPatchSet_V2
addDeletedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedClasses
		add:
			((self _classDeletionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addDeletedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			((self _methodDeletionPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addDeletedExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition named: className inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			(((self _methodExtensionDeletionPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				extendedClassName: className;
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addDeletedExtendedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition named: className inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			(((self _methodExtensionDeletionPatchClass: aPackageDefinition key)
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				extendedClassName: className;
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addDeletedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			((self _methodDeletionPatchClass
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addDeletedPackage: packageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedPackages
		add:
			((self _packageDeletionPatchClass for: packageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addExtendedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition
	currentProjectDefinition := aProjectDefinition.
	Rowan image
		newOrExistingSymbolDictionaryNamed:
			(aProjectDefinition symbolDictNameForPackageNamed: aPackageDefinition name).	"ensure that symbol dictionary exists"
	extendedClasses
		add:
			((self _classExtensionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedMethods
		add:
			(((self _methodExtensionPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addExtendedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedMethods
		add:
			(((self _methodExtensionPatchClass: aPackageDefinition key)
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'modification dispatching'
method: RwGsPatchSet_V2
addForcingNewClassVersionModification: aRwClassModificationForcingNewClassVersion toPatchSetInPackage: aPackage inProject: aProjectDefinition
	"Double dispatch from aRwClassModificationForcingNewClassVersion ... needed to isolate the loader methods from meaningful changes 
		while updating the loader using the loader"

	aRwClassModificationForcingNewClassVersion isAddition
		ifTrue: [ self error: 'unexpected addition for modification forcing new class version' ].
	aRwClassModificationForcingNewClassVersion isDeletion
		ifTrue: [ self error: 'unexpected deletion for modification forcing new class version' ].
	aRwClassModificationForcingNewClassVersion isModification
		ifTrue: [ 
			RwGsClassVersioningPatchV2
				addPatchedClassModificationForcingNewClassVersion:
					aRwClassModificationForcingNewClassVersion
				inPackage: aPackage
				inProject: aProjectDefinition
				toPatchSet: self ]
%

category: 'building'
method: RwGsPatchSet_V2
addMethodMove: aRwMethodMove

	movedMethods add: aRwMethodMove
%

category: 'building'
method: RwGsPatchSet_V2
addMovedPackage: packageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	movedPackages
		add:
			((self _packageMovePatchClass for: packageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPackageMove: anRwPackageMove

	movedPackages add: anRwPackageMove
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedClassClassVariables: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithClassVariableChanges
		add:
			((self _classVariablePatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedClassConstraints: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithConstraintChanges
		add:
			((self _classConstraintPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			((self _methodSourcePatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedClassMethodProperties: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			((self _methodPropertiesPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedClassNewVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition
	currentProjectDefinition := aProjectDefinition.

	classesWithNewVersions
		add:
			(((aClassModification classVersioningPatchClassUsing: self)
				for: aClassModification
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedClassProperties: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithPropertyChanges
		add:
			((self _classPropertiesPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedClassSymbolDictionaryMove: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithSymbolDictionaryChanges
		add:
			((self _classSymbolDictionaryMovePatchClass
				for: aClassModification
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			(((self _methodExtensionSourcePatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedExtendedClassMethodProperties: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			(((self _methodExtensionPropertiesPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedExtendedInstanceMethod: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			(((self _methodExtensionSourcePatchClass: aPackageDefinition key)
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedExtendedInstanceMethodProperties: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			(((self _methodExtensionPropertiesPatchClass: aPackageDefinition key)
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedInstanceMethod: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			((self _methodSourcePatchClass
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedInstanceMethodProperties: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			((self _methodPropertiesPatchClass
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_V2
addPatchedUnmanagedClassNewVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.

	classesWithNewVersions
		add:
			((self _classUnmanagedVersioningPatchClass
				for: aClassModification
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'private - applying'
method: RwGsPatchSet_V2
allPatchesAffectingLiveMethodsDo: liveMethodsBlock deletedMethodsDo: deletedMethodsBlock

	"Evaluate aBlock with every patch that can affect a method, traverse deletions separately."

	{addedMethods.
	extendedMethods.
	methodsNeedingRecompile} do: [ :patches | patches do: liveMethodsBlock ].
	deletedMethods do: deletedMethodsBlock
%

category: 'private - applying'
method: RwGsPatchSet_V2
anyElementOfCollection: aCollection
	"if aCollection is empty, answer nil. Otherwise, answer the first in enumeration order (which is unspecified for unordered collections)."

	aCollection do: [:each | ^each].
	^nil
%

category: 'public'
method: RwGsPatchSet_V2
apply

	"Apply the changes I represent to the running image."
	"UserGlobals at: #ConditionalHalt put: false"
 
(UserGlobals at: #ConditionalHalt ifAbsent: [ false ]) ifTrue: [ self halt ].
	self
		setupForApply;
		removeDeletedClassesFromTempSymbols;
		addAddedClassesToTempSymbols;
		recordCompiledForNewClassVersionDeletions;
		createNewClassesAndClassVersions;
		compileMethods.
	self reportAnyErrors
		ifTrue: [ ^ self ].	"No errors -- go ahead and install what's been compiled."
	self
		addAndUpdateLoadedProjects;
		addAndUpdateLoadedPackages;
		removeDeletedClassesFromSystem;
		"removeDeletedClassExtensionsFromSystem;" 
		installAddedClasses;
		movePackages;
		moveClassesBetweenSymbolDictionaries;
		installAddedClassExtensions;
		doMoveClassesBetweenPackages;
		doMoveMethodsBetweenPackages;
		updateSymbolAssociations;
		updateClassProperties;
		removeDeletedMethods;
		updateMethodDictionaries;
		updateMethodProperties;
		"removeDeletedClassesAndExtensionsFromPackages;"
		removeDeletedPackages;
		commit;
		runInitializers;
		commit;
		migrateInstances;
		commit
%

category: 'public'
method: RwGsPatchSet_V2
applyForNewClassVersions: anInstanceMigrator

	"ignore deleted methods when applying patches to new class version.
		all methods effectively deleted from class when the new class version is created, "

	| classNames |
	instanceMigrator := anInstanceMigrator.
	classNames := Set new.
	classesWithNewVersions
		do: [ :patch | classNames add: patch classDefinition key ].
	deletedMethods copy
		do: [ :patch | 
			(classNames includes: patch className)
				ifTrue: [ 
					deleteNewVersionMethods add: patch.
					deletedMethods remove: patch ] ].
	self apply
%

category: 'accessing'
method: RwGsPatchSet_V2
classesWithNewVersions

	^ classesWithNewVersions
%

category: 'private - applying'
method: RwGsPatchSet_V2
commit
	"I don't think I like the idea that we commit during a load ... the developer should always be in control of
		when a commit is performed ... automatic instance migration does do commits, however, it is a developer
		choice to do the commits ... if an error occurs after a commit is performed, I am concerned that the loaded 
		state of system will be corrupted ... "

	false ifTrue: [ System commit ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
compileMethodPatch: aMethodAdditionPatch
	aMethodAdditionPatch
		compileUsingNewClassesSymbolList: self createdClasses
		andExistingClasses: self tempSymbols
%

category: 'private - applying'
method: RwGsPatchSet_V2
compileMethods

	addedMethods do: [:each | self compileMethodPatch: each].
	extendedMethods do: [:each | self compileMethodPatch: each].
	methodsNeedingRecompile do: [:each | self compileMethodPatch: each]
%

category: 'private - applying'
method: RwGsPatchSet_V2
createClassesFromWorkSymbolList: workSymbolList symDictName: symDictName andClassesByNameSymbolList: newClassesByNameSymbolList
	"Pick one class or class version from the workList and create it, creating any superclasses or superclass versions that are to be created.
	Remove any classes created from the workList."

	| classNames className |
	classNames := (self class lookupSymbolDictName: symDictName in: workSymbolList)
		keys.
	classNames remove: symDictName.
	className := self anyElementOfCollection: classNames.
	className ifNil: [ self error: 'Empty WorkList.' ].
	self
		createClassNamed: className
		fromWorkSymbolList: workSymbolList
		symDictName: symDictName
		andClassesByNameSymbolList: newClassesByNameSymbolList
%

category: 'private - applying'
method: RwGsPatchSet_V2
createClassNamed: className fromWorkSymbolList: workSymbolList symDictName: symDictName andClassesByNameSymbolList: newClassesByNameSymbolList
	"Create the named class from the workList, creating any superclasses or superclass versions that are to be created.
	Remove any classes created from the workList."

	| patch superclassName |
	(self class lookupSymbolDictName: symDictName in: workSymbolList)
		removeKey: className asSymbol.
	patch := (self class
		lookupSymbolDictName: symDictName
		in: newClassesByNameSymbolList) at: className asSymbol.
	superclassName := patch superclassName asSymbol.
	(workSymbolList resolveSymbol: superclassName)
		ifNotNil: [ :superclassAssoc | 
			| ar |
			ar := self class resolveSymbolDictWith: superclassAssoc in: workSymbolList.
			ar size ~= 1
				ifTrue: [ 
					self
						error:
							'Internal error: more than one symbol dictionary with association for class '
								, superclassName printString ].
			self
				createClassNamed: superclassName
				fromWorkSymbolList: workSymbolList
				symDictName: (ar at: 1) name
				andClassesByNameSymbolList: newClassesByNameSymbolList ].
	patch createClassFor: self inSymDict: symDictName
%

category: 'patch access'
method: RwGsPatchSet_V2
createdClass: aClass
	| className |
	className := aClass name asSymbol.
	(createdClasses resolveSymbol: className)
		ifNil: [ createdClasses add: (SymbolAssociation newWithKey: className value: aClass) ]
		ifNotNil: [ :assoc | 
			assoc value == aClass
				ifFalse: [ 
					"new version created, update entry in createdClasses"
					createdClasses at: className put: aClass ] ]
%

category: 'patch access'
method: RwGsPatchSet_V2
createdClass: aClass inSymDict: symDictName
	| className symDict |
	className := aClass name.
	symDict := self class lookupSymbolDictName: symDictName in: self createdClasses.
	(symDict at: className ifAbsent: [  ])
		ifNil: [ symDict add: (SymbolAssociation newWithKey: className value: aClass) ]
		ifNotNil: [ :cl | 
			cl == aClass
				ifFalse: [ 
					"new version created, update entry in createdClasses"
					symDict at: className put: aClass ] ]
%

category: 'accessing'
method: RwGsPatchSet_V2
createdClasses
	^ createdClasses ifNil: [ createdClasses :=  self _createNewSymbolList ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
createNewClassesAndClassVersions
	"Who: Added classes and classes with new versions and classes with class variable changes
	   How: Create the new class or class version. Superclass by identity, not name resolution.
	   Order: Superclasses first.
	   Errors: Collect for reporting later"

	| newClassesByNameSymbolList workSymbolList |
	newClassesByNameSymbolList := self _createNewSymbolList.
	self addCreatedClassesAndVersionsToSymbolList: newClassesByNameSymbolList.
	workSymbolList := self _createNewSymbolList.
	newClassesByNameSymbolList
		do: [ :symDict | 
			| workList symDictName |
			symDictName := symDict name.
			workList := symDict keys.
			workList remove: symDictName.
			workList
				do: [ :className | 
					(self class lookupSymbolDictName: symDictName in: workSymbolList)
						at: className
						put: nil ] ].
	workSymbolList
		do: [ :symDict | 
			[ symDict keys size <= 1 ]
				whileFalse: [ 
					self
						createClassesFromWorkSymbolList: workSymbolList
						symDictName: symDict name
						andClassesByNameSymbolList: newClassesByNameSymbolList ] ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
doMoveClassesBetweenPackages
	| image |
	image := Rowan image.
	movedClasses
		do: [ :aClassMove | 
			| loadedClass pkgConvention |
			loadedClass := image loadedClassNamed: aClassMove classBefore name.
			pkgConvention := loadedClass loadedProject packageConvention.
			((pkgConvention = 'RowanHybrid' or: [ pkgConvention = 'Monticello' ])
				and: [ aClassMove packageBefore name ~= aClassMove packageAfter name ])
				ifTrue: [ 
					| newPackageName theClass |
					newPackageName := aClassMove packageAfter name.
					theClass := loadedClass handle.
					theClass
						methodsDo: [ :sel :meth | 
							meth rowanPackageName = newPackageName
								ifTrue: [ 
									self
										error:
											'The class ' , theClass name , ' has extension methods for the package '
												, newPackageName , ', so the class cannot be added to the package '
												, newPackageName
												,
													' without violating the restriction that extension category names must not match the class package name.' ] ].
					theClass class
						methodsDo: [ :sel :meth | 
							meth rowanPackageName = newPackageName
								ifTrue: [ 
									self
										error:
											'The class ' , theClass name , ' class has extension methods for the package '
												, newPackageName , ', so the class cannot be added to the package '
												, newPackageName
												,
													' without violating the restriction that extension category names must not match the class package name.' ] ] ].


			loadedClass loadedPackage removeLoadedClass: loadedClass.
			(image loadedPackageNamed: aClassMove packageAfter name)
				addLoadedClass: loadedClass ]
%

category: 'initialization'
method: RwGsPatchSet_V2
initialize
	addedPackages := Set new.
	addedProjects := Set new.
	deletedPackages := Set new.
	movedPackages := Set new.
	projectsWithPropertyChanges := Set new.
	deletedClasses := Set new.
	addedClasses := Set new.
	extendedClasses := Set new.
	classesWithNewVersions := Set new.
	classesWithClassVariableChanges := Set new.
	classesWithPropertyChanges := Set new.
	classesWithConstraintChanges := Set new.
	classesWithSymbolDictionaryChanges := Set new.
	movedClasses := Set new.
	deletedMethods := Set new.
	deleteNewVersionMethods := Set new.
	movedMethods := Set new.
	addedMethods := Set new.
	extendedMethods := Set new.
	methodsNeedingRecompile := Set new.
	methodsWithPropertyChanges := Set new.
	tempSymbols := SymbolDictionary new.
	createdClasses := Dictionary new.
	errors := Set new.
	createdClasses := nil.
	addedUnmanagedClasses := Set new
%

category: 'private - applying'
method: RwGsPatchSet_V2
installAddedClasses
	"Copy the name association from TempSymbols to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	addedClasses do: [:patch |  patch installClassInSystem ].
	addedUnmanagedClasses do: [ :patch | patch installClassInSystem ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
installAddedClassExtensions

	extendedClasses do: [ :each | each installClassExtensionInSystem: self loadSymbolList ]
%

category: 'accessing'
method: RwGsPatchSet_V2
instanceMigrator

	^ instanceMigrator
%

category: 'accessing'
method: RwGsPatchSet_V2
loadSymbolList
	^ loadSymbolList ifNil: [ Rowan image symbolList ]
%

category: 'accessing'
method: RwGsPatchSet_V2
loadSymbolList: aSymbolList
	loadSymbolList := aSymbolList
%

category: 'private - applying'
method: RwGsPatchSet_V2
migrateInstances

	"conditionally migrate instances of classes with new versions"

	| classSet |
	classSet := classesWithNewVersions collect: [ :patch | patch oldClassVersion ].
	classSet isEmpty
		ifTrue: [ ^ self ].
	instanceMigrator
		ifNil: [ 
			"if instanceMigrator is not set, then we are not ready to do instance migration on this pass"
			^ self ].
	instanceMigrator migrateInstancesOf: classSet asArray
%

category: 'private - applying'
method: RwGsPatchSet_V2
moveClassesBetweenSymbolDictionaries
	classesWithSymbolDictionaryChanges
		do: [ :patch | 
			| className |
			className := patch classDefinition name asSymbol.
			(self movedClassesSymbolList resolveSymbol: className)
				ifNil: [ patch installSymbolDictionaryPatchFor: self ]
				ifNotNil: [ :assoc | 
					| classMove |
					classMove := assoc value.
					patch installSymbolDictionaryPatchFor: self classMove: classMove ] ]
%

category: 'accessing'
method: RwGsPatchSet_V2
movedClassesSymbolList
	^ movedClassesSymbolList
		ifNil: [ movedClassesSymbolList := self _createNewSymbolList ]
%

category: 'accessing'
method: RwGsPatchSet_V2
movedMethods
	^ movedMethods
%

category: 'private - applying'
method: RwGsPatchSet_V2
movePackages
	movedPackages do: [ :each | each movePackage: classesWithNewVersions ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
recordCompiledForNewClassVersionDeletions
	deleteNewVersionMethods
		do: [ :each | 
			each
				primeBehaviorNewClassesSymbolList: self createdClasses
				andExistingClasses: self tempSymbols ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
removeDeletedClassesFromSystem
	"Remove the name binding from the SymbolDictionaries in the live SymbolList
        Remove the LoadedClass from its LoadedPackage"

	deletedClasses do: [:patch | patch deleteClassFromSystem ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
removeDeletedClassesFromTempSymbols
	"Deleted class names should not resolve during compilation."

	deletedClasses do: [:patch | tempSymbols removeKey: patch className asSymbol ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
removeDeletedMethods
	deletedMethods
		do: [ :methodDeletionPatch | 
			| className |
			className := methodDeletionPatch className.
			methodDeletionPatch
				deleteMethodNewClassesSymbolList: self createdClasses
				andExistingClasses: self tempSymbols ].
	deleteNewVersionMethods
		do: [ :methodDeletionPatch | 
			methodDeletionPatch
				deleteNewVersionMethodNewClassesSymbolList: self createdClasses
				andExistingClasses: self tempSymbols ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
removeDeletedPackages

	deletedPackages do: [:each | each deletePackage ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
reportAnyErrors
	"We're currently not collecting errors, but once we do, this will be the place they are reported.
	Answer true if errors detected (and exception resumed), false otherwise."

	^errors isEmpty
		ifFalse: 
			[self halt: 'Errors detected. Aborting application of patch.'.
			true]
		ifTrue: [false]
%

category: 'private - applying'
method: RwGsPatchSet_V2
runInitializers

	"run the class initialization methods as needed"

	| methodPatches orderedMethodPatches blackList |
	blackList := Rowan automaticClassInitializationBlackList.
	methodPatches := (addedMethods copy
		addAll: extendedMethods;
		addAll: methodsNeedingRecompile;
		yourself) select: [:each | each isAnInitializer ].
	methodPatches isEmpty ifTrue: [ ^ self ].
	orderedMethodPatches :=  (self class respondsTo: #methodPatchesInInitializationOrder:)
		ifTrue: [ self class methodPatchesInInitializationOrder: methodPatches ]
		ifFalse: [ methodPatches ].
	orderedMethodPatches do: [ :methodPatch | 
		(blackList includes: methodPatch projectDefinition name)
			ifFalse: [ 
				(RwExecuteClassInitializeMethodsAfterLoadNotification new
					candidateClass: methodPatch behavior thisClass) signal 
						ifTrue: [ methodPatch runInitializer ] ] ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
setupForApply

	"Copy the entire namespace from the user's transient SymbolList into a temporary SymbolDictionary in a temporary 
	SymbolList, the tempSymbols. The tempSymbols, once suitably modified, will be used as the environment in which 
	to compile methods during this apply operation."

	| symbolList |
	tempSymbols := SymbolDictionary new.
	symbolList := Rowan image symbolList.	
	"If there are any duplicated symbols, we only want the one that will be found first one, 
	so we copy in reverse order of search order, thereby overwriting later definitions with earlier ones."
	symbolList
		reverseDo: [ :dict | 
			"Need to preserve association identity, tempSymbols is used for compiling methods"
			dict associationsDo: [ :assoc | tempSymbols add: assoc ] ].

	self setupForMovedClasses
%

category: 'private - applying'
method: RwGsPatchSet_V2
setupForMovedClasses

	self _createMovedClasses
%

category: 'private - applying'
method: RwGsPatchSet_V2
setupForNewClassVersionUpdates

	self _createMovedClasses
%

category: 'patch access'
method: RwGsPatchSet_V2
superclassNamed: aName ifAbsent: absentBlock
	| superclassName |
	superclassName := aName asSymbol.
	^ (self createdClasses resolveSymbol: superclassName)
		ifNotNil: [ :assoc | assoc value ]
		ifNil: [ self tempSymbols at: superclassName ifAbsent: absentBlock ]
%

category: 'accessing'
method: RwGsPatchSet_V2
symbolDictionaryRegistryClass

	^ self _currentProjectDefinition
		ifNil: [ RwGsSymbolDictionaryRegistryV2 ]
		ifNotNil: [ :projectDefinition | projectDefinition symbolDictionaryRegistryClass ]
%

category: 'patch access'
method: RwGsPatchSet_V2
tempAssociationFor: aName
	^ self tempSymbols associationAt: aName
%

category: 'accessing'
method: RwGsPatchSet_V2
tempSymbols
	^ tempSymbols
%

category: 'private - applying'
method: RwGsPatchSet_V2
updateClassProperties
	"For classes with changes that don't require versioning, 
	update the properties in the class and the LoadedClasses as appropriate."

	| classPatches ts |
	ts := self tempSymbols.
	classPatches := OrderedCollection new.
	classPatches
		addAll:
				(self class
						classPatchesInReverseHierarchyOrder: classesWithClassVariableChanges
						tempSymbols: ts);
		addAll:
				(self class
						classPatchesInReverseHierarchyOrder: classesWithPropertyChanges
						tempSymbols: ts);
		addAll:
				(self class
						classPatchesInReverseHierarchyOrder: classesWithConstraintChanges
						tempSymbols: ts);
		yourself.
	classPatches
		do: [ :patch | 
			((self class
				lookupSymbolDictName: patch symbolDictionaryName
				in: self movedClassesSymbolList) at: patch className asSymbol ifAbsent: [  ])
				ifNil: [ patch installPropertiesPatchSymbolListFor: self ]
				ifNotNil: [ :aClassMove | patch installPropertiesPatchSymbolListFor: self classMove: aClassMove ] ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
updateMethodDictionaries
	"For added methods and methods that need recompiling,
	copy from temporary methodDictionaries to live methodDictionaries
	For added methods, create LoadedMethods and add to the appropriate LoadedClass
	or LoadedExtension
	For methods that need recompiling updated the LoadedMethods registration. "

	| movedClassesWithNewVersionMap movedExtensionMethodsMap emptyMap |
	movedClassesWithNewVersionMap := self _createNewSymbolList.
	emptyMap := true.
	classesWithNewVersions
		do: [ :patch | 
			((self class
				lookupSymbolDictName: patch symbolDictionaryName
				in: self movedClassesSymbolList) at: patch className asSymbol ifAbsent: [  ])
				ifNotNil: [ :aClassMove | 
					(self class
						lookupSymbolDictName: aClassMove symbolDictionaryNameAfter asSymbol
						in: movedClassesWithNewVersionMap)
						at: patch className asSymbol
						put:
							{aClassMove.
							patch}.
					emptyMap := false ] ].
	addedMethods
		do: [ :patch | 
			| className |
			className := patch className asSymbol.
			((self class
				lookupSymbolDictName: patch symbolDictionaryName
				in: movedClassesWithNewVersionMap) at: className ifAbsent: [  ])
				ifNil: [ patch installMethod ]
				ifNotNil: [ :ar | 
					"https://github.com/dalehenrich/Rowan/issues/316"
					patch installMovedMethod: (ar at: 1) newClassVersionPatch: (ar at: 2) ] ].
	emptyMap
		ifFalse: [ 
			"calculate moved extension methods map only if there are moved new class versions as well"
			movedExtensionMethodsMap := self _createNewSymbolList.
			movedMethods
				do: [ :aMethodMove | 
					| classExtDict key methodDict |
					classExtDict := (self class
						lookupSymbolDictName: aMethodMove symbolDictionaryNameAfter asSymbol
						in: movedExtensionMethodsMap)
						at: aMethodMove classOrExtensionBefore name asSymbol
						ifAbsentPut: [ Dictionary new ].
					key := aMethodMove isMeta
						ifTrue: [ 'class' ]
						ifFalse: [ 'instance' ].
					methodDict := classExtDict at: key ifAbsentPut: [ Dictionary new ].
					methodDict at: aMethodMove methodAfter selector put: aMethodMove ] ].
	extendedMethods
		do: [ :patch | 
			| className |
			className := patch className asSymbol.
			(movedClassesWithNewVersionMap resolveSymbol: className)
				ifNil: [ patch installMethod ]
				ifNotNil: [ :movedAssoc | 
					| ar classMove |
					"https://github.com/dalehenrich/Rowan/issues/316"
					ar := movedAssoc value.
					classMove := ar at: 1.
					((self class
						lookupSymbolDictName: classMove symbolDictionaryNameAfter
						in: movedExtensionMethodsMap) at: className ifAbsent: [  ])
						ifNil: [ patch installMethod ]
						ifNotNil: [ :assoc | 
							| classExtDict methodDict |
							classExtDict := assoc value.
							methodDict := patch isMeta
								ifTrue: [ classExtDict at: 'class' ifAbsent: [ Dictionary new ] ]
								ifFalse: [ classExtDict at: 'instance' ifAbsent: [ Dictionary new ] ].
							(methodDict at: patch methodDefinition selector ifAbsent: [  ])
								ifNil: [ patch installMethod ]
								ifNotNil: [ :aMethodMove | patch installMovedMethod: aMethodMove newClassVersionPatch: (ar at: 2) ] ] ] ].
	methodsNeedingRecompile do: [ :each | each installSourcePatch ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
updateMethodProperties
	methodsWithPropertyChanges
		do: [ :each | 
			each
				installPropertiesPatchNewClassesSymbolList: self createdClasses
				andExistingClasses: self tempSymbols ]
%

category: 'dispatching'
method: RwGsPatchSet_V2
updatePatchesForNewClassVersion: aClassVersioningPatch projectModification: aProjectSetModification
	aClassVersioningPatch
		updatePatchesForNewClassVersion: aProjectSetModification
			patchSetSymbolList: self;
		updateNewClassVersionPatchesForExtensionsIn: aProjectSetModification
			patchSet: self;
		updateNewClassVersionPatchesForSubclassesIn: aProjectSetModification
			patchSet: self
%

category: 'private - applying'
method: RwGsPatchSet_V2
updateSymbolAssociations
	"Install new class versions."

	classesWithNewVersions
		do: [ :each | 
			(self movedClassesSymbolList resolveSymbol: each className asSymbol)
				ifNil: [ each installNewClassVersionInSystem ]
				ifNotNil: [ :assoc | 
					| classMove |
					classMove := assoc value.
					each moveNewClassVersionInSystem: classMove ] ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_classAdditionPatchClass

	^ RwGsClassAdditionSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_classConstraintPatchClass

	^ RwGsClassConstraintsSymDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_classDeletionPatchClass

	^ RwGsClassDeletionSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_classExtensionPatchClass

	^ RwGsClassExtensionSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_classPropertiesPatchClass

	^ RwGsClassPropertiesSymDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_classSymbolDictionaryMovePatchClass

	^ RwGsClassSymbolDictionaryMoveSymDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_classUnmanagedAdditionPatchClass

	^ RwGsClassUnmanagedAdditionSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_classUnmanagedVersioningPatchClass

	^ RwGsClassUnmanagedVersioningSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_classVariablePatchClass

	^ RwGsClassVariableChangeSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_classVersioningPatchClass

	^ RwGsClassVersioningSymbolDictPatchV2
%

category: 'private - applying'
method: RwGsPatchSet_V2
_createMovedClasses
	movedClasses
		do: [ :movedClass | 
			| symDictName |
			symDictName := movedClass symbolDictionaryNameBefore asSymbol.
			( self class  lookupSymbolDictName: symDictName in: self movedClassesSymbolList)
				at: movedClass classBefore name asSymbol
				put: movedClass ]
%

category: 'private - applying'
method: RwGsPatchSet_V2
_createNewSymbolList
	| new |
	new := SymbolList new.
	self loadSymbolList
		do: [ :symDict | 
			| newSymDict |
			newSymDict := SymbolDictionary new
				name: symDict name;
				yourself.
			new addLast: newSymDict ].
	^ new
%

category: 'private - applying'
method: RwGsPatchSet_V2
_currentProjectDefinition
	^ currentProjectDefinition
		ifNil: [ 
			currentProjectDefinition := Rowan image
				loadedProjectNamed: Rowan unpackagedName
				ifAbsent: [ 
					"RwUnmanagedProjectDefinition may not be applicable in V2 system"
					(Rowan globalNamed: 'RwUnmanagedProjectDefinition') new ] ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_methodAdditionPatchClass

	^ RwGsMethodAdditionSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_methodDeletionPatchClass

	^ RwGsMethodDeletionSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_methodExtensionDeletionPatchClass: packageName

	^ (self _currentProjectDefinition
		useSessionMethodsForExtensionsForPackageNamed: packageName)
			ifTrue: [ RwGsMethodDeletionExtensionSessionMethodSymbolDictPatchV2 ]
			ifFalse: [ RwGsMethodDeletionExtensionSymbolDictPatchV2 ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_methodExtensionPatchClass: packageName

	^ (self _currentProjectDefinition
		useSessionMethodsForExtensionsForPackageNamed: packageName)
			ifTrue: [ RwGsMethodExtensionSessionMethodSymbolDictPatchV2 ]
			ifFalse: [ RwGsMethodExtensionSymbolDictPatchV2 ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_methodExtensionPropertiesPatchClass:  packageName

	^ (self _currentProjectDefinition
			useSessionMethodsForExtensionsForPackageNamed: packageName)
				ifTrue: [ RwGsMethodExtensionSessionMethodPropertiesSymDictPatchV2 ]
				ifFalse: [ RwGsMethodPropertiesSymDictPatchV2 ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_methodExtensionSourcePatchClass: packageName

	^ (self _currentProjectDefinition
			useSessionMethodsForExtensionsForPackageNamed: packageName)
				ifTrue: [ RwGsMethodExtensionSessionMethodSourceSymbolDictPatchV2 ]
				ifFalse: [ RwGsMethodSourceSymbolDictPatchV2 ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_methodPropertiesPatchClass

	^ RwGsMethodPropertiesSymDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_methodSourcePatchClass

	^ RwGsMethodSourceSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_packageAdditionPatchClass

	^ RwGsPackageAdditionSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_packageDeletionPatchClass

	^ RwGsPackageDeletionSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_packageMovePatchClass

	^ RwGsPackageMoveSymbolDictPatchV2
%

category: 'private - patch class accessors'
method: RwGsPatchSet_V2
_projectAdditionPatchClass

	^ RwGsProjectAdditionPatchV2
%

! Class implementation for 'RwGsPatchV2'

!		Instance methods for 'RwGsPatchV2'

category: 'accessing'
method: RwGsPatchV2
packageDefinition
	^packageDefinition
%

category: 'accessing'
method: RwGsPatchV2
packageDefinition: newValue
	packageDefinition := newValue
%

category: 'accessing'
method: RwGsPatchV2
packageName

	^packageDefinition key
%

category: 'accessing'
method: RwGsPatchV2
projectDefinition
	^ projectDefinition
		ifNil: [ 
			"RwUnmanagedProjectDefinition may not be applicable in V2 system"
			(Rowan globalNamed: 'RwUnmanagedProjectDefinition') new ]
%

category: 'accessing'
method: RwGsPatchV2
projectDefinition: newValue
	projectDefinition := newValue
%

category: 'accessing'
method: RwGsPatchV2
projectName

	^projectDefinition key
%

category: 'utility'
method: RwGsPatchV2
resolveName: aName

	"Answer a SymbolAssociation for the given name."

	^ Rowan image resolveName: aName
%

category: 'accessing'
method: RwGsPatchV2
symbolDictionary

	^ self symbolDictionaryFor: self packageName
%

category: 'accessing'
method: RwGsPatchV2
symbolDictionaryFor: aPackageName

	^ self symbolDictionaryFor: aPackageName projectDefinition: self projectDefinition
%

category: 'accessing'
method: RwGsPatchV2
symbolDictionaryFor: aPackageName projectDefinition: aProjectDefinition
	| symDictName |
	symDictName := aProjectDefinition symbolDictNameForPackageNamed: aPackageName.
	^ Rowan image newOrExistingSymbolDictionaryNamed: symDictName
%

category: 'accessing'
method: RwGsPatchV2
symbolDictionaryName
	"Need to create the symbol dictionary at this point, if it doesn't already exist"

	| symDictName |
	symDictName := (self projectDefinition
		symbolDictNameForPackageNamed: self packageName) asSymbol.
	Rowan image newOrExistingSymbolDictionaryNamed: symDictName.
	^ symDictName
%

category: 'accessing'
method: RwGsPatchV2
symbolDictionaryRegistry

	^ self symbolDictionary rowanSymbolDictionaryRegistry
%

! Class implementation for 'RwGsClassPatchV2'

!		Class methods for 'RwGsClassPatchV2'

category: 'instance creation'
classmethod: RwGsClassPatchV2
for: aClassDefinition inPackage: aPackageDefinition

	^(self new)
		classDefinition: aClassDefinition;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassPatchV2'

category: 'actions'
method: RwGsClassPatchV2
addToNewClassesByNameSymbolList: newClassesByNameSymbolList
	"Dictionary is class name -> classAdditionPatch. Error on duplicate name."

	| name symDict symDictName |
	name := classDefinition key asSymbol.
	name ifNil: [ self error: 'Class definition with no name.' ].
	symDictName := self symbolDictionaryName.
	symDict := RwGsPatchSet_V2
		lookupSymbolDictName: symDictName
		in: newClassesByNameSymbolList
		ifAbsent: [ 
			self
				error:
					'SymbolDictionary named ' , symDictName printString
						, ' not found in new classes symbol list' ].
	(symDict includesKey: name)
		ifTrue: [ 
			self
				error:
					'Duplicate new class name ' , name printString , ' in symbol dictionary '
						, symDictName printString ].
	symDict at: name put: self
%

category: 'private'
method: RwGsClassPatchV2
basicCreateClassWithSuperclass: superclass
	"For GemStone, the valid values are:
	byteSubclass
	variable
	normal for non-indexable pointer object"

	"Must be in-synch with RwGsLoadedClass>>updateClassTypeFromClass"

	| type oldVersion createdClass gs_options oldConstraints |
	type := classDefinition classType.
	oldVersion := self oldClassVersion.
	oldConstraints := oldVersion
		ifNil: [ #() ]
		ifNotNil: [ oldVersion _rwSortedConstraints ].
	gs_options := classDefinition gs_options collect: [ :each | each asSymbol ].
	(SessionTemps current at: #'ROWAN_TRACE' otherwise: nil)
		ifNotNil: [ gs_options add: #'logCreation' ].
	createdClass := (type = 'normal' or: [ type = 'immediate' ])
		ifTrue: [ 
			superclass
				subclass: classDefinition key
				instVarNames: (classDefinition propertyAt: 'instvars')
				classVars: (classDefinition propertyAt: 'classvars')
				classInstVars: (classDefinition propertyAt: 'classinstvars')
				poolDictionaries: (classDefinition propertyAt: 'pools')
				inDictionary: nil
				newVersionOf: oldVersion
				description: (classDefinition propertyAt: 'comment' ifAbsent: [  ])
				constraints: oldConstraints
				options: gs_options ]
		ifFalse: [ 
			type = 'variable'
				ifTrue: [ 
					superclass
						indexableSubclass: classDefinition key
						instVarNames: (classDefinition propertyAt: 'instvars')
						classVars: (classDefinition propertyAt: 'classvars')
						classInstVars: (classDefinition propertyAt: 'classinstvars')
						poolDictionaries: (classDefinition propertyAt: 'pools')
						inDictionary: nil
						newVersionOf: oldVersion
						description: (classDefinition propertyAt: 'comment' ifAbsent: [  ])
						constraints: oldConstraints
						options: gs_options ]
				ifFalse: [ 
					type = 'byteSubclass'
						ifTrue: [ 
							(classDefinition propertyAt: 'instvars') isEmpty
								ifFalse: [ self error: 'Cannot define byte class with named instvars.' ].
							superclass
								byteSubclass: classDefinition key
								classVars: (classDefinition propertyAt: 'classvars')
								classInstVars: (classDefinition propertyAt: 'classinstvars')
								poolDictionaries: (classDefinition propertyAt: 'pools')
								inDictionary: nil
								newVersionOf: oldVersion
								description: (classDefinition propertyAt: 'comment' ifAbsent: [  ])
								options: gs_options ]
						ifFalse: [ self error: 'Unknown class type' ] ] ].
	^ createdClass
%

category: 'accessing'
method: RwGsClassPatchV2
classDefinition
	^classDefinition
%

category: 'accessing'
method: RwGsClassPatchV2
classDefinition: newValue
	classDefinition := newValue .
%

category: 'accessing'
method: RwGsClassPatchV2
className

	^classDefinition key
%

category: 'actions'
method: RwGsClassPatchV2
createClassFor: aPatchSet
	| createdClass |
	createdClass := self privateCreateClassFor: aPatchSet.
	aPatchSet createdClass: createdClass.
	^ createdClass
%

category: 'actions'
method: RwGsClassPatchV2
createClassFor: aPatchSet inSymDict: symDictName
	| createdClass |
	createdClass := self privateCreateClassFor: aPatchSet inSymDict: symDictName.
	aPatchSet createdClass: createdClass inSymDict: symDictName.
	^ createdClass
%

category: 'installing'
method: RwGsClassPatchV2
installPropertiesPatchSymbolListFor: aPatchSet_symbolList

	self installPropertiesPatchSymbolListFor: aPatchSet_symbolList registry: self symbolDictionaryRegistry
%

category: 'patching moved classes'
method: RwGsClassPatchV2
installPropertiesPatchSymbolListFor: aPatchSet classMove: aClassMove

	| theRegistry |
	theRegistry := (self symbolDictionaryFor: aClassMove packageAfter name projectDefinition: aClassMove projectAfter)
		rowanSymbolDictionaryRegistry.
	self installPropertiesPatchSymbolListFor: aPatchSet registry: theRegistry
%

category: 'versioning'
method: RwGsClassPatchV2
oldClassVersion
	"The old version is what is currently bound to the class definition's name."

	^ (self resolveName: classDefinition key) value
%

category: 'Formatting'
method: RwGsClassPatchV2
printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: '(', classDefinition name, ')'
%

category: 'private'
method: RwGsClassPatchV2
privateCreateClassFor: aPatchSet
	| superclass |
	superclass := aPatchSet 
		superclassNamed: classDefinition superclassName 
		ifAbsent: [
			"https://github.com/GemTalk/Rowan/issues/471"
			"if we can't look up the class, try accessing the superclass from the class itself"
			(aPatchSet tempSymbols 
				at: classDefinition name asSymbol
				ifAbsent: [ self error: 'Class not found ', classDefinition className printString ]) superClass ].
	superclass
		ifNil: [ 
			classDefinition superclassName = 'nil'
				ifFalse: [ 
					self
						error:
							'The class named ' , classDefinition superclassName printString
								, ' does not exist.' ] ].
	^ self privateCreateClassWithSuperclass: superclass
%

category: 'private'
method: RwGsClassPatchV2
privateCreateClassFor: aPatchSet inSymDict: symDictName

	| superclass |
	superclass := aPatchSet 
		superclassNamed: classDefinition superclassName 
		ifAbsent: [
			"https://github.com/GemTalk/Rowan/issues/471"
			"if we can't look up the class, try accessing the superclass from the class itself"
			(aPatchSet tempSymbols 
				at: classDefinition name asSymbol
				ifAbsent: [ self error: 'Class not found ', classDefinition name printString ]) superClass ].
	superclass
		ifNil: [ 
			classDefinition superclassName = 'nil'
				ifFalse: [ 
					self
						error:
							'The class named ' , classDefinition superclassName printString
								, ' does not exist.' ] ].
	^ self privateCreateClassWithSuperclass: superclass
%

category: 'private'
method: RwGsClassPatchV2
privateCreateClassWithSuperclass: superclass

	| classProperties infoSource category createdClass |
	createdClass := self basicCreateClassWithSuperclass: superclass.
	classProperties := classDefinition properties.
	infoSource := Rowan configuration packageInfoSource.
	category := infoSource == #'Category'
		ifTrue: [ self packageName ]
		ifFalse: [ classProperties at: 'category' ifAbsent: [  ] ].
	createdClass _category: category.
	^ createdClass
%

category: 'accessing'
method: RwGsClassPatchV2
superclassName

	^classDefinition superclassName
%

category: 'private'
method: RwGsClassPatchV2
_classFormat: fmt forSubclassType: classType
	"Legal types are normal, variable, immediate, and byteSubclass."

	"These values need to be moved into Class"

	^ classType = 'normal'
		ifTrue: [ fmt ]
		ifFalse: [ 
			classType = 'variable'
				ifTrue: [ fmt bitOr: 16r4	"add indexable bit" ]
				ifFalse: [ 
					classType = 'byteSubclass'
						ifTrue: [ (fmt bitAnd: 16r3 bitInvert) bitOr: 16r1 + 16r4 ]
						ifFalse: [ 
							classType = 'immediate'
								ifTrue: [ 
									"selfCanBeSpecial"
									fmt bitOr: 16r2000 ]
								ifFalse: [ self error: 'Unknown class type' ] ] ] ]
%

category: 'private'
method: RwGsClassPatchV2
_gemStoneConstraintsFrom:	gs_constraints
	"reify the constraints array converting to references to instvar names and classes"

	(gs_constraints isKindOf: Array)
		ifTrue: [ 
			gs_constraints isEmpty
				ifTrue: [^ #() ]
				ifFalse: [
					| theConstraints |
					 theConstraints := {}.
					gs_constraints do: [ :ar | 
						(ar isKindOf: Array)
							ifTrue: [ theConstraints add: { (ar at: 1) asSymbol . Rowan globalNamed: (ar at: 2) } ]
							ifFalse: [ theConstraints add: (Rowan globalNamed: ar) ] ].
					^ theConstraints ] ]
		ifFalse: [ ^ Rowan globalNamed: gs_constraints ].
%

! Class implementation for 'RwGsClassAdditionSymbolDictPatchV2'

!		Instance methods for 'RwGsClassAdditionSymbolDictPatchV2'

category: 'actions'
method: RwGsClassAdditionSymbolDictPatchV2
createClassFor: aPatchSet
	newClass := super createClassFor: aPatchSet.
	symbolAssociation := aPatchSet tempAssociationFor: newClass name.
	^ newClass
%

category: 'actions'
method: RwGsClassAdditionSymbolDictPatchV2
createClassFor: aPatchSet inSymDict: symDictName
	newClass := super createClassFor: aPatchSet inSymDict: symDictName.
	symbolAssociation := aPatchSet tempAssociationFor: newClass name.
	^ newClass
%

category: 'actions'
method: RwGsClassAdditionSymbolDictPatchV2
installClassInSystem

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	| loadedClass |
	loadedClass := self symbolDictionaryRegistry
		addClassAssociation: symbolAssociation
		forClass: self newClass
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.
	loadedClass updatePropertiesFromClassDefinition: self classDefinition
%

category: 'accessing'
method: RwGsClassAdditionSymbolDictPatchV2
newClass
	^newClass
%

category: 'versioning'
method: RwGsClassAdditionSymbolDictPatchV2
oldClassVersion
	"We are adding a new class, so there is no old version."

	^nil
%

! Class implementation for 'RwGsClassUnmanagedAdditionSymbolDictPatchV2'

!		Instance methods for 'RwGsClassUnmanagedAdditionSymbolDictPatchV2'

category: 'actions'
method: RwGsClassUnmanagedAdditionSymbolDictPatchV2
createClassFor: aPatchSet
self error: 'probably shouldn''t be implemented or sent by this class'.
	newClass := super createClassFor: aPatchSet.
	symbolAssociation := aPatchSet tempAssociationFor: newClass name.
	^ newClass
%

category: 'actions'
method: RwGsClassUnmanagedAdditionSymbolDictPatchV2
installClassInSystem
	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	| loadedClass |
	[ 
	loadedClass := self symbolDictionaryRegistry
		addClassAssociation: symbolAssociation
		forClass: newClass
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2 ]
		on: RwExistingAssociationWithSameKeyNotification
		do: [ :ex | ex resume ].
	loadedClass updatePropertiesFromClassDefinition: self classDefinition
%

category: 'accessing'
method: RwGsClassUnmanagedAdditionSymbolDictPatchV2
oldClassVersion
	^oldClassVersion
%

category: 'accessing'
method: RwGsClassUnmanagedAdditionSymbolDictPatchV2
oldClassVersion: object
	oldClassVersion := object
%

! Class implementation for 'RwGsClassConstraintsSymDictPatchV2'

!		Instance methods for 'RwGsClassConstraintsSymDictPatchV2'

category: 'actions'
method: RwGsClassConstraintsSymDictPatchV2
addToNewClassesByNameSymbolList: newClassesByNameSymbolList
	"noop"
%

category: 'installing'
method: RwGsClassConstraintsSymDictPatchV2
installPropertiesPatchSymbolListFor: aPatchSet_symbolList

	self installPropertiesPatchSymbolListFor: aPatchSet_symbolList registry: self symbolDictionaryRegistry
%

category: 'installing'
method: RwGsClassConstraintsSymDictPatchV2
installPropertiesPatchSymbolListFor: aPatchSet registry: aSymbolDictionaryRegistry
	" update class and update loadedClass with new constraints"

	| className existingClass theConstraints existingConstraintsMap existingVaryingConstraint theConstraintsMap theVaryingConstraint keys existingConstraints instVarNames |
	className := classDefinition key asSymbol.
	existingClass := (aPatchSet class
		lookupSymbolDictName: self symbolDictionaryName
		in: aPatchSet createdClasses)
		at: className
		ifAbsent: [ 
			aPatchSet tempSymbols
				at: className
				ifAbsent: [ self error: 'Cannot find class to update constraints for.' ] ].
	existingConstraintsMap := Dictionary new.
	existingVaryingConstraint := existingClass _varyingConstraint.
	instVarNames := existingClass allInstVarNames.
	existingConstraints := [ existingClass _constraints ]
		on: Deprecated
		do: [ :ex | ex resume ].
	1 to: existingConstraints size do: [ :index | 
		existingConstraintsMap
			at: (instVarNames at: index)
			put: (existingConstraints at: index) ].
	theConstraints := self _gemStoneConstraintsFrom: classDefinition gs_constraints.
	theConstraintsMap := Dictionary new.
	theVaryingConstraint := Object.
	theConstraints
		do: [ :arrayOrVaryingConstraintClass | 
			arrayOrVaryingConstraintClass _isArray
				ifTrue: [ 
					theConstraintsMap
						at: (arrayOrVaryingConstraintClass at: 1)
						put: (arrayOrVaryingConstraintClass at: 2) ]
				ifFalse: [ theVaryingConstraint := arrayOrVaryingConstraintClass ] ].
	keys := existingConstraintsMap keys copy.
	keys addAll: theConstraintsMap keys.
	keys
		do: [ :key | 
			| existingConstraint theConstraint |
			existingConstraint := existingConstraintsMap at: key ifAbsent: [  ].
			theConstraint := theConstraintsMap at: key ifAbsent: [  ].
			existingConstraint == theConstraint
				ifFalse: [ 
					| instVarString |
					instVarString := key asString.
					existingConstraint == nil
						ifTrue: [ 
							"add theConstraint"
							existingClass _rwInstVar: instVarString constrainTo: theConstraint ]
						ifFalse: [ 
							theConstraint == nil
								ifTrue: [ 
									"remove the constraint"
									existingClass _rwInstVar: instVarString constrainTo: Object ]
								ifFalse: [ 
									"change the value of the constraint"
									existingClass _rwInstVar: instVarString constrainTo: theConstraint ] ] ] ].
	existingVaryingConstraint == theVaryingConstraint
		ifFalse: [ 
			"change the varying constraint"
			[ existingClass _setVaryingConstraint: theVaryingConstraint ]
				on: Deprecated
				do: [ :ex | ex resume ] ].
	aSymbolDictionaryRegistry
		updateClassProperties: existingClass
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

! Class implementation for 'RwGsClassDeletionSymbolDictPatchV2'

!		Class methods for 'RwGsClassDeletionSymbolDictPatchV2'

category: 'instance creation'
classmethod: RwGsClassDeletionSymbolDictPatchV2
for: aClassDefinition

	^self new classDefinition: aClassDefinition
%

!		Instance methods for 'RwGsClassDeletionSymbolDictPatchV2'

category: 'actions'
method: RwGsClassDeletionSymbolDictPatchV2
addToNewClassesByNameSymbolList: newClassesByNameSymbolList
	"noop"
%

category: 'deleting'
method: RwGsClassDeletionSymbolDictPatchV2
deleteClassFromSystem

	self symbolDictionaryRegistry deleteClassNamedFromPackage: self className implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

category: 'accessing'
method: RwGsClassDeletionSymbolDictPatchV2
symbolDictionary
	^ Rowan image symbolDictNamed: self symbolDictionaryName
%

category: 'accessing'
method: RwGsClassDeletionSymbolDictPatchV2
symbolDictionaryFor: aPackageName
	self error: 'no longer implemented'
%

category: 'accessing'
method: RwGsClassDeletionSymbolDictPatchV2
symbolDictionaryName
	"because this is a deletion, we can look up the symbol dictionariy directly"

	| className class | 
	className := self classDefinition name.
	class := Rowan globalNamed: className.
	Rowan image 
		loadedClassAndSymbolDicitonaryForClass: class 
		ifPresent: [:symDict :loadedClass | ^symDict  name]
		ifAbsent: [ self error: 'No symbol dictionary found for the class ', className printString ].
%

! Class implementation for 'RwGsClassExtensionSymbolDictPatchV2'

!		Instance methods for 'RwGsClassExtensionSymbolDictPatchV2'

category: 'actions'
method: RwGsClassExtensionSymbolDictPatchV2
installClassExtensionInSystem: aSymbolList
	"The class must already exist.
        Create or update the LoadedClassExtension for the extended class."

	(self projectDefinition
		useSessionMethodsForExtensionsForPackageNamed: self packageName)
		ifTrue: [ 
			| resolved |
			Rowan image ensureSessionMethodsEnabled.
			((resolved := aSymbolList objectNamed: self className asSymbol)
				notNil and: [ resolved isBehavior and: [ resolved isMeta not ] ])
				ifFalse: [ 
					self
						error:
							'The extension class named ' , self className printString , ' cannot be found.' ] ]
		ifFalse: [ 
			self symbolDictionaryRegistry
				ensureExtensionClassNamed: self className
				existsForPackageNamed: self packageName
				implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2 ]
%

! Class implementation for 'RwGsClassPropertiesSymDictPatchV2'

!		Instance methods for 'RwGsClassPropertiesSymDictPatchV2'

category: 'actions'
method: RwGsClassPropertiesSymDictPatchV2
addToNewClassesByNameSymbolList: newClassesByNameSymbolList
	"noop"
%

category: 'installing'
method: RwGsClassPropertiesSymDictPatchV2
installPropertiesPatchSymbolListFor: aPatchSet_symbolList

	self installPropertiesPatchSymbolListFor: aPatchSet_symbolList registry: self symbolDictionaryRegistry
%

category: 'installing'
method: RwGsClassPropertiesSymDictPatchV2
installPropertiesPatchSymbolListFor: aPatchSet registry: aSymbolDictionaryRegistry
	" update class and update loadedClass with new properties"

	| className existingClass createdClass symDict |
	className := classDefinition key asSymbol.
	symDict := aPatchSet class
		lookupSymbolDictName: self symbolDictionaryName
		in: aPatchSet createdClasses.
	existingClass := symDict
		at: className
		ifAbsent: [ 
			aPatchSet tempSymbols
				at: className
				ifAbsent: [ 
					"cannot find class ... caller can decide whether or not that is a problem"
					self error: 'Cannot find class to update properties for.' ] ].
	createdClass := self
		createClassFor: aPatchSet
		inSymDict: self symbolDictionaryName.	"use createClassFor:, but not expected to create new class version"
	createdClass == existingClass
		ifFalse: [ 
			self
				error:
					'internal error - class changed during class property update ... should have been a class versioning patch' ].
	aSymbolDictionaryRegistry
		updateClassProperties: existingClass
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

! Class implementation for 'RwGsClassSymbolDictionaryMoveSymDictPatchV2'

!		Class methods for 'RwGsClassSymbolDictionaryMoveSymDictPatchV2'

category: 'instance creation'
classmethod: RwGsClassSymbolDictionaryMoveSymDictPatchV2
for: aClassModification inPackage: aPackageDefinition

	^ self new
		classModification: aClassModification;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassSymbolDictionaryMoveSymDictPatchV2'

category: 'accessing'
method: RwGsClassSymbolDictionaryMoveSymDictPatchV2
classModification

	^classModification
%

category: 'accessing'
method: RwGsClassSymbolDictionaryMoveSymDictPatchV2
classModification: aClassModification

	classModification := aClassModification.
	classDefinition := classModification after
%

category: 'installing'
method: RwGsClassSymbolDictionaryMoveSymDictPatchV2
installSymbolDictionaryPatchFor: aPatchSet

	| before originalSymbolDictionary assoc newSymbolDictionary theClass registry loadedClass |
	theClass := Rowan globalNamed: classDefinition name.
	before := self classModification before.
	originalSymbolDictionary := Rowan globalNamed: before gs_symbolDictionary.
	assoc := originalSymbolDictionary associationAt: before key asSymbol.
	registry := originalSymbolDictionary rowanSymbolDictionaryRegistry.
	registry deleteClassNamedFromPackage: classDefinition name implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.
	newSymbolDictionary := Rowan image symbolDictNamed: (projectDefinition symbolDictNameForPackageNamed: packageDefinition name) .
	registry := newSymbolDictionary rowanSymbolDictionaryRegistry.
	loadedClass := registry 
		addClassAssociation: assoc 
			forClass: theClass 
			toPackageNamed: packageDefinition name
			implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.
	loadedClass updatePropertiesFromClassDefinition: self classDefinition
%

category: 'installing'
method: RwGsClassSymbolDictionaryMoveSymDictPatchV2
installSymbolDictionaryPatchFor: aPatchSet classMove: aClassMove

	RwGsSymbolDictionaryRegistry_ImplementationV2 moveClassFor: aClassMove
%

! Class implementation for 'RwGsClassVariableChangeSymbolDictPatchV2'

!		Instance methods for 'RwGsClassVariableChangeSymbolDictPatchV2'

category: 'actions'
method: RwGsClassVariableChangeSymbolDictPatchV2
createClassFor: aPatchSet

	"we're using createClassFor: to apply the class variable modifications. not expected to 
		create a new class version"

	| oldClassVersion newClassVersion |
	oldClassVersion := self oldClassVersion.
	newClassVersion := self privateCreateClassFor: aPatchSet.
	oldClassVersion == newClassVersion
		ifFalse: [ 
			self
				error:
					'internal error - unexpected new class version for class variable modification' ].
	^ oldClassVersion
%

category: 'installing'
method: RwGsClassVariableChangeSymbolDictPatchV2
installPropertiesPatchSymbolListFor: aPatchSet_symbolList

	self installPropertiesPatchSymbolListFor: aPatchSet_symbolList registry: self symbolDictionaryRegistry
%

category: 'installing'
method: RwGsClassVariableChangeSymbolDictPatchV2
installPropertiesPatchSymbolListFor: aPatchSet registry: aSymbolDictionaryRegistry
	" update class and update loadedClass with new properties"

	| className symDict existingClass |
	className := classDefinition key asSymbol.
	symDict := aPatchSet class
		lookupSymbolDictName: self symbolDictionaryName
		in: aPatchSet createdClasses.
	existingClass := symDict
		at: className
		ifAbsent: [ 
			aPatchSet tempSymbols
				at: className
				ifAbsent: [ 
					"cannot find class ... caller can decide whether or not that is a problem"
					self error: 'Cannot find class to update class variables for.' ] ].
	aSymbolDictionaryRegistry
		updateClassProperties: existingClass
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

! Class implementation for 'RwGsClassVersioningPatchV2'

!		Class methods for 'RwGsClassVersioningPatchV2'

category: 'patching'
classmethod: RwGsClassVersioningPatchV2
addPatchedClassModification: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet

	"Need to decide whether the patches in aClassModification warrant a new class version or 
	 simple property changes."

	^ self new
		addPatchedClassModification: aClassModification
		inPackage: aPackageDefinition
		inProject: aProjectDefinition
		toPatchSet: aRwGsPatchSet
%

category: 'patching'
classmethod: RwGsClassVersioningPatchV2
addPatchedClassModificationForcingNewClassVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet

	"Need to decide whether the patches in aClassModification warrant a new class version or 
	 simple property changes."

	^ self new
		addPatchedClassModificationForcingNewClassVersion: aClassModification
		inPackage: aPackageDefinition
		inProject: aProjectDefinition
		toPatchSet: aRwGsPatchSet
%

category: 'instance creation'
classmethod: RwGsClassVersioningPatchV2
for: aClassModification inPackage: aPackageDefinition

	^ self new
		classModification: aClassModification;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassVersioningPatchV2'

category: 'patching'
method: RwGsClassVersioningPatchV2
addPatchedClassModification: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet
	"Need to decide whether the patches in aClassModification warrant a new class version or 
	 simple property changes."

	| dict existingClass newFormat afterClassDefinition beforeClassDefinition newSuperclassAssoc afterSymDict beforeSymDict superclassFormat |
	packageDefinition := aPackageDefinition.
	projectDefinition := aProjectDefinition.
	afterClassDefinition := aClassModification after.
	beforeClassDefinition := aClassModification before.
	(newSuperclassAssoc := self resolveName: afterClassDefinition superclassName)
		ifNil: [ 
			"new superclass does not currently exist ... so it will be a new class, which means a new class version, guaranteed"
			aRwGsPatchSet
				addPatchedClassNewVersion: aClassModification
				inPackage: aPackageDefinition
				inProject: aProjectDefinition.
			^ self ].
	dict := Rowan image symbolDictNamed: beforeClassDefinition gs_symbolDictionary.
	existingClass := dict
		at: beforeClassDefinition name asSymbol
		ifAbsent: [ self error: 'Internal error. Attempt to modify a class whose name is not bound.' ].
	superclassFormat := existingClass superclass
		ifNil: [ Object format ]
		ifNotNil: [ :superClass | superClass format ].
	newFormat := self
		_classFormat: superclassFormat
		forSubclassType: afterClassDefinition classType.
	afterSymDict := self symbolDictionary name asString.
	beforeSymDict := beforeClassDefinition gs_symbolDictionary.
	beforeSymDict ~= afterSymDict
		ifTrue: [ 
			aRwGsPatchSet
				addPatchedClassSymbolDictionaryMove: aClassModification
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ].
	self
		_newSubclassWithSuperclass: newSuperclassAssoc value
		isEquivalentToSubclass: existingClass
		newOpts: (afterClassDefinition gs_options collect: [ :each | each asSymbol ])
		newFormat: newFormat
		newInstVars: afterClassDefinition instVarNames
		newClassInstVars: afterClassDefinition classInstVarNames
		newPools: afterClassDefinition poolDictionaryNames
		newClassVars: afterClassDefinition classVarNames
		newConstraints:
			(self _gemStoneConstraintsFrom: afterClassDefinition gs_constraints)
		patchedClassProperties: [ 
			aClassModification propertiesModification isEmpty
				ifFalse: [ 
					aRwGsPatchSet
						addPatchedClassProperties: afterClassDefinition
						inPackage: aPackageDefinition
						inProject: aProjectDefinition ] ]
		patchedConstraints: [ 
			aRwGsPatchSet
				addPatchedClassConstraints: afterClassDefinition
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ]
		patchedClassVars: [ 
			aRwGsPatchSet
				addPatchedClassClassVariables: afterClassDefinition
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ]
		patchedClassNewVersions: [ 
			aRwGsPatchSet
				addPatchedClassNewVersion: aClassModification
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ]
%

category: 'patching'
method: RwGsClassVersioningPatchV2
addPatchedClassModificationForcingNewClassVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet
	"Uncontitionally create a new class version"

	| dict existingClass beforeClassDefinition afterSymDict beforeSymDict |
	packageDefinition := aPackageDefinition.
	projectDefinition := aProjectDefinition.
	beforeClassDefinition := aClassModification before.
	dict := aRwGsPatchSet loadSymbolList
		objectNamed: beforeClassDefinition gs_symbolDictionary.
	existingClass := dict
		at: beforeClassDefinition name asSymbol
		ifAbsent: [ self error: 'Internal error. Attempt to modify a class whose name is not bound.' ].
	aRwGsPatchSet
		addPatchedClassNewVersion: aClassModification
		inPackage: aPackageDefinition
		inProject: aProjectDefinition.
	afterSymDict := self symbolDictionary name asString.
	beforeSymDict := beforeClassDefinition gs_symbolDictionary.
	beforeSymDict ~= afterSymDict
		ifTrue: [ 
			aRwGsPatchSet
				addPatchedClassSymbolDictionaryMove: aClassModification
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ]
%

category: 'accessing'
method: RwGsClassVersioningPatchV2
classModification: aClassModification

	classModification := aClassModification.
	classDefinition := classModification after
%

category: 'actions'
method: RwGsClassVersioningPatchV2
createClassFor: aPatchSet
	"we're using createClassFor: to apply the class modifications to the existing class
	oldClassVersion and produce a new class version"

	oldClassVersion := self oldClassVersion.
	newClassVersion := super createClassFor: aPatchSet.
	symbolAssociation := self resolveName: newClassVersion name.
	^ newClassVersion
%

category: 'accessing'
method: RwGsClassVersioningPatchV2
oldClassDefinition

	^ classModification before
%

category: 'versioning'
method: RwGsClassVersioningPatchV2
oldClassVersion

	"The old version is what is currently bound to the old class definition's name."

	^ (self resolveName: self oldClassDefinition key) value
%

category: 'private'
method: RwGsClassVersioningPatchV2
_newSubclassWithSuperclass: newSuperclass isEquivalentToSubclass: oldClass 
newOpts: optionsArray newFormat: theFormat newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars 
newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars newConstraints: aConstraint
patchedClassProperties: patchedClassPropertiesBlock 
patchedConstraints: patchedConstraintsBlock 
patchedClassVars: patchedClassVarsBlock 
patchedClassNewVersions: patchedClassNewVersionsBlock

	" based on Class>>_equivalentSubclass:superCls:name:newOpts:newFormat:newInstVars:newClassInstVars:newPools:newClassVars:inDict:isKernel: and ultimately needs to be rolled back into base, so that class creation and Rowan use the same new class version rules.
"

	"Class>>_equivalentSubclass:... has unwanted side effects"

	"squeezed down to the bare minimum"

	"oldClass is equivalent to the subclass that would be created using
 the other arguments if 
     instVar names match exactly ,
   and class instVar names match exactly ,
   and the classVars in oldClass can be modified to add/remove Associations 
     to match anArrayOfClassVars ,
   and pool dictionaries match exactly

  With respect to options and format, oldClass is equivalent if
    The state of format bits dbTransient, instancesNonPersistent, instancesInvariant  
     match exactly ,
    and subclassesDisallowed cannot be set in the new subclass if it not set in oldClass ,
    and modifiable  cannot be set if it is not set in oldClass  ,
    and  (SELF_CAN_BE_SPECIAL, NSC_DUPLICATES, INDEXABLE, IMPLEMENTATION, NO_STRUCT_UPDATE bits)
        of the formats must match exactly.
"

	| supr opts ivs civs poolds cvars cons cvarsPatched |
	cvarsPatched := (anArrayOfClassVars asSortedCollection = (oldClass classVarNames collect: [:each | each asString ]) asSortedCollection) not.
	self
		_newSubclassWithSuperclass: newSuperclass
		isEquivalentToSubclass: oldClass
		newOpts: optionsArray
		newFormat: theFormat
		newInstVars: anArrayOfInstvarNames
		newClassInstVars: anArrayOfClassInstVars
		newPools: anArrayOfPoolDicts
		newClassVars: anArrayOfClassVars
		newConstraints: aConstraint
		suprBlock: [ :bool | supr := bool not ]
		optsBlock: [ :arg | "arg is true or a String" opts := arg ~~ true  ]
		ivsBlock: [ :bool | ivs := bool not ]
		civsBlock: [ :bool | civs := bool not ]
		poolsBlock: [ :bool | poolds := bool not ]
		cvarsBlock: [ :bool | cvars := bool not ]
		consBlock:  [ :bool | cons := bool not ].
	(supr or: [ opts or: [ ivs or: [ civs or: [ poolds or: [cvars ] ] ] ] ])
		ifTrue: [ 
			"new class version means that class vars will be patched (for free) before methods compiled"
			patchedClassNewVersionsBlock value.
			^ self ].
	cvarsPatched
		ifTrue: [ 
			"have to patch class variables BEFORE methods are compiled"
			patchedClassVarsBlock value ].
	cons
		ifTrue: [
			"constraint changes are added in separate step after all classes have been created"
			patchedConstraintsBlock value ].
	"class property changes that do not affect method compilation"
	patchedClassPropertiesBlock value
%

category: 'private'
method: RwGsClassVersioningPatchV2
_newSubclassWithSuperclass: newSuperclass isEquivalentToSubclass: oldClass newOpts: optionsArray newFormat: theFormat newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars newConstraints: aConstraint suprBlock: suprBlock optsBlock: optsBlock ivsBlock: ivsBlock civsBlock: civsBlock poolsBlock: poolsBlock cvarsBlock: cvarsBlock consBlock: consBlock
	" based on Class>>_equivalentSubclass:superCls:name:newOpts:newFormat:newInstVars:newClassInstVars:newPools:newClassVars:inDict:isKernel: and ultimately needs to be rolled back into base, so that class creation and Rowan use the same new class version rules.
"

	"Class>>_equivalentSubclass:... has unwanted side effects"

	"squeezed down to the bare minimum"

	"oldClass is equivalent to the subclass that would be created using
 the other arguments if 
     instVar names match exactly ,
   and class instVar names match exactly ,
   and the classVars in oldClass can be modified to add/remove Associations 
     to match anArrayOfClassVars ,
   and pool dictionaries match exactly

  With respect to options and format, oldClass is equivalent if
    The state of format bits dbTransient, instancesNonPersistent, instancesInvariant  
     match exactly ,
    and subclassesDisallowed cannot be set in the new subclass if it not set in oldClass ,
    and modifiable  cannot be set if it is not set in oldClass  ,
    and  (SELF_CAN_BE_SPECIAL, NSC_DUPLICATES, INDEXABLE, IMPLEMENTATION, NO_STRUCT_UPDATE bits)
        of the formats must match exactly.
"

	| fmtArr |
	fmtArr := newSuperclass
		ifNil: [ 
			Object
				_validateOptions: optionsArray
				withFormat: theFormat
				newClassName: oldClass name asString ]
		ifNotNil: [ 
			newSuperclass
				_validateOptions: optionsArray
				withFormat: theFormat
				newClassName: oldClass name asString ].
	(oldClass isKindOf: Class)
		ifFalse: [ oldClass _validateClass: Class ].
	suprBlock value: oldClass superClass == newSuperclass.
	optsBlock value: (oldClass _optionsChangableTo: fmtArr) == true .
	ivsBlock value: (oldClass _instVarsEqual: anArrayOfInstvarNames).
	civsBlock value: (oldClass class _instVarsEqual: anArrayOfClassInstVars).
	poolsBlock value: (oldClass _poolDictsEqual: anArrayOfPoolDicts).
	cvarsBlock value: (oldClass _classVarsChangableTo: anArrayOfClassVars copy).
	consBlock
		value: (aConstraint size = 0 or: [ oldClass _constraintsEqual: aConstraint ])
%

! Class implementation for 'RwGsClassVersioningSymbolDictPatchV2'

!		Class methods for 'RwGsClassVersioningSymbolDictPatchV2'

category: 'instance creation'
classmethod: RwGsClassVersioningSymbolDictPatchV2
for: aClassModification inPackage: aPackageDefinition

	^ self new
		classModification: aClassModification;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassVersioningSymbolDictPatchV2'

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatchV2
classModification: aClassModification

	classModification := aClassModification.
	classDefinition := classModification after
%

category: 'actions'
method: RwGsClassVersioningSymbolDictPatchV2
createClassFor: aPatchSet

	"we're using createClassFor: to apply the class modifications to the existing class
	oldClassVersion and produce a new class version"

	oldClassVersion := self oldClassVersion.	"grab the class version BEFORE creating newClassVersion ...it may be needed later"
	newClassVersion := super createClassFor: aPatchSet.
	symbolAssociation := self resolveName: newClassVersion name.
	^ newClassVersion
%

category: 'actions'
method: RwGsClassVersioningSymbolDictPatchV2
createClassFor: aPatchSet inSymDict: symDictName
	"we're using createClassFor: to apply the class modifications to the existing class
	oldClassVersion and produce a new class version"

	oldClassVersion := self oldClassVersion.	"grab the class version BEFORE creating newClassVersion ...it may be needed later"
	newClassVersion := super createClassFor: aPatchSet inSymDict: symDictName.
	symbolAssociation := self resolveName: newClassVersion name.
	^ newClassVersion
%

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatchV2
existingSymbolDictionary
	"answer the current symbol dictionary for the class ... before being (potentially) moved to a different symbolDictionary"

	| symDictName |
	symDictName := classModification before gs_symbolDictionary.
	^ Rowan image newOrExistingSymbolDictionaryNamed: symDictName
%

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatchV2
existingSymbolDictionaryRegistry

	^ self existingSymbolDictionary rowanSymbolDictionaryRegistry
%

category: 'patching'
method: RwGsClassVersioningSymbolDictPatchV2
installNewClassVersionInSystem
	"Install the new class association in the symbolAssociation for the class.
	 Update the LoadedClass with properties for the new classversion."

	self symbolDictionaryRegistry
		addNewClassVersionToAssociation: newClassVersion
		oldClassVersion: oldClassVersion
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

category: 'patching'
method: RwGsClassVersioningSymbolDictPatchV2
moveNewClassVersionInSystem: aClassMove
	"Move the class association for the class.
	 Update the LoadedClass with properties for the new classversion."

	| theRegistry |
	theRegistry := (self
		symbolDictionaryFor: aClassMove packageAfter name
		projectDefinition: aClassMove projectAfter) rowanSymbolDictionaryRegistry.

	theRegistry
		addNewClassVersionToAssociation: newClassVersion
		oldClassVersion: oldClassVersion
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

category: 'versioning'
method: RwGsClassVersioningSymbolDictPatchV2
newClassVersion

	^ newClassVersion
%

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatchV2
oldClassDefinition

	^ classModification before
%

category: 'versioning'
method: RwGsClassVersioningSymbolDictPatchV2
oldClassVersion

	"The old version is what is currently bound to the old class definition's name."

	oldClassVersion ifNotNil: [ ^ oldClassVersion ].
	^ (self resolveName: self oldClassDefinition key) value
%

category: 'new version support'
method: RwGsClassVersioningSymbolDictPatchV2
updateNewClassVersionPatchesForExtensionsIn: aProjectSetModification patchSet: aPatchSet
	| className class |
	className := classDefinition name.
	class := self existingSymbolDictionary at: className asSymbol.
	self
		_updateNewClassVersionPatchesForClass: class
		in: aProjectSetModification
		patchSet: aPatchSet
%

category: 'new version support'
method: RwGsClassVersioningSymbolDictPatchV2
updateNewClassVersionPatchesForSubclassesIn: aProjectSetModification patchSet: patchSet

	| subclassesOfClassWithNewVersions existingClass classesWithNewVersions |
	existingClass := self oldClassVersion.
	subclassesOfClassWithNewVersions := IdentitySet new.
	subclassesOfClassWithNewVersions
		addAll: ((ClassOrganizer new allSubclassesOf: existingClass) reject: [:class | (Rowan image loadedClassForClass: class ifAbsent: []) isNil ]).
	classesWithNewVersions := patchSet classesWithNewVersions
		collect: [ :patch | patch oldClassVersion ].
	subclassesOfClassWithNewVersions removeAllPresent: classesWithNewVersions.
	subclassesOfClassWithNewVersions
		do: [ :subclass | 
			| loadedClass loadedPackage loadedProject loadedClassDefinition subclassName newVersionClassModification 
				projectModification packageModification classesModification classesModified |
			subclassName := subclass name asString.
			loadedClass := Rowan image loadedClassNamed: subclassName.
			loadedClassDefinition := loadedClass asDefinition.
			loadedPackage := loadedClass loadedPackage.
			loadedProject := loadedClass loadedProject.
			newVersionClassModification := loadedClassDefinition
				compareAgainstBaseForcingNewClassVersion: loadedClassDefinition.

			projectModification := aProjectSetModification elementsModified 
				at: loadedProject name 
				ifAbsentPut: [
					| def |
					"arrange for anew project modification to be added"
					def := loadedProject asDefinition.
					(RwProjectModification before: def after: def)
						propertiesModification: RwPropertiesModification new;
						packagesModification: RwPackagesModification new;
						yourself ].
			packageModification := projectModification packagesModification elementsModified 
					at: loadedPackage name 
					ifAbsentPut: [  
						| def |
						"arrange for a new package modification to be added"
						def := loadedPackage asDefinition.
						(RwPackageModification before: def after: def)
							classesModification: RwClassesModification new;
							classExtensionsModification: RwClassExtensionsModification new;
							yourself  ].
			classesModification := packageModification classesModification.
			classesModified := classesModification elementsModified.
			classesModification isEmpty
				ifTrue: [ 
					classesModified at: subclassName put: newVersionClassModification.
					newVersionClassModification
						mergeForNewClassVersionWith: newVersionClassModification ]
				ifFalse: [ 
					(classesModified at: subclassName ifAbsent: [  ])
						ifNil: [
							classesModified at: subclassName put: newVersionClassModification.
							newVersionClassModification
								mergeForNewClassVersionWith: newVersionClassModification ]
						ifNotNil: [ :existingClassModification | 
							existingClassModification isDeletion
								ifTrue: [ 
									"a deletion is not unexpected ... "
									]
								ifFalse: [
									newVersionClassModification mergeForExistingClassWith: existingClassModification.
									classesModified at: subclassName put: newVersionClassModification ] ] ] .
			self
				_updateNewClassVersionPatchesForClass: subclass
				in: aProjectSetModification
				patchSet: patchSet ]
%

category: 'new version support'
method: RwGsClassVersioningSymbolDictPatchV2
updatePatchesForNewClassVersion: aProjectSetModification patchSetSymbolList: patchSet
	| existingClass loadedClass loadedPackageName loadedClassDefinition newVersionClassModification existingClassName movedDeletedMap |
	movedDeletedMap := Dictionary new.
	(patchSet class
		lookupSymbolDictName: self symbolDictionaryName
		in: patchSet movedClassesSymbolList)
		keysAndValuesDo: [ :className :classMove | movedDeletedMap at: className put: classMove ].
	existingClass := self oldClassVersion.
	existingClassName := existingClass name asString.

	loadedClass := self existingSymbolDictionaryRegistry
		existingForClass: existingClass.
	loadedClassDefinition := loadedClass asDefinition.
	loadedPackageName := loadedClass loadedPackage name.

	newVersionClassModification := self classDefinition
		compareAgainstBaseForNewClassVersion: loadedClassDefinition.
	newVersionClassModification isEmpty
		ifFalse: [ 
			"only newVersionClassModification with substance need further processing"
			aProjectSetModification
				classesModificationAndPackageModificationAndProjectModificationDo: [ :classesModification :packageModification | 
					classesModification isEmpty
						ifFalse: [ 
							| classesModified |
							classesModified := classesModification elementsModified.
							(classesModified at: existingClassName ifAbsent: [  ])
								ifNil: [ 
									"not unexpected ... if there are multiple packages involved"
									 ]
								ifNotNil: [ :existingClassModification | 
									| deleteClassModification |
									deleteClassModification := false.
									(movedDeletedMap at: existingClassName ifAbsent: [  ])
										ifNotNil: [ :classMove | 
											deleteClassModification := classMove packageBefore name
												= packageModification after name ].
									deleteClassModification
										ifTrue: [ classesModified removeKey: existingClassName ]
										ifFalse: [ 
											newVersionClassModification mergeForExistingClassWith: existingClassModification.
											classesModified
												at: existingClassName
												put: newVersionClassModification ] ] ] ] ]
%

category: 'private'
method: RwGsClassVersioningSymbolDictPatchV2
_createMethodAdditionModificationForNewVersionOfClassNamed: className isMeta: isMeta methodMove: aMethodMove projectSetModification: aProjectSetModification
	| projectModification packageModification classesModification methodsModification methodDef source sourceModification modification afterMethodDef beforeMethodDef |
	projectModification := aProjectSetModification elementsModified
		at: aMethodMove projectAfter name
		ifAbsentPut: [ 
			| def |
			def := aMethodMove projectAfter.
			(RwProjectModification before: def after: def)
				propertiesModification: RwPropertiesModification new;
				packagesModification: RwPackagesModification new;
				yourself ].
	packageModification := projectModification packagesModification
		elementsModified
		at: aMethodMove packageAfter name
		ifAbsentPut: [ 
			| def |
			"arrange for a new package to be added"
			def := aMethodMove packageAfter.
			(RwPackageModification before: def after: def)
				classesModification: RwClassesModification new;
				classExtensionsModification: RwClassExtensionsModification new;
				yourself ].
	classesModification := packageModification classesModification elementsModified
		at: className
		ifAbsentPut: [ 
			| def |
			def := aMethodMove classOrExtensionAfter.
			(RwClassModification before: RwClassDefinition new after: def)
				instanceMethodsModification: RwMethodsModification new;
				classMethodsModification: RwMethodsModification new;
				yourself ].
	methodsModification := isMeta
		ifTrue: [ classesModification classMethodsModification elementsModified ]
		ifFalse: [ classesModification instanceMethodsModification elementsModified ].
	(methodsModification at: aMethodMove methodAfter selector ifAbsent: [  ])
		ifNil: [ 
			afterMethodDef := beforeMethodDef := methodDef := aMethodMove methodAfter.
			source := methodDef source.
			sourceModification := RwSourceModification new
				addElementModification:
						(RwUnconditionalPropertyModification
								key: 'source'
								oldValue: source
								newValue: source);
				yourself.
			modification := (RwMethodModificationForNewClassVersion
				before: beforeMethodDef
				after: afterMethodDef)
				isMeta: isMeta;
				classDefinition: aMethodMove classOrExtensionAfter;
				propertiesModification: RwPropertiesModification new;
				sourceModification: sourceModification;
				yourself ]
		ifNotNil: [ :theMethodModification | 
			modification := (RwMethodModificationForNewClassVersion
				before: theMethodModification before
				after: theMethodModification after)
				isMeta: isMeta;
				classDefinition: aMethodMove classOrExtensionAfter;
				propertiesModification: theMethodModification propertiesModification;
				sourceModification: theMethodModification sourceModification;
				yourself ].

	methodsModification at: aMethodMove methodAfter selector put: modification
%

category: 'private'
method: RwGsClassVersioningSymbolDictPatchV2
_createMethodExtensionModificationForNewVersionOfClassNamed: className isMeta: isMeta loadedMethod: loadedMethod projectSetModification: aProjectSetModification

	| loadedProject loadedPackage loadedClassExtension projectModification packageModification 
		classExtensionModification methodsModification methodDef source sourceModification modification
		afterMethodDef beforeMethodDef |
	loadedClassExtension := loadedMethod loadedClass.
	loadedPackage := loadedMethod loadedPackage.
	loadedProject := loadedMethod loadedProject.
	projectModification := aProjectSetModification elementsModified
		at: loadedProject name
		ifAbsentPut: [
			| def |
			def := loadedProject asDefinition.
			(RwProjectModification before: def after: def)
				propertiesModification: RwPropertiesModification new;
				packagesModification: RwPackagesModification new;
				yourself ].
	packageModification := projectModification packagesModification
		elementsModified
		at: loadedPackage name
		ifAbsentPut: [ 
			| def |
			"arrange for a new package to be added"
			def := loadedPackage asDefinition.
			(RwPackageModification before: def after: def)
				classesModification: RwClassesModification new;
				classExtensionsModification: RwClassExtensionsModification new;
				yourself ].
	classExtensionModification := packageModification classExtensionsModification
		elementsModified
		at: className
		ifAbsentPut: [ 
			| def |
			def := (loadedPackage loadedClassExtensions at: className) asDefinition.
			(RwClassExtensionModification
				before: RwClassExtensionDefinition new
				after: def)
				instanceMethodsModification:
						(RwExtensionMethodsModification extendedClassName: className);
				classMethodsModification:
						(RwExtensionMethodsModification extendedClassName: className);
				yourself ].
	methodsModification := isMeta
		ifTrue: [ classExtensionModification classMethodsModification elementsModified ]
		ifFalse: [ classExtensionModification instanceMethodsModification elementsModified ].
	(methodsModification at: loadedMethod selector ifAbsent: [  ])
		ifNil: [
			afterMethodDef := beforeMethodDef := methodDef := loadedMethod asDefinition.
			source := methodDef source.
			sourceModification := RwSourceModification new
				addElementModification:
						(RwUnconditionalPropertyModification
								key: 'source'
								oldValue: source
								newValue: source);
				yourself.
			modification := (RwExtensionMethodModificationForNewClassVersion
				before: beforeMethodDef
				after: afterMethodDef)
				isMeta: isMeta;
				classDefinition: loadedClassExtension asDefinition;
				propertiesModification: RwPropertiesModification new;
				sourceModification: sourceModification;
				yourself ]
		ifNotNil: [:theMethodModification |
			modification := (RwExtensionMethodModificationForNewClassVersion
				before: theMethodModification before
				after: theMethodModification after)
				isMeta: isMeta;
				classDefinition: loadedClassExtension asDefinition;
				propertiesModification: theMethodModification propertiesModification;
				sourceModification: theMethodModification sourceModification;
				yourself ].

	methodsModification at: loadedMethod selector put: modification
%

category: 'private'
method: RwGsClassVersioningSymbolDictPatchV2
_createMethodExtensionModificationForNewVersionOfClassNamed: className isMeta: isMeta methodMove: aMethodMove projectSetModification: aProjectSetModification
	| projectModification packageModification classExtensionModification methodsModification methodDef source sourceModification modification afterMethodDef beforeMethodDef |
	projectModification := aProjectSetModification elementsModified
		at: aMethodMove projectAfter name
		ifAbsentPut: [ 
			| def |
			def := aMethodMove projectAfter.
			(RwProjectModification before: def after: def)
				propertiesModification: RwPropertiesModification new;
				packagesModification: RwPackagesModification new;
				yourself ].
	packageModification := projectModification packagesModification
		elementsModified
		at: aMethodMove packageAfter name
		ifAbsentPut: [ 
			| def |
			"arrange for a new package to be added"
			def := aMethodMove packageAfter.
			(RwPackageModification before: def after: def)
				classesModification: RwClassesModification new;
				classExtensionsModification: RwClassExtensionsModification new;
				yourself ].
	classExtensionModification := packageModification classExtensionsModification
		elementsModified
		at: className
		ifAbsentPut: [ 
			| def |
			def := aMethodMove classOrExtensionAfter.
			(RwClassExtensionModification
				before: RwClassExtensionDefinition new
				after: def)
				instanceMethodsModification:
						(RwExtensionMethodsModification extendedClassName: className);
				classMethodsModification:
						(RwExtensionMethodsModification extendedClassName: className);
				yourself ].
	methodsModification := isMeta
		ifTrue: [ classExtensionModification classMethodsModification elementsModified ]
		ifFalse: [ classExtensionModification instanceMethodsModification elementsModified ].
	(methodsModification at: aMethodMove methodAfter selector ifAbsent: [  ])
		ifNil: [ 
			afterMethodDef := beforeMethodDef := methodDef := aMethodMove methodAfter.
			source := methodDef source.
			sourceModification := RwSourceModification new
				addElementModification:
						(RwUnconditionalPropertyModification
								key: 'source'
								oldValue: source
								newValue: source);
				yourself.
			modification := (RwExtensionMethodModificationForNewClassVersion
				before: beforeMethodDef
				after: afterMethodDef)
				isMeta: isMeta;
				classDefinition: aMethodMove classOrExtensionAfter;
				propertiesModification: RwPropertiesModification new;
				sourceModification: sourceModification;
				yourself ]
		ifNotNil: [ :theMethodModification | 
			modification := (RwExtensionMethodModificationForNewClassVersion
				before: theMethodModification before
				after: theMethodModification after)
				isMeta: isMeta;
				classDefinition: aMethodMove classOrExtensionAfter;
				propertiesModification: theMethodModification propertiesModification;
				sourceModification: theMethodModification sourceModification;
				yourself ].

	methodsModification at: aMethodMove methodAfter selector put: modification
%

category: 'private'
method: RwGsClassVersioningSymbolDictPatchV2
_createMethodModificationForNewVersionOfClassNamed: className methodMove: aMethodMove projectSetModification: aProjectSetModification
	aMethodMove classOrExtensionAfter isClassExtension
		ifTrue: [ 
			self
				_createMethodExtensionModificationForNewVersionOfClassNamed: className
				isMeta: aMethodMove isMeta
				methodMove: aMethodMove
				projectSetModification: aProjectSetModification ]
		ifFalse: [ 
			self
				_createMethodAdditionModificationForNewVersionOfClassNamed: className
				isMeta: aMethodMove isMeta
				methodMove: aMethodMove
				projectSetModification: aProjectSetModification ]
%

category: 'private'
method: RwGsClassVersioningSymbolDictPatchV2
_updateNewClassVersionPatchesForClass: class in: aProjectSetModification patchSet: aPatchSet
	| className extensionMap emptyDict |
	className := class name asString.
	extensionMap := Dictionary new.
	emptyDict := Dictionary new.
	(Rowan image loadedClassExtensionsForClass: class)
		do: [ :loadedClassExtension | 
			| dict |
			dict := extensionMap at: className ifAbsentPut: [ Dictionary new ].
			loadedClassExtension
				loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClass :loadedMethod | 
					(dict at: 'instance' ifAbsentPut: [ Dictionary new ])
						at: loadedMethod selector
						put: loadedMethod ]
				loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClass :loadedMethod | 
					(dict at: 'class' ifAbsentPut: [ Dictionary new ])
						at: loadedMethod selector
						put: loadedMethod ] ].
	extensionMap isEmpty
		ifTrue: [ ^ self ].

	aPatchSet movedMethods
		do: [ :aMethodMove | 
			| methodsDict selectorDict |
			methodsDict := extensionMap
				at: aMethodMove classOrExtensionAfter name
				ifAbsent: [ emptyDict ].

			selectorDict := aMethodMove isMeta
				ifTrue: [ methodsDict at: 'class' ifAbsent: [ emptyDict ] ]
				ifFalse: [ methodsDict at: 'instance' ifAbsent: [ emptyDict ] ].
			(selectorDict removeKey: aMethodMove methodAfter selector ifAbsent: [  ])
				ifNotNil: [ 
					"need to arrange to add the method back into the projectSetModification"
					self
						_createMethodModificationForNewVersionOfClassNamed: className
						methodMove: aMethodMove
						projectSetModification: aProjectSetModification ] ].

	aPatchSet
		allPatchesAffectingLiveMethodsDo: [ :patch | 
			"noop"
			 ]
		deletedMethodsDo: [ :patch | 
			| methodsDict selectorDict |
			methodsDict := extensionMap
				at: patch classDefinition name
				ifAbsent: [ emptyDict ].
			selectorDict := patch isMeta
				ifTrue: [ methodsDict at: 'class' ifAbsent: [ emptyDict ] ]
				ifFalse: [ methodsDict at: 'instance' ifAbsent: [ emptyDict ] ].
			selectorDict removeKey: patch methodDefinition selector ifAbsent: [  ] ].
	extensionMap
		valuesDo: [ :methodsDict | 
			(methodsDict at: 'instance' ifAbsent: [ emptyDict ])
				valuesDo: [ :loadedMethod | 
					self
						_createMethodExtensionModificationForNewVersionOfClassNamed: className
						isMeta: false
						loadedMethod: loadedMethod
						projectSetModification: aProjectSetModification ].
			(methodsDict at: 'class' ifAbsent: [ emptyDict ])
				valuesDo: [ :loadedMethod | 
					self
						_createMethodExtensionModificationForNewVersionOfClassNamed: className
						isMeta: true
						loadedMethod: loadedMethod
						projectSetModification: aProjectSetModification ] ]
%

! Class implementation for 'RwGsClassUnmanagedVersioningSymbolDictPatchV2'

!		Instance methods for 'RwGsClassUnmanagedVersioningSymbolDictPatchV2'

category: 'patching'
method: RwGsClassUnmanagedVersioningSymbolDictPatchV2
installNewClassVersionInSystem
	"Install the new class association in the symbolAssociation for the class.
	 Update the LoadedClass with properties for the new classversion."

	self symbolDictionaryRegistry
		addNewUnmanagedClassVersionToAssociation: newClassVersion
		oldClassVersion: oldClassVersion
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

category: 'new version support'
method: RwGsClassUnmanagedVersioningSymbolDictPatchV2
updatePatchesForNewClassVersion: aProjectSetModification patchSetSymbolList: patchSet
	"
	we happen to be modifying the existing project modification, so I think
		it may be practical to fabricate a newVersionClassModification
		that matches the one that would have been created if the before
		class had been packaged.

	So a little ifNotNil error action and then convert the remainder of the 
		method to do what we need
	"

	| existingClass newVersionClassModification existingClassName movedDeletedMap |
	movedDeletedMap := Dictionary new.
	(patchSet class
		lookupSymbolDictName: self symbolDictionaryName
		in: patchSet movedClassesSymbolList)
		keysAndValuesDo: [ :className :classMove | movedDeletedMap at: className put: classMove ].
	existingClass := self oldClassVersion.
	existingClassName := existingClass name asString.

	(self existingSymbolDictionaryRegistry
		existingForClass: existingClass
		ifAbsent: [  ])
		ifNotNil: [ :loadedClass | 
			self
				error:
					'Expected the class ' , existingClassName printString
						, ' to be unmanaged, but found a loaded class in package '
						, loadedClass loadedPackage name printString ].

	newVersionClassModification := self classDefinition
		compareAgainstBaseForNewClassUnmanagedVersion: classModification before.
	newVersionClassModification isEmpty
		ifTrue: [ 
			self
				error:
					'Unexpectedly empty class modification for an unmanaged class '
						, existingClassName asString ]
		ifFalse: [ 
			"only newVersionClassModification with substance need further processing"
			aProjectSetModification
				classesModificationAndPackageModificationAndProjectModificationDo: [ :classesModification :packageModification | 
					classesModification isEmpty
						ifFalse: [ 
							| classesModified |
							classesModified := classesModification elementsModified.
							(classesModified at: existingClassName ifAbsent: [  ])
								ifNil: [ 
									"not unexpected ... if there are multiple packages involved"
									 ]
								ifNotNil: [ :existingClassModification | 
									| deleteClassModification |
									deleteClassModification := false.
									(movedDeletedMap at: existingClassName ifAbsent: [  ])
										ifNotNil: [ :classMove | 
											deleteClassModification := classMove packageBefore name
												= packageModification after name ].
									deleteClassModification
										ifTrue: [ classesModified removeKey: existingClassName ]
										ifFalse: [ 
											newVersionClassModification mergeForExistingClassWith: existingClassModification.
											classesModified
												at: existingClassName
												put: newVersionClassModification ] ] ] ] ]
%

! Class implementation for 'RwGsMethodPatchV2'

!		Class methods for 'RwGsMethodPatchV2'

category: 'instance creation'
classmethod: RwGsMethodPatchV2
forMethod: aMethodDefinition isMeta: isMeta inClass: aClassDefinition inPackage: aPackageDefinition

	^(self new)
		methodDefinition: aMethodDefinition;
		isMeta: isMeta;
		classDefinition: aClassDefinition;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsMethodPatchV2'

category: 'accessing'
method: RwGsMethodPatchV2
behavior

	^ behavior
%

category: 'accessing'
method: RwGsMethodPatchV2
classDefinition

	^ classDefinition
%

category: 'accessing'
method: RwGsMethodPatchV2
classDefinition: newValue
	classDefinition := newValue
%

category: 'accessing'
method: RwGsMethodPatchV2
className

	^ self classDefinition key
%

category: 'accessing'
method: RwGsMethodPatchV2
compiledMethod

	^ compiledMethod
		ifNil: [ 
			| methodDictionary |
			methodDictionary := (behavior persistentMethodDictForEnv: 0 ) ifNil:[ Dictionary new ].
			selector := methodDefinition selector.
			compiledMethod := methodDictionary
				at: selector
				ifAbsent: [ self error: 'internal error - compiled method not present in method dictionary' ] ]
%

category: 'compiling'
method: RwGsMethodPatchV2
compileUsingNewClassesSymbolList: createdClasses andExistingClasses: tempSymbols
	self
		primeBehaviorNewClassesSymbolList: createdClasses
		andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			self
				error:
					'Class ' , self className printString , ' not found in the symbol dictionary '
						, self symbolDictionaryName printString , ' associated with the method '
						, methodDefinition selector printString ].

	[ 
	| sourceString protocol symbolList |
	sourceString := methodDefinition source.
	symbolList := SymbolList with: tempSymbols.
	protocol := (methodDefinition propertyAt: 'protocol') asSymbol.
	compiledMethod := behavior
		compileMethod: sourceString
		dictionaries: symbolList
		category: protocol
		intoMethodDict: false
		intoCategories: nil
		environmentId: self methodEnvironmentId	"we do not want the compiled method added to the class methodDictionary" ]
		on: CompileError , CompileWarning
		do: [ :ex | 
			ex
				addText:
					(RwRepositoryResolvedProjectTonelReaderVisitorV2
						lineNumberStringForMethod: methodDefinition).
			ex pass ]
%

category: 'initializers'
method: RwGsMethodPatchV2
isAnInitializer

	"answer true if I represent a class initialization method"

	^ isMeta and: [ selector == #'initialize' ]
%

category: 'accessing'
method: RwGsMethodPatchV2
isMeta

	^ isMeta
%

category: 'accessing'
method: RwGsMethodPatchV2
isMeta: newValue
	isMeta := newValue
%

category: 'accessing'
method: RwGsMethodPatchV2
methodDefinition
	^methodDefinition
%

category: 'accessing'
method: RwGsMethodPatchV2
methodDefinition: newValue
	methodDefinition := newValue
%

category: 'compiling'
method: RwGsMethodPatchV2
methodEnvironmentId

	"use the project load spec package properties"

	^ self projectDefinition methodEnvForPackageNamed: self packageName
%

category: 'private'
method: RwGsMethodPatchV2
primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols

	| className class |
	classDefinition key
		ifNil: [ 
			"class is being deleted ... we're done"
			^ self ].
	className := classDefinition key asSymbol.
	class := createdClasses
		at: className
		ifAbsent: [ 
			tempSymbols
				at: className
				ifAbsent: [ 
					"cannot find class ... caller can decide whether or not that is a problem"
					^ self ] ].
	behavior := isMeta
		ifTrue: [ class class ]
		ifFalse: [ class ]
%

category: 'private'
method: RwGsMethodPatchV2
primeBehaviorNewClassesSymbolList: createdClassesSymbolList andExistingClasses: tempSymbols
	| className class symDictName |
	classDefinition key
		ifNil: [ 
			"class is being deleted ... we're done"
			^ self ].
	className := classDefinition key asSymbol.
	symDictName := self symbolDictionaryName.
	class := (RwGsPatchSet_V2
		lookupSymbolDictName: symDictName
		in: createdClassesSymbolList)
		at: className
		ifAbsent: [ 
			tempSymbols
				at: className
				ifAbsent: [ 
					"cannot find class ... caller can decide whether or not that is a problem"
					^ self ] ].
	behavior := isMeta
		ifTrue: [ class class ]
		ifFalse: [ class ]
%

category: 'printing'
method: RwGsMethodPatchV2
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' for ';
		nextPutAll: self className asString.
	isMeta
		ifTrue: [ aStream nextPutAll: ' class' ].
	aStream
		nextPutAll: '>>';
		nextPutAll: methodDefinition key asString
%

category: 'private-installing'
method: RwGsMethodPatchV2
propertiesProtocolName

	^methodDefinition propertyAt: 'protocol' ifAbsent: ['unknown']
%

category: 'initializers'
method: RwGsMethodPatchV2
runInitializer

	"execute class initialization methods"

	self isAnInitializer
		ifTrue: [ behavior thisClass initialize ]
%

category: 'accessing'
method: RwGsMethodPatchV2
selector

	^ selector
%

! Class implementation for 'RwGsMethodAdditionSymbolDictPatchV2'

!		Instance methods for 'RwGsMethodAdditionSymbolDictPatchV2'

category: 'installing'
method: RwGsMethodAdditionSymbolDictPatchV2
installMethod

	self symbolDictionaryRegistry
		addNewCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodDeletionSymbolDictPatchV2'

!		Instance methods for 'RwGsMethodDeletionSymbolDictPatchV2'

category: 'deleting'
method: RwGsMethodDeletionSymbolDictPatchV2
deleteMethodNewClassesSymbolList: createdClasses andExistingClasses: tempSymbols
	self
		primeBehaviorNewClassesSymbolList: createdClasses
		andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class is being deleted, nothing else to do"
			^ self ].

	self symbolDictionaryRegistry
		deleteMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

category: 'deleting'
method: RwGsMethodDeletionSymbolDictPatchV2
deleteNewVersionMethodNewClassesSymbolList: createdClasses andExistingClasses: tempSymbols
	"remove the method from deleted things"

	"behavior is set, by an earlier call to deleteMethodNewClasses:andExistingClassSymbolList: "

	self symbolDictionaryRegistry
		_doDeleteCompiledMethodFromLoadedThings: self compiledMethod
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

category: 'initializers'
method: RwGsMethodDeletionSymbolDictPatchV2
isAnInitializer

	"answer true if I represent a class initialization method"

	^ false
%

category: 'initializers'
method: RwGsMethodDeletionSymbolDictPatchV2
runInitializer
	"noop"
%

! Class implementation for 'RwGsMethodDeletionExtensionSymbolDictPatchV2'

!		Instance methods for 'RwGsMethodDeletionExtensionSymbolDictPatchV2'

category: 'accessing'
method: RwGsMethodDeletionExtensionSymbolDictPatchV2
className

	^ self extendedClassName
%

category: 'accessing'
method: RwGsMethodDeletionExtensionSymbolDictPatchV2
extendedClassName

   ^extendedClassName
%

category: 'accessing'
method: RwGsMethodDeletionExtensionSymbolDictPatchV2
extendedClassName: anObject

	extendedClassName := anObject
%

category: 'private'
method: RwGsMethodDeletionExtensionSymbolDictPatchV2
primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols

	| className class |
	className := extendedClassName asSymbol.
	class := createdClasses
		at: className
		ifAbsent: [ 
			tempSymbols
				at: className
				ifAbsent: [ 
					"class is being deleted ... we're done"
					^ self] ].
	behavior := isMeta
		ifTrue: [ class class ]
		ifFalse: [ class ]
%

! Class implementation for 'RwGsMethodDeletionExtensionSessionMethodSymbolDictPatchV2'

!		Instance methods for 'RwGsMethodDeletionExtensionSessionMethodSymbolDictPatchV2'

category: 'accessing'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatchV2
compiledMethod

	^ compiledMethod
		ifNil: [ 
			| dictsArray mDict |
			dictsArray := self symbolDictionaryRegistry homeSessionMethods
				methodAndCategoryDictionaryFor: behavior.
			mDict := dictsArray at: 1.
			selector := methodDefinition selector.
			compiledMethod := mDict
				at: selector
				ifAbsent: [ 
					self
						error:
							'internal error - compiled session method not present in method dictionary' ] ]
%

category: 'accessing'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatchV2
symbolDictionary

	^self symbolDictionaryFor: self packageName
%

! Class implementation for 'RwGsMethodExtensionSymbolDictPatchV2'

!		Instance methods for 'RwGsMethodExtensionSymbolDictPatchV2'

category: 'installing'
method: RwGsMethodExtensionSymbolDictPatchV2
installMethod

	self symbolDictionaryRegistry
		addExtensionCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: self packageName
		 implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodExtensionSessionMethodSymbolDictPatchV2'

!		Instance methods for 'RwGsMethodExtensionSessionMethodSymbolDictPatchV2'

category: 'compiling'
method: RwGsMethodExtensionSessionMethodSymbolDictPatchV2
compileUsingNewClassesSymbolList: createdClasses andExistingClasses: tempSymbols
	self
		primeBehaviorNewClassesSymbolList: createdClasses
		andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			self
				error:
					'Class ' , self className printString , ' not found in the symbol dictionary '
						, self symbolDictionaryName printString , ' associated with the method '
						, methodDefinition selector printString ].

	[ 
	| sourceString protocol symbolList |
	sourceString := methodDefinition source.
	symbolList := SymbolList with: tempSymbols.
	protocol := (methodDefinition propertyAt: 'protocol') asSymbol.

	methDict := GsMethodDictionary new.
	catDict := GsMethodDictionary new.
	compiledMethod := behavior
		compileMethod: sourceString
		dictionaries: symbolList
		category: protocol
		intoMethodDict: methDict
		intoCategories: catDict
		environmentId: self methodEnvironmentId ]
		on: CompileError , CompileWarning
		do: [ :ex | 
			ex
				addText:
					(RwRepositoryResolvedProjectTonelReaderVisitorV2
						lineNumberStringForMethod: methodDefinition).
			ex pass ]
%

category: 'installing'
method: RwGsMethodExtensionSessionMethodSymbolDictPatchV2
installMethod

	"expecting only a single method to be compiled here"

	compiledMethod := self symbolDictionaryRegistry
		addExtensionSessionMethods: methDict
		catDict: catDict
		for: behavior
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.

	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodPropertiesSymDictPatchV2'

!		Instance methods for 'RwGsMethodPropertiesSymDictPatchV2'

category: 'installing'
method: RwGsMethodPropertiesSymDictPatchV2
installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols

	" update method protocol and update loadedMethod with new compiled method"

	| methodDictionary oldCompiledMethod |
	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ self error: 'Class ' , self className printString , ' not found.' ].

	methodDictionary := (behavior persistentMethodDictForEnv: 0 ) ifNil:[ Dictionary new ].
	selector := methodDefinition selector.
	oldCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			self
				error:
					'Internal error -- no existing CompileMethod found for patched method.' ].

	self symbolDictionaryRegistry
		moveCompiledMethod: oldCompiledMethod
		toProtocol: self propertiesProtocolName
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

category: 'installing'
method: RwGsMethodPropertiesSymDictPatchV2
installPropertiesPatchNewClassesSymbolList: createdClasses andExistingClasses: tempSymbols
	" update method protocol and update loadedMethod with new compiled method"

	| methodDictionary oldCompiledMethod |
	self
		primeBehaviorNewClassesSymbolList: createdClasses
		andExistingClasses: tempSymbols.
	behavior
		ifNil: [ self error: 'Class ' , self className printString , ' not found.' ].

	methodDictionary := (behavior persistentMethodDictForEnv: 0)
		ifNil: [ Dictionary new ].
	selector := methodDefinition selector.
	oldCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			self
				error:
					'Internal error -- no existing CompileMethod found for patched method.' ].

	self symbolDictionaryRegistry
		moveCompiledMethod: oldCompiledMethod
		toProtocol: self propertiesProtocolName
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2
%

category: 'initializers'
method: RwGsMethodPropertiesSymDictPatchV2
isAnInitializer

	"answer true if I represent a class initialization method"

	^ false
%

category: 'initializers'
method: RwGsMethodPropertiesSymDictPatchV2
runInitializer
	"noop"
%

! Class implementation for 'RwGsMethodExtensionSessionMethodPropertiesSymDictPatchV2'

!		Instance methods for 'RwGsMethodExtensionSessionMethodPropertiesSymDictPatchV2'

category: 'installing'
method: RwGsMethodExtensionSessionMethodPropertiesSymDictPatchV2
installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols

	^ super installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols
%

! Class implementation for 'RwGsMethodSourceSymbolDictPatchV2'

!		Instance methods for 'RwGsMethodSourceSymbolDictPatchV2'

category: 'installing'
method: RwGsMethodSourceSymbolDictPatchV2
installSourcePatch

	" update methodDictionary and update loadedMethod with new compiled method"

	self symbolDictionaryRegistry addRecompiledMethod: compiledMethod implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodExtensionSessionMethodSourceSymbolDictPatchV2'

!		Instance methods for 'RwGsMethodExtensionSessionMethodSourceSymbolDictPatchV2'

category: 'installing'
method: RwGsMethodExtensionSessionMethodSourceSymbolDictPatchV2
installSourcePatch

	" update methodDictionary and update loadedMethod with new compiled method"

	self symbolDictionaryRegistry addRecompiledSessionMethodMethod: compiledMethod implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsPackagePatchV2'

!		Class methods for 'RwGsPackagePatchV2'

category: 'instance creation'
classmethod: RwGsPackagePatchV2
for: aPackageDefinition

	^self new packageDefinition: aPackageDefinition
%

!		Instance methods for 'RwGsPackagePatchV2'

category: 'printing'
method: RwGsPackagePatchV2
printOn: aStream
	super printOn: aStream.
	aStream nextPutAll: '(' , packageDefinition name , ')'
%

! Class implementation for 'RwGsPackageAdditionSymbolDictPatchV2'

!		Instance methods for 'RwGsPackageAdditionSymbolDictPatchV2'

category: 'applying'
method: RwGsPackageAdditionSymbolDictPatchV2
createLoadedPackage

	| loadedPackage loadedProject |
	loadedPackage := self symbolDictionaryRegistry
		createLoadedPackageFromDefinition: self packageDefinition
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.

	projectDefinition ifNil: [ ^ self ].

	loadedProject := Rowan image
		loadedProjectNamed: projectDefinition name
		ifAbsent: [ 
			self
				error:
					'expected a loaded project named ' , projectDefinition name printString ].

	loadedProject addLoadedPackage: loadedPackage
%

! Class implementation for 'RwGsPackageDeletionSymbolDictPatchV2'

!		Instance methods for 'RwGsPackageDeletionSymbolDictPatchV2'

category: 'deleting'
method: RwGsPackageDeletionSymbolDictPatchV2
deletePackage

	(Rowan image loadedRegistryForPackageNamed: packageDefinition name)
		deletePackage: packageDefinition name
%

! Class implementation for 'RwGsPackageMoveSymbolDictPatchV2'

!		Instance methods for 'RwGsPackageMoveSymbolDictPatchV2'

category: 'moving'
method: RwGsPackageMoveSymbolDictPatchV2
movePackage: classesWithNewVersions
	"Loader already makes sure that the package is created properly, but we do have to 
		make sure that the old package is deleted from it's original location. Class extensions
		have to be removed as well (https://github.com/dalehenrich/Rowan/issues/495)"

	(Rowan image loadedRegistryForPackageNamed: packageDefinition name)
		movePackage: packageDefinition name
		to: packageDefinition gs_symbolDictionary
		classesWithNewVersions: classesWithNewVersions
%

! Class implementation for 'RwGsProjectPatchV2'

!		Class methods for 'RwGsProjectPatchV2'

category: 'instance creation'
classmethod: RwGsProjectPatchV2
for: aProjectDefinition

	^self new projectDefinition: aProjectDefinition
%

!		Instance methods for 'RwGsProjectPatchV2'

category: 'printing'
method: RwGsProjectPatchV2
printOn: aStream
	super printOn: aStream.
	aStream nextPutAll: '(' , projectDefinition name , ')'
%

category: 'applying'
method: RwGsProjectPatchV2
updateProjectProperties

	| loadedProject |
	loadedProject := Rowan image
		loadedProjectNamed: self projectName
		ifAbsent: [ self error: 'Internal error. Attempt to update unregistered project.' ].
	loadedProject setPropertiesTo: self projectDefinition properties
%

! Class implementation for 'RwGsProjectAdditionPatchV2'

!		Instance methods for 'RwGsProjectAdditionPatchV2'

category: 'applying'
method: RwGsProjectAdditionPatchV2
createLoadedProject

	| projectName existingLoadedProject newLoadedProject |
	projectName := self projectName.
	existingLoadedProject := Rowan image
		loadedProjectNamed: projectName
		ifAbsent: [ nil ].
	existingLoadedProject
		ifNotNil: [ self error: 'Internal error -- Attempt to add a project that exists.' ].
	newLoadedProject := projectDefinition asLoadedSymbolDictProject.
	Rowan image addLoadedProject: newLoadedProject.
	self updateProjectProperties
%

category: 'applying'
method: RwGsProjectAdditionPatchV2
updateProjectProperties

	"noop - properties updated during createLoadedProject"

	
%

! Class implementation for 'RwGsSymbolDictionaryRegistryV2'

!		Class methods for 'RwGsSymbolDictionaryRegistryV2'

category: 'accessing'
classmethod: RwGsSymbolDictionaryRegistryV2
defaultProtocolString

	^ 'as yet unclassified'
%

category: 'installation'
classmethod: RwGsSymbolDictionaryRegistryV2
globalSymbol

	^ #'RwSymbolDictionaryRegistry'
%

category: 'installation'
classmethod: RwGsSymbolDictionaryRegistryV2
installIn: aSymbolDictionary

	| registry |
	registry := self newForSymbolDictionary: aSymbolDictionary.
	aSymbolDictionary at: self globalSymbol put: registry.
	^ registry
%

category: 'instance creation'
classmethod: RwGsSymbolDictionaryRegistryV2
newForSymbolDictionary: aSymbolDictionary

	^ self new
		_symbolDictionary: aSymbolDictionary;
		initialize;
		yourself
%

category: 'accessing'
classmethod: RwGsSymbolDictionaryRegistryV2
registry_ImplementationClass

	^ RwGsSymbolDictionaryRegistry_ImplementationV2
%

!		Instance methods for 'RwGsSymbolDictionaryRegistryV2'

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addClassAssociation: assoc forClass: class toPackageNamed: packageName

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	^ self class registry_ImplementationClass addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addClassAssociation: assoc forClass: class toPackageNamed: packageName implementationClass: implementationClass

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName

	^ self class registry_ImplementationClass addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName implementationClass: implementationClass

	"expecting only a single method to be in methDict/catDict"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addNewClassVersionToAssociation: newClass oldClassVersion: oldClass
	"a new class version is being added to the association in the receiver previously occupied by the original class"

	self class registry_ImplementationClass
		addNewClassVersionToAssociation: newClass
		oldClassVersion: oldClass
		instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addNewClassVersionToAssociation: newClass oldClassVersion: oldClass implementationClass: implementationClass
	"a new class version is being added to the association in the receiver previously occupied by the original class"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	implementationClass
		addNewClassVersionToAssociation: newClass
		oldClassVersion: oldClass
		instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName

	^ self class registry_ImplementationClass addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addNewUnmanagedClassVersionToAssociation: newClass oldClassVersion: oldClass toPackageNamed: aPackageName implementationClass: implementationClass
	"a new class version is being added to the association in the receiver previously occupied by the original class"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	implementationClass
		addNewUnmanagedClassVersionToAssociation: newClass
		oldClassVersion: oldClass
		toPackageNamed: aPackageName
		instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addRecompiledMethod: newCompiledMethod

	"add a recompiled compiled method to behavior and update the loaded things"

	^ self class registry_ImplementationClass addRecompiledMethod: newCompiledMethod instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addRecompiledMethod: newCompiledMethod implementationClass: implementationClass

	"add a recompiled compiled method to behavior and update the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addRecompiledMethod: newCompiledMethod instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
addRecompiledSessionMethodMethod: newCompiledMethod implementationClass: implementationClass

	"add a recompiled session method compiled method to behavior and update the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addRecompiledSessionMethodMethod: newCompiledMethod instance: self
%

category: 'package - patch api'
method: RwGsSymbolDictionaryRegistryV2
createLoadedPackageFromDefinition: packageDefinition implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass createLoadedPackageFromDefinition: packageDefinition instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistryV2
deleteClassFromPackage: class

	"a class association is being deleted from the receiver remove it from the loaded things"

	^ self class registry_ImplementationClass deleteClassFromPackage: class instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistryV2
deleteClassNamedFromPackage: className implementationClass: implementationClass

	"a class association is being deleted from the receiver remove it from the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteClassNamedFromPackage: className instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistryV2
deleteCompiledMethod: compiledMethod from: behavior

	"delete a compiled method from behavior and remove it from the loaded things"

	^ self class registry_ImplementationClass deleteCompiledMethod: compiledMethod from: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistryV2
deleteMethod: selector for: behavior implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteMethod: selector for: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistryV2
deletePackage: packageName

	^  self class registry_ImplementationClass deletePackage: packageName instance: self
%

category: 'class disown api'
method: RwGsSymbolDictionaryRegistryV2
disownClass: class

	"Remove the specified class and all of it's packaged instance and class methods from the loaded things."

	^ self class registry_ImplementationClass disownClass: class instance: self
%

category: 'class disown api'
method: RwGsSymbolDictionaryRegistryV2
disownClassExtensions: class forLoadedPackage: loadedPackage

	"Remove the extension methods in the named class for the named package"

	^ self class registry_ImplementationClass disownClassExtensions: class forLoadedPackage: loadedPackage instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistryV2
ensureExtensionClassNamed: className existsForPackageNamed: packageName implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass ensureExtensionClassNamed: className existsForPackageNamed: packageName instance: self
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistryV2
existingForClass: aClass

	"Answer the registered LoadedClass for the given class."

	^ self
		existingForClass: aClass
		ifAbsent: [ self error: 'no loaded class found for ' , aClass name printString ]
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistryV2
existingForClass: aClass ifAbsent: absentBlock

	"Answer the registered LoadedClass for the given class."

	^ self loadedClassForClass: aClass ifAbsent: absentBlock
%

category: 'session methods'
method: RwGsSymbolDictionaryRegistryV2
homeSessionMethods

	| package |
	package := self _symbolDictionary at: GsPackage globalName otherwise: nil.
	package ifNil: [ package := GsPackage installIn: self _symbolDictionary ].
	^ package
%

category: 'initialization'
method: RwGsSymbolDictionaryRegistryV2
initialize

	| symbolDictObjectSecurityPolicy |
	packageRegistry := KeyValueDictionary new.	"keyed by package name"
	methodRegistry := IdentityKeyValueDictionary new.	"keyed by compiledMethod"

	symbolDictObjectSecurityPolicy := symbolDictionary objectSecurityPolicy.
	packageRegistry objectSecurityPolicy: symbolDictObjectSecurityPolicy.
	methodRegistry objectSecurityPolicy: symbolDictObjectSecurityPolicy.
%

category: 'class - registration'
method: RwGsSymbolDictionaryRegistryV2
loadedClassExtensionsForClass: aClass
	^ self class registry_ImplementationClass loadedClassExtensionsForClass: aClass
%

category: 'class - registration'
method: RwGsSymbolDictionaryRegistryV2
loadedClassExtensionsForClass: aClass ifAbsent: absentBlock
	^ self class registry_ImplementationClass loadedClassExtensionsForClass: aClass ifAbsent: absentBlock
%

category: 'class - registration'
method: RwGsSymbolDictionaryRegistryV2
loadedClassForClass: aClass
	^ self class registry_ImplementationClass loadedClassForClass: aClass
%

category: 'class - registration'
method: RwGsSymbolDictionaryRegistryV2
loadedClassForClass: aClass ifAbsent: absentBlock
	^ self class registry_ImplementationClass loadedClassForClass: aClass ifAbsent: absentBlock
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistryV2
loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock

	^ self class registry_ImplementationClass loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock instance: self
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistryV2
loadedPackageNamed: packageName ifAbsent: absentBlock

	^ self class registry_ImplementationClass loadedPackageNamed: packageName ifAbsent: absentBlock instance: self
%

category: 'accessing'
method: RwGsSymbolDictionaryRegistryV2
methodRegistry

   ^methodRegistry
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistryV2
moveCompiledMethod: compiledMethod toProtocol: newProtocol

	"move a compiled method into a different protocol and update loaded things"

	^ self class registry_ImplementationClass moveCompiledMethod: compiledMethod toProtocol: newProtocol instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistryV2
moveCompiledMethod: compiledMethod toProtocol: newProtocol implementationClass: implementationClass

	"move a compiled method into a different protocol and update loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass moveCompiledMethod: compiledMethod toProtocol: newProtocol instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistryV2
movePackage: packageName to: symbolDictionaryName classesWithNewVersions: classesWithNewVersions
	^ self class registry_ImplementationClass
		movePackage: packageName
		to: symbolDictionaryName
		classesWithNewVersions: classesWithNewVersions
		instance: self
%

category: 'package - patch api'
method: RwGsSymbolDictionaryRegistryV2
movePackage: packageName toProjectNamed: projectName
	^ self class registry_ImplementationClass
		movePackage: packageName
		toProjectNamed: projectName
		instance: self
%

category: 'accessing'
method: RwGsSymbolDictionaryRegistryV2
packageRegistry

   ^packageRegistry
%

category: 'class - registration'
method: RwGsSymbolDictionaryRegistryV2
registerLoadedClass: loadedClass forClass: aClass
	^ self class registry_ImplementationClass registerLoadedClass: loadedClass forClass: aClass
%

category: 'class - registration'
method: RwGsSymbolDictionaryRegistryV2
registerLoadedClassExtension: loadedClass forClass: aClass
	^ self class registry_ImplementationClass registerLoadedClassExtension: loadedClass forClass: aClass
%

category: 'class - registration'
method: RwGsSymbolDictionaryRegistryV2
unregisterLoadedClass: loadedClass forClass: aClass
	^ self class registry_ImplementationClass unregisterLoadedClass: loadedClass forClass: aClass
%

category: 'class - registration'
method: RwGsSymbolDictionaryRegistryV2
unregisterLoadedClassExtension: loadedClassExtension forClass: aClass
	^ self class registry_ImplementationClass unregisterLoadedClassExtension: loadedClassExtension forClass: aClass
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistryV2
updateClassProperties: class

	"class properties have changed, update the clas properties of the loaded things"

	^ self class registry_ImplementationClass updateClassProperties: class instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistryV2
updateClassProperties: class  implementationClass: implementationClass

	"class properties have changed, update the clas properties of the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass updateClassProperties: class instance: self
%

category: 'method - private api'
method: RwGsSymbolDictionaryRegistryV2
_doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior

	"remove a compiled method from loaded things"

	^ self class registry_ImplementationClass _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: self
%

category: 'method - private api'
method: RwGsSymbolDictionaryRegistryV2
_doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior implementationClass: implementationClass

	"remove a compiled method from loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
_loadedClassFor: class noNewVersion: noNewVersionBlock

	self
		_loadedClassFor: class
		noNewVersion: noNewVersionBlock
		newVersion: [ :loadedClass | 
			self
				error:
					'internal error - the value associated with the key ' , class name printString
						, ' is not identical to the given class' ]
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
_loadedClassFor: class noNewVersion: noNewVersionBlock newVersion: newVersionBlock

	| loadedClass classKey |
	(class isKindOf: Class)
		ifFalse: [ self error: 'internal error - expected a class' ].
	loadedClass := self 
		loadedClassForClass: class 
		ifAbsent: [ 
			self
				error:
					'internal error - No loaded class found for the class ' , class name printString ].
	classKey := loadedClass key asSymbol.
	self
		_symbolDictionaryAssociationAt: classKey
		ifPresent: [ :assoc | 
			assoc value == class
				ifTrue: [ ^ noNewVersionBlock cull: loadedClass cull: assoc ]
				ifFalse: [ ^ newVersionBlock cull: loadedClass cull: assoc ] ].

	self
		error:
			'internal error - there is no assocation present in the receiver for the given class '
				, classKey asString printString
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
_symbolDictionary

	^ symbolDictionary
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
_symbolDictionary: aSymbolDictionary

	symbolDictionary := aSymbolDictionary
%

category: 'private'
method: RwGsSymbolDictionaryRegistryV2
_symbolDictionaryAssociationAt: aKey ifPresent: oneArgBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the symbol association associated with the key, otherwise answer nil."

	| anAssoc |
	anAssoc := self _symbolDictionary associationAt: aKey otherwise: nil.
	anAssoc ifNotNil: [ ^ oneArgBlock cull: anAssoc ].
	^ nil
%

! Class implementation for 'RwGsSymbolDictionaryRegistry_ImplementationV2'

!		Class methods for 'RwGsSymbolDictionaryRegistry_ImplementationV2'

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: registryInstance

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	| loadedPackage loadedClass |
	loadedPackage := self existingOrNewLoadedPackageNamed: packageName instance: registryInstance.

	loadedClass := self 
		loadedClassForClass: class 
		ifAbsent: [ 
			loadedClass := RwGsLoadedSymbolDictClass newForClass: class.
			loadedPackage addLoadedClass: loadedClass.
			loadedClass updatePropertiesFromClassFor: registryInstance.
			self registerLoadedClass: loadedClass forClass: class.
			(loadedPackage loadedClassExtensions at: class name ifAbsent: [  ])
				ifNotNil: [ :loadedClassExtension | 
					"I think we need to subsume the loadedClassExtension methods into a loadedClass ..."
					"have yet to come with a test case that takes this path"
					registryInstance error: 'internal error - unexpected class extenstions for a loaded class ', class name asString printString , ' that has no entry in classRegistry in package ', loadedPackage name printString, '.' ].
			loadedClass ].

	self 
		_symbolDictionary: registryInstance _symbolDictionary 
		at: assoc key 
		ifPresent: [:theClass |
			theClass ~~ class
				ifTrue: [
					(RwExistingAssociationWithSameKeyNotification new
						errorMessage: 'Found an existing association in the ',  
								registryInstance _symbolDictionary name asString printString, 
								' symbol dictionary with a duplicate key ',
								assoc key printString, 
								' while attempting to add a new class' )
						signal.
					(registryInstance _symbolDictionary associationAt: assoc key) value: class ] ]
		ifAbsent: [
			assoc value: class.
			registryInstance _symbolDictionary add: assoc].
	^ loadedClass
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
addNewClassVersionToAssociation: newClass oldClassVersion: oldClass instance: registryInstance

	"a new class version is being added to the association in the receiver previously occupied by the original class"

	self 
		_loadedClassFor: newClass
		oldClassVersion: oldClass
		noNewVersion: [ 
			"newClass is actually not a new class version of existing class, that's okay... update properties anyway"
			self updateClassProperties: newClass instance: registryInstance.]
		newVersion: [ :loadedClass :assoc | 
			"association for class is present, install in association and update the loadedthing"
			assoc value: newClass.
			loadedClass handleClassDeletionOrNewVersion
				ifTrue: [ loadedClass updatePropertiesFromClassFor: registryInstance ]
				ifFalse: [ registryInstance error: 'internal error - new version of class not properly installed' ] ]
		instance: registryInstance.
	self 
		_loadedClassExtensionsFor: newClass
		oldClassVersion: oldClass
		noNewVersion: [ 
			"newClass is actually not a new class version of existing class, that's okay... noop"
]
		newVersion: [ :loadedClassExtension | 
			loadedClassExtension handleClassDeletionOrNewVersion
				ifFalse: [ registryInstance error: 'internal error - new version of class not properly installed' ] ]
		instance: registryInstance.
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
addNewUnmanagedClassVersionToAssociation: newClass oldClassVersion: oldClass toPackageNamed: aPackageName instance: registryInstance
	"a new class version is being added to the association in the receiver previously occupied by 
		the original class. No loadedClass or loadedClassExtension is expected for the oldClass"

	(oldClass isKindOf: Class)
		ifFalse: [ registryInstance error: 'internal error - expected a class' ].

	(Rowan image loadedClassForClass: oldClass ifAbsent: [  ])
		ifNotNil: [ 
			self
				error:
					'Unexpected loaded class for old version of class '
						, oldClass name asString printString ].

	self
		_symbolDictionary: registryInstance _symbolDictionary
		associationAt: newClass name
		ifPresent: [ :assoc | Rowan packageTools adopt adoptClass: newClass intoPackageNamed: aPackageName ]
%

category: 'package - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
createLoadedPackageFromDefinition: packageDefinition instance: registryInstance

	^ self
		createLoadedPackageNamed: packageDefinition key
		properties: packageDefinition properties
		instance: registryInstance
%

category: 'package - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
createLoadedPackageNamed: packageName properties: properties instance: registryInstance 

	| existingLoadedPackage newLoadedPackage |
	existingLoadedPackage := registryInstance packageRegistry at: packageName ifAbsent: [ nil ].
	existingLoadedPackage
		ifNotNil: [ self error: 'Internal error -- Attempt to add a package that exists.' ].
	newLoadedPackage := RwGsLoadedSymbolDictPackage newNamed: packageName.
	newLoadedPackage setPropertiesTo: properties.
	registryInstance packageRegistry at: packageName put: newLoadedPackage.
	^ newLoadedPackage
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
deleteClassFromPackage: class instance: registryInstance

	"a class association is being deleted from the receiver remove it from the loaded things and remove class from system"

	| removeClassFromSystem |
	removeClassFromSystem := RwDeleteClassFromSystemNotification new
		candidateClass: class;
		signal. "handle and `resume: true` if you want class to remain in system, unpackaged"
	^ self _doDeleteClassFromLoadedThings: class removeClassFromSystem: removeClassFromSystem instance: registryInstance
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
deleteClassNamedFromPackage: className instance: registryInstance

	"a class association is being deleted from the receiver remove it from the loaded things"

	| class |
	class := registryInstance _symbolDictionary
		at: className asSymbol
		ifAbsent: [ registryInstance error: 'No class found for the given class name: ' , className printString ].
	^ self deleteClassFromPackage: class instance: registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
deleteCompiledMethod: compiledMethod from: behavior instance: registryInstance

	"delete a compiled method from behavior and remove it from the loaded things"

	self _doDeleteCompiledMethod: compiledMethod from: behavior instance: registryInstance.

	self _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: registryInstance.

	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
deleteMethod: selector for: behavior instance: registryInstance

	| compiledMethod |

	compiledMethod := behavior compiledMethodAt: selector.
	self deleteCompiledMethod: compiledMethod from: behavior instance: registryInstance.
	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
deletePackage: packageName instance: registryInstance

	| loadedPackage |
	loadedPackage := registryInstance packageRegistry
		removeKey: packageName
		ifAbsent: [ registryInstance error: 'package ' , packageName printString , ' not found' ].
	loadedPackage loadedProject removeLoadedPackage: loadedPackage.
	^ registryInstance
%

category: 'class disown api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
disownClass: class instance: registryInstance

	"Remove the specified class and all of it's packaged instance and class methods from the loaded things."

	self
		_loadedClassFor: class
		noNewVersion: [ :loadedClass | 
			loadedClass disownFromLoaded: registryInstance.
			self 
				unregisterLoadedClass: loadedClass
				forClass: class ]
		instance: registryInstance.
	^ registryInstance
%

category: 'class disown api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
disownClassExtensions: class forLoadedPackage: loadedPackage instance: registryInstance

	"Remove the extension methods in the class for the given package"

	| loadedClassExtension |
	loadedClassExtension := loadedPackage
		loadedClassExtensionForClass: class
		ifAbsent: [ self error: 'No class extensions found for the class ', class name asString printString, ' in the package ', loadedPackage name printString ].
	
	loadedClassExtension disownFromLoaded: registryInstance.

	loadedPackage removeLoadedClassExtension: loadedClassExtension.

	^ registryInstance
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
ensureExtensionClassNamed: className existsForPackageNamed: packageName instance: registryInstance

	| extensionClass loadedPackage loadedClassExtension |
	extensionClass := registryInstance _symbolDictionary
		at: className asSymbol
		ifAbsent: [ 
			registryInstance
				error:
					'The extension class named ' , className printString
						, ' cannot be found in this symbol dictionary (' , registryInstance _symbolDictionary name printString
						,
							'). Packages that extend a class must be loaded into the symbol dictionary in which the class is installed.' ].
	loadedPackage := self existingOrNewLoadedPackageNamed: packageName instance: registryInstance.

	loadedPackage
		loadedClassExtensionForClass: extensionClass
		ifAbsent: [ 
			loadedClassExtension := RwGsLoadedSymbolDictClassExtension
				newForClass: extensionClass
				inPackage: loadedPackage.
			self
				registerLoadedClassExtension: loadedClassExtension
				forClass: extensionClass ].
	^ registryInstance
%

category: 'package - creation api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
existingOrNewLoadedPackageNamed: packageName instance: registryInstance

	^ registryInstance packageRegistry
			at: packageName
			ifAbsent: [ 
				registryInstance packageRegistry
					at: packageName
					put: (RwGsLoadedSymbolDictPackage newNamed: packageName) ].
%

category: 'class - registration'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
loadedClassExtensionsForClass: aClass
	^ self
		loadedClassExtensionsForClass: aClass 
		ifAbsent: [ self error: 'No loaded extension class found for: ', aClass name printString]
%

category: 'class - registration'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
loadedClassExtensionsForClass: aClass ifAbsent: absentBlock
	^ (aClass theNonMetaClass _extraDictAt: self _loadedClassExtensionKey) ifNil: absentBlock
%

category: 'class - registration'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
loadedClassForClass: aClass
	^ self 
		loadedClassForClass: aClass
		ifAbsent: [ self error: 'No loaded class found for: ', aClass name printString ]
%

category: 'class - registration'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
loadedClassForClass: aClass ifAbsent: absentBlock
	^ (aClass theNonMetaClass _extraDictAt: self _loadedClassKey) ifNil: absentBlock
%

category: 'loaded queries'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock instance: registryInstance

	| packageName |
	(hybridPackageName at: 1) = $*
		ifFalse: [ 
			registryInstance
				error:
					'Improperly formed hybrid package name' , hybridPackageName printString
						, '. Expected a leading ''*''' ].
	packageName := (hybridPackageName copyFrom: 2 to: hybridPackageName size)
		asLowercase.
	registryInstance packageRegistry keys
		do: [ :key | 
			key asLowercase = packageName
				ifTrue: [ ^ registryInstance packageRegistry at: key ] ].
	^ absentBlock value
%

category: 'loaded queries'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
loadedPackageNamed: packageName ifAbsent: absentBlock instance: registryInstance

	^ registryInstance packageRegistry at: packageName ifAbsent: absentBlock
%

category: 'package - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
movePackage: packageName to: symbolDictionaryName classesWithNewVersions: classesWithNewVersions instance: fromRegistryInstance
	| loadedPackage toRegistryInstance newClassVersionMap |
	loadedPackage := fromRegistryInstance packageRegistry
		removeKey: packageName
		ifAbsent: [ fromRegistryInstance error: 'package ' , packageName printString , ' not found' ].
	newClassVersionMap := Dictionary new.
	classesWithNewVersions
		do: [ :patch | newClassVersionMap at: patch oldClassVersion put: patch newClassVersion ].
	toRegistryInstance := (Rowan image
		newOrExistingSymbolDictionaryNamed: symbolDictionaryName)
		rowanSymbolDictionaryRegistry.
	loadedPackage loadedClassExtensions
		do: [ :loadedClassExtensions | 
			"class extensions must be removed from old package, additions are handled elsewhere"
			"https://github.com/dalehenrich/Rowan/issues/495"
			loadedClassExtensions moveFrom: fromRegistryInstance.
			newClassVersionMap
				at: loadedClassExtensions handle
				ifPresent: [ :newClassVersion | loadedClassExtensions handle: newClassVersion ].
			loadedClassExtensions moveTo: toRegistryInstance.].
	(toRegistryInstance packageRegistry at: packageName ifAbsent: [  ])
		ifNotNil: [ :unexpectedLoadedPackage | 
			toRegistryInstance
				error:
					'package ' , packageName printString , ' unexpectedly found in '
						, symbolDictionaryName printString ].
	toRegistryInstance packageRegistry at: packageName put: loadedPackage.
	loadedPackage updatePropertiesFromRegistryFor: toRegistryInstance.
	^ fromRegistryInstance
%

category: 'package - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
movePackage: packageName toProjectNamed: projectName instance: registryInstance
	| loadedPackage loadedProjectAfter loadedProjectBefore |
	loadedPackage := self
		loadedPackageNamed: packageName
		ifAbsent: [ registryInstance error: 'package ' , packageName printString , ' not found' ]
		instance: registryInstance.
	loadedProjectBefore := loadedPackage loadedProject.
	loadedProjectBefore removeLoadedPackage: loadedPackage.
	loadedProjectAfter := Rowan image loadedProjectNamed: projectName.
	loadedProjectAfter addLoadedPackage: loadedPackage.
	^ registryInstance
%

category: 'class - registration'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
registerLoadedClass: loadedClass forClass: aClass
	aClass theNonMetaClass _extraDictAt: self _loadedClassKey put: loadedClass
%

category: 'class - registration'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
registerLoadedClassExtension: loadedClass forClass: aClass
	((aClass theNonMetaClass _extraDictAt: self _loadedClassExtensionKey) 
		ifNil: [ | set |
			set := IdentitySet new.
			aClass theNonMetaClass _extraDictAt: self _loadedClassExtensionKey put: set.
			set ])
		add: loadedClass
%

category: 'class - registration'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
unregisterLoadedClass: loadedClass forClass: aClass
	| lc |
	(lc := aClass theNonMetaClass _extraDictAt: self _loadedClassKey) == loadedClass
		ifFalse: [ self error: 'Loaded class for ', aClass name printString, ' not found. Found ', lc printString, ' instead.' ].
	aClass theNonMetaClass _extraDictRemoveKey:  self _loadedClassKey
%

category: 'class - registration'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
unregisterLoadedClassExtension: loadedClassExtension forClass: aClass
	(aClass theNonMetaClass _extraDictAt: self _loadedClassExtensionKey)
		ifNil: [ self error: 'Loaded class extension for ', aClass name printString, ' not found' ]
		ifNotNil: [:aSet |
			aSet 
				remove: loadedClassExtension 
				ifAbsent: [ "if the class extension has already been removed we are okay" ].
			aSet isEmpty
				ifTrue: [ aClass theNonMetaClass _extraDictRemoveKey:  self _loadedClassExtensionKey ] ]
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
updateClassProperties: class instance: registryInstance

	"class properties have changed, update the clas properties of the loaded things"

	(class isKindOf: Class)
		ifFalse: [ registryInstance error: 'internal error - expected a class' ].
	registryInstance
		_loadedClassFor: class
		noNewVersion: [ :loadedClass | 
			"association for class is present, update the loaded thing"
			loadedClass updatePropertiesFromClassFor: registryInstance ].
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_clearLookupCachesFor: aBehavior env: envId

"Invalidates method lookup caches for all classes.
 Invalidates all send-site caches for the specified environment.

 envId must be a SmallInteger >= 0 and <= 255 .
"

 "set bit in VM's cbCodeChanged word so it can propagate to
  other VMs upon commit.  Code which adds or removes entries
  in persistent method dictionaries must send this method. "

	aBehavior 
		_clearLookupCaches: envId;
		_codeChangedForEnv: envId
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_doDeleteClassFromLoadedThings: class removeClassFromSystem: removeClassFromSystem instance: registryInstance

	"a class association is being deleted from the receiver remove it from the loaded things. Conditionally remove class from system"

	self
		_loadedClassFor: class
		noNewVersion: [ :loadedClass | 
			"association for class is present, finish delete operation"
			loadedClass removeFromLoaded: registryInstance.
			self unregisterLoadedClass: loadedClass forClass: class.
			removeClassFromSystem ifTrue: [ registryInstance _symbolDictionary removeKey: loadedClass key asSymbol ] ]
		instance: registryInstance.
	^ registryInstance
%

category: 'method - private api'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_doDeleteCompiledMethod: compiledMethod from: behavior instance: registryInstance

	"delete a compiled method from behavior"

	| selector |
	selector := compiledMethod selector.
	behavior removeSelector: selector asString environmentId: 0.

	^ registryInstance
%

category: 'class - registration'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_loadedClassExtensionKey
	^ #rowanLoadedClassExtension
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_loadedClassExtensionsFor: class oldClassVersion: oldClass noNewVersion: noNewVersionBlock newVersion: newVersionBlock instance: registryInstance
	| oldLoadedClassExtensionSet |
	(class isKindOf: Class)
		ifFalse: [ registryInstance error: 'internal error - expected a class' ].

	oldLoadedClassExtensionSet := self
		loadedClassExtensionsForClass: oldClass
		ifAbsent: [ 
			"we're done here"
			^ self ].
	oldLoadedClassExtensionSet copy
		do: [ :oldLoadedClassExtension | 
			| classKey loadedClassExtension loadedPackage |
			loadedPackage := oldLoadedClassExtension loadedPackage.
			self
				unregisterLoadedClassExtension: oldLoadedClassExtension
				forClass: oldClass.
			loadedPackage removeLoadedClassExtension: oldLoadedClassExtension.
			loadedClassExtension := RwGsLoadedSymbolDictClassExtension
				newForClass: class
				inPackage: loadedPackage.
			loadedClassExtension
				reregisterLoadedInstanceMethods:
						oldLoadedClassExtension loadedInstanceMethods;
				reregisterLoadedClassMethods: oldLoadedClassExtension loadedClassMethods;
				yourself.
			self registerLoadedClassExtension: loadedClassExtension forClass: class.
			classKey := loadedClassExtension key asSymbol.
			self
				_symbolDictionary: registryInstance _symbolDictionary
				associationAt: classKey
				ifPresent: [ :assoc | 
					assoc value == loadedClassExtension handle
						ifTrue: [ noNewVersionBlock cull: loadedClassExtension ]
						ifFalse: [ newVersionBlock cull: loadedClassExtension ] ] ]
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_loadedClassFor: class noNewVersion: noNewVersionBlock instance: registryInstance

	self
		_loadedClassFor: class
		noNewVersion: noNewVersionBlock
		newVersion: [ :loadedClass | 
			self
				error:
					'internal error - the value associated with the key ' , class name printString
						, ' is not identical to the given class' ]
		instance: registryInstance.
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_loadedClassFor: class noNewVersion: noNewVersionBlock newVersion: newVersionBlock instance: registryInstance
	(class isKindOf: Class)
		ifFalse: [ registryInstance error: 'internal error - expected a class' ].
	self
		_symbolDictionary: registryInstance _symbolDictionary
		associationAt: class name
		ifPresent: [ :assoc | 
			| loadedClass |
			loadedClass := self
				loadedClassForClass: class
				ifAbsent: [ 
					self
						error:
							'internal error - no loaded class for the class '
								, class name asString printString ].
			assoc value == class
				ifTrue: [ ^ noNewVersionBlock cull: loadedClass cull: assoc ]
				ifFalse: [ ^ newVersionBlock cull: loadedClass cull: assoc ] ].

	registryInstance
		error:
			'internal error - there is no assocation present in the receiver for the given class '
				, class name asString printString
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_loadedClassFor: class oldClassVersion: oldClass noNewVersion: noNewVersionBlock newVersion: newVersionBlock instance: registryInstance
	(class isKindOf: Class)
		ifFalse: [ registryInstance error: 'internal error - expected a class' ].
	self
		_symbolDictionary: registryInstance _symbolDictionary
		associationAt: class name
		ifPresent: [ :assoc | 
			| loadedClass oldLoadedClass loadedPackage |
			oldLoadedClass := self
				loadedClassForClass: oldClass
				ifAbsent: [ 
					registryInstance
						error:
							'internal error - no loaded class found for the old version of '
								, oldClass name asString printString ].
			loadedPackage := oldLoadedClass loadedPackage.
			(self loadedClassForClass: class ifAbsent: [  ])
				ifNil: [ 
					loadedClass := RwGsLoadedSymbolDictClass newForClass: class.
					loadedClass
						reregisterLoadedInstanceMethods: oldLoadedClass loadedInstanceMethods;
						reregisterLoadedClassMethods: oldLoadedClass loadedClassMethods;
						yourself.
					self unregisterLoadedClass: oldLoadedClass forClass: oldClass.
					self registerLoadedClass: loadedClass forClass: class.
					loadedPackage removeLoadedClass: oldLoadedClass.
					loadedPackage addLoadedClass: loadedClass.
					loadedClass updatePropertiesFromClassFor: registryInstance ]
				ifNotNil: [ :unexpectedLoadedClass | 
					assoc value == class
						ifTrue: [ ^ noNewVersionBlock cull: unexpectedLoadedClass cull: assoc ]
						ifFalse: [ 
							registryInstance
								error:
									'internal error - found a loaded class (' , unexpectedLoadedClass printString
										, ') for ' , class name asString printString
										, ' when no loaded class expected' ] ].
			assoc value == class
				ifTrue: [ ^ noNewVersionBlock cull: loadedClass cull: assoc ]
				ifFalse: [ ^ newVersionBlock cull: loadedClass cull: assoc ] ].

	registryInstance
		error:
			'internal error - there is no assocation present in the receiver for the given class '
				, class name asString printString
%

category: 'class - registration'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_loadedClassKey
	^ #rowanLoadedClass
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_symbolDictionary: symbolDictionary associationAt: aKey ifPresent: oneArgBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the symbol association associated with the key, otherwise answer nil."

	| anAssoc |
	anAssoc := symbolDictionary associationAt: aKey otherwise: nil.
	anAssoc ifNotNil: [ ^ oneArgBlock cull: anAssoc ].
	^ nil
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_symbolDictionary: symbolDictionary at: key ifPresent: oneArgBlock ifAbsent: absentBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the value associated with the key, otherwise answer the value of absentBlock."

	| v |
	v := symbolDictionary at: key ifAbsent: [ ^absentBlock value ].
	^ oneArgBlock cull: v
%

! Class implementation for 'RwLoadedThing'

!		Class methods for 'RwLoadedThing'

category: 'accessing'
classmethod: RwLoadedThing
absentToken

	^AbsentToken
%

category: 'class initialization'
classmethod: RwLoadedThing
initialize
  "RwLoadedThing initialize"

  AbsentToken := '<absent>'
%

category: 'instance creation'
classmethod: RwLoadedThing
newNamed: aName

	^(self new)
		initialize;
		initializeForName: aName;
		yourself
%

!		Instance methods for 'RwLoadedThing'

category: 'accessing'
method: RwLoadedThing
absentToken

	^AbsentToken
%

category: 'private'
method: RwLoadedThing
definitionsFor: loadedThings

	| result |
	result := Dictionary new: loadedThings size.
	loadedThings
		do: [:loadedThing | result at: loadedThing key put: loadedThing asDefinition].
	^result
%

category: 'accessing'
method: RwLoadedThing
handle
	"Answer a reference to the platform-specific image object for which I hold information."

	^handle
%

category: 'accessing'
method: RwLoadedThing
handle: anObject
	"Set my reference to the platform-specific image object for which I hold information."

	self markPackageDirty.
	handle := anObject
%

category: 'initialization'
method: RwLoadedThing
initialize

	properties := Dictionary new
%

category: 'initialization'
method: RwLoadedThing
initializeForName: aName

	name := aName
%

category: 'accessing'
method: RwLoadedThing
loadedPackage

	^ self subclassResponsibility: #'loadedPackage'
%

category: 'accessing'
method: RwLoadedThing
loadedProject

	^ self loadedPackage loadedProject
%

category: 'accessing'
method: RwLoadedThing
name

	^name
%

category: 'accessing'
method: RwLoadedThing
name: aString

	self markPackageDirty.
	name := aString
%

category: 'accessing'
method: RwLoadedThing
prettyName

	^self name
%

category: 'printing'
method: RwLoadedThing
printOn: aStream

	super printOn: aStream.
	name
		ifNotNil: 
			[aStream
				space;
				nextPutAll: name]
%

category: 'private'
method: RwLoadedThing
propertiesForDefinition

	^properties copy
%

category: 'accessing'
method: RwLoadedThing
propertyAt: propertyName

	^properties at: propertyName ifAbsent: [AbsentToken]
%

category: 'accessing'
method: RwLoadedThing
propertyAt: propertyName ifAbsent: aBlock

	^properties at: propertyName ifAbsent: aBlock
%

category: 'accessing'
method: RwLoadedThing
propertyAt: propertyName put: aValue
	"Value should be a string"

	self markPackageDirty.
	^properties at: propertyName put: aValue
%

category: 'accessing'
method: RwLoadedThing
removeProperty: propertyName

	self markPackageDirty.
	^properties removeKey: propertyName ifAbsent: [AbsentToken]
%

category: 'accessing'
method: RwLoadedThing
setPropertiesTo: aDictionary

	properties := aDictionary copy
%

! Class implementation for 'RwLoadedClass'

!		Instance methods for 'RwLoadedClass'

category: 'definitions'
method: RwLoadedClass
asDefinition
	"Create a Definition corresponding to what I define in the image."
	^RwClassDefinition
		withProperties: self propertiesForDefinition
		classMethodDefinitions: self classMethodDefinitions
		instanceMethodDefinitions: self instanceMethodDefinitions
%

category: 'accessing'
method: RwLoadedClass
classCategory

	^self propertyAt: 'category' ifAbsent: [ '' ]
%

category: 'accessing'
method: RwLoadedClass
classClassVarNames

	^self propertyAt: 'classvars'
%

category: 'accessing'
method: RwLoadedClass
classComment

	^self propertyAt: 'comment' ifAbsent: ['']
%

category: 'accessing'
method: RwLoadedClass
classInstVarNames

	^self propertyAt: 'instvars'
%

category: 'private'
method: RwLoadedClass
classMethodDefinitions

	^self definitionsFor: loadedClassMethods
%

category: 'accessing'
method: RwLoadedClass
classPoolDictionaries

	^self propertyAt: 'pools'
%

category: 'accessing'
method: RwLoadedClass
classSuperclass

	^self propertyAt: 'superclass'
%

category: 'accessing'
method: RwLoadedClass
classSymbolDictionaryName

	^self propertyAt: 'gs_SymbolDictionary'
%

category: 'testing'
method: RwLoadedClass
includesSelector: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods includesKey: aSelector ]
		ifFalse: [ loadedInstanceMethods includesKey: aSelector ]
%

category: 'private'
method: RwLoadedClass
instanceMethodDefinitions

	^self definitionsFor: loadedInstanceMethods
%

category: 'testing'
method: RwLoadedClass
isEmpty

	^loadedInstanceMethods isEmpty and: [loadedClassMethods isEmpty]
%

category: 'testing'
method: RwLoadedClass
isLoadedClass

	^ true
%

category: 'testing'
method: RwLoadedClass
isLoadedClassExtension

	^ false
%

category: 'accessing'
method: RwLoadedClass
loadedClassMethods

	^ loadedClassMethods
%

category: 'accessing'
method: RwLoadedClass
loadedInstanceMethods 

	^ loadedInstanceMethods
%

category: 'enumeration'
method: RwLoadedClass
loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock
	loadedInstanceMethods
		valuesDo: [ :loadedMethod | 
			loadedInstanceMethodBlock
				cull: self loadedProject
				cull: self loadedPackage
				cull: self
				cull: loadedMethod ].
	loadedClassMethods
		valuesDo: [ :loadedMethod | 
			loadedClassMethodBlock
				cull: self loadedProject
				cull: self loadedPackage
				cull: self
				cull: loadedMethod ]
%

category: 'testing'
method: RwLoadedClass
loadedMethodAt: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods at: aSelector ifAbsent: [nil]]
		ifFalse: [ loadedInstanceMethods at: aSelector ifAbsent: [nil] ]
%

category: 'accessing'
method: RwLoadedClass
loadedPackage

	^loadedPackage
%

category: 'accessing'
method: RwLoadedClass
loadedPackage: aLoadedPackage

	loadedPackage := aLoadedPackage
%

category: 'private'
method: RwLoadedClass
markPackageDirty

	loadedPackage markDirty
%

category: 'accessing'
method: RwLoadedClass
packageName

	^loadedPackage name
%

category: 'other'
method: RwLoadedClass
prettyName

	^' class ', self name
%

category: 'properties'
method: RwLoadedClass
updatePropertiesFromClassDefinition: classDefinition
	"Copy all properties to the receiver's property dictionary that are not recorded in the class directly"

	| recordedPropertyNames |
	recordedPropertyNames := self _classBasedProperties asSet.
	classDefinition properties keysAndValuesDo: [:propertyName :propertyValue |
		(recordedPropertyNames includes: propertyName)
			ifFalse: [ self propertyAt: propertyName put: propertyValue ] ]
%

category: 'private'
method: RwLoadedClass
_classBasedProperties

	"Answer the list of properties that are derived from the class instance itself"

	^ #()
%

! Class implementation for 'RwGsLoadedSymbolDictClass'

!		Class methods for 'RwGsLoadedSymbolDictClass'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictClass
newForClass: aClass

	^self new initializeForClass: aClass
%

!		Instance methods for 'RwGsLoadedSymbolDictClass'

category: 'methods'
method: RwGsLoadedSymbolDictClass
addLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
addLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
addLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self addLoadedClassMethod: aLoadedMethod]
		ifFalse: [self addLoadedInstanceMethod: aLoadedMethod]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
handleClassDeletion

	"The class to which I refer has been deleted, so I must unregister myself.
	Normally, I will have a loadedPackage, but if something interrupted my initialization it might be nil."

	GsPackagePolicy currentOrNil
		ifNotNil: [ :pp | 
			pp
				removeAllMethodsFor: handle;
				removeAllMethodsFor: handle class ].
	(Rowan image loadedClassExtensionsForClass: handle)
		do: [ :loadedClassExtension | loadedClassExtension handleClassDeletion ].
	Rowan image removeLoadedClassExtensionsForClass: handle.
	self loadedPackage removeLoadedClass: self
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
handleClassDeletionOrNewVersion

	"The class is deleted if both:
	* its name no longer resolves to a class in the classHistory of the class I remember.
	* no class in the classHistory of the class I remember is accessible under its name.
	If my name no longer resolves to my class, but another class in its classHistory does resolve,
	consider it a class re-version or rename.
	Answer true if the class still exists, false if it has been deleted."

	| resolved thoseResolving |
	resolved := Rowan image resolveClassNamed: name.
	resolved == handle
		ifTrue: [ ^ true ].	"Has been deleted, renamed, or a new version under the same name.
	Answer false if deleted, set handle and answer true otherwise."
	thoseResolving := handle classHistory reverse
		select: [ :aClass | aClass == (Rowan image resolveClassNamed: aClass name) ].
	thoseResolving size = 0
		ifTrue: [ 
			self handleClassDeletion.
			^ false ].
	thoseResolving size > 1
		ifTrue: [ 
			RwNotification
				signal:
					'Class history with multiple "current" members found. One associated name is '
						, name ].
	handle := thoseResolving first.
	^ true
%

category: 'initialization'
method: RwGsLoadedSymbolDictClass
initialize

	super initialize.
	loadedInstanceMethods := KeyValueDictionary new.
	loadedClassMethods := KeyValueDictionary new
%

category: 'initialization'
method: RwGsLoadedSymbolDictClass
initializeForClass: aClass

	self initialize.
	self initializeForName: aClass name asString.
	handle := aClass
%

category: 'initialization'
method: RwGsLoadedSymbolDictClass
initializeForName: aClassName

	super initializeForName: aClassName.
	properties at: 'name' put: aClassName
%

category: 'accessing'
method: RwGsLoadedSymbolDictClass
key
	"Answer some token that will uniquely identify me relative to any other LoadedClass in the same package."

	^name
%

category: 'removing'
method: RwGsLoadedSymbolDictClass
removeFromLoaded: aPackageSymbolDictionary

	self disownFromLoaded: aPackageSymbolDictionary.
	self handleClassDeletion
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
removeLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in loadedClass']
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
removeLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in loadedClass']
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
removeLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self removeLoadedClassMethod: aLoadedMethod]
		ifFalse: [self removeLoadedInstanceMethod: aLoadedMethod]
%

category: 'private'
method: RwGsLoadedSymbolDictClass
reregisterLoadedClassMethods: aDictionary
	"transfer the loaded methods in aDictionary to the receiver"

	aDictionary do: [ :loadedMethod | loadedMethod loadedClass: self ].
	loadedClassMethods := aDictionary
%

category: 'private'
method: RwGsLoadedSymbolDictClass
reregisterLoadedInstanceMethods: aDictionary
	"transfer the loaded methods in aDictionary to the receiver"

	aDictionary do: [ :loadedMethod | loadedMethod loadedClass: self ].
	loadedInstanceMethods := aDictionary
%

category: 'private'
method: RwGsLoadedSymbolDictClass
symbolDictionaryName: aName

	self propertyAt: 'gs_SymbolDictionary' put: aName asString
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateCategoryFromClass

	| propertyName oldValue newValue absentToken |
	propertyName := 'category'.	"needs to be listed in _classBasedProperties method"
	absentToken := self absentToken.
	oldValue := self propertyAt: propertyName.
	newValue := handle _classCategory ifNil: [ absentToken ].
	(newValue ~~ absentToken and: [ newValue isEmpty ])
		ifTrue: [ newValue := absentToken ].	"Absent token must be compared by identity, because a comment of '<absent>' would be equal to no comment."
	(oldValue == absentToken | (newValue == absentToken)
		ifTrue: [ oldValue == newValue ]
		ifFalse: [ oldValue = newValue ])
		ifFalse: [ 
			newValue == absentToken
				ifTrue: [ self removeProperty: propertyName ]
				ifFalse: [ self propertyAt: propertyName put: newValue ] ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassInstvarNamesFromClass
	"Order of instvars does not matter to Cypress (at least not in GemStone) so we keep the instvar names sorted."

	| propertyName oldNames newNames |
	propertyName := 'classinstvars'.	"needs to be listed in _classBasedProperties method"
	oldNames := self propertyAt: propertyName.
	newNames := handle class instVarNames collect: [:each | each asString].
	oldNames = newNames ifFalse: [self propertyAt: propertyName put: newNames]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassNameFromClass

	| oldName newName |
	oldName := name.
	newName := handle name asString.
	oldName = newName
		ifFalse: 
			[self name: newName.
			self propertyAt: 'name' put: name] 	"needs to be listed in _classBasedProperties method"
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassTypeFromClass
	"For GemStone, the valid values are:
	byteSubclass
	variable
	normal for non-indexable pointer object"

	"Must be in-synch with RwClassDefinition>>_updateClassTypeFromClass:"

	| propertyName oldValue newValue |
	propertyName := 'type'.	"needs to be listed in _classBasedProperties method"
	oldValue := self propertyAt: propertyName.
	newValue := handle rwClassType.

	oldValue = newValue
		ifFalse: [ self propertyAt: propertyName put: newValue ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassVariableNamesFromClass
	"Order of variable names does not matter to Cypress (at least not for GemStone) so we keep the names sorted."

	| propertyName oldNames newNames |
	propertyName := 'classvars'.	"needs to be listed in _classBasedProperties method"
	oldNames := self propertyAt: propertyName.
	newNames := (handle classVarNames collect: [:each | each asString])
				asSortedCollection asArray.
	oldNames = newNames ifFalse: [self propertyAt: propertyName put: newNames]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateCommentFromClass

	| propertyName oldValue newValue absentToken |
	propertyName := 'comment'.	"needs to be listed in _classBasedProperties method"
	absentToken := self absentToken.
	oldValue := self propertyAt: propertyName.
	(oldValue ~~ absentToken and: [oldValue isEmpty])
		ifTrue: [oldValue := absentToken].
	newValue := (handle _extraDictAt: #comment) ifNil: [absentToken].
	(newValue ~~ absentToken and: [newValue isEmpty])
		ifTrue: [newValue := absentToken].

	"Absent token must be compared by identity, because a comment of '<absent>' would be equal to no comment."
	(oldValue == absentToken | (newValue == absentToken)
		ifTrue: [oldValue == newValue]
		ifFalse: [oldValue = newValue])
			ifFalse: 
				[newValue == absentToken
					ifTrue: [self removeProperty: propertyName]
					ifFalse: [self propertyAt: propertyName put: newValue]]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateConstraintsFromClass
	| propertyName oldValue newValue sortedConstraints |
	propertyName := 'gs_constraints'.	"needs to be listed in _classBasedProperties method"
	oldValue := self propertyAt: propertyName.
	sortedConstraints := handle _rwSortedConstraints.
	(sortedConstraints isKindOf: Array ) 
		ifTrue: [
			newValue := (sortedConstraints collect: [:ar | 
					(ar isKindOf: Array )
						ifTrue: [ {(ar at: 1) asString . (ar at: 2) name asString } ]
						ifFalse: [ 
							"varyingConstraint"
							ar name asString ] ]) asArray.
			newValue isEmpty ifTrue: [newValue := self absentToken] ]
		ifFalse: [
			newValue :=  sortedConstraints 
				ifNil: [ self absentToken ]
				ifNotNil: [ sortedConstraints ] ].

	"Since the absent token is not equal to any other valid value, we can skip the identity check in this case."
	oldValue = newValue
		ifFalse: 
			[newValue == self absentToken
				ifTrue: [self removeProperty: propertyName]
				ifFalse: [self propertyAt: propertyName put: newValue]]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateInstvarNamesFromClass
	"Order of instvars does not matter to Cypress (at least not in GemStone) so we keep the instvar names sorted."

	| propertyName oldNames newNames |
	propertyName := 'instvars'.	"needs to be listed in _classBasedProperties method"
	oldNames := self propertyAt: propertyName.
	newNames := handle instVarNames collect: [:each | each asString].
	oldNames = newNames ifFalse: [self propertyAt: propertyName put: newNames]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateOptionsFromClass
	"Options are GemStone-specific. If the class has no options, the property is absent.
	Otherwise, the property is a sorted array of strings. The valid values are:

	dbTransient
	disallowGciStore
	instancesInvariant
	instancesNonPersistent
	modifiable
	subclassesDisallowed
	traverseByCallback

	Not all combinations are legal, but we don't have to worry about that here, since we're getting the values
	from the image, and the image is trusted to only have valid values."

	| propertyName oldValue newValue |
	propertyName := 'gs_options'.	"needs to be listed in _classBasedProperties method"
	oldValue := self propertyAt: propertyName.	"TODO, may need changes to result of _rwOptionsArray , see RwClassDefinition >> _updateOptionsFromClass "
	newValue := (handle _rwOptionsArray collect: [ :option | option asString ])
		asArray.
	newValue isEmpty
		ifTrue: [ newValue := self absentToken ].	"Since the absent token is not equal to any other valid value, we can skip the identity check in this case."
	oldValue = newValue
		ifFalse: [ 
			newValue == self absentToken
				ifTrue: [ self removeProperty: propertyName ]
				ifFalse: [ self propertyAt: propertyName put: newValue ] ].
	handle _rwReservedOop
		ifNotNil: [ :resOop | self propertyAt: 'gs_reservedoop' put: resOop asString ]
		ifNil: [ self removeProperty: 'gs_reservedoop' ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updatePoolDictionaryNamesFromClass
	"Order of pool dictionaries *does* matter in GemStone, so we keep the names in the order given in the image."

	| propertyName oldNames newNames |
	propertyName := 'pools'.	"needs to be listed in _classBasedProperties method"
	oldNames := self propertyAt: propertyName.
	newNames := (handle sharedPools collect: [ :each | each name asString ])
		asArray.
	oldNames = newNames
		ifFalse: [ self propertyAt: propertyName put: newNames ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updatePropertiesFromClassFor: aSymbolDictionaryRegistry

	"Update my properties from the class. Leave unknown properties alone, they may apply to another platform."

	self
		updateSymbolDictionaryFromClassFor:
				aSymbolDictionaryRegistry _symbolDictionary;
		updateClassNameFromClass;
		updateSuperclassNameFromClass;
		updateInstvarNamesFromClass;
		updateClassInstvarNamesFromClass;
		updateClassVariableNamesFromClass;
		updatePoolDictionaryNamesFromClass;
		updateClassTypeFromClass;
		updateOptionsFromClass;
		updateConstraintsFromClass;
		updateCommentFromClass;
		updateCategoryFromClass
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateSuperclassNameFromClass
  | oldName newName |
  oldName := self propertyAt: 'superclass'.	"needs to be listed in _classBasedProperties method"
  newName := handle superclass
    ifNil: [ 'nil' ]
    ifNotNil: [ :superclass | superclass name asString ].
  oldName = newName
    ifFalse: [ self propertyAt: 'superclass' put: newName ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateSymbolDictionaryFromClassFor: aSymbolDictionary

	| newName oldName |
	newName := aSymbolDictionary name.
	oldName := self propertyAt: 'gs_SymbolDictionary'.	"needs to be listed in _classBasedProperties method"
	oldName = newName
		ifFalse: [ self symbolDictionaryName: newName ]
%

category: 'private'
method: RwGsLoadedSymbolDictClass
_classBasedProperties

	"Answer the list of properties that are derived from the class instance itself"

	^ #(  'category' 'classinstvars'  'name' 'type' 'classvars' 'comment' 'gs_constraints' 'instvars'  'gs_options' 
			'pools' 'superclass' 'gs_SymbolDictionary' )
%

! Class implementation for 'RwLoadedClassExtension'

!		Instance methods for 'RwLoadedClassExtension'

category: 'definitions'
method: RwLoadedClassExtension
asDefinition
	"Create a Definition corresponding to what I define in the image."
	^RwClassExtensionDefinition
		withProperties: self propertiesForDefinition
		classMethodDefinitions: self classMethodDefinitions
		instanceMethodDefinitions: self instanceMethodDefinitions
%

category: 'private'
method: RwLoadedClassExtension
classMethodDefinitions

	^self definitionsFor: loadedClassMethods
%

category: 'testing'
method: RwLoadedClassExtension
includesSelector: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods includesKey: aSelector ]
		ifFalse: [ loadedInstanceMethods includesKey: aSelector ]
%

category: 'private'
method: RwLoadedClassExtension
instanceMethodDefinitions

	^self definitionsFor: loadedInstanceMethods
%

category: 'testing'
method: RwLoadedClassExtension
isEmpty

	^loadedInstanceMethods isEmpty and: [loadedClassMethods isEmpty]
%

category: 'testing'
method: RwLoadedClassExtension
isLoadedClass

	^ false
%

category: 'testing'
method: RwLoadedClassExtension
isLoadedClassExtension

	^ true
%

category: 'accessing'
method: RwLoadedClassExtension
loadedClassMethods

	^ loadedClassMethods
%

category: 'accessing'
method: RwLoadedClassExtension
loadedInstanceMethods 

	^ loadedInstanceMethods
%

category: 'enumeration'
method: RwLoadedClassExtension
loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock
	loadedInstanceMethods
		valuesDo: [ :loadedMethod | 
			loadedInstanceMethodBlock
				cull: self loadedProject
				cull: self loadedPackage
				cull: self
				cull: loadedMethod ].
	loadedClassMethods
		valuesDo: [ :loadedMethod | 
			loadedClassMethodBlock
				cull: self loadedProject
				cull: self loadedPackage
				cull: self
				cull: loadedMethod ]
%

category: 'private'
method: RwLoadedClassExtension
loadedMethodAt: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods at: aSelector ifAbsent: [nil]]
		ifFalse: [ loadedInstanceMethods at: aSelector ifAbsent: [nil] ]
%

category: 'accessing'
method: RwLoadedClassExtension
loadedPackage

	^loadedPackage
%

category: 'accessing'
method: RwLoadedClassExtension
loadedPackage: aLoadedPackage

	loadedPackage := aLoadedPackage
%

category: 'private'
method: RwLoadedClassExtension
markPackageDirty

	loadedPackage markDirty
%

category: 'accessing'
method: RwLoadedClassExtension
packageName

	^loadedPackage name
%

! Class implementation for 'RwGsLoadedSymbolDictClassExtension'

!		Class methods for 'RwGsLoadedSymbolDictClassExtension'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictClassExtension
newForClass: aClass inPackage: aLoadedPackage

	^ self new initializeForClass: aClass inPackage: aLoadedPackage
%

!		Instance methods for 'RwGsLoadedSymbolDictClassExtension'

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
addLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
addLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
addLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self addLoadedClassMethod: aLoadedMethod]
		ifFalse: [self addLoadedInstanceMethod: aLoadedMethod]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClassExtension
handleClassDeletion

	"The class to which I refer is or has been deleted. Clean up the loaded extension methods.
		I expect the caller to remove me from the registry."

	loadedInstanceMethods values , loadedClassMethods values
		do: [ :loadedMethod | loadedMethod handleClassDeletion ].
	self loadedPackage removeLoadedClassExtension: self
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClassExtension
handleClassDeletionOrNewVersion
	"The class is deleted if both:
	* its name no longer resolves to a class in the classHistory of the class I remember.
	* no class in the classHistory of the class I remember is accessible under its name.
	If my name no longer resolves to my class, but another class in its classHistory does resolve,
	consider it a class re-version or rename.
	Answer true if the class still exists, false if it has been deleted."

	| resolved thoseResolving |
	resolved := Rowan image resolveClassNamed: name.
	resolved == handle
		ifTrue: [ ^ true ].	"Has been deleted, renamed, or a new version under the same name.
	Answer false if deleted, set handle and answer true otherwise."
	thoseResolving := handle classHistory reverse
		select: [ :aClass | aClass == (Rowan image resolveClassNamed: aClass name) ].
	thoseResolving size = 0
		ifTrue: [ 
			self handleClassDeletion.
			^ false ].
	thoseResolving size > 1
		ifTrue: [ 
			RwNotification
				signal:
					'Class history with multiple "current" members found. One associated name is '
						, name ].
	handle := thoseResolving first.
	^ true
%

category: 'initialization'
method: RwGsLoadedSymbolDictClassExtension
initialize

	super initialize.
	loadedInstanceMethods := KeyValueDictionary new.
	loadedClassMethods := KeyValueDictionary new
%

category: 'initialization'
method: RwGsLoadedSymbolDictClassExtension
initializeForClass: aClass inPackage: aLoadedPackage

	self initialize.
	name := aClass name asString.
	handle := aClass.
	aLoadedPackage addLoadedClassExtension: self.
	self propertyAt: 'name' put: name
%

category: 'accessing'
method: RwGsLoadedSymbolDictClassExtension
key
	"Answer some token that will uniquely identify me relative to any other LoadedExtendedClass in the same package."

	^name
%

category: 'removing'
method: RwGsLoadedSymbolDictClassExtension
moveFrom: fromRegistryInstance
	"class extensions must be removed from old package, additions are handled elsewhere"

	"https://github.com/dalehenrich/Rowan/issues/495"

	fromRegistryInstance unregisterLoadedClassExtension: self forClass: handle
%

category: 'removing'
method: RwGsLoadedSymbolDictClassExtension
moveTo: toRegistryInstance
	"class extensions must be removed from old package, additions are handled elsewhere"

	"https://github.com/dalehenrich/Rowan/issues/495"

	toRegistryInstance registerLoadedClassExtension: self forClass: handle
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
removeLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in LoadedClassExtension']
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
removeLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in LoadedClassExtension']
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
removeLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self removeLoadedClassMethod: aLoadedMethod]
		ifFalse: [self removeLoadedInstanceMethod: aLoadedMethod]
%

category: 'private'
method: RwGsLoadedSymbolDictClassExtension
reregisterLoadedClassMethods: aDictionary
	"transfer the loaded methods in aDictionary to the receiver"

	aDictionary do: [ :loadedMethod | loadedMethod loadedClass: self ].
	loadedClassMethods := aDictionary
%

category: 'private'
method: RwGsLoadedSymbolDictClassExtension
reregisterLoadedInstanceMethods: aDictionary
	"transfer the loaded methods in aDictionary to the receiver"

	aDictionary do: [ :loadedMethod | loadedMethod loadedClass: self ].
	loadedInstanceMethods := aDictionary
%

! Class implementation for 'RwLoadedMethod'

!		Instance methods for 'RwLoadedMethod'

category: 'definitions'
method: RwLoadedMethod
asDefinition
	"Create a Definition corresponding to what I define in the image."

	^RwMethodDefinition withProperties: self propertiesForDefinition
		source: self source
%

category: 'accessing'
method: RwLoadedMethod
classIsMeta

	^classIsMeta
%

category: 'queries'
method: RwLoadedMethod
loadedClass

	^loadedClass
%

category: 'accessing'
method: RwLoadedMethod
loadedClass: aLoadedClass

	loadedClass := aLoadedClass
%

category: 'queries'
method: RwLoadedMethod
loadedPackage

	^self loadedClass loadedPackage
%

category: 'private'
method: RwLoadedMethod
markPackageDirty
	"LoadedClass may still be nil if we're creating a new LoadedMethod."

	loadedClass ifNotNil: [loadedClass markPackageDirty]
%

category: 'accessing'
method: RwLoadedMethod
methodCategory

	^ properties at: 'protocol'
%

category: 'definitions'
method: RwLoadedMethod
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at: 'selector' put: name.
	^props
%

category: 'accessing'
method: RwLoadedMethod
selector

	^ properties at: 'selector'
%

category: 'accessing'
method: RwLoadedMethod
source

	self subclassResponsibility
%

! Class implementation for 'RwGsLoadedSymbolDictMethod'

!		Class methods for 'RwGsLoadedSymbolDictMethod'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictMethod
forMethod: aGsNMethod

	| instance |
	instance := self newNamed: aGsNMethod selector.
	instance
		handle: aGsNMethod;
		updateFromHandle.
	^ instance
%

!		Instance methods for 'RwGsLoadedSymbolDictMethod'

category: 'private-updating'
method: RwGsLoadedSymbolDictMethod
handleClassDeletion

	"The class to which I refer has been deleted, so I must unregister myself."

	self unpackageMethod
%

category: 'accessing'
method: RwGsLoadedSymbolDictMethod
key

	"Answer some token that will uniquely identify me relative to any other LoadedMethod in the same LoadedClass."

	^ name	"This is inadequate because the same selector can be defined in both class and metaclass?"
%

category: 'printing'
method: RwGsLoadedSymbolDictMethod
printOn: aStream

	super printOn: aStream.
	name
		ifNotNil: 
			[aStream
				space;
				nextPutAll: handle inClass printString, ' ( ', handle inClass asOop asString, ' )' ]
%

category: 'accessing'
method: RwGsLoadedSymbolDictMethod
source

	^handle sourceString copy
%

category: 'private-updating'
method: RwGsLoadedSymbolDictMethod
unpackageMethod

	"Remove the loaded method from the package structure - turn the method into an unpackaged method"

	Rowan image removeLoadedMethodForCompileMethod: handle
%

category: 'private-updating'
method: RwGsLoadedSymbolDictMethod
updateForProtocolChange
	"Check to see whether I'm in a different protocol. If I am, that could change which package I'm in and I need to update that."

	| oldProtocol newProtocol |
	oldProtocol := self propertyAt: 'protocol'.
	newProtocol := (handle inClass categoryOfSelector: handle selector)
				asString.

	"Must test for AbsentToken by identity, or a new protocol of '<absent>' would not  be detected."
	oldProtocol == AbsentToken | (oldProtocol ~= newProtocol)
		ifTrue: [	self propertyAt: 'protocol' put: newProtocol ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictMethod
updateFromHandle

	"update method properties: selector and protocol, and classIsMeta"

	self updateForProtocolChange.
	self propertyAt: 'selector' put: handle selector asSymbol.
	classIsMeta := handle inClass isMeta
%

! Class implementation for 'RwLoadedPackage'

!		Instance methods for 'RwLoadedPackage'

category: 'accessing'
method: RwLoadedPackage
addLoadedClass: aLoadedClass

	self markDirty.
	loadedClasses at: aLoadedClass key put: aLoadedClass.
	aLoadedClass loadedPackage: self
%

category: 'accessing'
method: RwLoadedPackage
addLoadedClassExtension: aLoadedClassExtension

	self markDirty.
	loadedClassExtensions at: aLoadedClassExtension key
		put: aLoadedClassExtension.
	aLoadedClassExtension loadedPackage: self
%

category: 'definitions'
method: RwLoadedPackage
asDefinition
	"Create a Definition corresponding to what I define in the image."

	^RwPackageDefinition
		withProperties: self propertiesForDefinition
		classDefinitions: self classDefinitions
		classExtensions: self classExtensionDefinitions
%

category: 'other'
method: RwLoadedPackage
asExtensionName

	^'*', self name asLowercase
%

category: 'private'
method: RwLoadedPackage
classDefinitions
	"Create definitions from all of the classes I define, and answer the collection of them"

	^self definitionsFor: loadedClasses
%

category: 'private'
method: RwLoadedPackage
classExtensionDefinitions
	"Create definitions from all of the class extensions I define, and answer the collection of them"

	^self definitionsFor: loadedClassExtensions
%

category: 'queries'
method: RwLoadedPackage
classOrExtensionForClassNamed: className ifAbsent: absentBlock

	^loadedClasses at: className
		ifAbsent: [loadedClassExtensions at: className ifAbsent: absentBlock]
%

category: 'testing'
method: RwLoadedPackage
isDirty
	"a project is dirty if it has changes that are not written to disk, or it's packages 
		have changes that are not written to  disk."

	^ isDirty
%

category: 'testing'
method: RwLoadedPackage
isEmpty

	^loadedClasses isEmpty and: [loadedClassExtensions isEmpty]
%

category: 'accessing'
method: RwLoadedPackage
key

	^ name
%

category: 'enumeration'
method: RwLoadedPackage
loadedClassedDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedClasses
		valuesDo: [ :loadedClass | 
			loadedClassBlock cull: self loadedProject cull: self cull: loadedClass.
			loadedClass
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ].
	loadedClassExtensions
		valuesDo: [ :loadedClassExtension | 
			loadedClassExtensionBlock
				cull: self loadedProject
				cull: self
				cull: loadedClassExtension.
			loadedClassExtension
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ]
%

category: 'accessing'
method: RwLoadedPackage
loadedClasses
	^loadedClasses
%

category: 'enumeration'
method: RwLoadedPackage
loadedClassesDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock 

	loadedClasses
		valuesDo: [ :loadedClass | 
			loadedClassBlock 
				cull: loadedClass
				cull: self loadedProject 
				cull: self].
	loadedClassExtensions
		valuesDo: [ :loadedClassExtension | 
			loadedClassExtensionBlock
				cull: loadedClassExtension
				cull: self loadedProject
				cull: self ]
%

category: 'accessing'
method: RwLoadedPackage
loadedClassExtensions
	^loadedClassExtensions
%

category: 'accessing'
method: RwLoadedPackage
loadedProject

   ^loadedProject
%

category: 'accessing'
method: RwLoadedPackage
loadedProject: anObject

   loadedProject := anObject
%

category: 'private'
method: RwLoadedPackage
markDirty
	"I have been changed independent of a change to my repository, and therefore may be out of sync with my repository"

	isDirty := true
%

category: 'private'
method: RwLoadedPackage
markNotDirty
	"I have been changed to be consistent with my source, so mark not dirty."

	isDirty := false
%

category: 'private'
method: RwLoadedPackage
markPackageDirty

	self markDirty
%

category: 'other'
method: RwLoadedPackage
prettyName

	^' package ', self name
%

category: 'accessing'
method: RwLoadedPackage
projectName

	^ loadedProject name
%

category: 'accessing'
method: RwLoadedPackage
removeLoadedClass: aLoadedClass

	self markDirty.
	loadedClasses removeKey: aLoadedClass key.
	aLoadedClass loadedPackage: nil
%

category: 'accessing'
method: RwLoadedPackage
removeLoadedClassExtension: aLoadedClassExtension

	self markDirty.
	loadedClassExtensions removeKey: aLoadedClassExtension key.
	aLoadedClassExtension loadedPackage: nil
%

! Class implementation for 'RwGsLoadedSymbolDictPackage'

!		Instance methods for 'RwGsLoadedSymbolDictPackage'

category: 'queries'
method: RwGsLoadedSymbolDictPackage
classOrExtensionForClass: behavior ifAbsent: absentBlock

	| className |
	className := behavior thisClass name asString.
	^ self classOrExtensionForClassNamed: className ifAbsent: absentBlock
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
classOrExtensionForClassNamed: className ifAbsent: absentBlock

	^ loadedClasses
		at: className
		ifAbsent: [ loadedClassExtensions at: className ifAbsent: absentBlock ]
%

category: 'initialization'
method: RwGsLoadedSymbolDictPackage
initialize

	super initialize.
	loadedClasses := KeyValueDictionary new.
	loadedClassExtensions := KeyValueDictionary new.
	"A new package is dirty until it has been shown to be identical to a repository."
	isDirty := true
%

category: 'initialization'
method: RwGsLoadedSymbolDictPackage
initializeForName: aName

	super initializeForName: aName.
	properties at: 'name' put: aName
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
loadedClassExtensionForClass: aClass ifAbsent: absentBlock

	"If there is an existing extension for the given (non-meta) class in this package, answer it, otherwise invoke absentBlock."

	^ loadedClassExtensions
		at: aClass thisClass name asString
		ifAbsent: absentBlock
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
loadedClassForClass: aClass ifAbsent: absentBlock

	"If there is an existing loadedClass for the given (non-meta) class in this package, answer it, otherwise invoke absentBlock.."

	^ loadedClasses at: aClass thisClass name asString ifAbsent: absentBlock
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
loadedClassOrClassExtensionForClass: aClass ifAbsent: absentBlock

	"If there is an existing loaded class or loaded class extesnion for the given (non-meta) class in this package, answer it, otherwise invoke absentBlock."

	^ loadedClasses
		at: aClass thisClass name asString
		ifAbsent: [ self loadedClassExtensionForClass: aClass ifAbsent: absentBlock ]
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
packageSymbolDictionaryName

	^self propertyAt: 'gs_SymbolDictionary'
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
packageSymbolDictionaryName: symDictName
	self propertyAt: 'gs_SymbolDictionary' put: symDictName asString
%

category: 'private'
method: RwGsLoadedSymbolDictPackage
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at:  'gs_SymbolDictionary' put: (Rowan image loadedRegistryForPackageNamed: self name) _symbolDictionary name asString.
	^ props
%

category: 'private'
method: RwGsLoadedSymbolDictPackage
updatePropertiesFromRegistryFor: aSymbolDictionaryRegistry
	"Update my properties from the symbol dictionary registry."

	| newName oldName |
	newName := aSymbolDictionaryRegistry _symbolDictionary name.
	oldName := self propertyAt: 'gs_SymbolDictionary'.
	oldName = newName
		ifFalse: [ self packageSymbolDictionaryName: newName ]
%

! Class implementation for 'RwLoadedProject'

!		Class methods for 'RwLoadedProject'

category: 'accessing'
classmethod: RwLoadedProject
_projectDefinitionPlatformConditionalAttributesKey
	"The value of the property key preserves the platform conditional attributes used to read the project from disk"

	^ '_Project_Definition_PlatformConditionalAttributes'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectDefinitionSourceKey
	"The value of the property key indicates which source the project definition was derived from.
		Currently used when deciding whether to change the loaded commit id, during a load ... 
		if the load is derived from a loaded project (RwLoadedProject class _projectDefinitionSourceValue), 
		then it isn't necessary to update the loaded commit id."

	^ '_Project_Definition_Source'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectDiskDefinitionSourceValue
	"This value of the property key indicates that the source of the project definition was loaded from disk, 
		then it isn't necessary to update the loaded commit id."

	^ 'loaded from disk'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectLoadedDefinitionSourceValue
	"This value of the property key indicates that the source of the project definition was derived from
		a loaded project, then it isn't necessary to update the loaded commit id."

	^ 'loaded project'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectLoadedDefinitionSourceWithDependentProjectsValue
	"This value of the property key indicates that the source of the project definition was loaded from disk, 
		however, the project has dependent projects that will need to be reread from disk on load."

	^ 'loaded from disk with dependent projects'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectModifiedProjectSourceValue
	"This value of the property key indicates that the source of the project definition is newly created project or explicitly modified, so we don't want to read project from disk on load."

	^ 'modified project'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectUnknownDefinitionSourceValue
	"This value of the property key indicates that the source of the project definition is unknown."

	^ 'unknown'
%

!		Instance methods for 'RwLoadedProject'

category: 'accessing'
method: RwLoadedProject
addLoadedPackage: aLoadedPackage

	self markDirty.
	loadedPackages at: aLoadedPackage key put: aLoadedPackage.
	aLoadedPackage loadedProject: self
%

category: 'actions'
method: RwLoadedProject
audit
	"run audit on the receiver"

	^ Rowan projectTools audit auditForProject: self
%

category: 'commit log'
method: RwLoadedProject
commitLog: logLimit

	self subclassResponsibility: #commitLog:
%

category: 'initialization'
method: RwLoadedProject
initialize

	super initialize.
	loadedPackages := KeyValueDictionary new.
	isDirty := true. "a project is dirty if it has changes that are not written to disk"
%

category: 'testing'
method: RwLoadedProject
isDirty
	"a project is dirty if it has changes that are not written to disk, or it's packages have changes that are not written to  disk."

	isDirty
		ifTrue: [ ^ true ].
	self loadedPackages
		do: [ :loadedPackage | 
			loadedPackage isDirty
				ifTrue: [ ^ true ] ].
	^ false
%

category: 'testing'
method: RwLoadedProject
isEmpty

	^ loadedPackages isEmpty
%

category: 'accessing'
method: RwLoadedProject
key

	^ name
%

category: 'actions'
method: RwLoadedProject
load
	"load the receiver into the image"

	| projectDefinition projectSetDefinition readProjectDefinition |
	projectDefinition := self asDefinition.
	projectSetDefinition := projectDefinition read.
	readProjectDefinition := projectSetDefinition projectNamed: projectDefinition name.
	readProjectDefinition == projectDefinition 
		ifFalse: [
			"https://github.com/GemTalk/Rowan/issues/488"
			self error: 'expected to update the projectDefinition in-place' ].
	^ projectDefinition _loadTool loadProjectSetDefinition: projectSetDefinition
%

category: 'actions'
method: RwLoadedProject
load: instanceMigrator
	"load the receiver into the image"

	| projectDefinition projectSetDefinition readProjectDefinition |
	projectDefinition := self asDefinition.
	projectSetDefinition := projectDefinition read.
	readProjectDefinition := projectSetDefinition projectNamed: projectDefinition name.
	readProjectDefinition == projectDefinition 
		ifFalse: [
			"https://github.com/GemTalk/Rowan/issues/488"
			self halt: 'expected to update the projectDefinition in-place' ].
	^ projectDefinition _loadTool loadProjectSetDefinition: projectSetDefinition instanceMigrator: instanceMigrator
%

category: 'accessing'
method: RwLoadedProject
loadedCommitId

	self subclassResponsibility: #loadedCommitId
%

category: 'accessing'
method: RwLoadedProject
loadedPackageDefinitions

	"Create definitions from all of the packages I define, and answer the collection of them"

	^ self definitionsFor: loadedPackages
%

category: 'accessing'
method: RwLoadedProject
loadedPackages

	^ loadedPackages
%

category: 'accessing'
method: RwLoadedProject
loadedPackages: anObject

   loadedPackages := anObject
%

category: 'enumeration'
method: RwLoadedProject
loadedPackagesDo: loadedPackageBlock loadedClassedDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedPackages
		valuesDo: [ :loadedPackage | 
			loadedPackageBlock cull: self cull: loadedPackage.
			loadedPackage
				loadedClassedDo: loadedClassBlock
				loadedClassExtensionsDo: loadedClassExtensionBlock
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ]
%

category: 'accessing'
method: RwLoadedProject
loadedProject

	^ self
%

category: 'accessing'
method: RwLoadedProject
loadSpecification

	^ handle
%

category: 'private'
method: RwLoadedProject
markDirty
	"I have been changed independent of a change to my repository, and therefore may be out of sync with my repository"

	isDirty := true
%

category: 'private'
method: RwLoadedProject
markNotDirty
	"I have been changed to be consistent with my source, so mark not dirty."

	isDirty := false
%

category: 'accessing'
method: RwLoadedProject
packageNames

	"Return list of package names in the receiver"

	^ self loadedPackages keys asArray
%

category: 'accessing'
method: RwLoadedProject
prettyName

	^' project ' , self name
%

category: 'accessing'
method: RwLoadedProject
projectDefinitionSourceProperty

	^ properties at: RwLoadedProject _projectDefinitionSourceKey ifAbsent: [ RwLoadedProject _projectUnknownDefinitionSourceValue ]
%

category: 'accessing'
method: RwLoadedProject
projectUrl

	"Return the projectUrl used to clone the project"

	^ self specification projectUrl
%

category: 'definitions'
method: RwLoadedProject
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at: 'name' put: name.
	props at: self class _projectDefinitionSourceKey put: self class _projectLoadedDefinitionSourceValue.
	^ props
%

category: 'accessing'
method: RwLoadedProject
removeLoadedPackage: aLoadedPackage

	self markDirty.
	loadedPackages removeKey: aLoadedPackage key
%

category: 'accessing'
method: RwLoadedProject
repositoryCommitId

	self subclassResponsibility: #repositoryCommitId
%

category: 'properties'
method: RwLoadedProject
specification

	^ properties at: 'spec'
%

category: 'actions'
method: RwLoadedProject
unload
	"unload the receiver from the image"

	| projectDefinition |
	projectDefinition := self asDefinition.
	^ projectDefinition _deleteTool deleteProjectDefinition: projectDefinition
%

category: 'testing'
method: RwLoadedProject
useGit

	^ self subclassResponsibility: #useGit
%

! Class implementation for 'RwGsLoadedSymbolDictResolvedProjectV2'

!		Class methods for 'RwGsLoadedSymbolDictResolvedProjectV2'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictResolvedProjectV2
newForResolvedProject: aResolvedProject
	^ self new
		initialize;
		initializeForResolvedProject: aResolvedProject;
		yourself
%

!		Instance methods for 'RwGsLoadedSymbolDictResolvedProjectV2'

category: 'definitions'
method: RwGsLoadedSymbolDictResolvedProjectV2
asDefinition
	"Create a Definition corresponding to what I define in the image."

	| resolvedProject |
	resolvedProject := (RwResolvedProjectV2
		basicLoadSpecification: handle _loadSpecification copy)
		packages: self loadedPackageDefinitions;
		yourself.
	resolvedProject _projectRepository: handle _projectRepository copy.
	resolvedProject _projectSpecification: handle _projectSpecification copy.
	resolvedProject _projectDefinition
		projectDefinitionSourceProperty:
			RwLoadedProject _projectLoadedDefinitionSourceValue;
		projectDefinitionPlatformConditionalAttributes:
				handle projectDefinitionPlatformConditionalAttributes copy;
		yourself.
	resolvedProject _projectDefinition components: handle _projectStructure copy.	"temporary hack until RwProjectStructure gets defined"
	^ resolvedProject
%

category: 'testing'
method: RwGsLoadedSymbolDictResolvedProjectV2
canCommit

	^ self resolvedProject canCommit
%

category: 'actions'
method: RwGsLoadedSymbolDictResolvedProjectV2
checkout: revision
	^ self resolvedProject repository checkout: revision
%

category: 'queries'
method: RwGsLoadedSymbolDictResolvedProjectV2
commitId

	^ self resolvedProject commitId
%

category: 'commit log'
method: RwGsLoadedSymbolDictResolvedProjectV2
commitLog: logLimit

	^ self resolvedProject commitLog: logLimit
%

category: 'querying'
method: RwGsLoadedSymbolDictResolvedProjectV2
componentForPackageNamed: packageName
	"Answer nil if no component found"

	^ self components componentForPackageNamed: packageName
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
componentNames

	^ handle componentNames
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
components

	^ handle _projectStructure
%

category: 'properties'
method: RwGsLoadedSymbolDictResolvedProjectV2
defaultSymbolDictName: symDictName

	self resolvedProject defaultSymbolDictName: symDictName
%

category: 'initialization'
method: RwGsLoadedSymbolDictResolvedProjectV2
initializeForResolvedProject: aResolvedProject
	self initializeForName: aResolvedProject projectName.
	handle := aResolvedProject copyForLoadedProject
%

category: 'actions'
method: RwGsLoadedSymbolDictResolvedProjectV2
load
	"
		load only the receiver into the image. Required projects for the receiver are only loaded if they are not already 
			present in the image.

		To explicitly load the receiver AND required projects, construct a project set containing projects to be loaded 
			and send #load to the project set.
	"

	^ self asDefinition load
%

category: 'actions'
method: RwGsLoadedSymbolDictResolvedProjectV2
load: instanceMigrator
	"
		load only the receiver into the image, using the specified instance migrator. Required projects for the receiver are only 
			loaded if they are not already present in the image.
	"

	^ self asDefinition load: instanceMigrator
%

category: 'properties'
method: RwGsLoadedSymbolDictResolvedProjectV2
loadedCommitId

	^ self resolvedProject loadedCommitId
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
loadedComponentDefinitions
	^ self resolvedProject _projectStructure copy
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
loadedConfigurationNames

	^ self resolvedProject loadedConfigurationNames
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
loadedGroupNames

	^ self resolvedProject loadedGroupNames
%

category: 'actions'
method: RwGsLoadedSymbolDictResolvedProjectV2
loadProjectSet
	"
		refresh the contents of the receiver from disk and create a project set that includes project definitions of
			required projects, also read from disk. Then load the entire project set.
	"

	^ self asDefinition loadProjectSet
%

category: 'actions'
method: RwGsLoadedSymbolDictResolvedProjectV2
loadProjectSet: platformConditionalAttributes
	"
		refresh the contents of the receiver from disk and create a project set that includes project definitions of
			required projects, also read from disk. Then load the entire project set.

		Use the specified platform conditional attributes when reading the receiver from disk.
	"

	^ self asDefinition loadProjectSet: platformConditionalAttributes
%

category: 'actions'
method: RwGsLoadedSymbolDictResolvedProjectV2
loadProjectSet: platformConditionalAttributes instanceMigrator: instanceMigrator
	"
		refresh the contents of the receiver from disk and create a project set that includes project definitions of
			required projects, also read from disk. Then load the entire project set, using the specified 
			instance migrator.

		Use the specified platform conditional attributes when reading the receiver from disk.

		Use the instanceMigrator to handle new versions of any classes that may result from the load.
	"

	^ self asDefinition
		loadProjectSet: platformConditionalAttributes
		instanceMigrator: instanceMigrator
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
loadSpecification

	^ handle _loadSpecification
%

category: 'private'
method: RwGsLoadedSymbolDictResolvedProjectV2
markPackageDirty
	"... indicates that receiver needs to mark it's container as dirty .... "

	self markDirty
%

category: 'properties'
method: RwGsLoadedSymbolDictResolvedProjectV2
packageConvention

	^ self resolvedProject packageConvention
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
platformConditionalAttributes
	"Answer the platformConditionalAttributes used to load the project"

	^ self resolvedProject platformConditionalAttributes
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
projectDefinitionPlatformConditionalAttributes
	"Answer the projectDefinitionPlatformConditionalAttributes used to load the project"

	^ self resolvedProject projectDefinitionPlatformConditionalAttributes
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
projectOwnerId

	^ self propertyAt: 'projectOwnerId'
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
projectOwnerId: aString

	^ self propertyAt: 'projectOwnerId' put: aString
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
projectUrl

	"Return the projectUrl used to clone the project"

	^ self resolvedProject projectUrl
%

category: 'definitions'
method: RwGsLoadedSymbolDictResolvedProjectV2
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
self halt.
	props at: 'projectRef' put: handle copy.
	^ props
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
remote

	^ self resolvedProject repository remote
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
repositoryCommitId

	^ self resolvedProject repositoryCommitId
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ self resolvedProject repositoryRoot
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
repositoryRootPath

	^ self repositoryRoot pathString
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
resolvedProject

	^ self handle
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
specification

self deprecated: 'temporary patch .. sender should send direct message to receiver'.
	^ handle
%

category: 'querying'
method: RwGsLoadedSymbolDictResolvedProjectV2
subcomponentsOf: componentName attributes: attributes ifNone: noneBlock
	| subcomponents |
	subcomponents := self components
		subcomponentsOf: componentName
		resolvedProject: self
		matchBlock: [ :aComponent | aComponent matchesAttributes: attributes ]
		ifNone: [^ noneBlock value ].
	subcomponents isEmpty
		ifTrue: [ ^ noneBlock value ].
	^ subcomponents
%

category: 'querying'
method: RwGsLoadedSymbolDictResolvedProjectV2
subcomponentsOf: componentName ifNone: noneBlock
	^ self
		subcomponentsOf: componentName
		attributes: self platformConditionalAttributes
		ifNone: noneBlock
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
symbolDictNameForPackageNamed: packageName

	^self resolvedProject symbolDictNameForPackageNamed: packageName
%

category: 'actions'
method: RwGsLoadedSymbolDictResolvedProjectV2
unload
	"unload the receiver from the image"

	| resolvedProject |
	resolvedProject := self asDefinition.
	^ resolvedProject _projectDefinition _deleteTool
		deleteProjectDefinition: resolvedProject
%

category: 'loading'
method: RwGsLoadedSymbolDictResolvedProjectV2
updateLoadedCommitId

	self resolvedProject updateLoadedCommitId
%

category: 'accessing'
method: RwGsLoadedSymbolDictResolvedProjectV2
useGit

	^ self resolvedProject useGit
%

! Class implementation for 'RwMethodAdditionOrRemoval'

!		Class methods for 'RwMethodAdditionOrRemoval'

category: 'instance creation'
classmethod: RwMethodAdditionOrRemoval
packageDefinition: aPackageDefinition classDefinitionOrExtension: aClassDefinitionOrExtension methodKey: aMethodKey isMeta: isMeta methodsModification: aMethodsModification

	^(self new)
		packageDefinition: aPackageDefinition;
		classDefinitionOrExtension: aClassDefinitionOrExtension;
		methodKey: aMethodKey;
		isMeta: isMeta;
		methodsModification: aMethodsModification;
		yourself
%

category: 'instance creation'
classmethod: RwMethodAdditionOrRemoval
projectDefinition: aProjectDefinition packageDefinition: aPackageDefinition classDefinitionOrExtension: aClassDefinitionOrExtension methodKey: aMethodKey isMeta: isMeta methodsModification: aMethodsModification

	^(self new)
		projectDefinition: aProjectDefinition;
		packageDefinition: aPackageDefinition;
		classDefinitionOrExtension: aClassDefinitionOrExtension;
		methodKey: aMethodKey;
		isMeta: isMeta;
		methodsModification: aMethodsModification;
		yourself
%

!		Instance methods for 'RwMethodAdditionOrRemoval'

category: 'Accessing'
method: RwMethodAdditionOrRemoval
classDefinitionOrExtension
	^classDefinitionOrExtension
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
classDefinitionOrExtension: newValue
	classDefinitionOrExtension := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
isMeta
	^isMeta
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
isMeta: newValue
	isMeta := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
methodKey
	^methodKey
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
methodKey: newValue
	methodKey := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
methodsModification
	^methodsModification
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
methodsModification: newValue
	methodsModification := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
packageDefinition
	^packageDefinition
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
packageDefinition: newValue
	packageDefinition := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
projectDefinition
	^ projectDefinition
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
projectDefinition: newValue
	projectDefinition := newValue
%

! Class implementation for 'RwModification'

!		Class methods for 'RwModification'

category: 'instance creation'
classmethod: RwModification
before: beforeDefinition after: afterDefinition

	^(self new initialize)
		before: beforeDefinition;
		after: afterDefinition;
		yourself
%

!		Instance methods for 'RwModification'

category: 'Accessing'
method: RwModification
after
	^after
%

category: 'Updating'
method: RwModification
after: newValue
	after := newValue
%

category: 'Accessing'
method: RwModification
before
	^before
%

category: 'Updating'
method: RwModification
before: newValue
	before := newValue
%

category: 'initializing'
method: RwModification
initialize

	propertiesModification := RwPropertiesModification new
%

category: 'testing'
method: RwModification
isAddition

	^before isEmpty
%

category: 'testing'
method: RwModification
isDeletion

	^after isEmpty
%

category: 'testing'
method: RwModification
isEmpty

	^propertiesModification isEmpty
%

category: 'testing'
method: RwModification
isModification

	^after isEmpty not and: [ before isEmpty not ]
%

category: 'Accessing'
method: RwModification
key

	| beforeKey |
	beforeKey := before key.
	^beforeKey ifNil: [after key] ifNotNil: [beforeKey]
%

category: 'Printing'
method: RwModification
printOn: aStream

	super printOn: aStream.
	self isEmpty ifTrue: [aStream nextPutAll: ' (empty)']
%

category: 'Accessing'
method: RwModification
propertiesModification
	^propertiesModification
%

category: 'Updating'
method: RwModification
propertiesModification: newValue
	propertiesModification := newValue
%

! Class implementation for 'RwClassModification'

!		Instance methods for 'RwClassModification'

category: 'visiting'
method: RwClassModification
acceptVisitor: aVisitor

	^aVisitor visitClassModification: self
%

category: 'Accessing'
method: RwClassModification
classMethodsModification
	^classMethodsModification
%

category: 'Updating'
method: RwClassModification
classMethodsModification: newValue
	classMethodsModification := newValue
%

category: 'initialization'
method: RwClassModification
initialize
	"Dummy initialization that understands isEmpty for printing."

	super initialize.
	instanceMethodsModification := #().
	classMethodsModification := #()
%

category: 'Accessing'
method: RwClassModification
instanceMethodsModification
	^instanceMethodsModification
%

category: 'Updating'
method: RwClassModification
instanceMethodsModification: newValue
	instanceMethodsModification := newValue
%

category: 'testing'
method: RwClassModification
isEmpty

	^super isEmpty & instanceMethodsModification isEmpty
		& classMethodsModification isEmpty
%

category: 'merging'
method: RwClassModification
mergeForExistingClassWith: anExistingClassModification

	"merge aClassModification modifictions into the receiver"

	anExistingClassModification propertiesModification isEmpty
		ifFalse: [
			self propertiesModification isEmpty
				ifFalse: ["the properties modification for the receiver can be safely ignored" ].
			propertiesModification := anExistingClassModification propertiesModification copy ].
	instanceMethodsModification
		mergeForExistingClassWith: anExistingClassModification instanceMethodsModification.
	classMethodsModification
		mergeForExistingClassWith: anExistingClassModification classMethodsModification.
	after := anExistingClassModification after
%

category: 'merging'
method: RwClassModification
mergeForNewClassVersionWith: aClassModification

	"merge aClassModification modifictions into the receiver"

	aClassModification propertiesModification isEmpty
		ifFalse: [ 
			self
				error:
					'internal error - an incoming class modification is not expected to have properties when a new class version is involved' ].
	instanceMethodsModification
		mergeForNewClassVersionWith: aClassModification instanceMethodsModification.
	classMethodsModification
		mergeForNewClassVersionWith: aClassModification classMethodsModification
%

! Class implementation for 'RwClassExtensionModification'

!		Instance methods for 'RwClassExtensionModification'

category: 'visiting'
method: RwClassExtensionModification
acceptVisitor: aVisitor

	^aVisitor visitClassExtensionModification: self
%

category: 'patching'
method: RwClassExtensionModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ 
			aPatchSet
				addExtendedClass: self after
				inPackage: aPackage
				inProject: aProjectDefinition ].
	self isDeletion
		ifTrue: [ 
			"nothing interesting to do for deletion"
			 ].
	self isModification
		ifTrue: [ 
			"nothing interesting to do for modification"
			 ]
%

! Class implementation for 'RwClassModificationForcingNewClassVersion'

!		Instance methods for 'RwClassModificationForcingNewClassVersion'

category: 'visiting'
method: RwClassModificationForcingNewClassVersion
acceptVisitor: aVisitor

	^ aVisitor visitClassModificationForcingNewVersion: self
%

! Class implementation for 'RwMethodModification'

!		Instance methods for 'RwMethodModification'

category: 'visiting'
method: RwMethodModification
acceptVisitor: aVisitor

	^ aVisitor visitMethodModification: self
%

category: 'patching'
method: RwMethodModification
addExtensionModificationToPatchSetForNewClassVersion: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ self error: 'internal error - unexpected method addition' ].
	self isDeletion
		ifTrue: [ self error: 'internal error - unexpected method deletion' ].
	self isModification
		ifTrue: [ 
			"treat like an addition, since it is an addition of a method to the new class version"
			self isMeta
				ifTrue: [ 
					aPatchSet
						addExtendedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addExtendedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ] ]
%

category: 'patching'
method: RwMethodModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addAddedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addAddedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isDeletion
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addDeletedClassMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addDeletedInstanceMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isModification
		ifTrue: [ 
			sourceModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedClassMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedInstanceMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ].
			propertiesModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedClassMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedInstanceMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ] ]
%

category: 'converting'
method: RwMethodModification
asExtensionMethodModification

	^ (RwExtensionMethodModification before: before after: after)
		isMeta: self isMeta;
		propertiesModification: propertiesModification;
		sourceModification: sourceModification;
		classDefinition: self classDefinition;
		yourself
%

category: 'converting'
method: RwMethodModification
asMethodModificationForNewClassVersion

	^ (RwMethodModificationForNewClassVersion before: before after: after)
		isMeta: self isMeta;
		classDefinition: self classDefinition;
		propertiesModification: self propertiesModification;
		sourceModification: self sourceModification;
		yourself
%

category: 'Accessing'
method: RwMethodModification
classDefinition
	^classDefinition
%

category: 'Updating'
method: RwMethodModification
classDefinition: aClassDefinition
	classDefinition := aClassDefinition
%

category: 'testing'
method: RwMethodModification
isEmpty

	^super isEmpty & sourceModification isEmpty
%

category: 'Accessing'
method: RwMethodModification
isMeta
	^isMeta
%

category: 'Updating'
method: RwMethodModification
isMeta: newValue
	isMeta := newValue
%

category: 'merging'
method: RwMethodModification
mergeForNewClassVersionWith: aMethodModification

	"validate that this is a proper modification"

	self sourceModification isEmpty
		ifTrue: [ 
			aMethodModification sourceModification isEmpty
				ifTrue: [ 
					self
						error:
							'internal error - unexpected missing source modification during method modification for new class version merge' ]
				ifFalse: [ 
					"this is as it should be ... method source must be carried forward to the new class version"
					 ] ].
	self propertiesModification isEmpty
		ifTrue: [ 
			aMethodModification propertiesModification isEmpty
				ifFalse: [ self error: 'internal error - not yet implemented' ] ]
%

category: 'Accessing'
method: RwMethodModification
sourceModification
	^sourceModification
%

category: 'Accessing'
method: RwMethodModification
sourceModification: aRWSourceModification
	sourceModification := aRWSourceModification
%

! Class implementation for 'RwExtensionMethodModification'

!		Instance methods for 'RwExtensionMethodModification'

category: 'visiting'
method: RwExtensionMethodModification
acceptVisitor: aVisitor

	^ aVisitor visitExtensionMethodModification: self
%

category: 'patching'
method: RwExtensionMethodModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addExtendedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addExtendedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isDeletion
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addDeletedExtendedClassMethod: self before
						inClass: self classDefinition
						named: self extendedClassName
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addDeletedExtendedInstanceMethod: self before
						inClass: self classDefinition
						named: self extendedClassName
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isModification
		ifTrue: [ 
			sourceModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedExtendedClassMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedExtendedInstanceMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ].
			propertiesModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedExtendedClassMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedExtendedInstanceMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ] ]
%

category: 'converting'
method: RwExtensionMethodModification
asExtensionMethodModification

	^ self
%

category: 'accessing'
method: RwExtensionMethodModification
classDefinition: aClassDefinition
	classDefinition := aClassDefinition
%

category: 'accessing'
method: RwExtensionMethodModification
extendedClassName

   ^extendedClassName
%

category: 'accessing'
method: RwExtensionMethodModification
extendedClassName: anObject

   extendedClassName := anObject
%

! Class implementation for 'RwMethodModificationForNewClassVersion'

!		Instance methods for 'RwMethodModificationForNewClassVersion'

category: 'visiting'
method: RwMethodModificationForNewClassVersion
acceptVisitor: aVisitor

	^ aVisitor visitMethodModificationForNewClassVersion: self
%

category: 'patching'
method: RwMethodModificationForNewClassVersion
addModificationToPatchSetForNewClassVersion: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isDeletion
		ifTrue: [ 
			"method deletions on a new class version can be ignored: https://github.com/dalehenrich/Rowan/issues/353"
			"method deletions on a new class version needs to have the loaded things taken core of: https://github.com/dalehenrich/Rowan/issues/393"

			"treat like a deletion, since this ends up being a deletion of a method from the new class version"
			self isMeta
				ifTrue: [ 
					aPatchSet
						addDeletedClassMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addDeletedInstanceMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ] ].
	(self isAddition or: [ self isModification ])
		ifTrue: [ 
			"treat like an addition, since this ends up being an addition of a method to the new class version"
			self isMeta
				ifTrue: [ 
					aPatchSet
						addAddedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addAddedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ] ].
%

! Class implementation for 'RwExtensionMethodModificationForNewClassVersion'

!		Instance methods for 'RwExtensionMethodModificationForNewClassVersion'

category: 'visiting'
method: RwExtensionMethodModificationForNewClassVersion
acceptVisitor: aVisitor

	^ aVisitor visitExtensionMethodModificationForNewClassVersion: self
%

! Class implementation for 'RwPackageModification'

!		Instance methods for 'RwPackageModification'

category: 'visiting'
method: RwPackageModification
acceptVisitor: aVisitor

	^aVisitor visitPackageModification: self
%

category: 'Accessing'
method: RwPackageModification
classesModification
	^classesModification
%

category: 'Updating'
method: RwPackageModification
classesModification: newValue
	classesModification := newValue
%

category: 'Accessing'
method: RwPackageModification
classExtensionsModification
	^classExtensionsModification
%

category: 'Updating'
method: RwPackageModification
classExtensionsModification: newValue
	classExtensionsModification := newValue
%

category: 'initialization'
method: RwPackageModification
initialize
	"Dummy initialization that understands isEmpty for printing."

	super initialize.
	classesModification := #().
	classExtensionsModification := #()
%

category: 'testing'
method: RwPackageModification
isEmpty

	^super isEmpty & classesModification isEmpty
		& classExtensionsModification isEmpty
%

! Class implementation for 'RwProjectModification'

!		Instance methods for 'RwProjectModification'

category: 'visiting'
method: RwProjectModification
acceptVisitor: aVisitor

	^ aVisitor visitProjectModification: self
%

category: 'initialization'
method: RwProjectModification
initialize

	"Dummy initialization that understands isEmpty for printing."

	super initialize.
	packagesModification := #()
%

category: 'testing'
method: RwProjectModification
isEmpty

	^ super isEmpty & packagesModification isEmpty
%

category: 'accessing'
method: RwProjectModification
packagesModification

   ^packagesModification
%

category: 'accessing'
method: RwProjectModification
packagesModification: anObject

   packagesModification := anObject
%

! Class implementation for 'RwMove'

!		Instance methods for 'RwMove'

category: 'Accessing'
method: RwMove
packageAfter
	^packageAfter
%

category: 'Updating'
method: RwMove
packageAfter: newValue
	packageAfter := newValue
%

category: 'Accessing'
method: RwMove
packageBefore
	^packageBefore
%

category: 'Updating'
method: RwMove
packageBefore: newValue
	packageBefore := newValue
%

category: 'Accessing'
method: RwMove
projectAfter
	^projectAfter
%

category: 'Updating'
method: RwMove
projectAfter: newValue
	projectAfter := newValue
%

category: 'Accessing'
method: RwMove
projectBefore
	^projectBefore
%

category: 'Updating'
method: RwMove
projectBefore: newValue
	projectBefore := newValue
%

category: 'Accessing'
method: RwMove
symbolDictionaryNameAfter
	^ self projectAfter
		gemstoneSymbolDictNameForPackageNamed: self packageAfter name
%

category: 'Accessing'
method: RwMove
symbolDictionaryNameBefore
	^ self projectBefore
		gemstoneSymbolDictNameForPackageNamed: self packageBefore name
%

! Class implementation for 'RwClassMove'

!		Class methods for 'RwClassMove'

category: 'instance creation'
classmethod: RwClassMove
classBefore: beforeClassDefinition classAfter: afterClassDefinition packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition

	^(self new)
		classBefore: beforeClassDefinition;
		classAfter: afterClassDefinition;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		yourself
%

category: 'instance creation'
classmethod: RwClassMove
classBefore: beforeClassDefinition classAfter: afterClassDefinition packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition projectBefore: beforeProjectDefinition projectAfter: afterProjectDefinition

	^(self new)
		classBefore: beforeClassDefinition;
		classAfter: afterClassDefinition;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		projectBefore: beforeProjectDefinition;
		projectAfter: afterProjectDefinition;
		yourself
%

!		Instance methods for 'RwClassMove'

category: 'Accessing'
method: RwClassMove
classAfter
	^classAfter
%

category: 'Updating'
method: RwClassMove
classAfter: newValue
	classAfter := newValue
%

category: 'Accessing'
method: RwClassMove
classBefore
	^classBefore
%

category: 'Updating'
method: RwClassMove
classBefore: newValue
	classBefore := newValue
%

! Class implementation for 'RwMethodMove'

!		Class methods for 'RwMethodMove'

category: 'unknown'
classmethod: RwMethodMove
methodBefore: beforeMethodDefinition methodAfter: afterMethodDefinition classOrExtensionBefore: beforeClassDefinitionOrExtension classOrExtensionAfter: afterClassDefinitionOrExtension packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition isMeta: isMeta

	^(self new)
		methodBefore: beforeMethodDefinition;
		methodAfter: afterMethodDefinition;
		classOrExtensionBefore: beforeClassDefinitionOrExtension;
		classOrExtensionAfter: afterClassDefinitionOrExtension;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		isMeta: isMeta;
		yourself
%

category: 'unknown'
classmethod: RwMethodMove
methodBefore: beforeMethodDefinition methodAfter: afterMethodDefinition classOrExtensionBefore: beforeClassDefinitionOrExtension classOrExtensionAfter: afterClassDefinitionOrExtension packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition projectBefore: beforeProjectDefinition projectAfter: afterProjectDefinition isMeta: isMeta

	^(self new)
		methodBefore: beforeMethodDefinition;
		methodAfter: afterMethodDefinition;
		classOrExtensionBefore: beforeClassDefinitionOrExtension;
		classOrExtensionAfter: afterClassDefinitionOrExtension;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		projectBefore: beforeProjectDefinition;
		projectAfter: afterProjectDefinition;
		isMeta: isMeta;
		yourself
%

!		Instance methods for 'RwMethodMove'

category: 'Accessing'
method: RwMethodMove
classOrExtensionAfter
	^classOrExtensionAfter
%

category: 'Updating'
method: RwMethodMove
classOrExtensionAfter: newValue
	classOrExtensionAfter := newValue
%

category: 'Accessing'
method: RwMethodMove
classOrExtensionBefore
	^classOrExtensionBefore
%

category: 'Updating'
method: RwMethodMove
classOrExtensionBefore: newValue
	classOrExtensionBefore := newValue
%

category: 'Accessing'
method: RwMethodMove
isMeta
	^isMeta
%

category: 'Updating'
method: RwMethodMove
isMeta: newValue
	isMeta := newValue
%

category: 'Accessing'
method: RwMethodMove
methodAfter
	^methodAfter
%

category: 'Updating'
method: RwMethodMove
methodAfter: newValue
	methodAfter := newValue
%

category: 'Accessing'
method: RwMethodMove
methodBefore
	^methodBefore
%

category: 'Updating'
method: RwMethodMove
methodBefore: newValue
	methodBefore := newValue
%

! Class implementation for 'RwPackageMove'

!		Class methods for 'RwPackageMove'

category: 'instance creation'
classmethod: RwPackageMove
packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition projectBefore: beforeProjectDefinition projectAfter: afterProjectDefinition
	^ self new
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		projectBefore: beforeProjectDefinition;
		projectAfter: afterProjectDefinition;
		yourself
%

!		Instance methods for 'RwPackageMove'

category: 'accessing'
method: RwPackageMove
packageDefinition
	^ self packageAfter
%

! Class implementation for 'RwPackageAdditionOrRemoval'

!		Class methods for 'RwPackageAdditionOrRemoval'

category: 'instance creation'
classmethod: RwPackageAdditionOrRemoval
projectDefinition: aProjectDefinition packageDefinition: aPackageDefinition packageKey: aPackageKey packagesModification: aPackagesModification

	^(self new)
		projectDefinition: aProjectDefinition;
		packageDefinition: aPackageDefinition;
		packageKey: aPackageKey;
		packagesModification: aPackagesModification;
		yourself
%

!		Instance methods for 'RwPackageAdditionOrRemoval'

category: 'Accessing'
method: RwPackageAdditionOrRemoval
packageDefinition
	^packageDefinition
%

category: 'Updating'
method: RwPackageAdditionOrRemoval
packageDefinition: newValue
	packageDefinition := newValue
%

category: 'accessing'
method: RwPackageAdditionOrRemoval
packageKey
	^packageKey
%

category: 'accessing'
method: RwPackageAdditionOrRemoval
packageKey: object
	packageKey := object
%

category: 'accessing'
method: RwPackageAdditionOrRemoval
packagesModification
	^packagesModification
%

category: 'accessing'
method: RwPackageAdditionOrRemoval
packagesModification: object
	packagesModification := object
%

category: 'Accessing'
method: RwPackageAdditionOrRemoval
projectDefinition
	^projectDefinition
%

category: 'Updating'
method: RwPackageAdditionOrRemoval
projectDefinition: newValue
	projectDefinition := newValue
%

! Class implementation for 'RwPlatform'

!		Instance methods for 'RwPlatform'

category: 'automatic class initialization'
method: RwPlatform
automaticClassInitializationBlackList

	"Answer list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		preferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setPreferenceFor: preferenceSymbol to: list.
			list]
%

category: 'automatic class initialization'
method: RwPlatform
automaticClassInitializationBlackList_default

	"Answer default list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		defaultPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setDefaultPreferenceFor: preferenceSymbol to: list.
			list]
%

category: 'automatic class initialization'
method: RwPlatform
automaticClassInitializationBlackList_global

	"Answer global list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		globalPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setDefaultPreferenceFor: preferenceSymbol to: list.
			list]
%

category: 'queries'
method: RwPlatform
basePlatformConditionalAttribute
	"Answer the generic conditional attribute for the platform"

	"Examples include: 'gemstone', 'pharo', 'squeak', 'vast' 
		(see RwSpecification class >> _supportedPlatformNames)"

	self subclassResponsibility: #'basePlatformConditionalAttribute'
%

category: 'preferences'
method: RwPlatform
clearAllPreferencesFor: preferenceSymbol 

	self subclassResponsibility: #clearAllPreferencesFor:
%

category: 'automatic class initialization'
method: RwPlatform
clearAutomaticClassInitializationBlackList

	"Answer list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwPlatform
clearAutomaticClassInitializationBlackList_default

	"Answer default list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearDefaultPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwPlatform
clearAutomaticClassInitializationBlackList_global

	"Answer default list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearGlobalPreferenceFor: preferenceSymbol
%

category: 'preferences'
method: RwPlatform
clearDefaultPreferenceFor: preferenceSymbol 

	self subclassResponsibility: #clearDefaultPreferenceFor:
%

category: 'preferences'
method: RwPlatform
clearPreferenceFor: preferenceSymbol 

	self subclassResponsibility: #clearPreferenceFor:
%

category: 'preferences'
method: RwPlatform
defaultPreferenceFor: preferenceSymbol

	^ self defaultPreferenceFor: preferenceSymbol ifAbsent: [ self error: 'No preference found for ', preferenceSymbol asString printString ]
%

category: 'preferences'
method: RwPlatform
defaultPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self subclassResponsibility: #defaultPreferenceFor:ifAbsent:
%

category: 'queries'
method: RwPlatform
globalNamed: aString

	"Answer a global object with the given name.  If no object with the given name is found, returns nil."

	self subclassResponsibility: #'globalNamed:'
%

category: 'queries'
method: RwPlatform
platformConditionalAttributes
	"Answer the platform conditional attributes. Currently 'common' is the only shared attribute."

	"subclasses need to override and provide additional platform-specific attributes"

	^ #('common')
%

category: 'preferences'
method: RwPlatform
preferenceFor: preferenceSymbol

	^ self preferenceFor: preferenceSymbol ifAbsent: [ self error: 'No preference found for ', preferenceSymbol asString printString ]
%

category: 'preferences'
method: RwPlatform
preferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self subclassResponsibility: #preferenceFor:ifAbsent:
%

category: 'preferences'
method: RwPlatform
setDefaultPreferenceFor: preferenceSymbol to: anObject

	self subclassResponsibility: #setDefaultPreferenceFor:to:
%

category: 'preferences'
method: RwPlatform
setPreferenceFor: preferenceSymbol to: anObject

	self subclassResponsibility: #setPreferenceFor:to:
%

category: 'automatic class initialization'
method: RwPlatform
_automaticClassInitializationBlackList_symbol

	^#automaticClassInitializationBlackList
%

! Class implementation for 'RwGsPlatform'

!		Instance methods for 'RwGsPlatform'

category: 'automatic class initialization'
method: RwGsPlatform
automaticClassInitializationBlackList_session

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		sessionPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setSessionPreferenceFor: preferenceSymbol to: list.
			list ]
%

category: 'automatic class initialization'
method: RwGsPlatform
automaticClassInitializationBlackList_user

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		userPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setUserPreferenceFor: preferenceSymbol to: list.
			list ]
%

category: 'queries'
method: RwGsPlatform
basePlatformConditionalAttribute
	"Answer the generic conditional attribute for the platform"

	"Examples include: 'gemstone', 'pharo', 'squeak', 'vast' 
		(see RwSpecification class >> _supportedPlatformNames)"

	^ 'gemstone'
%

category: 'preferences'
method: RwGsPlatform
clearAllPreferencesFor: preferenceSymbol


	self 
		clearSessionPreferenceFor: preferenceSymbol;
		clearUserPreferenceFor: preferenceSymbol;
		clearGlobalPreferenceFor: preferenceSymbol;
		yourself
%

category: 'automatic class initialization'
method: RwGsPlatform
clearAutomaticClassInitializationBlackList_global

	"Answer global list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearGlobalPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwGsPlatform
clearAutomaticClassInitializationBlackList_session

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearSessionPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwGsPlatform
clearAutomaticClassInitializationBlackList_user

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearUserPreferenceFor: preferenceSymbol
%

category: 'preferences'
method: RwGsPlatform
clearDefaultPreferenceFor: preferenceSymbol
	"global preferences implements default preference"

	self clearGlobalPreferenceFor: preferenceSymbol
%

category: 'preferences - gemstone'
method: RwGsPlatform
clearGlobalPreferenceFor: preferenceSymbol

	self _globalPreferenceDict removeKey: preferenceSymbol ifAbsent: []
%

category: 'preferences'
method: RwGsPlatform
clearPreferenceFor: preferenceSymbol
	"clear sessoin and userPreferences - preserve non-gemstone semantics"

	self 
		clearSessionPreferenceFor: preferenceSymbol;
		clearUserPreferenceFor: preferenceSymbol;
		yourself
%

category: 'preferences - gemstone'
method: RwGsPlatform
clearSessionPreferenceFor: preferenceSymbol

	self _sessionPreferenceDict removeKey: preferenceSymbol ifAbsent: []
%

category: 'preferences - gemstone'
method: RwGsPlatform
clearUserPreferenceFor: preferenceSymbol

	self _userPreferenceDict removeKey: preferenceSymbol ifAbsent: []
%

category: 'defaults'
method: RwGsPlatform
defaultConfiguration

	^ RwConfiguration new
		packageInfoSource: #'SymbolDictionary';
		yourself
%

category: 'preferences'
method: RwGsPlatform
defaultPreferenceFor: preferenceSymbol ifAbsent: aBlock

	"global preferences implements default preference"

	^self globalPreferenceFor: preferenceSymbol ifAbsent: aBlock
%

category: 'queries'
method: RwGsPlatform
globalNamed: aString

	"Answer a global object with the given name.  If no object with the given name is found, returns nil."

	^ Rowan image objectNamed: aString
%

category: 'preferences - gemstone'
method: RwGsPlatform
globalPreferenceFor: preferenceSymbol

	^ self globalPreferenceFor: preferenceSymbol ifAbsent: [ self error: 'Preference for ', preferenceSymbol printString, ' not found' ].
%

category: 'preferences - gemstone'
method: RwGsPlatform
globalPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _globalPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: aBlock
%

category: 'queries'
method: RwGsPlatform
image

	"Answer the platform-specific object for querying the local image"

	^ alternateImageClass ifNil: [ RwGsImage ]
%

category: 'initialization'
method: RwGsPlatform
initialize

	self automaticClassInitializationBlackList
%

category: 'queries'
method: RwGsPlatform
instanceMigrator

	^ instanceMigrator
		ifNil: [ instanceMigrator := RwGsInstanceMigrator noMigration ]
%

category: 'queries'
method: RwGsPlatform
instanceMigrator: anInstanceMigrator

	instanceMigrator := anInstanceMigrator
%

category: 'queries'
method: RwGsPlatform
orderedDictionaryClass
  "Answer the platform-specific OrderedDictionary-compatible class"

  ^ GsTonelOrderedDictionary
%

category: 'parsing'
method: RwGsPlatform
parseSelectorFrom: methodString

	| meth |
	^ [ 
	meth := self
		_parseMethod: methodString
		category: #'xyzzy'
		using: self image symbolList
		environmentId: 0.
	meth class ~~ GsNMethod
		ifTrue: [ 
			"if error slot is nil, then the method wasn't compiled because of errors"
			(meth at: 2) == nil
				ifFalse: [ ^ nil ].
			meth := meth at: 1 ].
	meth selector asString ]
		on: CompileError
		do: [ :ex | ex return: '_____could_not_parse_selector_from_method_source_____' ]
%

category: 'queries'
method: RwGsPlatform
platformConditionalAttributes
	"Answer the conditional attributes for the current platform."

	^ super platformConditionalAttributes
		,
			{(self basePlatformConditionalAttribute).
			'gemstone-kernel'.
			((System gemVersionReport at: 'gsVersion') asRwGemStoneVersionNumber)}
%

category: 'preferences'
method: RwGsPlatform
preferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _sessionPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: [ 
			self 
				_userPreferenceDict at: preferenceSymbol 
				ifAbsent: [
					self _globalPreferenceDict 
						at: preferenceSymbol
						ifAbsent:aBlock ] ]
%

category: 'preferences - gemstone'
method: RwGsPlatform
sessionPreferenceFor: preferenceSymbol

	^ self sessionPreferenceFor: preferenceSymbol ifAbsent: [ self error: 'Preference for ', preferenceSymbol printString, ' not found' ].
%

category: 'preferences - gemstone'
method: RwGsPlatform
sessionPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _sessionPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: aBlock
%

category: 'preferences'
method: RwGsPlatform
setDefaultPreferenceFor: preferenceSymbol to: anObject

	"global preferences implements default preference"

	^self setGlobalPreferenceFor: preferenceSymbol to: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
setGlobalPreferenceFor: preferenceSymbol to: anObject

	self _globalPreferenceDict at: preferenceSymbol put: anObject
%

category: 'preferences'
method: RwGsPlatform
setPreferenceFor: preferenceSymbol to: anObject

	"clear session; set userPreferences - preserve non-gemstone semantics"

	self clearSessionPreferenceFor: preferenceSymbol.
	^self setUserPreferenceFor: preferenceSymbol to: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
setSessionPreferenceFor: preferenceSymbol to: anObject

	self _sessionPreferenceDict at: preferenceSymbol put: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
setUserPreferenceFor: preferenceSymbol to: anObject

	self _userPreferenceDict at: preferenceSymbol put: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
userPreferenceFor: preferenceSymbol

	^ self userPreferenceFor: preferenceSymbol ifAbsent: [ self error: 'Preference for ', preferenceSymbol printString, ' not found' ].
%

category: 'preferences - gemstone'
method: RwGsPlatform
userPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _userPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: aBlock
%

category: 'private'
method: RwGsPlatform
_alternateImageClass

	^ alternateImageClass
%

category: 'private'
method: RwGsPlatform
_alternateImageClass: anImageClass

	alternateImageClass := anImageClass
%

category: 'private'
method: RwGsPlatform
_globalPreferenceDict

	^ (self class _userPlatformDictionaryForUser: 'SystemUser') at: #RwGlobalPlatform_Preferences ifAbsentPut: [ Dictionary new ]
%

category: 'private'
method: RwGsPlatform
_parseMethod: source category: cat using: aSymbolList environmentId: anEnvironmentId
	"Compiles the method into disposable dictionaries, if possible.
	 Attempts auto-recompile for undefinedSymbols.
	 Returns the compiled method or signals a CompileError.
   Only used to parse a method to determine the selector.  "

	| undefinedSymbolList undefinedSymbols |
	undefinedSymbols := SymbolDictionary new name: #'UndefinedSymbols'.
	undefinedSymbolList := SymbolList with: undefinedSymbols.
	^ [ 
	UndefinedObject
		compileMethod: source
		dictionaries: aSymbolList
		category: cat
		intoMethodDict: GsMethodDictionary new
		intoCategories: GsMethodDictionary new
		environmentId: anEnvironmentId ]
		onSynchronous: (Array with: CompileError with: CompileWarning)
		do:
			(Array
				with: [ :ex | 
					| undefSymbol symbols |
					undefSymbol := true.
					symbols := Array new.
					ex errorDetails
						do: [ :errArray | 
							(errArray atOrNil: 1) == 1031
								ifTrue: [ symbols add: (errArray atOrNil: 5) asSymbol ]
								ifFalse: [ undefSymbol := false ] ].
					undefSymbol
						ifTrue: [ 
							"attempt auto-define of undefined symbols"
							symbols do: [ :sym | undefinedSymbols at: sym put: nil ].

							[ 
							^ UndefinedObject
								compileMethod: source
								dictionaries: aSymbolList , undefinedSymbolList
								category: cat
								intoMethodDict: GsMethodDictionary new
								intoCategories: GsMethodDictionary new
								environmentId: anEnvironmentId ]
								onSynchronous: (Array with: CompileError with: CompileWarning)
								do:
									(Array with: [ :exb | undefSymbol := false ] with: [ :exc | exc resume ]) ].
					undefSymbol
						ifFalse: [ ex outer ] ]
				with: [ :ex | ex resume ])
%

category: 'private'
method: RwGsPlatform
_sessionPreferenceDict

	^ SessionTemps current at: #RwSessionPlatform_Preferences ifAbsentPut: [ Dictionary new ]
%

category: 'private'
method: RwGsPlatform
_userPreferenceDict

	^ self class _userPlatformDictionary at: #RwUserPlatform_Preferences ifAbsentPut: [ Dictionary new ]
%

! Class implementation for 'RwPropertyModification'

!		Class methods for 'RwPropertyModification'

category: 'instance creation'
classmethod: RwPropertyModification
key: key oldValue: oldValue newValue: newValue

	^(self new)
		key: key;
		oldValue: oldValue;
		newValue: newValue;
		yourself
%

!		Instance methods for 'RwPropertyModification'

category: 'testing'
method: RwPropertyModification
isEmpty

	^oldValue = newValue
%

category: 'Accessing'
method: RwPropertyModification
key
	^key
%

category: 'Updating'
method: RwPropertyModification
key: znewValue
	key := znewValue
%

category: 'Accessing'
method: RwPropertyModification
newValue
	^newValue
%

category: 'Updating'
method: RwPropertyModification
newValue: znewValue
	newValue := znewValue
%

category: 'Accessing'
method: RwPropertyModification
oldValue
	^oldValue
%

category: 'Updating'
method: RwPropertyModification
oldValue: znewValue
	oldValue := znewValue
%

! Class implementation for 'RwUnconditionalPropertyModification'

!		Instance methods for 'RwUnconditionalPropertyModification'

category: 'testing'
method: RwUnconditionalPropertyModification
isEmpty

	^ false
%

! Class implementation for 'RwResolvedLoadComponentsV2'

!		Class methods for 'RwResolvedLoadComponentsV2'

category: 'instance creation'
classmethod: RwResolvedLoadComponentsV2
new

	^self basicNew initialize
%

!		Instance methods for 'RwResolvedLoadComponentsV2'

category: 'accessing'
method: RwResolvedLoadComponentsV2
addComponentNamed: componentName toComponentNamed: toComponentName
	| component |
	component := self
		componentNamed: toComponentName
		ifAbsent: [ self error: 'The component ' , toComponentName printString , ' is undefined' ].
	component addComponentNamed: componentName
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
addPackageNamed: packageName toComponentNamed: componentName 
	| component |
	component := self
		componentNamed: componentName
		ifAbsent: [ self error: 'The component ' , componentName printString , ' is undefined' ].
	component
		addPackageNames: {packageName}.
	^ component
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
addPackageNamed: packageName toComponentNamed: componentName gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc
	| component |
	component := self
		componentNamed: componentName
		ifAbsent: [ self error: 'The component ' , componentName printString , ' is undefined' ].
	component
		conditionalPackageMapSpecsAtGemStoneUserId: aSymbolDictAssoc key
			andPackageName: packageName
			setSymbolDictNameTo: aSymbolDictAssoc value;
		addPackageNames: {packageName}.
	^ component
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
addPackagesNamed: packageNames toComponentNamed: aComponentName
	packageNames
		do: [ :packageName | self addPackageNamed: packageName toComponentNamed: aComponentName ]
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
addPlatformNestedComponentNamed: aComponentName condition: conditionArray comment: commentString
	| component |
	self components
		at: aComponentName
		ifPresent: [ 
			self
				error: 'The component ' , aComponentName printString , ' is already present' ].
	component := self components
		at: aComponentName
		ifAbsentPut: [ RwPlatformNestedProjectLoadComponentV2 newNamed: aComponentName ].
	component
		condition: conditionArray;
		comment: commentString;
		yourself.
	^ component
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
addProjectNamed: projectName toComponentNamed: toComponentName
	| component |
	component := self
		componentNamed: toComponentName
		ifAbsent: [ self error: 'The component ' , toComponentName printString , ' is undefined' ].
	component addProjectNamed: projectName
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
addSimpleComponentNamed: aComponentName condition: condition
	| component |
	self components
		at: aComponentName
		ifPresent: [ 
			self
				error: 'The component ' , aComponentName printString , ' is already present' ].
	component := self components
		at: aComponentName
		ifAbsentPut: [ RwSimpleProjectLoadComponentV2 newNamed: aComponentName ].
	component
		condition: condition;
		yourself.
	^ component
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
addSimpleComponentNamed: aComponentName condition: condition comment: commentString
	| component |
	self components
		at: aComponentName
		ifPresent: [ 
			self
				error: 'The component ' , aComponentName printString , ' is already present' ].
	component := self components
		at: aComponentName
		ifAbsentPut: [ RwSimpleProjectLoadComponentV2 newNamed: aComponentName ].
	component
		condition: condition;
		comment: commentString;
		yourself.
	^ component
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
addSimpleNestedComponentNamed: aComponentName condition: condition comment: commentString
	| component |
	self components
		at: aComponentName
		ifPresent: [:ignored |
			self
				error: 'The component ' , aComponentName printString , ' is already present' ].
	component := self components
		at: aComponentName
		ifAbsentPut: [ RwSimpleNestedProjectLoadComponentV2 newNamed: aComponentName ].
	component
		condition: condition;
		comment: commentString;
		yourself.
	^ component
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
categoryComponentsFor: componentNameList
	"category components are the components listed in the top-level loaded components"

	| topLevel categoryComponents |
	topLevel := componentNameList
		collect: [ :componentName | self componentNamed: componentName ].
	categoryComponents := Set new.
	topLevel
		do: [ :component | 
			component componentNames
				do: [ :componentName | categoryComponents add: (self componentNamed: componentName) ] ].
	^ categoryComponents asArray
%

category: 'querying'
method: RwResolvedLoadComponentsV2
componentForPackageNamed: packageName
	self components
		do: [ :component | 
			(component packageNames includes: packageName)
				ifTrue: [ ^ component ] ].
	^ nil
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
componentNamed: aComponentName
	^ self
		componentNamed: aComponentName
		ifAbsent: [ self error: 'No component named ' , aComponentName printString , ' found' ]
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
componentNamed: aComponentName ifAbsent: absentBlock

	^ self components 
		at: aComponentName 
		ifAbsent: absentBlock
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
components
	^components
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
components: object
	components := object
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
componentsWithDoits
	^ self components select: [ :each | each hasDoits ]
%

category: 'enumerating'
method: RwResolvedLoadComponentsV2
conditionalComponentsStartingWith: componentNames platformConditionalAttributes: platformConditionalAttributes do: aBlock
	| visited |
	visited := Set new.
	componentNames
		do: [ :componentName | 
			| theComponent |
			theComponent := self componentNamed: componentName.

			self
				_conditionalComponentsStartingWith: theComponent
				platformConditionalAttributes: platformConditionalAttributes
				visited: visited
				do: aBlock ]
%

category: 'enumerating'
method: RwResolvedLoadComponentsV2
do: aBlock
	"For each component in the receiver, evaluates the one-argument block
 aBlock with the value as the argument.  Returns the receiver."

	self components do: aBlock
%

category: 'exporting'
method: RwResolvedLoadComponentsV2
export: componentsRoot

	self components values do: [:component|
		component exportToUrl: 'file:',  componentsRoot pathString, '/' ].
	self components isEmpty
		ifTrue: [
			"add README.md as placeholder to ensure that the directory is preserved by git"
			(componentsRoot /  'README', 'md') writeStreamDo: [ :fileStream | ] ]
%

category: 'gemstone support'
method: RwResolvedLoadComponentsV2
gemstoneSetSymbolDictName: symbolDictName forPackageNamed: packageName
	self
		gemstoneSetSymbolDictNameForUser: self _gemstoneAllUsersName
		to: symbolDictName
		forPackageNamed: packageName
%

category: 'gemstone support'
method: RwResolvedLoadComponentsV2
gemstoneSetSymbolDictNameForUser: userId to: symbolDictName forPackageNamed: packageName
	| foundOne |
	foundOne := false.
	self components
		keysAndValuesDo: [ :componentName :component | 
			(component packageNames includes: packageName)
				ifTrue: [ 
					foundOne := true.
					component
						conditionalPackageMapSpecsAtGemStoneUserId: userId
						andPackageName: packageName
						setSymbolDictNameTo: symbolDictName ] ].
	foundOne
		ifFalse: [ self error: 'No package named ' , packageName printString , ' found.' ]
%

category: 'gemstone support'
method: RwResolvedLoadComponentsV2
gemstoneSetUseSessionMethodsForExtensions: aBool forPackageNamed: packageName
	self
		gemstoneSetUseSessionMethodsForExtensionsForUser: self _gemstoneAllUsersName
		to: aBool
		forPackageNamed: packageName
%

category: 'gemstone support'
method: RwResolvedLoadComponentsV2
gemstoneSetUseSessionMethodsForExtensionsForUser: userId to: aBool forPackageNamed: packageName
	| foundOne |
	foundOne := false.
	self components
		keysAndValuesDo: [ :componentName :component | 
			(component packageNames includes: packageName)
				ifTrue: [ 
					foundOne := true.
					component
						conditionalPackageMapSpecsAtGemStoneUserId: userId
						andPackageName: packageName
						setUseSessionMethodsForExtensions: aBool ] ].
	foundOne
		ifFalse: [ self error: 'No package named ' , packageName printString , ' found.' ]
%

category: 'gemstone support'
method: RwResolvedLoadComponentsV2
gemstoneSymbolDictNameForPackageNamed: packageName forUser: userId ifAbsent: absentBlock
	self components
		keysAndValuesDo: [ :componentName :component | 
			(component packageNames includes: packageName)
				ifTrue: [ 
					| userIdPropertiesMap packagePropertiesMap |
					userIdPropertiesMap := (component
						conditionalPackageMapSpecsAtGemStoneUserId: userId)
						at: #'packageNameToPlatformPropertiesMap'
						ifAbsent: [ 
							"no entries for the specific userId, check if there's an entry for allusers"
							(component
								conditionalPackageMapSpecsAtGemStoneUserId: self _gemstoneAllUsersName)
								at: #'packageNameToPlatformPropertiesMap'
								ifAbsent: absentBlock ].
					packagePropertiesMap := userIdPropertiesMap
						at: packageName
						ifAbsent: absentBlock.
					^ packagePropertiesMap at: 'symbolDictName' ifAbsent: absentBlock ] ].
	^ absentBlock value
%

category: 'initialization'
method: RwResolvedLoadComponentsV2
initialize
	components := Dictionary new
%

category: 'testing'
method: RwResolvedLoadComponentsV2
isEmpty
	^ self components isEmpty
%

category: 'copying'
method: RwResolvedLoadComponentsV2
postCopy
	super postCopy.
	components := self components copy.
	components keysAndValuesDo: [:key :value | components at: key put: value copy ].
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
removeComponentNamed: aComponentName
	self components
		do: [ :component | component removeComponentNamed: aComponentName ].
	^ self components removeKey: aComponentName ifAbsent: [  ].
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
removePackageNamed: aPackageName
	self components do: [ :component | component removePackageNamed: aPackageName ]
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
removeProjectNamed: aProjectName
	self components do: [ :component | component removeProjectNamed: aProjectName ]
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
renameComponentNamed: aComponentPath to: aComponentName
	| component referencePath componentPath |
	component := self components
		removeKey: aComponentPath
		ifAbsent: [ self error: 'No component named ' , aComponentPath printString , ' found' ].
	referencePath := component referencePath.
	componentPath := referencePath parent segments size = 0
		ifTrue: [ 
			"top-level component, simple rename is sufficient"
			aComponentName ]
		ifFalse: [ 
			"need to preserve the path for the component"
			(referencePath parent / aComponentName) pathString ].
	(self components includesKey: componentPath)
		ifTrue: [ 
			self
				error:
					'A component with the name ' , componentPath printString , ' already exists' ].
	component name: componentPath.
	self components
		do: [ :comp | 
			(comp componentNames includes: aComponentPath)
				ifTrue: [ 
					comp
						removeComponentNamed: aComponentPath;
						addComponentNamed: componentPath ] ].
	self components at: componentPath put: component.
	^ componentPath
%

category: 'querying'
method: RwResolvedLoadComponentsV2
subcomponentsOf: componentName resolvedProject: resolvedProject matchBlock: matchBlock ifNone: noneBlock
	| aComponent subcomponents |
	subcomponents := {}.
	aComponent := self
		componentNamed: componentName
		ifAbsent: [ 
			"read from disk if not present?"
			^ noneBlock value ].
	(matchBlock value: aComponent)
		ifFalse: [ 
			"The component is not loadable, so ignore it's subcomponents"
			^ subcomponents ].
	aComponent componentNames
		do: [ :subcomponentName | 
			| subcomponent |
			subcomponent := self
				componentNamed: subcomponentName
				ifAbsent: [ 
					"read from disk if not present?"
					^ noneBlock value ].
			(matchBlock value: subcomponent)
				ifTrue: [ subcomponents add: subcomponent ] ].
	^ subcomponents
%

category: 'accessing'
method: RwResolvedLoadComponentsV2
_addComponent: aComponent
	"not sure I like how this is used ... the component structure needs to be kept in sync with packages, so this is not quite the route to go, unless we ensure that the component has an entry for the package"

	"see similar comment in addRawPackageNamed: and addPackages:forComponent: "

	"should be sent from the component visitor ... not unexpected to have a duplicate, but the new
		component --- presumably freshly read from disk --- wins"

	^ self components at: aComponent name put: aComponent
%

category: 'enumerating'
method: RwResolvedLoadComponentsV2
_conditionalComponentsStartingWith: aComponent platformConditionalAttributes: platformConditionalAttributes visited: visitedComponentNames do: aBlock
	visitedComponentNames add: aComponent name.
	aComponent conditionalPropertyMatchers
		keysAndValuesDo: [ :platformMatchers :ignored | 
			(self
				_platformAttributeMatchIn: platformMatchers
				using: platformConditionalAttributes)
				ifTrue: [ 
					aBlock value: aComponent.
					aComponent componentNames
						do: [ :cName | 
							(visitedComponentNames includes: cName)
								ifFalse: [ 
									self
										_conditionalComponentsStartingWith: (self componentNamed: cName)
										platformConditionalAttributes: platformConditionalAttributes
										visited: visitedComponentNames
										do: aBlock ] ] ] ]
%

category: 'private'
method: RwResolvedLoadComponentsV2
_gemstoneAllUsersName
	^ RwLoadSpecificationV2 _gemstoneAllUsersName
%

category: 'enumerating'
method: RwResolvedLoadComponentsV2
_matchPlatformAttributes: platformPatternMatcher using: platformConditionalAttributes
	platformConditionalAttributes
		do: [ :anObject | 
			(platformPatternMatcher match: anObject)
				ifTrue: [ ^ true ] ].
	^ false
%

category: 'enumerating'
method: RwResolvedLoadComponentsV2
_platformAttributeMatchIn: platformMatchersList using: platformConditionalAttributes
	platformMatchersList
		do: [ :platformPatternMatcher | 
			(self
				_matchPlatformAttributes: platformPatternMatcher
				using: platformConditionalAttributes)
				ifTrue: [ ^ true ] ].
	^ false
%

category: 'private'
method: RwResolvedLoadComponentsV2
_validate
	"ensure that each of the components is valid and return a list of the package names managed by all components"

	| componentPackageNames |
	componentPackageNames := Set new.
	self components
		keysAndValuesDo: [ :componentName :component | 
			component
				validate;
				_validateDoits.
			componentPackageNames addAll: component packageNames ].
	^ componentPackageNames
%

category: 'private'
method: RwResolvedLoadComponentsV2
_validate: platformConfigurationAttributes
	"ensure that each of the components is valid and return a list of the package names managed by all components for the given group name"

	| componentPackageNames |
	componentPackageNames := Set new.
	self components
		keysAndValuesDo: [ :componentName :component | 
			component
				validate;
				_validateDoits.
			componentPackageNames
				addAll:
					(component
						packageNamesForPlatformConfigurationAttributes:
							platformConfigurationAttributes) ].
	^ componentPackageNames
%

! Class implementation for 'RwSpecification'

!		Class methods for 'RwSpecification'

category: 'instance creation'
classmethod: RwSpecification
fromUrl: specNameOrUrl

	"self fromUrl: 'file:/home/dhenrich/rogue/_homes/rogue/_home/shared/repos/RowanSample1/configs/Default.ston'"

	| url |
	url := specNameOrUrl asRwUrl.
	url scheme isNil
		ifTrue: [ self error: 'scheme must be file: or https:' ].
	url scheme = 'file'
		ifTrue: [ ^ self fromFile: url pathForFile ].
	url scheme asString = 'https'
		ifTrue: [ self error: 'not yet supported'.
"
			| client response |
			GsSecureSocket disableCertificateVerificationOnClient.
			client := (Rowan globalNamed: 'ZnClient') new.
			response := client
				beOneShot;
				enforceHttpSuccess: true;
				get: url.
			^ self _readStonFrom: response decodeFromUTF8
" ].
	self error: 'Unknown scheme: ' , url scheme printString
%

category: 'accessing'
classmethod: RwSpecification
label
	^ self class name asString , ' '
%

category: 'instance creation'
classmethod: RwSpecification
new

	^self basicNew initialize
%

category: 'accessing'
classmethod: RwSpecification
_supportedPlatformNames
	^ #('gemstone' 'pharo' 'squeak' 'vast')
%

!		Instance methods for 'RwSpecification'

category: 'private'
method: RwSpecification
currentVersion
	"
		0.1.0 - initial version for specs
		0.2.0 - defaultConfigurationNames and defaultGroupNames i.v. added to RwProjectSpecification
		0.3.0 - remoteUrl i.v. added to RwGitRepositorySpecification
	"
	^ '0.3.0'
%

category: 'initialization'
method: RwSpecification
initialize
  
%

category: 'initialization'
method: RwSpecification
initializeForExport
  "if spec has been exported, clear out any of the fields that represent local disk state"
%

category: 'initialization'
method: RwSpecification
initializeForImport

  "if spec has been imported, clear out any of the fields that represent local disk state"
  
%

category: 'copying'
method: RwSpecification
postCopy
  "don't forget to copy any compound state objects"

  
%

category: 'accessing'
method: RwSpecification
projectUrl: ignored
  
%

category: 'accessing'
method: RwSpecification
version

	^ nil
%

! Class implementation for 'RwLoadSpecificationV2'

!		Class methods for 'RwLoadSpecificationV2'

category: 'accessing'
classmethod: RwLoadSpecificationV2
label
	^ 'load specification '
%

category: 'gemstone-support'
classmethod: RwLoadSpecificationV2
_gemstoneAllUsersName
	^ 'allusers'
%

!		Instance methods for 'RwLoadSpecificationV2'

category: 'comparing'
method: RwLoadSpecificationV2
= anObject
	^ self specName = anObject specName
		and: [ 
			self projectName = anObject projectName
				and: [ 
					self projectAlias = anObject projectAlias
						and: [ 
							self projectsHome = anObject projectsHome
								and: [ 
									self customConditionalAttributes asArray sort
										= anObject customConditionalAttributes asArray sort
										and: [ 
											self componentNames asArray sort = anObject componentNames asArray sort
												and: [ 
													self projectSpecFile = anObject projectSpecFile
														and: [ 
															self repositoryResolutionPolicy = anObject repositoryResolutionPolicy
																and: [ 
																	self gitUrl = anObject gitUrl
																		and: [ 
																			self diskUrl = anObject diskUrl
																				and: [ 
																			self readonlyDiskUrl = anObject readonlyDiskUrl
																				and: [ 
																					self mercurialUrl = anObject mercurialUrl
																						and: [ 
																							self svnUrl = anObject svnUrl
																								and: [ 
																									self revision = anObject revision
																										and: [ 
																											self comment = anObject comment
																												and: [ 
																													self _platformProperties = anObject _platformProperties
																														or: [ self platformProperties = anObject platformProperties ] ] ] ] ] ] ] ] ] ] ] ] ] ] ] ]
%

category: 'visiting'
method: RwLoadSpecificationV2
acceptVisitor: aVisitor

	^ aVisitor visitLoadSpecification: self
%

category: 'accessing'
method: RwLoadSpecificationV2
addTopLevelComponentNamed: componentName
	componentNames add: componentName
%

category: 'accessing'
method: RwLoadSpecificationV2
comment
	^ comment ifNil: [ ^ '' ]
%

category: 'accessing'
method: RwLoadSpecificationV2
comment: aString
	comment := aString
%

category: 'accessing'
method: RwLoadSpecificationV2
componentNames
	^ componentNames
%

category: 'accessing'
method: RwLoadSpecificationV2
componentNames: anArray
	componentNames := anArray asArray
%

category: 'accessing'
method: RwLoadSpecificationV2
customConditionalAttributes

	^ customConditionalAttributes ifNil: [ #() ]
%

category: 'accessing'
method: RwLoadSpecificationV2
customConditionalAttributes: anArray

	customConditionalAttributes := anArray
%

category: 'accessing'
method: RwLoadSpecificationV2
diskUrl
	^ diskUrl
%

category: 'accessing'
method: RwLoadSpecificationV2
diskUrl: anUrlString
	revision := gitUrl := diskUrl := mercurialUrl := readonlyDiskUrl := svnUrl := nil.
	diskUrl := anUrlString
%

category: 'exporting'
method: RwLoadSpecificationV2
exportTo: directoryReference
	directoryReference / self specName , 'ston'
		writeStreamDo: [ :fileStream | self exportToStream: fileStream ]
%

category: 'exporting'
method: RwLoadSpecificationV2
exportToStream: fileStream
	STON put: self copy initializeForExport onStreamPretty: fileStream
%

category: 'ston'
method: RwLoadSpecificationV2
fromSton: stonReader
	"return an instance of RwResolvedLoadSpecificationV2 that wraps the receiver"

	^ (super fromSton: stonReader)
		_validate;
		yourself
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
gemstoneDefaultMethodEnvForUser: userId
	| gemstoneProperties userProperties |
	gemstoneProperties := self platformProperties
		at: 'gemstone'
		ifAbsent: [ ^ self _gemstoneDefaultMethodEnv ].
	userProperties := gemstoneProperties
		at: userId
		ifAbsent: [ 
			gemstoneProperties
				at: self _gemstoneAllUsersName
				ifAbsent: [ ^ self _gemstoneDefaultMethodEnv ] ].
	^ userProperties
		at: #'defaultMethodEnv'
		ifAbsent: [ self _gemstoneDefaultMethodEnv ]
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
gemstoneDefaultSymbolDictName
	^ self gemstoneDefaultSymbolDictNameForUser: self _gemstoneAllUsersName
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
gemstoneDefaultSymbolDictNameForUser: userId
	| gemstoneProperties userProperties |
	gemstoneProperties := self platformProperties
		at: 'gemstone'
		ifAbsent: [ ^ self _gemstoneDefaultSymbolDictName ].
	userProperties := gemstoneProperties
		at: userId
		ifAbsent: [ 
			gemstoneProperties
				at: self _gemstoneAllUsersName
				ifAbsent: [ ^ self _gemstoneDefaultSymbolDictName ] ].
	^ (userProperties
		at: #'defaultSymbolDictName'
		ifAbsent: [ self _gemstoneDefaultSymbolDictName ]) asString
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
gemstoneDefaultUseSessionMethodsForExtensionsForUser: userId
	| gemstoneProperties userProperties |
	gemstoneProperties := self platformProperties
		at: 'gemstone'
		ifAbsent: [ ^ self _gemstoneDefaultUseSessionMethodsForExtensions ].
	userProperties := gemstoneProperties
		at: userId
		ifAbsent: [ 
			gemstoneProperties
				at: self _gemstoneAllUsersName
				ifAbsent: [ ^ self _gemstoneDefaultUseSessionMethodsForExtensions ] ].
	^ userProperties
		at: #'defaultUseSessionMethodsForExtensions'
		ifAbsent: [ self _gemstoneDefaultUseSessionMethodsForExtensions ]
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
gemstoneSetDefaultMethodEnvForUser: userId to: env

	((self platformProperties at: 'gemstone' ifAbsentPut: [ Dictionary new ])
		at: userId ifAbsentPut: [ Dictionary new ])
			at: #defaultMethodEnv put: env
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
gemstoneSetDefaultMethodEnvTo: env
	self gemstoneSetDefaultMethodEnvForUser: self _gemstoneAllUsersName to: env
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
gemstoneSetDefaultSymbolDictNameForUser: userId to: symbolDictName

	((self platformProperties at: 'gemstone' ifAbsentPut: [ Dictionary new ])
		at: userId ifAbsentPut: [ Dictionary new ])
			at: #defaultSymbolDictName put: symbolDictName asString
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
gemstoneSetDefaultSymbolDictNameTo: symbolDictName
	self gemstoneSetDefaultSymbolDictNameForUser: self _gemstoneAllUsersName to: symbolDictName
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
gemstoneSetDefaultUseSessionMethodsForExtensionsForUser: userId to: aBool
	((self platformProperties at: 'gemstone' ifAbsentPut: [ Dictionary new ])
		at: userId
		ifAbsentPut: [ Dictionary new ])
		at: #'defaultUseSessionMethodsForExtensions'
		put: aBool
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
gemstoneSetDefaultUseSessionMethodsForExtensionsTo: aBool
	self gemstoneSetDefaultUseSessionMethodsForExtensionsForUser: self _gemstoneAllUsersName to: aBool
%

category: 'accessing'
method: RwLoadSpecificationV2
gitUrl
	^ gitUrl
%

category: 'accessing'
method: RwLoadSpecificationV2
gitUrl: anUrlString
	gitUrl := diskUrl := mercurialUrl := readonlyDiskUrl := svnUrl := nil.
	gitUrl := anUrlString
%

category: 'comparing'
method: RwLoadSpecificationV2
hash
	| hashValue |
	hashValue := self specName hash.
	hashValue := hashValue bitXor: self customConditionalAttributes hash.
	hashValue := hashValue bitXor: self projectName hash.
	hashValue := hashValue bitXor: self projectAlias hash.
	hashValue := hashValue bitXor: self projectSpecFile hash.
	hashValue := hashValue bitXor: self gitUrl hash.
	hashValue := hashValue bitXor: self diskUrl hash.
	hashValue := hashValue bitXor: self readonlyDiskUrl hash.
	hashValue := hashValue bitXor: self mercurialUrl hash.
	hashValue := hashValue bitXor: self svnUrl hash.
	hashValue := hashValue bitXor: self revision hash.
	hashValue := hashValue bitXor: self comment hash.
	hashValue := hashValue bitXor: self componentNames hash.
	hashValue := hashValue bitXor: self projectsHome hash.
	hashValue := hashValue bitXor: self repositoryResolutionPolicy hash.
	hashValue := hashValue bitXor: self _platformProperties hash.
	^ hashValue
%

category: 'initialization'
method: RwLoadSpecificationV2
initialize
	super initialize.
	componentNames := {}.
	projectSpecFile := 'rowan/project.ston'.
	comment := ''
%

category: 'initialization'
method: RwLoadSpecificationV2
initializeForExport
	"if spec is to be exported, clear out any of the fields that represent local disk state"

	super initializeForExport.
	platformProperties
		ifNotNil: [ 
			platformProperties isEmpty
				ifTrue: [ platformProperties := nil ] ].
	repositoryResolutionPolicy := projectsHome := nil
%

category: 'testing'
method: RwLoadSpecificationV2
isStrict
	^ self repositoryResolutionPolicy == #strict
%

category: 'accessing'
method: RwLoadSpecificationV2
mercurialUrl
	^ mercurialUrl
%

category: 'accessing'
method: RwLoadSpecificationV2
mercurialUrl: anUrlString
	gitUrl := diskUrl := mercurialUrl := readonlyDiskUrl := svnUrl := nil.
	mercurialUrl := anUrlString
%

category: 'accessing'
method: RwLoadSpecificationV2
platformProperties
	^ platformProperties ifNil: [ platformProperties := Dictionary new ]
%

category: 'copying'
method: RwLoadSpecificationV2
postCopy
	"don't forget to copy any compound state objects"

	super postCopy.
	componentNames := componentNames copy.
	customConditionalAttributes := customConditionalAttributes copy.
	platformProperties
		ifNotNil: [ 
			| platformPropertiesCopy |
			platformPropertiesCopy := platformProperties copy.
			platformProperties
				keysAndValuesDo: [ :platformName :userIdMap | 
					| userIdMapCopy |
					userIdMapCopy := userIdMap copy.
					platformPropertiesCopy at: platformName put: userIdMapCopy.
					platformName = 'gemstone'
						ifTrue: [ 
							userIdMap
								keysAndValuesDo: [ :userId :platformPropertiesMap | 
									| platformPropertiesMapCopy |
									platformPropertiesMapCopy := platformPropertiesMap copy.
									userIdMapCopy at: userId put: platformPropertiesMapCopy.
									platformPropertiesMap
										keysAndValuesDo: [ :propertyKey :propertyValue | platformPropertiesMapCopy at: propertyKey put: propertyValue copy ] ] ]
						ifFalse: [ self error: 'postCopy of ' , platformName printString , ' not yet implemented' ] ].
			platformProperties := platformPropertiesCopy ]
%

category: 'printing'
method: RwLoadSpecificationV2
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' for ';
		nextPutAll: (self specName ifNil: ['nil'])
%

category: 'accessing'
method: RwLoadSpecificationV2
projectAlias
	"project alias is used as the name of the root directory for the project ... necessary if the project is 
		embedded in another project's git repository or you want use a non-default directory on disk"

	^ projectAlias ifNil: [ self projectName ]
%

category: 'accessing'
method: RwLoadSpecificationV2
projectAlias: aString
	"project alias is used as the name of the root directory for the project ... necessary if the project is 
		embedded in another project's git repository or you want use a non-default directory on disk"

	projectAlias := aString
%

category: 'accessing'
method: RwLoadSpecificationV2
projectName
	^ projectName
%

category: 'accessing'
method: RwLoadSpecificationV2
projectName: aString
	projectName := aString
%

category: 'accessing'
method: RwLoadSpecificationV2
projectsHome
	"projects home specifies the disk location where projects cloned/created by the receiver will be located."

	^ projectsHome ifNil: [FileLocator rowanProjectsHome ]
%

category: 'accessing'
method: RwLoadSpecificationV2
projectsHome: aStringOrFileReference
	"projects home specifies the disk location where projects cloned/created by the receiver will be located."

	projectsHome := aStringOrFileReference asFileReference
%

category: 'accessing'
method: RwLoadSpecificationV2
projectSpecFile
	^ projectSpecFile
%

category: 'accessing'
method: RwLoadSpecificationV2
projectSpecFile: aString
	projectSpecFile := aString
%

category: 'accessing'
method: RwLoadSpecificationV2
projectUrl
	^ self gitUrl
		ifNotNil: [ :urlString | urlString ]
		ifNil: [ 
			self svnUrl
				ifNotNil: [ :urlString | urlString ]
				ifNil: [ self mercurialUrl ifNotNil: [ :urlString | urlString ] ifNil: [ self diskUrl ifNil: [ self readonlyDiskUrl ]] ] ]
%

category: 'accessing'
method: RwLoadSpecificationV2
readonlyDiskUrl
	^ readonlyDiskUrl
%

category: 'accessing'
method: RwLoadSpecificationV2
readonlyDiskUrl: anUrlString
	revision := gitUrl := diskUrl := mercurialUrl := readonlyDiskUrl := svnUrl := nil.
	readonlyDiskUrl := anUrlString
%

category: 'accessing'
method: RwLoadSpecificationV2
repositoryResolutionPolicy
	^repositoryResolutionPolicy
%

category: 'accessing'
method: RwLoadSpecificationV2
repositoryResolutionPolicy: aSymbolOrNil
	"
	#strict - repository will be forced to match the specificed revision
	"

	repositoryResolutionPolicy := aSymbolOrNil
%

category: 'accessing'
method: RwLoadSpecificationV2
repositoryRoot
	^ self projectsHome / self projectAlias
%

category: 'actions'
method: RwLoadSpecificationV2
resolveProjectSetStrict
	"resolve using #strict repositoryResolutionpolicy"

	| oldPolicy |
	self isStrict
		ifTrue: [ ^ self resolve ].
	oldPolicy := self repositoryResolutionPolicy.
	[ 
	"force #strict policy to ensure that the revision is checked out out in the repository"
	self repositoryResolutionPolicy: #'strict'.
	^ self resolveProjectSet ]
		ensure: [ self repositoryResolutionPolicy: oldPolicy ]
%

category: 'actions'
method: RwLoadSpecificationV2
resolveStrict
	"resolve using #strict repositoryResolutionpolicy"

	| oldPolicy |
	self isStrict
		ifTrue: [ ^ self resolve ].
	oldPolicy := self repositoryResolutionPolicy.
	[ 
	"force #strict policy to ensure that the revision is checked out out in the repository"
	self repositoryResolutionPolicy: #'strict'.
	^ self resolve ]
		ensure: [ self repositoryResolutionPolicy: oldPolicy ]
%

category: 'actions'
method: RwLoadSpecificationV2
resolveWithParentProject: aResolvedProject
	"give embedded projects a chance to resolve cleanly"

	self projectsHome: aResolvedProject projectsHome.
	^self  resolve
%

category: 'accessing'
method: RwLoadSpecificationV2
revision
	" git :: committish; svn :: revision; mercurial :: changeset; disk :: empty string"

	^ revision
%

category: 'accessing'
method: RwLoadSpecificationV2
revision: aRevisionString
	" git :: committish; svn :: revision; mercurial :: changeset; disk :: empty string"

	^ revision := aRevisionString
%

category: 'accessing'
method: RwLoadSpecificationV2
specName

	^ specName ifNil: [ self projectName ]
%

category: 'accessing'
method: RwLoadSpecificationV2
specName: aString
	specName := aString
%

category: 'accessing'
method: RwLoadSpecificationV2
svnUrl
	^ svnUrl
%

category: 'accessing'
method: RwLoadSpecificationV2
svnUrl: anUrlString
	gitUrl := diskUrl := mercurialUrl := readonlyDiskUrl := svnUrl := nil.
	svnUrl := anUrlString
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
_gemstoneAllUsersName

	^ self class _gemstoneAllUsersName
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
_gemstoneDefaultMethodEnv
	^ 0
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
_gemstoneDefaultSymbolDictName

	^ 'UserGlobals'
%

category: 'gemstone-support'
method: RwLoadSpecificationV2
_gemstoneDefaultUseSessionMethodsForExtensions

	^ false
%

category: 'accessing'
method: RwLoadSpecificationV2
_platformProperties
	"direct access to IV ... used by ="

	^ platformProperties
%

category: 'private'
method: RwLoadSpecificationV2
_validate
	"ensure that the data structures within the receiver contain valid information:
		1. platform implementation is responsible for validating platform structures"

	| repoUrls |
	#(#'componentNames' #'specName' #'projectSpecFile')
		do: [ :messageName | 
			(self perform: messageName)
				ifNil: [ 
					Error
						signal:
							'The instance variable ' , messageName asString printString , ' cannot be nil' ] ].
	repoUrls := {}.
	#(#'gitUrl' #'diskUrl' #'mercurialUrl' #'svnUrl' #readonlyDiskUrl)
		do: [ :messageName | (self perform: messageName) ifNotNil: [ repoUrls add: messageName asString ] ].
	repoUrls size > 1
		ifTrue: [ Error signal: 'Only one of (gitUrl diskUrl mercurialUrl readonlyDiskUrl svnUrl) must be be set' ].
	(repoUrls size = 0 or: [ (repoUrls includes: 'diskUrl') or: [repoUrls includes: 'readonlyDiskUrl']])
		ifTrue: [ 
			self revision
				ifNotNil: [ :rev | 
					Error
						signal:
							'Invalid revision ' , rev printString
								, '. Should be nil for disk-based repository' ] ]
		ifFalse: [ 
			self gitUrl asRwUrl scheme ~= 'file'
				ifTrue: [ 
					self revision
						ifNil: [ 
							Error
								signal:
									'The instance variable ''revision'' must be set for the'
										, (repoUrls at: 1) asString printString ] ] ].
	self platformProperties
		keysAndValuesDo: [ :platformName :userIdMap | 
			(self class _supportedPlatformNames includes: platformName)
				ifFalse: [ 
					Error
						signal:
							'Unknown platform name ' , platformName printString , ' in platform properties' ].
			platformName = 'gemstone'
				ifTrue: [ self _validateGemStonePlatformUserIdMap: userIdMap ] ].
	^ true
%

category: 'private'
method: RwLoadSpecificationV2
_validateGemStonePlatformUserIdMap: userIdMap
	"ensure that the data structures within the receiver contain valid information:
		1. platform implementation is responsible for validating platform structures"

	| expectedPropertyMap |
	expectedPropertyMap := Dictionary new
		add: #'defaultSymbolDictName' -> CharacterCollection;
		add: #'defaultMethodEnv' -> SmallInteger;
		add: #'defaultUseSessionMethodsForExtensions' -> Boolean;
		yourself.
	userIdMap
		keysAndValuesDo: [ :userId :platformPropertiesMap | 
			platformPropertiesMap
				keysAndValuesDo: [ :propertyKey :propertyValue | 
					(expectedPropertyMap includesKey: propertyKey)
						ifTrue: [ 
							| expectedClass |
							expectedClass := expectedPropertyMap at: propertyKey.
							(propertyValue isKindOf: expectedClass)
								ifFalse: [ 
									Error
										signal:
											'Value of property (' , propertyKey printString , '->'
												, propertyValue printString , ') is expected to be class '
												, expectedClass name asString printString , ' not class '
												, propertyValue class name asString printString ] ]
						ifFalse: [ Error signal: 'Unknown platform property key ' , propertyKey printString ] ] ]
%

! Class implementation for 'RwEmbeddedLoadSpecificationV2'

!		Class methods for 'RwEmbeddedLoadSpecificationV2'

category: 'accessing'
classmethod: RwEmbeddedLoadSpecificationV2
label
	^ 'embedded load specification '
%

! Class implementation for 'RwProjectSpecificationV2'

!		Class methods for 'RwProjectSpecificationV2'

category: 'accessing'
classmethod: RwProjectSpecificationV2
label
	^ 'project specification '
%

!		Instance methods for 'RwProjectSpecificationV2'

category: 'comparing'
method: RwProjectSpecificationV2
= anObject
	| lazyEqual |
	^ self specName = anObject specName
		and: [ 
			self projectName = anObject projectName
				and: [ 
					self componentsPath = anObject componentsPath
						and: [ 
							self packageFormat = anObject packageFormat
								and: [ 
									self packageConvention = anObject packageConvention
										and: [ 
											self packagesPath = anObject packagesPath
												and: [ 
													self projectsPath = anObject projectsPath
														and: [ 
															self specsPath = anObject specsPath
																and: [ 
																	lazyEqual := self _repoType = anObject _repoType
																		or: [ self repoType = anObject repoType ].
																	lazyEqual
																		and: [ 
																			self comment = anObject comment
																				and: [ self loadedCommitId = anObject loadedCommitId ] ] ] ] ] ] ] ] ] ]
%

category: 'accessing'
method: RwProjectSpecificationV2
comment
	^ comment ifNil: [ ^ '' ]
%

category: 'accessing'
method: RwProjectSpecificationV2
comment: aString
	comment := aString
%

category: 'accessing'
method: RwProjectSpecificationV2
componentsPath

	^ componentsPath
%

category: 'accessing'
method: RwProjectSpecificationV2
componentsPath: aString
	componentsPath := aString
%

category: 'exporting'
method: RwProjectSpecificationV2
exportTo: directoryReference

	(directoryReference / self projectSpecPath / self specName, 'ston')
		writeStreamDo: [ :fileStream | STON put: self copy initializeForExport onStreamPretty: fileStream ]
%

category: 'comparing'
method: RwProjectSpecificationV2
hash
	| hashValue |
	hashValue := self specName hash.
	hashValue := hashValue bitXor: self projectName hash.
	hashValue := hashValue bitXor: self componentsPath hash.
	hashValue := hashValue bitXor: self packagesPath hash.
	hashValue := hashValue bitXor: self projectsPath hash.
	hashValue := hashValue bitXor: self specsPath hash.
	hashValue := hashValue bitXor: self _repoType hash.
	hashValue := hashValue bitXor: self comment hash.
	hashValue := hashValue bitXor: self packageFormat hash.
	hashValue := hashValue bitXor: self packageConvention hash.
	hashValue := hashValue bitXor: self loadedCommitId hash.
	^ hashValue
%

category: 'initialization'
method: RwProjectSpecificationV2
initialize
	super initialize.
	componentsPath := 'rowan/components'.
	packagesPath := 'rowan/src'.
	projectsPath := 'rowan/projects'.
	specsPath := 'rowan/specs'.
	projectSpecPath := 'rowan'.
	specName := 'project'.
	comment := ''
%

category: 'initialization'
method: RwProjectSpecificationV2
initializeForExport
	"if spec is to be exported, clear out any of the fields that represent local disk state"

	super initializeForExport.
	projectName := loadedCommitId := repoType := nil
%

category: 'accessing'
method: RwProjectSpecificationV2
loadedCommitId
	^ loadedCommitId
%

category: 'accessing'
method: RwProjectSpecificationV2
loadedCommitId: aCommitId
	loadedCommitId := aCommitId
%

category: 'accessing'
method: RwProjectSpecificationV2
packageConvention
	^ packageConvention ifNil: [ 'RowanHybrid' ]
%

category: 'accessing'
method: RwProjectSpecificationV2
packageConvention: aString
	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	packageConvention := aString
%

category: 'accessing'
method: RwProjectSpecificationV2
packageFormat
	^ self packageFormatIfAbsent: [ 'tonel' ]
%

category: 'accessing'
method: RwProjectSpecificationV2
packageFormat: aString
	(#('tonel' 'filetree') includes: aString)
		ifFalse: [ 
			self
				error:
					'Unknown package format ' , aString printString
						, '. Should be one of: tonel, or filetree' ].
	packageFormat := aString
%

category: 'accessing'
method: RwProjectSpecificationV2
packageFormatIfAbsent: absentBlock
	^ packageFormat ifNil: absentBlock
%

category: 'accessing'
method: RwProjectSpecificationV2
packagesPath

	^ packagesPath
%

category: 'accessing'
method: RwProjectSpecificationV2
packagesPath: aString
	packagesPath := aString
%

category: 'printing'
method: RwProjectSpecificationV2
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' for ';
		nextPutAll: (self specName ifNil: ['nil'])
%

category: 'accessing'
method: RwProjectSpecificationV2
projectName

	^ projectName
%

category: 'accessing'
method: RwProjectSpecificationV2
projectName: aString
	projectName := aString
%

category: 'accessing'
method: RwProjectSpecificationV2
projectsPath

	^ projectsPath
%

category: 'accessing'
method: RwProjectSpecificationV2
projectsPath: aString
	projectsPath := aString
%

category: 'accessing'
method: RwProjectSpecificationV2
projectSpecPath

	^ projectSpecPath
%

category: 'accessing'
method: RwProjectSpecificationV2
projectSpecPath: aString
	projectSpecPath := aString
%

category: 'accessing'
method: RwProjectSpecificationV2
repoType
	^ repoType ifNil: [ repoType := #disk ]
%

category: 'accessing'
method: RwProjectSpecificationV2
repoType: aSymbol
	"#disk, #git or #none"

	(#(#'disk' #'git' #'none') includes: aSymbol asSymbol)
		ifFalse: [ self error: 'Unknown repo type ' , aSymbol asSymbol printString ].
	^ repoType := aSymbol asSymbol
%

category: 'accessing'
method: RwProjectSpecificationV2
specName

	^ specName
%

category: 'accessing'
method: RwProjectSpecificationV2
specName: aString
	specName := aString
%

category: 'accessing'
method: RwProjectSpecificationV2
specsPath

	^ specsPath
%

category: 'accessing'
method: RwProjectSpecificationV2
specsPath: aString
	specsPath := aString
%

category: 'accessing'
method: RwProjectSpecificationV2
_repoType
	"direct access to IV ... used by ="

	^ repoType
%

category: 'private'
method: RwProjectSpecificationV2
_validate
	"ensure that the data structures within the receiver contain valid information:
		1. platform implementation is responsible for validating platform structures"

	#(#'componentsPath' #'packagesPath' #'projectsPath' #'specsPath' #'projectName' #'specName' #'projectSpecPath')
		do: [ :messageName | 
			(self perform: messageName)
				ifNil: [ 
					Error
						signal:
							'The instance variable ' , messageName asString printString , ' cannot be nil' ] ].
	^ true
%

! Class implementation for 'RwUrl'

!		Class methods for 'RwUrl'

category: 'instance creation'
classmethod: RwUrl
fromString: aString
  "Return a URL from a string and handle
	a String without a scheme as a HttpUrl."

  "RwUrl fromString: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'"

  "RwUrl fromString: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"

  "RwUrl fromString: 'telnet:chaos.resnet.gatech.edu'"

  "RwUrl fromString: 'file:/etc/passwd'"

  | remainder index scheme fragment newUrl |
  remainder := aString trimSeparators.
  index := remainder indexOf: $#.
  index > 0
    ifTrue: [ 
      "extract the fragment, if any"
      fragment := remainder copyFrom: index + 1 to: remainder size.
      remainder := remainder copyFrom: 1 to: index - 1 ].
  scheme := self schemeNameForString: remainder.
  newUrl := (self urlClassForScheme: scheme) new
    privateInitializeFromText: remainder.
  newUrl privateFragment: fragment.
  ^ newUrl
%

category: 'constants'
classmethod: RwUrl
schemeName

	"When searching for a class to handle a particular scheme, make sure that Url classes never match by default. This is so that abstract Url classes e.g. HierarchicalUrl can be iterated over, but will not be selected"

	^ #'none'
%

category: 'parsing'
classmethod: RwUrl
schemeNameForString: aString
	"Get the scheme name from a string, or return nil if it's not specified. 
	Used in internal parsing routines - an outsider may as well use asUrl. 
	Return scheme in lowercases."
	
	"Url schemeNameForString: 'http://www.yahoo.com'"
	"Url schemeNameForString: '/etc/passwed'"
	"Url schemeNameForString: '/etc/testing:1.2.3'"

	| index schemeName |
	index := aString indexOf: $: ifAbsent: [^ nil].
	schemeName := aString copyFrom: 1 to: index - 1.
	(schemeName allSatisfy: [:each | each isLetter]) ifFalse: [^ nil].
	^ schemeName asLowercase
%

category: 'parsing'
classmethod: RwUrl
urlClassForScheme: scheme
	"explicitly list the classes to be matched: https://github.com/dalehenrich/Rowan/issues/211"

	^ {RwFileUrl.
	RwHierarchicalUrl.
	RwHttpUrl.
	RwHttpsUrl}
		detect: [ :urlClass | urlClass schemeName = scheme ]
		ifNone: [ RwGenericUrl ]
%

!		Instance methods for 'RwUrl'

category: 'converting'
method: RwUrl
asRwRepository
  "return a platform appropriate repository for the repository identified in the receiver"

  ^ self subclassResponsibility: #'asRwRepository'
%

category: 'converting'
method: RwUrl
asRwUrl
  ^ self
%

category: 'converting'
method: RwUrl
asString

	^self printString
%

category: 'converting'
method: RwUrl
asUrl
	^self
%

category: 'accessing'
method: RwUrl
authority
	^''
%

category: 'fragment'
method: RwUrl
fragment
	^fragment
%

category: 'printing'
method: RwUrl
printOn: aStream

	^self subclassResponsibility: #printOn:
%

category: 'fragment'
method: RwUrl
privateFragment: aString
	fragment := aString
%

category: 'parsing'
method: RwUrl
privateInitializeFromText: aString

	^self subclassResponsibility: #privateInitializeFromText:
%

category: 'parsing'
method: RwUrl
privateInitializeFromText: aString relativeTo: aUrl
	"initialize from the given string, as a relative URL.  aString will have had the scheme name removed, if it was present to begin with.  If it was, then the scheme name was the same as the receiver's scheme name"

	"by default, just do regular initialization"
	^self privateInitializeFromText: aString
%

category: 'classification'
method: RwUrl
scheme
	"return a string with the scheme of this URL.  For instance, HTTP"

	^self subclassResponsibility: #scheme
%

! Class implementation for 'RwFileUrl'

!		Class methods for 'RwFileUrl'

category: 'instance creation'
classmethod: RwFileUrl
fromString: aString
	"Method that can be called explicitly to create a FileUrl."

	^self new privateInitializeFromText: aString
%

category: 'constants'
classmethod: RwFileUrl
schemeName
	^'file'
%

!		Instance methods for 'RwFileUrl'

category: 'converting'
method: RwFileUrl
asRwRepository
  "return a platform appropriate repository for the repository located in the directory referenced by the receiver"

  ^ self createRwRepositoryForPath: self pathForDirectory
%

category: 'accessing'
method: RwFileUrl
fileName
	"Return the last part of the path,
	most often a filename but can also be a directory."

	^self path last
%

category: 'testing'
method: RwFileUrl
firstPartIsDriveLetter
	"Return true if the first part of the path is a letter
	followed by a $: like 'C:' "
	
	| firstPart |
	path isEmpty ifTrue: [^false].
	firstPart := path first.
	^firstPart size = 2 and: [
		firstPart first isLetter
			and: [firstPart last = $:]]
%

category: 'accessing'
method: RwFileUrl
host
	"Return the host name, either 'localhost', '', or a fully qualified domain name."
	
	^host ifNil: ['']
%

category: 'accessing'
method: RwFileUrl
host: hostName
	"Set the host name, either 'localhost', '', or a fully qualified domain name."
	
	host := hostName
%

category: 'private-initialization'
method: RwFileUrl
host: aHostString pathParts: aCollection isAbsolute: aBoolean

	host := aHostString.
	path := aCollection.
	isAbsolute := aBoolean
%

category: 'private-initialization'
method: RwFileUrl
initializeFromPathString: aPathString
	"<aPathString> is a file path as a String.
	We construct a path collection using various heuristics."

	| pathString hasDriveLetter |
	pathString := aPathString.
	pathString isEmpty ifTrue: [pathString := '/'].
	"Copy without empty string preceeding first / or between duplicated /s."
	path := ((pathString subStrings: '/') copyWithout: '') collect: [:token | token unescapePercents].

	"A path like 'C:' refers in practice to 'c:/'"
	((pathString endsWith: '/') or:
		[(hasDriveLetter := self firstPartIsDriveLetter) and: [path size = 1]])
			ifTrue: [path add: ''].

	"Decide if we are absolute by checking for leading $/ or
	beginning with drive letter. Smarts for other OSes?"
	self isAbsolute: ((pathString beginsWith: '/')
						or: [hasDriveLetter ifNil: [self firstPartIsDriveLetter]])
%

category: 'accessing'
method: RwFileUrl
isAbsolute
	"Should the path be considered absolute to
	the filesystem instead of relative to the default directory?"
 
	^isAbsolute
%

category: 'accessing'
method: RwFileUrl
isAbsolute: aBoolean
	"Set if the path should be considered absolute to
	the filesystem instead of relative to the default directory."

	isAbsolute := aBoolean
%

category: 'accessing'
method: RwFileUrl
path
	"Return an ordered collection of the path elements."
	
	^path
%

category: 'accessing'
method: RwFileUrl
path: aCollection
	"Set the collection of path elements."

	path := aCollection
%

category: 'paths'
method: RwFileUrl
pathDirString
	"Path to directory as url, using slash as delimiter.
	Filename is left out."

	^String streamContents: [ :s |
		isAbsolute ifTrue: [ s nextPut: $/ ].
		1 to: self path size - 1 do: [ :ii |
			s nextPutAll: (path at: ii); nextPut: $/]]
%

category: 'paths'
method: RwFileUrl
pathForDirectory
	"Path using local file system's pathname delimiter.
	DOS paths with drive letters should not
	be prepended with a delimiter even though
	they are absolute. Filename is left out."

	| delimiter |
	delimiter :=  '/'.
	^String streamContents: [ :s |
		(self isAbsolute and: [self firstPartIsDriveLetter not])
			ifTrue: [ s nextPutAll: delimiter ].
		1 to: self path size - 1 do: [ :ii |
			s nextPutAll: (path at: ii); nextPutAll: delimiter]]
%

category: 'paths'
method: RwFileUrl
pathForFile
  ^ self pathString
%

category: 'private-initialization'
method: RwFileUrl
pathParts: aCollection isAbsolute: aBoolean

	^self host: nil pathParts: aCollection isAbsolute: aBoolean
%

category: 'paths'
method: RwFileUrl
pathString
	"Path as it appears in a URL with $/ as delimiter."
	
	
	^String streamContents: [ :s | | first |
		self isAbsolute ifTrue:[ s nextPut: $/ ].
		first := true.
		self path do: [ :p |
			first ifFalse: [ s nextPut: $/ ].
			first := false.
			s nextPutAll: p  ] ]
%

category: 'copying'
method: RwFileUrl
postCopy
	"Be sure not to share the path with the copy."

	super postCopy.
	path := path copy
%

category: 'printing'
method: RwFileUrl
printOn: aStream
	"Return the FileUrl according to RFC3986
		'file:'['//'<host>]<path>#<fragment>
	Note that <host> being '' is equivalent to 'localhost' and is not printed."

	aStream nextPutAll: self schemeName;
		nextPut: $:.

	"File URLs with hosts (which are fairly useless) cannot be relative."
	host isEmpty ifFalse: [isAbsolute ifFalse: [aStream nextPutAll: '<ErroneousURL>'. ^nil].
						aStream nextPutAll: '//';
						nextPutAll: host].

	aStream
		nextPutAll: self pathString.

	fragment ifNotNil:
		[aStream
			nextPut: $#;
			nextPutAll: fragment ].
%

category: 'private-initialization'
method: RwFileUrl
privateInitializeFromText: aString
	"Calculate host and path from a file URL in String format.
	Some malformed formats are allowed and interpreted by guessing."

	| schemeName pathString bare i |
	bare := aString trimSeparators.
	schemeName := RwUrl schemeNameForString: bare.
	(schemeName == nil  or: [schemeName ~= self schemeName])
		ifTrue: [
			host := ''.
			pathString := bare]
		ifFalse: [
			"First remove schemeName and colon"
			bare := bare copyFrom: (schemeName size + 2) to: bare size.
			"A proper file URL then has two slashes before host,
			A malformed URL is interpreted as using syntax file:<path>."
			(bare beginsWith: '//')
				ifTrue: [i := bare indexOf: $/ startingAt: 3.
						i=0 ifTrue: [
								host := bare copyFrom: 3 to: bare size.
								pathString := '']
							ifFalse: [
								host := bare copyFrom: 3 to: i-1.
								pathString := bare copyFrom: host size + 3 to: bare size]]
				ifFalse: [host := ''.
						pathString := bare]].
	self initializeFromPathString: pathString
%

category: 'private-initialization'
method: RwFileUrl
privateInitializeFromText: pathString relativeTo: aUrl
	"<pathString> should be a filesystem path.
	This url is adjusted to be aUrl + the path."

	| newPath |
	self host: aUrl host.
	self initializeFromPathString: pathString.
	self isAbsolute: aUrl isAbsolute.

	newPath := aUrl path copy.
	newPath removeLast.	"empty string that says its a directory"
	path do: [ :token |
		((token ~= '..') and: [token ~= '.']) ifTrue: [ 
			newPath addLast: token unescapePercents ].
		token = '..' ifTrue: [ 
			newPath isEmpty ifFalse: [ 
				newPath last = '..' ifFalse: [ newPath removeLast ] ] ].
		"token = '.' do nothing" ].
	path := newPath

	
%

category: 'classification'
method: RwFileUrl
scheme
	^self class schemeName
%

category: 'classification'
method: RwFileUrl
schemeName
	^self class schemeName
%

category: 'accessing'
method: RwFileUrl
segments

	^ path
%

! Class implementation for 'RwGenericUrl'

!		Class methods for 'RwGenericUrl'

category: 'parsing'
classmethod: RwGenericUrl
fromString: aString
	| schemeName locator |
	schemeName := RwUrl schemeNameForString: aString.
	schemeName ifNil: [ ^self schemeName: 'xnoscheme' locator: aString ].
	locator := aString copyFrom: (schemeName size + 2) to: aString size.
	^self schemeName: schemeName locator: locator
%

category: 'instance creation'
classmethod: RwGenericUrl
schemeName: schemeName  locator: locator
	^self new schemeName: schemeName  locator: locator
%

!		Instance methods for 'RwGenericUrl'

category: 'access'
method: RwGenericUrl
locator
	^locator
%

category: 'paths'
method: RwGenericUrl
pathForDirectory

	^self locator
%

category: 'printing'
method: RwGenericUrl
printOn: aStream
	
	self schemeName ifNotNil: [
		aStream nextPutAll: self schemeName; nextPut: $:].
	
	aStream nextPutAll: self locator.

	self fragment ifNotNil: [
		aStream nextPut: $#; nextPutAll: self fragment].
%

category: 'parsing'
method: RwGenericUrl
privateInitializeFromText: aString
	schemeName := RwUrl schemeNameForString: aString.
	locator :=  schemeName 
		ifNil: [ aString ]
		ifNotNil: [ aString copyFrom: (schemeName size+2) to: aString size ].
%

category: 'parsing'
method: RwGenericUrl
privateInitializeFromText: aString relativeTo: aUrl
	schemeName := aUrl schemeName.
	locator := aString.
%

category: 'classification'
method: RwGenericUrl
scheme
	^ self schemeName.
%

category: 'access'
method: RwGenericUrl
schemeName
	^schemeName
%

category: 'private'
method: RwGenericUrl
schemeName: schemeName0  locator: locator0
	schemeName := schemeName0.
	locator := locator0.
%

! Class implementation for 'RwHierarchicalUrl'

!		Class methods for 'RwHierarchicalUrl'

category: 'instance creation'
classmethod: RwHierarchicalUrl
schemeName: schemeName  authority: authority  path: path  query: query
	^self new schemeName: schemeName  authority: authority  path: path  query: query
%

!		Instance methods for 'RwHierarchicalUrl'

category: 'access'
method: RwHierarchicalUrl
authority
	^authority
%

category: 'printing'
method: RwHierarchicalUrl
fullPath
  | ans |
  ans := WriteStreamPortable on: String new.
  path
    do: [ :pathElem | 
      ans nextPut: $/.
      ans nextPutAll: pathElem ].
  self query == nil
    ifFalse: [ 
      ans nextPut: $?.
      ans nextPutAll: self query ].
  self fragment == nil
    ifFalse: [ 
      ans nextPut: $#.
      ans nextPutAll: self fragment ].
  ^ ans contents
%

category: 'access'
method: RwHierarchicalUrl
isAbsolute
	
	path size > 0 ifFalse: [^ false].
	(path at: 1) size > 0 ifFalse: [^ false].
	^ ((path at: 1) at: 1) ~~ $.
%

category: 'access'
method: RwHierarchicalUrl
password
	"http://user:pword@foo.com' asUrl password"
	^password
%

category: 'access'
method: RwHierarchicalUrl
path
	"return a collection of the decoded path elements, as strings"
	^path
%

category: 'access'
method: RwHierarchicalUrl
path: aCollection
	"Set the collection of path elements."

	path := aCollection
%

category: 'access'
method: RwHierarchicalUrl
port
	^port
%

category: 'copying'
method: RwHierarchicalUrl
postCopy
	"Be sure not to share the path with the copy"

	super postCopy.
	path := path copy
%

category: 'printing'
method: RwHierarchicalUrl
printOn: aStream
  aStream nextPutAll: self schemeName.
  aStream nextPutAll: '://'.
  self username
    ifNotNil: [ 
      aStream nextPutAll: self username.
      self password
        ifNotNil: [ 
          aStream nextPutAll: ':'.
          aStream nextPutAll: self password ].
      aStream nextPutAll: '@' ].
  aStream nextPutAll: self authority.
  port
    ifNotNil: [ 
      aStream
        nextPut: $:;
        nextPutAll: port printString ].
  path
    do: [ :pathElem | 
      aStream nextPut: $/.
      aStream nextPutAll: pathElem ].
  self query == nil
    ifFalse: [ 
      aStream nextPut: $?.
      aStream nextPutAll: self query ].
  self fragment == nil
    ifFalse: [ 
      aStream nextPut: $#.
      aStream nextPutAll: self fragment ]
%

category: 'parsing'
method: RwHierarchicalUrl
privateInitializeFromText: aString

	| remainder ind specifiedSchemeName |
	remainder := aString.
	schemeName
		ifNil: [ 
			specifiedSchemeName := RwUrl schemeNameForString: remainder.
			specifiedSchemeName
				ifNotNil: [ 
					schemeName := specifiedSchemeName.
					remainder := remainder copyFrom: schemeName size + 2 to: remainder size ].
			schemeName
				ifNil: [ 
					"assume HTTP"
					schemeName := 'http' ] ].	"remove leading // if it's there"
	(remainder beginsWith: '//')
		ifTrue: [ remainder := remainder copyFrom: 3 to: remainder size ].	"get the query"
	ind := remainder indexOf: $?.
	ind > 0
		ifTrue: [ 
			query := remainder copyFrom: ind + 1 to: remainder size.
			remainder := remainder copyFrom: 1 to: ind - 1 ].	"get the authority"
	ind := remainder indexOf: $/.
	ind > 0
		ifTrue: [ 
			ind = 1
				ifTrue: [ authority := '' ]
				ifFalse: [ 
					authority := remainder copyFrom: 1 to: ind - 1.
					remainder := remainder copyFrom: ind + 1 to: remainder size ] ]
		ifFalse: [ 
			authority := remainder.
			remainder := '' ].	"extract the username+password"
	(authority includes: $@)
		ifTrue: [ 
			username := authority copyUpTo: $@.
			authority := authority
				copyFrom: (authority indexOf: $@) + 1
				to: authority size.
			(username includes: $:)
				ifTrue: [ 
					password := (username copyFrom: (username indexOf: $:) + 1 to: username size)
						unescapePercents asByteArray decodeFromUTF8 asString.
					username := (username copyUpTo: $:) unescapePercents asByteArray
						decodeFromUTF8 asString ]
				ifFalse: [ 
					password := nil.
					username := username unescapePercents asByteArray decodeFromUTF8 asString ] ].	"Extract the port"
	(authority includes: $:)
		ifTrue: [ 
			| lastColonIndex portString |
			lastColonIndex := authority findLast: [ :c | c = $: ].
			portString := authority copyFrom: lastColonIndex + 1 to: authority size.
			(portString size > 0) 
				ifTrue: [
					(portString allSatisfy: [ :each | each isDigit ])
						ifTrue: [ 
							port := Integer fromString: portString.
							port > 65535
								ifTrue: [ self error: 'Invalid port number' ] ]
						ifFalse: [ self error: 'Invalid port number' ] ].
			authority := authority copyFrom: 1 to: lastColonIndex - 1 ].	

	"get the path"
	path := self privateParsePath: remainder relativeTo: #()
%

category: 'parsing'
method: RwHierarchicalUrl
privateParsePath: remainder relativeTo: basePath 
	| nextTok s parsedPath |
	s := remainder readStream.
	parsedPath := OrderedCollection new.
	parsedPath addAll: basePath.
	parsedPath isEmpty ifFalse: [ parsedPath removeLast ].
	
	[ s peek = $/ ifTrue: [ s next ].
	nextTok := WriteStreamPortable on: String new.
	[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].
	nextTok := nextTok contents unescapePercents.
	nextTok = '..' 
		ifTrue: [ parsedPath size > 0 ifTrue: [ parsedPath removeLast ] ]
		ifFalse: [ nextTok ~= '.' ifTrue: [ parsedPath add: nextTok ] ].
	s atEnd ] whileFalse.
	parsedPath isEmpty ifTrue: [ parsedPath add: '' ].
	^ parsedPath
%

category: 'access'
method: RwHierarchicalUrl
query
	"return the query, the part after any ?.  Any %XY's have already been decoded.  If there wasno query part, nil is returned (it is possible to also have an empty query"
	^query 
%

category: 'classification'
method: RwHierarchicalUrl
scheme
	^ self schemeName.
%

category: 'access'
method: RwHierarchicalUrl
schemeName
	^schemeName
%

category: 'private'
method: RwHierarchicalUrl
schemeName: schemeName0  authority: authority0  path: path0  query: query0
	"initialize a new instance"
	schemeName := schemeName0.
	authority := authority0.
	path := path0.
	query := query0.
%

category: 'access'
method: RwHierarchicalUrl
segments

	^ path
%

category: 'access'
method: RwHierarchicalUrl
username
	"http://user:pword@foo.com' asUrl username"
	^username
%

! Class implementation for 'RwHttpUrl'

!		Class methods for 'RwHttpUrl'

category: 'constants'
classmethod: RwHttpUrl
schemeName
	^'http'
%

! Class implementation for 'RwHttpsUrl'

!		Class methods for 'RwHttpsUrl'

category: 'constants'
classmethod: RwHttpsUrl
schemeName
	^'https'
%

! Class implementation for 'ZnBufferedReadStream'

!		Class methods for 'ZnBufferedReadStream'

category: 'instance creation'
classmethod: ZnBufferedReadStream
new

	^ self basicNew
		initialize;
		yourself
%

category: 'instance creation'
classmethod: ZnBufferedReadStream
on: readStream
	^ self new
		on: readStream;
		yourself
%

category: 'convenience'
classmethod: ZnBufferedReadStream
on: readStream do: block
	"Execute block with as argument a ZnBufferedReadStream on readStream.
	Return the value of block."

	^ block value: (self on: readStream)
%

!		Instance methods for 'ZnBufferedReadStream'

category: 'testing'
method: ZnBufferedReadStream
atEnd
	^ position > limit and: [ stream atEnd ]
	
%

category: 'initialize-release'
method: ZnBufferedReadStream
close
	stream close
%

category: 'testing'
method: ZnBufferedReadStream
closed
	^ stream closed
%

category: 'accessing'
method: ZnBufferedReadStream
collectionSpecies
	^ stream isBinary
		ifTrue: [ ByteArray ]
		ifFalse: [ String ]
%

category: 'accessing'
method: ZnBufferedReadStream
contents
	
	^ self upToEnd
%

category: 'accessing'
method: ZnBufferedReadStream
defaultBufferSize
	^ 2 raisedToInteger: 16
%

category: 'private'
method: ZnBufferedReadStream
discardBuffer
	limit := 0.
	position := 1
%

category: 'initialization'
method: ZnBufferedReadStream
initialize

	position := 1.
	limit := 0
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
int16
	^ self nextIntegerOfSize: 2 signed: true bigEndian: true 
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
int32
	^ self nextIntegerOfSize: 4 signed: true bigEndian: true
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
int8
	^ self nextIntegerOfSize: 1 signed: true bigEndian: true 
%

category: 'accessing'
method: ZnBufferedReadStream
isBinary
	^ stream isBinary
%

category: 'testing'
method: ZnBufferedReadStream
isStream
	^ true
%

category: 'accessing'
method: ZnBufferedReadStream
next
	"Return the next element and move over it"
	
	position > limit
		ifTrue: [ self nextBuffer ].
	^ position <= limit
		ifTrue: [ 
			| char |
			char := buffer at: position.
			position := position + 1.
			char ]
		ifFalse: [ nil ]
%

category: 'accessing'
method: ZnBufferedReadStream
next: requestedCount 
	"Read requestedCount elements and return them as a collection.
	If less are available, a smaller collection will be returned."

	^ self 
		next: requestedCount 
		into: (self collectionSpecies new: requestedCount)
%

category: 'accessing'
method: ZnBufferedReadStream
next: requestedCount into: collection
	"Read requestedCount elements into collection,
	returning a copy if less elements are available"
	
	^ self 
		next: requestedCount 
		into: collection 
		startingAt: 1   
%

category: 'accessing'
method: ZnBufferedReadStream
next: requestedCount into: collection startingAt: offset
	"Read requestedCount elements into collection starting at offset,
	returning a copy if less elements are available"
	
	| read |
	read := self 
		readInto: collection 
		startingAt: offset 
		count: requestedCount.
	^ read = requestedCount 
		ifTrue: [ collection ]
		ifFalse: [ collection copyFrom: 1 to: offset + read - 1 ]     
%

category: 'private'
method: ZnBufferedReadStream
nextBuffer
	stream atEnd ifTrue: [ ^ self ].
	limit := stream readInto: buffer startingAt: 1 count: buffer size.
	position := 1
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
nextInt32
	^ self nextIntegerOfSize: 4 signed: true bigEndian: true
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
nextIntegerOfSize: numberOfBytes signed: signed bigEndian: bigEndian
	"Assuming the receiver is a stream of bytes, read the next integer of size numberOfBytes.
	If bigEndian is true, use network byte order, most significant byte first, 
	else use little endian order, least significant byte first.
	If signed is true, interpret as a two-complement signed value, 
	else interpret as a plain unsigned value."
	
	| value |
	value := 0.
	bigEndian
		ifTrue: [ 
			(numberOfBytes - 1) * 8 to: 0 by: -8 do: [ :shift |
				value := value + (self next bitShift: shift) ] ]
		ifFalse: [ 
			0 to: (numberOfBytes - 1) * 8 by: 8 do: [ :shift |
				value := value + (self next bitShift: shift) ] ].
	^ (signed and: [ (value bitAt: numberOfBytes * 8) = 1 ])
		ifTrue: [ value - (1 << (numberOfBytes * 8)) ]
		ifFalse: [ value ]
%

category: 'accessing'
method: ZnBufferedReadStream
nextInto: collection
	"Read the next elements of the receiver into collection,
	returning a copy if less elements are available"
	
	^ self
		next: collection size
		into: collection
%

category: 'accessing'
method: ZnBufferedReadStream
nextLine
"Answer next line (may be empty) without line end delimiters, or nil if at end.
Leave the stream positioned after the line delimiter(s).
Handle a zoo of line delimiters CR, LF, or CR-LF pair"

| cr lf chrcls result ch |
self atEnd ifTrue: [^nil].
cr := (chrcls:= Character) cr.
lf := chrcls  lf.
result := self collectionSpecies new.
[ ch := self next .
  (ch == cr or:[ ch == lf ]) ifTrue:[ 
    ch == cr ifTrue:[ self peekFor: lf ].
    ^ result 
  ].
  result add: ch .
  self atEnd 
] whileFalse .
^ result
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
nextLittleEndianNumber: numberOfBytes
	^ self nextIntegerOfSize: numberOfBytes signed: false bigEndian: false
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
nextNumber: numberOfBytes
	^ self nextIntegerOfSize: numberOfBytes signed: false bigEndian: true
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
nextWord
	^ self nextIntegerOfSize: 2 signed: false bigEndian: true
%

category: 'initialize-release'
method: ZnBufferedReadStream
on: readStream
	stream := readStream.
	self sizeBuffer: self defaultBufferSize
%

category: 'accessing'
method: ZnBufferedReadStream
peek
	"Return the next element but do not move over it"
	
	position > limit
		ifTrue: [ self nextBuffer ].
	^ position <= limit
		ifTrue: [ buffer at: position ]
		ifFalse: [ nil ]
%

category: 'accessing'
method: ZnBufferedReadStream
peek: count
  self peek .
  ^ buffer copyFrom: position to: (position + count min: limit)
%

category: 'accessing'
method: ZnBufferedReadStream
peekFor: object
	"Answer false and do not move over the next element if it is not equal to object, or if the receiver is at the end. 
	Answer true and move over the next element when it is equal to object."

	^ self peek = object
		ifTrue: [ 
			self next.
			true ]
		ifFalse: [ false ]
%

category: 'accessing'
method: ZnBufferedReadStream
position
	
	"If the buffer advanced, we need to check the original stream position, minus what we have read.
	The -1 is because the buffer is base 1"
	^ stream position - limit + position - 1
%

category: 'accessing'
method: ZnBufferedReadStream
position: anInteger 
	
	| bufferEnd bufferStart |
	bufferEnd := stream position.
	bufferStart := bufferEnd - limit.
	(anInteger between: bufferStart and: bufferEnd)
		ifTrue: [ position := anInteger - bufferStart + 1 ]
		ifFalse: [ 
			"We reset the buffer and update the position in the underlying stream"
			limit := 0.
			position := 1.
			stream position: anInteger ]
%

category: 'private'
method: ZnBufferedReadStream
readFromBufferInto: collection startingAt: offset count: requestedCount
	"Read up to requestedCount elements into collection starting at offset,
	from my buffer, answering the number of elements read.
	There could be fewer elements buffered."

	| read |
	read := 0.
	position <= limit
		ifTrue: [ read := limit - position + 1 min: requestedCount.
			collection
				replaceFrom: offset
				to: offset + read - 1
				with: buffer
				startingAt: position.
			position := position + read ].
	^ read
%

category: 'accessing'
method: ZnBufferedReadStream
readInto: collection startingAt: offset count: requestedCount
	"Read requestedCount elements into collection starting at offset,
	answering the number of elements read, there could be fewer elements available."

	| countRead countYetToRead |
	"First, read from elements already in my buffer."
	countRead := self readFromBufferInto: collection startingAt: offset count: requestedCount.
	countYetToRead := requestedCount - countRead.
	countYetToRead > 0
		ifTrue: [ "See if there are more elements to be read from the underlying stream"
			| newOffset |
			newOffset := offset + countRead.
			(self shouldBufferReadOfCount: countYetToRead)
				ifTrue: [ self nextBuffer.
					position > limit ifTrue: [ ^ countRead ].
					limit > 0
						ifTrue:
							[ countRead := countRead + (self readInto: collection startingAt: newOffset count: countYetToRead) ] ]
				ifFalse:
					[ countRead := countRead + (stream readInto: collection startingAt: newOffset count: countYetToRead) ] ].
	^ countRead
%

category: 'accessing'
method: ZnBufferedReadStream
setToEnd
	
	stream setToEnd
%

category: 'private'
method: ZnBufferedReadStream
shouldBufferReadOfCount: elementCount
	"For larger read requests, buffering fails to give an advantage."

	^ elementCount < (buffer size / 2)
%

category: 'accessing'
method: ZnBufferedReadStream
size

	^ stream size
%

category: 'initialize-release'
method: ZnBufferedReadStream
sizeBuffer: size
	buffer := self collectionSpecies new: size
%

category: 'accessing'
method: ZnBufferedReadStream
skip: count
	"Skip over count elements.
	This could be further optimzed."
	
	count timesRepeat: [ self next ]
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
uint16
	^ self nextIntegerOfSize: 2 signed: false bigEndian: true 
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
uint32
	^ self nextIntegerOfSize: 4 signed: false bigEndian: true 
%

category: 'accessing-bytes'
method: ZnBufferedReadStream
uint8
	^ self nextIntegerOfSize: 1 signed: false bigEndian: true
%

category: 'accessing'
method: ZnBufferedReadStream
upTo: value 
	"Read upto but not including value and return them as a collection.
	If value is not found, return the entire contents of the stream.
	This could be further optimzed."
	
	^ self collectionSpecies 
		streamContents: [ :writeStream | | element |
			[ self atEnd or: [ (element := self next) = value ] ] whileFalse: [ 
				writeStream nextPut: element ] ]
%

category: 'accessing'
method: ZnBufferedReadStream
upToAll: aCollection 
"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."

| startPos endMatch result x |
startPos := self position.
x := self upTo: aCollection first.
self atEnd ifTrue: [ ^ x ].
2 to: aCollection size do: [:i |
	self peek = (aCollection at: i)
		ifTrue: [ self next ]
		ifFalse: [ self position: startPos.
		^ self upToEnd ] ].
endMatch := self position.
self position: startPos.
result := self next: endMatch - startPos - aCollection size.
self position: endMatch.
^ result
%

category: 'accessing'
method: ZnBufferedReadStream
upToEnd
	"Read elements until the stream is atEnd and return them as a collection."

	^ self collectionSpecies
		streamContents: [ :out | 
			[ self atEnd ] whileFalse: [ 
				position > limit
					ifTrue: [ self nextBuffer ].	
				out next: limit - position + 1 putAll: buffer startingAt: position.
				position := limit + 1 ] ]
%

category: 'accessing'
method: ZnBufferedReadStream
wrappedStream
	^ stream
%

category: 'accessing'
method: ZnBufferedReadStream
wrappedStreamName
	^ stream wrappedStreamName
%

! Class implementation for 'ZnBufferedReadWriteStream'

!		Class methods for 'ZnBufferedReadWriteStream'

category: 'instance creation'
classmethod: ZnBufferedReadWriteStream
on: writeStream
	^ self basicNew
		on: writeStream;
		yourself
%

category: 'convenience'
classmethod: ZnBufferedReadWriteStream
on: readStream do: block
	"Execute block with as argument a ZnBufferedReadStream on readStream.
	Return the value of block."

	^ block value: (self on: readStream)
%

!		Instance methods for 'ZnBufferedReadWriteStream'

category: 'testing'
method: ZnBufferedReadWriteStream
atEnd
	
	^ self readingActionDo: [ readStream atEnd ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
close
	
	writeStream flush.
	writeStream close.
%

category: 'testing'
method: ZnBufferedReadWriteStream
closed
	^ readStream closed
%

category: 'accessing'
method: ZnBufferedReadWriteStream
flush
	
	self writingActionDo: [ writeStream flush ]
%

category: 'testing'
method: ZnBufferedReadWriteStream
isBinary
	
	^ readStream isBinary
%

category: 'testing'
method: ZnBufferedReadWriteStream
isReadOnly
	
	^ false
%

category: 'testing'
method: ZnBufferedReadWriteStream
isStream

	^ true
%

category: 'accessing'
method: ZnBufferedReadWriteStream
next
	
	^ self readingActionDo: [ 
		readStream next ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
next: anInteger 
	
	^ self readingActionDo: [ 
		readStream next: anInteger ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
next: count putAll: collection

	self writingActionDo: [ 
		writeStream next: count putAll: collection ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
next: count putAll: collection startingAt: offset
	
	self writingActionDo: [
		writeStream next: count putAll: collection startingAt: offset ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
nextPut: aCharacter 
	
	self writingActionDo: [ writeStream nextPut: aCharacter ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
nextPutAll: aString 
	
	^ self writingActionDo: [ writeStream nextPutAll: aString ]
%

category: 'instance creation'
method: ZnBufferedReadWriteStream
on: aStream

	lastRead := true.
	readStream := ZnBufferedReadStream on: aStream.
	writeStream := ZnBufferedWriteStream on: aStream.
%

category: 'accessing'
method: ZnBufferedReadWriteStream
peek
	
	^ self readingActionDo: [ 
		readStream peek ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
position
	
	^ lastRead
		ifTrue: [ readStream position ]
		ifFalse: [ writeStream position ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
position: anInteger 
	
	self writingActionDo: [ 
		writeStream position: anInteger ]
	
%

category: 'private'
method: ZnBufferedReadWriteStream
readingActionDo: aBlock

	"Reading from the read stream.
	We should 
	 - flush the write stream
	 - discard the read buffer (which may contain incorrect data).
	 - and then perform the read."
	
	lastRead ifFalse: [ 
		writeStream flush.
		readStream discardBuffer ].
	^ aBlock ensure: [ lastRead := true ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
readInto: collection startingAt: offset count: requestedCount
	
	^ self readingActionDo: [ 
		readStream readInto: collection startingAt: offset count: requestedCount ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
setToEnd
	
	^ self writingActionDo: [ 
		writeStream setToEnd ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
size
	^ readStream size
%

category: 'initialize-release'
method: ZnBufferedReadWriteStream
sizeBuffer: anInteger 
	
	readStream sizeBuffer: anInteger.
	writeStream sizeBuffer: anInteger.
%

category: 'accessing'
method: ZnBufferedReadWriteStream
skip: anInteger 
	
	self readingActionDo: [ 
		readStream skip: anInteger ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
truncate
	
	self writingActionDo: [ writeStream truncate ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
truncate: anInteger 
	
	self writingActionDo: [ writeStream truncate: anInteger ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
upTo: aCharacter 
	
	^ self readingActionDo: [ readStream upTo: aCharacter ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
upToEnd
	
	^ self readingActionDo: [ readStream upToEnd ]
%

category: 'accessing'
method: ZnBufferedReadWriteStream
wrappedStream

	^ readStream wrappedStream
%

category: 'accessing'
method: ZnBufferedReadWriteStream
wrappedStreamName

	^ readStream wrappedStreamName
%

category: 'accessing'
method: ZnBufferedReadWriteStream
writingActionDo: aBlock
	
	"Writing to the write stream.
	We should 
	 - write the write stream
	 - discard the read buffer (which may contain incorrect data)"
	lastRead ifTrue: [ 
		writeStream discardBuffer ].
	readStream discardBuffer.
	^ aBlock ensure: [ lastRead := false ]
%

! Class implementation for 'ZnBufferedWriteStream'

!		Class methods for 'ZnBufferedWriteStream'

category: 'instance creation'
classmethod: ZnBufferedWriteStream
on: writeStream
	^ self basicNew
		on: writeStream;
		yourself
%

category: 'convenience'
classmethod: ZnBufferedWriteStream
on: writeStream do: block
	"Execute block with as argument a ZnBufferedWriteStream on writeStream,
	making sure #flush is called at the end. Return the value of block."
	
	| bufferedWriteStream result |
	bufferedWriteStream := self on: writeStream.
	result := block value: bufferedWriteStream.
	bufferedWriteStream flush.
	^ result
%

!		Instance methods for 'ZnBufferedWriteStream'

category: 'private'
method: ZnBufferedWriteStream
buffer
	buffer isNil 
		ifTrue: [ self sizeBuffer: self defaultBufferSize ].
	^ buffer
%

category: 'accessing'
method: ZnBufferedWriteStream
bufferFreeSize
	^ self bufferSize - position
%

category: 'accessing'
method: ZnBufferedWriteStream
bufferSize
	^ buffer isNil 
		ifTrue: [ self defaultBufferSize ]
		ifFalse: [ buffer size ]
%

category: 'initialize-release'
method: ZnBufferedWriteStream
close
	self flush.
	stream close
%

category: 'accessing'
method: ZnBufferedWriteStream
cr
	self nextPut: Character cr
%

category: 'accessing'
method: ZnBufferedWriteStream
crlf
	self cr; lf
%

category: 'accessing'
method: ZnBufferedWriteStream
defaultBufferSize
	^ 2 raisedToInteger: 16
%

category: 'private'
method: ZnBufferedWriteStream
discardBuffer

	position := 0
%

category: 'accessing'
method: ZnBufferedWriteStream
flush
	self flushBuffer.
	stream flush
%

category: 'private'
method: ZnBufferedWriteStream
flushBuffer
	position = 0 ifTrue: [ ^ self ].
	position = self bufferSize
		ifTrue: [ stream nextPutAll: buffer ]
		ifFalse: [ stream nextPutAll: (buffer copyFrom: 1 to: position) ].
	position := 0
%

category: 'private'
method: ZnBufferedWriteStream
flushBufferIfFull
	position = self bufferSize 
		ifTrue: [ self flushBuffer ]
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
int16: integer
	^ self nextIntegerOfSize: 2 signed: true bigEndian: true put: integer
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
int32: integer
	^ self nextIntegerOfSize: 4 signed: true bigEndian: true put: integer
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
int8: integer
	^ self nextIntegerOfSize: 1 signed: true bigEndian: true put: integer
%

category: 'testing'
method: ZnBufferedWriteStream
isBinary

	^ stream isBinary
%

category: 'testing'
method: ZnBufferedWriteStream
isStream

	^ true
%

category: 'accessing'
method: ZnBufferedWriteStream
lf
	self nextPut: Character lf
%

category: 'accessing'
method: ZnBufferedWriteStream
next: count putAll: collection
	"Write count elements from collection"
	
	self 
		next: count 
		putAll: collection 
		startingAt: 1
%

category: 'accessing'
method: ZnBufferedWriteStream
next: count putAll: collection startingAt: offset
	"Write count elements from collection starting at offset."
	
	self flushBufferIfFull.
	count <= self bufferFreeSize
		ifTrue: [
			self buffer replaceFrom: position + 1 to: position + count with: collection startingAt: offset.
			position := position + count ]
		ifFalse: [
			self flushBuffer.
			count > (self bufferSize / 2)
				ifTrue: [ stream next: count putAll: collection startingAt: offset ]
				ifFalse: [ self next: count putAll: collection startingAt: offset ] ]
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
nextInt32Put: integer
	^ self nextIntegerOfSize: 4 signed: true bigEndian: true put: integer
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
nextIntegerOfSize: numberOfBytes signed: signed bigEndian: bigEndian put: value
	"Assuming the receiver is a stream of bytes, write value as the next integer of size numberOfBytes.
	If bigEndian is true, use network byte order, most significant byte first, 
	else use little endian order, least significant byte first.
	If signed is true, encode as a two-complement signed value, 
	else encode as a plain unsigned value."
	
	| unsignedValue |
	unsignedValue := (signed and: [ value negative ])
		ifTrue: [ (1 << (numberOfBytes * 8)) + value ] 
		ifFalse: [ value ].
	(unsignedValue between: 0 and: (2 raisedTo: (numberOfBytes * 8)) - 1)
		ifFalse: [ self error: 'Domain Error ', unsignedValue printString, ' outside of expected range' ].
	bigEndian
		ifTrue: [ 
			numberOfBytes to: 1 by: -1 do: [ :index |
				self nextPut: (unsignedValue digitAt: index) ] ]
		ifFalse: [ 
			1 to: numberOfBytes do: [ :index |
				self nextPut: (unsignedValue digitAt: index) ] ].
	^ value
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
nextLittleEndianNumber: numberOfBytes put: integer
	^ self nextIntegerOfSize: numberOfBytes signed: false bigEndian: false put: integer
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
nextNumber: numberOfBytes put: integer
	^ self nextIntegerOfSize: numberOfBytes signed: false bigEndian: true put: integer
%

category: 'accessing'
method: ZnBufferedWriteStream
nextPut: object
	self flushBufferIfFull.
	position := position + 1.
	self buffer at: position put: object
%

category: 'accessing'
method: ZnBufferedWriteStream
nextPutAll: collection
	"Write a collection"
	
	self 
		next: collection size 
		putAll: collection 
		startingAt: 1
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
nextWordPut: integer
	^ self nextIntegerOfSize: 2 signed: false bigEndian: true put: integer
%

category: 'initialize-release'
method: ZnBufferedWriteStream
on: writeStream
	stream := writeStream.
	position := 0
%

category: 'accessing'
method: ZnBufferedWriteStream
position

	^ stream position + position
%

category: 'accessing'
method: ZnBufferedWriteStream
position: anInteger 
	self flush.
	stream position: anInteger
%

category: 'accessing'
method: ZnBufferedWriteStream
print: object
	object printOn: self
%

category: 'printing'
method: ZnBufferedWriteStream
printOn: aStream
	aStream 
		nextPutAll: 'a '; 
		nextPutAll: self class name
%

category: 'accessing'
method: ZnBufferedWriteStream
setToEnd
	
	self flush.
	stream setToEnd
%

category: 'accessing'
method: ZnBufferedWriteStream
sizeBuffer: size
	buffer := (stream isBinary ifTrue: [ ByteArray ] ifFalse: [ String ]) new: size
%

category: 'accessing'
method: ZnBufferedWriteStream
space
	self nextPut: Character space
%

category: 'accessing'
method: ZnBufferedWriteStream
tab
	self nextPut: Character tab
%

category: 'accessing'
method: ZnBufferedWriteStream
truncate
	
	stream truncate
%

category: 'accessing'
method: ZnBufferedWriteStream
truncate: anInteger 
	
	self flush.
	stream truncate: anInteger
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
uint16: integer
	^ self nextIntegerOfSize: 2 signed: false bigEndian: true put: integer
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
uint32: integer
	^ self nextIntegerOfSize: 4 signed: false bigEndian: true put: integer
%

category: 'accessing-bytes'
method: ZnBufferedWriteStream
uint8: integer
	^ self nextIntegerOfSize: 1 signed: false bigEndian: true put: integer
%

! Class implementation for 'ZnCharacterEncoder'

!		Class methods for 'ZnCharacterEncoder'

category: 'accessing'
classmethod: ZnCharacterEncoder
canonicalEncodingIdentifier: string
	^ (string select: [ :each | each isAlphaNumeric ]) asLowercase
%

category: 'accessing'
classmethod: ZnCharacterEncoder
handlesEncoding: string
	"Return true when my instances handle the encoding described by string"
	
	self subclassResponsibility: #handlesEncoding:
%

category: 'accessing'
classmethod: ZnCharacterEncoder
knownEncodingIdentifiers
	"Return a collection of all known encoding identifiers in the system"
	
	self = ZnCharacterEncoder ifFalse: [ ^ #() ].
	^ Array streamContents: [ :all |
		self allSubclasses do: [ :subClass |
			all nextPutAll: subClass knownEncodingIdentifiers ] ]
%

category: 'instance creation'
classmethod: ZnCharacterEncoder
newForEncoding: string
	"Return a new character encoder object for an encoding described by string.
	Search for a subclass that handles it and delegate (subclassResponsibility)."
	
	| concreteSubclass |
	concreteSubclass := self allSubclasses 
		detect: [ :each | each handlesEncoding: string ] 
		ifNone: [ ^ self error: 'The ', string printString, ' is not currently supported.' ].
	^ concreteSubclass newForEncoding: string
%

!		Instance methods for 'ZnCharacterEncoder'

category: 'converting'
method: ZnCharacterEncoder
asZnCharacterEncoder
	^ self
%

category: 'converting'
method: ZnCharacterEncoder
backOnStream: stream
	"Move back one character on stream, assuming stream understands #back"
	
	self subclassResponsibility: #backOnStream:
%

category: 'convenience'
method: ZnCharacterEncoder
decodeAsCodePoints: bytes
	"Decode bytes and return the resulting code points"
	
	self subclassResponsibility: #decodeAsCodePoints:
%

category: 'convenience'
method: ZnCharacterEncoder
encodeCodePoints: codePoints
	"Encode codePoints and return the resulting byte array"
	
	^ self subclassResponsibility: #encodeCodePoints:
%

category: 'converting'
method: ZnCharacterEncoder
encodedByteCountFor: character
	"Return how many bytes are needed to encode character"
	
	"We should use #codePoint but #asInteger is faster"
	
	^ self encodedByteCountForCodePoint: character asInteger
%

category: 'convenience'
method: ZnCharacterEncoder
encodedByteCountForCodePoints: codePoints
	"Return the exact number of bytes it would take to encode codePoints as a byte array"

	^self subclassResponsibility: #encodedByteCountForCodePoints:
%

category: 'convenience'
method: ZnCharacterEncoder
encodedByteCountForString: string
	"Return the exact number of bytes it would take to encode string as a byte array"

	^self subclassResponsibility: #encodedByteCountForCodePoints:
%

category: 'convenience'
method: ZnCharacterEncoder
next: count putAll: string startingAt: offset toStream: stream
	"Write count characters from string starting at offset to stream."
	
	offset to: offset + count - 1 do: [ :index | 
		self nextPut: (string at: index) toStream: stream ]
%

category: 'converting'
method: ZnCharacterEncoder
nextCodePointFromStream: stream
	"Read and return the next integer code point from stream"
	
	self subclassResponsibility: #nextCodePointFromStream:
%

category: 'converting'
method: ZnCharacterEncoder
nextFromStream: stream
	"Read and return the next character from stream"
	
	"We should use #codePoint: but #value: is faster"
	
	^ Character value: (self nextCodePointFromStream: stream)
%

category: 'converting'
method: ZnCharacterEncoder
nextPut: character toStream: stream
	"Write the encoding for character to stream"
	
	"We should use #codePoint but #asInteger is faster"
	
	self nextPutCodePoint: character asInteger toStream: stream
%

! Class implementation for 'ZnUTF8Encoder'

!		Class methods for 'ZnUTF8Encoder'

category: 'accessing'
classmethod: ZnUTF8Encoder
default
	"Return a cached instance of the most commonly used encoder,
	which is faster than going via #newForEncoding: that does a subclass search"
	
	^ Default ifNil: [ Default := self new ]
%

category: 'accessing'
classmethod: ZnUTF8Encoder
handlesEncoding: string
	"Return true when my instances handle the encoding described by string"
	
	^ (self canonicalEncodingIdentifier: string) = 'utf8'
%

category: 'accessing'
classmethod: ZnUTF8Encoder
knownEncodingIdentifiers
	^ #( utf8 )
%

category: 'instance creation'
classmethod: ZnUTF8Encoder
newForEncoding: string
	"No further parametrization needed"
	
	^ self new
%

!		Instance methods for 'ZnUTF8Encoder'

category: 'converting'
method: ZnUTF8Encoder
backOnStream: stream
	"Move back one character on stream"

	self error: 'not currently supported'
%

category: 'convenience'
method: ZnUTF8Encoder
decodeAsCodePoints: bytes
	"Decode bytes and return the resulting code points"

	| ar |
	ar := {}.
	bytes decodeFromUTF8 do: [:char | ar add: char codePoint ].
	^ ar
%

category: 'convenience'
method: ZnUTF8Encoder
decodeBytes: bytes
	"Decode bytes and return the resulting string"

	^ bytes decodeFromUTF8
%

category: 'convenience'
method: ZnUTF8Encoder
encodeCodePoints: codePoints
	"Encode codePoints and return the resulting byte array"
	
	^ codePoints asByteArray asUnicodeString encodeAsUTF8
%

category: 'converting'
method: ZnUTF8Encoder
encodedByteCountFor: character
	"Return how many bytes are needed to encode character"
		
	^ character asString encodeAsUTF8 size
%

category: 'convenience'
method: ZnUTF8Encoder
encodedByteCountForCodePoints: codePoints
	"Return the exact number of bytes it would take to encode codePoints as a byte array"

	^ (self encodeCodePoints: codePoints) size
%

category: 'convenience'
method: ZnUTF8Encoder
encodedByteCountForString: string
	"Return the exact number of bytes it would take to encode string as a byte array"

	^ (self encodeString: string) size
%

category: 'convenience'
method: ZnUTF8Encoder
encodeString: string
	"Encode string and return the resulting Utf8 instance"
	
	^ string encodeAsUTF8 asByteArray
%

category: 'accessing'
method: ZnUTF8Encoder
identifier
	^ #utf8
%

category: 'convenience'
method: ZnUTF8Encoder
next: count putAll: string startingAt: offset toStream: stream
	"Write count characters from string starting at offset to stream."
	
	stream nextPutAll: (string copyFrom: offset to: offset + count - 1) encodeAsUTF8 asByteArray
%

category: 'converting'
method: ZnUTF8Encoder
nextCodePointFromStream: stream
	"Read and return the next integer code point from stream"

	self error: 'not currently supported'
%

category: 'converting'
method: ZnUTF8Encoder
nextPutCodePoint: codePoint toStream: stream
	"Write the encoding for Integer code point to stream"

	^ stream nextPutAll: (Character codePoint: codePoint) asString encodeAsUTF8
%

category: 'convenience'
method: ZnUTF8Encoder
readInto: aCollection startingAt: offset count: requestedCount fromStream: stream
	"Read requestedCount characters into string starting at offset,
	returning the number read, there could be less available when stream is atEnd"

	| decodedCollection pos |
	pos := stream position.
	decodedCollection := self decodeBytes: stream contents.
	aCollection 
		replaceFrom: offset 
		to: offset + (requestedCount min: decodedCollection size) - 1
		with: decodedCollection
		startingAt: pos + 1.
	stream setToEnd.
	^ 	requestedCount min: decodedCollection size
%

! Class implementation for 'ZnCharacterReadWriteStream'

!		Class methods for 'ZnCharacterReadWriteStream'

category: 'instance creation'
classmethod: ZnCharacterReadWriteStream
on: wrappedStream encoding: encoding

	^ self new
		on: wrappedStream encoding: encoding;
		yourself
%

!		Instance methods for 'ZnCharacterReadWriteStream'

category: 'accessing'
method: ZnCharacterReadWriteStream
atEnd
	
	^ readStream atEnd
%

category: 'accessing'
method: ZnCharacterReadWriteStream
close
	
	writeStream close
%

category: 'testing'
method: ZnCharacterReadWriteStream
closed
	^ writeStream closed
%

category: 'accessing'
method: ZnCharacterReadWriteStream
collectionSpecies
	^ String
%

category: 'accessing'
method: ZnCharacterReadWriteStream
cr
	
	writeStream cr
%

category: 'accessing'
method: ZnCharacterReadWriteStream
flush

	writeStream flush
%

category: 'testing'
method: ZnCharacterReadWriteStream
isReadOnly
	
	^ false
%

category: 'accessing'
method: ZnCharacterReadWriteStream
next
	
	^ readStream next
%

category: 'accessing'
method: ZnCharacterReadWriteStream
next: anInteger 
	
	^ readStream next: anInteger
%

category: 'accessing'
method: ZnCharacterReadWriteStream
nextPut: aCharacter

	^ writeStream nextPut: aCharacter
%

category: 'accessing'
method: ZnCharacterReadWriteStream
nextPutAll: aString

	^ writeStream nextPutAll: aString
%

category: 'instance creation'
method: ZnCharacterReadWriteStream
on: aStream encoding: encoding
	| encoder |
	encoder := encoding asZnCharacterEncoder.
	readStream := ZnCharacterReadStream on: aStream encoding: encoder.
	writeStream := ZnCharacterWriteStream on: aStream encoding: encoder
%

category: 'accessing'
method: ZnCharacterReadWriteStream
peek
	
	^ readStream peek
%

category: 'accessing'
method: ZnCharacterReadWriteStream
position

	^ readStream position
%

category: 'accessing'
method: ZnCharacterReadWriteStream
position: anInteger 
	
	readStream position: anInteger
%

category: 'accessing'
method: ZnCharacterReadWriteStream
readOnlyCopy

	^ readStream
%

category: 'accessing'
method: ZnCharacterReadWriteStream
setToEnd

	writeStream setToEnd
%

category: 'accessing'
method: ZnCharacterReadWriteStream
size

	^ readStream size
%

category: 'accessing'
method: ZnCharacterReadWriteStream
skip: anInteger 
	
	readStream skip: anInteger
%

category: 'accessing'
method: ZnCharacterReadWriteStream
space
	
	writeStream space
%

category: 'accessing'
method: ZnCharacterReadWriteStream
upToAll: aCollection
	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."
	
	^ self collectionSpecies streamContents: [ :out |
		| partialMatch pattern matched |
		partialMatch := (self collectionSpecies new: aCollection size) writeStream.
		pattern := aCollection readStream.
		matched := false.
		([ matched or: [ self atEnd or: [ pattern atEnd ] ] ]) whileFalse: [
			| ch |
			(ch := self next) = pattern next
				ifTrue: [
					pattern atEnd
						ifTrue: [ matched := true ]
						ifFalse: [ partialMatch nextPut: ch ] ]
				ifFalse: [
					pattern reset.
					out nextPutAll: partialMatch contents.
					partialMatch reset.
					out nextPut: ch ] ].
		matched ifFalse: [ out nextPutAll: partialMatch contents ] ]
%

category: 'accessing'
method: ZnCharacterReadWriteStream
upToEnd
	
	^ readStream upToEnd
%

! Class implementation for 'ZnEncodedStream'

!		Class methods for 'ZnEncodedStream'

category: 'accessing'
classmethod: ZnEncodedStream
defaultEncoder
	^ ZnUTF8Encoder default
%

category: 'instance creation'
classmethod: ZnEncodedStream
on: wrappedStream
	^ self new
		on: wrappedStream;
		yourself
%

category: 'instance creation'
classmethod: ZnEncodedStream
on: wrappedStream encoding: encoding
	^ self new
		on: wrappedStream;
		encoding: encoding;
		yourself
%

!		Instance methods for 'ZnEncodedStream'

category: 'initialize-release'
method: ZnEncodedStream
close
	stream close
%

category: 'testing'
method: ZnEncodedStream
closed
	^ stream closed
%

category: 'accessing'
method: ZnEncodedStream
encoder
	^ encoder ifNil: [ encoder := self class defaultEncoder ]
%

category: 'initialize-release'
method: ZnEncodedStream
encoder: characterEncoder
	encoder := characterEncoder
%

category: 'initialize-release'
method: ZnEncodedStream
encoding: encoding
	encoder := encoding asZnCharacterEncoder
%

category: 'testing'
method: ZnEncodedStream
isStream
  ^ true
%

category: 'initialize-release'
method: ZnEncodedStream
on: wrappedStream
	stream := wrappedStream
%

category: 'accessing'
method: ZnEncodedStream
position
	^ stream position
%

category: 'accessing'
method: ZnEncodedStream
position: aPosition
	stream position: aPosition
%

category: 'accessing'
method: ZnEncodedStream
setToEnd
	stream setToEnd
%

category: 'accessing'
method: ZnEncodedStream
size
	^ stream size
%

category: 'accessing'
method: ZnEncodedStream
truncate
	stream truncate
%

category: 'accessing'
method: ZnEncodedStream
truncate: anInteger 
	stream truncate: anInteger
%

category: 'accessing'
method: ZnEncodedStream
wrappedStream
	^ stream
%

category: 'accessing'
method: ZnEncodedStream
wrappedStreamName
	^ stream wrappedStreamName
%

! Class implementation for 'ZnEncodedReadStream'

!		Instance methods for 'ZnEncodedReadStream'

category: 'testing'
method: ZnEncodedReadStream
atEnd
	^ peeked isNil and: [ stream atEnd ]
%

category: 'accessing'
method: ZnEncodedReadStream
contents
	
	^ self collectionSpecies
		streamContents: [ :collectionStream | 
			collectionStream nextPutAll: (self encoder decodeBytes: stream  contents) ]
%

category: 'testing'
method: ZnEncodedReadStream
isBinary
	^ false
%

category: 'testing'
method: ZnEncodedReadStream
isReadOnly

	^ true
%

category: 'accessing'
method: ZnEncodedReadStream
next
	^ peeked
		ifNil: [ 
			stream atEnd ifFalse: [ self nextElement ] ]
		ifNotNil: [ | character |
			character := peeked.
			peeked := nil.
			character ]
%

category: 'accessing'
method: ZnEncodedReadStream
next: requestedCount 
	"Read requestedCount elements into new collection and return it,
	 it could be that less elements were available"

	^ self 
		next: requestedCount 
		into: (self collectionSpecies new: requestedCount)
%

category: 'accessing'
method: ZnEncodedReadStream
next: requestedCount into: collection
	"Read requestedCount elements into collection,
	returning a copy if less elements are available"
	
	^ self
		next: requestedCount
		into: collection
		startingAt: 1
%

category: 'accessing'
method: ZnEncodedReadStream
next: requestedCount into: collection startingAt: offset
	"Read requestedCount elements into collection starting at offset,
	returning a copy if less elements are available"
	
	| readCount |
	readCount := self 
		readInto: collection 
		startingAt: offset 
		count: requestedCount.
	^ requestedCount = readCount
		ifTrue: [ collection ]
		ifFalse: [ collection copyFrom: 1 to: offset + readCount - 1 ]
%

category: 'private'
method: ZnEncodedReadStream
nextElement
	self subclassResponsibility 
%

category: 'accessing'
method: ZnEncodedReadStream
nextInto: collection
	"Read the next elements of the receiver into collection,
	returning a copy if less elements are available"
	
	^ self
		next: collection size
		into: collection
%

category: 'accessing'
method: ZnEncodedReadStream
peek
	^ peeked
		ifNil: [
			stream atEnd ifFalse: [ peeked := self nextElement ] ]
%

category: 'accessing'
method: ZnEncodedReadStream
peekFor: object
	^ self peek = object
		ifTrue: [ 
			self next.
			true ]
		ifFalse: [ false ]
%

category: 'accessing'
method: ZnEncodedReadStream
position

	^ super position - (peeked ifNil: [ 0 ] ifNotNil: [ 1 ])
%

category: 'accessing'
method: ZnEncodedReadStream
position: anInteger
	super position: anInteger.
	peeked := nil
%

category: 'accessing'
method: ZnEncodedReadStream
readInto: collection startingAt: offset count: requestedCount
	"Read requestedCount elements into collection starting at offset,
	returning the number of elements read, there could be less elements available.
	This is an inefficient abstract implementation, reading one by one."
	
	0 to: requestedCount - 1 do: [ :count | | object |
		(object := self next) ifNil: [ ^ count ].  
		collection at: offset + count put: object ].
	^ requestedCount
%

category: 'accessing'
method: ZnEncodedReadStream
skip: count
	count timesRepeat: [ self next ]
%

category: 'accessing'
method: ZnEncodedReadStream
upTo: anObject 	
	^ self collectionSpecies 
		streamContents: [ :out | | element |
			[ self atEnd or: [ (element := self next) = anObject ] ] whileFalse: [ 
				out nextPut: element ] ]
%

category: 'accessing'
method: ZnEncodedReadStream
upToEnd
	^ self collectionSpecies
		streamContents: [ :collectionStream | 
			[ self atEnd ] whileFalse: [ collectionStream nextPut: self next ] ]
%

! Class implementation for 'ZnCharacterReadStream'

!		Instance methods for 'ZnCharacterReadStream'

category: 'accessing'
method: ZnCharacterReadStream
collectionSpecies
	^ String
%

category: 'accessing'
method: ZnCharacterReadStream
match: subCollection 
	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."
	| pattern startMatch |
	pattern := subCollection readStream.
	startMatch := nil.
	[ pattern atEnd ] whileFalse: 
		[ self atEnd ifTrue: [ ^ false ].
		self next = pattern next 
			ifTrue: [ pattern position = 1 ifTrue: [ startMatch := self position ] ]
			ifFalse: 
				[ pattern position: 0.
				startMatch ifNotNil: 
					[ self position: startMatch.
					startMatch := nil ] ] ].
	^ true
%

category: 'private'
method: ZnCharacterReadStream
nextElement
	^ self encoder nextFromStream: stream
%

category: 'accessing'
method: ZnCharacterReadStream
nextLine
	"Read a CR, LF or CRLF terminated line, returning the contents of the line without the EOL. Return nil when the receiver is #atEnd."
	
	self atEnd ifTrue: [ ^ nil ].
	^ self collectionSpecies streamContents: [ :out |
		out nextPutAll: (self encoder decodeBytes: stream nextLine) ]
%

category: 'accessing'
method: ZnCharacterReadStream
readInto: collection startingAt: offset count: requestedCount 
	"Read count elements and place them in collection starting at offset.
	Return the number of elements actually read."
	
	^ peeked 
		ifNil: [ | readCount |
			readCount := self encoder 
					readInto: collection 
					startingAt: offset 
					count: requestedCount 
					fromStream: stream.
			readCount ]
		ifNotNil: [ 
			collection at: offset put: peeked.
			peeked := nil.
			(self 
				readInto: collection 
				startingAt: offset + 1
				count: requestedCount - 1) + 1 ]
%

category: 'accessing'
method: ZnCharacterReadStream
upToAll: aCollection
	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."
	
	^ self collectionSpecies streamContents: [ :out |
		| partialMatch pattern matched |
		partialMatch := (self collectionSpecies new: aCollection size) writeStreamPortable.
		pattern := aCollection readStreamPortable.
		matched := false.
		([ matched or: [ self atEnd or: [ pattern atEnd ] ] ]) whileFalse: [
			| ch |
			(ch := self next) = pattern next
				ifTrue: [
					pattern atEnd
						ifTrue: [ matched := true ]
						ifFalse: [ partialMatch nextPut: ch ] ]
				ifFalse: [
					pattern reset.
					out nextPutAll: partialMatch contents.
					partialMatch reset.
					out nextPut: ch ] ].
		matched ifFalse: [ out nextPutAll: partialMatch contents ] ]
%

! Class implementation for 'ZnEncodedWriteStream'

!		Instance methods for 'ZnEncodedWriteStream'

category: 'accessing'
method: ZnEncodedWriteStream
<< collection
	^ self nextPutAll: collection
%

category: 'accessing'
method: ZnEncodedWriteStream
flush
	stream flush
%

category: 'testing'
method: ZnEncodedWriteStream
isBinary
	^ false
%

category: 'accessing'
method: ZnEncodedWriteStream
next: count putAll: collection	
	self 
		next: count 
		putAll: collection 
		startingAt: 1
%

category: 'accessing'
method: ZnEncodedWriteStream
next: count putAll: collection startingAt: offset
	"Write count items from collection starting at offset.
	This is an inefficient abstract implementation writing one by one."
	
	0 to: count - 1 do: [ :each | 
		self nextPut: (collection at: offset + each) ]
%

category: 'accessing'
method: ZnEncodedWriteStream
nextPut: anObject
	self subclassResponsibility
%

category: 'accessing'
method: ZnEncodedWriteStream
nextPutAll: collection

	stream nextPutAll: (self encoder encodeString: collection)
%

! Class implementation for 'ZnCharacterWriteStream'

!		Instance methods for 'ZnCharacterWriteStream'

category: 'accessing'
method: ZnCharacterWriteStream
cr
	self nextPut: Character cr
%

category: 'accessing'
method: ZnCharacterWriteStream
crlf
	self cr; lf
%

category: 'accessing'
method: ZnCharacterWriteStream
lf
	self nextPut: Character lf
%

category: 'accessing'
method: ZnCharacterWriteStream
next: count putAll: collection startingAt: offset
	"Write count characters from collection starting at offset."
	
	self encoder 
		next: count 
		putAll: collection 
		startingAt: offset 
		toStream: stream 
%

category: 'accessing'
method: ZnCharacterWriteStream
nextPut: object
	self encoder 
		nextPut: object 
		toStream: stream.
	^ object
%

category: 'accessing'
method: ZnCharacterWriteStream
print: object
	object printOn: self
%

category: 'accessing'
method: ZnCharacterWriteStream
space
	self nextPut: Character space
%

category: 'accessing'
method: ZnCharacterWriteStream
tab
	self nextPut: Character tab
%

! Class implementation for 'TonelSTONWriter'

!		Instance methods for 'TonelSTONWriter'

category: 'accessing'
method: TonelSTONWriter
aliases
	^ aliases
%

category: 'accessing'
method: TonelSTONWriter
aliases: aDictionary
	aliases := aDictionary
%

category: 'private'
method: TonelSTONWriter
encodeKey: key value: value

	super encodeKey: key asSymbol
		value: (value isSymbol ifTrue: [value asString] ifFalse: [value])
%

category: 'writing'
method: TonelSTONWriter
encodeMap: pairs
	| first |
	first := true.
	writeStream nextPut: ${.
	pairs isEmpty
		ifTrue: [
			self prettyPrintSpace ]
		ifFalse: [
			self indentedDo: [
				pairs size = 1 
					ifTrue: [ self prettyPrintSpace ]
					ifFalse: [ self newlineIndent ].
				pairs keysAndValuesDo: [ :key :value |
					first 
						ifTrue: [ first := false ] 
						ifFalse: [ self mapElementSeparator ].
					self encodeKey: key value: value ] ].
				pairs size = 1 
					ifTrue: [ self prettyPrintSpace ]
					ifFalse: [ self newlineIndent ] ].
	writeStream nextPut: $}
%

category: 'initialization'
method: TonelSTONWriter
initialize
	super initialize.
	self prettyPrint: true.
	aliases := { Rowan platform orderedDictionaryClass -> nil } asDictionary
%

category: 'accessing'
method: TonelSTONWriter
stonNameFor: aClass
	^ self aliases 
		at: aClass 
		ifAbsent: [ aClass stonName ]
%

category: 'writing'
method: TonelSTONWriter
writeObject: anObject do: block
	(jsonMode and: [ anObject class ~= STON listClass and: [ anObject class ~= STON mapClass ] ])
		ifTrue: [ self error: 'wrong object class for JSON mode' ].
	self with: anObject do: [
		(self stonNameFor: anObject class) ifNotNil: [ :stonName | 
			writeStream nextPutAll: stonName.
			self prettyPrintSpace ].
		block value ]
%

! Class implementation for 'PharoTonelV1STONWriter'

!		Instance methods for 'PharoTonelV1STONWriter'

category: 'private'
method: PharoTonelV1STONWriter
encodeKey: key value: value
	self nextPut: key asSymbol.
	self prettyPrintSpace.
	writeStream nextPut: $:.
	self prettyPrintSpace.
	self nextPut: value asSymbol
%

! Class implementation for 'AbstractBinaryFileStream'

!		Class methods for 'AbstractBinaryFileStream'

category: 'instance creation'
classmethod: AbstractBinaryFileStream
handle: aCollection file: aFile forWrite: aTrue
	
	^ self basicNew
		handle: aCollection file: aFile forWrite: aTrue;
		yourself
%

!		Instance methods for 'AbstractBinaryFileStream'

category: 'testing'
method: AbstractBinaryFileStream
atEnd

	^ File atEnd: handle
%

category: 'accessing'
method: AbstractBinaryFileStream
contents
	"Answer the contents of the receiver while leaving the position unchanged.
	Fail if the receiver doesn't support positioning.
	#upToEnd provides an alternative that doesn't rely on stream positioning."

	| savedPosition contents |

	savedPosition := self position.
	self position: 0.
	contents := self upToEnd.
	self position: savedPosition.
	^contents
%

category: 'character writing'
method: AbstractBinaryFileStream
cr
	
	self nextPut: Character cr asInteger
%

category: 'character writing'
method: AbstractBinaryFileStream
crlf
	
	self nextPutAll: String crlf
%

category: 'accessing'
method: AbstractBinaryFileStream
file
	^ file
%

category: 'accessing'
method: AbstractBinaryFileStream
file: aFile 
	
	file := aFile
%

category: 'flushing'
method: AbstractBinaryFileStream
flush
	"When writing, this flushes the write buffer the stream uses to reduce
	the number of write() system calls it makes. This should generally be
	used before #sync, but on Windows they do the same thing."
	
	File flush: handle
%

category: 'initialization'
method: AbstractBinaryFileStream
handle: aCollection file: aFile forWrite: aBoolean
	
	handle := aCollection.
	file := aFile.
	forWrite := aBoolean
%

category: 'testing'
method: AbstractBinaryFileStream
isBinary
	^ true
%

category: 'character writing'
method: AbstractBinaryFileStream
lf

	self nextPut: Character lf asInteger
%

category: 'accessing'
method: AbstractBinaryFileStream
name

	^ file name
%

category: 'accessing'
method: AbstractBinaryFileStream
next
	"Answer the next byte from this file, or nil if at the end of the file."

	^ (self next: 1) ifEmpty: [ nil ] ifNotEmpty: [ :col | col first ]
%

category: 'accessing'
method: AbstractBinaryFileStream
next: n
	"Return a string with the next n characters of the filestream in it."

	^ self next: n into: (ByteArray new: n)
%

category: 'accessing'
method: AbstractBinaryFileStream
next: n into: aBuffer
	"Return a string with the next n characters of the filestream in it."
	| readBuffer read |
	readBuffer := aBuffer.
	read := File read: handle into: readBuffer startingAt: 1 count: n.
	^read = n 
		ifTrue: [ readBuffer ]
		ifFalse: [ readBuffer copyFrom: 1 to: read ]
%

category: 'reading'
method: AbstractBinaryFileStream
next: n into: aString startingAt: startIndex
	"Read n bytes into the given string.
	Return aString or a partial copy if less than
	n elements have been read."
	|read|
	read := (self readInto: aString startingAt: startIndex count: n).
	^read = n 
		ifTrue: [ aString ]
		ifFalse: [ aString copyFrom: 1 to: startIndex + read - 1 ]	
%

category: 'writing'
method: AbstractBinaryFileStream
next: amount putAll: aByteArray

	forWrite
		ifFalse: [ ^ self error: 'Cannot write a read-only file' ].
	[ File
		write: handle
		from: aByteArray
		startingAt: 1
		count: amount ]
		on: Error
		do: [:ex | (FileWriteError fileName: self name)
				signal:
					(self close
						ifTrue: [ 'File ' , self name , ' is closed' ]
						ifFalse: [ 'File ' , self name , ' write failed' ]) ].
	^ aByteArray
%

category: 'writing'
method: AbstractBinaryFileStream
next: anInteger putAll: aCollection startingAt: startIndex
"Store the next anInteger elements from the given collection."
(startIndex = 1 and:[anInteger = aCollection size])
	ifTrue:[^self nextPutAll: aCollection].
^self nextPutAll: (aCollection copyFrom: startIndex to: startIndex+anInteger-1)
%

category: 'accessing'
method: AbstractBinaryFileStream
nextInto: aBuffer
	"Return a string with the next n characters of the filestream in it."

	^ self next: aBuffer size into: aBuffer
%

category: 'endianess'
method: AbstractBinaryFileStream
nextLittleEndianNumber: n 
	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."

	| bytes s |
	bytes := self next: n.
	s := 0.
	n to: 1 by: -1 do: [:i | s := (s bitShift: 8) bitOr: (bytes at: i)].
	^ s
%

category: 'endianess'
method: AbstractBinaryFileStream
nextLittleEndianNumber: n put: value
	"Answer the next n bytes as a positive Integer or LargePositiveInteger, where the bytes are ordered from least significant to most significant."
	| bytes |
	bytes := ByteArray new: n.
	1 to: n do: [:i | bytes at: i put: (value digitAt: i)].
	self nextPutAll: bytes
%

category: 'writing'
method: AbstractBinaryFileStream
nextPut: anInteger

	^ self nextPutAll: (ByteArray with: anInteger asInteger)
%

category: 'writing'
method: AbstractBinaryFileStream
nextPutAll: aByteArray
	self next: aByteArray basicSize putAll: aByteArray
%

category: 'accessing'
method: AbstractBinaryFileStream
peek
	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "
	self subclassResponsibility
%

category: 'positioning'
method: AbstractBinaryFileStream
position

	^ File getPosition: handle
%

category: 'positioning'
method: AbstractBinaryFileStream
position: aPosition
	
	File setPosition: handle to: aPosition
%

category: 'printing'
method: AbstractBinaryFileStream
printOn: aStream
	"Put a printed version of the receiver onto aStream."

	aStream
		nextPutAll: self class name;
		nextPutAll: ': ';
		print: file name
%

category: 'reading'
method: AbstractBinaryFileStream
readInto: readBuffer startingAt: startIndex count: count

	^ File read: handle into: readBuffer startingAt: startIndex count: count
%

category: 'positioning'
method: AbstractBinaryFileStream
reset
	self position: 0
%

category: 'positioning'
method: AbstractBinaryFileStream
setToEnd
	
	self position: self size
%

category: 'accessing'
method: AbstractBinaryFileStream
size

	^ File sizeOf: handle
%

category: 'positioning'
method: AbstractBinaryFileStream
skip: n
	"Set the character position to n characters from the current position.
	Error if not enough characters left in the file.
	By default we read n characters and we avoid reading the output"
	self next: n
%

category: 'flushing'
method: AbstractBinaryFileStream
sync	
	"When writing, this syncs any written/flushed data still in the kernel
	file system buffers to disk. This should generally be used after #flush,
	but on Windows they do the same thing."

	File sync: handle
%

category: 'accessing'
method: AbstractBinaryFileStream
upTo: delim

	^ self upToAnyOf: (ByteArray with: delim)
%

category: 'accessing'
method: AbstractBinaryFileStream
upToAnyOf: delimiters

	^ ByteArray new: 1000 streamContents: [ :stream | | ch |
		[ (ch := self next) isNil or: [ delimiters includes: ch] ] 
			whileFalse: [ stream nextPut: ch ] ]
%

category: 'accessing'
method: AbstractBinaryFileStream
upToEnd
	"Answer a subcollection from the current access position through the last element of the receiver."

	^ByteArray streamContents: [ :newStream |
		| next |
		[ (next := self next) isNil ] whileFalse: [
			newStream nextPut: next ] ]
%

category: 'accessing'
method: AbstractBinaryFileStream
wrappedStreamName

	^self name
%

! Class implementation for 'BinaryFileStream'

!		Instance methods for 'BinaryFileStream'

category: 'open/close'
method: BinaryFileStream
close
	self closed
		ifTrue: [ ^ self ].
	handle close.
	handle := nil
%

category: 'testing'
method: BinaryFileStream
closed
	^ handle isOpen not
%

category: 'finalization'
method: BinaryFileStream
finalize

	^ self close
%

category: 'accessing'
method: BinaryFileStream
peek
	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "
	| next |
	self atEnd ifTrue: [^ nil].
	next := self next.
	self position: self position - 1.
	^ next
%

category: 'positioning'
method: BinaryFileStream
skip: n
	"Set the character position to n characters from the current position."
	self position: self position + n
%

category: 'positioning'
method: BinaryFileStream
truncate

	self truncate: 0
%

category: 'positioning'
method: BinaryFileStream
truncate: pos
	"Truncate to this position"

	^ File truncate: handle to: pos
%

! Class implementation for 'RwAuditReport'

!		Class methods for 'RwAuditReport'

category: 'other'
classmethod: RwAuditReport
for: anObject

	^self new owner: anObject; 
			log;
			yourself
%

!		Instance methods for 'RwAuditReport'

category: 'other'
method: RwAuditReport
log

	GsFile gciLogClient: '==== Auditing ', owner prettyName.
%

category: 'other'
method: RwAuditReport
owner

	^owner
%

category: 'other'
method: RwAuditReport
owner: anObject


	owner := anObject
%

category: 'other'
method: RwAuditReport
printOn: aStream
	
	aStream nextPutAll: '==============Auditing ', self owner prettyName asString; lf.
	self do: [:e | 
		(e isKindOf: Array) ifTrue: [
			e do: [:err | err printOn: aStream. aStream lf]
		] ifFalse: [e printOn: aStream].
	]
%

! Class implementation for 'CypressMessageDigestStream'

!		Class methods for 'CypressMessageDigestStream'

category: 'instance creation'
classmethod: CypressMessageDigestStream
bytes

	^self on: ByteArray new
%

category: 'instance creation'
classmethod: CypressMessageDigestStream
characters

	^self on: String new
%

category: 'Documentation'
classmethod: CypressMessageDigestStream
comment
"WriteStreamLegacy has a wired in comment method (in 2.3.15), so we
	need this method to answer correctly provide the comment for this 
	class"
" As of GS/64 3.1, comments are now recorded in the class extraDict
  dictionary under the key #comment.  Comment information formerly
  recorded as a GsClassDocumentation under the key #description are
  converted to a string and placed under #comment during DB 
  conversion/upgrade. "

  | cmt |
  cmt := self _extraDictAt: #comment.
  ^ cmt isNil ifTrue: [ '' ] ifFalse: [ cmt ]
%

!		Instance methods for 'CypressMessageDigestStream'

category: 'digests'
method: CypressMessageDigestStream
md5sum

	^self contents md5sum
%

category: 'digests'
method: CypressMessageDigestStream
sha1Sum

	^self contents sha1Sum
%

category: 'digests'
method: CypressMessageDigestStream
sha256Sum

	^self contents sha256Sum
%

category: 'digests'
method: CypressMessageDigestStream
sha512Sum

	^self contents sha512Sum
%

! Class implementation for 'MemoryWriteStream'

!		Instance methods for 'MemoryWriteStream'

category: 'testing'
method: MemoryWriteStream
isReadOnly
	
	^ false
%

category: 'accessing'
method: MemoryWriteStream
readOnlyCopy
	
	^ collection readStreamPortable
%

category: 'positioning'
method: MemoryWriteStream
truncate
	collection truncate
%

category: 'positioning'
method: MemoryWriteStream
truncate: anInteger 
	collection truncate: anInteger 
	
%

! Class extensions for 'AbstractDictionary'

!		Instance methods for 'AbstractDictionary'

category: '*rowan-gemstone-kernel-36x'
method: AbstractDictionary
at: key ifPresent: aBlock
   "Lookup the given key in the receiver. If it is present, answer the value of 
    evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v := self at: key ifAbsent: [^ nil].
	^ aBlock cull: v
%

! Class extensions for 'Array'

!		Instance methods for 'Array'

category: '*Cypress-PackageManagement'
method: Array
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	| indent |
	aStream
		nextPutAll: '[';
		lf.
	indent := startIndent + 1.
	1 to: self size
		do: 
			[:index |
			| item |
			item := self at: index.
			indent timesRepeat: [aStream tab].
			item _writeCypressJsonOn: aStream indent: indent.
			index < self size
				ifTrue: 
					[aStream
						nextPutAll: ',';
						lf]].
	self size = 0 ifTrue: [indent timesRepeat: [aStream tab]].
	aStream nextPutAll: ' ]'
%

! Class extensions for 'Behavior'

!		Instance methods for 'Behavior'

category: '*ast-kernel-core'
method: Behavior
parseTreeFor: aSymbol	
	^ RBParser parseMethod: (self sourceCodeAt: aSymbol) onError: [ :msg :pos | ^ nil ]
%

category: '*rowan-gemstone-kernel'
method: Behavior
rowanPackageName

	"answer the name of the package that the receiver is a member of. Answer 'Rowan unpackagedName` if 
		the receiver is not a member of any package"

	| loadedClass |
	loadedClass := Rowan image
		loadedClassForClass: self thisClass
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedClass loadedPackage name
%

category: '*rowan-gemstone-kernel'
method: Behavior
rowanProjectName

	"answer the name of the project that the receiver is a member of. Answer `Rowan unpackagedName` if 
		the receiver is not a member of any project"

	| loadedClass |
	loadedClass := Rowan image
		loadedClassForClass: self thisClass
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedClass loadedProject name
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileExtensionMethod: sourceString category: categoryName packageName: packageName
	^ Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: categoryName
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		inPackageNamed: packageName
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileExtensionMethod: sourceString package: aPackageName

	| aCategory |
	aCategory := '*', aPackageName asLowercase .
	^Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategory asString asLowercase
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileMethod: sourceString category: aCategoryString

	^ Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategoryString asString
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileMethod: sourceString category: aCategoryString packageName: packageName

	^ Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategoryString
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		inPackageNamed: packageName
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileMethod: sourceString dictionaries: aSymbolList category: aCategoryString packageName: packageName
	"Rowan version of Behavior >> #compileMethod:dictionaries:category:environmentId:"

	"This compiles some source code for the receiver.  The first argument,
 sourceString, is the string of source code to be compiled.  The second
 argument is a SymbolList to be used in parsing, along with the list of all
 class variables and pool dictionaries for the receiver and all of its
 superclasses.  The third argument (a String) indicates the method's category.

 sourceString must be a kind of String or DoubleByteString.  Instances of
 JapaneseString are not supported as source strings.  String literals
 ('abc') are generated as instances of the class of sourceString,
 unless sourceString is a Symbol, in which case 'abc' produces a String.
 If sourceString is a DoubleByteSymbol, 'abc' produces a DoubleByteString.

 anEnvironmentId must be a SmallInteger >= 0 and <= 16rFFFF.
 0 denotes the base Smalltalk image.  1 was reserved for use by Ruby .

 If there are no errors, this adds the resulting compiled method to the
 receiver's method dictionary and returns that method,
 otherwise signals a CompileError .
 A CompileWarning may be signaled, after adding the new method
 to a receiver's method dictionary."

	^ Rowan projectTools browser
		addOrUpdateMethod: sourceString
		dictionaries: aSymbolList
		inProtocol: aCategoryString
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		inPackageNamed: packageName
%

category: '*rowan-gemstone-35x'
method: Behavior
rwGuaranteePersistentMethodDictForEnv: envId
	"in 3.5, the method persistentMethodDictForEnv: DOES NOT always return a GsMethodDictionary,
		as classes are created without a GsMethodDictionary for envId 0."

	<primitive: 2001>
	| prot |
	prot := System _protectedMode .
	[ 
		| newDict |
		(self persistentMethodDictForEnv: envId) ifNotNil: [:oldDict | ^ oldDict ].
		newDict := GsMethodDictionary new.
		self persistentMethodDictForEnv: envId put: newDict.
		^ newDict ] 
		ensure:[ prot _leaveProtectedMode ].
%

category: '*rowan-gemstone-kernel-36x'
method: Behavior
rwMethodCategories
	^ self _unifiedCategorys: 0
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwMoveClassToPackage: packageName
	"Move class to <packageName>, whether or not it has been packaged. The methods in the class that are in the
		original package of the class are also moved to the new package. If the class was originally unpackaged,
		then only unpackaged methods (class and instance side) are moved to the new package."

	^ Rowan projectTools browser
		moveClassNamed: self thisClass name asString
		toPackage: packageName
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwMoveMethod: methodSelector toCategory: categoryName

	^ Rowan projectTools browser
		moveMethod: methodSelector
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		toProtocol: categoryName
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwMoveMethod: methodSelector toPackage: packageName
	"Move the method into <packageName>, whether or not it has been packaged"

	^ Rowan projectTools browser
		moveMethod: methodSelector
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		toPackage: packageName
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwRemoveCategory: categoryName

	^ Rowan projectTools browser
		removeProtocol: categoryName 
		fromClassNamed:  self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwRemoveSelector: methodSelector

	^ Rowan projectTools browser
		removeMethod: methodSelector
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwUnpackageClass
	"Unpackage the receiver and all methods in the class that in the same package, 
		while leaving the class installed in the image"

	^ Rowan projectTools browser unpackageClassNamed: self thisClass name asString
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwUnpackageMethod: methodSelector
	"Move the method into <packageName>, whether or not it has been packaged"

	^ Rowan projectTools browser
		unpackageMethod: methodSelector
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-35x'
method: Behavior
_constraintOn: aSymbol

"Returns the class kind constraint for the instance variable represented by
 aSymbol.  If aSymbol does not represent an instance variable of objects whose
 behavior is defined by the receiver, returns nil.
 If the instance variable aSymbol is not constrained, returns Object ."

| ivNams constrs |

ivNams := instVarNames .
constrs := constraints .
1 to: self instSize do: [ :i |
  aSymbol == (ivNams  at: i) ifTrue:[ ^ self _constraintAt: i ].
].
^ nil
%

category: '*rowan-gemstone-35x'
method: Behavior
_ivOffsetAndConstraint: aSymbol

"Searches the instVarNames instance variable of the receiver for an instance
 variable named aSymbol, and returns an Array containing the offset and the
 constraint for that instance variable.  Returns nil if no instance variable
 exists with the name aSymbol."

| idx |
idx := instVarNames indexOfIdentical: aSymbol .
idx == 0 ifTrue:[ ^ nil ].
^ { idx .  self _constraintAt: idx } 
%

category: '*rowan-gemstone-35x'
method: Behavior
_namedIvConstraintAtOffset: offset

"Returns the constraint, if any, on the named instance variable at the
 specified offset.  Returns Object if there is no such named instance variable,
 or if the instance variable at that offset is not constrained."

(offset > self instSize ) ifTrue:[ ^ Object ] .
^ self _constraintAt: offset 
%

category: '*rowan-gemstone-35x'
method: Behavior
_newConstraint: aClass atOffset: offset

"Execute the constraint change for Behavior | instvar:ConstraintTo:
 assuming all error and variance checks have been done."
| constrs |
self deprecated: 'Behavior>>_newConstraint:atOffset: deprecated, Constraints are no longer supported'.
self _validatePrivilege ifTrue:[ 
  (constrs := constraints) size == 0 ifTrue:[ | sz |
    aClass == Object ifTrue:[ ^ self "do nothing"].
    sz := self instSize .
    (constrs := Array new: sz ) replaceFrom: 1 to: sz withObject: Object.
    constraints := constrs .
  ].
  constrs at: offset put: aClass .
  (aClass == Object) ifFalse:[ self _setConstraintBit ].
  self _refreshClassCache: false .
]
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rowanCopyMethodsAndVariablesFrom: sourceClass dictionaries: dicts

"Copies all instance and class methods, pool dictionaries, and values of
 class variables from the given class to ourselves. 

 Returns an Array of methods in the source class which failed to compile.
 Some of them might be class methods.  The Array will be empty if none failed.

 Method environmentIds are copied from the source methods.
"

| failed srccls targcls sel doit otherCvs |

self _validatePrivilege ifFalse:[ ^ nil ].
self == sourceClass ifTrue:[ 
  "because iteration is directly over the source's categories dictionaries"
  ^ self error: 'source of copy must not be self' 
].
failed := { } .

"Copy pool dictionaries"
sourceClass _poolDictionaries do: [ :dict | | poolDicts |
  poolDicts := poolDictionaries .
  (poolDicts ~~ nil and:[ poolDicts includesIdentical: dict]) ifFalse: [
      poolDicts ifNil:[ poolDicts := { } . poolDictionaries := poolDicts ]
          ifNotNil:[ poolDicts isInvariant ifTrue:[
                       poolDicts := Array withAll: poolDicts . poolDictionaries := poolDicts
                     ]].
      poolDicts add: dict
  ].
].

"Copy class variable values"
otherCvs := sourceClass _classVars .
otherCvs ifNotNil:[ | destCvs |
   destCvs := classVars . 
   otherCvs == destCvs ifTrue: [ self halt ].
   otherCvs associationsDo: [ :assn | | other |
    destCvs ifNotNil:[ other := destCvs associationAt: assn key otherwise: nil ].
	(other == assn)
		ifTrue: [
			"avoid sharing associations between the reciever and sourceClass"
			destCvs removeKey: other key.	"remove the association"
			destCvs at: assn key put: assn value
		].
    (other == nil or: [other value == nil and: [assn value ~~ nil]]) ifTrue: [
        destCvs ifNil:[ destCvs := self _createClassVarsDict ].
        destCvs at: assn key put: assn value
    ].
  ].
].

"Copy class and instance methods"
1 to: 2 do: [ :j | | envId |
  j == 1 ifTrue:[ srccls := sourceClass.  targcls := self ] 
        ifFalse:[ srccls := sourceClass class.  targcls := self class ].
  envId := 0 .
  srccls categorysDo:[ :cat :sels |
      1 to: sels size do: [ :s | | oldMeth |
	sel := sels at: s.
	doit := true.
	doit ifTrue: [ | methEnvId |
          oldMeth := srccls compiledMethodAt: sel environmentId: envId .
	  methEnvId := oldMeth environmentId .
          methEnvId == envId ifFalse:[ self error:'environmentId mismatch']. 
	  ( targcls 
	     _compileMethodTrappingErrors: oldMeth sourceString 
	     dictionaries: dicts category: cat environmentId: envId ) ifNotNil:[
	    failed add: oldMeth 
          ].
        ].
      ].
  ].
].

^failed.
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rwInstVar: aString constrainTo: aClass
"Copy of instVar:constratinTo: without requiring that class be mutable"

"Changes the receiver's constraint on the instance variable named
 aString to aClass.

 The argument aString must be the name of an instance variable defined in the
 receiver or inherited from a superclass.  aClass must be a kind of Class.
 The receiver, and any subclasses for which a constraint change will result,
 must be modifiable; otherwise, an error will be generated.

 If the superclass of the receiver has a constraint on the same instance
 variable, then aClass must be identical to, or a subclass of, that inherited
 constraint.

 For each of the receiver's subclasses, if the constraint on the specified
 instance variable is aClass or is a subclass of aClass, then that constraint
 will be unchanged.  Otherwise, the subclass's constraint will be changed to
 aClass."

| ivInfo offset mySubclasses superConstraintClass |
self _validatePrivilege ifFalse:[ ^ nil ].
aClass _validateIsClass ifFalse:[ ^ nil ].
(Symbol _existingWithAll: aString) ifNotNil:[ :aSymbol |
  ivInfo := self _ivOffsetAndConstraint: aSymbol .
].
ivInfo ifNil:[ ^ self _error: #classErrNotAVar args:{ aString } ] .
offset := ivInfo at: 1 .
superConstraintClass := self superClass _namedIvConstraintAtOffset: offset.
(aClass ~~ Object and: [superConstraintClass ~~ Object])
ifTrue: [ 
	(aClass validateSubclassOf: superConstraintClass) ifFalse:[
	  ^ nil
	] ].
mySubclasses := self subclasses .
self _rwNewConstraint: aClass atOffset: offset .
mySubclasses do:[:x| x _rwNewInheritedConstraint: aClass atOffset: offset ] .
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rwNewConstraint: aClass atOffset: offset

	| oldConstraintsArray newConstraintsArray constraintsIndex instanceVariableNames |
	oldConstraintsArray := constraints.
	newConstraintsArray := oldConstraintsArray copy.
	instanceVariableNames := self class allInstVarNames.
	constraintsIndex := instanceVariableNames indexOf: #constraints.
	self _unsafeAt: constraintsIndex put: newConstraintsArray.

	[ self _newConstraint: aClass atOffset: offset ] on: Deprecated do: [:ex | ex resume ].

	constraints immediateInvariant
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rwNewInheritedConstraint: aClass atOffset: offset

"Change the constraint for offset to aClass if that offset is not
 already constrained to be a subclass of aClass.  Assume all
 variance and error checks have been done."

self _validatePrivilege ifTrue:[ 
  ((self _constraintAt: offset ) isSubclassOf: aClass ) ifFalse:[
    self _rwNewConstraint: aClass atOffset: offset .
    self subclasses do:[:aSubcls|
       aSubcls _rwNewInheritedConstraint: aClass atOffset: offset ].
  ] .
]
 
%

category: '*rowan-gemstone-35x'
method: Behavior
_setConstraintBit

"Sets the constraint bit in the 'format' instance variable of the receiver."

self deprecated: 'Behavior>>_setConstraintBit deprecated, Constraints are no longer supported'.
self _validatePrivilege ifTrue:[
  format := format bitOr: 16#10 .
]
%

category: '*rowan-gemstone-35x'
method: Behavior
_setVaryingConstraint: aClass

"Assign a new value to the constraint on unnamed variables of the receiver,
 assuming all checks have been made."

| constrs ofs |

self deprecated: 'Behavior>>_setVaryingConstraint: deprecated, Constraints are no longer supported'.
self _validatePrivilege ifTrue:[
  constrs := constraints .
  ofs := self instSize + 1 .
  constrs size == 0 ifTrue:[ 
    aClass == Object ifTrue:[ ^ self "nothing to do"].
    (constrs := Array new: ofs) replaceFrom: 1 to: ofs withObject: Object .
    constraints := constrs .
  ].
  constrs at: ofs put: aClass .
  (aClass == Object) ifFalse:[ self _setConstraintBit ].
  self _refreshClassCache: false .
]
%

! Class extensions for 'Boolean'

!		Instance methods for 'Boolean'

category: '*ast-kernel-core'
method: Boolean
rbStoreOn: aStream
  aStream nextPutAll: self asString
%

category: '*Cypress-PackageManagement'
method: Boolean
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	aStream nextPutAll: self printString
%

! Class extensions for 'ByteArray'

!		Class methods for 'ByteArray'

category: '*filesystem-gemstone-kernel'
classmethod: ByteArray
readHexFrom: aString
  "Create a byte array from a hexadecimal representation"

  ^ (self new: aString size // 2) readHexFrom: aString readStream
%

!		Instance methods for 'ByteArray'

category: '*filesystem-gemstone-kernel'
method: ByteArray
asString
  "Convert to a String with Characters for each byte"

  ^ String withBytes: self
%

category: '*rowan-gemstone-kernel'
method: ByteArray
byteArrayMap

	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"

	| map |
	map := ByteArray new: 256 withAll: 0.
	self do: [ :ascii | map at: ascii + 1 put: 1 ].
	^ map
%

category: '*filesystem-gemstone-kernel'
method: ByteArray
decodeWith: encoding
	"Produce a String that decodes the receiver, using a specified encoding.
	Encoding is either a ZnCharacterEncoder instance or an identifier for one."
	
	"#[76 101 115 32 195 169 108 195 168 118 101 115 32 102 114 97 110 195 167 97 105 115] decodeWith: #utf8"
	
	^ encoding asZnCharacterEncoder decodeBytes: self
%

category: '*filesystem-gemstone-kernel'
method: ByteArray
utf8Decoded
	"Produce a String decoding the receiver using UTF-8,
	the recommended encoding for Strings, unless you know what you are doing."

	"#[76 101 115 32 195 169 108 195 168 118 101 115 32 102 114 97 110 195 167 97 105 115] utf8Decoded"
	
	^ self decodeFromUTF8
%

! Class extensions for 'Character'

!		Class methods for 'Character'

category: '*filesystem-gemstone-kernel'
classmethod: Character
digitValue: x 
	"Answer the Character whose digit value is x. For example,
	 answer $9 for x=9, $0 for x=0, $A for x=10, $Z for x=35."

	| n |
	n := x asInteger.
	^self withValue: (n < 10 ifTrue: [n + 48] ifFalse: [n + 55])
%

! Class extensions for 'CharacterCollection'

!		Class methods for 'CharacterCollection'

category: '*filesystem-gemstone-kernel'
classmethod: CharacterCollection
crlf
	"Answer a string containing a carriage return and a linefeed."

	^ self with: Character cr with: Character lf
%

!		Instance methods for 'CharacterCollection'

category: '*filesystem-gemstone-kernel'
method: CharacterCollection
asFileReference

	^ FileSystem disk referenceTo: self
%

category: '*filesystem-gemstone-kernel'
method: CharacterCollection
asPath
	"convert myself to a path"
	"Examples:
		'.' asPath
		'~/Desktop' asPath
		'/home/foo' asPath
		'../../foo.bar' asPath"
	^ FileSystem disk resolve: self
%

category: '*filesystem-gemstone-kernel'
method: CharacterCollection
asPathWith: anObject 
	^ anObject pathFromString: self
%

category: '*filesystem-gemstone-kernel'
method: CharacterCollection
asResolvedBy: aFileSystem
	^ aFileSystem resolveString: self
%

category: '*rowan-gemstone-components-kernel'
method: CharacterCollection
asRwGemStoneVersionNumber

	^ RwGemStoneVersionNumber fromString: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
asRwRepository

	"return a platform appropriate repository for the repository identified in the receiver"

	^ self asRwUrl asRwRepository
%

category: '*rowan-gemstone-components-kernel'
method: CharacterCollection
asRwSemanticVersionNumber

	^ RwSemanticVersionNumber fromString: self
%

category: '*rowan-gemstone-url'
method: CharacterCollection
asRwUrl

	""

	^ RwUrl fromString: self
%

category: '*filesystem-gemstone-kernel'
method: CharacterCollection
asZnCharacterEncoder
	"Return a ZnCharacterEncoder instance using the receiver as identifier"
	
	" 'UTF-8' asZnCharacterEncoder "
	
	((self select: [ :each | each isAlphaNumeric ]) asLowercase) = 'utf8' ifFalse: [ self error: 'Only utf8 encoding supported'].
	^ ZnUTF8Encoder new
%

category: '*filesystem-gemstone-kernel'
method: CharacterCollection
encodeWith: encoding
	"Produce a ByteArray that encodes the receiver, using a specified encoding.
	Encoding is either a ZnCharacterEncoder instance or an identifier for one."
	
	" 'Les élèves français' encodeWith: #utf8 "
	
	^ encoding asZnCharacterEncoder encodeString: self
%

category: '*rowan-gemstone-url'
method: CharacterCollection
indexOfAnyOf: specialChars startingAt: oldPos

	oldPos to: self size do: [ :i | 
		(specialChars includes: (self at: i))
			ifTrue: [ ^ i ] ].
	^ 0
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
indexOfAnyOf: aByteArray startingAt: start ifAbsent: aBlock

	"returns the index of the first character in the given set, starting from start"

	| ans |
	ans := self class
		findFirstInString: self
		inSet: aByteArray asByteArray byteArrayMap
		startingAt: start.
	ans = 0
		ifTrue: [ ^ aBlock value ]
		ifFalse: [ ^ ans ]
%

category: '*ast-kernel-core'
method: CharacterCollection
rbStoreOn: aStream
  "Print inside string quotes, doubling inbedded quotes."

  | x |
  aStream nextPut: $'.
  1 to: self size do: [ :i | 
    aStream nextPut: (x := self at: i).
    x = $'
      ifTrue: [ aStream nextPut: x ] ].
  aStream nextPut: $'
%

category: '*rowan-gemstone-components-kernel'
method: CharacterCollection
rwPlatformAttributeMatchForGemStoneVersion: anRwGemStoneVersionConfigurationPlatformAttributeMatcher

	^ anRwGemStoneVersionConfigurationPlatformAttributeMatcher matchString: self
%

category: '*rowan-gemstone-components-kernel'
method: CharacterCollection
rwPlatformAttributeMatchForString: anRwStringConfigurationPlatformAttributeMatcher

	^ anRwStringConfigurationPlatformAttributeMatcher matchString: self
%

category: '*rowan-gemstone-components-kernel'
method: CharacterCollection
rwSemanticIntegerLessThanSelf: anInteger

	"integers have greater precedence than strings"
	"anInteger < aString-> true"

  ^ true
%

category: '*rowan-gemstone-components-kernel'
method: CharacterCollection
rwSemanticStringLessThanSelf: aString

	^ aString < self
%

category: '*rowan-gemstone-components-kernel'
method: CharacterCollection
rwSemanticVersionComponentLessThan: aRwSemanticVersonComponent

	^ aRwSemanticVersonComponent rwSemanticStringLessThanSelf: self
%

category: '*rowan-gemstone-url'
method: CharacterCollection
unescapePercents

	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"

	| ans c asciiVal pos oldPos specialChars |
	ans _ WriteStream on: String new.
	oldPos _ 1.
	specialChars _ '+%'.

	[ 
	pos _ self indexOfAnyOf: specialChars startingAt: oldPos.
	pos > 0 ]
		whileTrue: [ 
			ans nextPutAll: (self copyFrom: oldPos to: pos - 1).
			c _ self at: pos.
			c = $+
				ifTrue: [ ans nextPut: $  ]
				ifFalse: [ 
					(c = $% and: [ pos + 2 <= self size ])
						ifTrue: [ 
							asciiVal _ ((self at: pos + 1) asUppercase digitValueInRadix: 16) * 16
								+ ((self at: pos + 2) asUppercase digitValueInRadix: 16).
							pos _ pos + 2.
							asciiVal > 255
								ifTrue: [ ^ self ].	"not really an escaped string"
							ans nextPut: (Character value: asciiVal) ]
						ifFalse: [ ans nextPut: c ] ].
			oldPos _ pos + 1 ].
	ans nextPutAll: (self copyFrom: oldPos to: self size).
	^ ans contents
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
withGemstoneLineEndings

	"assume the string is textual, and that CR, LF, and CRLF are all 
  valid line endings.  Replace each occurence with a single LF"

	| cr lf crlf inPos outPos outString lineEndPos newOutPos |
	cr := Character cr.
	lf := Character lf.
	crlf := ByteArray new.
	crlf
		add: cr asciiValue;
		add: lf asciiValue.

	inPos := 1.
	outPos := 1.
	outString := self class _newString: self size.

	[ 
	lineEndPos := self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [ 0 ].
	lineEndPos ~= 0 ]
		whileTrue: [ 
			newOutPos := outPos + (lineEndPos - inPos + 1).
			outString
				replaceFrom: outPos
				to: newOutPos - 2
				with: self
				startingAt: inPos.
			outString at: newOutPos - 1 put: lf.
			outPos := newOutPos.

			((self at: lineEndPos) = cr
				and: [ lineEndPos < self size and: [ (self at: lineEndPos + 1) = lf ] ])
				ifTrue: [ 
					"CRLF ending"
					inPos := lineEndPos + 2 ]
				ifFalse: [ 
					"CR or LF ending"
					inPos := lineEndPos + 1 ] ].	"no more line endings.  copy the rest"
	newOutPos := outPos + (self size - inPos + 1).
	outString
		replaceFrom: outPos
		to: newOutPos - 1
		with: self
		startingAt: inPos.

	^ outString copyFrom: 1 to: newOutPos - 1
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
withoutGemstoneLineEndings

	"assume the string is textual, and that CR, LF, and CRLF are all 
	valid line endings.  Remove each occurence. "

	| cr lf crlf inPos outPos outString lineEndPos newOutPos |
	cr := Character cr.
	lf := Character lf.
	crlf := ByteArray new.
	crlf
		add: cr asciiValue;
		add: lf asciiValue.

	inPos := 1.
	outPos := 1.
	outString := self class _newString: self size.

	[ 
	lineEndPos := self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [ 0 ].
	lineEndPos ~= 0 ]
		whileTrue: [ 
			newOutPos := outPos + (lineEndPos - inPos + 1).
			outString
				replaceFrom: outPos
				to: newOutPos - 2
				with: self
				startingAt: inPos.
			outPos := newOutPos - 1.

			((self at: lineEndPos) = cr
				and: [ lineEndPos < self size and: [ (self at: lineEndPos + 1) = lf ] ])
				ifTrue: [ 
					"CRLF ending"
					inPos := lineEndPos + 2 ]
				ifFalse: [ 
					"CR or LF ending"
					inPos := lineEndPos + 1 ] ].	"no more line endings.  copy the rest"
	newOutPos := outPos + (self size - inPos + 1).
	outString
		replaceFrom: outPos
		to: newOutPos - 1
		with: self
		startingAt: inPos.

	^ outString copyFrom: 1 to: newOutPos - 1
%

! Class extensions for 'Class'

!		Instance methods for 'Class'

category: '*rowan-gemstone-35x'
method: Class
indexableSubclass: aString instVarNames: anArrayOfInstvarNames classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDict inDictionary: aDictionary newVersionOf: oldClass description: aDescription constraints: constraintsArray options: optionsArray

	| newClass |
	newClass := self indexableSubclass: aString instVarNames: anArrayOfInstvarNames classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDict inDictionary: aDictionary newVersionOf: oldClass description: aDescription options: optionsArray.
	^ newClass
%

category: '*rowan-gemstone-kernel'
method: Class
rwByteSubclass: aString classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'byteSubclass'
		superclass: self name asString
		instVarNames: #()
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwByteSubclass: aString classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName  options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'byteSubclass'
		superclass: self name asString
		instVarNames: #()
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: #()
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwCategory
	"Provide direct access to category of class."

	^ self category
%

category: '*rowan-gemstone-kernel'
method: Class
rwCategory: aString
	^ Rowan projectTools browser
		updateClassCategory: aString
		forClassNamed: self thisClass name asString
%

category: '*rowan-gemstone-kernel-36x'
method: Class
rwClassDefinitionInSymbolDictionaryNamed: symDictName
	"create an RwClassDefinition for the reciever suitable for recreating the class. Ignore methods"

	| loadedClass superclassName |
superclassName := self superClass ifNil: [ 'nil' ] ifNotNil: [:sc| sc name asString ].
	loadedClass := Rowan image
		loadedClassForClass: self
		ifAbsent: [ 
			^ (RwClassDefinition
				newForClassNamed: self name asString
				super: superclassName
				instvars: (self instVarNames collect: [ :each | each asString ])
				classinstvars: (self class instVarNames collect: [ :each | each asString ])
				classvars: (self classVarNames collect: [ :each | each asString ])
				category: self _classCategory
				comment: self commentForFileout
				pools: (self sharedPools collect: [ :each | each name asString ]) asArray
				type: self rwClassType)
				gs_symbolDictionary: symDictName;
				yourself ].
	^ loadedClass asDefinition
%

category: '*rowan-gemstone-kernel-36x'
method: Class
rwClassType
	"Answer the string the desribes the class type"

	^ self isBytes
		ifTrue: [ 
			self superClass isBytes not
				ifTrue: [ 'byteSubclass' ]
				ifFalse: [ 'normal' ] ]
		ifFalse: [ 
			self areInstancesSpecial
				ifTrue: [ 'immediate' ]
				ifFalse: [ 
					self isNsc
						ifTrue: [ 'normal' ]
						ifFalse: [ 
							(self isVariable and: [ self superClass isVariable not ])
								ifTrue: [ 'variable' ]
								ifFalse: [ 'normal' ] ] ] ]
%

category: '*rowan-gemstone-kernel'
method: Class
rwComment

	"Provide direct access to comment of class, bypassing default comeent string."
  
  ^ (self _extraDictAt: #comment) ifNil: [ '' ]
%

category: '*rowan-gemstone-kernel'
method: Class
rwComment: aString

	^ Rowan projectTools browser
		updateClassComment: aString
		forClassNamed: self thisClass name asString
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: #()
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: #()
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts inDictionary: aDictionary newVersionOf: oldClass category: aCategoryName packageName: aPackageName options: optionsArray
	| loadedPackage |
	loadedPackage := Rowan image
		loadedPackageNamed: aPackageName
		ifAbsent: [ self error: 'No loaded package found for ' , aPackageName printString ].

	aDictionary
		ifNotNil: [ 
			| expectedSymDictName specifiedSymDictName |
			(expectedSymDictName := loadedPackage loadedProject
				symbolDictNameForPackageNamed: aPackageName)
				~= (specifiedSymDictName := aDictionary name asString)
				ifTrue: [ 
					self
						error:
							'Attempt to move a packaged class ' , aString printString
								, ' from the symbol dictionary ' , expectedSymDictName printString
								, ' to the symbol dictionary ' , specifiedSymDictName printString
								, '. Please use the Rowan api to achieve the move' ] ].

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: #()
		options: optionsArray
%

category: '*rowan-gemstone-35x'
method: Class
subclass: aString instVarNames: anArrayOfInstvarNames classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts inDictionary: aDictionary newVersionOf: oldClass description: aDescription constraints: theConstraints options: optionsArray
	"class creation creates a class with no constraints, so if constraints _are_ specified, we need to add them separately"

	| newClass |
	newClass := self 
		_subclass: aString 
		instVarNames: anArrayOfInstvarNames 
		classVars: anArrayOfClassVars 
		classInstVars: anArrayOfClassInstVars 
		poolDictionaries: anArrayOfPoolDicts 
		inDictionary: aDictionary 
		newVersionOf: oldClass 
		description: aDescription 
		options: optionsArray.
	newClass _installConstraints: theConstraints oldClass: oldClass.
	^ newClass
%

category: '*rowan-gemstone-35x'
method: Class
_constraintsEqual: anArray
  "Result true if receiver's constraints equal to anArray or 
   if anArray is empty and receiver's constraints are all Object ."
^ [ | myConstr superInstSiz ofs arySiz |
    anArray _isArray ifTrue:[
      myConstr := constraints .
      superInstSiz := superClass ifNil:[ 0 ] ifNotNil:[:sc | sc instSize] .
      (arySiz := anArray size) == 0 ifTrue:[
	superInstSiz + 1 to: myConstr size do:[:j | 
	  (myConstr at:j ) == Object ifFalse:[ 
	     (j == (self instSize + 1) and:[ superClass ~~ nil]) ifTrue:[
	       ^ self _varyingConstraint isVersionOf: superClass _varyingConstraint 
	     ].
	     ^ false 
	  ].
	].
      ] ifFalse:[ | varConstr instSiz myConstrSiz ivNams |
	instSiz := self instSize .
	varConstr := (myConstr atOrNil: instSiz + 1) ifNil:[ Object]. 
	ofs := 1 .
	myConstr := myConstr copyFrom: superInstSiz + 1 to: instSiz .
	"elements of myConstr, and varConstr, set to nil when finding a matching
	 element in anArray."
	myConstrSiz := myConstr size .
	ivNams := instVarNames .
	1 to: arySiz do:[:j | | elem |
	  elem := anArray at: j .
	  elem _isArray ifTrue:[ | ivNam |
	    ivNam := elem atOrNil: 1 .
	    1 to: myConstrSiz do:[:m |
	      (ivNams at: (superInstSiz + m)) == ivNam ifTrue:[ 
		 ((elem atOrNil: 2) isVersionOf: (myConstr at: m))   ifTrue:[
		   myConstr at: m put: nil .
		 ] ifFalse:[
		   ^ false 
		 ].
	      ].
	    ].
	  ] ifFalse:[
	    j == arySiz ifTrue:[ 
	      (elem isVersionOf: varConstr) ifTrue:[ varConstr := nil ] ifFalse:[ ^ false ]
	    ] ifFalse:[ 
	      ^ false 
	    ].
	  ].
	].
	"items neither nil nor Object were missing from anArray"
	(varConstr == nil or:[ varConstr == Object ]) ifFalse:[ ^ false ].
	1 to: myConstrSiz do:[:j| | cx |
	  ((cx := myConstr at: j ) == nil or:[ cx == Object]) ifFalse:[ ^ false ]
	].
      ]
    ] ifFalse:[
      (self _varyingConstraint isVersionOf: anArray) ifFalse:[ ^ false ].
    ].
    true
  ] onSynchronous: Error do:[:ex| false ].
%

category: '*rowan-gemstone-35x'
method: Class
_equivalentSubclass: oldClass superCls: actualSelf name: aString newOpts: optionsArray newFormat: theFormat newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars inDict: aDictionary constraints: aConstraint isKernel: isKernelBool
	^ self
		_equivalentSubclass: oldClass
		superCls: actualSelf
		name: aString
		newOpts: optionsArray
		newFormat: theFormat
		newInstVars: anArrayOfInstvarNames
		newClassInstVars: anArrayOfClassInstVars
		newPools: anArrayOfPoolDicts
		newClassVars: anArrayOfClassVars
		inDict: aDictionary
		isKernel: isKernelBool
%

category: '*rowan-gemstone-35x'
method: Class
_installConstraints: theConstraints

	| existingConstraintsMap existingVaryingConstraint theConstraintsMap theVaryingConstraint keys 
		existingConstraints myInstVarNames |
	existingConstraintsMap := Dictionary new.
	existingVaryingConstraint := self _varyingConstraint.
	myInstVarNames := self allInstVarNames.
	existingConstraints := [ self _constraints ifNil: [ {} ] ] on: Deprecated do: [:ex | ex resume ].
	1 to: existingConstraints size do: [:index |
		existingConstraintsMap at: (myInstVarNames at: index) put: (existingConstraints at: index ) ].
	theConstraintsMap := Dictionary new.
	theVaryingConstraint := Object.
	theConstraints do: [:arrayOrVaryingConstraintClass |
		arrayOrVaryingConstraintClass _isArray
			ifTrue: [ theConstraintsMap at: (arrayOrVaryingConstraintClass at: 1) put: (arrayOrVaryingConstraintClass at: 2) ]
			ifFalse: [ theVaryingConstraint := arrayOrVaryingConstraintClass ] ].
	keys := existingConstraintsMap keys copy.
	keys addAll: theConstraintsMap keys.
	keys do: [:key | 
		| existingConstraint theConstraint |
		existingConstraint := existingConstraintsMap at: key ifAbsent: [].
		theConstraint := theConstraintsMap at: key ifAbsent: [].
		existingConstraint == theConstraint
			ifFalse: [ 
				| instVarString |
				instVarString := key asString.
				existingConstraint == nil
					ifTrue: [ 
						"add theConstraint" 
						self _rwInstVar: instVarString constrainTo: theConstraint ]
					ifFalse: [ 
						theConstraint == nil
							ifTrue: [ 
								"remove the constraint" 
								self _rwInstVar: instVarString constrainTo: Object ]
							ifFalse: [
								"change the value of the constraint"
                                self _rwInstVar: instVarString constrainTo: theConstraint ] ] ] ].
	existingVaryingConstraint == theVaryingConstraint
		ifFalse: [
			"change the varying constraint"
			[ self _setVaryingConstraint: theVaryingConstraint] on: Deprecated do: [:ex | ex resume ] ].
%

category: '*rowan-gemstone-35x'
method: Class
_installConstraints: theConstraints oldClass: oldClass

	oldClass ifNotNil: [ [ self _installOldConstraints: oldClass _constraints ] on: Deprecated do: [:ex | ex resume ] ].
	theConstraints 
		ifNil: [ constraints := nil ]
		ifNotNil: [ self _installConstraints: theConstraints ]
%

category: '*rowan-gemstone-35x'
method: Class
_installOldConstraints: theConstraints

	constraints := theConstraints copy
%

category: '*rowan-gemstone-kernel'
method: Class
_rwDefinitionOfConstraints
"This is the part of the definition that describes constraints.  Constraints are
 deprecated and not enforced, but may still be useful for some purposes.
 Returns a string of the form
     constraints: { <Array of instance-variable-symbol/class-name pairs> }
 "

| result firstElement constraintArray |
result := String new.

result add: 'constraints: '.
( constraints isKindOf: Array ) ifTrue: [
	constraintArray := self _rwSortedConstraints.
    result addAll: '{ '.
    firstElement := true.
    constraintArray do: [ :ar |
        " if not the first constraint, prefix with a period to separate
          from the last constraint "
        firstElement ifFalse: [
          result add: ' . '; lf; add: '                '
        ]
        ifTrue: [
          firstElement := false
        ].
		(ar  isKindOf: Array ) 
			ifTrue: [
				result add: '{ #'; add: (ar at: 1) ;
					add: ' . '; add: (ar at: 2) name; addLast: $} ]
			ifFalse: [ 
				"varyingConstraint"
				result add: ar name ].
      ].
    result add: ' }'.
  ]
  ifFalse: [
    constraints class class == Metaclass3 ifTrue: [
      result add: constraints name.
    ]
    ifFalse: [
      result add: ' nil'
    ].
  ].

^result
%

category: '*rowan-gemstone-kernel-36x'
method: Class
_rwOptionsArray
  ^ self _optionsArrayForDefinition
%

category: '*rowan-gemstone-kernel'
method: Class
_rwOptionsForDefinition 
  "copy of _optionsForDefinition"

  | result arr |
  result :=  'options: #(' copy .
  arr := self _rwOptionsArray .
  1 to: arr size do:[:j | result add: $ ; add: (arr at: j) ].
  result add: $)  .
  ^ result
%

category: '*rowan-gemstone-kernel-36x'
method: Class
_rwReservedOop
 "returns nil or the SmallInteger specifying a reserved oop"
  ^ self asOopNumber <= System _lastReservedOopNumber 
    ifTrue:[ self asOop ] 
    ifFalse:[ nil ].
%

category: '*rowan-gemstone-kernel'
method: Class
_rwSortedConstraints
"as of https://github.com/dalehenrich/Rowan/issues/293, no longer sorting in alphabetical order ... instance variable order is the right answer"

|   aConstraint constraintArray |
( constraints isKindOf: Array ) ifTrue: [
	constraintArray := {}.
    1 to: self instSize do: [ :x |
      aConstraint := constraints atOrNil: x .
      ((aConstraint ~~ nil _and: [aConstraint ~~ Object])
          _and:[ superClass == nil
            _or:[ ((superClass _namedIvConstraintAt: x) isVersionOf: aConstraint) not ]] )
      ifTrue: [ constraintArray add: {(instVarNames at: x) . aConstraint } ] ].

    aConstraint:= self _varyingConstraint.
    ( (aConstraint ~~ Object) _and:
        [(superClass _varyingConstraint) ~~ aConstraint] )
		ifTrue: [ constraintArray add: aConstraint ]
  ]
  ifFalse: [
    constraints class class == Metaclass3 ifTrue: [
      ^ constraints
    ]
    ifFalse: [
      ^nil
    ].
  ].

^constraintArray
%

! Class extensions for 'Collection'

!		Instance methods for 'Collection'

category: '*filesystem-gemstone-kernel'
method: Collection
difference: aCollection
  "Answer the set theoretic difference of two collections."

  ^ self reject: [ :each | aCollection includes: each ]
%

category: '*filesystem-gemstone-kernel'
method: Collection
ifEmpty: aBlock
  self size == 0
    ifTrue: [ ^ aBlock value ]
%

category: '*filesystem-gemstone-kernel'
method: Collection
isEmptyOrNil
  "Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"

  ^ self size == 0
%

! Class extensions for 'CypressAddition'

!		Instance methods for 'CypressAddition'

category: '*rowan-cypress-kernel'
method: CypressAddition
isAddition
  ^ true
%

category: '*cypress-environmental-tools'
method: CypressAddition
loadClassDefinition: aSymbolDictionaryName environmentLoader: environmentLoader
  self definition
    loadClassDefinition: aSymbolDictionaryName
    environmentLoader: environmentLoader
%

category: '*cypress-environmental-tools'
method: CypressAddition
loadMethodDefinition: lookupSymbolList environmentLoader: environmentLoader
  self definition
    loadMethodDefinition: lookupSymbolList
    environmentLoader: environmentLoader
%

category: '*cypress-environmental-tools'
method: CypressAddition
postLoadDefinition: lookupSymbolList environmentId: environmentId
  self definition
    postLoadOver: nil
    lookupSymbolList: lookupSymbolList
    environmentId: environmentId
%

! Class extensions for 'CypressClassDefinition'

!		Instance methods for 'CypressClassDefinition'

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
accept: aVisitor
	aVisitor visitClassDefinition: self.
%

category: '*Cypress-Comparison'
method: CypressClassDefinition
category: aString

	category := aString
%

category: '*Cypress-Comparison'
method: CypressClassDefinition
classCreationSelector
  | type |
  type := self subclassType.
  type = ''
    ifTrue: [ ^ 'subclass:' ]
    ifFalse: [ 
      type = 'indexableSubclass'
        ifTrue: [ ^ 'indexableSubclass:' ]
        ifFalse: [ 
          type = 'byteSubclass'
            ifTrue: [ ^ 'byteSubclass:' ]
            ifFalse: [ self error: 'unknown subclass type: ' , type ] ] ]
%

category: '*Cypress-Comparison'
method: CypressClassDefinition
classDefinitionString

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	stream
		nextPut: $(;
		nextPutAll: superclassName;
		space;
		nextPutAll: self classCreationSelector;
		space;
		nextPutAll: self name printString.
	self subclassType = 'byteSubclass'
		ifFalse: 
			[stream
				lf;
				tab;
				nextPutAll: 'instVarNames: #(' , self instanceVariablesString , ')'].
	stream
		lf;
		tab;
		nextPutAll: 'classVars: #(' , self classVariablesString , ')';
		lf;
		tab;
		nextPutAll: 'classInstVars: #(' , self classInstanceVariablesString , ')';
		lf;
		tab;
		nextPutAll: 'poolDictionaries: #(' , self poolDictionariesString , ')';
		lf;
		tab;
		nextPutAll: 'inDictionary: ''<not-defined>''';
		nextPut: $);
		lf;
		tab;
		tab;
		nextPutAll: 'category: ' , self category printString , ';';
		lf;
		tab;
		tab;
		nextPutAll: 'comment: ' , self comment printString.
	^stream contents
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
commentStamp

	^ ''
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
createOrReviseClass

	^ self subclassType = ''
		ifTrue: [ self createOrReviseRegularClass ]
		ifFalse: [ 
			self subclassType = 'byteSubclass'
				ifTrue: [ self createOrReviseByteClass ]
				ifFalse: [ 
					| typ |
					typ := self subclassType.
					(typ = 'indexableSubclass' or: [ typ = 'variable' ])
						ifTrue: [ self createOrReviseIndexableClass ]
						ifFalse: [ self error: 'unknown subclass type: ' , self subclassType printString ] ] ]
%

category: '*cypress-environmental-tools'
method: CypressClassDefinition
createOrReviseClass: aSymbolDictionaryName environmentLoader: environmentLoader
  ^ self subclassType = ''
    ifTrue: [ 
      self
        createOrReviseRegularClass: aSymbolDictionaryName
        environmentLoader: environmentLoader ]
    ifFalse: [ 
      self subclassType = 'byteSubclass'
        ifTrue: [ 
          self
            createOrReviseByteClass: aSymbolDictionaryName
            environmentLoader: environmentLoader ]
        ifFalse: [ 
          self subclassType = 'indexableSubclass'
            ifTrue: [ 
              self
                createOrReviseIndexableClass: aSymbolDictionaryName
                environmentLoader: environmentLoader ]
            ifFalse: [ self error: 'unknown subclass type: ' , self subclassType printString ] ] ]
%

category: '*cypress-environmental-tools'
method: CypressClassDefinition
createOrReviseRegularClass: aSymbolDictionaryName environmentLoader: environmentLoader
  "To be resolved:
		- the question of an 'environment' in which to create the class.
		- the question of which SymbolDictionary in which to create the class.
	 These are perhaps the same question."

  | superClass lookupSymbolList |
  lookupSymbolList := environmentLoader lookupSymbolList.
  superClass := (lookupSymbolList resolveSymbol: self superclassName) value.
  ^ (superClass
    subclass: self name
    instVarNames: (self instVarNames collect: [ :each | each asSymbol ])
    classVars: (self classVarNames collect: [ :each | each asSymbol ])
    classInstVars: (self classInstVarNames collect: [ :each | each asSymbol ])
    poolDictionaries: #()
    inDictionary:
      ((self symbolDictionaryForClassNamed: self name symbolList: lookupSymbolList)
        ifNil: [ (lookupSymbolList resolveSymbol: aSymbolDictionaryName) value ])
    options: #())
    category: category;
    comment: self comment
%

category: '*rowan-tools-kernel'
method: CypressClassDefinition
definitionString

	| classType type |
	type := self subclassType.
	type = ''
		ifTrue: [ classType := 'normal' ]
		ifFalse: [ 
			(type = 'indexableSubclass' or: [ type = 'variable' ])
				ifTrue: [ classType := 'variable' ]
				ifFalse: [ 
					type = 'byteSubclass'
						ifTrue: [ classType := 'byteSubclass' ]
						ifFalse: [ self error: 'unknown subclass type: ' , type ] ] ].
	^ Rowan projectTools browser
		classCreationTemplateForSubclassOf: superclassName
		className: self name printString
		type: classType
		instanceVariablesString: self instanceVariablesString
		classVariablesString: self classVariablesString
		classInstanceVariablesString: self classInstanceVariablesString
		poolDictionariesString: self poolDictionariesString
		comment: self comment printString
		category: self category printString
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
hasClassInstanceVariables

	^ self classInstVarNames isEmpty not
%

category: '*cypress-environmental-tools'
method: CypressClassDefinition
loadClassDefinition: aSymbolDictionaryName environmentLoader: environmentLoader
  "Create a new version of the defined class. If the class already exists,
	 copy the behaviors and state from the old version."

  | newClass oldClass lookupSymbolList |
  lookupSymbolList := environmentLoader lookupSymbolList.
  self defaultSymbolDictionaryName: aSymbolDictionaryName.
  (lookupSymbolList resolveSymbol: self name)
    ifNotNil: [ :assoc | oldClass := assoc value ].
  newClass := self
    createOrReviseClass: aSymbolDictionaryName
    environmentLoader: environmentLoader.
  (oldClass isNil or: [ newClass == oldClass ])
    ifTrue: [ ^ self ].
  self classNeedingMigration: newClass.
  self
    recompileWithSubclassesFrom: oldClass
    to: newClass
    symbolList: lookupSymbolList 
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
printDefinitionOn: stream

        stream
            nextPutAll: self superclassName;
            space;
            nextPutAll: self classCreationSelector;
            nextPut: $# ;
            nextPutAll: self className;
            cr; tab.
        stream
            nextPutAll: 'instanceVariableNames: ';
            store: self instanceVariablesString;
            cr; tab;
            nextPutAll: 'classVariableNames: ';
            store: self classVariablesString;
            cr; tab;
            nextPutAll: 'poolDictionaries: ';
            store: self poolDictionariesString;
            cr; tab;
            nextPutAll: 'category: ';
            store: self category asString 
%

category: '*cypress-environmental-tools'
method: CypressClassDefinition
symbolDictionaryForClassNamed: aString symbolList: aSymbolList
  "Answer the SymbolDictionary containing the named class.
	 If there are multiple answers, answer the first.
	 If there are no answers (i.e., the class does not exist), answer
	 the result of evaluating aBlock."

  ^ aSymbolList asArray detect: [ :each | each
        anySatisfy: [ :every | every isBehavior and: [ every name asString = aString asString ] ] ]
  ifNone: [  ]
%

! Class extensions for 'CypressClassStructure'

!		Instance methods for 'CypressClassStructure'

category: '*Cypress-MesssageDigest'
method: CypressClassStructure
addToDigest: aMessageDigestStream

	aMessageDigestStream
		tab;
		tab;
		nextPutAll: self class name;
		cr;
		tab;
		tab;
		tab;
		nextPutAll: 'extension:';
		nextPutAll: self isClassExtension printString;
		cr;
		tab;
		tab;
		tab;
		nextPutAll: 'comment:';
		nextPutAll: self comment;
		cr;
		tab;
		tab;
		tab;
		nextPutAll: 'properties:';
		cr;
		tab;
		tab;
		tab;
		tab.
	self properties _writeCypressJsonOn: aMessageDigestStream indent: 4.
	aMessageDigestStream
		cr;
		tab;
		tab;
		tab;
		nextPutAll: 'class methods:';
		cr.
	(self classMethods asSortedCollection: 
			[:a :b |
			(a isMetaclass printString , a selector)
				< (b isMetaclass printString , b selector)])
		do: [:each | each addToDigest: aMessageDigestStream].
	aMessageDigestStream
		tab;
		tab;
		tab;
		nextPutAll: 'instance methods:';
		cr.
	(self instanceMethods asSortedCollection: 
			[:a :b |
			(a isMetaclass printString , a selector)
				< (b isMetaclass printString , b selector)])
		do: [:each | each addToDigest: aMessageDigestStream]
%

category: '*Cypress-MesssageDigest'
method: CypressClassStructure
isSkeleton

	^instanceMethods isNil
		and: [classMethods isNil
		and: [comment isNil
		and: [isClassExtension isNil]]]
%

! Class extensions for 'CypressDefinition'

!		Instance methods for 'CypressDefinition'

category: '*rowan-tools-kernel'
method: CypressDefinition
isOrganizationDefinition
  ^false
%

category: '*cypress-environmental-tools'
method: CypressDefinition
loadClassDefinition: aSymbolDictionaryName environmentLoader: environmentLoader
  "default is to do nothing"

%

category: '*cypress-environmental-tools'
method: CypressDefinition
loadMethodDefinition: lookupSymbolList environmentLoader: environmentLoader
  "default is to do nothing"

%

category: '*cypress-environmental-tools'
method: CypressDefinition
postLoad: lookupSymbolList environmentId: environmentId
  "noop"

%

category: '*cypress-environmental-tools'
method: CypressDefinition
postLoadOver: aDefinition lookupSymbolList: lookupSymbolList environmentId: environmentId
  self postLoad: lookupSymbolList environmentId: environmentId
%

! Class extensions for 'CypressHierarchicalUrl'

!		Instance methods for 'CypressHierarchicalUrl'

category: '*rowan-gemstone-3215'
method: CypressHierarchicalUrl
segments
	^ path
%

! Class extensions for 'CypressMethodDefinition'

!		Instance methods for 'CypressMethodDefinition'

category: '*rowan-cypress-kernel'
method: CypressMethodDefinition
accept: aVisitor
	^ aVisitor visitMethodDefinition: self
%

category: '*cypress-environmental-tools'
method: CypressMethodDefinition
loadMethodDefinition: lookupSymbolList environmentLoader: environmentLoader
  | cls actualCls |
  cls := (lookupSymbolList resolveSymbol: self className) value.
  actualCls := self classIsMeta
    ifTrue: [ cls class ]
    ifFalse: [ cls ].
  actualCls
    compileMethod: self source
    dictionaries: environmentLoader compilationSymbolList
    category: self category
    environmentId: environmentLoader defaultEnvironmentId
%

category: '*rowan-cypress-kernel'
method: CypressMethodDefinition
offset: anInteger inFile: aFileName
	"noop"
%

category: '*cypress-environmental-tools'
method: CypressMethodDefinition
postLoadOver: aDefinition lookupSymbolList: lookupSymbolList environmentId: environmentId
  super
    postLoadOver: aDefinition
    lookupSymbolList: lookupSymbolList
    environmentId: environmentId.
  (self isInitializer
    and: [ aDefinition isNil or: [ self source ~= aDefinition source ] ])
    ifTrue: [ 
      (self theNonMetaClass: lookupSymbolList)
        perform: #'initialize'
        env: environmentId ]
%

category: '*cypress-environmental-tools'
method: CypressMethodDefinition
theNonMetaClass: lookupSymbolList
  ^ self
    resolveGlobalNamed: self className
    lookupSymbolList: lookupSymbolList
    or: [  ]
%

category: '*rowan-tools-kernel'
method: CypressMethodDefinition
timeStamp

	"fake out a timeStamp for GsJade package changes browser... should not end up being 
		displayed in chagnes browser, but transport layer expects a timeStamp at the moment"

	^ 'dkh 3/29/2018 14:21'
%

! Class extensions for 'CypressMethodStructure'

!		Instance methods for 'CypressMethodStructure'

category: '*Cypress-MesssageDigest'
method: CypressMethodStructure
addToDigest: aMessageDigestStream

	aMessageDigestStream
		tab;
		tab;
		tab;
		tab;
		nextPutAll: self class name;
		cr;
		tab;
		tab;
		tab;
		tab;
		tab;
		nextPutAll: self selector;
		cr;
		tab;
		tab;
		tab;
		tab;
		tab;
		nextPutAll: 'properties:';
		cr;
		tab;
		tab;
		tab;
		tab;
		tab;
		tab.
	self properties _writeCypressJsonOn: aMessageDigestStream indent: 6.
	aMessageDigestStream
		cr;
		tab;
		tab;
		tab;
		tab;
		nextPutAll: 'source:';
		nextPutAll: self source;
		cr
%

category: '*Cypress-MesssageDigest'
method: CypressMethodStructure
isSkeleton

	^source isNil
		and: [classStructure isNil
		and: [isMetaclass isNil]]
%

! Class extensions for 'CypressModification'

!		Instance methods for 'CypressModification'

category: '*rowan-cypress-kernel'
method: CypressModification
isModification
  ^ true
%

category: '*cypress-environmental-tools'
method: CypressModification
loadClassDefinition: aSymbolDictionaryName environmentLoader: environmentLoader
  self modification
    loadClassDefinition: aSymbolDictionaryName
    environmentLoader: environmentLoader
%

category: '*cypress-environmental-tools'
method: CypressModification
loadMethodDefinition: lookupSymbolList environmentLoader: environmentLoader
  self modification
    loadMethodDefinition: lookupSymbolList
    environmentLoader: environmentLoader
%

category: '*cypress-environmental-tools'
method: CypressModification
postLoadDefinition: lookupSymbolList environmentId: environmentId
  self modification
    postLoadOver: self obsoletion
    lookupSymbolList: lookupSymbolList
    environmentId: environmentId
%

! Class extensions for 'CypressObject'

!		Instance methods for 'CypressObject'

category: '*cypress-environmental-tools'
method: CypressObject
resolveGlobalNamed: aString lookupSymbolList: lookupSymbolList or: aBlock
  ^ ((lookupSymbolList resolveSymbol: aString) ifNil: [ ^ aBlock value ]) value
%

! Class extensions for 'CypressPackageManager'

!		Instance methods for 'CypressPackageManager'

category: '*Cypress-Comparison'
method: CypressPackageManager
comparePackagesFrom: someCypressPackageInformations

	| packageNames savedLocation comparator |
	packageNames := someCypressPackageInformations collect: 
					[:each |
					savedLocation := each savedLocation.
					each name].
	comparator := CypressPackageComparator new.
	comparator comparingPackages: packageNames fromDirectory: savedLocation.
	^comparator getDifferences
%

! Class extensions for 'CypressPackageStructure'

!		Instance methods for 'CypressPackageStructure'

category: '*Cypress-MesssageDigest'
method: CypressPackageStructure
addToDigest: aMessageDigestStream

	aMessageDigestStream
		nextPutAll: self class name;
		cr;
		tab;
		nextPutAll: 'name:';
		nextPutAll: self name;
		cr;
		tab;
		nextPutAll: 'properties:';
		cr;
		tab;
		tab.
	self properties _writeCypressJsonOn: aMessageDigestStream indent: 2.
	aMessageDigestStream
		cr;
		tab;
		nextPutAll: 'classes:';
		cr.
	(self classes asSortedCollection: [:a :b | a name < b name])
		do: [:each | each addToDigest: aMessageDigestStream].
	aMessageDigestStream
		tab;
		nextPutAll: 'extensions:';
		cr.
	(self extensions asSortedCollection: [:a :b | a name < b name])
		do: [:each | each addToDigest: aMessageDigestStream]
%

category: '*Cypress-MesssageDigest'
method: CypressPackageStructure
isSkeleton

	^(properties isNil or: [properties isEmpty])
		and: [classes isNil
		and: [extensions isNil]]
%

! Class extensions for 'CypressPatchOperation'

!		Instance methods for 'CypressPatchOperation'

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
<= other
	^ self definition <= other definition
%

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
isAddition
	^ false
%

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
isModification
	^ false
%

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
isRemoval
	^ false
%

! Class extensions for 'CypressRemoval'

!		Instance methods for 'CypressRemoval'

category: '*rowan-cypress-kernel'
method: CypressRemoval
isRemoval
  ^ true
%

category: '*cypress-environmental-tools'
method: CypressRemoval
loadClassDefinition: aSymbolDictionaryName environmentLoader: environmentLoader
  CypressError
    signal:
      'inappropriate to send #loadClassDefinition:environmentLoader: to a removal operation'
%

category: '*cypress-environmental-tools'
method: CypressRemoval
loadMethodDefinition: lookupSymbolList environmentLoader: environmentLoader
  CypressError
    signal:
      'inappropriate to send #loadMethodDefinition:environmentLoader: to a removal operation'
%

category: '*cypress-environmental-tools'
method: CypressRemoval
postLoadDefinition: lookupSymbolList environmentId: environmentId
  CypressError
    signal:
      'inappropriate to send #postLoadDefinition:environmentId: to a removal operation'
%

! Class extensions for 'CypressStructure'

!		Instance methods for 'CypressStructure'

category: '*Cypress-MesssageDigest'
method: CypressStructure
addToDigest: aMessageDigestStream

	self subclassResponsibility: #addToDigest:
%

category: '*Cypress-MesssageDigest'
method: CypressStructure
digest
	"Answer a digest of the receiver, unless it is a skeleton (never populated).
	 The digest is not constrained, but is typically a ByteArray or an Integer.
	 In the case of a skeleton, answer nil so there is a distinction between
	 no such package and an empty package."

	| stream |
	self isSkeleton ifTrue: [^nil].
	stream := CypressMessageDigestStream characters.
	self addToDigest: stream.
	^stream md5sum
%

category: '*Cypress-MesssageDigest'
method: CypressStructure
isSkeleton

	^self subclassResponsibility: #isSkeleton
%

! Class extensions for 'Dictionary'

!		Instance methods for 'Dictionary'

category: '*Cypress-PackageManagement'
method: Dictionary
_writeCypressJsonOn: fileStream
	"Private method which may be removed in a future GemStone version."

	self _writeCypressJsonOn: fileStream indent: 0.
	fileStream lf
%

category: '*Cypress-PackageManagement'
method: Dictionary
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	| indent cnt |
	indent := startIndent.
	aStream
		nextPutAll: '{';
		lf.
	cnt := 0.
	indent := indent + 1.
	self keys asSortedCollection do: 
			[:key |
			| value |
			value := self at: key.
			value ifNotNil: [ cnt := cnt + 1.
			indent timesRepeat: [aStream tab].
			key _writeCypressJsonOn: aStream indent: indent.
			aStream nextPutAll: ' : '.
			value _writeCypressJsonOn: aStream indent: indent.
			cnt < self size
				ifTrue: 
					[aStream
						nextPutAll: ',';
						lf]]].
	self size = 0 ifTrue: [indent timesRepeat: [aStream tab]].
	aStream nextPutAll: ' }'
%

! Class extensions for 'DoubleByteSymbol'

!		Instance methods for 'DoubleByteSymbol'

category: '*ast-kernel-core'
method: DoubleByteSymbol
rbStoreOn: aStream
  aStream nextPut: $#.
  super rbStoreOn: aStream
%

! Class extensions for 'FileLocator'

!		Class methods for 'FileLocator'

category: '*rowan-components-kernel'
classmethod: FileLocator
rowanProjectsHome
	"Answer the path to $ROWAN_PROJECTS_HOME"

	^ self origin: #rowanProjectsHome
%

! Class extensions for 'FileStreamPortable'

!		Class methods for 'FileStreamPortable'

category: '*FileSystem-Core'
classmethod: FileStreamPortable
onHandle: aFileSystemHandle
	^ self concreteStream new
		open: aFileSystemHandle fullName
		forWrite: aFileSystemHandle isWritable
%

! Class extensions for 'FileSystem'

!		Class methods for 'FileSystem'

category: '*filesystem-disk'
classmethod: FileSystem
* aFileOrDirectoryName
	^ self disk * aFileOrDirectoryName
%

category: '*filesystem-disk'
classmethod: FileSystem
/ aFileOrDirectoryName
	^ self disk / aFileOrDirectoryName
%

category: '*FileSystem-Memory'
classmethod: FileSystem
currentMemoryFileSystem
	^ MemoryStore currentFileSystem
%

category: '*filesystem-disk'
classmethod: FileSystem
disk
	"Answer a filesystem that represents the 'on-disk' filesystem used by the host operating system."

	^ DiskStore currentFileSystem
%

category: '*FileSystem-Memory'
classmethod: FileSystem
memory
	^ self store: MemoryStore new
%

category: '*filesystem-disk'
classmethod: FileSystem
root
	^ self disk root
%

category: '*filesystem-disk'
classmethod: FileSystem
workingDirectory
	^ self disk workingDirectory
%

!		Instance methods for 'FileSystem'

category: '*FileSystem-Disk'
method: FileSystem
isDiskFileSystem
	^ store isDiskFileSystem
%

category: '*FileSystem-Memory'
method: FileSystem
isMemoryFileSystem
	^ store isMemoryFileSystem
%

! Class extensions for 'FileSystemStore'

!		Instance methods for 'FileSystemStore'

category: '*FileSystem-Disk'
method: FileSystemStore
isDiskFileSystem
	^ false
%

category: '*FileSystem-Memory'
method: FileSystemStore
isMemoryFileSystem
	^ false
%

! Class extensions for 'GsFile'

!		Class methods for 'GsFile'

category: '*filesystem-gemstone-kernel-35x'
classmethod: GsFile
_contentsOfServerDirectory: aPathName expandPath: aBoolean

	^ self _contentsOfServerDirectory: aPathName expandPath: aBoolean utf8Results: false
%

! Class extensions for 'GsFileIn'

!		Instance methods for 'GsFileIn'

category: '*rowan-gemstone-kernel-36x'
method: GsFileIn
currentPackage

	^ Rowan gemstoneTools topaz currentTopazPackageName
%

category: '*rowan-gemstone-kernel-36x'
method: GsFileIn
currentPackage: aStringOrNil

	Rowan gemstoneTools topaz currentTopazPackageName: aStringOrNil
%

category: '*rowan-gemstone-kernel-36x'
method: GsFileIn
currentProject

	^ Rowan gemstoneTools topaz currentTopazProjectName
%

category: '*rowan-gemstone-kernel-36x'
method: GsFileIn
currentProject: aStringOrNil

	Rowan gemstoneTools topaz currentTopazProjectName: aStringOrNil
%

! Class extensions for 'GsNMethod'

!		Instance methods for 'GsNMethod'

category: '*rowan-gemstone-kernel'
method: GsNMethod
rowanPackageName

	"answer the name of the package that the receiver is a member of. Answer `Rowan unpackagedName` if 
		the receiver is not a member of any package"

	| loadedMethod |
	loadedMethod := Rowan image
		loadedMethodForMethod: self
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedMethod loadedPackage name
%

category: '*rowan-gemstone-kernel'
method: GsNMethod
rowanProjectName

	"answer the name of the project that the receiver is a member of. Answer `Rowan unpackagedName` if 
		the receiver is not a member of any project"

	| loadedMethod |
	loadedMethod := Rowan image
		loadedMethodForMethod: self
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedMethod loadedProject name
%

! Class extensions for 'Integer'

!		Class methods for 'Integer'

category: '*ast-kernel-core'
classmethod: Integer
_rwFinishFromStream: aStream signFound: aSignFound factor: aFactor radix: radix
  "BinaryExponent = ( 'e' | 'E' | 'd' | 'D' | 'q' ) ['-' | '+'] Digits
   DecimalExponent = ( 'f' | 'F' ) ['-' | '+'] Digits
   Digit = '0' | '1' | '2' | ... | '9'
   Digits = Digit {Digit}
   Exponent = BinaryExponent | DecimalExponent | ScaledDecimalExponent | FixedPointExponent
   FractionalPart = '.' Digits [Exponent]
   FixedPointExponent = 'p' [ ['-' | '+'] Digits ] 
   Number = RadixedLiteral | NumericLiteral
   Numeric = Digit | 'A' | 'B' | ... | 'Z'
   NumericLiteral = Digits ( [FractionalPart] | [Exponent] )
   Numerics = Numeric { Numeric }
   RadixedLiteral = Digits ( '#' | 'r' ) ['-'] Numerics
   ScaledDecimalExponent = 's' [ ['-' | '+'] Digits ]
"
  "parse Numerics (plus option sign) for RadixedLiteral"

  | number ch signFound factor |
  signFound := aSignFound.
  factor := aFactor.
  number := 0.
  (aStream peek isEquivalent: $-)
    ifTrue: [ 
      signFound
        ifTrue: [ ^ self _errIncorrectFormat: aStream ].
      aStream next.
      signFound := true.
      factor := -1 ]
    ifFalse: [ 
      (aStream peek isEquivalent: $+)
        ifTrue: [ 
          signFound
            ifTrue: [ ^ self _errIncorrectFormat: aStream ].
          aStream next.
          signFound := true ] ].
  [ aStream atEnd not and: [ | peekCh | peekCh := aStream peek. radix <= 10 ifTrue: [ peekCh isDigit ] ifFalse: [ peekCh isAlphaNumeric ] ] ]
    whileTrue: [ 
      ch := aStream next.
      number := number * radix + (ch digitValueInRadix: radix) ].
  ^ number * factor
%

!		Instance methods for 'Integer'

category: '*filesystem-gemstone-kernel'
method: Integer
<< shiftAmount
	"left shift"
	
	shiftAmount < 0 ifTrue: [self error: 'negative arg'].
	^ self bitShift: shiftAmount
%

category: '*filesystem-gemstone-kernel'
method: Integer
>> shiftAmount
	"right shift"
	
	shiftAmount < 0 ifTrue: [self error: 'negative arg'].
	^ self bitShift: 0 - shiftAmount
%

category: '*filesystem-gemstone-kernel'
method: Integer
digitAt: n
	"Answer the value of an apparent byte-indexable field in the receiver,
	 analogous to the large integers, which are organized as bytes."

	n = 1
		ifTrue: [ 
			"Negate carefully in case the receiver is SmallInteger minVal"
			^ self < 0
				ifTrue: [ -256 - self bitAnd: 255 ]
				ifFalse: [ self bitAnd: 255 ] ].
	^ self < 0
		ifTrue: [ (-256 - self bitShift: -8) + 1 digitAt: n - 1 ]
		ifFalse: [ (self bitShift: 8 - (n bitShift: 3)) bitAnd: 255 ]
%

category: '*FileSystem-Core'
method: Integer
humanReadableSIByteSize
	^ String streamContents: [ :s|
		self humanReadableSIByteSizeOn: s ]
%

category: '*FileSystem-Core'
method: Integer
humanReadableSIByteSizeOn: s
	| exponent base |
	"Print a string with an SI binary unit represation of myself."
	base := 1000.
	self < base
		ifTrue: [ ^ s print: self; space; nextPut: $B ].
	exponent := (self log / base log) asInteger.
	(self / (base ** exponent)) printOn: s showingDecimalPlaces: 2.
	s 
		space;
		nextPut: ('kMGTPE' at: exponent);
		nextPut: $B.
%

category: '*rowan-gemstone-components-kernel'
method: Integer
rwSemanticIntegerLessThanSelf: anInteger

	^ anInteger < self
%

category: '*rowan-gemstone-components-kernel'
method: Integer
rwSemanticStringLessThanSelf:  aString
  "integers have greater precedence than strings"
	" aString < anInteger -> false"

  ^ false
%

category: '*rowan-gemstone-components-kernel'
method: Integer
rwSemanticVersionComponentLessThan: aRwSemanticVersonComponent

	^ aRwSemanticVersonComponent rwSemanticIntegerLessThanSelf: self
%

! Class extensions for 'Interval'

!		Class methods for 'Interval'

category: '*Rowan-GemStone-Kernel'
classmethod: Interval
fromSton: stonReader
	| result values |
	values := OrderedCollection new.
	stonReader parseMapDo: [:key :value | values add: value].
	values size = 2 ifTrue: [result := self from: values first to: values second].
	values size = 3 ifTrue: [result := self from: values first to: values second by: values third].
	^result
%

!		Instance methods for 'Interval'

category: '*Rowan-GemStone-Kernel'
method: Interval
stonOn: stonWriter
  stonWriter
    writeObject: self
    streamMap: [ :dictionary | 
      dictionary
        at: #'start' put: from;
        at: #'stop' put: to;
        at: #'step' put: by ]
%

! Class extensions for 'Number'

!		Class methods for 'Number'

category: '*ast-kernel-core'
classmethod: Number
rwFromStream: aStream
  "BinaryExponent = ( 'e' | 'E' | 'd' | 'D'  'q' | 'Q') ['-' | '+'] Digits
   DecimalExponent = ( 'f' | 'F' ) ['-' | '+'] Digits
   Digit = '0' | '1' | '2' | ... | '9'
   Digits = Digit {Digit}
   Exponent = BinaryExponent | DecimalExponent | ScaledDecimalExponent | FixedPointExponent
   FractionalPart = '.' Digits [Exponent]
   FixedPointExponent = 'p' [ ['-' | '+'] Digits ] 
   Number = RadixedLiteral | NumericLiteral
   Numeric = Digit | 'A' | 'B' | ... | 'Z'
   NumericLiteral = Digits ( [FractionalPart] | [Exponent] )
   Numerics = Numeric { Numeric }
   RadixedLiteral = Digits ( '#' | 'r' ) ['-'] Numerics
   ScaledDecimalExponent = 's' [ ['-' | '+'] Digits ]
"
  | ch integerPart factor signFound |
  self _checkReadStream: aStream forClass: CharacterCollection.
  ch := aStream next.
  [ ch unicodeIsWhitespace] whileTrue: [ ch := aStream next ].
  aStream skip: -1.
  integerPart := 0.
  factor := 1.
  signFound := false.
  (aStream peek isEquivalent: $-)
    ifTrue: [ 
      aStream next.
      signFound := true.
      factor := -1 ]
    ifFalse: [ 
      (aStream peek isEquivalent: $+)
        ifTrue: [ 
          aStream next.
          signFound := true ] ].
  (aStream atEnd or: [ aStream peek isDigit not ])
    ifTrue: [ ^ self _errIncorrectFormat: aStream ].
  [ aStream atEnd not and: [ (ch := aStream peek) isDigit ] ]
    whileTrue: [ 
      aStream next.
      integerPart := integerPart * 10 + ch digitValue ].

  (ch == $r or: [ ch == $# ])
    ifTrue: [ 
      "found a radix separator"
      aStream next.
      ^ Integer
        _rwFinishFromStream: aStream
        signFound: signFound
        factor: factor
        radix: integerPart ].
  (ch isEquivalent: (Locale decimalPoint at: 1))
    ifTrue: [ 
      | chch |
		chch := aStream peek2. ".?"
		chch notNil
			ifTrue: [
				"not at eof"
				chch isDigit 
					ifFalse: [
						"we're done"
						^ integerPart * factor ] ].
	  "found a decimal point, followed by a numeric character."
      aStream next.
      ^ BinaryFloat
        _finishFromStream: aStream
        signFound: signFound
        factor: factor
        integerPart: integerPart ].
  (#( $e $E $d $D $q $s $p $f $F ) includesIdentical: ch) ifTrue:[ 
      aStream next.
      ^ BinaryFloat
        _finishFromStream: aStream
        signFound: signFound
        factor: factor
        integerPart: integerPart
        fractionalPart: 0
        exponent: ch ].
  ^ integerPart * factor
%

!		Instance methods for 'Number'

category: '*ast-kernel-core'
method: Number
rbStoreOn: aStream
  self printOn: aStream
%

category: '*Cypress-PackageManagement'
method: Number
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	aStream nextPutAll: self printString
%

! Class extensions for 'Object'

!		Instance methods for 'Object'

category: '*ast-kernel-core'
method: Object
acceptVisitor: aVisitor
%

category: '*gemstone-interactions-kernel'
method: Object
confirm: aString
  ^ (GsConfirmInteraction prompt: aString) signal
%

category: '*filesystem-gemstone-kernel'
method: Object
flag: aSymbol

	"Send this message, with a relevant symbol as argument, to flag a message for subsequent retrieval.  For example, you might put the following line in a number of messages:
	self flag: #returnHereUrgently
	Then, to retrieve all such messages, browse all senders of #returnHereUrgently."
%

category: '*gemstone-interactions-kernel'
method: Object
inform: aString
  "Display aString to the user."

  ^ (GsInformInteraction message: aString) signal
%

category: '*gemstone-interactions-kernel'
method: Object
inspect
  ^ (GsInspectInteraction theObject: self) signal
%

category: '*ast-kernel-core'
method: Object
isValue

	^false
%

category: '*rowan-gemstone-components-kernel'
method: Object
rwPlatformAttributeMatchForGemStoneVersion: anRwGemStoneVersionConfigurationPlatformAttributeMatcher
  ^ self
    error: 'Expected a String or a RwGemStoneVersion'
%

category: '*rowan-gemstone-components-kernel'
method: Object
rwPlatformAttributeMatchForString: anRwStringConfigurationPlatformAttributeMatcher
  ^ self
    error: 'Expected a String or a RwGemStoneVersion'
%

category: '*rowan-gemstone-components-kernel'
method: Object
rwSemanticIntegerLessThanSelf: anInteger
  ^ self
    error: 'Invalid semantic verson component - should be an Integer.'
%

category: '*rowan-gemstone-components-kernel'
method: Object
rwSemanticStringLessThanSelf: aString
  ^ self
    error: 'Invalid semantic verson component - should be String.'
%

category: '*rowan-gemstone-components-kernel'
method: Object
rwSemanticVersionComponentLessThan: aRwSemanticVersonComponent
  ^ self
    error: 'Invalid semantic verson component - should be String or Integer.'
%

category: '*filesystem-gemstone-kernel'
method: Object
split: aSequenceableCollection
	"Split the argument using the receiver as a separator."
	"optimized version for single delimiters"
	"($/ split: '/foo/bar')>>>#('' 'foo' 'bar') asOrderedCollection"
	"([:c| c isSeparator] split: 'aa bb cc dd')>>> #('aa' 'bb' 'cc' 'dd') asOrderedCollection"
		
	| result |
	result := OrderedCollection new: (aSequenceableCollection size / 2) asInteger.
	self split: aSequenceableCollection do: [ :item |
		result add: item ].
	^ result
%

category: '*filesystem-gemstone-kernel'
method: Object
split: aSequenceableCollection do: aBlock
	"optimized version for single delimiters:
	Example:
		$/ split: '/foo/bar' indicesDo: [ :item | ]"
	self split: aSequenceableCollection indicesDo: [ :start :end | 
		aBlock value: (aSequenceableCollection copyFrom: start to: end) ]
%

category: '*filesystem-gemstone-kernel'
method: Object
split: aSequenceableCollection indicesDo: aBlock
	"Perform an action specified as aBlock (with a start and end argument) to each of the indices of the receiver element that have been identified by splitting the receiver using the splitter argument. optimized version for single delimiters."
	
	"(String streamContents: [:s | Character space split: 'Pharo is cool'  indicesDo: [ :start :end | s << 's:' << start asString << ' ' << 'e:' << end asString << ' ' ]]) >>> 's:1 e:5 s:7 e:8 s:10 e:13 '"
		
		
		
	|  position oldPosition |
	
	position := 1.
	oldPosition := position.
	
	position := aSequenceableCollection indexOf: self startingAt: position.
	[ position > 0 ] whileTrue: [
		aBlock value: oldPosition value: position - 1.
		position := position + 1.
		oldPosition := position.
		position := aSequenceableCollection indexOf: self startingAt: position.
	].

	aBlock value: oldPosition value: aSequenceableCollection size.
%

category: '*Cypress-PackageManagement'
method: Object
_writeCypressJsonOn: fileStream
	"Private method which may be removed in a future GemStone version."

	self _writeCypressJsonOn: fileStream indent: 0
%

! Class extensions for 'Path'

!		Instance methods for 'Path'

category: '*FileSystem-Core'
method: Path
asFileReference
	^ FileSystem disk referenceTo: self
%

category: '*FileSystem-Core'
method: Path
relativeToReference: aReference 
	^ self relativeToPath: aReference path
%

! Class extensions for 'PositionableStreamPortable'

!		Instance methods for 'PositionableStreamPortable'

category: '*filesystem-gemstone-kernel'
method: PositionableStreamPortable
isBinary
	"Return true if the receiver is a binary byte stream"
	^collection class == ByteArray
%

category: '*filesystem-gemstone-kernel'
method: PositionableStreamPortable
nextInto: aCollection
	"Read the next elements of the receiver into aCollection.
	Return aCollection or a partial copy if less than aCollection
	size elements have been read."
	^self next: aCollection size into: aCollection startingAt: 1.
%

! Class extensions for 'QuadByteSymbol'

!		Instance methods for 'QuadByteSymbol'

category: '*ast-kernel-core'
method: QuadByteSymbol
rbStoreOn: aStream
  aStream nextPut: $#.
  super rbStoreOn: aStream
%

! Class extensions for 'ReadStreamPortable'

!		Instance methods for 'ReadStreamPortable'

category: '*filesystem-gemstone-kernel'
method: ReadStreamPortable
readInto: aCollection startingAt: startIndex count: n
	"Read n objects into the given collection. 
	Return number of elements that have been read."
	
	| max |
	max := (readLimit - position) min: n.
	aCollection 
		replaceFrom: startIndex 
		to: startIndex + max - 1
		with: collection
		startingAt: position + 1.
	position := position + max.
	^ max
%

! Class extensions for 'ReadWriteStreamPortable'

!		Instance methods for 'ReadWriteStreamPortable'

category: '*filesystem-gemstone-kernel'
method: ReadWriteStreamPortable
readInto: aCollection startingAt: startIndex count: n
	"Read n objects into the given collection. 
	Return number of elements that have been read."
	
	| max |
	max := (readLimit - position) min: n.
	aCollection 
		replaceFrom: startIndex 
		to: startIndex + max - 1
		with: collection
		startingAt: position + 1.
	position := position + max.
	^ max
%

! Class extensions for 'Rowan'

!		Class methods for 'Rowan'

category: '*rowan-gemstone-core'
classmethod: Rowan
clearGlobalAutomaticClassInitializationBlackList

	"Clear global list of project names for which automatic class initialiation should be disabled.
		user black list only applies to current user."

	^ self platform clearAutomaticClassInitializationBlackList_global
%

category: '*rowan-gemstone-core'
classmethod: Rowan
clearSessionAutomaticClassInitializationBlackList

	"Clear session list of project names for which automatic class initialiation should be disabled.
		Session black list only active for duration of GemStone session."

	^ self platform clearAutomaticClassInitializationBlackList_session
%

category: '*rowan-gemstone-core'
classmethod: Rowan
clearUserAutomaticClassInitializationBlackList

	"Clear user list of project names for which automatic class initialiation should be disabled.
		user black list only applies to current user."

	^ self platform clearAutomaticClassInitializationBlackList_user
%

category: '*rowan-gemstone-core'
classmethod: Rowan
globalAutomaticClassInitializationBlackList

	"Answer global list of project names for which automatic class initialiation should be disabled.
		Session black list only active for duration of GemStone session."

	^ self platform automaticClassInitializationBlackList_global
%

category: '*rowan-core'
classmethod: Rowan
initialize

	"Rowan initialize."

	configuration := self platform defaultConfiguration.
	self platform initialize
%

category: '*rowan-coreV2'
classmethod: Rowan
newEmbeddedProjectNamed: projectName
	^ self platform newEmbeddedProjectNamed: projectName
%

category: '*rowan-coreV2'
classmethod: Rowan
newProjectNamed: projectName
	^ self platform newProjectNamed: projectName
%

category: '*rowan-coreV2'
classmethod: Rowan
projectFromUrl: loadSpecUrl
	^ self platform projectFromUrl: loadSpecUrl
%

category: '*rowan-coreV2'
classmethod: Rowan
projectFromUrl: loadSpecUrl diskUrl: urlString
	^ self platform projectFromUrl: loadSpecUrl diskUrl: urlString
%

category: '*rowan-coreV2'
classmethod: Rowan
projectFromUrl: loadSpecUrl gitUrl: urlString
	^ self platform projectFromUrl: loadSpecUrl gitUrl: urlString
%

category: '*rowan-coreV2'
classmethod: Rowan
projectFromUrl: loadSpecUrl projectsHome: projectsHome
	^ self platform projectFromUrl: loadSpecUrl projectsHome: projectsHome
%

category: '*rowan-coreV2'
classmethod: Rowan
projectFromUrl: loadSpecUrl projectsHome: projectsHome componentNames: componentNames
	^ self platform
		projectFromUrl: loadSpecUrl
		projectsHome: projectsHome
		componentNames: componentNames
%

category: '*rowan-coreV2'
classmethod: Rowan
projectFromUrl: loadSpecUrl projectsHome: projectsHome componentNames: componentNames customConditionalAttributes: customConditionalAttributes
	^ self platform
		projectFromUrl: loadSpecUrl
		projectsHome: projectsHome
		componentNames: componentNames
		customConditionalAttributes: customConditionalAttributes
%

category: '*rowan-coreV2'
classmethod: Rowan
projectFromUrl: loadSpecUrl projectsHome: projectsHome componentNames: componentNames platformConditionalAttributes: platformConditionalAttributes
	^ self platform
		projectFromUrl: loadSpecUrl
		projectsHome: projectsHome
		componentNames: componentNames
		platformConditionalAttributes: platformConditionalAttributes
%

category: '*rowan-coreV2'
classmethod: Rowan
projectFromUrl: loadSpecUrl projectsHome: projectsHome customConditionalAttributes: customConditionalAttributes
	^ self platform
		projectFromUrl: loadSpecUrl
		projectsHome: projectsHome
		customConditionalAttributes: customConditionalAttributes
%

category: '*rowan-coreV2'
classmethod: Rowan
projectFromUrl: loadSpecUrl readonlyDiskUrl: urlString
	^ self platform projectFromUrl: loadSpecUrl readonlyDiskUrl: urlString
%

category: '*rowan-gemstone-core'
classmethod: Rowan
sessionAutomaticClassInitializationBlackList

	"Answer session list of project names for which automatic class initialiation should be disabled.
		Session black list only active for duration of GemStone session."

	^ self platform automaticClassInitializationBlackList_session
%

category: '*rowan-gemstone-core'
classmethod: Rowan
userAutomaticClassInitializationBlackList

	"Answer user list of project names for which automatic class initialiation should be disabled.
		user black list only applies to current user."

	^ self platform automaticClassInitializationBlackList_user
%

! Class extensions for 'RowanInterface'

!		Instance methods for 'RowanInterface'

category: '*rowan-gemstone-core'
method: RowanInterface
_gemstonePlatformSpec

	^ self _specification platformSpec at: 'gemstone'
%

! Class extensions for 'RowanMethodService'

!		Instance methods for 'RowanMethodService'

category: '*rowan-services-core-32x'
method: RowanMethodService
_initializeBreakPointsFor: theMethod
  "Answers an Array stepPoints"
  | list |
  list := OrderedCollection new.
  theMethod _allBreakpoints
    ifNil: [ ^ OrderedCollection new ]
    ifNotNil: [ :anArray | 
      1 to: anArray size by: 3 do: [ :i | 
        list
          add:
            (theMethod _stepPointForMeth: (anArray at: i + 1) ip: (anArray at: i + 2)) ] ].
  ^ list asOrderedCollection
%

! Class extensions for 'RowanProjectService'

!		Instance methods for 'RowanProjectService'

category: '*rowan-services-corev2'
method: RowanProjectService
addPackageNamed: packageName toComponentNamed: componentName

	Rowan image loadedPackageNamed: packageName ifAbsent: [
		self browserTool addPackageNamed: packageName toComponentNamed: componentName andProjectNamed: name. 
		self update.
		^self answer: #added.].
	self answer: #duplicatePackage
%

! Class extensions for 'RwAbstractClassDefinition'

!		Instance methods for 'RwAbstractClassDefinition'

category: '*rowan-cypress-definitions'
method: RwAbstractClassDefinition
name
  ^ self key
%

! Class extensions for 'RwAbstractProjectComponentVisitorV2'

!		Instance methods for 'RwAbstractProjectComponentVisitorV2'

category: '*rowan-gemstone-componentsv2'
method: RwAbstractProjectComponentVisitorV2
_components: componentDirPath forProject: aProjectName
	| componentDirectory selected |
	self componentNames isEmpty
		ifTrue: [ ^ #() ].
	componentDirectory := componentDirPath asFileReference.
	selected := (self componentNames
		select: [ :componentName | (visitedComponentNames includes: componentName) not ])
		collect: [ :componentName | 
			self readComponents
				at: componentName
				ifAbsentPut: [ 
 					(RwAbstractRowanProjectLoadComponentV2
						fromComponentsDirectory: componentDirectory
						named: componentName)
						projectName: aProjectName;
						yourself ] ].
	^ selected
%

category: '*rowan-gemstone-componentsv2'
method: RwAbstractProjectComponentVisitorV2
_projects: projectDirPath forProject: ignored
	| urlBase |
	self projectNames isEmpty
		ifTrue: [ ^ #() ].
	urlBase := 'file:' , projectDirPath asFileReference pathString , '/'.
	^ self projectNames
		collect: [ :prjName | 
			self readProjects
				at: prjName
				ifAbsentPut: [ 
					| url |
					url := urlBase , prjName , '.ston'.
					RwSpecification fromUrl: url ] ]
%

! Class extensions for 'RwAbstractProjectDefinitionV2'

!		Instance methods for 'RwAbstractProjectDefinitionV2'

category: '*rowan-gemstone-definitionsv2'
method: RwAbstractProjectDefinitionV2
compareAgainstBase: aDefinition

	| modification packagesModification |
	modification := RwProjectModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	packagesModification := RwPackagesModification new.
	self
		compareDictionary: packages
		againstBaseDictionary: aDefinition packages
		into: packagesModification
		elementClass: RwPackageDefinition.
	modification packagesModification: packagesModification.
	^ modification
%

category: '*rowan-gemstone-definitionsv2'
method: RwAbstractProjectDefinitionV2
projectDefinitionSourceProperty

	^ properties at: RwLoadedProject _projectDefinitionSourceKey ifAbsent: [ RwLoadedProject _projectUnknownDefinitionSourceValue ]
%

category: '*rowan-gemstone-definitionsv2'
method: RwAbstractProjectDefinitionV2
projectDefinitionSourceProperty: sourceKeyOrNil

	sourceKeyOrNil ifNil: [ ^ properties removeKey: RwLoadedProject _projectDefinitionSourceKey ifAbsent: [] ].
	^ properties at: RwLoadedProject _projectDefinitionSourceKey put: sourceKeyOrNil
%

category: '*rowan-gemstone-definitions-onlyv2'
method: RwAbstractProjectDefinitionV2
symbolDictionaryRegistryClass

	^ RwGsSymbolDictionaryRegistryV2
%

category: '*rowan-gemstone-definitionsv2'
method: RwAbstractProjectDefinitionV2
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue
	({'projectOwnerId'.
	'spec'.
	(RwLoadedProject _projectDefinitionSourceKey).
	(RwLoadedProject _projectDefinitionPlatformConditionalAttributesKey).
	'projectRef'} includes: propertyKey)
		ifTrue: [ 
			"projectRef entries are considered to be equal for comparison purposes"
			"spec entries are considered to be equal for comparison purposes"
			"_projectDefinitionSourceKey entries are considered equal for comparison purpposes"
			"_projectDefinitionPlatformConditionalAttributesKey entries are considered equal for comparison purpposes"
			"projectOwnerId entries are considered equal for comparison purpposes"
			^ true ].
	^ super
		_compareProperty: propertyKey
		propertyVaue: propertyValue
		againstBaseValue: baseValue
%

! Class extensions for 'RwAbstractRowanProjectLoadComponentV2'

!		Class methods for 'RwAbstractRowanProjectLoadComponentV2'

category: '*rowan-gemstone-componentsv2'
classmethod: RwAbstractRowanProjectLoadComponentV2
fromFile: filePath
	filePath asFileReference
		readStreamDo: [ :fileStream | 
			| stream |
			Rowan projectTools trace trace: '--- reading component ' , filePath asString.
			stream := ZnBufferedReadStream on: fileStream.	"wrap with buffered stream to bypass https://github.com/GemTalk/FileSystemGs/issues/9"
			^ self _readStonFrom: stream ]
%

category: '*rowan-gemstone-componentsv2'
classmethod: RwAbstractRowanProjectLoadComponentV2
orderedDictionaryClass

	^ Rowan platform orderedDictionaryClass
%

!		Instance methods for 'RwAbstractRowanProjectLoadComponentV2'

category: '*rowan-gemstone-componentsv2'
method: RwAbstractRowanProjectLoadComponentV2
_exportToUrl: directoryUrl
	| url |
	url := directoryUrl asRwUrl.
	url schemeName = 'file'
		ifTrue: [ 
			| fileRef |
			fileRef := url pathForDirectory asFileReference / self name , 'ston'.
			fileRef parent ensureCreateDirectory.
			fileRef
				writeStreamDo: [ :stream | 
					| string |
					string := STON toStringPretty: self.
					stream nextPutAll: string.
					^ self ] ].
	url schemeName = 'memory'
		ifTrue: [ 
			FileSystem currentMemoryFileSystem workingDirectory / url pathForDirectory
				/ self name , 'ston'
				writeStreamDo: [ :stream | 
					| string |
					string := STON toStringPretty: self.
					stream nextPutAll: string.
					^ self ] ].
	^ nil	"otherwise a noop"
%

! Class extensions for 'RwAbstractTool'

!		Instance methods for 'RwAbstractTool'

category: '*rowan-tools-gemstone-35x'
method: RwAbstractTool
readlink: filepath
	"resolve (possible) symbolic links in filepath and return an absolute path"

	^ GsFile _expandFilename: filepath trimSeparators isClient: false
%

! Class extensions for 'RwClassDefinition'

!		Class methods for 'RwClassDefinition'

category: '*rowan-cypress-definitions'
classmethod: RwClassDefinition
fromCypressClassStructure: aCypressClassStructure
  ^ self new
    fromCypressClassStructure: aCypressClassStructure;
    yourself
%

!		Instance methods for 'RwClassDefinition'

category: '*rowan-cypress-definitions'
method: RwClassDefinition
category

	^ properties at: 'category' ifAbsent: [  ]
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
category: aString

	^ properties at: 'category' put: aString
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
classInstVarNames
  ^ properties at: 'classinstvars'
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
classInstVarNames: anArray

	^ properties at: 'classinstvars' put: anArray
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
comment
  ^ properties at: 'comment' ifAbsent: ['']
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
compareAgainstBaseForcingNewClassVersion: aDefinition

	"all unchanged and unremoved methods need to be applied to the patch"

	| modification instanceMethodsModification classMethodsModification |
	modification := self _modificationForcingNewClassVersion
		before: aDefinition
		after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	instanceMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	classMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	self
		compareDictionary: instanceMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition instanceMethodDefinitions
		into: instanceMethodsModification
		elementClass: RwMethodDefinition
		isMeta: false.
	self
		compareDictionary: classMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition classMethodDefinitions
		into: classMethodsModification
		elementClass: RwMethodDefinition
		isMeta: true.
	modification
		instanceMethodsModification: instanceMethodsModification;
		classMethodsModification: classMethodsModification.
	^ modification
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
fromCypressClassStructure: aCypressClassStructure

	properties
		at: 'category' put: aCypressClassStructure category;
		at: 'classinstvars' put: aCypressClassStructure classInstanceVariableNames;
		at: 'classvars' put: aCypressClassStructure classVariableNames;
		yourself.
	aCypressClassStructure comment ifNotNil: [ :cmt | properties at: 'comment' put: cmt ].
	aCypressClassStructure gs_options isEmpty ifFalse: [ properties at: 'gs_options' put: aCypressClassStructure gs_options ].
	aCypressClassStructure gs_constraints isEmpty ifFalse: [ properties at: 'gs_constraints' put: aCypressClassStructure gs_constraints ].
	properties
		at: 'instvars' put: aCypressClassStructure instanceVariableNames;
		at: 'name' put: aCypressClassStructure className;
		at: 'pools' put: aCypressClassStructure poolDictionaryNames;
		at: 'superclass' put: aCypressClassStructure superclassName;
		yourself.
	aCypressClassStructure subclassType isEmpty
		ifTrue: [ properties at: 'type' put: 'normal' ]
		ifFalse: [ properties at: 'type' put: aCypressClassStructure subclassType asString ].
	aCypressClassStructure instanceMethods
		do: [ :cypMethodDef | 
			self
				addInstanceMethodDefinition:
					(RwMethodDefinition fromCypressMethod: cypMethodDef) ].
	aCypressClassStructure classMethods
		do: [ :cypMethodDef | 
			self
				addClassMethodDefinition:
					(RwMethodDefinition fromCypressMethod: cypMethodDef) ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_constraints

	^self properties
				at: 'gs_constraints'
				ifAbsent: [ #() ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_constraints: constraintsArray

	(constraintsArray _isArray and: [ constraintsArray isEmpty not ])
		ifTrue: [ 
			self properties
				at: 'gs_constraints'
				put: constraintsArray ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_options

	^self properties
				at: 'gs_options'
				ifAbsent: [ #() ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_options: optionsArray
	"preserver optionsArray order"

	(optionsArray _isArray and: [ optionsArray isEmpty not ])
		ifTrue: [ 
			self properties
				at: 'gs_options'
				put:
					(optionsArray collect: [ :each | each asString ]) asArray ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_reservedOop

	^self properties
				at: 'gs_reservedoop'
				ifAbsent: [ '' ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_reservedOop: aString
	aString isEmpty not
		ifTrue: [ self properties at: 'gs_reservedoop' put: aString ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_symbolDictionary

	^ self properties
		at: 'gs_SymbolDictionary'
		ifAbsent: []
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_symbolDictionary: aSymbolDictionaryName

	self properties
		at: 'gs_SymbolDictionary'
		put: aSymbolDictionaryName asString
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
poolDictionaryNames
  ^ properties at: 'pools'
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
subclassType
  | type |
  type := properties at: 'type'.
  type = 'normal'
    ifTrue: [ ^ '' ].
  ^ type
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue
	propertyKey = 'comment'
		ifTrue: [ 
			propertyValue = baseValue
				ifTrue: [ ^ true ]
				ifFalse: [ 
					"empty or nil comments need to compare equal in GemStone"
					^ (propertyValue == nil or: [ propertyValue isEmpty ])
						and: [ baseValue == nil or: [ baseValue isEmpty ] ] ] ].
	^ super
		_compareProperty: propertyKey
		propertyVaue: propertyValue
		againstBaseValue: baseValue
%

category: '*rowan-core-definitions-extensions'
method: RwClassDefinition
_methodsModificationClass

	^ RwMethodsModification
%

category: '*rowan-core-definitions-extensions'
method: RwClassDefinition
_modificationClass

	^ RwClassModification
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
_modificationForcingNewClassVersion

	^ RwClassModificationForcingNewClassVersion
%

! Class extensions for 'RwClassExtensionDefinition'

!		Instance methods for 'RwClassExtensionDefinition'

category: '*rowan-core-definitions-extensions'
method: RwClassExtensionDefinition
comparePropertiesAgainstBase: aDefinition
	"property differences aren't of interest for a class extension ..."

	^ RwPropertiesModification new
%

category: '*rowan-core-definitions-extensions'
method: RwClassExtensionDefinition
_methodsModificationClass

	^ RwExtensionMethodsModification
%

category: '*rowan-core-definitions-extensions'
method: RwClassExtensionDefinition
_modificationClass

	^ RwClassExtensionModification
%

! Class extensions for 'RwClassModification'

!		Instance methods for 'RwClassModification'

category: '*rowan-gemstone-loader-extensions-onlyv2'
method: RwClassModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	aPatchSet
		addClassModification: self 
		toPatchSetInPackage: aPackage 
		inProject: aProjectDefinition.
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
method: RwClassModification
classVersioningPatchClassUsing: aPatchSet

	^ aPatchSet _classVersioningPatchClass
%

! Class extensions for 'RwClassModificationForcingNewClassVersion'

!		Instance methods for 'RwClassModificationForcingNewClassVersion'

category: '*rowan-gemstone-loader-extensions-onlyv2'
method: RwClassModificationForcingNewClassVersion
addModificationForcingNewClassVersionToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	aPatchSet
		addForcingNewClassVersionModification: self 
		toPatchSetInPackage: aPackage 
		inProject: aProjectDefinition
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
method: RwClassModificationForcingNewClassVersion
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self shouldNotImplement: #addModificationToPatchSet:inPackage:inProject:
%

! Class extensions for 'RwClassMove'

!		Instance methods for 'RwClassMove'

category: '*rowan-gemstone-loader-extensions-onlyv2'
method: RwClassMove
addMovedClassToPatchSet: aPatchSet

	aPatchSet addClassMove: self
%

! Class extensions for 'RwClassUnmanagedModification'

!		Instance methods for 'RwClassUnmanagedModification'

category: '*rowan-gemstone-loader-extensions-onlyv2'
method: RwClassUnmanagedModification
classVersioningPatchClassUsing: aPatchSet

	^ aPatchSet _classUnmanagedVersioningPatchClass
%

! Class extensions for 'RwDefinition'

!		Instance methods for 'RwDefinition'

category: '*rowan-core-definitions-extensions'
method: RwDefinition
comparePropertiesAgainstBase: aDefinition

	| keys modification |
	modification := RwPropertiesModification new.
	keys := properties keys copy.
	keys addAll: aDefinition properties keys.
	keys do: 
			[:key |
				| before after |
				before := aDefinition propertyAt: key ifAbsent: [nil].
				after := self propertyAt: key ifAbsent: [nil].
				(self _compareProperty: key propertyVaue: before againstBaseValue: after)
					ifFalse: 
						[modification addElementModification: (RwPropertyModification
							key: key
							oldValue: before
							newValue: after)]].
	^modification
%

! Class extensions for 'RwEmbeddedLoadSpecificationV2'

!		Instance methods for 'RwEmbeddedLoadSpecificationV2'

category: '*rowan-definitionsV2'
method: RwEmbeddedLoadSpecificationV2
resolveWithParentProject: aResolvedProject
	"give embedded projects a chance to resolve cleanly"

	| basicProject |
	self projectsHome: aResolvedProject projectsHome.
	basicProject := RwResolvedProjectV2 basicLoadSpecification: self.
	basicProject _projectRepository: aResolvedProject _projectRepository copy.
	self projectsHome: aResolvedProject repositoryRoot.
	basicProject _projectRepository resolve.
	^ basicProject
%

! Class extensions for 'RwGitTool'

!		Instance methods for 'RwGitTool'

category: '*rowan-tools-gemstone'
method: RwGitTool
createTmpFileWith: fileContents

	| file filename |
	filename := (self performOnServer: self _mktempCommand) trimRight.
	[ 
	| count |
	file := GsFile openWriteOnServer: filename.
	(count := file nextPutAll: fileContents withGemstoneLineEndings)
		ifNil: [ self error: 'failed write' ] ]
		ensure: [ file close ].
	^ filename
%

category: '*rowan-tools-gemstone'
method: RwGitTool
performOnServer: commandLine status: statusBlock
  | performOnServerStatusArray |
  performOnServerStatusArray := System _performOnServer: commandLine.
  ^ statusBlock value: performOnServerStatusArray
%

! Class extensions for 'RwGsImage'

!		Class methods for 'RwGsImage'

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
applyModification_V2: aProjectSetModification instanceMigrator: instanceMigrator symbolList: symbolList
	(self _shouldCloneRowanLoader: aProjectSetModification)
		ifTrue: [ 
			self
				applyModification_V2: aProjectSetModification
				visitorClass:
					(self _cloneRowanLoaderSymbolDictionary
						at: RwGsImagePatchVisitor_V2 name)
				instanceMigrator: instanceMigrator
				symbolList: symbolList ]
		ifFalse: [ 
			self
				applyModification_V2: aProjectSetModification
				visitorClass: RwGsImagePatchVisitor_V2
				instanceMigrator: instanceMigrator ]
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
applyModification_V2: aProjectSetModification visitorClass: visitorClass instanceMigrator: instanceMigrator
	| visitor patchSet newClassVersionPatchSet |
	visitor := visitorClass new.
	visitor visit: aProjectSetModification.
	patchSet := visitor patchSet.
	patchSet classesWithNewVersions isEmpty
		ifTrue: [ 
			patchSet apply.
			^ self ].
	patchSet setupForNewClassVersionUpdates.
	patchSet classesWithNewVersions
		do: [ :each | 
			patchSet
				updatePatchesForNewClassVersion: each
				projectModification: aProjectSetModification ].
	visitor := visitorClass new.
	visitor visit: aProjectSetModification.
	newClassVersionPatchSet := visitor patchSet.
	newClassVersionPatchSet applyForNewClassVersions: instanceMigrator
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
applyModification_V2: aProjectSetModification visitorClass: visitorClass instanceMigrator: instanceMigrator symbolList: symbolList
	| visitor patchSet newClassVersionPatchSet |
	visitor := visitorClass new.
	visitor visit: aProjectSetModification.
	patchSet := visitor patchSet.
	patchSet loadSymbolList: symbolList.
	patchSet classesWithNewVersions isEmpty
		ifTrue: [ 
			patchSet apply.
			^ self ].
	patchSet setupForNewClassVersionUpdates.
	patchSet classesWithNewVersions
		do: [ :each | 
			patchSet
				updatePatchesForNewClassVersion: each
				projectModification: aProjectSetModification ].
	visitor := visitorClass new.
	visitor visit: aProjectSetModification.
	newClassVersionPatchSet := visitor patchSet.
	newClassVersionPatchSet applyForNewClassVersions: instanceMigrator
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
loadedClassAndSymbolDicitonaryForClass: class ifPresent: presentBlock ifAbsent: absentBlock
	"scan the symbol list for a loaded package that matches the loaded package for the given loaded class"

	| loadedClass loadedPackage packageName |
	loadedClass := self symbolDictionaryRegistryClass registry_ImplementationClass loadedClassForClass: class.
	loadedPackage := loadedClass loadedPackage.
	packageName := loadedPackage name.
	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry loadedPackageNamed: packageName ifAbsent: [  ])
						ifNotNil: [ :lp | 
							lp == loadedPackage 
								ifTrue: [ ^ presentBlock value: (symbolDict) value: loadedClass ] ] ] ].
	^ absentBlock value
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
loadedClassExtensionsForClass: class
	"lookup the loadedClassExtensions for the given class"

	^ self symbolDictionaryRegistryClass registry_ImplementationClass loadedClassExtensionsForClass: class ifAbsent: [ IdentitySet new ]
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
loadedClassForClass: class ifAbsent: absentBlock
	"Lookup the given class in the classRegistry"

	^ self symbolDictionaryRegistryClass registry_ImplementationClass 
		loadedClassForClass: class
		ifAbsent: absentBlock
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
loadedClassNamed: className ifFound: foundBlock ifAbsent: absentBlock

	"scan the symbol list for a RwLoadedClass instance of the given name"

	| class loadedClass |
	class := self objectNamed: className.
	class ifNil: [ ^ absentBlock value ].
	loadedClass := self symbolDictionaryRegistryClass registry_ImplementationClass 
		loadedClassForClass: class
		ifAbsent: [ ^ absentBlock value ].
	^ foundBlock value: loadedClass
%

category: '*rowan-gemstone-core-36x'
classmethod: RwGsImage
loadedMethod: selector inClassNamed: className isMeta: isMeta ifFound: foundBlock ifAbsent: absentBlock
	"scan the symbol list for a RwLoadedMethod instances for the given selector in the named class"

	| behavior compiledMethod |
	behavior := self objectNamed: className.
	behavior ifNil: [ ^ absentBlock value ].
	isMeta
		ifTrue: [ behavior := behavior class ].
	compiledMethod := behavior
		compiledMethodAt: selector asSymbol
		environmentId: 0
		otherwise: nil.
	compiledMethod ifNil: [ ^ absentBlock value ].
	^ compiledMethod _rowanPackageInfo
		ifNotNil: [ :loadedMethod | loadedMethod ]
		ifNil: [ absentBlock value ]
%

category: '*rowan-gemstone-core-36x'
classmethod: RwGsImage
loadedMethodForMethod: compiledMethod ifAbsent: absentBlock
	"scan the symbol list for a RwLoadedMethod instances for the given compiled method"

	^ compiledMethod _rowanPackageInfo
		ifNotNil: [ :loadedMethod | loadedMethod ]
		ifNil: [ absentBlock value ]
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
removeLoadedClassExtensionsForClass: class
	"The class has or will be deleted from the system, remove the loadedClassExtensions that refer
		to the given class"

	(self symbolDictionaryRegistryClass registry_ImplementationClass
		loadedClassExtensionsForClass: class
		ifAbsent: [ #() ]) copy
		do: [ :loadedClassExtension | 
			self symbolDictionaryRegistryClass registry_ImplementationClass
				unregisterLoadedClassExtension: loadedClassExtension
				forClass: class ]
%

category: '*rowan-gemstone-core-36x'
classmethod: RwGsImage
removeLoadedMethodForCompileMethod: compiledMethod
	"The given compiled method is being removed from the system, remove the loadedMethod associated 
		with the compiled method."

	compiledMethod _rowanPackageInfo: nil
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
symbolDictionaryRegistryClass

	^ RwGsSymbolDictionaryRegistryV2
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
_cloneRowanLoaderSymbolDictionary

	"in order to cleanly update Rowan using Rowan, it is necessary to isolate a copy of all of the loader code
		in a separate symbol dictionary and then use the isolated copy to execute the update."

	| rowanLoaderSymbolDict clonedSymDictName clonedSymDict |
	rowanLoaderSymbolDict := Rowan image symbolDictNamed: 'RowanLoader'.
	clonedSymDictName := #'RowanLoader_cloned'.
	clonedSymDict := rowanLoaderSymbolDict 
		_rowanCloneSymbolDictionaryNamed: clonedSymDictName 
		symbolList: GsCurrentSession currentSession symbolList.
	Transcript cr; show: 'RowanLoader symbol dictionary cloned'.
	^ clonedSymDict
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
classmethod: RwGsImage
_shouldCloneRowanLoader: aProjectSetModification
	"When modifications are made to the Rowan-GemStone-Loader package in the Rowan project, we need to clone the RowanLoader symbol dictionary"

	| projectModification |
	projectModification := aProjectSetModification elementsModified
		at: 'Rowan'
		ifAbsent: [ ^ false ].
	#('Rowan-GemStone-LoaderV2')
		do: [ :loaderPackageName | 
			(projectModification packagesModification elementsModified
				at: loaderPackageName
				ifAbsent: [  ])
				ifNotNil: [ :packageModification | ^ packageModification isEmpty not ] ].
	^ false
%

! Class extensions for 'RwGsLoadedSymbolDictClass'

!		Instance methods for 'RwGsLoadedSymbolDictClass'

category: '*rowan-gemstone-core-36x'
method: RwGsLoadedSymbolDictClass
disownFromLoaded: aPackageSymbolDictionary
	| compiledMethod |
	loadedInstanceMethods
		valuesDo: [ :loadedInstanceMethod | 
			self removeLoadedInstanceMethod: loadedInstanceMethod.
			compiledMethod := loadedInstanceMethod handle.
			compiledMethod _rowanPackageInfo: nil ].
	loadedClassMethods
		valuesDo: [ :loadedClassMethod | 
			compiledMethod := loadedClassMethod handle.
			compiledMethod _rowanPackageInfo: nil ]
%

! Class extensions for 'RwGsLoadedSymbolDictClassExtension'

!		Instance methods for 'RwGsLoadedSymbolDictClassExtension'

category: '*rowan-gemstone-core-36x'
method: RwGsLoadedSymbolDictClassExtension
disownFromLoaded: registry
	| compiledMethod |
	loadedInstanceMethods
		valuesDo: [ :loadedInstanceMethod | 
			self removeLoadedInstanceMethod: loadedInstanceMethod.
			compiledMethod := loadedInstanceMethod handle.
			compiledMethod _rowanPackageInfo: nil ].
	loadedClassMethods
		valuesDo: [ :loadedClassMethod | 
			self removeLoadedClassMethod: loadedClassMethod.
			compiledMethod := loadedClassMethod handle.
			compiledMethod _rowanPackageInfo: nil ].

	registry unregisterLoadedClassExtension: self forClass: handle
%

! Class extensions for 'RwGsMethodAdditionSymbolDictPatchV2'

!		Instance methods for 'RwGsMethodAdditionSymbolDictPatchV2'

category: '*rowan-gemstone-loaderv2-36x'
method: RwGsMethodAdditionSymbolDictPatchV2
installMovedMethod: aClassMove newClassVersionPatch: newClassVersionPatch
	"the receiver represents an existing method for a class with a new version that has moved to a new package"

	"the old method in the old class version must be removed from the loaded things in the new registry, since it was moved earlier, 
		then the regular installMethod should be performed --- new version requires that all methods be compiled"

	"https://github.com/dalehenrich/Rowan/issues/316"

	| oldClassVersion oldBehavior theRegistry |
	theRegistry := (self
		symbolDictionaryFor: aClassMove packageAfter name
		projectDefinition: aClassMove projectAfter) rowanSymbolDictionaryRegistry.

	oldClassVersion := newClassVersionPatch oldClassVersion.
	oldClassVersion ~~ newClassVersionPatch newClassVersion
		ifTrue: [ 
			"only do this work if we truly have a new class version"
			oldBehavior := self isMeta
				ifTrue: [ oldClassVersion class ]
				ifFalse: [ oldClassVersion ].
			(oldBehavior compiledMethodAt: self methodDefinition selector otherwise: nil)
				ifNotNil: [ :oldCompiledMethod | 
					"new methods will not be in the old method dictionary"
					oldCompiledMethod _rowanPackageInfo: nil ] ].

	theRegistry
		addNewCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: aClassMove packageAfter name
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.
	selector := compiledMethod selector
%

! Class extensions for 'RwGsMethodExtensionSymbolDictPatchV2'

!		Instance methods for 'RwGsMethodExtensionSymbolDictPatchV2'

category: '*rowan-gemstone-loaderv2-36x'
method: RwGsMethodExtensionSymbolDictPatchV2
installMovedMethod: aMethodMove newClassVersionPatch: newClassVersionPatch
	"the receiver represents an existing method for a class with a new version that has moved to a new package"

	"the old method in the old class version must be removed from the loaded things in the new registry, since it was moved earlier, 
		then the regular installMethod should be performed --- new version requires that all methods be compiled"

	"https://github.com/dalehenrich/Rowan/issues/316"

	| oldClassVersion oldBehavior theRegistry newBehavior |
	theRegistry := (self
		symbolDictionaryFor: aMethodMove packageAfter name
		projectDefinition: aMethodMove projectAfter) rowanSymbolDictionaryRegistry.
	oldClassVersion := newClassVersionPatch oldClassVersion.
	oldClassVersion ~~ newClassVersionPatch newClassVersion
		ifTrue: [ 
			"only do this work if we truly have a new class version"
			oldBehavior := self isMeta
				ifTrue: [ oldClassVersion class ]
				ifFalse: [ oldClassVersion ].
			(oldBehavior compiledMethodAt: self methodDefinition selector otherwise: nil)
				ifNotNil: [ :oldCompiledMethod | 
					"new methods will not be in the old method dictionary"
					oldCompiledMethod _rowanPackageInfo: nil ] ].

	newBehavior := behavior isMeta
		ifTrue: [ newClassVersionPatch newClassVersion class ]
		ifFalse: [ newClassVersionPatch newClassVersion ].
	theRegistry
		addExtensionCompiledMethod: compiledMethod
		for: newBehavior
		protocol: self propertiesProtocolName
		toPackageNamed: aMethodMove packageAfter name
		implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2.
	selector := compiledMethod selector
%

! Class extensions for 'RwGsPatchSet_V2'

!		Instance methods for 'RwGsPatchSet_V2'

category: '*rowan-gemstone-loaderv2-36x'
method: RwGsPatchSet_V2
doMoveMethodsBetweenPackages
	| image |
	image := Rowan image.
	movedMethods
		do: [ :aMethodMove | 
			| packageDef classOrExtensionDef loadedPackage loadedClassOrExtension loadedMethods loadedMethod compiledMethod registry |
			packageDef := aMethodMove packageBefore.
			classOrExtensionDef := aMethodMove classOrExtensionBefore.
			loadedPackage := image loadedPackageNamed: packageDef name.
			loadedClassOrExtension := loadedPackage
				classOrExtensionForClassNamed: classOrExtensionDef name
				ifAbsent: [ 
					self
						error:
							'internal error - no loaded class or extension found for class '
								, classOrExtensionDef name printString , '  in package '
								, packageDef name printString ].
			loadedMethods := aMethodMove isMeta
				ifTrue: [ loadedClassOrExtension loadedClassMethods ]
				ifFalse: [ loadedClassOrExtension loadedInstanceMethods ].
			loadedMethod := loadedMethods at: aMethodMove methodBefore selector.

			registry := image loadedRegistryForPackageNamed: loadedPackage name.

			loadedClassOrExtension removeLoadedMethod: loadedMethod.
			loadedClassOrExtension isLoadedClassExtension
				ifTrue: [ 
					loadedClassOrExtension isEmpty
						ifTrue: [ 
							(registry
								loadedClassExtensionsForClass: loadedClassOrExtension handle
								ifAbsent: [  ])
								ifNotNil: [ :loadedClassExtensions | 
									loadedClassExtensions isEmpty
										ifFalse: [ 
											loadedClassExtensions remove: loadedClassOrExtension.
											loadedClassExtensions isEmpty
												ifTrue: [ 
													registry
														unregisterLoadedClassExtension: loadedClassOrExtension
														forClass: loadedClassOrExtension handle ] ] ].
							loadedPackage removeLoadedClassExtension: loadedClassOrExtension ] ].

			compiledMethod := loadedMethod handle.
			compiledMethod _rowanPackageInfo: nil.

			packageDef := aMethodMove packageAfter.
			classOrExtensionDef := aMethodMove classOrExtensionAfter.
			loadedPackage := image loadedPackageNamed: packageDef name.
			registry := (Rowan image
				symbolDictNamed:
					(aMethodMove projectAfter
						symbolDictNameForPackageNamed: aMethodMove packageAfter name))
				rowanSymbolDictionaryRegistry.
			loadedClassOrExtension := loadedPackage
				classOrExtensionForClassNamed: classOrExtensionDef name
				ifAbsent: [ 
					classOrExtensionDef isClassExtension
						ifTrue: [ 
							"add a new class extension on demand"
							(aMethodMove projectAfter
								useSessionMethodsForExtensionsForPackageNamed:
									aMethodMove packageAfter name)
								ifTrue: [ 
									| resolved |
									((resolved := self loadSymbolList
										objectNamed: classOrExtensionDef name asSymbol) notNil
										and: [ resolved isBehavior and: [ resolved isMeta not ] ])
										ifFalse: [ 
											self
												error:
													'The extension class named ' , self className printString , ' cannot be found.' ]	"logic is not quite correct here ... need to create a lodedClassExtension for this puppy ... deferring session method work to a later date"	"https://github.com/dalehenrich/Rowan/issues/254" ]
								ifFalse: [ 
									registry
										ensureExtensionClassNamed: classOrExtensionDef name
										existsForPackageNamed: packageDef name
										implementationClass: RwGsSymbolDictionaryRegistry_ImplementationV2 ].
							loadedPackage loadedClassExtensions at: classOrExtensionDef name ]
						ifFalse: [ 
							self
								error:
									'internal error - no loaded class found for class '
										, classOrExtensionDef name printString , '  in package '
										, packageDef name printString ] ].

			loadedClassOrExtension addLoadedMethod: loadedMethod.

			compiledMethod _rowanPackageInfo: loadedMethod ]
%

! Class extensions for 'RwGsPlatform'

!		Instance methods for 'RwGsPlatform'

category: '*rowan-services-extensions'
method: RwGsPlatform
answeringServiceClass
  ^ RowanAnsweringService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
browserServiceClass

	^ RowanBrowserService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
classServiceClass

	^ RowanClassService
%

category: '*rowan-tools-extensions-gemstone'
method: RwGsPlatform
classTools

	"Answer the platform-specific class for class tools"

	^ RwClassTool
%

category: '*rowan-services-extensions'
method: RwGsPlatform
commandResultClass

	^ RowanCommandResult
%

category: '*rowan-tools-extensions-gemstone'
method: RwGsPlatform
gitTools

	"Answer the platform-specific class for git tools"

	^ RwGitTool new
%

category: '*rowan-services-extensions'
method: RwGsPlatform
jadeServerClassNamed: className

	| jadeClasses |
	jadeClasses := Array with: (UserGlobals at: #JadeServer). 
	jadeClasses add: (UserGlobals at: #JadeServer64bit32). 
	jadeClasses add: (UserGlobals at: #JadeServer64bit35). 
	^jadeClasses detect:[:cls | cls name == className] ifNone:[self error: 'Could not look up a JadeServer class: ', className]
%

category: '*rowan-services-extensions'
method: RwGsPlatform
loggingServiceClass

	^ RowanLoggingService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
methodServiceClass

	^ RowanMethodService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
packageServiceClass

	^ RowanPackageService
%

category: '*rowan-tools-extensions-gemstone'
method: RwGsPlatform
packageTools
	"Answer the platform-specific class for package tools"

	^RwPackageTool
%

category: '*rowan-services-extensions'
method: RwGsPlatform
projectServiceClass

	^ RowanProjectService
%

category: '*rowan-tools-extensions-gemstone'
method: RwGsPlatform
projectTools
	"Answer the platform-specific class for project tools"

	^RwProjectTool
%

category: '*rowan-services-extensions'
method: RwGsPlatform
serviceClass

	^ RowanService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
serviceClasses
	"Explicitly add each class rather than sending #allSubclasses so
	that users other than SystemUser have visibility. Visibility in Rowan
	is determined at compile time. See STONReader>>lookupClass:"
	
	| array |
	array := Array with: RowanService. 
	array add: RowanAnsweringService; 
		add: RowanAutoCommitService; 
		add: RowanBrowserService;
		add: RowanClassService; 
		add: RowanDebuggerService; 
		add: RowanDictionaryService; 
		add: RowanFrameService;
		add: RowanInspectorService;
		add: RowanLoggingService;
		add: RowanMethodService;
		add: RowanPackageService; 
		add: RowanProcessService;
		add: RowanProjectService;
		add: RowanQueryService;
		add: RowanTestService;
		add: RowanVariableService.
	^array
%

category: '*rowan-services-extensions'
method: RwGsPlatform
serviceClassFor: className

	^self serviceClasses detect:[:cls | cls name asString = className asString] ifNone:[]
%

! Class extensions for 'RwGsSymbolDictionaryRegistryV2'

!		Instance methods for 'RwGsSymbolDictionaryRegistryV2'

category: '*rowan-gemstone-loaderv2-36x'
method: RwGsSymbolDictionaryRegistryV2
adoptCompiledMethod: compiledMethod classExtension: classExtension for: behavior protocol: protocolString toPackageNamed: packageName
	| methodDictionary selector protocolSymbol existing loadedMethod loadedPackage loadedClassOrExtension |
	classExtension
		ifTrue: [ 
			"to adopt and extension method, it is much less complicated"
			^ self
				addExtensionCompiledMethod: compiledMethod
				for: behavior
				protocol: protocolString
				toPackageNamed: packageName ].

	methodDictionary := (behavior persistentMethodDictForEnv: 0)
		ifNil: [ Dictionary new ].
	selector := compiledMethod selector.
	compiledMethod
		==
			(methodDictionary
				at: selector
				ifAbsent: [ self error: 'expected an existing compiled method' ])
		ifFalse: [ 
			self
				error:
					'The given compiled method does not the existing compiled method in the class.' ].

	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [ behavior addCategory: protocolSymbol ].
	behavior _moveMethod: selector toCategory: protocolSymbol.

	existing := compiledMethod _rowanPackageInfo.
	existing
		ifNotNil: [ 
			"existing LoadedMethod found for compiled method ... ignore already packaged methods"
			^ self ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.
	compiledMethod _rowanPackageInfo: loadedMethod.

	loadedPackage := self
		loadedPackageNamed: packageName
		ifAbsent: [ 
			self
				error: 'Internal error -- attempt to add a method to a nonexistent package.' ].

	loadedClassOrExtension := loadedPackage
		loadedClassOrClassExtensionForClass: behavior
		ifAbsent: [ 
			self
				error:
					'Internal error -- attempt to add a method to a package in which its class is neither defined nor extended.' ].
	loadedClassOrExtension addLoadedMethod: loadedMethod
%

! Class extensions for 'RwGsSymbolDictionaryRegistry_ImplementationV2'

!		Class methods for 'RwGsSymbolDictionaryRegistry_ImplementationV2'

category: '*rowan-gemstone-loaderv2-36x'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: registryInstance
	| methodDictionary selector protocolSymbol existing loadedMethod loadedPackage loadedClassExtension |
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	selector := compiledMethod selector.

	(methodDictionary at: selector ifAbsent: [  ])
		ifNotNil: [ :oldCompiledMethod | 
			compiledMethod == oldCompiledMethod
				ifFalse: [ 
					| src oldSrc "temps for ease of debugging" |
					(src := compiledMethod sourceString trimWhiteSpace)
						= (oldSrc := oldCompiledMethod sourceString trimWhiteSpace)
						ifFalse: [ 
							"only a problem, if the new and old compiled method are not identical"
							self
								error:
									'internal error - Compiled method ' , behavior name asString , '>>'
										, selector asString
										,
											' already exists in method dictionary when new extension method is expected ( package '
										, packageName , ').' ] ] ].

	methodDictionary at: selector put: compiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [ behavior addCategory: protocolSymbol ].
	behavior _moveMethod: selector toCategory: protocolSymbol.

	existing := compiledMethod _rowanPackageInfo.
	existing
		ifNotNil: [ 
			registryInstance
				error:
					'internal error - Existing LoadedMethod ' , behavior name asString , '>>'
						, selector asString , ' found for extension compiled method ( package '
						, packageName , ').' ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	compiledMethod _rowanPackageInfo: loadedMethod.

	loadedPackage := Rowan image
		loadedPackageNamed: packageName
		ifAbsent: [ self existingOrNewLoadedPackageNamed: packageName instance: registryInstance ].

	loadedClassExtension := loadedPackage
		loadedClassExtensionForClass: behavior
		ifAbsent: [ 
			| class ext |
			class := behavior theNonMetaClass.
			ext := RwGsLoadedSymbolDictClassExtension
				newForClass: class
				inPackage: loadedPackage.
			self registerLoadedClassExtension: ext forClass: class.
			ext ].
	loadedClassExtension addLoadedMethod: loadedMethod.
	^ registryInstance
%

category: '*rowan-gemstone-loaderv2-36x'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName instance: registryInstance
	"expecting only a single method to be in methDict/catDict"

	| dictsArray mDict cDict existing loadedMethod loadedPackage loadedClassExtension compiledMethod |
	dictsArray := registryInstance homeSessionMethods
		methodAndCategoryDictionaryFor: behavior.
	mDict := dictsArray at: 1.
	cDict := dictsArray at: 2.
	catDict
		keysAndValuesDo: [ :protocolSymbol :selectors | 
			| symbolSet |
			symbolSet := cDict
				at: protocolSymbol
				ifAbsent: [ cDict at: protocolSymbol put: SymbolSet new ].
			symbolSet addAll: selectors ].
	methDict
		keysAndValuesDo: [ :sel :meth | 
			mDict at: sel put: meth.
			GsPackagePolicy current updateMethodLookupCacheFor: meth in: behavior.
			compiledMethod := meth ].

	existing := compiledMethod _rowanPackageInfo.
	existing
		ifNotNil: [ 
			registryInstance
				error:
					'Internal error -- existing LoadedMethod found for extension compiled method.' ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	compiledMethod _rowanPackageInfo: loadedMethod.

	loadedPackage := self
		existingOrNewLoadedPackageNamed: packageName
		instance: registryInstance.

	loadedClassExtension := loadedPackage
		loadedClassExtensionForClass: behavior
		ifAbsent: [ 
			| class ext |
			class := behavior theNonMetaClass.
			ext := RwGsLoadedSymbolDictClassExtension
				newForClass: class
				inPackage: loadedPackage.
			self registerLoadedClassExtension: ext forClass: class.
			ext ].
	loadedClassExtension addLoadedMethod: loadedMethod.

	^ compiledMethod
%

category: '*rowan-gemstone-loaderv2-36x'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: registryInstance
	| methodDictionary selector protocolSymbol existing loadedMethod loadedPackage loadedClassOrExtension |
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	selector := compiledMethod selector.
	(methodDictionary at: selector ifAbsent: [  ])
		ifNotNil: [ :oldCompiledMethod | 
			"there is an existing compiled method ... that means we're adding a recompiled methoded and moving it to the (possibly new) protocol"
			self addRecompiledMethod: compiledMethod instance: registryInstance.
			^ self
				moveCompiledMethod: compiledMethod
				toProtocol: protocolString
				instance: registryInstance ].
	methodDictionary at: selector put: compiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [ behavior addCategory: protocolSymbol ].
	behavior _moveMethod: selector toCategory: protocolSymbol.

	existing := compiledMethod _rowanPackageInfo.
	existing
		ifNotNil: [ 
			registryInstance
				error: 'Internal error -- existing LoadedMethod found for compiled method.' ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	compiledMethod _rowanPackageInfo: loadedMethod.

	loadedPackage := self
		loadedPackageNamed: packageName
		ifAbsent: [ 
			registryInstance
				error: 'Internal error -- attempt to add a method to a nonexistent package.' ]
		instance: registryInstance.

	loadedClassOrExtension := loadedPackage
		loadedClassOrClassExtensionForClass: behavior
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- attempt to add a method to a package in which its class is neither defined nor extended.' ].
	loadedClassOrExtension addLoadedMethod: loadedMethod.
	^ registryInstance
%

category: '*rowan-gemstone-loaderv2-36x'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
addRecompiledMethod: newCompiledMethod instance: registryInstance
	"add a recompiled compiled method to behavior and update the loaded things"

	| selector behavior methodDictionary oldCompiledMethod loadedMethod |
	selector := newCompiledMethod selector.
	behavior := newCompiledMethod inClass.
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	oldCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- expected an existing compiled method in the method dictionary' ].

	oldCompiledMethod == newCompiledMethod
		ifTrue: [ 
			"exit early, no more work to be done"
			^ registryInstance ].
	methodDictionary at: selector put: newCompiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	loadedMethod := oldCompiledMethod _rowanPackageInfo.
	loadedMethod
		ifNil: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for the old compiledMethod.' ].
	oldCompiledMethod _rowanPackageInfo: nil.

	loadedMethod handle: newCompiledMethod.
	newCompiledMethod _rowanPackageInfo: loadedMethod.
	^ registryInstance
%

category: '*rowan-gemstone-loaderv2-36x'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
addRecompiledSessionMethodMethod: newCompiledMethod instance: registryInstance
	"add a recompiled session method compiled method to behavior and update the loaded things"

	| selector behavior dictsArray mDict cDict oldCompiledMethod loadedMethod |
	selector := newCompiledMethod selector.
	behavior := newCompiledMethod inClass.
	dictsArray := registryInstance homeSessionMethods
		methodAndCategoryDictionaryFor: behavior.
	mDict := dictsArray at: 1.
	cDict := dictsArray at: 2.
	oldCompiledMethod := mDict
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- expected an existing compiled method in the session method method dictionary' ].

	oldCompiledMethod == newCompiledMethod
		ifTrue: [ 
			"exit early, no more work to be done"
			^ registryInstance ].
	mDict at: selector put: newCompiledMethod.
	GsPackagePolicy current
		updateMethodLookupCacheFor: newCompiledMethod
		in: behavior.

	loadedMethod := oldCompiledMethod _rowanPackageInfo.
	loadedMethod
		ifNil: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for the old compiledMethod.' ].
	oldCompiledMethod _rowanPackageInfo: nil.

	loadedMethod handle: newCompiledMethod.
	newCompiledMethod _rowanPackageInfo: loadedMethod
%

category: '*rowan-gemstone-loaderv2-36x'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
moveClassFor: classMove
	" move class from <oldRegistry> to <newRegistry> which includes moveing the loaded methods associated with the class"

	"loaded things are handled elsewhere, just need to update the various registries ... and move the association"

	"extension methods will be dealt with later"

	| originalSymbolDictionary newSymbolDictionary before assoc theClass loadedClass theBehavior oldRegistry newRegistry |
	before := classMove classBefore.
	originalSymbolDictionary := Rowan image
		symbolDictNamed: before gs_symbolDictionary.
	assoc := originalSymbolDictionary associationAt: before key asSymbol.
	theClass := assoc value.
	theBehavior := theClass class.
	oldRegistry := originalSymbolDictionary rowanSymbolDictionaryRegistry.

	newSymbolDictionary := Rowan image
		symbolDictNamed: classMove classAfter gs_symbolDictionary.
	newRegistry := newSymbolDictionary rowanSymbolDictionaryRegistry.

	loadedClass := self loadedClassForClass: theClass.
	originalSymbolDictionary removeKey: assoc key.

	self
		_symbolDictionary: newSymbolDictionary
		at: assoc key
		ifPresent: [ :class | 
			theClass ~~ class
				ifTrue: [ 
					self
						error:
							' internal error - found an existing association in the '
								, newSymbolDictionary name asString printString
								, ' symbol dictionary with a duplicate key ' , assoc key printString
								, ' while attempting to move class ' , assoc key asString printString ] ]
		ifAbsent: [ newSymbolDictionary add: assoc ].

	loadedClass loadedInstanceMethods values
		do: [ :loadedMethod | 
			| compiledMethod |
			"this operation can probably be skipped, since the loaded method itself is not changing"
			compiledMethod := theClass compiledMethodAt: loadedMethod selector asSymbol.
			compiledMethod _rowanPackageInfo: loadedMethod ].
	loadedClass loadedClassMethods values
		do: [ :loadedMethod | 
			| compiledMethod |
			"this operation can probably be skipped, since the loaded method itself is not changing"
			compiledMethod := theBehavior
				compiledMethodAt: loadedMethod selector asSymbol.
			compiledMethod _rowanPackageInfo: loadedMethod ]
%

category: '*rowan-gemstone-loaderv2-36x'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
moveCompiledMethod: compiledMethod toProtocol: newProtocol instance: registryInstance
	"move a compiled method into a different protocol and update loaded things"

	| behavior selector loadedMethod oldCat catSym catDict methodDictionary existingCompiledMethod |
	selector := compiledMethod selector.
	behavior := compiledMethod inClass.

	methodDictionary := (behavior persistentMethodDictForEnv: 0)
		ifNil: [ Dictionary new ].
	existingCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing CompileMethod found for patched method.' ].
	existingCompiledMethod == compiledMethod
		ifFalse: [ 
			registryInstance
				error:
					'Internal error - the existingCompiledMethod is not identical to the compiled method arg' ].

	oldCat := behavior categoryOfSelector: selector environmentId: 0.
	catSym := newProtocol asSymbol.
	catDict := behavior _baseCategorysForStore: 0.
	oldCat ifNotNil: [ (catDict at: oldCat) remove: selector ].
	catDict
		at: catSym
		ifAbsent: [ behavior addCategory: newProtocol environmentId: 0 ].
	(catDict at: catSym) add: selector.

	behavior _moveMethod: selector toCategory: newProtocol.

	loadedMethod := compiledMethod _rowanPackageInfo.
	loadedMethod
		ifNil: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for the compiledMethod.' ].

	loadedMethod updateForProtocolChange.
	^ registryInstance
%

category: '*rowan-gemstone-loaderv2-36x'
classmethod: RwGsSymbolDictionaryRegistry_ImplementationV2
_doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: registryInstance
	"remove a compiled method from loaded things"

	| loadedMethod loadedPackage loadedClassOrExtension |
	compiledMethod _rowanPackageInfo
		ifNotNil: [ :aLoadedMethod | 
			compiledMethod _rowanPackageInfo: nil.
			loadedMethod := aLoadedMethod ]
		ifNil: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for deleted method.' ].

	loadedPackage := loadedMethod loadedPackage.
	loadedClassOrExtension := loadedPackage
		classOrExtensionForClass: behavior
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- attempt to remove a method from a package in which its class is neither defined nor extended.' ].

	loadedClassOrExtension removeLoadedMethod: loadedMethod.
	loadedClassOrExtension isLoadedClassExtension
		ifTrue: [ 
			loadedClassOrExtension isEmpty
				ifTrue: [ 
					self
						unregisterLoadedClassExtension: loadedClassOrExtension
						forClass: loadedClassOrExtension handle.
					loadedPackage removeLoadedClassExtension: loadedClassOrExtension ] ].

	^ registryInstance
%

! Class extensions for 'RwLoadSpecificationV2'

!		Instance methods for 'RwLoadSpecificationV2'

category: '*rowan-definitionsv2'
method: RwLoadSpecificationV2
resolve
	"resolve ensures that the project directory already exists on disk (cloned for git projects) or created on disk for new projects
		answer  the project definition specified by the receiver and any dependent projects"

	"if the project directory already exists on disk, then read the project definition(s) from disk"

	^ RwResolvedProjectV2 loadSpecification: self
%

category: '*rowan-definitionsv2'
method: RwLoadSpecificationV2
resolve: platformAttributes
	"resolve ensures that the project directory already exists on disk (cloned for git projects) or created on disk for new projects
		answer  the project definition specified by the receiver and any dependent projects"

	"if the project directory already exists on disk, then read the project definition(s) from disk"

	^ RwResolvedProjectV2 loadSpecification: self platformAttributes: platformAttributes
%

category: '*rowan-definitionsv2'
method: RwLoadSpecificationV2
resolveProjectSet
	"resolve ensures that the project directory already exists on disk (cloned for git projects) or created on disk for new projects
		answer  the project definition specified by the receiver and any dependent projects"

	"if the project directory already exists on disk, then read the project definition(s) from disk"

	^ RwResolvedProjectV2 loadSpecificationProjectSet: self
%

category: '*rowan-definitionsv2'
method: RwLoadSpecificationV2
resolveProjectSet: platformAttributes
	"resolve ensures that the project directory already exists on disk (cloned for git projects) or created on disk for new projects
		answer  the project definition specified by the receiver and any dependent projects"

	"if the project directory already exists on disk, then read the project definition(s) from disk"

	^ RwResolvedProjectV2 loadSpecificationProjectSet: self platformAttributes: platformAttributes
%

! Class extensions for 'RwMethodDefinition'

!		Class methods for 'RwMethodDefinition'

category: '*rowan-cypress-definitions'
classmethod: RwMethodDefinition
fromCypressMethod: cypMethodDef
  ^ self new
    fromCypressMethod: cypMethodDef;
    yourself
%

!		Instance methods for 'RwMethodDefinition'

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareAgainstBase: aDefinition 

	| modification |
	modification := RwMethodModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification: (self compareSourceAgainstBase: aDefinition).
	^modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareAgainstBaseForNewClassVersion: aDefinition

	| modification |
	modification := RwMethodModificationForNewClassVersion
		before: aDefinition
		after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification:
				(self compareSourceAgainstBaseForNewClassVersion: aDefinition).
	^ modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareExtensionMethodsAgainstBase: aDefinition

	| modification |
	modification := RwExtensionMethodModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification: (self compareSourceAgainstBase: aDefinition).
	^ modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareSourceAgainstBase: aDefinition
	| modification before after |
	modification := RwSourceModification new.
	before := aDefinition source.
	after := self source.
	(before notNil and: [ after notNil and: [ before _unicodeEqual: after ] ])
		ifFalse: [ 
			modification
				addElementModification:
					(RwPropertyModification key: 'source' oldValue: before newValue: after) ].
	^ modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareSourceAgainstBaseForNewClassVersion: aDefinition

	"unconditional modification for new class versions"

	| modification before after |
	modification := RwSourceModification new.
	before := aDefinition source.
	after := self source.
	modification
		addElementModification:
			(RwUnconditionalPropertyModification
				key: 'source'
				oldValue: before
				newValue: after).
	^ modification
%

category: '*rowan-cypress-definitions'
method: RwMethodDefinition
fromCypressMethod: cypMethodDef
  properties
    at: 'selector' put: cypMethodDef selector asSymbol;
    at: 'protocol' put: cypMethodDef category;
    yourself.
  self source: cypMethodDef source
%

! Class extensions for 'RwMethodMove'

!		Instance methods for 'RwMethodMove'

category: '*rowan-gemstone-loader-extensions-onlyv2'
method: RwMethodMove
addMovedMethodToPatchSet: aPatchSet

	aPatchSet addMethodMove: self
%

! Class extensions for 'RwPackage'

!		Instance methods for 'RwPackage'

category: '*rowan-gemstone-core'
method: RwPackage
methodEnv

	^ self _gemstonePlatformSpec methodEnvForPackageNamed: self name
%

! Class extensions for 'RwPackageDefinition'

!		Instance methods for 'RwPackageDefinition'

category: '*rowan-core-definitions-extensions'
method: RwPackageDefinition
compareAgainstBase: aDefinition

	| modification classesModification classExtensionsModification |
	modification := RwPackageModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	classesModification := RwClassesModification new.
	classExtensionsModification := RwClassExtensionsModification new.
	self
		compareDictionary: classDefinitions
		againstBaseDictionary: aDefinition classDefinitions
		into: classesModification
		elementClass: RwClassDefinition.
	self
		compareDictionary: classExtensions
		againstBaseDictionary: aDefinition classExtensions
		into: classExtensionsModification
		elementClass: RwClassExtensionDefinition.
	modification
		classesModification: classesModification;
		classExtensionsModification: classExtensionsModification.
	^modification
%

category: '*rowan-gemstone-definitions'
method: RwPackageDefinition
gs_symbolDictionary

	^ self properties
		at: 'gs_SymbolDictionary'
		ifAbsent: []
%

category: '*rowan-gemstone-definitions'
method: RwPackageDefinition
gs_symbolDictionary: aSymbolDictionaryName

	self properties
		at: 'gs_SymbolDictionary'
		put: aSymbolDictionaryName asString
%

category: '*rowan-cypress-definitions'
method: RwPackageDefinition
name
  ^ self key
%

category: '*rowan-gemstone-definitions'
method: RwPackageDefinition
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue
false ifTrue: [
"gs_SymbolDictionary is now explicitly set before load, so no longer special case for nil"
 	propertyKey = 'gs_SymbolDictionary'
		ifTrue: [ 
			propertyValue = baseValue
				ifTrue: [ ^ true ]
				ifFalse: [ 
					"if one or the other is nil, then count it as equal"
					^ propertyValue == nil or: [ baseValue == nil ] ] ].
].
	^ super
		_compareProperty: propertyKey
		propertyVaue: propertyValue
		againstBaseValue: baseValue
%

! Class extensions for 'RwPackageMove'

!		Instance methods for 'RwPackageMove'

category: '*rowan-gemstone-loader-extensions-onlyv2'
method: RwPackageMove
addMovedPackageToPatchSet: aPatchSet

	aPatchSet addPackageMove: self
%

category: '*rowan-gemstone-loader-extensions-onlyv2'
method: RwPackageMove
movePackage: classesWithNewVersions
	"Move the loaded package from one project to another. 
		(https://github.com/dalehenrich/Rowan/issues/680)"

	projectBefore name = projectAfter name
		ifTrue: [ 
			self
				error:
					'internal error - unexpected move for package when source and destination projects ('
						, projectBefore name , ') are the same' ].
	packageBefore name = packageAfter name
		ifFalse: [ 
			self error: 'internal error - unexpected move for package when source package ('.
			packageBefore name , ' and destination package (' , packageAfter name
				, ') are NOT the same' ].
	(Rowan image loadedRegistryForPackageNamed: packageAfter name)
		movePackage: packageAfter name
		toProjectNamed: projectAfter name
%

! Class extensions for 'RwPackageSetDefinition'

!		Instance methods for 'RwPackageSetDefinition'

category: '*rowan-core-definitions-extensions'
method: RwPackageSetDefinition
compareAgainstBase: aDefinition

	| result |
	result := RwPackageSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary: aDefinition definitions
		into: result
		elementClass: RwPackageDefinition.
	^ result
%

! Class extensions for 'RwPackageTool'

!		Class methods for 'RwPackageTool'

category: '*rowan-tools-onlyv2'
classmethod: RwPackageTool
audit
  ^ RwPkgAuditToolV2 new
%

! Class extensions for 'RwPlatform'

!		Class methods for 'RwPlatform'

category: '*rowan-gemstone-core'
classmethod: RwPlatform
current

	^ self _userPlatformDictionary 
		at: #RwUserPlatformInstance 
		ifAbsentPut: [ RwGsPlatform new ]
%

category: '*rowan-gemstone-core'
classmethod: RwPlatform
reset

	^ self _userPlatformDictionary 
		removeKey: #RwUserPlatformInstance 
		ifAbsent: [ ]
%

category: '*rowan-gemstone-core'
classmethod: RwPlatform
_userPlatformDictionary

	"Platform globals are put into the current user's UserGlobals so that the values can be persisted.
		if the user does not have write access to UserGlobals, we'll store in session-specific dictionary"

	^self _userPlatformDictionaryForUser: RwGsImage currentUserId
%

category: '*rowan-gemstone-core'
classmethod: RwPlatform
_userPlatformDictionaryForUser: aUserId

	"Platform globals are put into the current user's UserGlobals so that the values can be persisted.
		if the user does not have write access to UserGlobals, we'll store in session-specific dictionary"

	| userGlobals |
	userGlobals := (AllUsers userWithId: aUserId) objectNamed: 'UserGlobals'.
	^ (System canWrite: userGlobals)
		ifTrue: [ userGlobals ]
		ifFalse: [ SessionTemps current ]
%

!		Instance methods for 'RwPlatform'

category: '*rowan-corev2'
method: RwPlatform
newEmbeddedProjectNamed: projectName
	^ RwDefinedProject newEmbeddedProjectNamed: projectName
%

category: '*rowan-corev2'
method: RwPlatform
newProjectNamed: projectName
	^ RwDefinedProject newNamed: projectName
%

category: '*rowan-corev2'
method: RwPlatform
projectFromUrl: loadSpecUrl
	^ RwResolvedProject projectFromUrl: loadSpecUrl
%

category: '*rowan-corev2'
method: RwPlatform
projectFromUrl: loadSpecUrl diskUrl: urlString
	^ RwResolvedProject projectFromUrl: loadSpecUrl diskUrl: urlString
%

category: '*rowan-corev2'
method: RwPlatform
projectFromUrl: loadSpecUrl gitUrl: urlString
	^ RwResolvedProject projectFromUrl: loadSpecUrl gitUrl: urlString
%

category: '*rowan-corev2'
method: RwPlatform
projectFromUrl: loadSpecUrl projectsHome: projectsHome
	^ RwResolvedProject projectFromUrl: loadSpecUrl projectsHome: projectsHome
%

category: '*rowan-corev2'
method: RwPlatform
projectFromUrl: loadSpecUrl projectsHome: projectsHome componentNames: componentNames 
	^ RwResolvedProject
		projectFromUrl: loadSpecUrl
		projectsHome: projectsHome
		componentNames: componentNames
%

category: '*rowan-corev2'
method: RwPlatform
projectFromUrl: loadSpecUrl projectsHome: projectsHome componentNames: componentNames customConditionalAttributes: customConditionalAttributes
	^ RwResolvedProject
		projectFromUrl: loadSpecUrl
		projectsHome: projectsHome
		componentNames: componentNames
		customConditionalAttributes: customConditionalAttributes
%

category: '*rowan-corev2'
method: RwPlatform
projectFromUrl: loadSpecUrl projectsHome: projectsHome componentNames: componentNames platformConditionalAttributes: platformConditionalAttributes
	^ RwResolvedProject
		projectFromUrl: loadSpecUrl
		projectsHome: projectsHome
		componentNames: componentNames
		platformConditionalAttributes: platformConditionalAttributes
%

category: '*rowan-corev2'
method: RwPlatform
projectFromUrl: loadSpecUrl projectsHome: projectsHome customConditionalAttributes: customConditionalAttributes
	^ RwResolvedProject
		projectFromUrl: loadSpecUrl
		projectsHome: projectsHome
		customConditionalAttributes: customConditionalAttributes
%

category: '*rowan-corev2'
method: RwPlatform
projectFromUrl: loadSpecUrl readonlyDiskUrl: urlString
	^ RwResolvedProject projectFromUrl: loadSpecUrl readonlyDiskUrl: urlString
%

category: '*rowan-core'
method: RwPlatform
projectNamed: aName

	"Answer a project with the given name.  If no project with the given name is found, signals error."

	| project |
	project := RwProject newNamed: aName.
	project _loadedProject.	"signal error, if the project does not exist"
	^ project
%

category: '*rowan-core'
method: RwPlatform
projectNamed: aName ifPresent: presentBlock ifAbsent: absentBlock

	"Lookup a loaded project with the given name, if found evaluate the <presentBlock>, if not evaluate the <absentBlock.."

	^ Rowan image
		loadedProjectNamed: aName
		ifPresent: [:loadedProject |  presentBlock cull: (RwProject newNamed: aName) ]
		ifAbsent: absentBlock
%

! Class extensions for 'RwPrjAdoptTool'

!		Instance methods for 'RwPrjAdoptTool'

category: '*rowan-tools-corev2'
method: RwPrjAdoptTool
adoptProjectFromUrl: specUrl diskUrl: diskUrl projectsHome: projectsHome
	"Create loaded project (if needed), traverse the package definitions and 
				create loaded packages for each"

	| loadSpec projectSetDefinition |
	loadSpec := RwSpecification fromUrl: specUrl.
	projectSetDefinition := loadSpec
		diskUrl: diskUrl;
		projectsHome: projectsHome;
		resolveProjectSet.

	Rowan projectTools adopt
		_adoptProjectProjectsInProjectSet: projectSetDefinition
%

category: '*rowan-tools-corev2'
method: RwPrjAdoptTool
adoptProjectFromUrl: specUrl projectsHome: projectsHome
	"Create loaded project (if needed), traverse the package definitions and 
				create loaded packages for each"

	| loadSpec projectSetDefinition |
	loadSpec := RwSpecification fromUrl: specUrl.
	projectSetDefinition := loadSpec
		projectsHome: projectsHome;
		resolveProjectSet.

	self _adoptProjectProjectsInProjectSet: projectSetDefinition
%

category: '*rowan-tools-corev2'
method: RwPrjAdoptTool
adoptProjectFromUrl: specUrl readonlyDiskUrl: diskUrl projectsHome: projectsHome
	"Create loaded project (if needed), traverse the package definitions and 
				create loaded packages for each"

	| loadSpec projectSetDefinition |
	loadSpec := RwSpecification fromUrl: specUrl.
	projectSetDefinition := loadSpec
		readonlyDiskUrl: diskUrl;
		projectsHome: projectsHome;
		resolveProjectSet.

	Rowan projectTools adopt
		_adoptProjectProjectsInProjectSet: projectSetDefinition
%

category: '*rowan-tools-corev2'
method: RwPrjAdoptTool
_adoptProjectProjectsInProjectSet: projectSetDefinition
	"Create loaded project (if needed), traverse the package definitions and 
				create loaded packages for each"

	| auditFailures reAudit theProjectSetDefinition tracer wasTracing adoptErrors |
	theProjectSetDefinition := RwProjectSetDefinition new.
	tracer := Rowan projectTools trace.
	wasTracing := tracer isTracing.
	tracer startTracing.
	projectSetDefinition projects
		do: [ :resolvedProject | 
			| resolvedProject_copy projectDefinition |
			"make a copy of the resolvedProject (and repair it for now, since copyForLoadedProject is somewhat destructive"
			resolvedProject_copy := resolvedProject copyForLoadedProject.
			projectDefinition := resolvedProject _projectDefinition copy.
			projectDefinition components: resolvedProject_copy _projectStructure.
			resolvedProject_copy
				_projectDefinition: projectDefinition;
				_projectStructure: nil;
				yourself.
			tracer trace: 'Project: ' , resolvedProject_copy name.
			resolvedProject_copy packageNames
				do: [ :packageName | 
					"wipe out package contents, so we can load *empty* project and packages, that will be adopted in next step"
					tracer trace: '	' , packageName.
					(resolvedProject_copy packageNamed: packageName)
						classDefinitions: Dictionary new;
						classExtensions: Dictionary new;
						yourself ].
			theProjectSetDefinition addProject: resolvedProject_copy ].
	wasTracing
		ifFalse: [ 
			"reduce noise if tracing not already set"
			tracer stopTracing ].
	Rowan projectTools loadV2 loadProjectSetDefinition: theProjectSetDefinition.	"Load the project shell -- project and empty packages"
	wasTracing
		ifFalse: [ tracer startTracing ].
	[ 
	"Adopt the project set definition ... 
		Log and ignore any missing method or missing classes encountered as they may not be
		present in the .gs bootstrap file for the proejct ... The will be created when we
		reload the project a little bit later on."
	adoptErrors := false.
	Rowan projectTools adopt adoptProjectSetDefinition: projectSetDefinition ]
		on:
			RwAdoptMissingMethodErrorNotification , RwAdoptMissingClassErrorNotification
		do: [ :ex | 
			ex
				methodErrorDo: [ 
					adoptErrors := true.
					tracer
						trace:
							'Missing loaded method ' , ex methodPrintString
								, ' encountered during adopt' ]
				classErrorDo: [ 
					adoptErrors := true.
					tracer
						trace:
							'Missing loaded class ' , ex className , ' encountered during adopt' ].
			ex resume: nil ].

	projectSetDefinition deriveLoadedThings
		do: [ :loadedProject | 
			"mark projects and packages not dirty"
			loadedProject markNotDirty.
			loadedProject loadedPackages
				valuesDo: [ :loadedPackage | loadedPackage markNotDirty ] ].

	System commit.	"save pre-audit state, so that audit errors can be examined"

	reAudit := true.	"kick off the first audit"
	[ reAudit ]
		whileTrue: [ 
			auditFailures := {}.
			reAudit := false.
			projectSetDefinition projects
				do: [ :projectDefinition | 
					| audit projectName |
					projectName := projectDefinition name.
					audit := Rowan projectTools audit auditForProjectNamed: projectName.
					tracer trace: '	-- audit finished '.
					audit isEmpty
						ifFalse: [ 
							"we must have had an audit failure that was not handled"
							reAudit := false.
							tracer trace: 'FAILED AUDIT: ' , projectName.
							auditFailures add: projectName ] ].
			reAudit
				ifTrue: [ tracer trace: 'RERUN AUDIT' ] ].
	wasTracing
		ifFalse: [ tracer stopTracing ].
	auditFailures isEmpty
		ifFalse: [ 
			self
				error:
					'Post load Rowan audit failed for projects ' , auditFailures printString ].
	adoptErrors
		ifTrue: [ self error: 'Missing methods during adopt step, Check log for details' ]
%

! Class extensions for 'RwProject'

!		Instance methods for 'RwProject'

category: '*rowan-corev2'
method: RwProject
addNewPackageNamed: packageName inSybolDictionaryNamed: symbolDictionaryName toComponentNamed: componentName
	Rowan image
		loadedPackageNamed: packageName
		ifAbsent: [ 
			| projectDefinition component |
			projectDefinition := self defined.
			component := projectDefinition
				componentNamed: componentName
				ifAbsent: [ 
					self
						error:
							'The component ' , componentName printString , ' does not exist in the project'
								, self name printString ].
			self _loadSpecification gemstoneDefaultSymbolDictName = symbolDictionaryName
				ifTrue: [ projectDefinition addPackageNamed: packageName toComponentNamed: componentName ]
				ifFalse: [ 
					projectDefinition
						addPackageNamed: packageName
						toComponentNamed: componentName
						gemstoneDefaultSymbolDictionaryForUser:
							System myUserProfile userId -> symbolDictionaryName ].
			^ projectDefinition load ].
	self
		error:
			'The package ' , packageName printString , ' already exists in the project '
				, self name printString
%

category: '*rowan-corev2'
method: RwProject
addNewPackageNamed: packageName toComponentNamed: componentName
	^ self
		addNewPackageNamed: packageName
		inSybolDictionaryNamed: self _loadSpecification gemstoneDefaultSymbolDictName
		toComponentNamed: componentName
%

category: '*rowan-corev2'
method: RwProject
addTopLevelComponentNamed: componentName
	^ self addTopLevelComponentNamed: componentName condition: 'common'
%

category: '*rowan-corev2'
method: RwProject
addTopLevelComponentNamed: componentName condition: condition
	"since we are working with a loaded project here, adding a new top level component 
		with a condition, implies that the condition should be applied to the load specification, 
		thus causing the new component to be loaded"

	| projectDefinition component conditionals |
	projectDefinition := self defined.
	component := projectDefinition
		addTopLevelComponentNamed: componentName
		condition: condition.
	conditionals := projectDefinition customConditionalAttributes copy.
	conditionals add: condition.
	projectDefinition customConditionalAttributes: conditionals asSet asArray.
	projectDefinition load.
	^ component
%

category: '*rowan-corev2'
method: RwProject
componentNames
	^ self _loadedProject componentNames
%

category: '*rowan-gemstone-core'
method: RwProject
defaultSymbolDictName: aString

	^ self _loadedProject defaultSymbolDictName: aString
%

category: '*rowan-corev2'
method: RwProject
diskRepositoryRoot: repositoryRootPathString
	| originalRepositoryRoot |
	repositoryRootPathString isString
		ifFalse: [ self error: 'readOnly repository root must be a string' ].
	originalRepositoryRoot := self repositoryRoot.
	self requiredProjects
		do: [ :project | 
			project repositoryRoot = originalRepositoryRoot
				ifTrue: [ 
					"only embedded required projects should have their repository root swapped out"
					project _diskRepositoryRoot: repositoryRootPathString ] ].
	self _diskRepositoryRoot: repositoryRootPathString
%

category: '*rowan-corev2'
method: RwProject
exportLoadSpecification
	^ self _loadedProject asDefinition exportLoadSpecification
%

category: '*rowan-gemstone-core'
method: RwProject
exportTopazFormatTo: filePath
	^ self
		logClassCreation: false
		excludeClassInitializers: false
		excludeRemoveAllMethods: false
%

category: '*rowan-gemstone-core'
method: RwProject
exportTopazFormatTo: filePath logClassCreation: logClassCreation excludeClassInitializers: excludeClassInitializers excludeRemoveAllMethods: excludeRemoveAllMethods
	^ self _loadedProject asDefinition
		exportTopazFormatTo: filePath
		logClassCreation: logClassCreation
		excludeClassInitializers: excludeClassInitializers
		excludeRemoveAllMethods: excludeRemoveAllMethods
%

category: '*rowan-gemstone-core'
method: RwProject
exportTopazFormatTo: filePath logClassCreation: logClassCreation excludeClassInitializers: excludeClassInitializers excludeRemoveAllMethods: excludeRemoveAllMethods usingPackageNamesMap: packageNamesMap
	^ self _loadedProject asDefinition
		exportTopazFormatTo: filePath
		logClassCreation: logClassCreation
		excludeClassInitializers: excludeClassInitializers
		excludeRemoveAllMethods: excludeRemoveAllMethods
		usingPackageNamesMap: packageNamesMap
%

category: '*rowan-corev2'
method: RwProject
gitRepositoryRoot: repositoryRootPathString
	| originalRepositoryRoot |
	repositoryRootPathString isString
		ifFalse: [ self error: 'readOnly repository root must be a string' ].
	originalRepositoryRoot := self repositoryRoot.
	self requiredProjects
		do: [ :project | 
			project repositoryRoot = originalRepositoryRoot
				ifTrue: [ 
					"only embedded required projects should have their repository root swapped out"
					project _gitRepositoryRoot: repositoryRootPathString ] ].
	self _gitRepositoryRoot: repositoryRootPathString
%

category: '*rowan-corev2'
method: RwProject
loadedComponents
	^ self _loadedProject loadedComponentDefinitions
%

category: '*rowan-gemstone-core'
method: RwProject
methodEnvForPackageNamed: packageName

	^ self _gemstonePlatformSpec methodEnvForPackageNamed: packageName
%

category: '*rowan-corev2'
method: RwProject
packageConvention
	^ self _loadedProject packageConvention
%

category: '*rowan-corev2'
method: RwProject
platformConditionalAttributes
	"Answer the platformConditionalAttributes used to load the project"

	^ self _loadedProject platformConditionalAttributes
%

category: '*rowan-corev2'
method: RwProject
projectsHome
	^ self _loadedProject resolvedProject projectsHome
%

category: '*rowan-corev2'
method: RwProject
readOnlyRepositoryRoot: repositoryRootPathString commitId: commitId
	| originalRepositoryRoot |
	repositoryRootPathString isString
		ifFalse: [ self error: 'readOnly repository root must be a string' ].
	originalRepositoryRoot := self repositoryRoot.
	self requiredProjects
		do: [ :project | 
			project repositoryRoot = originalRepositoryRoot
				ifTrue: [ 
					"only embedded required projects should have their repository root swapped out"
					project
						_readOnlyRepositoryRoot: repositoryRootPathString
						commitId: commitId ] ].
	self
		_readOnlyRepositoryRoot: repositoryRootPathString
		commitId: commitId
%

category: '*rowan-corev2'
method: RwProject
readOnlyRepositoryRoot: repositoryRootPathString projectsHome: projectsHome commitId: commitId
	| originalRepositoryRoot |
	repositoryRootPathString isString
		ifFalse: [ self error: 'readOnly repository root must be a string' ].
	originalRepositoryRoot := self repositoryRoot.
	self requiredProjects
		do: [ :project | 
			project repositoryRoot = originalRepositoryRoot
				ifTrue: [ 
					"only embedded required projects should have their repository root swapped out"
					project
						_readOnlyRepositoryRoot: repositoryRootPathString
						projectsHome: projectsHome
						commitId: commitId ] ].
	self
		_readOnlyRepositoryRoot: repositoryRootPathString
		projectsHome: projectsHome
		commitId: commitId
%

category: '*rowan-corev2'
method: RwProject
removePackageNamed: packageName
	| projectDefinition |
	Rowan image
		loadedPackageNamed: packageName
		ifAbsent: [ 
			self
				error:
					'The package ' , packageName printString , ' does not exists in the project '
						, self name printString ].
	projectDefinition := self defined.
	projectDefinition removePackageNamed: packageName.
	^ projectDefinition load
%

category: '*rowan-corev2'
method: RwProject
repositoryRoot
	^ self _loadedProject repositoryRoot
%

category: '*rowan-corev2'
method: RwProject
repositoryRoot: aFileReferenceOrString
	| resolvedProject originalRepositoryRoot |
	originalRepositoryRoot := self repositoryRoot.
	self requiredProjects
		do: [ :project | 
			project repositoryRoot = originalRepositoryRoot
				ifTrue: [ 
					"only embedded required projects should have their repository root swapped out"
					project _repositoryRoot: aFileReferenceOrString ] ].
	resolvedProject := self asDefinition.
	resolvedProject repositoryRoot: aFileReferenceOrString.
	^ resolvedProject loadProjectSet
%

category: '*rowan-corev2'
method: RwProject
repositoryRoot: aFileReferenceOrString platformConditionalAttributes: platformConditionalAttributes
	| resolvedProject originalRepositoryRoot |
	originalRepositoryRoot := self repositoryRoot.
	self requiredProjects
		do: [ :project | 
			project repositoryRoot = originalRepositoryRoot
				ifTrue: [ 
					"only embedded required projects should have their repository root swapped out"
					project _repositoryRoot: aFileReferenceOrString ] ].
	resolvedProject := self asDefinition.
	resolvedProject repositoryRoot: aFileReferenceOrString.
	^ resolvedProject loadProjectSet: platformConditionalAttributes
%

category: '*rowan-corev2'
method: RwProject
repositoryRoot: aFileReferenceOrString platformConditionalAttributes: platformConditionalAttributes instanceMigrator: instanceMigrator
	| resolvedProject originalRepositoryRoot |
	originalRepositoryRoot := self repositoryRoot.
	self requiredProjects
		do: [ :project | 
			project repositoryRoot = originalRepositoryRoot
				ifTrue: [ 
					"only embedded required projects should have their repository root swapped out"
					project _repositoryRoot: aFileReferenceOrString ] ].
	resolvedProject := self asDefinition.
	resolvedProject repositoryRoot: aFileReferenceOrString.
	^ resolvedProject loadProjectSet: platformConditionalAttributes instanceMigrator: instanceMigrator
%

category: '*rowan-corev2'
method: RwProject
requiredProjects
	"return list of dependent project names"

	"https://github.com/GemTalk/Rowan/issues/571 is addressed"

	| requiredProjectNames theComponents |
	theComponents := self loadedComponents. "use loadedComponents, not _loadedProjectDefinition - loadedComponents kept up to date"
	requiredProjectNames := Set new.
	theComponents
		conditionalComponentsStartingWith: self componentNames
		platformConditionalAttributes: self platformConditionalAttributes
		do: [ :aComponent | requiredProjectNames addAll: aComponent projectNames ].
	^ requiredProjectNames asArray
		collect: [ :projectName | Rowan projectNamed: projectName ]
%

category: '*rowan-gemstone-core'
method: RwProject
symbolDictNameForPackageNamed: packageName

	^ self _loadedProject symbolDictNameForPackageNamed: packageName
%

category: '*rowan-corev2'
method: RwProject
topLevelComponentNames
	^ self _loadedProject resolvedProject _loadSpecification componentNames
%

category: '*rowan-gemstone-core'
method: RwProject
useSessionMethodsForExtensionsForPackageNamed: packageName

	^ self _gemstonePlatformSpec
		useSessionMethodsForExtensionsForPackageNamed: packageName
%

category: '*rowan-corev2'
method: RwProject
_diskRepositoryRoot: repositoryRootPathString
	self _loadedProject resolvedProject diskRepositoryRoot: repositoryRootPathString
%

category: '*rowan-corev2'
method: RwProject
_gitRepositoryRoot: repositoryRootPathString
	self _loadedProject resolvedProject gitRepositoryRoot: repositoryRootPathString
%

category: '*rowan-corev2'
method: RwProject
_readOnlyRepositoryRoot: repositoryRootPathString commitId: commitId
	self _loadedProject resolvedProject
		readOnlyRepositoryRoot: repositoryRootPathString
		commitId: commitId
%

category: '*rowan-corev2'
method: RwProject
_readOnlyRepositoryRoot: repositoryRootPathString projectsHome: projectsHome commitId: commitId
	self _loadedProject resolvedProject _loadSpecification
		projectsHome: projectsHome;
		readonlyDiskUrl: 'file:' , repositoryRootPathString.
	self _loadedProject resolvedProject
		readOnlyRepositoryRoot: repositoryRootPathString
		commitId: commitId
%

category: '*rowan-corev2'
method: RwProject
_repositoryRoot: aFileReference
	self _loadedProject resolvedProject repositoryRoot: aFileReference
%

! Class extensions for 'RwProjectDefinitionV2'

!		Instance methods for 'RwProjectDefinitionV2'

category: '*rowan-gemstone-definitionsv2'
method: RwProjectDefinitionV2
gemstoneDefaultSymbolDictNameForUser: userId
	^ self projectSpecification gemstoneDefaultSymbolDictNameForUser: userId
%

category: '*rowan-gemstone-definitionsv2'
method: RwProjectDefinitionV2
gemstoneSetSymbolDictName: symbolDictName forPackageNamed: packageName
	self components
		gemstoneSetSymbolDictName: symbolDictName
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitionsv2'
method: RwProjectDefinitionV2
gemstoneSetSymbolDictNameForUser: userId to: symbolDictName forPackageNamed: packageName
	self components
		gemstoneSetSymbolDictNameForUser: userId
		to: symbolDictName
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitionsv2'
method: RwProjectDefinitionV2
gemstoneSetUseSessionMethodsForExtensions: aBool forPackageNamed: packageName
	self components
		gemstoneSetUseSessionMethodsForExtensions: aBool
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitionsv2'
method: RwProjectDefinitionV2
gemstoneSetUseSessionMethodsForExtensionsForUser: userId to: aBool forPackageNamed: packageName
	self components
		gemstoneSetUseSessionMethodsForExtensionsForUser: userId
		to: aBool
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitionsv2'
method: RwProjectDefinitionV2
gemstoneSymbolDictNameForPackageNamed: packageName forUser: userId ifAbsent: absentBlock
	^ self components
		gemstoneSymbolDictNameForPackageNamed: packageName
		forUser: userId
		ifAbsent: absentBlock
%

category: '*rowan-gemstone-definitionsv2'
method: RwProjectDefinitionV2
_gemstoneAllUsersName
	^ RwLoadSpecificationV2 _gemstoneAllUsersName
%

! Class extensions for 'RwProjectModification'

!		Instance methods for 'RwProjectModification'

category: '*rowan-corev2'
method: RwProjectModification
componentsWithDoits
	^ self after
		ifNotNil: [ :projectDef | projectDef componentsWithDoits ]
%

! Class extensions for 'RwProjectSetDefinition'

!		Instance methods for 'RwProjectSetDefinition'

category: '*rowan-core-definitions-extensions'
method: RwProjectSetDefinition
compareAgainstBase: aDefinition
	| result |
	result := RwProjectSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary: aDefinition definitions
		into: result
		elementClass: RwProjectDefinitionV2.
	^ result
%

category: '*rowan-core-definitions-extensions'
method: RwProjectSetDefinition
compareAgainstBaseForLoader: aDefinition
	"use this message IFF you are prepared to deal directly with movedClasses and movedMethods.
		For general purpose comparison, compareAgainstBase: is a better choice"

	| result |
	result := RwProjectSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary: aDefinition definitions
		into: result
		elementClass: RwProjectDefinitionV2.
	result
		updateForPackageMoves;
		updateForClassMoves;
		updateForMethodMoves.
	^ result
%

! Class extensions for 'RwProjectSetModification'

!		Instance methods for 'RwProjectSetModification'

category: '*rowan-corev2'
method: RwProjectSetModification
componentsWithDoits
	| componentsWithDoits |
	componentsWithDoits := Set new.
	self elementsModified
		keysAndValuesDo: [ :projectName :projectModification | 
			componentsWithDoits
				addAll: projectModification componentsWithDoits ].
	^ componentsWithDoits
%

! Class extensions for 'RwProjectTool'

!		Class methods for 'RwProjectTool'

category: '*rowan-tools-onlyv2'
classmethod: RwProjectTool
browser

	^RwPrjBrowserToolV2 new
%

category: '*rowan-tools-corev2'
classmethod: RwProjectTool
createV2
	^ RwPrjCreateToolV2 new
%

category: '*rowan-tools-onlyv2'
classmethod: RwProjectTool
load

	^RwPrjLoadToolV2 new
%

category: '*rowan-tools-corev2'
classmethod: RwProjectTool
loadV2

	^RwPrjLoadToolV2 new
%

category: '*rowan-tools-corev2'
classmethod: RwProjectTool
readV2
  ^ RwPrjReadToolV2 new
%

category: '*rowan-tools-corev2'
classmethod: RwProjectTool
reconcileV2

	^ RwPrjReconcileToolV2 new
%

category: '*rowan-tools-onlyv2'
classmethod: RwProjectTool
write

	^RwPrjWriteToolV2 new
%

category: '*rowan-tools-corev2'
classmethod: RwProjectTool
writeV2
	^ RwPrjWriteToolV2 new
%

! Class extensions for 'RwResolvedProjectV2'

!		Instance methods for 'RwResolvedProjectV2'

category: '*rowan-gemstone-definitions-extensionsv2'
method: RwResolvedProjectV2
asLoadedSymbolDictProject
	^ RwGsLoadedSymbolDictResolvedProjectV2 newForResolvedProject: self
%

category: '*rowan-core-definitionsv2'
method: RwResolvedProjectV2
compareAgainstBase: aDefinition

	| modification packagesModification |
	modification := RwProjectModification before: aDefinition after: self.
	modification
		propertiesModification: (self _projectDefinition comparePropertiesAgainstBase: aDefinition _projectDefinition).
	packagesModification := RwPackagesModification new.
	self
		compareDictionary: self packages
		againstBaseDictionary: aDefinition packages
		into: packagesModification
		elementClass: RwPackageDefinition.
	modification packagesModification: packagesModification.
	^ modification
%

category: '*rowan-core-definitionsv2'
method: RwResolvedProjectV2
compareDictionary: myDictionary againstBaseDictionary: baseDictionary into: anElementsModification elementClass: elementClass

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys do: 
			[:key |
			| before after modification |
			before := baseDictionary at: key ifAbsent: [elementClass new].
			after := myDictionary at: key ifAbsent: [elementClass new].
			modification := after compareAgainstBase: before.
			modification isEmpty
				ifFalse: [anElementsModification addElementModification: modification]]
%

category: '*rowan-tests-definitionsv2-extensions-onlyv2'
method: RwResolvedProjectV2
create
	"RwComponentProjectDefinition tests compatibility ... eventually get rid of this"
	self resolve; export
%

category: '*rowan-tests-definitionsv2-extensions-onlyv2'
method: RwResolvedProjectV2
exportPharoTonelFormatV1

	Rowan projectTools writeV2 writeResolvedProjectPharoTonelFormatV1: self
%

category: '*rowan-tests-definitionsv2-extensions-onlyv2'
method: RwResolvedProjectV2
exportPharoTonelFormatV1Packages
	| projectSetDefinition |
	projectSetDefinition := [ 
	RwProjectSetDefinition new
		addProject: self copy read;
		yourself ]
		on: Error
		do: [ :ignored | RwProjectSetDefinition new ].
	self
		exportPharoTonelFormatV1Packages: projectSetDefinition
		packagesRoot: self packagesRoot
		packageFormat: self packageFormat
		packageConvention: self packageConvention
%

category: '*rowan-tests-definitionsv2-extensions-onlyv2'
method: RwResolvedProjectV2
exportPharoTonelFormatV1Packages: diskProjectSetDefinition packagesRoot: packagesRoot packageFormat: packageFormat packageConvention: packageConvention
	| projectSetDefinition visitor projectSetModification writerVisitorClass |
	packagesRoot / 'properties' , 'st'
		writeStreamDo: [ :fileStream | 
			fileStream
				nextPutAll: '{ ';
				lf;
				tab;
				nextPutAll: '#format : ' , packageFormat printString , ',';
				lf;
				tab;
				nextPutAll: '#convention : ' , packageConvention printString;
				lf;
				nextPutAll: '}';
				lf ].	"write out packages"
	writerVisitorClass := packageFormat = 'tonel'
		ifTrue: [ RwModificationPharoTonelFormatV1WriterVisitorV2 ]
		ifFalse: [ self error: 'should not be used for filetree format packages' ].
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: self.
	projectSetModification := projectSetDefinition
		compareAgainstBase: diskProjectSetDefinition.
	visitor := writerVisitorClass new
		packagesRoot: packagesRoot;
		yourself.

	visitor visit: projectSetModification
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneDefaultSymbolDictName
	^ self _loadSpecification gemstoneDefaultSymbolDictName
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneDefaultSymbolDictNameForUser: userId
	^ self _loadSpecification gemstoneDefaultSymbolDictNameForUser: userId
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneSetDefaultSymbolDictNameForUser: userId to: symbolDictName
	self _loadSpecification gemstoneSetDefaultSymbolDictNameForUser: userId to: symbolDictName
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneSetDefaultSymbolDictNameTo: symbolDictName
	self _loadSpecification gemstoneSetDefaultSymbolDictNameTo: symbolDictName
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneSetDefaultUseSessionMethodsForExtensionsForUser: userId to: aBool
	self _loadSpecification
		gemstoneSetDefaultUseSessionMethodsForExtensionsForUser: userId
		to: aBool
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneSetDefaultUseSessionMethodsForExtensionsTo: aBool
	self _loadSpecification
		gemstoneSetDefaultUseSessionMethodsForExtensionsTo: aBool
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneSetSymbolDictName: symbolDictName forPackageNamed: packageName
	self _projectDefinition gemstoneSetSymbolDictName: symbolDictName forPackageNamed: packageName
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneSetSymbolDictNameForUser: userId to: symbolDictName forPackageNamed: packageName
	self _projectDefinition
		gemstoneSetSymbolDictNameForUser: userId
		to: symbolDictName
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneSetUseSessionMethodsForExtensions: aBool forPackageNamed: packageName
	self _projectDefinition
		gemstoneSetUseSessionMethodsForExtensions: aBool
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneSetUseSessionMethodsForExtensionsForUser: userId to: aBool forPackageNamed: packageName
	self _projectDefinition
		gemstoneSetUseSessionMethodsForExtensionsForUser: userId
		to: aBool
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneSymbolDictNameForPackageNamed: packageName
	^ self
		gemstoneSymbolDictNameForPackageNamed: packageName
		forUser: Rowan image currentUserId
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
gemstoneSymbolDictNameForPackageNamed: packageName forUser: userId
	| resolvedLoadComponents |
	resolvedLoadComponents := self _projectStructure
		ifNil: [ self _projectDefinition ]
		ifNotNil: [ :structure | structure ].
	^ resolvedLoadComponents
		gemstoneSymbolDictNameForPackageNamed: packageName
		forUser: userId
		ifAbsent: [ 
			"no entry for this package, use the defaultSymbolDictName"
			^ self gemstoneDefaultSymbolDictNameForUser: userId ]
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
methodEnvForPackageNamed: packageName

	^self _loadSpecification gemstoneDefaultMethodEnvForUser: Rowan image currentUserId
%

category: '*rowan-gemstone-definitionsv2'
method: RwResolvedProjectV2
useSessionMethodsForExtensionsForPackageNamed: packageName
	| default |
	default := self _loadSpecification
		gemstoneDefaultUseSessionMethodsForExtensionsForUser:
			Rowan image currentUserId.
	(self componentForPackageNamed: packageName)
		ifNil: [ ^ default ]
		ifNotNil: [ :component | 
			| packageMap propertiesMap |
			packageMap := (component
				conditionalPackageMapSpecsAtGemStoneUserId: Rowan image currentUserId)
				at: #'packageNameToPlatformPropertiesMap'
				ifAbsent: [ 
					(component
						conditionalPackageMapSpecsAtGemStoneUserId: self _gemstoneAllUsersName)
						at: #'packageNameToPlatformPropertiesMap'
						ifAbsent: [ ^ default ] ].
			propertiesMap := packageMap at: packageName ifAbsent: [ ^ default ].
			^ propertiesMap at: 'useSessionMethodsForExtensions' ifAbsent: [ ^ default ] ]
%

! Class extensions for 'RwSpecification'

!		Class methods for 'RwSpecification'

category: '*rowan-gemstone-specifications'
classmethod: RwSpecification
fromFile: filePath
	filePath asFileReference
		readStreamDo: [ :fileStream | 
			| stream spec |
			stream := ZnBufferedReadStream on: fileStream.	"wrap with buffered stream to bypass https://github.com/GemTalk/FileSystemGs/issues/9"
			spec := (STON fromStream: stream)
				initializeForImport;
				yourself.
			Rowan projectTools trace
				trace: '--- reading ' , spec class label , filePath asString.
			^ spec ]
%

! Class extensions for 'SequenceableCollection'

!		Class methods for 'SequenceableCollection'

category: '*rowan-gemstone-kernel'
classmethod: SequenceableCollection
new: size withAll: value

	"Answer an instance of me, with number of elements equal to size, each 
	of which refers to the argument, value."

	^ (self new: size)
		atAllPut: value;
		yourself
%

!		Instance methods for 'SequenceableCollection'

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
allButFirst
  "Answer a copy of the receiver containing all but the first
	element. Raise an error if there are not enough elements."

  ^ self allButFirst: 1
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
allButFirst: n
	"Answer a copy of the receiver containing all but the first n
	elements. Raise an error if there are not enough elements."

	^ self copyFrom: n + 1 to: self size
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
copyAfterLast: anElement
	"Answer a copy of the receiver from after the last occurence
	of anElement up to the end. If no such element exists, answer 
	an empty copy."

	^ self allButFirst: (self lastIndexOf: anElement ifAbsent: [^ self copyEmpty])
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
copyLast: n
	"Answer the last n elements of the receiver.  
	Raise an error if there are not enough elements."

	| size |
	size := self size.
	^ self copyFrom: size - n + 1 to: size
%

category: '*rowan-gemstone-kernel'
method: SequenceableCollection
copyUpTo: anObject

	"Answer all elements up to but not including anObject. If there
  is no such object, answer a copy of the receiver."

	| idx |
	idx := self indexOf: anObject startingAt: 1.
	idx == 0
		ifTrue: [ ^ self copy ]
		ifFalse: [ ^ self copyFrom: 1 to: idx - 1 ]
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
copyUpToLast: anElement
  "Answer a copy of the receiver from index 1 to the last occurrence of 
	anElement, not including anElement."

	| n |
	n :=  (self lastIndexOf: anElement ifAbsent: [ ^ self copy ]) - 1.
  ^ self copyFrom: 1 to: n
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
copyWithFirst: newElement 
	"Answer a copy of the receiver that is 1 bigger than the receiver with newElement as the first element."

	| newIC |
	newIC := self species new: self size + 1.
	newIC 
		replaceFrom: 2
		to: self size + 1
		with: self
		startingAt: 1.
	newIC at: 1 put: newElement.
	^ newIC
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
grownBy: length
	"Answer a copy of receiver collection with size grown by length"

	| newCollection size |
	size := self size.
	newCollection := self species new: size + length.
	newCollection replaceFrom: 1 to: size with: self startingAt: 1.
	^ newCollection
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
lastIndexOf: anElement ifAbsent: exceptionBlock
  "Answer the index of the last occurence of anElement within the  
	receiver. If the receiver does not contain anElement, answer the
	result of evaluating the argument, exceptionBlock."

  ^ self lastIndexOf: anElement startingAt: self size ifAbsent: exceptionBlock
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock
  "Answer the index of the last occurence of anElement within the  
	receiver. If the receiver does not contain anElement, answer the
	result of evaluating the argument, exceptionBlock."

  lastIndex to: 1 by: -1 do: [ :index | 
    (self at: index) = anElement
      ifTrue: [ ^ index ] ].
  ^ exceptionBlock ~~ nil
    ifTrue: [ exceptionBlock value ]
    ifFalse: [ 0 ]
%

category: '*ast-kernel-core'
method: SequenceableCollection
rbStoreElementsFrom: firstIndex to: lastIndex on: aStream
  | noneYet defaultElement arrayElement |
  noneYet := true.
  defaultElement := nil.
  firstIndex to: lastIndex do: [ :index | 
    arrayElement := self at: index.
    arrayElement = defaultElement
      ifFalse: [ 
        noneYet
          ifTrue: [ noneYet := false ]
          ifFalse: [ aStream nextPut: $; ].
        aStream nextPutAll: ' at: '.
        index rbStoreOn: aStream.
        aStream nextPutAll: ' put: '.
        arrayElement rbStoreOn: aStream] ].
  ^ noneYet
%

category: '*ast-kernel-core'
method: SequenceableCollection
rbStoreOn: aStream
  aStream nextPutAll: '(('.
  aStream nextPutAll: self class name.
  aStream nextPutAll: ' new: '.
  self size rbStoreOn: aStream.
  aStream nextPut: $).
  (self rbStoreElementsFrom: 1 to: self size on: aStream)
    ifFalse: [ aStream nextPutAll: '; yourself' ].
  aStream nextPut: $)
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
readStreamPortable

	^ ReadStreamPortable on: self
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
replaceAll: oldObject with: newObject
  "Replace all occurences of oldObject with newObject"

  | index |
  index := self indexOf: oldObject startingAt: 1 ifAbsent: [ 0 ].
  [ index = 0 ]
    whileFalse: [ 
      self at: index put: newObject.
      index := self indexOf: oldObject startingAt: index + 1 ifAbsent: [ 0 ] ]
%

category: '*filesystem-gemstone-kernel'
method: SequenceableCollection
reversed
	"Answer a copy of the receiver with element order reversed."
	"Example: 'frog' reversed"

	| n result src |
	n := self size.
	result := self species new: n.
	src := n + 1.
	1 to: n do: [:i | result at: i put: (self at: (src := src - 1))].
	^ result
%

! Class extensions for 'Stream'

!		Instance methods for 'Stream'

category: '*filesystem-gemstone-kernel'
method: Stream
isBinary
	^false
%

! Class extensions for 'String'

!		Instance methods for 'String'

category: '*Cypress-PackageManagement'
method: String
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	aStream nextPutAll: '"'.
	CypressUrl
		writeWithHttpEscapes: (CypressObject normalizeLineEndingsOf: self)
		on: aStream.
	aStream nextPutAll: '"'
%

! Class extensions for 'Symbol'

!		Instance methods for 'Symbol'

category: '*ast-kernel-core'
method: Symbol
rbStoreOn: aStream
  aStream nextPut: $#.
  super rbStoreOn: aStream
%

! Class extensions for 'SymbolDictionary'

!		Instance methods for 'SymbolDictionary'

category: '*rowan-gemstone-kernel'
method: SymbolDictionary
rowanSymbolDictionaryRegistry

	"answer the RwGsSymbolDictionaryRegistry instance installed in the receiver, otherwise answer nil"

	^ self at: #'RwSymbolDictionaryRegistry' ifAbsent: [  ]
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: SymbolDictionary
_rowanCloneSymbolDictionaryNamed: aSymbol symbolList: symbolList

	"return a new symbol dictionary containing copies of all of the classes in the receiver ... the state of each class should be the same with 
		respect to class intance variables and class variables ... similar to what happens when a new version of a class is created, except the
		copied classes are not in the class history of the original class"

	"it is expected that the receiver is in the <symbolList>"

	| toBeOrdered order clonedSymDict processed aClass clonedClasses |
    "order the list of classes in the receiver in superclass order, so that superclasses are cloned before the subclasses are cloned"
	toBeOrdered := (self values select: [:each | each isBehavior ]) asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[ (aClass := RwGsPatchSet_V2 _anyElementOf: toBeOrdered ifEmpty: [ nil ]) isNil ]
		whileFalse: [ 
			RwGsPatchSet_V2
				_orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed ].
	"create clone and clone all of the classes before compiling methods"
	clonedSymDict := self class new.
	clonedSymDict name: aSymbol.
	clonedClasses := OrderedCollection new.
	[
		symbolList add: clonedSymDict before: self. "install clone after receiver, so that methods will be compiled and reference the cloned classes"
		"clone the body of classes before compiling methods"
		order do: [:oldClass |
			| oldClassName clonedClass hist superclass |
			oldClassName := oldClass name asSymbol.
			hist := oldClass classHistory copy.	"make copy ... leverage the new class version behavior, which preserves a lot of state, without 
																adding the new class to old class' class hitory"
			superclass := symbolList objectNamed: oldClass superclass name. "look up superclass, in case superclass has been cloned"
			clonedClass :=  superclass
				_subclass: oldClassName asString 
				instVarNames: oldClass instVarNames
				format: oldClass format  
				classVars: oldClass classVarNames
				classInstVars: oldClass class instVarNames
				poolDictionaries: #()
				inDictionary: nil
				inClassHistory: hist
				description: nil
				options: oldClass _optionsArrayForDefinition .
			clonedSymDict at: oldClassName put: clonedClass.
			clonedClasses add: {clonedClass. oldClass} ].
			"compile methods in cloned class"
			clonedClasses do: [:ar | | x clonedClass oldClass |
				clonedClass := ar at: 1.
				oldClass := ar at: 2.
				(x := clonedClass _rowanCopyMethodsAndVariablesFrom: oldClass dictionaries: symbolList)
					isEmpty 
						ifFalse: [ self error: 'failed to compile methods in the cloned class ', oldClass name asString printString ] ] ] 
		ensure: [ 
			"do not leave clone in the symbol list"
			symbolList remove: clonedSymDict ifAbsent: [] ].
	^ clonedSymDict
%

! Class extensions for 'TestAsserter'

!		Instance methods for 'TestAsserter'

category: '*filesystem-gemstone-kernel'
method: TestAsserter
assertCollection: actual equals: expected
	"Specialized test method that generates a proper error message for collection"
	^ self
		assert: expected = actual
		description: [ self comparingCollectionBetween: actual and: expected ]
%

category: '*filesystem-gemstone-kernel'
method: TestAsserter
comparingCollectionBetween: left and: right
	| additionalLeft additionalRight sortBlock|
	
	"use a very slow sort block"
	sortBlock := [ :a :b | a asString <= b asString ].
	additionalLeft := (left difference: right) sort: sortBlock.
	additionalRight := (right difference: left) sort: sortBlock. 
	
	^ String streamContents: [:stream |
		stream
			nextPutAll: 'Given Collections do not match. Got '; lf;
			tab; nextPutAll: 'left := '; print: left; nextPut: $.; lf;
			nextPutAll: ' instead of ';
			tab; nextPutAll: ' right :='; print: right; nextPut: $.; lf.
		left size = right size
			ifFalse: [ 
				stream 
					nextPutAll: 'Collection size does not match: left='; 
					print: left size;
					nextPutAll: ' vs. right=';
					print: right size; lf ].
		additionalLeft isEmpty
			ifFalse: [ 
				stream 
					nextPutAll: 'Got ';
					print: additionalLeft size;
					nextPutAll: ' additional element(s) in the left collection: ';
					tab; print: additionalLeft  ].
		additionalRight isEmpty
			ifFalse: [ 
				stream 
					nextPutAll: 'Got ';
					print: additionalRight size;
					nextPutAll: ' additional element(s) in the right collection: ';
					tab; print: additionalRight  ]]
%

! Class extensions for 'UndefinedObject'

!		Instance methods for 'UndefinedObject'

category: '*filesystem-gemstone-kernel'
method: UndefinedObject
isEmptyOrNil
  "Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"

  ^ true
%

category: '*ast-kernel-core'
method: UndefinedObject
rbStoreOn: aStream
  aStream nextPutAll: self asString
%

category: '*rowan-gemstone-kernel'
method: UndefinedObject
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: 'nil'
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: UndefinedObject
subclass: aString 
instVarNames: anArrayOfInstvarNames 
classVars: anArrayOfClassVars 
classInstVars: anArrayOfClassInstVars 
poolDictionaries: anArrayOfPoolDicts 
inDictionary: aDictionary 
newVersionOf: oldClass 
description: aDescription 
constraints: constraintsArray
options: optionsArray

  | descr theClass superClassOffset |
  descr := aDescription.
  oldClass ifNotNil: [ 
     (Object _equivalentSubclass: oldClass
        superCls: self
        name: aString
        newOpts: optionsArray
        newFormat: oldClass format
        newInstVars: anArrayOfInstvarNames
        newClassInstVars: anArrayOfClassInstVars
        newPools: anArrayOfPoolDicts
        newClassVars: anArrayOfClassVars
        inDict: aDictionary
        constraints: constraintsArray isKernel: false ) ifTrue: [
            oldClass _commentOrDescription: aDescription.
            ^oldClass "avoid creation of a new version"
        ].
      descr ifNil: [descr := oldClass commentForFileout]
  ].
  theClass := Object
        subclass: aString
        instVarNames: anArrayOfInstvarNames
        classVars: anArrayOfClassVars
        classInstVars: anArrayOfClassInstVars
        poolDictionaries: anArrayOfPoolDicts
        inDictionary: aDictionary
        newVersionOf: oldClass
        description: descr
		constraints: constraintsArray
        options: optionsArray.
  theClass == oldClass
    ifFalse:
      [superClassOffset := Behavior _ivOffsetOf: #superClass.
      theClass _unsafeAt: superClassOffset put: nil.
      theClass class _unsafeAt: superClassOffset put: Object class superClass].
  ^theClass
%

! Class extensions for 'Utf8'

!		Instance methods for 'Utf8'

category: '*filesystem-gemstone-kernel'
method: Utf8
asByteArray
	^ ByteArray streamContents: [ :stream |
		self do: [ :each |
			stream nextPut: each ] ]
%

! Class extensions for 'Warning'

!		Instance methods for 'Warning'

category: '*gemstone-interactions-kernel'
method: Warning
defaultAction
  "The user should be notified of the occurrence of an exceptional
	occurrence and given an option of continuing or aborting the
	computation. The description of the occurrence should include
	any text specified as the argument of the #signal: message."

  | response |
  response := (GsNotifyInteraction
    prompt:
      self description withoutGemstoneLineEndings , ' Press ''Proceed'' to continue.'
    confirm: 'Proceed'
    cancel: 'Debug'
    abort: 'Cancel') signal.
  response == true
    ifTrue: [ ^ super defaultAction ].
  response == false
    ifTrue: [ self halt: 'Debugging: ' , self description ].
  ^ Processor activeProcess terminate
%

! Class extensions for 'ZnBufferedReadStream'

!		Instance methods for 'ZnBufferedReadStream'

category: '*rowan-components-kernel'
method: ZnBufferedReadStream
buffer

	^ buffer
%

! Class Initialization

run
CypressAbstractRepository initialize.
CypressGemStoneDirectoryUtilities initialize.
CypressPackageManager2 initialize.
FastUUIDGenerator initialize.
RBConfigurableFormatter initialize.
RBPatternScanner initialize.
RBScanner initialize.
Rowan initialize.
RwLoadedThing initialize.
RwModificationFiletreeWriterVisitor initialize.
RwModificationFiletreeWriterVisitorV2 initialize.
true
%
