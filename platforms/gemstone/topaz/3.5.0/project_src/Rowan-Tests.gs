! Class Declarations
! Generated file, do not Edit

doit
(Object
	subclass: 'RwTestProjectLibraryGenerator'
	instVarNames: #( projectsHome projectName projectUrl preserveChangesOnGithub )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-TestsV2';
		comment: '| comment |
RwRowanSample9Test _clearLoadSpecSessionCache.
(RwAbstractV2Test _testRowanProjectsSandbox / ''RowanSample9'') ensureDeleteAll.

comment := ''''.
RwTestProjectLibraryGenerator new
	projectName: ''RowanSample9'';
	projectUrl: ''https://github.com/dalehenrich/RowanSample9'';
	preserveChangesOnGithub: true;
	genSpec_0000: comment;
	genSpec_0001: comment;
	genSpec_0002: comment;
	genSpec_0003: comment;
	genSpec_0004: comment;
	genSpec_0005: comment;
	genSpec_0006: comment;
	genSpec_0007: comment;
	genSpec_0008: comment;
	genSpec_0009: comment;
	genSpec_0010: comment;
	genSpec_0011: comment;
	genSpec_0012: comment;
	genSpec_0013: comment;
	genSpec_0014: comment;
	genSpec_0015: comment;
	yourself';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwTestProjectLibraryIndexCard'
	instVarNames: #( name title specName index derivedFrom comment rowanIssues gemstoneIssues )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-TestsV2';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanLoggingService
	subclass: 'TestLoggingService'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: 'Used for Jadeite testing';
		immediateInvariant.
true.
%

doit
(RwAbstractProjectSetModificationVisitor
	subclass: 'RwSample1TestValidationVisitor'
	instVarNames: #( defaultNoopBlock addedClassBlock addedClassExtensionBlock addedMethodBlock addedMethodExtensionBlock addedPackageBlock addedProjectBlock changedClassBlock changedClassExtensionBlock changedMethodBlock changedMethodExtensionBlock changedPackageBlock changedProjectBlock deletedClassBlock deletedClassExtensionBlock deletedMethodBlock deletedMethodExtensionBlock deletedPackageBlock deletedProjectBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests-35x';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsImage
	subclass: 'RwGsTestImage'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests-GemStone';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'JadeServerTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'NewTonelParserTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-TestsV2';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RowanServicesTest'
	instVarNames: #( defaultProjectDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: 'RowanServicesTest subclasses require RowanSample1 project to be loaded.';
		immediateInvariant.
true.
%

doit
(RowanServicesTest
	subclass: 'RowanAnsweringServiceTest'
	instVarNames: #( service )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanServicesTest
	subclass: 'RowanBrowserServiceTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanServicesTest
	subclass: 'RowanClassServiceTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: 'Created to test inherited tests on client';
		immediateInvariant.
true.
%

doit
(RowanClassServiceTest
	subclass: 'RowanTestClassServiceTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanServicesTest
	subclass: 'RowanDebuggerServiceTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanServicesTest
	subclass: 'RowanDictionaryServiceTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanServicesTest
	subclass: 'RowanMethodServiceTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanServicesTest
	subclass: 'RowanPackageServiceTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanServicesTest
	subclass: 'RowanProjectServiceTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanServicesTest
	subclass: 'RowanQueryServicesTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Services-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RwAbstractTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractTest
	subclass: 'RwAbstractV2Test'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-TestsV2';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractV2Test
	subclass: 'RwResolvedProjectV2Test'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-TestsV2';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractV2Test
	subclass: 'RwRowanSample9Test'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-TestsV2';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractTest
	subclass: 'RwInterfaceTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwInterfaceTest
	subclass: 'RwProjectTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractTest
	subclass: 'RwLoadingTest'
	instVarNames: #(  )
	classVars: #( PoolDictionaryDictionary )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: 'No class-specific documentation for CypLoadingTest, hierarchy is: 
Object
  TestAsserter
    TestCase( testSelector)
      CypLoadingTest
';
		immediateInvariant.
true.
%

doit
(RwAbstractTest
	subclass: 'RwProjectComponentDefinitionsTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractTest
	subclass: 'RwSymbolDictionaryTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractTest
	subclass: 'RwToolTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwToolTest
	subclass: 'RwAbstractComponentDefinitionTest'
	instVarNames: #( repositoryRoot )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractComponentDefinitionTest
	subclass: 'RwComponentDefinitionTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractComponentDefinitionTest
	subclass: 'RwProjectReferenceDefinitionTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwToolTest
	subclass: 'RwBrowserToolTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwAdoptToolApiTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwBrowserToolApiTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwDisownToolApiTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwHybridBrowserToolTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwProjectAuditToolTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: 'keep test cases here';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwProjectDeleteToolTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwProjectReaderWriterTest'
	instVarNames: #( filesystem toDelete projectsToDelete )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectReaderWriterTest
	subclass: 'RwProjectFiletreeTonelReaderWriterTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectFiletreeTonelReaderWriterTest
	subclass: 'RwProjectFiletreeReaderWriterTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectFiletreeTonelReaderWriterTest
	subclass: 'RwProjectTonelReaderWriterTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectReaderWriterTest
	subclass: 'RwProjectTopazWriterTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests-GemStone';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwReconcileToolApiTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwRowanProjectIssuesTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRowanProjectIssuesTest
	subclass: 'RwCloneSymbolDictionaryTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRowanProjectIssuesTest
	subclass: 'RwRowanIssue188Test'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRowanProjectIssuesTest
	subclass: 'RwRowanIssue493Test'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwRowanProjectIssuesTestV2'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-TestsV2';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwBrowserToolTest
	subclass: 'RwUnpackagedBrowserApiTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwToolTest
	subclass: 'RwEditToolTest'
	instVarNames: #( globalBlackList userBlackList sessionBlackList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwToolTest
	subclass: 'RwMoveTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwToolTest
	subclass: 'RwPlatformInstanceTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwToolTest
	subclass: 'RwProjectSetTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwToolTest
	subclass: 'RwProjectToolTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwToolTest
	subclass: 'RwRowanSampleAbstractTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRowanSampleAbstractTest
	subclass: 'RwRowanSample1Test'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests-35x';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRowanSampleAbstractTest
	subclass: 'RwRowanSample2Test'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRowanSampleAbstractTest
	subclass: 'RwRowanSample4Test'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRowanSampleAbstractTest
	subclass: 'RwRowanSample7Test'
	instVarNames: #( repositoryRoot )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractTest
	subclass: 'RwUrlTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RwGemStoneVersionNumberTestCase'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RwProjectConfigurationsTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RwSemanticVersionNumber200TestCase'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: 'The tests in this class were extracted from the examples in Semantic Version Specification ...';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RwSemanticVersionNumberTestCase'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RwSentButNotImplementedTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #()
)
		category: 'Rowan-Tests';
		comment: '';
		immediateInvariant.
true.
%

! Class implementation for 'RwTestProjectLibraryGenerator'

!		Instance methods for 'RwTestProjectLibraryGenerator'

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0000: commitMessage
	"Create an initial project template with no packages -- basically an empty project.
		assume that github project already exists."

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0000'.
	specName := 'spec_' , postfix.
	derivedFrom := 'master'.

	indexCard := self
		_createCard: postfix
		specName: specName
		title: 'Empty project with no packages'
		index: 0
		derivedFrom: derivedFrom
		comment: ''.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0000: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0001: commitMessage
	"Create a bare bones package structure -Core and -Tests, the tests should validate 
		the loaded state of project. Start with spec_0000 and add spec_0001 meat to the bones"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0001'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0000'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'Bare bones package structure -Core and -Tests'
		index: 1
		derivedFrom: derivedFrom
		comment: 'One class per package: RowanSample9-Core and RowanSample9-Tests packages')
		rowanIssues: #( 527);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0001: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0002: commitMessage
	"RowanSample4 - basic project definition"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0002'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0000'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'RowanSample4 basic project definition'
		index: 2
		derivedFrom: derivedFrom
		comment: 'RowanSampe9Class1 has extension methods')
		rowanIssues: #( 254 504);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0002: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0003: commitMessage
	"RowanSample4 - primer project definition"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0003'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0002'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'RowanSample4 primer project definition'
		index: 3
		derivedFrom: derivedFrom
		comment: 'RowanSample9Class1 has instancesInvariant option set')
		rowanIssues: #(254);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0003: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0004: commitMessage
	"Reconcile inconsistencies for storage of package-specific properties. This set of definitions, uses
		three methods sent to a project definition to set the symbol dictionary for packages: as a
		starting point to see which data structures are written to disk."

	"
	projectDefinition
		addPackageNamed: projectName , '-Core1'
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'core'
			gemstoneDefaultSymbolDictionaryForUser: userId -> RwAbstractV2Test _sampleSymbolDictionaryName1;
		addPackageNamed: projectName , '-Core2'
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'core';
		gemstoneSetSymbolDictName: RwAbstractV2Test _sampleSymbolDictionaryName2 forPackageNamed: projectName , '-Core2';
		addPackageNamed: projectName , '-Tests'
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'tests';
		gemstoneSetDefaultSymbolDictNameForUser: userId to: RwAbstractV2Test _sampleSymbolDictionaryName3;
	"

	"https://github.com/GemTalk/Rowan/issues/531"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0004'.
	specName := 'spec_' , postfix.
	derivedFrom := 'master'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'Reconcile inconsistencies for storage of package-specific properties'
		index: 4
		derivedFrom: derivedFrom
		comment: '')
		rowanIssues: #(500 531);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core1'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0004: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage.

	self genSpec_0004_b: commitMessage , '_b'
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0004_b: commitMessage
	"https://github.com/GemTalk/Rowan/issues/532"

	"The method is NOT idempotent with respect to the branches involved. It must be run whenever genSpec_0004 is run.
		Right now it is called from genSpec_0004_b, so explicit top-level call is not necessary."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom branchName |
	postfix := '0004_b'.
	specName := 'spec_' , postfix.
	derivedFrom := 'master'.
	branchName := 'spec_0004'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title:
			'Create inconsistency in component definitions ... duplicate package error expected on load'
		index: 4
		derivedFrom: derivedFrom
		comment: '')
		rowanIssues: #(532);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core3'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor_004_b: specName
		branchName: branchName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0004_b: resolvedProject ].

	self
		_finishCommitAndPush: branchName
		indexCard: indexCard
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0005: commitMessage
	"Two classes, two  packages, plus tests"

	"https://github.com/dalehenrich/Rowan/issues/230"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0005'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0000'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'Two classes, two  packages, plus tests. Primer for Issue 230'
		index: 5
		derivedFrom: derivedFrom
		comment: 'One class per package: RowanSample9-Core1, RowanSample9-Core2 and RowanSample9-Tests packages. Tests ensure that classes in Core1 are in ', RwRowanSample9Test _sampleSymbolDictionaryName2 printString, ' and classes in Core2 are in symbol dictionary ', RwRowanSample9Test _sampleSymbolDictionaryName3 printString, ' and classes in Tests are in symbol dictionary ', RwRowanSample9Test _sampleSymbolDictionaryName1 printString)
		rowanIssues: #( 504);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0005: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0006: commitMessage
	"spec_0002 with different symbol dict mappings for issue #504"

	"https://github.com/dalehenrich/Rowan/issues/504"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0006'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0002'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'spec_0002 with different symbol dict mappings'
		index: 6
		derivedFrom: derivedFrom
		comment:
			'RowanSample9-Core, RowanSample9-Extensions, RowanSample9-GemStone, RowanSample9-GemStone-Tests and RowanSample9-Tests packages. Tests ensure that all of the classes are in the proper symbol dictionary')
		rowanIssues: #(504);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0006: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0007: commitMessage
	"Two classes, two  packages, plus tests"

	"https://github.com/dalehenrich/Rowan/issues/504"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0007'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0005'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'Two classes, two  packages, plus tests. Primer for Issue 230, using ivs instead of instancesInvariant'
		index: 7
		derivedFrom: derivedFrom
		comment: 'One class per package: RowanSample9-Core1, RowanSample9-Core2 and RowanSample9-Tests packages. Tests ensure that classes in Core1 are in ', RwRowanSample9Test _sampleSymbolDictionaryName2 printString, ' and classes in Core2 are in symbol dictionary ', RwRowanSample9Test _sampleSymbolDictionaryName3 printString, ' and classes in Tests are in symbol dictionary ', RwRowanSample9Test _sampleSymbolDictionaryName1 printString)
		rowanIssues: #( 504);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0007: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0008: commitMessage
	"two symbol dicts ... gemstone in one, the rest in another"

	"https://github.com/dalehenrich/Rowan/issues/493"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0008'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0006'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'two symbol dicts ... gemstone in one, the rest in another'
		index: 8
		derivedFrom: derivedFrom
		comment: 'RowanSample9-Core, RowanSample9-Extensions, and RowanSample9-Tests packages in ', RwRowanSample9Test _sampleSymbolDictionaryName1 printString, '. RowanSample9-GemStone and RowanSample9-GemStone-Tests packages in ', RwRowanSample9Test _sampleSymbolDictionaryName2 printString)
		rowanIssues: #( 493);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0008: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0009: commitMessage
	"two symbol dicts ... gemstone in one symbol dict, the rest in the default symbol dict"

	"https://github.com/dalehenrich/Rowan/issues/493"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0009'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0008'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'one symbol dict specified for gemstone, the rest in default (unspecified)'
		index: 9
		derivedFrom: derivedFrom
		comment: 'RowanSample9-Core, RowanSample9-Extensions, and RowanSample9-Tests packages in default. RowanSample9-GemStone and RowanSample9-GemStone-Tests packages in ', RwRowanSample9Test _sampleSymbolDictionaryName2 printString)
		rowanIssues: #( 493);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0009: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0010: commitMessage
	"two symbol dicts ... gemstone in one symbol dict, the rest in the default symbol dict --- default symbol changed from 0009"

	"https://github.com/dalehenrich/Rowan/issues/493"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0010'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0009'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'one symbol dict specified for gemstone, the rest in default --- default sym dict changed from 0009'
		index: 10
		derivedFrom: derivedFrom
		comment: 'RowanSample9-Core, RowanSample9-Extensions, and RowanSample9-Tests packages in default. RowanSample9-GemStone and RowanSample9-GemStone-Tests packages in ', RwRowanSample9Test _sampleSymbolDictionaryName2 printString)
		rowanIssues: #( 493);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0010: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0011: commitMessage
	"A single class with an extension method in a separate package. All packages loaded into a single symbol dict. Test methods validate classes and symbol dictionary mapping."

	"https://github.com/dalehenrich/Rowan/issues/495"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0011'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0001'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'A single class with an extension method in a separate package. All packages loaded into a single symbol dict. Test methods validate classes and symbol dictionary mapping.'
		index: 11
		derivedFrom: derivedFrom
		comment: 'RowanSample9-Core, RowanSample9-Extensions, and RowanSample9-Tests packages in default symbol dictionary.')
		rowanIssues: #( 495);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0011: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0012: commitMessage
	"Starting with spec_0011, move extension method to a new extension package; move class package to a 
		different symbol dict; move new extension package to a third symbol dictionary. This is an illegal combination
		(extension method and class in different symbol dictionaries) and does cause an error."

	"https://github.com/dalehenrich/Rowan/issues/495"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0012'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0011'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'Starting with spec_0011, move extension method to a new extension package; move class package to a 
		different symbol dict; move new extension package to a third symbol dictionary. This is an illegal combination
		(extension method and class in different symbol dictionaries) and does cause an error.'
		index: 12
		derivedFrom: derivedFrom
		comment: 'RowanSample9-Core in one symbol dict, RowanSample9-Extensions1 in another symbol dict, and 
		RowanSample9-Tests packages in default symbol dictionary.')
		rowanIssues: #( 495);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0012: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0013: commitMessage
	"Starting with spec_0011, move extension method to a new extension package; move class package to a 
		different symbol dict; move new extension package to the first symbol dictionary. This is an illegal combination
		(extension method and class in different symbol dictionaries) and does cause an error."

	"https://github.com/dalehenrich/Rowan/issues/495"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0013'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0011'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'Starting with spec_0011, move extension method to a new extension package; move class package to a 
		different symbol dict; move new extension package to the first symbol dictionary. This is an illegal combination
		(extension method and class in different symbol dictionaries) and does cause an error.'
		index: 13
		derivedFrom: derivedFrom
		comment: 'Swap symbol dicts for RowanSample9-Core and RowanSample9-Extensions1. RowanSample9-Tests
		packages in default symbol dictionary.')
		rowanIssues: #( 495);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0013: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0014: commitMessage
	"Starting with spec_0011, move extension method to a new extension package; move new extension package 
		to the classes symbol dictionary. This is a legal combination (extension method and class in same symbol
		dictionary) the V2 classes are handling the symbol dictionary lookup properly, so this combo validates that
		the bug (#493) is fixed."

	"https://github.com/dalehenrich/Rowan/issues/493"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0014'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0011'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'Starting with spec_0011, move extension method to a new extension package; move new extension package 
		to the classes symbol dictionary. This is a legal combination (extension method and class in same symbol
		dictionary) the V2 classes are handling the symbol dictionary lookup properly, so this combo validates that
		the bug (#493) is fixed.'
		index: 14
		derivedFrom: derivedFrom
		comment: 'RowanSample9-Core and RowanSample9-Extensions1 in same symbol dictionary, but extension method moves
		to new package. RowanSample9-Tests package in default symbol dictionary.')
		rowanIssues: #( 493);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0014: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'generators'
method: RwTestProjectLibraryGenerator
genSpec_0015: commitMessage
	"Starting with spec_0014, remove the old (now empty) package from the project as triggering a package move
	as opposed to a class move seems to trigger the bug, which implies that move package is not quite right. 

	It seems that assigning a new symbol dictionary to the OLD package ... the package that the class is moved FROM
	may trigger a bogus package move.

	The test RwRowanProjectIssuesTestV2 >> testIssue495_move_class_and_extension_method_to_new_symbol_dict
	showed that #495 wasn't fixed by the V2 implementation."

	"https://github.com/dalehenrich/Rowan/issues/495"

	"The method is idempotent with respect to the branches involved, UNLESS something
		has explicitly changed within the model or the disk format of artefacts."

	| indexCard loadSpecification resolvedRepository specName postfix derivedFrom |
	postfix := '0015'.
	specName := 'spec_' , postfix.
	derivedFrom := 'spec_0014'.

	indexCard := (self
		_createCard: postfix
		specName: specName
		title: 'Starting with spec_0014, remove the old (now empty) package from the project as triggering a package move
	as opposed to a class move seems to trigger the bug, which implies that move package is not quite right. 

	It seems that assigning a new symbol dictionary to the OLD package ... the package that the class is moved FROM
	may trigger a bogus package move.

	The test RwRowanProjectIssuesTestV2 >> testIssue495_move_class_and_extension_method_to_new_symbol_dict
	showed that #493 wasn''t fixed by the V2 implementation.'
		index: 15
		derivedFrom: derivedFrom
		comment: 'RowanSample9-Core and RowanSample9-Extensions1 in same symbol dictionary, but extension method moves
		to RowanSample9-Extensions1. RowanSample9-Tests package in default symbol dictionary. Move the old (empty) package
		to a different symbol dictionary.')
		rowanIssues: #( 495);
		yourself.
	loadSpecification := (self _createLoadSpecification: self projectName)
		specName: specName;
		revision: derivedFrom;
		gitUrl: self projectUrl;
		componentNames: {'Core'};
		groupNames:
				{'core'.
					'tests'};
		yourself.

	resolvedRepository := self
		_genSpecFor: specName
		loadSpecification: loadSpecification
		addDefinitions: [ :resolvedProject | self _addDefinitionsFor_0015: resolvedProject ].

	self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: (derivedFrom copyReplaceAll: 'spec' with: 'index')
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'accessing'
method: RwTestProjectLibraryGenerator
preserveChangesOnGithub
	"if true, modifications to git repository will be pushed to remote"

	^ preserveChangesOnGithub ifNil: [ preserveChangesOnGithub := true ]
%

category: 'accessing'
method: RwTestProjectLibraryGenerator
preserveChangesOnGithub: aBool
	"if true, modifications to git repository will be pushed to remote"

	preserveChangesOnGithub := aBool
%

category: 'accessing'
method: RwTestProjectLibraryGenerator
projectName
	^projectName
%

category: 'accessing'
method: RwTestProjectLibraryGenerator
projectName: object
	projectName := object
%

category: 'accessing'
method: RwTestProjectLibraryGenerator
projectsHome
	^ projectsHome ifNil: [ self _testRowanProjectsSandbox ]
%

category: 'accessing'
method: RwTestProjectLibraryGenerator
projectsHome: aString
	projectsHome := aString asFileReference
%

category: 'accessing'
method: RwTestProjectLibraryGenerator
projectUrl
	^projectUrl
%

category: 'accessing'
method: RwTestProjectLibraryGenerator
projectUrl: object
	projectUrl := object
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0000: resolvedProject
	resolvedProject
		comment: 'spec_0000 definitions';
		addComponentNamed: 'Core'
			definedGroupNames:
				(Dictionary new
						add: 'core' -> {};
						add: 'tests' -> {'core'};
						yourself)
			comment: 'Primary component used for loading the core classes.';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0001: resolvedProject
	| className packageName |
	resolvedProject
		addPackagesNamed: {(projectName , '-Core')}
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'core';
		addPackageNamed: projectName , '-Tests'
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'tests';
		yourself.
	packageName := projectName , '-Core'.
	className := projectName , 'Class1'.
	((resolvedProject packageNamed: packageName)
		addClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		category: packageName
		comment: 'I am an example class')
		addInstanceMethod: 'foo ^1' protocol: 'accessing';
		yourself.
	packageName := projectName , '-Tests'.
	((resolvedProject packageNamed: packageName)
		addClassNamed: projectName , 'TestCase'
		super: 'TestCase'
		category: packageName
		comment: 'I test the example class')
		addInstanceMethod: 'test  self assert: ' , className , ' new foo = 1'
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0002: resolvedProject
	"RowanSample4 basic package and class structure"

	| packageName1 packageName2 packageName3 packageName4 packageName5 className gemstoneClassName |
	packageName1 := projectName , '-' , 'Core'.
	packageName2 := projectName , '-' , 'Extensions'.
	packageName3 := projectName , '-' , 'GemStone'.
	packageName4 := projectName , '-' , 'GemStone-Tests'.
	packageName5 := projectName , '-' , 'Tests'.
	resolvedProject
		addPackagesNamed:
				{packageName1.
				packageName2.
				packageName3}
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'core';
		addPackagesNamed:
				{packageName4.
				packageName5}
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'tests';
		yourself.
	className := projectName , 'Class1'.
	((resolvedProject packageNamed: packageName1)
		addClassNamed: className
		super: 'Object'
		instvars: #()
		category: packageName1
		comment: 'I am an example class')
		addInstanceMethod: 'foo ^1' protocol: 'accessing';
		yourself.
	((resolvedProject packageNamed: packageName2)
		addClassExtensionNamed: className)
		addClassMethod: 'bar ^''bar''' protocol: '*' , packageName2 asLowercase;
		yourself.
	gemstoneClassName := projectName , 'IdentityKeyValueDictionary'.
	((resolvedProject packageNamed: packageName3)
		addClassNamed: gemstoneClassName
		super: 'IdentityKeyValueDictionary'
		instvars: #()
		category: packageName3
		comment: 'I am an example class')
		addInstanceMethod: 'foo ^1' protocol: 'accessing';
		addClassMethod: 'bar ^''bar''' protocol: 'accessing';
		yourself.
	((resolvedProject packageNamed: packageName4)
		addClassNamed: projectName , 'GemStoneTestCase'
		super: 'TestCase'
		category: packageName4
		comment: 'I test the GemStone class')
		addInstanceMethod: 'test1  self assert: ' , gemstoneClassName , ' new foo = 1'
			protocol: 'tests';
		addInstanceMethod: 'test2  self assert: ' , gemstoneClassName , ' bar = ''bar'''
			protocol: 'tests';
		yourself.
	((resolvedProject packageNamed: packageName5)
		addClassNamed: projectName , 'TestCase'
		super: 'TestCase'
		category: packageName5
		comment: 'I test the Core class')
		addInstanceMethod: 'test1  self assert: ' , className , ' new foo = 1'
			protocol: 'tests';
		addInstanceMethod: 'test2  self assert: ' , className , ' bar = ''bar'''
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0003: resolvedProject
	"primer for https://github.com/dalehenrich/Rowan/issues/230"

	| packageName1  className  |
	packageName1 := projectName , '-' , 'Core'.
	className := projectName , 'Class1'.
	((resolvedProject packageNamed: packageName1)
		classDefinitionNamed: className)
		gs_options: #(#'instancesInvariant');
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0004: resolvedProject
	| className packageName userId |
	userId := resolvedProject _gemstoneAllUsersName.
	(resolvedProject
		addComponentNamed: 'Core1'
		definedGroupNames:
			(Dictionary new
				add: 'core' -> {};
				add: 'tests' -> {'core'};
				yourself)
		comment: 'contains ' , projectName , '-Core1 package')
		componentNames: #('Core2');
		yourself.
	(resolvedProject
		addComponentNamed: 'Core2'
		definedGroupNames:
			(Dictionary new
				add: 'core' -> {};
				add: 'tests' -> {'core'};
				yourself)
		comment: 'contains ' , projectName , '-Core2 package')
		componentNames: #('Core1');
		yourself.
	resolvedProject
		addPackageNamed: projectName , '-Core1'
			toComponentNamed: 'Core1'
			withConditions: {'common'}
			andGroupName: 'core'
			gemstoneDefaultSymbolDictionaryForUser:
				userId -> RwAbstractV2Test _sampleSymbolDictionaryName2;
		addPackageNamed: projectName , '-Core2'
			toComponentNamed: 'Core2'
			withConditions: {'common'}
			andGroupName: 'core';
		gemstoneSetSymbolDictName: RwAbstractV2Test _sampleSymbolDictionaryName3
			forPackageNamed: projectName , '-Core2';
		addPackageNamed: projectName , '-Tests'
			toComponentNamed: 'Core1'
			withConditions: {'common'}
			andGroupName: 'tests';
		gemstoneSetDefaultSymbolDictNameForUser: userId
			to: RwAbstractV2Test _sampleSymbolDictionaryName1;
		yourself.
	self _addPackageCore1DefinitionsFor_0004: resolvedProject.
	packageName := projectName , '-Core2'.
	className := projectName , 'Class2'.
	((resolvedProject packageNamed: packageName)
		addClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		category: packageName
		comment: 'I am an example class')
		addInstanceMethod: 'foo ^1' protocol: 'accessing';
		yourself.
	packageName := projectName , '-Tests'.
	((resolvedProject packageNamed: packageName)
		addClassNamed: projectName , 'TestCase'
		super: 'TestCase'
		category: packageName
		comment: 'I test the example class')
		addInstanceMethod: 'test  self assert: ' , className , ' new foo = 1'
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0004_b: resolvedProject
	| userId |
	userId := 'SystemUser'.
	(resolvedProject
		addComponentNamed: 'Core3'
		definedGroupNames:
			(Dictionary new
				add: 'core' -> {};
				add: 'tests' -> {'core'};
				yourself)
		comment: 'contains ' , projectName , '-Core1 package')
		componentNames: #('Core1');
		yourself.
	resolvedProject
		addPackageNamed: projectName , '-Core1'
			toComponentNamed: 'Core3'
			withConditions: {'common'}
			andGroupName: 'core';
		yourself.
	^ self _addPackageCore1DefinitionsFor_0004: resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0005: resolvedProject

	| packageName1 packageName2 packageName3  className1 className2 |
	packageName1 := projectName , '-' , 'Core1'.
	packageName2 := projectName , '-' , 'Core2'.
	packageName3 := projectName , '-' , 'Tests'.
	className1 := projectName , 'Class1'.
	className2 := projectName , 'IdentityKeyValueDictionary'.

	resolvedProject
		addPackagesNamed:
				{packageName1.
				packageName2}
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'core';
		addPackagesNamed:
				{packageName3}
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'tests';
		yourself.

	resolvedProject
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: packageName1;
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName3 
			forPackageNamed: packageName2;
		yourself.

	((resolvedProject packageNamed: packageName1)
		addClassNamed: className1
		super: 'Object'
		instvars: #()
		category: packageName1
		comment: 'I am an example class')
		addInstanceMethod: 'foo ^1' protocol: 'accessing';
		addClassMethod: 'bar ^''bar''' protocol: 'accessing';
		gs_options: #(#'instancesInvariant');
		yourself.
	((resolvedProject packageNamed: packageName2)
		addClassNamed: className2
		super: 'IdentityKeyValueDictionary'
		instvars: #()
		category: packageName2
		comment: 'I am an example class')
		addInstanceMethod: 'foo ^1' protocol: 'accessing';
		addClassMethod: 'bar ^''bar''' protocol: 'accessing';
		yourself.
	((resolvedProject packageNamed: packageName3)
		addClassNamed: projectName , 'TestCase'
		super: 'TestCase'
		category: packageName3
		comment: 'I test the Core class')
		addInstanceMethod: 'test1  self assert: ' , className1 , ' new foo = 1'
			protocol: 'tests';
		addInstanceMethod: 'test2  self assert: ' , className1 , ' bar = ''bar'''
			protocol: 'tests';
		addInstanceMethod: 'test3  self assert: ' , className2 , ' new foo = 1'
			protocol: 'tests';
		addInstanceMethod: 'test4  self assert: ' , className2 , ' bar = ''bar'''
			protocol: 'tests';
		addInstanceMethod: 'testSymbolDicts
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName2, ''') includesKey: ''', className1 , ''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName3, ''') includesKey: ''', className2 , ''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName1, ''') includesKey: ''', projectName , 'TestCase'' asSymbol).
'
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0006: resolvedProject

	| className1 className2 |
	className1 := projectName , 'Class1'.
	className2 := projectName , 'IdentityKeyValueDictionary'.

	resolvedProject
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: projectName , '-' , 'Core';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: projectName , '-' , 'Extensions';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName3 
			forPackageNamed: projectName , '-' , 'GemStone';
		yourself.

	((resolvedProject packageNamed: projectName , '-' , 'Tests')
		classDefinitionNamed: projectName , 'TestCase')
		addInstanceMethod: 'testSymbolDicts
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName2, ''') includesKey: ''', className1 , ''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName3, ''') includesKey: ''', className2 , ''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName1, ''') includesKey: ''', projectName , 'TestCase'' asSymbol).
'
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0007: resolvedProject
	| packageName1 className1 |
	packageName1 := projectName , '-' , 'Core1'.
	className1 := projectName , 'Class1'.

	((resolvedProject packageNamed: packageName1) classDefinitionNamed: className1)
		instVarNames: #('iv1');
		gs_options: #();
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0008: resolvedProject

	| className1 className2 |
	className1 := projectName , 'Class1'.
	className2 := projectName , 'IdentityKeyValueDictionary'.

	resolvedProject
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName3 
			forPackageNamed: projectName , '-' , 'Core';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName3
			forPackageNamed: projectName , '-' , 'Extensions';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: projectName , '-' , 'GemStone';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: projectName , '-' , 'GemStone-Tests';
		yourself.

	((resolvedProject packageNamed: projectName , '-' , 'Tests')
		classDefinitionNamed: projectName , 'TestCase')
		updateInstanceMethod: 'testSymbolDicts
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName3, ''') includesKey: ''', className1 , ''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName2, ''') includesKey: ''', className2 , ''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName1, ''') includesKey: ''', projectName , 'TestCase'' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName2, ''') includesKey: ''', projectName , 'GemStoneTestCase'' asSymbol).
'
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0009: resolvedProject

	| className1 className2 |
	className1 := projectName , 'Class1'.
	className2 := projectName , 'IdentityKeyValueDictionary'.

	resolvedProject
		gemstoneSetSymbolDictName: nil 
			forPackageNamed: projectName , '-' , 'Core';
		gemstoneSetSymbolDictName: nil 
			forPackageNamed: projectName , '-' , 'Extensions';
		gemstoneSetSymbolDictName: nil 
			forPackageNamed: projectName , '-' , 'Tests';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: projectName , '-' , 'GemStone';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: projectName , '-' , 'GemStone-Tests';
		yourself.

	((resolvedProject packageNamed: projectName , '-' , 'Tests')
		classDefinitionNamed: projectName , 'TestCase')
		updateInstanceMethod: 'testSymbolDicts
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName1, ''') includesKey: ''', className1 , ''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName2, ''') includesKey: ''', className2 , ''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName1, ''') includesKey: ''', projectName , 'TestCase'' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName2, ''') includesKey: ''', projectName , 'GemStoneTestCase'' asSymbol).
'
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0010: resolvedProject
	| className1 className2 |
	className1 := projectName , 'Class1'.
	className2 := projectName , 'IdentityKeyValueDictionary'.

	resolvedProject
		gemstoneSetDefaultSymbolDictNameTo:
			RwRowanSample9Test _sampleSymbolDictionaryName4.

	((resolvedProject packageNamed: projectName , '-' , 'Tests')
		classDefinitionNamed: projectName , 'TestCase')
		updateInstanceMethod:
				'testSymbolDicts
	self assert: ((Rowan image symbolDictNamed: '''
						, RwRowanSample9Test _sampleSymbolDictionaryName4 , ''') includesKey: '''
						, className1
						,
							''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: '''
						, RwRowanSample9Test _sampleSymbolDictionaryName2 , ''') includesKey: '''
						, className2
						,
							''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: '''
						, RwRowanSample9Test _sampleSymbolDictionaryName4 , ''') includesKey: '''
						, projectName
						,
							'TestCase'' asSymbol).
	self assert: ((Rowan image symbolDictNamed: '''
						, RwRowanSample9Test _sampleSymbolDictionaryName2 , ''') includesKey: '''
						, projectName
						,
							'GemStoneTestCase'' asSymbol).
'
			protocol: 'tests';
		yourself.

	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0011: resolvedProject
	"Add an extension package for a method in class1 ... load everything into a single symbol dict"

	"https://github.com/GemTalk/Rowan/issues/495"

	| packageName1 packageName2 packageName3 className1 className2  |
	packageName1 := projectName , '-' , 'Core'.
	packageName2 := projectName , '-' , 'Extensions'.
	packageName3 := projectName , '-' , 'Tests'.
	className1 := projectName , 'Class1'.
	className2 := projectName , 'TestCase'.

	resolvedProject
		addPackagesNamed:
				{
				packageName2.
				}
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'core';
		yourself.
	((resolvedProject packageNamed: packageName2)
		addClassExtensionNamed: className1)
		addClassMethod: 'bar ^''bar''' protocol: '*' , packageName2 asLowercase;
		yourself.
	((resolvedProject packageNamed: packageName3)
		classDefinitionNamed:className2)
		addInstanceMethod: 'test2  self assert: ' , className1 , ' bar = ''bar'''
			protocol: 'tests';
		addInstanceMethod: 'testSymbolDicts
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName1, ''') includesKey: ''', className1 , ''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: ''' , RwRowanSample9Test _sampleSymbolDictionaryName1, ''') includesKey: ''', className2 , ''' asSymbol).
'
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0012: resolvedProject
	"Starting with spec_0011, move extension method to a new extension package; move class package to a 
		different symbol dict; move new extension package to a third symbol dictionary. This is an illegal combination
		(extension method and class in different symbol dictionaries) and does cause an error."

	"https://github.com/GemTalk/Rowan/issues/495"

	| packageName1 packageName2 packageName3 packageName4 className1 className2 |
	packageName1 := projectName , '-' , 'Core'.
	packageName2 := projectName , '-' , 'Extensions'.
	packageName3 := projectName , '-' , 'Tests'.
	packageName4 := projectName , '-' , 'Extensions1'.
	className1 := projectName , 'Class1'.
	className2 := projectName , 'TestCase'.

	resolvedProject
		addPackagesNamed: {packageName4}
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'core';
		yourself.

	resolvedProject
		gemstoneSetSymbolDictName:  RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: packageName1;
		gemstoneSetSymbolDictName:  RwRowanSample9Test _sampleSymbolDictionaryName3 
			forPackageNamed: packageName4;
		yourself.

	((resolvedProject packageNamed: packageName2)
		classExtensionDefinitionNamed: className1)
		removeClassMethod: #'bar';
		yourself.
	((resolvedProject packageNamed: packageName4)
		addClassExtensionNamed: className1)
		addClassMethod: 'bar ^''bar''' protocol: '*' , packageName4 asLowercase;
		yourself.
	((resolvedProject packageNamed: packageName3) classDefinitionNamed: className2)
		updateInstanceMethod:
				'testSymbolDicts
	self assert: ((Rowan image symbolDictNamed: '''
						, RwRowanSample9Test _sampleSymbolDictionaryName2 , ''') includesKey: '''
						, className1
						,
							''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: '''
						, RwRowanSample9Test _sampleSymbolDictionaryName1 , ''') includesKey: '''
						, className2
						,
							''' asSymbol).
'
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0013: resolvedProject
	"Starting with spec_0011, move extension method to a new extension package; move class package to a 
		different symbol dict; move new extension package to the first symbol dictionary. This is an illegal combination
		(extension method and class in different symbol dictionaries) and does cause an error."

	"https://github.com/GemTalk/Rowan/issues/495"

	| packageName1 packageName2 packageName3 packageName4 className1 className2 |
	packageName1 := projectName , '-' , 'Core'.
	packageName2 := projectName , '-' , 'Extensions'.
	packageName3 := projectName , '-' , 'Tests'.
	packageName4 := projectName , '-' , 'Extensions1'.
	className1 := projectName , 'Class1'.
	className2 := projectName , 'TestCase'.

	resolvedProject
		addPackagesNamed: {packageName4}
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'core';
		yourself.

	resolvedProject
		gemstoneSetSymbolDictName:  RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: packageName1;
		gemstoneSetSymbolDictName:  RwRowanSample9Test _sampleSymbolDictionaryName1 
			forPackageNamed: packageName4;
		yourself.

	((resolvedProject packageNamed: packageName2)
		classExtensionDefinitionNamed: className1)
		removeClassMethod: #'bar';
		yourself.
	((resolvedProject packageNamed: packageName4)
		addClassExtensionNamed: className1)
		addClassMethod: 'bar ^''bar''' protocol: '*' , packageName4 asLowercase;
		yourself.
	((resolvedProject packageNamed: packageName3) classDefinitionNamed: className2)
		updateInstanceMethod:
				'testSymbolDicts
	self assert: ((Rowan image symbolDictNamed: '''
						, RwRowanSample9Test _sampleSymbolDictionaryName2 , ''') includesKey: '''
						, className1
						,
							''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: '''
						, RwRowanSample9Test _sampleSymbolDictionaryName1 , ''') includesKey: '''
						, className2
						,
							''' asSymbol).
'
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0014: resolvedProject
	"Starting with spec_0011, move extension method to a new extension package; move new extension package 
		to the classes symbol dictionary. This is an legal combination (extension method and class in same symbol
		dictionary) and should cause an error, but currently we get an audit error."

	"https://github.com/GemTalk/Rowan/issues/495"

	| packageName1 packageName2 packageName3 packageName4 className1 className2 |
	packageName1 := projectName , '-' , 'Core'.
	packageName2 := projectName , '-' , 'Extensions'.
	packageName3 := projectName , '-' , 'Tests'.
	packageName4 := projectName , '-' , 'Extensions1'.
	className1 := projectName , 'Class1'.
	className2 := projectName , 'TestCase'.

	resolvedProject
		addPackagesNamed: {packageName4}
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'core';
		yourself.

	resolvedProject
		gemstoneSetSymbolDictName:  RwRowanSample9Test _sampleSymbolDictionaryName1 
			forPackageNamed: packageName1;
		gemstoneSetSymbolDictName:  RwRowanSample9Test _sampleSymbolDictionaryName1 
			forPackageNamed: packageName4;
		yourself.

	((resolvedProject packageNamed: packageName2)
		classExtensionDefinitionNamed: className1)
		removeClassMethod: #'bar';
		yourself.
	((resolvedProject packageNamed: packageName4)
		addClassExtensionNamed: className1)
		addClassMethod: 'bar ^''bar''' protocol: '*' , packageName4 asLowercase;
		yourself.
	((resolvedProject packageNamed: packageName3) classDefinitionNamed: className2)
		updateInstanceMethod:
				'testSymbolDicts
	self assert: ((Rowan image symbolDictNamed: '''
						, RwRowanSample9Test _sampleSymbolDictionaryName1 , ''') includesKey: '''
						, className1
						,
							''' asSymbol).
	self assert: ((Rowan image symbolDictNamed: '''
						, RwRowanSample9Test _sampleSymbolDictionaryName1 , ''') includesKey: '''
						, className2
						,
							''' asSymbol).
'
			protocol: 'tests';
		yourself.
	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addDefinitionsFor_0015: resolvedProject
	"Starting with spec_0014, remove the old (now empty) package from the project as triggering a package move
	as opposed to a class move seems to trigger the bug, which implies that move package is not quite right. 

	It seems that assigning a new symbol dictionary to the OLD package ... the package that the class is moved FROM
	may trigger a bogus package move.

	The test RwRowanProjectIssuesTestV2 >> testIssue495_move_class_and_extension_method_to_new_symbol_dict
	showed that #495 wasn't fixed by the V2 implementation."

	"https://github.com/GemTalk/Rowan/issues/495"

	| packageName2 |
	packageName2 := projectName , '-' , 'Extensions'.

	resolvedProject
		gemstoneSetSymbolDictName:  RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: packageName2;
		yourself.

	^ resolvedProject
%

category: 'private'
method: RwTestProjectLibraryGenerator
_addPackageCore1DefinitionsFor_0004: projectDefinition
	| className packageName |
	packageName := projectName , '-Core1'.
	className := projectName , 'Class1'.
	((projectDefinition packageNamed: packageName)
		addClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		category: packageName
		comment: 'I am an example class')
		addInstanceMethod: 'foo ^1' protocol: 'accessing';
		yourself.
	^ projectDefinition
%

category: 'private'
method: RwTestProjectLibraryGenerator
_createCard: postfix specName: specName title: title index: index derivedFrom: parentbranch comment: comment
	^ RwTestProjectLibraryIndexCard new
		name: 'index_' , postfix;
		title: title;
		specName: specName;
		index: index;
		derivedFrom: parentbranch;
		comment: comment;
		rowanIssues: {};
		gemstoneIssues: {};
		yourself
%

category: 'private'
method: RwTestProjectLibraryGenerator
_createLoadSpecification: aString
	^ RwLoadSpecificationV2 new
		projectName: aString;
		projectsHome: self projectsHome;
		gemstoneSetDefaultSymbolDictNameTo: self _sampleSymbolDictionaryName1;
		yourself
%

category: 'private'
method: RwTestProjectLibraryGenerator
_doCommitAndPush: commitMessage resolvedRepository: resolvedRepository branchName: branchName
	| somethingToCommit |
	somethingToCommit := true.
	[ resolvedRepository commit: commitMessage ]
		on: GsInteractionRequest
		do: [ :ex | 
			ex interaction message = 'Nothing to commit'
				ifFalse: [ ex pass ].
			somethingToCommit := false.
			ex response: nil ].
	(somethingToCommit and: [ self preserveChangesOnGithub ])
		ifTrue: [ 
			"only push if we really want to preserve the changes during this run and something has changed"
			resolvedRepository push: resolvedRepository remote branch: branchName ]
%

category: 'private'
method: RwTestProjectLibraryGenerator
_finishCommitAndPush: specName indexCard: indexCard derivedFrom: derivedFrom  resolvedRepository: resolvedRepository commitMessage: commitMessage
	| derivedIndexCardFile |
	derivedFrom
		ifNotNil: [ 
			derivedIndexCardFile := resolvedRepository repositoryRoot / derivedFrom , 'ston'.
			derivedIndexCardFile exists
				ifTrue: [ derivedIndexCardFile delete ] ].
	indexCard exportTo: resolvedRepository repositoryRoot.

	self
		_doCommitAndPush: commitMessage
		resolvedRepository: resolvedRepository
		branchName: specName.

	resolvedRepository checkout: 'master'.	"write the index card and spec on the master branch"
	resolvedRepository pull: resolvedRepository remote branch: 'master'.

	(resolvedRepository repositoryRoot / 'indexCards') ensureCreateDirectory.
	indexCard exportTo: resolvedRepository repositoryRoot / 'indexCards'.
	(resolvedRepository repositoryRoot / 'specs') ensureCreateDirectory.
	resolvedRepository _loadSpecification exportTo: resolvedRepository repositoryRoot / 'specs'.

	self
		_doCommitAndPush: commitMessage
		resolvedRepository: resolvedRepository
		branchName: 'master'
%

category: 'private'
method: RwTestProjectLibraryGenerator
_finishCommitAndPush: specName indexCard: indexCard  resolvedRepository: resolvedRepository commitMessage: commitMessage
	^ self
		_finishCommitAndPush: specName
		indexCard: indexCard
		derivedFrom: nil
		resolvedRepository: resolvedRepository
		commitMessage: commitMessage
%

category: 'private'
method: RwTestProjectLibraryGenerator
_genSpecFor: specName loadSpecification: loadSpecification addDefinitions: addDefinitionsBlock
	"Coming in the load spec revision is pointing at the desired starting 
		point --- the structure to _start_ with. Since we don't know whether the 
		repository has been cloned or not, we do a resolve, which will ensure
		that the repository is on the revision specifiied in the incoming load spec.
	Once we've resolved and read, we reset the revision of the load spec
		to point to the branch we want to write to. We wipe out the project
		roots, so we have a clean sarting point and then export the project
		definition and load spec."

	| resolvedRepository resolvedProject |
	resolvedProject := loadSpecification resolveStrict.

	resolvedRepository := resolvedProject repository.
	(resolvedRepository branches includes: specName)
		ifTrue: [ 
			"branch exists, so we'll check it out and make the necessary mods"
			resolvedRepository checkout: specName.
			resolvedRepository pull: resolvedRepository remote branch: specName ]
		ifFalse: [ 
			"create the branch"
			resolvedRepository createBranch: specName ].

	resolvedProject revision: specName.	"update the revision to match the current branch, since we want the revision set correctly when exported"
	addDefinitionsBlock value: resolvedProject.

	resolvedProject projectRoots
		do: [ :rootDir | 
			"eliminate the rowan directory structure, so it can be created afresh ... if it already exists"
			rootDir ensureDeleteAll ].

	resolvedProject 
		export;	"write the rowan directory structure"
		exportLoadSpecification.

	^ resolvedRepository
%

category: 'private'
method: RwTestProjectLibraryGenerator
_genSpecFor_004_b: specName branchName: branchName loadSpecification: loadSpecification addDefinitions: addDefinitionsBlock
	"Create a second set of specs/components in an existing branch"

	| resolvedRepository resolvedProject |
	resolvedProject := loadSpecification resolveStrict.

	resolvedRepository := resolvedProject repository.
	(resolvedRepository branches includes: branchName)
		ifTrue: [ 
			"branch exists, so we'll check it out and make the necessary mods"
			resolvedRepository checkout: branchName.
			resolvedRepository pull: resolvedRepository remote branch: branchName ]
		ifFalse: [ self error: 'Expected branch ' , branchName printString , ' to already exist' ].

	resolvedProject revision: branchName.	"update the revision to match the current branch, since we want the revision set correctly when exported"
	addDefinitionsBlock value: resolvedProject.

	resolvedProject
		exportComponents;
		exportLoadSpecification.	"write the component and load spec directory structure"

	^ resolvedRepository
%

category: 'private'
method: RwTestProjectLibraryGenerator
_sampleSymbolDictionaryName1
	^ RwAbstractV2Test _sampleSymbolDictionaryName1
%

category: 'private'
method: RwTestProjectLibraryGenerator
_testRowanProjectsSandbox
	^ RwAbstractV2Test _testRowanProjectsSandbox
%

! Class implementation for 'RwTestProjectLibraryIndexCard'

!		Instance methods for 'RwTestProjectLibraryIndexCard'

category: 'accessing'
method: RwTestProjectLibraryIndexCard
comment
	^comment
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
comment: object
	comment := object
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
derivedFrom
	^derivedFrom
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
derivedFrom: object
	derivedFrom := object
%

category: 'export'
method: RwTestProjectLibraryIndexCard
exportTo: directoryReference
	self exportTo: directoryReference as: self name , '.ston'
%

category: 'export'
method: RwTestProjectLibraryIndexCard
exportTo: directoryReference as: fileName
	directoryReference / fileName
		writeStreamDo: [ :fileStream | STON put: self onStreamPretty: fileStream ]
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
gemstoneIssues
	^gemstoneIssues
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
gemstoneIssues: object
	gemstoneIssues := object
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
index
	^index
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
index: object
	index := object
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
name
	^name
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
name: object
	name := object
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
rowanIssues
	^rowanIssues
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
rowanIssues: object
	rowanIssues := object
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
specName
	^specName
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
specName: object
	specName := object
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
title
	^title
%

category: 'accessing'
method: RwTestProjectLibraryIndexCard
title: object
	title := object
%

! Class implementation for 'RwSample1TestValidationVisitor'

!		Instance methods for 'RwSample1TestValidationVisitor'

category: 'actions'
method: RwSample1TestValidationVisitor
addedClass: aClassModification
	currentClassDefinition := aClassModification after.
	self addedClassBlock cull: aClassModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedClassBlock
	^ addedClassBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedClassBlock: aBlock
	addedClassBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
addedClassExtension: aClassExtensionModification
	currentClassExtension := aClassExtensionModification after.
	self addedClassExtensionBlock cull: aClassExtensionModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedClassExtensionBlock
	^ addedClassExtensionBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedClassExtensionBlock: aBlock
	addedClassExtensionBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
addedMethod: aMethodModification
	self addedMethodBlock cull: aMethodModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedMethodBlock
	^ addedMethodBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedMethodBlock: aBlock
	addedMethodBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
addedMethodExtension: aMethodExtensionModification
	self addedMethodExtensionBlock cull: aMethodExtensionModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedMethodExtensionBlock
	^ addedMethodExtensionBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedMethodExtensionBlock: aBlock
	addedMethodExtensionBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
addedPackage: aPackageModification
	currentPackageDefinition := aPackageModification after.
	self addedPackageBlock cull: aPackageModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedPackageBlock
	^ addedPackageBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedPackageBlock: aBlock
	addedPackageBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
addedProject: aProjectModification
	currentProjectDefinition := aProjectModification after.
	self addedProjectBlock cull: aProjectModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedProjectBlock
	^ addedProjectBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
addedProjectBlock: aBlock
	addedProjectBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
changedClass: aClassModification
	currentClassDefinition := aClassModification after.
	self changedClassBlock cull: aClassModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedClassBlock
	^ changedClassBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedClassBlock: aBlock
	changedClassBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
changedClassExtension: aClassExtensionModification
	currentClassExtension := aClassExtensionModification after.
	self changedClassExtensionBlock cull: aClassExtensionModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedClassExtensionBlock
	^ changedClassExtensionBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedClassExtensionBlock: aBlock
	changedClassExtensionBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
changedMethod: aMethodModification
	self changedMethodBlock cull: aMethodModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedMethodBlock
	^ changedMethodBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedMethodBlock: aBlock
	changedMethodBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
changedMethodExtension: aMethodExtensionModification
	self changedMethodExtensionBlock cull: aMethodExtensionModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedMethodExtensionBlock
	^ changedMethodExtensionBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedMethodExtensionBlock: aBlock
	changedMethodExtensionBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
changedPackage: aPackageModification
	currentPackageDefinition := aPackageModification after.
	self changedPackageBlock cull: aPackageModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedPackageBlock
	^ changedPackageBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedPackageBlock: aBlock
	changedPackageBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
changedProject: aProjectModification
	currentProjectDefinition := aProjectModification after.
	self changedProjectBlock cull: aProjectModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedProjectBlock
	^ changedProjectBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
changedProjectBlock: aBlock
	changedProjectBlock := aBlock
%

category: 'accessing'
method: RwSample1TestValidationVisitor
defaultNoopBlock
	^ defaultNoopBlock ifNil: [ [  ] ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
defaultNoopBlock: aBlock
	defaultNoopBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
deletedClass: aClassModification
	self deletedClassBlock cull: aClassModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedClassBlock
	^ deletedClassBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedClassBlock: aBlock
	deletedClassBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
deletedClassExtension: aClassExtensionModification
	self deletedClassExtensionBlock cull: aClassExtensionModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedClassExtensionBlock
	^ deletedClassExtensionBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedClassExtensionBlock: aBlock
	deletedClassExtensionBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
deletedMethod: aMethodModification
	self deletedMethodBlock cull: aMethodModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedMethodBlock
	^ deletedMethodBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedMethodBlock: aBlock
	deletedMethodBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
deletedMethodExtension: aMethodExtensionModification
	self deletedMethodExtensionBlock cull: aMethodExtensionModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedMethodExtensionBlock
	^ deletedMethodExtensionBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedMethodExtensionBlock: aBlock
	deletedMethodExtensionBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
deletedPackage: aPackageModification
	self deletedPackageBlock cull: aPackageModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedPackageBlock
	^ deletedPackageBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedPackageBlock: aBlock
	deletedPackageBlock := aBlock
%

category: 'actions'
method: RwSample1TestValidationVisitor
deletedProject: aProjectModification
	self deletedProjectBlock cull: aProjectModification cull: self
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedProjectBlock
	^ deletedProjectBlock ifNil: [ self defaultNoopBlock ]
%

category: 'accessing'
method: RwSample1TestValidationVisitor
deletedProjectBlock: aBlock
	deletedProjectBlock := aBlock
%

! Class implementation for 'RwGsTestImage'

!		Class methods for 'RwGsTestImage'

category: 'accessing'
classmethod: RwGsTestImage
resetTestProjectRegistry

	"RwGsTestImage resetTestProjectRegistry"

	"drop any projects that may be present test project registry"

	((AllUsers userWithId: self currentUserId) objectNamed: #'UserGlobals')
		removeKey: #'RwGsTestLoadedProjectRegistry' ifAbsent: [  ];
		removeKey: #'RwGsTestProjectRepositoryRegistry' ifAbsent: [  ];
		yourself
%

category: 'querying'
classmethod: RwGsTestImage
_loadedProjectNamedForNonTestProjects: aString ifAbsent: absentBlock

	"Look up a loaded project. First in current users project registry, then scan AllUsers for the project ... note that the user needs to be the project owner."

	| currentUserId |
	currentUserId := self currentUserId.
	^ (super _loadedProjectRegistryForUserId: currentUserId)
		at: aString
		ifAbsent: [ 
			AllUsers
				do: [ :userProfile | 
					| aUserId |
					aUserId := userProfile userId.
					aUserId ~= currentUserId
						ifTrue: [ 
							(super _loadedProjectRegistryForUserId: aUserId)
								ifNotNil: [ :projectRegistry | 
									(projectRegistry at: aString ifAbsent: [  ])
										ifNotNil: [ :loadedProject | ^ loadedProject ] ] ] ].
			^ absentBlock value ]
%

category: 'private'
classmethod: RwGsTestImage
_loadedProjectRegistryForUserId: aUserId

	^ self _loadedTestProjectRegistryForUserId: aUserId
%

category: 'private'
classmethod: RwGsTestImage
_loadedTestProjectRegistryForUserId: aUserId

	| ug |
	ug := (AllUsers userWithId: aUserId) objectNamed: #'UserGlobals'.
	^ ug
		at: #'RwGsTestLoadedProjectRegistry'
		ifAbsent: [ 
			(self currentUserId = aUserId)
				ifFalse: [ ^ nil ].
			ug at: #'RwGsTestLoadedProjectRegistry' put: StringKeyValueDictionary new ]
%

category: 'accessing'
classmethod: RwGsTestImage
_projectForNonTestProject: projectName

	" this is a method that should only need to be used by tests ... and then sparingly"

	^self _loadedProjectNamedForNonTestProjects: projectName ifAbsent: [self error: 'no project ', projectName printString, ' found.']
%

category: 'private'
classmethod: RwGsTestImage
_projectRepositoryRegistryForUserId: aUserId

	| ug |
	ug := (AllUsers userWithId: aUserId) objectNamed: #'UserGlobals'.
	^ ug
		at: #'RwGsTestProjectRepositoryRegistry'
		ifAbsent: [ 
			(self currentUserId = aUserId)
				ifFalse: [ ^ nil ].
			ug at: #'RwGsTestProjectRepositoryRegistry' put: StringKeyValueDictionary new ]
%

! Class implementation for 'JadeServerTest'

!		Instance methods for 'JadeServerTest'

category: 'support'
method: JadeServerTest
jadeiteServer

	^JadeServer theJadeiteServer
%

category: 'tests'
method: JadeServerTest
test_jadeServerCanonicalLocation
  | jadeServerClass |
  (System _gemVersion beginsWith: '3.2')
    ifTrue: [ jadeServerClass := JadeServer64bit32 ]
    ifFalse: [ jadeServerClass := JadeServer64bit35 ].
  self assert: (JadeServer theJadeiteServer isKindOf: jadeServerClass).
  self
    assert:
      (JadeServer theJadeiteServer class canUnderstand: #'updateFromSton:').
  self
    assert:
      JadeServer theJadeiteServer == (SessionTemps current at: #'jadeiteServer')
%

category: 'tests'
method: JadeServerTest
test_jadeServerExists

	"at minimum (for now), these classes should always be present:
	Object
		JadeServer
			JadeServer64bit
				JadeServer64bit24
					JadeServer64bit3x
						JadeServer64bit32.

	See RsGsPlatform>>jadeServerClassNamed: for symbol list JadeServer*
	lives in. Note that method will only lookup JadeServer & JadeServer64bit32"

	"if method compiles we're in like flint"
	{JadeServer .
			JadeServer64bit .
				JadeServer64bit24 .
					JadeServer64bit3x .
						JadeServer64bit32}.
%

category: 'tests'
method: JadeServerTest
test_jadeServerHierarchyValid

	"The hierarchy should be:
	Object
		JadeServer
			JadeServer64bit
				JadeServer64bit24
					JadeServer64bit3x
						JadeServer64bit32.

	See RsGsPlatform>>jadeServerClassNamed: for symbol list JadeServer*
	lives in. Note that method will only lookup JadeServer, JadeServer64bit32,
	and JadeServer64bit35"
				
	| jadeServerClass subclasses |
	jadeServerClass := Rowan platform jadeServerClassNamed: #JadeServer. 
	subclasses :=  jadeServerClass subclasses asArray.
	self assert: subclasses size equals: 1. 
	self assert: subclasses first name = #JadeServer64bit.
	jadeServerClass := Rowan globalNamed: subclasses first name. 
	subclasses :=  jadeServerClass subclasses asArray.
	self assert: subclasses size equals: 1. 
	self assert: subclasses asArray first name = #JadeServer64bit24.
	jadeServerClass :=  Rowan globalNamed: subclasses first name. 
	subclasses :=  jadeServerClass subclasses asArray.
	self assert: subclasses size equals: 1. 
	self assert: subclasses asArray first name = #JadeServer64bit3x.
	jadeServerClass :=  Rowan globalNamed: subclasses first name. 
	subclasses :=  jadeServerClass subclasses asArray.
	self assert: subclasses size equals: 1. 
	self assert: subclasses asArray first name = #JadeServer64bit32.
	jadeServerClass := Rowan platform jadeServerClassNamed: #JadeServer64bit32. 
	subclasses :=  jadeServerClass subclasses asArray.
	self assert: subclasses asArray first name = #JadeServer64bit35.
	jadeServerClass := Rowan platform jadeServerClassNamed: #JadeServer64bit35. 
	subclasses :=  jadeServerClass subclasses asArray.
	self assert: subclasses isEmpty
%

category: 'tests'
method: JadeServerTest
test_rowanCanFindJadeServer

	self assert: (Rowan class canUnderstand: #jadeServerClassNamed:).
	self assert: (RwGsPlatform canUnderstand: #jadeServerClassNamed:).
	self assert: (Rowan jadeServerClassNamed: #JadeServer64bit32) equals: JadeServer64bit32.
	self assert: (Rowan jadeServerClassNamed: #JadeServer64bit35)equals: JadeServer64bit35
%

category: 'tests'
method: JadeServerTest
test_serviceUsesCanonicalJadeServer
  | jadeServerClass |
  (System _gemVersion beginsWith: '3.2')
    ifTrue: [ jadeServerClass := JadeServer64bit32 ]
    ifFalse: [ jadeServerClass := JadeServer64bit35 ].
  self
    assert: (RowanAnsweringService new jadeiteServer isKindOf: jadeServerClass).
  self
    assert:
      RowanAnsweringService new jadeiteServer == JadeServer theJadeiteServer
%

category: 'tests'
method: JadeServerTest
test_updateFromSton
	
	"the entry point for all services call is JadeServer>>updateFromSton:.
	Make sure the method is present and will accept/return ston string"

	| service stonString resultString services |

	self assert: (JadeServer canUnderstand: #updateFromSton:).
	service := RowanQueryService new 
				command: #implementorsOf:; 
				commandArgs: (Array with: #test_updateFromSton).
	stonString := STON toString: (Array with: service).
	resultString := self jadeiteServer updateFromSton: stonString. 
	[services := STON fromString: resultString.
	self assert: services size equals: 3.
	self assert: (services first isKindOf: RowanMethodService).
	self assert: ((services at: 2) isKindOf: RowanQueryService).
	self assert: ((services at: 2) queryResults first isKindOf: RowanMethodService).
	self assert: (services at: 2) queryResults first selector == #test_updateFromSton.
	self assert: (services last isKindOf: RowanLoggingService)]
		ensure: [RowanCommandResult initializeResults.]
%

! Class implementation for 'NewTonelParserTest'

!		Instance methods for 'NewTonelParserTest'

category: 'asserting'
method: NewTonelParserTest
assertParse: aString rule: rule equals: result 
	self 
		assert: (self parse: aString rule: rule)
		equals: result
%

category: 'private'
method: NewTonelParserTest
newClassDefinitionForClassNamed: nameString superclassName: superclassString category: categoryString instVarNames: ivarArray classVarNames: cvarArray poolDictionaryNames: poolArray classInstVarNames: civarArray type: typeSymbol comment: commentString
  ^ TonelCypressReader
    newClassDefinitionForClassNamed: nameString
    superclassName: superclassString
    category: categoryString
    instVarNames: ivarArray
    classVarNames: cvarArray
    poolDictionaryNames: poolArray
    classInstVarNames: civarArray
    type: typeSymbol
    comment: commentString
%

category: 'private'
method: NewTonelParserTest
newMethodDefinitionForClassNamed: className classIsMeta: meta selector: selector category: category source: source
  ^ TonelCypressReader
    newMethodDefinitionForClassNamed: className
    classIsMeta: meta
    selector: selector
    category: category
    source: source
%

category: 'private'
method: NewTonelParserTest
newTypeDefinitionFrom: anArray
  ^ TonelCypressReader newTypeDefinitionFrom: anArray
%

category: 'private'
method: NewTonelParserTest
parse: aString rule: rule
  | parser |
  parser := self tonelParserClass onString: aString forReader: self.
  ^ parser perform: rule
%

category: 'asserting'
method: NewTonelParserTest
shouldParse: aString rule: rule raise: error
  | parser |
  parser := self tonelParserClass onString: aString  forReader: self.
  self should: [ parser perform: rule ] raise: error
%

category: 'tests'
method: NewTonelParserTest
testComment
	self 
		shouldParse: 'this "should" be an error'
		rule: #comment
		raise: TonelParseError.
	
	self  
		assertParse: '"this is a comment"'
		rule: #comment
		equals: 'this is a comment'.
	
	self  
		assertParse: '"""this"" is a comment with ""nested"" colons ""also at the end"""'
		rule: #comment
		equals: '"this" is a comment with "nested" colons "also at the end"'
%

category: 'tests'
method: NewTonelParserTest
testCPreprocessor_initializePaths
	self 
		assertParse: '
{ #category: ''Private'' }
CPreprocessor>>_initializePaths [
', self _CPreprocessor_initializePaths_method_source, '
]'
		rule: #methodDef
		equals: (self newMethodDefinitionForClassNamed: #CPreprocessor
			classIsMeta: false
			selector: #_initializePaths
			category: 'Private'
			source: '_initializePaths
', self _CPreprocessor_initializePaths_method_source).
%

category: 'tests'
method: NewTonelParserTest
testExtractSelector
	| parser |
	
	parser := self tonelParserClass new.
	
	self assert: (parser extractSelector: 'unary') equals: #unary.
	self assert: (parser extractSelector: '+ something') equals: #+.
	self assert: (parser extractSelector: '==> other') equals: #==>.
	self 
		assert: (parser extractSelector: 'some: arg1 keyword: arg2 selector: arg3') 
		equals: #some:keyword:selector:.
	self 
		assert: (parser extractSelector: 'some: 	arg1 keyword:arg2 selector: arg3') 
		equals: #some:keyword:selector:.
	self 
		assert: (parser extractSelector: 'some: arg1 
keyword: arg2 
selector: arg3') 
		equals: #some:keyword:selector:.
%

category: 'tests'
method: NewTonelParserTest
testIssue465
	self 
		assertParse: '
{ #category: ''documentation'' }
Object>>anReOverviewComment [
', self _issue_45_method_source, '
]'
		rule: #methodDef
		equals: (self newMethodDefinitionForClassNamed: #Object
			classIsMeta: false
			selector: #anReOverviewComment
			category: 'documentation'
			source: 'anReOverviewComment
', self _issue_45_method_source).
%

category: 'tests'
method: NewTonelParserTest
testMetadata
	self 
		assertParse: '{ #vars: [ #a, #b ] }' 
		rule: #metadata 
		equals: { #vars -> #(a b) } asDictionary.
	
	self 
		assertParse: '{ 
	#vars: [ #a, #b ],
	#uses: { #someNested: 42 } 
	}' 
		rule: #metadata 
		equals: { 
			#vars -> #(a b). 
			#uses -> { #someNested -> 42 } asDictionary
		} asDictionary
%

category: 'tests'
method: NewTonelParserTest
testMethod

	self 
		assertParse: 'Object>>name' 
		rule: #method
		equals: #(('Object' nil) 'name').
		
	self 
		assertParse: 'Object >> name: aString' 
		rule: #method
		equals: #(('Object' nil) 'name: aString').

false ifTrue: [	"I'm not sure that this pattern will show up in the wild ...so it can fail"
	self 
		assertParse: 'Object >> name: aString [ I do not care ]' 
		rule: #method
		equals: #(('Object' nil) 'name: aString').
].
	self 
		assertParse: 'Object class >> name: aString' 
		rule: #method
		equals: #(('Object' 'class') 'name: aString').
%

category: 'tests'
method: NewTonelParserTest
testMethodBody

true ifTrue: [ "skip this test for now" ^ self ].
	self 
		assertParse: '[ method body... I will ignore what is inside ]'
		rule: #methodBody
		equals: ' method body... I will ignore what is inside'.

	self 
		assertParse: '[
method 
	[body... [I 
		will ignore] 
what] is inside
]'
		rule: #methodBody
		equals: '
method 
	[body... [I 
		will ignore] 
what] is inside'.
		
	self 
		assertParse: '[ method body with "''", ''"'', "[", '']'' ]'
		rule: #methodBody
		equals: ' method body with "''", ''"'', "[", '']'''.
%

category: 'tests'
method: NewTonelParserTest
testMethodDef
	self 
		assertParse: '
{ #category: ''accessing'' }
Object>>name [
	^ self printString
]'
		rule: #methodDef
		equals: (self newMethodDefinitionForClassNamed: #Object
			classIsMeta: false
			selector: #name
			category: 'accessing' 
			source: 'name
	^ self printString').
			
	self 
		assertParse: '
Object class>>name [
	^ self printString
]'
		rule: #methodDef
		equals: (self newMethodDefinitionForClassNamed: #Object
			classIsMeta: true
			selector: #name
			category: ''
			source: 'name
	^ self printString').

	self 
		assertParse: '
TClass classSide >> template: aSystemCategoryName [
	"I really do not care"
]'
		rule: #methodDef
		equals: (self newMethodDefinitionForClassNamed: #TClass
			classIsMeta: true
			selector: #template:
			category: ''
			source: 'template: aSystemCategoryName
	"I really do not care"').
%

category: 'tests'
method: NewTonelParserTest
testMethodDefList
	| parsed |
	
	parsed := self 
		parse: '
Object class>>new [
	^ self basicNew initialize
]

{ #category: ''accessing'' }
Object>>name [
	^ self printString
]

{ #category: ''printing'' }
Object>>printOn: aStream [
	"Append to the argument, aStream, a sequence of characters that  
	identifies the receiver."

	| title |
	title := self class name.
	aStream
		nextPutAll: (title first isVowel ifTrue: [''an ''] ifFalse: [''a '']);
		nextPutAll: title

]'
		rule: #methodDefList.
		
	self assert: parsed flattened size equals: 3
%

category: 'tests'
method: NewTonelParserTest
testRemoveFromEnclosingStartEnd
  | parser nl |
  nl := TonelWriter lineEnding.
  parser := self tonelParserClass new.
  self
    assert: (parser removeFrom: '[ ^ self ]' enclosingStart: $[ end: $])
    equals: '^ self'.
  self
    assert:
      (parser
        removeFrom:
          ('[ 
	^ self ]' withLineEndings: nl)
        enclosingStart: $[
        end: $])
    equals: Character tab asString , '^ self'.
  self
    assert:
      (parser
        removeFrom:
          ('[ 
	^ self
	]' withLineEndings: nl)
        enclosingStart: $[
        end: $])
    equals: Character tab asString , '^ self'.
  self
    assert:
      (parser
        removeFrom:
          ('[ 

	^ self

]' withLineEndings: nl)
        enclosingStart: $[
        end: $])
    equals:
      ('
	^ self
' withLineEndings: nl)
%

category: 'tests'
method: NewTonelParserTest
testType
	self assertParse: 'Class' rule: #type equals: 'Class'.
	self assertParse: 'Trait' rule: #type equals: 'Trait'.
	self assertParse: 'Extension' rule: #type equals: 'Extension'
%

category: 'tests'
method: NewTonelParserTest
testTypeDef
  self
    assertParse:
      '
"
this is a test
"
Class { 
	#name: ''X'',
	#superclass: ''Y'',
	#category: ''Z'' 
}'
    rule: #'typeDef'
    equals:
      (self
        newClassDefinitionForClassNamed: 'X'
        superclassName: 'Y'
        category: 'Z'
        instVarNames: #()
        classVarNames: #()
        poolDictionaryNames: #()
        classInstVarNames: #()
        type: #'normal'
        comment: 'this is a test')
%

category: 'tests'
method: NewTonelParserTest
testTypeDefWithClassVars
  self
    assertParse:
      '
"
this is a test
"
Class {
	#name : #MCMockASubclass,
	#superclass : #MCMockClassA,
	#instVars : [
		''x''
	],
	#classVars : [
		''Y''
	],
	#category : #MonticelloMocks
}
'
    rule: #'typeDef'
    equals:
      (self
        newClassDefinitionForClassNamed: 'MCMockASubclass'
        superclassName: 'MCMockClassA'
        category: 'MonticelloMocks'
        instVarNames: #(#'x')
        classVarNames: #(#'Y')
        poolDictionaryNames: #()
        classInstVarNames: #()
        type: #'normal'
        comment: 'this is a test')
%

category: 'private'
method: NewTonelParserTest
tonelParserClass

	^true
		ifTrue: [ NewTonelParser ]
		ifFalse: [ TonelParser ]
%

category: 'private'
method: NewTonelParserTest
_CPreprocessor_initializePaths_method_source

	^ '| list |
  self nativeCppCmd .
	list := { '''' }.
	(path ~~ nil and: [path first == $$]) ifTrue: [list add: self directory].
  cppArchMType ifNil:[  "not using native cpp"
	  list add: ''/usr/include/''; add: ''/usr/local/include/'' .
    systemSearchPaths := { } .
  ] ifNotNil:[
    systemSearchPaths := { ''/usr/include/'' . ''/usr/local/include/'' }.
    cppArchMType == 50 ifTrue:[ systemSearchPaths add: ''/usr/include/linux'' ].
  ].
  searchPaths := list .
'
%

category: 'private'
method: NewTonelParserTest
_issue_45_method_source
^'"

RePlugin -- A Regular Expressions Plugin for Squeak

Introduction

RePlugin is a Squeak Plugin providing modern regular expression matching operations similar to those found in Perl. It was written by Andrew C. Greenberg (werdna@gate.net), with contributions by Markus Kohler, Stephen Pair and others. RePlugin 3.2 (and ''the Gory Details'' portion of this document) is directly taken from Version 2.04 of the excellent PCRE library by Philip Hazel with only minor modifications.

RePlugin, an Overview

While the primary functionality (and documentation) for RePlugin is found in new classes RePattern and ReMatch and the operations set forth therein, a comprehensive set of convenience functions are provided in the String class for ease of use. 

A Simple Example to Get You Started

After installing RePlugin, you can execute the following in a workspace: 

	''Candy is dandy, but liquor is quicker.''  reMatch: ''a.*y''

This reMatch: message directs RePlugin to search the longer string for the leftmost occurrence of the letter ''a'', followed by the longest string that can be collected thereafter comprising any characters, but ending in a ''y.'' The message answers: 

	 a ReMatch(''andy is dandy'')

(*blush*) which is an object of type ReMatch. As you shall see later, ReMatch objects can be saved to obtain a wide range of information about the match result. When printed, as here, it conveniently identifies the substring that was actually matched, which can also be obtained from the ReMatch instance by sending it the message match. (Note that the longer string ''andy is dandy'' was matched, and not the shorter ''andy''.) If there was no match of the string, for example if the subject string were 

	''You got ''y'', but only after the ''a''''

then the message would answer nil.  A common use of regular expression matching is simply to determine as a boolean result whether the pattern has been matched (similar to the #match method).  Accordingly, a convenience function is provided:

	(''Candy is dandy, but liquor is quicker.'' matchRe: ''a.*y'') ifTrue: [''matched''] ifFalse: [''not matched'']

Global Searching and Replacing

It is sometimes convenient to ask ReMatch to repeatedly search for non-overlapping matches of a regular expression, and to report a collection of information with respect to each of the matches found. For example, the message: 

	''Stupid is as stupid does.'' reMatch: ''stupid'' andCollect: [:m | m match ].

This message looks for occurrences of the regular expression ''stupid'' in the subject string. Each time a match is found, the corresponding match object is passed to the block associated with the collect: keyword, and the results of those computations are returned in an OrderedCollection. Since the first occurrence begins with a capital, only one match is found. (You could collect all occurrences either by using a character class or the i modifier, for example, using the reMatch:opt:collect: message.) In this case, however, the answer will be: 

	OrderedCollection (''stupid'' )

As a somewhat more useful example, 

	''Stupid is as stupid does.'' reMatch: ''\w+'' andCollect: [:m | m match ].

can be used to collect an ordered collection of all non-whitespace phrases in the string, in this case: 

 	OrderedCollection (''Stupid'' ''is'' ''as'' ''stupid'' ''does'' )

This particular form (collecting matches) is used with such frequency that a convenience function is provided:

	''Stupid is as stupid does.'' collectRe: ''\w+''
 
Sometimes you will want to substitute text for the matched text, which you can accomplish with the reMatch:collect: message and some fancy footwork, or which you can do quite easily, for example, as follows: 

	''Stupid is as stupid does.'' reMatch: ''stupid'' opt: ''i'' sub: [:m | ''Andy'' ].

which answers a string replacing all occurrences of stupid (because of the opt: ''i'', the search is done without regard to case) with ''Andy'', yielding: 

	''Andy is as Andy does.''

You can also ''capture'' text by surrounding regular expression subexpressions with parentheses. For example, consider the following expression: 

	''    line has leading spaces'' reMatch: ''^\W+(.*)''

which answers 

	a ReMatch(''     line has leading spaces'')

This would have little utility, since it merely copies the line of text entirely. But since RePlugin keeps track of which text is ''captured'' by which parenthetical group, which is numbered in the order the left parenthesis appears in the string. These group matches can be seperately obtained by sending the resulting match object the message ''matchAt:,'' for example: 

	(''    line has leading spaces'' reMatch: ''^\W+(.*)'') matchAt: 1

which answers 

	''line has leading spaces''

That is, the line without the leading white space. Indeed, RePlugin remembers these parenthetical captures during the match, so that you can check for double words as follows: 

	''this line has has a double word'' reMatch: ''(\w+)\W+\1''

which matches 

	a ReMatch(''has has'')

These and other regular expression operations are discussed in substantially greater detail below. 


Matching With RePlugin

The Principal Messages

You may call RePlugin in any of the following ways: 

	subjectString reMatch: pattern [from: from] [to: to] [opt: optionString]
	subjectString reMatch: [opt: optionString] sub: aBlock [num: maxMatches]
	subjectString reMatch: [opt: optionString] collect: aBlock [num: maxMatches]

The keywords in square brackets are optional, in the sense that messages are available with every combination of keywords shown, with and without the optional keywords. 

The first message performs a single search on the substring of subjectString from from to to, using the modifiers set forth in optionString. If from: is not specified, then 1 is used, if to: is not specified, then subjectString size is used, and if opt: is not specified, then the empty string is used. 
It should be noted that everywhere a pattern is permitted in these operations, either a string or compiled pattern object (an Re) may be used. If a string is used, then RePlugin will first search to see if the object was recently compiled, and if so, use that object, or if not, compiles the expression and remembers it for later reuse. If a compiled pattern object (an Re) is used, then that compiled object will be used, thereby avoiding recompilations and table lookups. 

The second message performs repeated searches of subjectString for nonoverlapping matches of pattern, using compile and matching options optionString until no more matches are present or maxMatches have been found. (If maxMatches is less than zero, the number of matches will be limited only by the number of matches in the string.) Then, for each match found, replace the matched substring with the result of applying the corresponding match object to aBlock. If opt: is not specified, then the empty string is used, and if num: is not specified, then the equivalent of -1 is used. 

There is a special case in the instance where the empty string is matched, because the ''next'' match would begin in the same place, thereby creating an infinite loop. This case is handled as in Perl 5.004, where an empty string is replaced with the result of calling the block, and the next search begins after ''bumping'' the string to the next character. Accordingly, 

	''Thanks Markus and Steve for all your help'' reMatch: ''x*'' sub: [:m | ''!!'' ].  

will answer: 

	''!!T!!h!!a!!n!!k!!s!! !!M!!a!!r!!k!!u!!s!! !!a!!n!!d!! !!S!!t!!e!!v!!e!! !!f!!o!!r!! !!a!!l!!l!! !!y!!o!!u!!r!! !!h!!e!!l!!p!!''

Finally, the third message performs repeated searches of subjectString for nonoverlapping matches of pattern, using compile and matching options optionString until no more matches are present or maxMatches have been found. (If maxMatches is less than zero, the number of matches will be limited only by the number of matches in the string.) Then, for each match found, evalute aBlock with the corresponding matchObject, and maintain and then answer an ordered collection of the results in the order they were computed. If opt: is not specified, then the empty string is used, and if num: is not specified, then the equivalent of -1 is used. 

reMatch:collect: handles empty string in the same manner as reMatch:sub:, with the added proviso that an empty match will not be counted if it immediately follows a non-empty match. Accordingly 

	''123'' reMatch: ''\d*'' collect: [:m | m match]

answers 

	OrderedCollection (''123'' )

and not ''OrderedCollection (''123'' ''''),'' although 

	''123'' reMatch: ''\d*'' sub: [:m | ''<'', m match, ''>'']

will answer 

	 ''<123><>''

These null match rules mirror the semantics of Perl 5''s m/.../g and s/.../g operators. 

Using ReMatch to Obtain Principal Match Information

The substring of the substring matched by re is given by: 

	m match

The beginning and end of the substring in searchString is given by the messages from and to, respectively, so that the substring matched (the result of m match could be obtained with: 

 	m searchString
		copyFrom: (m from)
		to: (m to)


Using ReMatch to Obtain Captured Groups (and Collections of Captured Groups)

The number of substrings capturable by a parenthetical grouping in an re (regardless of the number actually matched to create m) is given by: 

	m numGroups
	
The string captured by parenthetical grouping i, where 1<=i<=(m numGroups) is given by 

	m matchAt: i

and this can be generated as follows: 

	m searchString
		copyFrom: (m fromAt: i)
		to: (m toAt: i)

And an array of size (m numGroups) can be generated from strings and indices accordingly: 

	m matches
	m froms
	m tos


Efficient Regular Expression Matching

RePattern tests for regular expression matching in three stages: 

1. Compiles the regular expression into a convenient internal form. 
2. Searches an object string or substring for matches. 
3. Produces results of queries on a match object. 

If you intend to repeatedly matching a single regular expression against many different strings, for example each line of a file or element of a collection, then repeating Step 1, the compilation, would be wasteful and inefficient. RePattern avoids recompilation by keeping track of the last dozen or so compiled regular expressions, avoiding the costly process of recompilation. Unfortunately, this adds the (less inefficient) cost of a table lookup with each regular expression match. 

Accordingly, RePattern permits you to generate and keep ''compiled pattern objects,'' for repeated matching against subsequent strings without recompiling or searching the compilation cache. You can create an compiled pattern object with the asRePattern message: 

	''\w+'' asRePattern

which answers 

	an Re(''\w+\00'')

and the resulting pattern can be used wherever a pattern string can be used, except that no recompilation or table lookup occurs. The following: 

	re := ''\w+'' asRePattern
	myCollection do: [:i|
		Transcript show: ((i reMatch: re) match); cr]

will be substantially faster than 

	myCollection do: [:i|
		Transcript show: ((i reMatch: ''\w+'') match); cr]

Regular Expression Syntax Summary

A regular expression (or regexp) specifies a set of strings that matches it. Regular expressions can be concatenated to form new regular expressions; if A and B are both regular expressions, then AB is also an regular expression. If a string p matches A and another string q matches B, the string pq will match AB. Thus, complex expressions are easily constructed from simpler primitive expressions. 

Regular expressions can contain both special and ordinary characters. Most ordinary characters, like ''A'', ''a'', or ''0'', are the simplest regular expressions; they simply match themselves. You can concatenate ordinary characters, so last matches the string ''last''. 

Some characters, like ''|'' or ''('', are special. Special characters either stand for classes of ordinary characters, or affect how the regular expressions around them are interpreted. 

The special characters are: 

''.'' 
(Dot.) In the default mode, this matches any character except a newline. If the ''s'' option has been specified, dot matches any character at all, including a newline. 

''^'' 
(Caret.) Matches the start of the string, and if the ''m'' option has been specified, then this also matches immediately after each newline. 

''$'' 
Matches the end of the string, and if the ''m'' option has been specified, then this also matches before a newline. foo matches both ''foo'' and ''foobar'', while the regular expression foo$ matches only ''foo''. 

''*'' 
Causes the resulting regexp to match 0 or more repetitions of the preceding regexp, as many repetitions as are possible. ab* will match ''a'', ''ab'', or ''a'' followed by any number of ''b''s. 

''+'' 
Causes the resulting regexp to match 1 or more repetitions of the preceding regexp. ab+ will match ''a'' followed by any non-zero number of ''b''s; it will not match just ''a''. 

''?'' 
Causes the resulting regexp to match 0 or 1 repetitions of the preceding regexp. ab? will match either ''a'' or ''ab''. 

*?, +?, ?? 
The ''*'', ''+'', and ''?'' qualifiers are all greedy; they match as much text as possible. Sometimes this behaviour isn''t desired; if the regexp <.*> is matched against ''<H1>title</H1>'', it will match the entire string, and not just ''<H1>''. Adding ''?'' after the qualifier makes it perform the match in non-greedy or minimal fashion; as few characters as possible will be matched. Using .*? in the previous expression will match only ''<H1>''. 

{m,n} 
Causes the resulting regexp to match from m to n repetitions of the preceding regexp, attempting to match as many repetitions as possible. For example, a{3,5} will match from 3 to 5 ''a'' characters. Omitting n specifies an infinite upper bound; you can''t omit m. 

{m,n}? 
Causes the resulting regexp to match from m to n repetitions of the preceding regexp, attempting to match as few repetitions as possible. This is the non-greedy version of the previous qualifier. For example, on the 6-character string ''aaaaaa'', a{3,5} will match 5 ''a'' characters, while a{3,5}? will only match 3 characters. 

''\'' 
Either escapes special characters (permitting you to match characters like ''*'', ''?'', and so forth), or signals a special sequence; special sequences are discussed below. 

[] 
Used to indicate a set of characters. Characters can be listed individually, or a range of characters can be indicated by giving two characters and separating them by a ''-''. Special characters are not active inside sets. For example, [akm$] will match any of the characters ''a'', ''k'', ''m'', or ''$''; [a-z] will match any lowercase letter, and [a-zA-Z0-9] matches any letter or digit. Character classes such as \w or \S(defined below) are also acceptable inside a range. If you want to include a '']'' or a ''-'' inside a set, precede it with a backslash, or place it as the first character. The pattern []] will match '']'', for example. 

You can match the characters not within a range by complementing the set. This is indicated by including a ''^'' as the first character of the set; ''^'' elsewhere will simply match the ''^'' character. For example, [^5] will match any character except ''5''. 

''|'' 
A|B, where A and B can be arbitrary regexps, creates a regular expression that will match either A or B. This can be used inside groups (see below) as well. To match a literal ''|'', use \|, or enclose it inside a character class, as in [|]. 

(...) 
Matches whatever regular expression is inside the parentheses, and indicates the start and end of a group; the contents of a group can be retrieved after a match has been performed, and can be matched later in the string with the \number special sequence, described below. To match the literals ''('' or '''')'', use \( or \), or enclose them inside a character class: [(] [)]. 

(?...) 
This is an extension notation (a ''?'' following a ''('' is not meaningful otherwise). The first character after the ''?'' determines what the meaning and further syntax of the construct is. Following are the currently supported extensions: 

(?imsx[-imsx]) 
(One or more letters from the set ''i'', ''m'', ''s'', ''x''.) The group matches the empty string and set (or unset if the letters follow a ''-'') corresponding options for the regular expression or subexpression in which it is contained. 

(?:...) 
A non-grouping version of regular parentheses. Matches whatever regular expression is inside the parentheses, but the substring matched by the group cannot be retrieved after performing a match or referenced later in the pattern. 

(?#...) 
A comment; the contents of the parentheses are simply ignored. 

(?=...) 
Matches if ... matches next, but doesn''t consume any of the string. This is called a lookahead assertion. For example, Isaac (?=Asimov) will match ''Isaac'' only if it''s followed by ''Asimov''. 

(?!!...) 
Matches if ... doesn''t match next. This is a negative lookahead assertion. For example, Isaac (?!!Asimov) will match ''Isaac'' only if it''s not followed by ''Asimov''. 

(?<=...) 
Matches if ... matches, but doesn''t consume any of the string. This is called a lookbehind assertion. For example, (?<=foo|fooey)bar will match ''bar'' only if it''s preceded by ''foo'' or ''fooey''. All lookbehinds must have some fixed length, although alternatives need not be of the same length, as in the example. 

(?<!!...) 
Matches if ... doesn''t match, and doesn''t consume any of the string. This is called a negative lookbehind assertion. For example, (?<=foo|fooey)bar will match ''bar'' only if it''s not preceded by ''foo'' or ''fooey''. 

(?(condition)yes-pattern) 
Matches if condition is false or if condition is true and yes-pattern matches. 

(?(condition)yes-pattern|no-pattern) 
Matches if condition is true and yes-pattern matches, or if condition is false and no-pattern matches. 

The special sequences consist of ''\'' and a character from the list below. If the ordinary character is not on the list, then the resulting regexp will match the second character. For example, \$ matches the character ''$''. 

\number 
Matches the contents of the group of the same number. Groups are numbered starting from 1. For example, (.+) \1 matches ''the the'' or ''55 55'', but not ''the end'' (note the space after the group). This special sequence can only be used to match one of the first 99 groups. If the first digit of number is 0, or number is 3 octal digits long, it will not be interpreted as a group match, but as the character with octal value number. Inside the ''['' and '']'' of a character class, all numeric escapes are treated as characters. 
\A 
Matches only at the start of the string. 
\b 
Matches the empty string, but only at the beginning or end of a word. A word is defined as a sequence of alphanumeric characters, so the end of a word is indicated by whitespace or a non-alphanumeric character. 
\B 
Matches the empty string, but only when it is not at the beginning or end of a word. 
\d 
Matches any decimal digit; this is equivalent to the set [0-9]. 
\D 
Matches any non-digit character; this is equivalent to the set [^0-9]. 
\s 
Matches any whitespace character; this is equivalent to the set [ \t\n\r\f\v]. 
\S 
Matches any non-whitespace character; this is equivalent to the set [^ \t\n\r\f\v]. 
\w 
Matches any alphanumeric character; this is equivalent to the set [a-zA-Z0-9_]. 
\W 
Matches any non-alphanumeric character; this is equivalent to the set [^a-zA-Z0-9_]. 

\Z 
Matches only at the end of the string. 

\\ 
Matches a literal backslash. 


Compiler and Matching Option Modes Summary

  i  for Caseless Matching Mode
  m  for Multiline Mode
  s  for Dotall Mode (Dot matches newlines)
  x  for Extended Mode (whitespace not meaningful, comments permitted)
  A  for Anchored mode
  B  for NOTBOL mode (see below)
  E  for ''Dollar end only'' mode (see below)
  U  for Ungreedy mode -- greediness of operators is reversed
  X  for PCRE ''Extra'' mode (see below)
  Z  for NOTEOL mode (see below)

Options B and Z are available only when matching. Option A is available for both matching and compiling. The remaining options are available only for compiling patterns. "
	^ self'
%

! Class implementation for 'RowanServicesTest'

!		Class methods for 'RowanServicesTest'

category: 'Testing'
classmethod: RowanServicesTest
isAbstract
  ^ self sunitName = #'RowanServicesTest'
%

!		Instance methods for 'RowanServicesTest'

category: 'unicode method'
method: RowanServicesTest
addUnicodeSymbolKeyToUserGlobals
  "RowanServicesTest new addUnicodeSymbolKeyToUserGlobals"

  UserGlobals
    at: (String with: (Character withValue: 16r3DA)) asSymbol
    put: 'fnoodle'
%

category: 'unicode method'
method: RowanServicesTest
addUnicodeValueToUserGlobals
  "RowanServicesTest new addUnicodeValueToUserGlobals"

  UserGlobals at: #'bad' put: '£¥' asSymbol
%

category: 'unicode method'
method: RowanServicesTest
compileUnicodeMethod
	"RowanServicesTest new compileUnicodeMethod"

	RowanServicesTest rwCompileMethod:
	'iAmAUnicodeMethod

		| abc |
		abc := ''', (String with: (Character withValue: 16r3DA)), '''.
		self halt. 
		^abc'

	category: 'unicode method'
%

category: 'support'
method: RowanServicesTest
createClassDefinitionNamed: className

	| classDefinition |
	classDefinition := RwClassDefinition
		newForClassNamed: className
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'services test'
			comment: String new
			pools: #()
			type: 'normal'.
	^classDefinition
%

category: 'support'
method: RowanServicesTest
createNonDiskTestProjectNamed: projectName packageName: packageName

	| projectDefinition projectSetDefinition  |
	projectDefinition := RwProjectDefinition newForGitBasedProjectNamed: projectName.
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		yourself.
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.
	^projectDefinition
%

category: 'support'
method: RowanServicesTest
createProjectDefinitionNamed: projectName

	| projectDefinition |

	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		defaultSymbolDictName: self defaultSymbolDictionaryName;
		yourself.
	^projectDefinition
%

category: 'support'
method: RowanServicesTest
createServicesTestClass
  | packageDefinition classDefinition |
  packageDefinition := self createServicesTestPackage.
  packageDefinition classDefinitions
    do: [ :classDef | 
      classDef key = self servicesDefaultClassName
        ifTrue: [ ^ classDef ] ].
  classDefinition := self
    createClassDefinitionNamed: self servicesDefaultClassName.
  packageDefinition addClassDefinition: classDefinition.
  ^ classDefinition
%

category: 'support'
method: RowanServicesTest
createServicesTestPackage
  | projectDefinition |
  defaultProjectDefinition
    ifNotNil: [ :projectDef | ^ projectDef packageNamed: self servicesTestPackageName ].
  projectDefinition := self defaultProjectDefinition.
  projectDefinition addPackageNamed: self servicesTestPackageName.
  ^ projectDefinition packageNamed: self servicesTestPackageName
%

category: 'support'
method: RowanServicesTest
createServicesTestTestClass
  | packageDefinition classDefinition |
  packageDefinition := self defaultProjectDefinition
    packageNamed: self servicesTestPackageName.
  classDefinition := self
    createTestClassDefinitionNamed: self servicesDefaultTestClassName.
  packageDefinition addClassDefinition: classDefinition.
  ^ classDefinition
%

category: 'support'
method: RowanServicesTest
createTestClassDefinitionNamed: className

	| classDefinition |
	classDefinition := RwClassDefinition
		newForClassNamed: className
			super: 'TestCase'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'services test'
			comment: String new
			pools: #()
			type: 'normal'.
	^classDefinition
%

category: 'support'
method: RowanServicesTest
defaultProjectDefinition
  ^ defaultProjectDefinition
    ifNil: [ 
      defaultProjectDefinition := self
        createProjectDefinitionNamed: self servicesTestProjectName ]
%

category: 'support'
method: RowanServicesTest
defaultSymbolDictionaryName

	^'ServicesTestDictionary'
%

category: 'unicode method'
method: RowanServicesTest
iAmAUnicodeMethod

		| abc |
		abc := 'Ϛ'.
		self halt. 
		^abc
%

category: 'support'
method: RowanServicesTest
jadeiteIssueTested: aSymbol withTitle: anObject
	"send this to help identify which tests test which issues
	format: #issue<issueNumber>
	Example self issueTested: #issue235 withTitle: 'Need Find Class/Method from console'

	Issues currently reside in: 
		https://github.com/GemTalk/Jadeite/issues/"
%

category: 'support'
method: RowanServicesTest
loadRowanSample1
  | gitRoot projectName spec projectTools |
  projectName := 'RowanSample1'.
  (Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
    ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].
  gitRoot := self _testRowanProjectsSandbox.
  (gitRoot / projectName) ensureDeleteAll.
	spec := 'file:$ROWAN_PROJECTS_HOME/Rowan/samples/RowanSample1.ston' asRwUrl asSpecification.
	projectTools := Rowan projectTools.
	projectTools clone
		cloneSpecification: spec
		gitRootPath: gitRoot pathString
		useSsh: true
		registerProject: false.	"does not register the project, so it is not visible in project list ... does however clone the project to local disk"
	"attach a project definition to the Rowan project on disk ... not loaded and not registered"
	projectTools create createProjectFromSpecUrl: 'file:', gitRoot pathString, '/', projectName, '/', spec specsPath, '/RowanSample1.ston'.
	projectTools load loadProjectNamed: 'RowanSample1'.
%

category: 'support'
method: RowanServicesTest
loadServicesTestProject
  | projectSetDefinition |
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: self defaultProjectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition
%

category: 'unicode method'
method: RowanServicesTest
removeUnicodeSymbolsFromUserGlobals
  "RowanServicesTest new addUnicodeSymbolToUserGlobals"

  UserGlobals
    removeKey: (String with: (Character withValue: 16r3DA)) asSymbol
    ifAbsent: [  ].
  UserGlobals removeKey: #'bad' ifAbsent: [  ]
%

category: 'constants'
method: RowanServicesTest
servicesDefaultClassName

	^'RowanServicesTestClass'
%

category: 'constants'
method: RowanServicesTest
servicesDefaultTestClassName

	^'RowanServicesTestClassForTesting'
%

category: 'constants'
method: RowanServicesTest
servicesTestPackageName

	^'RowanServicesTestPackage'
%

category: 'constants'
method: RowanServicesTest
servicesTestProjectName

	^'RowanServicesTestProject'
%

category: 'setup teardown'
method: RowanServicesTest
setUp
	| user symListP symListT dictP dictT index |
	"ensure results are clean as service requests not coming through #updateFromSton: like the client"
  super setUp.
  SessionTemps current at: #'versionsVerified' put: false.
	RowanAnsweringService new setEnableInteractionHandler: false. 
	RowanCommandResult initializeResults.
	Rowan platform _alternateImageClass: Rowan image testImageClass.
"ensure that project is unloaded"
	(Rowan image loadedProjectNamed: self servicesTestProjectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].
"ensure that the default symbol dictionary has been removed and that any classes used in tests are not preset"
	user := System myUserProfile.
	symListP := user symbolList.
	symListT := GsCurrentSession currentSession symbolList.

	{self defaultSymbolDictionaryName}
		do: [ :symDictName | 
			dictP := symListP objectNamed: symDictName.
			dictP
				ifNotNil: [ 
					(dictP at: GsPackagePolicy globalName otherwise: nil)
						ifNotNil: [ :policy | policy disable ].
					index := symListP indexOf: dictP.
					index > 0
						ifTrue: [ user removeDictionaryAt: index ] ].

			dictT := symListT objectNamed: symDictName.
			dictT
				ifNotNil: [ 
					(dictT at: GsPackagePolicy globalName otherwise: nil)
						ifNotNil: [ :policy | policy disable ].
					index := symListT indexOf: dictT.
					index > 0
						ifTrue: [ symListT removeAtIndex: index ] ] ].
	GsPackagePolicy current refreshSessionMethodDictionary.
%

category: 'setup teardown'
method: RowanServicesTest
tearDown
  super tearDown.
  Rowan platform _alternateImageClass: nil.
  RowanCommandResult initializeResults.	"squash the gui updates"
  RowanAnsweringService new setEnableInteractionHandler: true
%

category: 'support'
method: RowanServicesTest
unloadServicesTestProject

	Rowan image loadedProjectNamed: self servicesTestProjectName ifAbsent:[^self].
	Rowan projectTools delete deleteProjectNamed: self servicesTestProjectName.
	defaultProjectDefinition := nil
%

category: 'private'
method: RowanServicesTest
_testRowanProjectsSandbox
	"working repository for use as ROWAN_PROJECTS_HOME for tests"

	| rowanProject |
	(System gemEnvironmentVariable: 'ROWAN_PROJECTS_SANDBOX')
		ifNotNil: [ :sandboxPath | ^ sandboxPath asFileReference ].
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ rowanProject repositoryRoot / 'test/testRepositories/repos/'
%

! Class implementation for 'RowanAnsweringServiceTest'

!		Instance methods for 'RowanAnsweringServiceTest'

category: 'support'
method: RowanAnsweringServiceTest
setUp

	super setUp. 
	service := RowanAnsweringService new organizer: ClassOrganizer new.
%

category: 'tests'
method: RowanAnsweringServiceTest
test_disableBreakpointsInterface
  self
    jadeiteIssueTested: #'issue515'
    withTitle: '(3.0.77) clear all breakpoints menu item would be useful'.
  service setBreakPointsAreEnabled: true.
  self assert: service breakPointsAreEnabled.
  self assert: RowanService breakPointsAreEnabled equals: true.
  self assert: (SessionTemps current at: #'Jadeite_BreakPointsAreEnabled').
  service setBreakPointsAreEnabled: false.
  self deny: service breakPointsAreEnabled.
  self assert: RowanService breakPointsAreEnabled equals: false.
  self deny: (SessionTemps current at: #'Jadeite_BreakPointsAreEnabled')
%

category: 'tests'
method: RowanAnsweringServiceTest
test_execCompileError
 
	self deny: (service exec: '1 +' context: nil asOop) key.
%

category: 'tests'
method: RowanAnsweringServiceTest
test_execNilContext

	self assert: (service exec: '123' context: nil asOop) value equals: 123 asOop.
	self assert: (service exec: '$a' context: nil asOop) value equals: $a asOop.
	self assert: (service exec: '3+4' context: nil asOop) value equals: 7 asOop.
	self assert: (service exec: 'true' context: nil asOop) value equals: true asOop.
	self assert: (service exec: 'false' context: nil asOop) value equals: false asOop.
%

category: 'tests'
method: RowanAnsweringServiceTest
test_execWithContext

	self assert: (service exec: 'self' context: 123 asOop) value equals: 123 asOop.
	self assert: (service exec: 'self size' context: Array new asOop) value equals: 0 asOop.
	self assert: (service exec: '1 + self' context: 2 asOop) value equals: 3 asOop.
%

category: 'tests'
method: RowanAnsweringServiceTest
test_initializeAutoCommit
	| autoCommit | 
	self jadeiteIssueTested: #issue396 withTitle: 'Ability to turn on autocommit would be nice'.
	autoCommit := RowanService autoCommit. 
	self assert: RowanService autoCommit equals: autoCommit.
	self assert: (SessionTemps current at: #'Jadeite_AutoCommit') equals: autoCommit.
	[service initializeAutoCommit. 
	self deny: RowanService autoCommit. 
	self deny: (SessionTemps current at: #'Jadeite_AutoCommit')] ensure: [
		RowanService setAutoCommit: autoCommit.
		self assert: RowanService autoCommit equals: autoCommit.]
%

category: 'tests'
method: RowanAnsweringServiceTest
test_initializeBreakPointsAreDisabled
  | breakPointsAreEnabled |
  self
    jadeiteIssueTested: #'issue515'
    withTitle: '(3.0.77) clear all breakpoints menu item would be useful'.
  breakPointsAreEnabled := RowanService breakPointsAreEnabled.
  self assert: RowanService breakPointsAreEnabled equals: breakPointsAreEnabled.
  self
    assert: (SessionTemps current at: #'Jadeite_BreakPointsAreEnabled')
    equals: breakPointsAreEnabled.
  [ 
  service initializeBreakPointsAreEnabled.
  self assert:  RowanService breakPointsAreEnabled.
  self assert: (SessionTemps current at: #'Jadeite_BreakPointsAreEnabled') ]
    ensure: [ 
      RowanService setBreakPointsAreEnabled: breakPointsAreEnabled.
      self
        assert: RowanService breakPointsAreEnabled
        equals: breakPointsAreEnabled ]
%

category: 'tests'
method: RowanAnsweringServiceTest
test_loadedPackageExists
	self jadeiteIssueTested: #issue205 withTitle: 'misspelled extension category name causes trouble'.
	Rowan packageNames do:[:packageName |
		self assert: (service loadedPackageExists: packageName) answer].
	self deny: (service loadedPackageExists: 'AAAA') answer.
	self deny: (service loadedPackageExists: 'AJsfdjsdf') answer.
	self assert: (service loadedPackageExists: 'Rowan-Kernel') answer. 
	self assert: (service loadedPackageExists: 'rowan-kernel') answer. "lower case is accepted"
%

category: 'tests'
method: RowanAnsweringServiceTest
test_matchingPattern

	self jadeiteIssueTested: #issue235 withTitle: 'Need Find Class/Method from console'.
	service selectorsMatchingPattern: #('size'). 
	self assert: service answer size equals: 1. 
	self assert: service answer first = #size.

	service selectorsMatchingPattern: #('SIZE').  "no case match"
	self assert: service answer size equals: 1. 
	self assert: service answer first = #size.

	service selectorsMatchingPattern: #('test_matching' $*). 
	self assert: service answer size equals: 1.
	self assert: service answer first = #test_matchingPattern.

	service selectorsMatchingPattern: #($* 'test_matching' ). 
	self assert: service answer size equals: 0.

	"sorted result"
	service selectorsMatchingPattern: #('size' $*). 
	self assert: service answer size > 1. 
	1 to: service answer size - 1 do:[:idx | 
		self assert: (service answer at: idx) < (service answer at: idx + 1)].
%

category: 'tests'
method: RowanAnsweringServiceTest
test_maxPrint
	self jadeiteIssueTested: #issue398 withTitle: 'String Inspectors don''t display lfs'.
	self assert: (service printStringOf: 123 asOop toMaxSize: 5) equals: '123'.
	self assert: (service printStringOf: 123 asOop toMaxSize: 2) equals: '12...'.
	self assert: (service printStringOf: 'abc' asOop toMaxSize: 2) equals: '''a...'.
	self assert: (service printStringOf: Object new asOop toMaxSize: 25) equals: 'anObject'.
	self assert: (service printStringOf: 'ab
cd' asOop toMaxSize: 25) equals: '''ab
cd'''.  "includes lf (10) - no ? substitution"
%

category: 'tests'
method: RowanAnsweringServiceTest
test_play

	"method to safely play with commits" 

	self deny: false
%

category: 'tests'
method: RowanAnsweringServiceTest
test_setAutoCommit
	| autoCommit | 
	self jadeiteIssueTested: #issue396 withTitle: 'Ability to turn on autocommit would be nice'.
	autoCommit := RowanService autoCommit. 
	[service setAutoCommit: true. 
	self assert: RowanService autoCommit. 
	self assert: (SessionTemps current at: #'Jadeite_AutoCommit').
	service setAutoCommit: false. 
	self deny: RowanService autoCommit. 
	self deny: (SessionTemps current at: #'Jadeite_AutoCommit')] ensure: [
		RowanService setAutoCommit: autoCommit.
		self assert: RowanService autoCommit equals: autoCommit.]
%

! Class implementation for 'RowanBrowserServiceTest'

!		Instance methods for 'RowanBrowserServiceTest'

category: 'tests'
method: RowanBrowserServiceTest
test_compileClassWithClassSelected
  "because the selectedClass is the name of the 
	class to be compiled, it compiles without a confirmation"

  | browserService |
  self
    jadeiteIssueTested: #'issue516'
    withTitle: 'Deleting classes and project reload (3.0.77)'.
  self createServicesTestPackage.
  self loadServicesTestProject.
  browserService := RowanBrowserService new.
  browserService selectedClass: 'Fubar'.
  browserService
    compileClass:
      'Object rwSubclass: ''Fubar''
	instVarNames: #( abc def )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
		category: ''' , self servicesTestPackageName
        ,
          '''
		options: #()'.
  browserService recompileMethodsAfterClassCompilation.
  [ 
  self
    assert:
      (Rowan image symbolList resolveSymbol: #'Fubar') value allInstVarNames
    equals: #(#'abc' #'def').
  browserService selectedClass: 'Fubar'.
  browserService
    compileClass:
      'Object rwSubclass: ''Fubar''
	instVarNames: #( abc )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
		category: ''' , self servicesTestPackageName
        ,
          '''
		options: #()'.
  browserService recompileMethodsAfterClassCompilation.
  self
    assert:
      (Rowan image symbolList resolveSymbol: #'Fubar') value allInstVarNames
    equals: #(#'abc') ]
    ensure: [ 
      Rowan projectTools browser removeClassNamed: 'Fubar'.
      self unloadServicesTestProject ]
%

category: 'tests'
method: RowanBrowserServiceTest
test_flipAutoCommit
	| autoCommit service | 
	self jadeiteIssueTested: #issue396 withTitle: 'Ability to turn on autocommit would be nice'.
	autoCommit := RowanService autoCommit. 
	service := RowanAutoCommitService new. 
	[service flipAutoCommit. 
	self assert: RowanService autoCommit equals: autoCommit not. 
	self assert: (SessionTemps current at: #'Jadeite_AutoCommit') equals: autoCommit not.
	service flipAutoCommit. 
	self assert: RowanService autoCommit equals: autoCommit. 
	self assert: (SessionTemps current at: #'Jadeite_AutoCommit') equals: autoCommit] ensure: [
		RowanService setAutoCommit: autoCommit.
		self assert: RowanService autoCommit equals: autoCommit.]
%

category: 'tests'
method: RowanBrowserServiceTest
test_windowsRegistry

	| browserService object |
	self jadeiteIssueTested: #issue385 withTitle: 'Inspector should keep associated root object alive'.
	browserService := RowanBrowserService new. 
	object := Object new. 
	browserService saveRootObject: object asOop windowHandle: 123456. 
	self assert: (browserService openWindows at: 123456) equals: object.
	browserService releaseWindowHandle: 123456. 
	self assert: (browserService openWindows at: 123456 ifAbsent:['gone']) equals: 'gone'.
%

! Class implementation for 'RowanClassServiceTest'

!		Class methods for 'RowanClassServiceTest'

category: 'Testing'
classmethod: RowanClassServiceTest
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #RowanClassServiceTest
%

!		Instance methods for 'RowanClassServiceTest'

category: 'patch'
method: RowanClassServiceTest
createClassNamed: className
%

category: 'support'
method: RowanClassServiceTest
createHierarchyWithNonResolvableClass

	"do not delete - sent by Jadeite client test
	RowanClassServiceTest new createHierarchyWithNonResolvableClass.
	Code by dhenrich"

  | projectName  packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
    className4 projectSetDefinition class1 class2 class3 class4 oldClass1 oldClass2 oldClass3  |

  projectName := 'Issue470'.
  packageName1 := 'Issue470-Core'.
  packageName2 := 'Issue470-Extensions'.
  className1 := 'Issue470Class1'.
  className2 := 'Issue470Class2'.
  className3 := 'Issue470Class3'.
  className4 := 'Issue470Class4'.

  {projectName}
    do: [ :pn |
      (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
        ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
  projectDefinition := (RwProjectDefinition
    newForGitBasedProjectNamed: projectName)
    addPackageNamed: packageName1;
    addPackageNamed: packageName2;
    defaultSymbolDictName: 'UserGlobals';
    yourself.

  packageDefinition := projectDefinition packageNamed: packageName1.

  classDefinition := (RwClassDefinition
    newForClassNamed: className1
      super: 'Object'
      instvars: #(ivar1)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className2
      super: className1
      instvars: #('ivar2')
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className3
      super: className2
      instvars: #('ivar4' 'ivar3')
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
   yourself.
  packageDefinition
    addClassDefinition: classDefinition.

"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).

  class2 := Rowan globalNamed: className2.
  self assert: class2 instVarNames = #(ivar2).
  self assert: class2 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: class3 superClass == class2.

"remove class2 and add class4 -- edit projectDefinition structure in place"
  projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
  packageDefinition := projectDefinition packageNamed: packageName1.

  packageDefinition removeClassNamed: className2.

  classDefinition := (RwClassDefinition
    newForClassNamed: className4
      super: className1
      instvars: #('ivar2')
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.
"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  oldClass1 := class1.
  oldClass2 := class2.
  oldClass3 := class3.
 
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: oldClass1 == class1.

  class4 := Rowan globalNamed: className4.
  self assert: class4 instVarNames = #(ivar2).
  self assert: class4 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: class3 superClass == oldClass2.
  self assert: oldClass3 == class3.
%

category: 'support'
method: RowanClassServiceTest
servicesClassInstance

	^self servicesDefaultClassName evaluate perform: #new
%

category: 'support'
method: RowanClassServiceTest
setUp
	super setUp.
	self createServicesTestClass. 
	self loadServicesTestProject.
%

category: 'support'
method: RowanClassServiceTest
tearDown

	self unloadServicesTestProject.
	super tearDown.
%

category: 'tests'
method: RowanClassServiceTest
test_addCategory
	| classService behavior |
	
	behavior := Rowan globalNamed: self servicesDefaultClassName. 
	self deny: (behavior categoryNames includes: 'fnoodle'). 
	classService := RowanClassService forClassNamed: self servicesDefaultClassName meta: false. 
	classService addCategory: 'fnoodle'.
	self assert: (behavior categoryNames includes: #fnoodle).
%

category: 'tests'
method: RowanClassServiceTest
test_addedProjectNotOnDisk

	| projectDefinition packageDefinition classDefinition projectService |
	projectDefinition := self createNonDiskTestProjectNamed: 'Azer' packageName: 'Baijan'. 
	[packageDefinition := projectDefinition packageNamed: 'Baijan'.

	classDefinition := RwClassDefinition
		newForClassNamed: #Baijan
		super: 'Object'
		instvars: #(name address orderHistory)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: 'a CustomerRecord holds the sales record for a customer.'
		pools: #()
		type: 'normal'.
	packageDefinition addClassDefinition: classDefinition.
	Rowan projectTools load loadProjectDefinition: projectDefinition.

	(RowanClassService forClassNamed: 'Baijan') update. "<-- walkback occurrred here"
	projectService := RowanProjectService newNamed: 'Azer'. 
	self deny: projectService existsOnDisk.
	self deny: projectService isSkew]
		ensure: [RowanBrowserService new unloadProjectsNamed: (Array with: 'Azer')]
%

category: 'tests'
method: RowanClassServiceTest
test_behavior
	"return class or meta class" 
	| classService |
	classService := RowanClassService forClassNamed: 'Array' meta: false.
	self assert: classService behavior equals: Array.
	classService := RowanClassService forClassNamed: 'OrderedCollection' meta: true.
	self assert: classService behavior equals: OrderedCollection class
%

category: 'tests'
method: RowanClassServiceTest
test_classComment
	| classService behavior |

	behavior := Rowan globalNamed: self servicesDefaultClassName. 
	self assert: behavior comment equals: String new. 
	classService := RowanClassService forClassNamed: self servicesDefaultClassName meta: false. 
	classService classComment: 'This is a test'. 
	self assert: behavior comment equals: 'This is a test'
%

category: 'tests'
method: RowanClassServiceTest
test_classFromName
	"always return thisClass" 
	| classService |
	classService := RowanClassService forClassNamed: 'Array' meta: false.
	self assert: classService theClass equals: Array.
	classService := RowanClassService forClassNamed: 'OrderedCollection' meta: true.
	self assert: classService theClass equals: OrderedCollection
%

category: 'tests'
method: RowanClassServiceTest
test_classHierarchy
	"return class hierarchy in format client can use.
	#nil -> #(Object class service)
	Object class service -> #(RowanService class service) 
	etc"
  
	| classService hierarchy objectClassService rowanServiceService |
	classService := RowanClassService forClassNamed: 'RowanClassService'.
	hierarchy := classService classHierarchy hierarchyServices. 
	self assert: (hierarchy isKindOf: Dictionary). 
	self assert: ((hierarchy at: #nil) isKindOf: Array).
	self assert: (hierarchy at: #nil) size equals: 1. 
	objectClassService := (hierarchy at: #nil) first.
	self assert: (objectClassService isKindOf: RowanClassService).
	self assert: objectClassService name equals: 'Object'.
	rowanServiceService := (hierarchy at: objectClassService) first. 
	self assert: rowanServiceService name equals: 'RowanService'.
	self assert: (hierarchy at: rowanServiceService) first name equals: 'RowanClassService'.
%

category: 'tests'
method: RowanClassServiceTest
test_classHierarchyClassSide
	"same as instance side"
  
	| classService hierarchy objectClassService rowanServiceService |
	classService := RowanClassService forClassNamed: 'RowanClassService' meta: true.
	hierarchy := classService classHierarchy hierarchyServices. 
	self assert: (hierarchy isKindOf: Dictionary). 
	self assert: ((hierarchy at: #nil) isKindOf: Array).
	self assert: (hierarchy at: #nil) size equals: 1. 
	objectClassService := (hierarchy at: #nil) first.
	self assert: (objectClassService isKindOf: RowanClassService).
	self assert: objectClassService name equals: 'Object'.
	rowanServiceService := (hierarchy at: objectClassService) first. 
	self assert: rowanServiceService name equals: 'RowanService'.
	self assert: (hierarchy at: rowanServiceService) first name equals: 'RowanClassService'.
%

category: 'tests'
method: RowanClassServiceTest
test_classWasDeleted
  | classService classDefinition packageDefinition |
  self
    jadeiteIssueTested: #'issue284'
    withTitle:
      '(3.0.49 and 3.0.50) project browser not updated properly on reload of project'.
  self unloadServicesTestProject.	"test class created in setUp"
  packageDefinition := self createServicesTestPackage. 
  [ 
  self loadServicesTestProject.
  System commitTransaction.	"commit loaded package, but not class"
  classDefinition := self
    createClassDefinitionNamed: self servicesDefaultClassName.
  packageDefinition addClassDefinition: classDefinition.
  self loadServicesTestProject.	"reload with class"
  classService := RowanClassService new name: self servicesDefaultClassName.
  self deny: classService wasDeleted.
  System abortTransaction.
  self assert: classService wasDeleted ]
    ensure: [ 
      self unloadServicesTestProject.
      System commitTransaction ]
%

category: 'test method compilation'
method: RowanClassServiceTest
test_compileClassInitializer
	"if you compile a class side method #initialize, the error 
	RwExecuteClassInitializeMethodsAfterLoadNotification is signaled. 
	Ensure that #saveMethodSource:category: doesn't handle it as
	it should be handled in compileMethod:behavior:symbolList:inCategory:"
	| classService errorHit methodService selector |
	self jadeiteIssueTested: #issue356 withTitle: 'Add method compilation tests in server services tests'.
	classService := RowanClassService forClassNamed: self servicesDefaultClassName.
	selector := #initialize. 
	classService meta: true. 
	errorHit := false. 
	[classService saveMethodSource: selector asString , ' ^$a' category: 'test initialize'] on: 
		RwExecuteClassInitializeMethodsAfterLoadNotification do:[:ex | errorHit := true.  ex resume: false. ].
	[self deny: errorHit. 
	methodService := classService methodsNamed: selector.
	self assert: methodService size equals: 1. 
	self assert: methodService first selector equals: selector.
	self assert: methodService first meta equals: true.
	self assert: (self servicesDefaultClassName evaluate perform: selector) equals: $a]
		ensure: [
			classService removeSelector: selector ifAbsent: [].
			self deny: ((self servicesDefaultClassName evaluate compiledMethodAt: selector otherwise: false))]
%

category: 'test method compilation'
method: RowanClassServiceTest
test_compileMethodNoCategory
	"defaults to 'other'"
	| classService methodService selector |
	self jadeiteIssueTested: #issue356 withTitle: 'Add method compilation tests in server services tests'.
	selector := #fnoodle. 
	classService := RowanClassService forClassNamed: self servicesDefaultClassName.
	self deny: (self servicesDefaultClassName evaluate categoryNames includes: 'other'). 
	classService saveMethodSource: selector asString, ' ^$a' category: nil.
	[methodService := classService methodsNamed: selector.
	self assert: methodService size equals: 1. 
	self assert: methodService first meta equals: false.
	self assert: methodService first category equals: 'other'. 
	self assert: (self servicesDefaultClassName evaluate categoryNames includes: #'other'). 
	self assert: (self servicesClassInstance perform: selector) equals: $a]
		ensure: [
			classService removeSelector: selector ifAbsent: [].
			self deny: ((self servicesDefaultClassName evaluate compiledMethodAt: selector otherwise: false))]
%

category: 'test method compilation'
method: RowanClassServiceTest
test_dirtyState
	| classService methodService selector |
	self jadeiteIssueTested: #issue356 withTitle: 'Add method compilation tests in server services tests'.
	selector := #simpleMethod. 
	self loadRowanSample1. "ensure we're in a clean state"
	self deny: (RowanProjectService newNamed:  'RowanSample1') isDirty.
	self deny: (RowanPackageService forPackageNamed: 'RowanSample1-Core') isDirty.
	classService := RowanClassService forClassNamed: 'RowanSample1'.
	classService saveMethodSource: selector asString,  ' ^123' category: 'abc'.
	
	methodService := classService methodsNamed: selector.
	[self assert: (RowanProjectService newNamed: 'RowanSample1') isDirty.
	self assert: (RowanPackageService new name: 'RowanSample1-Core') isDirty.]
			ensure: [
				Rowan projectTools delete deleteProjectNamed: 'RowanSample1'.]
%

category: 'test method compilation'
method: RowanClassServiceTest
test_dirtyStateNewProject
  "dirtiness is based on a comparison to disk.
	New projects (created in setUp) should be dirty"

  | classService selector |
  self
    jadeiteIssueTested: #'issue356'
    withTitle: 'Add method compilation tests in server services tests'.
  selector := #'simpleMethod'.
  [ 
  self assert: (RowanProjectService newNamed: 'RowanServicesTestProject') isDirty.
  self
    assert:
      (RowanPackageService forPackageNamed: 'RowanServicesTestPackage') isDirty.
  classService := RowanClassService forClassNamed: 'RowanServicesTestClass'.
  classService saveMethodSource: selector asString , ' ^123' category: 'abc' ]
    ensure: [ Rowan projectTools browser removeClassNamed: 'RowanServicesTestClass' ]
%

category: 'tests'
method: RowanClassServiceTest
test_equality

	| classService1 classService2 |
	classService1 := RowanClassService forClassNamed: 'RowanClassService'. 
	classService2 := RowanClassService forClassNamed: 'RowanClassService'. 
	self assert: classService1 equals: classService2.
	self deny: classService1 == classService2.
	self deny: classService1 equals: RowanClassService. 
	self deny: classService1 equals: #foo.
	self deny: classService1 equals: (RowanPackageService forPackageNamed: 'Rowan-Services-Tests').
	self deny: classService1 equals: (RowanProjectService newNamed: 'Rowan').
	self deny: classService1 equals: (RowanMethodService forSelector: #test_equality class: RowanClassServiceTest meta: false organizer: ClassOrganizer new)
%

category: 'tests'
method: RowanClassServiceTest
test_instVarNamesIsArray
	"instVarNames was getting set to a collection which
	was not handled well by STON"
	| classService |
	
	classService := RowanClassService forClassNamed: 'UnauthorizedObjectStub' meta: false. 
	self assert: (classService instVarNames isKindOf: Array).
%

category: 'tests'
method: RowanClassServiceTest
test_nameIsString

	| classService |
	self jadeiteIssueTested: #issue441 withTitle: '(3.0.62) suspicious code in RowanClassService>>hierarchyClassServiceFor:'.
	classService := RowanClassService forClassNamed: 'RowanClassService'. 
	self assert: (classService name isKindOf: String).
	classService := RowanClassService forClassNamed: #RowanClassService.
	self assert: (classService name isKindOf: String).

	classService := RowanClassService forClassNamed: 'RowanClassService' meta: true. 
	self assert: (classService name isKindOf: String).
	classService := RowanClassService forClassNamed: #RowanClassService meta: true. 
	self assert: (classService name isKindOf: String).

	classService := RowanClassService basicForClassNamed: 'RowanClassService'.
	self assert: (classService name isKindOf: String).
	classService := RowanClassService basicForClassNamed: #RowanClassService.
	self assert: (classService name isKindOf: String).

	classService := RowanClassService forClassNamed: 'RowanClassService' package: 'Rowan-Services-Tests'. 
	self assert: (classService name isKindOf: String).
	classService := RowanClassService forClassNamed: #RowanClassService package: 'Rowan-Services-Tests'. 
	self assert: (classService name isKindOf: String).

	classService := RowanClassService minimalForClassNamed: 'RowanClassService'.
	self assert: (classService name isKindOf: String).
	classService := RowanClassService minimalForClassNamed: #RowanClassService.
	self assert: (classService name isKindOf: String).
%

category: 'test method compilation'
method: RowanClassServiceTest
test_rowanCompileGone

	"#rowanCompile was used to tell Rowan
	to compile a method in a Rowan package
	or in the traditional manner. That is no 
	longer needed. Make sure it's not referenced
	anywhere." 

	self assert: (ClassOrganizer new referencesToLiteral: '#rowanCompile' evaluate) first isEmpty
%

category: 'test method compilation'
method: RowanClassServiceTest
test_selectedMethod
	| classService methodService selector |
	self jadeiteIssueTested: #issue356 withTitle: 'Add method compilation tests in server services tests'.
	selector := #simpleMethod. 
	classService := RowanClassService forClassNamed: self servicesDefaultClassName.
	self deny: classService meta. 
	self deny: (self servicesDefaultClassName evaluate compiledMethodAt: selector otherwise: false).
	classService saveMethodSource: selector asString,  ' ^123' category: 'abc'.
	
	methodService := classService methodsNamed: selector.
	[self assert: classService selectedMethods size equals: 1.
	self assert: classService selectedMethods first selector equals: selector]
		ensure: [
			classService removeSelector: selector ifAbsent: [].
			self deny: ((self servicesDefaultClassName evaluate compiledMethodAt: selector otherwise: false))]
%

category: 'tests'
method: RowanClassServiceTest
test_setClassCommentDuringMetaclassRefresh
  | classService behavior meta metaClassService |
  behavior := Rowan globalNamed: self servicesDefaultClassName.
  self assert: behavior comment equals: String new.
  classService := RowanClassService
    forClassNamed: self servicesDefaultClassName
    meta: false.
  classService classComment: 'This is a test'.
  meta := behavior class.
  metaClassService := RowanClassService new
    name: 'RowanClassService';
    oop: meta asOop.
  metaClassService fastRefresh.
  self assert: metaClassService comment equals: 'This is a test'
%

category: 'test method compilation'
method: RowanClassServiceTest
test_setSuperSubIndicators
	| classService superclassMethodService subclassMethodService selector subclassService browserService |
	selector := #indicatorTesting. 
	self loadRowanSample1.
	[browserService := RowanBrowserService new. 
	browserService compileClass: 
		'RowanSample1 rwSubclass: ''RowanSubClass''
			instVarNames: #()
			classVars: #()
			classInstVars: #()
			poolDictionaries: #()
			category: ''RowanSample1-Core''
			options: #()'.
	classService := RowanClassService forClassNamed: 'RowanSample1'.
	self assert: RowanCommandResult results size equals: 0. "we no longer return a service on first stage of compile"
	browserService recompileMethodsAfterClassCompilation. 
	classService saveMethodSource: selector asString,  ' ^#deleteThisMethod' category: 'abc'.
	superclassMethodService := (classService methodsNamed: selector) first.
	self deny: superclassMethodService hasSupers.
	self deny: superclassMethodService hasSubs.
	subclassService := RowanClassService forClassNamed: 'RowanSubClass'.
	subclassService saveMethodSource: selector asString,  ' ^#subclassMethod' category: 'abc'.
	subclassMethodService := RowanCommandResult results 
			detect:[:service | service isMethodService
				and:[service selector = selector and:[service className = 'RowanSubClass']]]. "an updated subclass method should be heading back to the client" 
	superclassMethodService := RowanCommandResult results 
			detect:[:service | service isMethodService
				and:[service selector = selector and:[service className = 'RowanSample1']]]. "an updated superclass method should be heading back to the client" 
	self assert: superclassMethodService hasSubs.  
	self deny: superclassMethodService hasSupers.
	self assert: subclassMethodService hasSupers.
	self deny: subclassMethodService hasSubs.
	]
			ensure: [
				Rowan projectTools delete deleteProjectNamed: 'RowanSample1'.]
%

category: 'test method compilation'
method: RowanClassServiceTest
test_simpleCompile
	| classService methodService selector |
	self jadeiteIssueTested: #issue356 withTitle: 'Add method compilation tests in server services tests'.
	selector := #simpleMethod. 
	classService := RowanClassService forClassNamed: self servicesDefaultClassName.
	self deny: classService meta. 
	self deny: (self servicesDefaultClassName evaluate compiledMethodAt: selector otherwise: false).
	classService saveMethodSource: selector asString,  ' ^123' category: 'abc'.
	
	methodService := classService methodsNamed: selector.
	[self assert: methodService size equals: 1. 
	self assert: methodService first selector equals: selector.
	self assert: methodService first meta equals: false.
	self assert: methodService first category equals: 'abc'.
	self assert: (self servicesClassInstance perform: selector) equals: 123.
	self assert: ((self servicesDefaultClassName evaluate compiledMethodAt: selector otherwise: nil) isKindOf: GsNMethod)]
		ensure: [
			classService removeSelector: selector ifAbsent: [].
			self deny: ((self servicesDefaultClassName evaluate compiledMethodAt: selector otherwise: false))]
%

category: 'test method compilation'
method: RowanClassServiceTest
test_simpleCompileClassSide
	| classService methodService selector |
	self jadeiteIssueTested: #issue356 withTitle: 'Add method compilation tests in server services tests'.
	classService := RowanClassService forClassNamed: self servicesDefaultClassName.
	selector := #simpleMethod.
	classService meta: true. 
	self assert: classService meta. 
	self deny: (((self servicesDefaultClassName evaluate perform: #class)  compiledMethodAt: selector otherwise: false)).
	classService saveMethodSource: selector asString,  ' ^123' category: 'abc'.
	[methodService := classService methodsNamed: selector.
	self assert: methodService size equals: 1. 
	self assert: methodService first selector equals: selector.
	self assert: methodService first meta equals: true.
	self assert: methodService first category equals: 'abc'.
	self assert: (self servicesDefaultClassName evaluate perform: selector) equals: 123.
	((self servicesDefaultClassName evaluate perform: #class)compiledMethodAt: selector) isKindOf: GsNMethod]
		ensure: [
			classService removeSelector: selector ifAbsent: [].
			self deny: (((self servicesDefaultClassName evaluate perform: #class)  compiledMethodAt: selector otherwise: false)).]
%

category: 'test method compilation'
method: RowanClassServiceTest
test_simpleCompileOnClassWithoutMetaSet
	| classService  methodService selector |
	self jadeiteIssueTested: #issue356 withTitle: 'Add method compilation tests in server services tests'.
	selector := #noMeta. 
	classService := RowanClassService forClassNamed: self servicesDefaultClassName.
	classService meta: nil.  "possible for meta not to be set but it should have an oop from which to determine" 
	classService oop: (self servicesDefaultClassName, ' class') evaluate asOop. 
	self deny: (((self servicesDefaultClassName evaluate perform: #class)  compiledMethodAt: selector otherwise: false)).
	classService saveMethodSource: selector asString,  ' ^true' category: 'testing'.
	[methodService := classService methodsNamed: selector.
	self assert: methodService size equals: 1. 
	self assert: methodService first selector equals: selector.
	self assert: methodService first meta equals: true. "we created a class method"
	self assert: methodService first category equals: 'testing'.
	self assert: (self servicesDefaultClassName evaluate perform: selector)]
		ensure: [
			classService removeSelector: selector ifAbsent: [].
			self deny: (((self servicesDefaultClassName evaluate perform: #class)  compiledMethodAt: selector otherwise: false)).]
%

category: 'test method compilation'
method: RowanClassServiceTest
test_simpleCompileWithoutMetaSet
	| classService methodService selector |
	self jadeiteIssueTested: #issue356 withTitle: 'Add method compilation tests in server services tests'.
	selector := #noMeta. 
	classService := RowanClassService forClassNamed: self servicesDefaultClassName.
	classService meta: nil.  "possible for meta not to be set but it should have an oop from which to determine" 
	classService oop: self servicesDefaultClassName evaluate asOop. 
	self deny: (self servicesDefaultClassName evaluate compiledMethodAt: selector otherwise: false).
	classService saveMethodSource: selector asString,  ' ^true' category: 'testing'.
	methodService := classService methodsNamed: selector.
	self assert: methodService size equals: 1. 
	self assert: methodService first selector equals: selector.
	self assert: methodService first meta equals: false. "we created an instance method"
	self assert: methodService first category equals: 'testing'.
	self assert: (self servicesClassInstance perform: selector).
%

! Class implementation for 'RowanTestClassServiceTest'

!		Class methods for 'RowanTestClassServiceTest'

category: 'support'
classmethod: RowanTestClassServiceTest
shouldInheritSelectors

	^true
%

!		Instance methods for 'RowanTestClassServiceTest'

category: 'support'
method: RowanTestClassServiceTest
nonTestMethod

	"do not remove. Used in test"
%

category: 'tests'
method: RowanTestClassServiceTest
test_isTestCase

	| classService |
	self jadeiteIssueTested: #issue253 withTitle: 'popup method menu in method list is slow for JadeServer methods'. 
	classService := RowanClassService forClassNamed: self class.
	self assert: classService isTestCase.
	classService isTestCase: false. 
	self deny: classService isTestCase. 
	classService setIsTestCaseCommand. 
	self assert: classService isTestCase.

	classService := RowanClassService forClassNamed: 'JadeServer'.
	self deny: classService isTestCase.
%

category: 'tests'
method: RowanTestClassServiceTest
test_runClassService

	self jadeiteIssueTested: #issue341 withTitle: 'Run sunit tests from class pass when they should not'.
%

category: 'tests'
method: RowanTestClassServiceTest
test_setTestClass

	| classService |
	classService := RowanClassService new name:  'RowanMethodService'. 
	self assert: classService isTestCase equals: nil.
	classService setIsTestCase. 
	self deny: classService isTestCase. 
	
	classService := RowanClassService new name:  'RowanTestClassServiceTest'. 
	self assert: classService isTestCase equals: nil.
	classService setIsTestCase. 
	self assert: classService isTestCase.
%

category: 'tests'
method: RowanTestClassServiceTest
test_testSelectors

	| classService |
	self jadeiteIssueTested: #issue341 withTitle: 'Run sunit tests from class pass when they should not'.
	classService := RowanClassService forClassNamed: 'RowanTestClassServiceTest'. 
	self deny: (classService tests detect:[:methodService | methodService selector = #test_testSelectors] ifNone:[]) equals: nil.
	self assert: (classService tests detect:[:methodService | methodService selector = #nonTestMethod] ifNone:[]) equals: nil.
%

! Class implementation for 'RowanDebuggerServiceTest'

!		Instance methods for 'RowanDebuggerServiceTest'

category: 'tests'
method: RowanDebuggerServiceTest
test_debugBlanksOnly

	| string debugString |
	self jadeiteIssueTested: #issue262 withTitle: 'Console debug-it does nothing if selected expression has temp variables'.
	string := '     '. 
	debugString := RowanDebuggerService new debugStringFrom: string. 
	self assert: debugString equals: 'nil halt.'
%

category: 'tests'
method: RowanDebuggerServiceTest
test_debugEmptyString

	| string debugString |
	self jadeiteIssueTested: #issue262 withTitle: 'Console debug-it does nothing if selected expression has temp variables'.
	string := String new.
	debugString := RowanDebuggerService new debugStringFrom: string. 
	self assert: debugString equals: 'nil halt.'
%

category: 'tests'
method: RowanDebuggerServiceTest
test_debugStringBarInString

	| string debugString |
	self jadeiteIssueTested: #issue262 withTitle: 'Console debug-it does nothing if selected expression has temp variables'.
	string := '| var |
var := ''|'''. 
	debugString := RowanDebuggerService new debugStringFrom: string. 
	self assert: debugString equals: '| var | nil halt. 
var := ''|'''.
%

category: 'tests'
method: RowanDebuggerServiceTest
test_debugStringLeadingWhitespace

	| string debugString |
	self jadeiteIssueTested: #issue262 withTitle: 'Console debug-it does nothing if selected expression has temp variables'.
	string := '   | var |
var := ''|'''. 
	debugString := RowanDebuggerService new debugStringFrom: string. 
	self assert: debugString equals: '| var | nil halt. 
var := ''|'''.
%

category: 'tests'
method: RowanDebuggerServiceTest
test_debugStringNoTemps

	| string debugString |
	self jadeiteIssueTested: #issue262 withTitle: 'Console debug-it does nothing if selected expression has temp variables'.
	string := 'abc'. 
	debugString := RowanDebuggerService new debugStringFrom: string. 
	self assert: debugString equals: 'nil halt. ', string
%

category: 'tests'
method: RowanDebuggerServiceTest
test_debugStringTemps

	| string debugString |
	self jadeiteIssueTested: #issue262 withTitle: 'Console debug-it does nothing if selected expression has temp variables'.
	string := '| ps |
ps := RowanProjectService newNamed: ''RowanSample1''.
ps refresh'. 
	debugString := RowanDebuggerService new debugStringFrom: string. 
	self assert: debugString equals: '| ps | nil halt. 
ps := RowanProjectService newNamed: ''RowanSample1''.
ps refresh'
%

category: 'tests'
method: RowanDebuggerServiceTest
test_malformed
	"it won't compile but it shouldn't walkback either"
	| string debugString |
	self jadeiteIssueTested: #issue262 withTitle: 'Console debug-it does nothing if selected expression has temp variables'.
	string := 'abc | def | ^abc'.
	debugString := RowanDebuggerService new debugStringFrom: string. 
	self assert: debugString equals: 'nil halt. abc | def | ^abc'.
%

! Class implementation for 'RowanDictionaryServiceTest'

!		Instance methods for 'RowanDictionaryServiceTest'

category: 'tests'
method: RowanDictionaryServiceTest
test_insertRemoveDictionary
	| dictionaryService browserService |
	dictionaryService := RowanDictionaryService new name: 'FnoodleDictionary'. 
	dictionaryService insertAt: 1. 
	self assert: Rowan image symbolList first name equals: #FnoodleDictionary.

	browserService := RowanBrowserService new. 
	browserService removeDictionariesNamed: #('FnoodleDictionary').
	self deny: Rowan image symbolList first name equals: #FnoodleDictionary.
%

! Class implementation for 'RowanMethodServiceTest'

!		Instance methods for 'RowanMethodServiceTest'

category: 'support'
method: RowanMethodServiceTest
setUp

	super setUp.
	self createServicesTestClass. 
	self loadServicesTestProject.
%

category: 'constants'
method: RowanMethodServiceTest
stepPoint1Source
	"sent from the client, too" 

^'simpleMethod

	| array |
	array := Array new. 
			"^3"		"^2"
	array add: OrderedCollection new. 
			"^5"							"^4"
	array size.
			"^6"
	^array'
%

category: 'constants'
method: RowanMethodServiceTest
stepPoint2Source
	"sent from the client, too" 


^'simpleMethod2

	| array |
	array := Array new. 
						"^1"
	array add: (RowanClassService forClassNamed: Fraction). 
			"^3"								"^2"
	array do:[:classService | 
			"^4"  
				| stepPoints |
			stepPoints := classService stepPoints.
												"^5"
			stepPoints size
							"^6"]. 
	array size.
			"^7"
	^array'
%

category: 'constants'
method: RowanMethodServiceTest
stepPoint3Source
	"sent from the client, too" 

	"missing step point numbers were optimized away or screwed
	up by the 3.2.15 server. "

^'initialize: aGsProcess status: aString

	| theOrganizer frames oop status |
	theOrganizer := ClassOrganizer new. 
												"^1"
	frames := Array new: aGsProcess stackDepth.
							"^3"					"^2"
	1 to: aGsProcess stackDepth do: [:i | 
								"^4"
		frames at: i put: (RowanFrameService process: aGsProcess level: i organizer: theOrganizer).
				"^5"											"^6"
	].
	oop := aGsProcess asOop.  
								"^9"
	status := aString.'
%

category: 'support'
method: RowanMethodServiceTest
tearDown

	self unloadServicesTestProject.
	super tearDown.
%

category: 'tests'
method: RowanMethodServiceTest
test_classNameIsString

	| methodService organizer |
	self jadeiteIssueTested: #issue441 withTitle: '(3.0.62) suspicious code in RowanClassService>>hierarchyClassServiceFor:'.
	organizer := ClassOrganizer new. 
	methodService := RowanMethodService forGsNMethod: (RowanMethodServiceTest compiledMethodAt: #setUp) organizer: organizer.
	self assert: (methodService className isKindOf: String).
	self assert: methodService className = 'RowanMethodServiceTest'.

	methodService := RowanMethodService forSelector: #setUp class: RowanMethodServiceTest meta: false organizer: organizer.
	self assert: (methodService className isKindOf: String).
	self assert: methodService className = 'RowanMethodServiceTest'.

	methodService := RowanMethodService source: 'fnoodle' selector: #fnoodle category: 'other' className: 'RowanMethodServiceTest' packageName: 'Rowan-Services-Tests' meta: true. 
	self assert: (methodService className isKindOf: String).
	self assert: methodService className = 'RowanMethodServiceTest'.
%

category: 'tests'
method: RowanMethodServiceTest
test_isTestMethod
	"isTestMethod not getting initialized correctly" 
	| methodService organizer |
	self jadeiteIssueTested: #issue512 withTitle: '"run selected" can get disabled after save in debugger (3.0.76)'.
	organizer := ClassOrganizer new. 
	methodService := RowanMethodService forGsNMethod: (RowanMethodServiceTest compiledMethodAt: #test_isTestMethod) organizer: organizer.
	self assert: methodService isTestMethod. 
	methodService := RowanMethodService forGsNMethod: (RowanMethodService compiledMethodAt: #initialize) organizer: organizer.
	self deny: methodService isTestMethod.
%

category: 'tests'
method: RowanMethodServiceTest
test_reformatSource
	| classService methodService source |
		classService := RowanClassService forClassNamed: self servicesDefaultClassName.
	source := 'abc | abc | abc := 1. abc := abc + abc. ^abc'.
	classService saveMethodSource: source category: 'other'.
	self assert: (classService methodsNamed: #abc) size equals: 1.
	methodService := (classService methodsNamed: #abc) first.
	self assert: methodService source equals: source.
	methodService reformatSource.
	self assert: methodService reformatSource source equals: 'abc
  | abc |
  abc := 1.
  abc := abc + abc.
  ^ abc'
%

category: 'tests'
method: RowanMethodServiceTest
test_runMethodTest

	| methodService classService |
	self jadeiteIssueTested: #issue410 withTitle: 'Selecting class in Project Browser changes test status icons in SUnit Browser'.
	methodService := RowanMethodService new.
	methodService runTest: #test_matchingPattern inClassName: 'RowanAnsweringServiceTest'.
	self assert: methodService testResult equals: 'passed'.
	self createServicesTestTestClass.
	self loadServicesTestProject.
	classService := RowanClassService forClassNamed: self servicesDefaultTestClassName.
	classService saveMethodSource: 'testMethod1  self assert: false' category: 'failing test'.
	methodService runTest: #testMethod1 inClassName: self servicesDefaultTestClassName.
	self assert: methodService testResult equals: 'failure'.
	classService saveMethodSource: 'testMethod2  1 zork' category: 'failing test'.
	methodService runTest: #testMethod2 inClassName: self servicesDefaultTestClassName.
	self assert: methodService testResult equals: 'error'.
%

! Class implementation for 'RowanPackageServiceTest'

!		Instance methods for 'RowanPackageServiceTest'

category: 'tests'
method: RowanPackageServiceTest
test_classHierarchy

	"format for client is:
		#nil-> #(<class serviceA1> <class service A2) ...
		#<classService A1> -> #(<classService B1> <classService B2> ... )
		#<classService A2> -> #(<classService B3> <classService B4> ... )
		#<classService B1> -> #(<classService C1> <classService C2> ... )
		etc"

	| packageService objectClassService |

	self jadeiteIssueTested: #issue239 withTitle: 'long update times possible when selecting a package with `hierarchy` tab selected'.
	packageService := RowanPackageService forPackageNamed: 'Rowan-Tests'. 
	packageService classHierarchy. "<-- infinite recursion occured here"
	self assert: (packageService hierarchyServices at: #nil) size equals: 1. "duplicate Object services was the problem"
	objectClassService := (packageService hierarchyServices at: #nil) first.
	self assert: objectClassService name = 'Object'.
	self assert: ((packageService hierarchyServices at: objectClassService) detect:[:classService | classService name = 'TestAsserter'] ifNone: []) notNil.
	self assert: ((packageService hierarchyServices keys) detect:[:classService | (classService ~~ #nil) and: [classService name = 'TestCase']] ifNone: []) notNil.
%

category: 'tests'
method: RowanPackageServiceTest
test_compileAndSelectClass
  | package browserService |
  [ 
  self assert: RowanCommandResult results isEmpty.
  package := self createServicesTestPackage.
  self loadServicesTestProject.
  browserService := RowanBrowserService new.
  self assert: RowanCommandResult results isEmpty.
  browserService
    compileClass:
      'RowanServicesTest rwSubclass: ''RowanTestCompile'' 
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: ''' , self servicesTestPackageName
        ,
          '''
		options: #()'.
  self assert: RowanCommandResult results size equals: 0.	"we no longer return a service on first stage of compile"
  browserService recompileMethodsAfterClassCompilation.
  self assert: RowanCommandResult results size equals: 5.
  self
    assert: (RowanCommandResult results at: 4) name
    equals: 'RowanTestCompile'.
  self assert: browserService selectedClass name equals: 'RowanTestCompile' ]
    ensure: [ 
      Rowan projectTools browser removeClassNamed: 'RowanTestCompile'.
      self unloadServicesTestProject ]
%

category: 'tests'
method: RowanPackageServiceTest
test_compileAndSelectClassDifferentPackage
  | package browserService testsPackage |
  [ 
  self assert: RowanCommandResult results isEmpty.
  package := self createServicesTestPackage.
  browserService := RowanBrowserService new.
  self assert: RowanCommandResult results isEmpty.
  browserService
    compileClass:
      'RowanServicesTest rwSubclass: ''RowanTestCompile''
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: ''Rowan-Services-Tests''
		options: #()'.
  self assert: RowanCommandResult results size equals: 0.	"we no longer return a service on first stage of compile"
  browserService recompileMethodsAfterClassCompilation.
  self assert: RowanCommandResult results size equals: 5.
  self
    assert: (RowanCommandResult results at: 4) name
    equals: 'RowanTestCompile'.
  self
    assert: RowanCommandResult results first name
    equals: 'Rowan-Services-Tests'.
  testsPackage := RowanCommandResult results first.
  self assert: testsPackage selectedClass name equals: 'RowanTestCompile' ]
    ensure: [ 
      Rowan projectTools browser removeClassNamed: 'RowanTestCompile'.
      self unloadServicesTestProject ]
%

category: 'tests'
method: RowanPackageServiceTest
test_compileClassSelectsPackageAndClass
  | package browserService newClassService |
  self
    jadeiteIssueTested: #'issue228'
    withTitle: 'lose selected class in project browser when new version created'.
  package := self createServicesTestPackage.
  self loadServicesTestProject.
  [ 
  browserService := RowanBrowserService new.
  browserService
    compileClass:
      'RowanServicesTest rwSubclass: ''TestCompileClass''
			instVarNames: #()
			classVars: #()
			classInstVars: #()
			poolDictionaries: #()
			category: ''' , self servicesTestPackageName
        ,
          '''
			options: #()'.
  self assert: RowanCommandResult results size equals: 0.	"we no longer return a service on first stage of compile"
  browserService recompileMethodsAfterClassCompilation.
  newClassService := RowanCommandResult results at: 4.
  self assert: newClassService name equals: 'TestCompileClass' ]
    ensure: [ 
      RowanBrowserService new
        unloadProjectsNamed: (Array with: self servicesTestProjectName) ]
%

category: 'tests'
method: RowanPackageServiceTest
test_packageWasDeleted
  "NOTE - use commit/abort in tests carefully. 
	Can cause hard-to-diagnose problems later 
	in test runs"

  | packageService projectDef packageDef |
  self
    jadeiteIssueTested: #'issue284'
    withTitle:
      '(3.0.49 and 3.0.50) project browser not updated properly on reload of project'.
  projectDef := self defaultProjectDefinition.
  [ 
  System commitTransaction.	"commit project but not package"
  projectDef
    packageNamed: self servicesTestPackageName
    ifAbsent: [ 
      packageDef := RwPackageDefinition newNamed: self servicesTestPackageName.
      projectDef addPackage: packageDef ].
  Rowan projectTools load loadProjectDefinition: projectDef.
  packageService := RowanPackageService
    forPackageNamed: self servicesTestPackageName.
  self deny: packageService wasDeleted.
  System abortTransaction.
  self assert: packageService wasDeleted ]
    ensure: [ 
      self unloadServicesTestProject.
      System commitTransaction ]
%

category: 'tests'
method: RowanPackageServiceTest
test_testClassesIncludesExtensions
	| packageService testClassNames |
	self jadeiteIssueTested: #issue378 withTitle: '(3.0.53) test class not defined in package shows up in package of SUnit browser'.
	packageService := RowanPackageService forPackageNamed: 'Rowan-Services-Tests'.
	packageService testClasses. 
	testClassNames := packageService jadeite_testClasses collect:[:classService | classService name].
	self assert: (testClassNames includes: 'RwRowanProjectIssuesTest'). "extension tests"
	self assert: (testClassNames includes: 'RowanPackageServiceTest').

	packageService := RowanPackageService forPackageNamed: 'Rowan-Tests'.
	packageService testClasses. 
	testClassNames := packageService jadeite_testClasses collect:[:classService | classService name].
	self assert: (testClassNames includes: 'RwRowanProjectIssuesTest').
%

! Class implementation for 'RowanProjectServiceTest'

!		Instance methods for 'RowanProjectServiceTest'

category: 'support'
method: RowanProjectServiceTest
existingProjectNamed: projectName

	| projectService |
	projectService := RowanProjectService newNamed: projectName. 
	self assert: (Rowan image loadedProjectNamed: projectName) name equals: projectName.
	^projectService
%

category: 'support'
method: RowanProjectServiceTest
projectServiceNamed: projectName

	| projectService |
	projectService := RowanProjectService newNamed: projectName. 
	self assert: (Rowan image loadedProjectNamed: projectName) name equals: projectName.
	^projectService
%

category: 'setup teardown'
method: RowanProjectServiceTest
setUp
  super setUp.
  self loadServicesTestProject
%

category: 'setup teardown'
method: RowanProjectServiceTest
tearDown

	self unloadServicesTestProject.
	super tearDown.
%

category: 'tests'
method: RowanProjectServiceTest
test_addedProjectNotOnDisk

	| projectService projectName |
	projectName := 'Tashkent'. 
	self jadeiteIssueTested: #issue246 withTitle: 'Jadeite handling project that''s not committed'. 
	self createNonDiskTestProjectNamed:  projectName packageName: 'Packagekent'. 
	projectService := RowanProjectService newNamed: projectName. 
	projectService refresh. "<-- walkback occured here" 
	[self deny: projectService existsOnDisk.
	self deny: projectService isSkew "no skew if not on disk"]
		ensure: [RowanBrowserService new unloadProjectsNamed: (Array with: 'Tashkent')]
%

category: 'tests'
method: RowanProjectServiceTest
test_addPackage

	| projectService  packageName loadedPackage |
	packageName := 'TestAddPackage'.
	projectService := self projectServiceNamed: self servicesTestProjectName.
	projectService addPackageNamed: packageName.
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	self assert: loadedPackage name equals: packageName. 
	self assert: loadedPackage projectName equals: self servicesTestProjectName
%

category: 'tests'
method: RowanProjectServiceTest
test_commandResultSessionTemp

	self assert: RowanCommandResult results == (SessionTemps current at: #rowanCommandResults)
%

category: 'tests'
method: RowanProjectServiceTest
test_unloadNotLoadedProjectDoesNotWalkback

	"just make sure if a project we gracefully handle trying to remove an unloaded project"
	self deny: (Rowan image loadedProjectNamed: 'BadProjectName' ifAbsent:[false]). 
	RowanBrowserService new unloadProjectsNamed: #('BadProjectName').
	self deny: (Rowan image loadedProjectNamed: 'BadProjectName' ifAbsent:[false]).
%

category: 'tests'
method: RowanProjectServiceTest
test_updateAddsCommandResult
	| projectService |
	projectService := self projectServiceNamed: self servicesTestProjectName.
	RowanCommandResult initializeResults. 
	self assert: RowanCommandResult results size equals: 0. 
	projectService update. 
	self assert: RowanCommandResult results size equals: 1. 
	self assert: RowanCommandResult results first == projectService.
%

! Class implementation for 'RowanQueryServicesTest'

!		Instance methods for 'RowanQueryServicesTest'

category: 'tests'
method: RowanQueryServicesTest
test_dontUseFileStream
  | queryService results |
  self
    jadeiteIssueTested: #'issue611'
    withTitle: 'Use FileStreamPortable not FileStream'.
  queryService := RowanQueryService new.
  queryService organizer: ClassOrganizer new.
  queryService browseClassReferences: 'FileStream'.
  results := queryService queryResults.
  self assert: results size equals: 1.
  self assert: results first className equals: 'Stream'.
  self
    assert: results first selector
    equals: #'installStreamImplementationFrom:'
%

category: 'tests'
method: RowanQueryServicesTest
test_hierarchyImplementors

	| queryService hierarchyClassNames |
	queryService := RowanQueryService new organizer: ClassOrganizer new. 
	queryService hierarchyImplementorsOf: #isEmpty inClass: 'RwModification'.
	hierarchyClassNames := Array with: 'RwModification'. 
	hierarchyClassNames addAll: (RwModification allSuperclasses collect:[:cls | cls name asString]).
	hierarchyClassNames addAll: (RwModification subclasses collect:[:cls | cls name asString]). 
	queryService queryResults do:[:methodService |
		self assert: methodService selector equals: #isEmpty.
		self assert: (hierarchyClassNames includes: methodService className asString)].
%

category: 'tests'
method: RowanQueryServicesTest
test_hierarchyImplementorsGetsAllSubclasses
	"was missing subclasses of subclasses" 

	| queryService subclassesImplementing |
	self jadeiteIssueTested: #issue242 withTitle: '`implementors in hierarchy` doesn''t include method in the currently selected class?'.
	queryService := RowanQueryService new organizer: ClassOrganizer new. 
	queryService hierarchyImplementorsOf: #initialize inClass: 'RwLoadedThing'.
	subclassesImplementing := Array new. 
	queryService queryResults do:[:methodService |
		| classService |
		self assert: methodService selector equals: #initialize.
		classService := RowanClassService forClassNamed: methodService className.
		subclassesImplementing add:  methodService className.
		classService classHierarchy. 
		self assert: (classService classHierarchyNames includes: 'RwLoadedThing')].
	self assert: (subclassesImplementing includes: 'RwLoadedThing'). 
	self assert: (subclassesImplementing includes: 'RwLoadedProject'). 
	self assert: (subclassesImplementing includes: 'RwGsLoadedSymbolDictPackage'). 
	self assert: (subclassesImplementing includes: 'RwGsLoadedSymbolDictClass'). 
	self assert: (subclassesImplementing includes: 'RwGsLoadedSymbolDictClassExtension').
%

category: 'tests'
method: RowanQueryServicesTest
test_hierarchySenders

	| queryService hierarchyClassNames |
	queryService := RowanQueryService new organizer: ClassOrganizer new. 
	queryService hierarchySendersOf: #isEmpty inClass: 'RwModification'.
	hierarchyClassNames := Array with: 'RwModification'. 
	hierarchyClassNames addAll: (RwModification allSuperclasses collect:[:cls | cls name asString]).
	hierarchyClassNames addAll: (RwModification allSubclasses collect:[:cls | cls name asString]). 
	queryService queryResults do:[:methodService |
		self assert: (methodService source includesString: 'isEmpty').
		self assert: (hierarchyClassNames includes: methodService className asString)].
%

category: 'tests'
method: RowanQueryServicesTest
test_implementors

	| queryService |
	queryService := RowanQueryService new organizer: ClassOrganizer new. 
	queryService implementorsOf: #size.
	queryService queryResults do:[:methodService |
		self assert: methodService selector equals: #size.].
%

category: 'tests'
method: RowanQueryServicesTest
test_projectLog

	| queryService result |
	queryService := RowanQueryService new.
	queryService projectLog: 'Rowan'. 
	result := RowanCommandResult results first. 
	self assert: (result isKindOf: RowanQueryService). 
	self assert: (result queryResults isKindOf: String)
%

category: 'tests'
method: RowanQueryServicesTest
test_senders

	| queryService |
	queryService := RowanQueryService new organizer: ClassOrganizer new. 
	queryService sendersOf: #isEmpty.
	queryService queryResults do:[:methodService |
		self assert: (methodService source includesString: 'isEmpty')].
%

! Class implementation for 'RwAbstractTest'

!		Class methods for 'RwAbstractTest'

category: 'cleanup'
classmethod: RwAbstractTest
cleanup
	"self cleanup"

	| user symListP symListT dictP dictT index |
	user := System myUserProfile.
	symListP := user symbolList.
	symListT := GsCurrentSession currentSession symbolList.
	self _symbolDictionaryNames
		do: [ :symDictName | 
			dictP := symListP
				detect: [ :each | (each at: symDictName ifAbsent: [ nil ]) == each ]
				ifNone: [  ].
			dictP
				ifNotNil: [ 
					(dictP at: GsPackagePolicy globalName otherwise: nil)
						ifNotNil: [ :policy | policy disable ].
					index := symListP indexOf: dictP.
					index > 0
						ifTrue: [ user removeDictionaryAt: index ] ].
			dictT := symListT
				detect: [ :each | (each at: symDictName ifAbsent: [ nil ]) == each ]
				ifNone: [  ].
			dictT
				ifNotNil: [ 
					(dictT at: GsPackagePolicy globalName otherwise: nil)
						ifNotNil: [ :policy | policy disable ].
					index := symListT indexOf: dictT.
					index > 0
						ifTrue: [ symListT removeAtIndex: index ] ] ].
	GsPackagePolicy current refreshSessionMethodDictionary.
	ClassOrganizer clearCachedOrganizer
%

category: 'private'
classmethod: RwAbstractTest
_symbolDictionaryName

	^ #'CypressTestData'
%

category: 'private'
classmethod: RwAbstractTest
_symbolDictionaryName1

	^ #'RowanTestData'
%

category: 'private'
classmethod: RwAbstractTest
_symbolDictionaryName2

	^ #'RowanTestData2'
%

category: 'private'
classmethod: RwAbstractTest
_symbolDictionaryNames

	^ 	{(self _symbolDictionaryName).
		(self _symbolDictionaryName1).
		(self _symbolDictionaryName2).
		(self _unmanagedDictionaryName)}
%

category: 'private'
classmethod: RwAbstractTest
_testRowanProjectsSandbox
	"working repository for use as ROWAN_PROJECTS_HOME for tests"

	| rowanProject |
	(System gemEnvironmentVariable: 'ROWAN_PROJECTS_SANDBOX')
		ifNotNil: [ :sandboxPath | ^ sandboxPath asFileReference ].
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ rowanProject repositoryRoot / 'test/testRepositories/repos/'
%

category: 'private'
classmethod: RwAbstractTest
_unmanagedDictionaryName

	^ #'UnmanagedPackages'
%

!		Instance methods for 'RwAbstractTest'

category: 'support'
method: RwAbstractTest
assertAbsenceOfPackage: packageName

	| loadedPackage symbolDict |
	symbolDict := Rowan image
		newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName.
	loadedPackage := symbolDict rowanSymbolDictionaryRegistry
		loadedPackageNamed: packageName
		ifAbsent: [  ].
	self assert: loadedPackage equals: nil
%

category: 'support'
method: RwAbstractTest
classDefinition: className super: superClassName category: category inPackage: packageName

	^ Dictionary new
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: superClassName
								category: category
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support'
method: RwAbstractTest
classDefinition: className super: superClassName classVars: classVars inPackage: packageName

	^ Dictionary new
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: superClassName
								classVars: classVars
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support'
method: RwAbstractTest
classDefinition: className super: superClassName comment: comment inPackage: packageName

	^ Dictionary new
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: superClassName
								comment: comment
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support'
method: RwAbstractTest
classDefinition: className super: superClassName inPackage: packageName

	^ Dictionary new
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: superClassName
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support'
method: RwAbstractTest
classDefinition: className super: superClassName instanceMethods: instanceMethods classMethods: classMethods inPackage: packageName

	^ Dictionary new
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: superClassName
								inPackage: packageName)
						classMethodDefinitions: classMethods
						instanceMethodDefinitions: instanceMethods);
		yourself
%

category: 'support'
method: RwAbstractTest
classDefinition: className super: superClassName instVars: instVars inPackage: packageName

	^ Dictionary new
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: superClassName
								instVars: instVars
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support'
method: RwAbstractTest
classExtensionDefinition: className instanceMethods: instanceMethods classMethods: classMethods

	^ Dictionary new
		at: className
			put:
				(RwClassExtensionDefinition
						withProperties: (self propertiesForClassExtensionNamed: className)
						classMethodDefinitions: classMethods
						instanceMethodDefinitions: instanceMethods);
		yourself
%

category: 'private'
method: RwAbstractTest
gsInteractionConfirmationHandler

	^ GsInteractionHandler new
		defaultBlock: [ :ignored | self assert: false description: 'expected a confirmation' ];
		confirmBlock: [ :interaction | interaction ok ];
		yourself
%

category: 'private'
method: RwAbstractTest
gsInteractionInformHandler: interactionBlock

	^ GsInteractionHandler new
		defaultBlock: [ :ignored | self assert: false description: 'expected an inform' ];
		informBlock: interactionBlock;
		yourself
%

category: 'private'
method: RwAbstractTest
handleConfirmationDuring: aBlock

	"expect a confirmation"

	aBlock
		on: GsInteractionRequest
		do: [ :ex | 
			ex
				response:
					(ex interaction interactWith: self gsInteractionConfirmationHandler) ]
%

category: 'private'
method: RwAbstractTest
handleInformDuring: aBlock interactionBlock: interactionBlock

	"expect a confirmation"

	aBlock
		on: GsInteractionRequest
		do: [ :ex | 
			ex
				response:
					(ex interaction interactWith: (self gsInteractionInformHandler: interactionBlock)) ]
%

category: 'support'
method: RwAbstractTest
methodDefsFromSpec: specArray
  | dict |
  dict := Dictionary new.
  specArray
    do: [ :spec | 
      | selector protocol source |
      selector := (spec at: 1) asSymbol.
      protocol := (spec at: 2) asString.
      source := (spec at: 3) asString.
      dict
        at: selector
        put:
          (RwMethodDefinition
            withProperties:
              (Dictionary with: 'selector' -> selector with: 'protocol' -> protocol)
            source: source) ].
  ^ dict
%

category: 'support'
method: RwAbstractTest
packageDefinition: packageName

	^ RwPackageDefinition
		withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
		classDefinitions: Dictionary new
		classExtensions: Dictionary new
%

category: 'support'
method: RwAbstractTest
packageDefinition: packageName classNamed: className super: superClassName

	^ RwPackageDefinition
		withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
		classDefinitions:
			(self classDefinition: className super: superClassName inPackage: packageName)
		classExtensions: Dictionary new
%

category: 'support'
method: RwAbstractTest
packageDefinition: packageName classNamed: className super: superClassName category: category

	^ RwPackageDefinition
		withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
		classDefinitions:
			(self
				classDefinition: className
				super: superClassName
				category: category
				inPackage: packageName)
		classExtensions: Dictionary new
%

category: 'support'
method: RwAbstractTest
packageDefinition: packageName classNamed: className super: superClassName classVars: classVars

	^ RwPackageDefinition
		withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
		classDefinitions:
			(self
				classDefinition: className
				super: superClassName
				classVars: classVars
				inPackage: packageName)
		classExtensions: Dictionary new
%

category: 'support'
method: RwAbstractTest
packageDefinition: packageName classNamed: className super: superClassName comment: comment

	^ RwPackageDefinition
		withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
		classDefinitions:
			(self
				classDefinition: className
				super: superClassName
				comment: comment
				inPackage: packageName)
		classExtensions: Dictionary new
%

category: 'support'
method: RwAbstractTest
packageDefinition: packageName classNamed: className super: superClassName instanceMethods: instanceMethods classMethods: classMethods

	^ RwPackageDefinition
		withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
		classDefinitions:
			(self
				classDefinition: className
				super: superClassName
				instanceMethods: instanceMethods
				classMethods: classMethods
				inPackage: packageName)
		classExtensions: Dictionary new
%

category: 'support'
method: RwAbstractTest
packageDefinition: packageName classNamed: className super: superClassName instVars: instVars

	^ RwPackageDefinition
		withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
		classDefinitions:
			(self
				classDefinition: className
				super: superClassName
				instVars: instVars
				inPackage: packageName)
		classExtensions: Dictionary new
%

category: 'support'
method: RwAbstractTest
packageDefinition: packageName extendClassNamed: className instanceMethods: instanceMethods classMethods: classMethods

	^ RwPackageDefinition
		withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
		classDefinitions: Dictionary new
		classExtensions:
			(self
				classExtensionDefinition: className
				instanceMethods: instanceMethods
				classMethods: classMethods)
%

category: 'support'
method: RwAbstractTest
packageSetDefinition: packageName

	^ (RwPackageSetDefinition new addPackage: (self packageDefinition: packageName))
		asDefinition
%

category: 'support'
method: RwAbstractTest
packageSetDefinition: packageName classNamed: className super: superClassName

	^ (RwPackageSetDefinition new
		addPackage:
			(self packageDefinition: packageName classNamed: className super: superClassName))
		asDefinition
%

category: 'support'
method: RwAbstractTest
packageSetDefinition: packageName classNamed: className super: superClassName category: category

	^ (RwPackageSetDefinition new
		addPackage:
			(self
				packageDefinition: packageName
				classNamed: className
				super: superClassName
				category: category))
		asDefinition
%

category: 'support'
method: RwAbstractTest
packageSetDefinition: packageName classNamed: className super: superClassName classVars: classVars

	^ (RwPackageSetDefinition new
		addPackage:
			(self
				packageDefinition: packageName
				classNamed: className
				super: superClassName
				classVars: classVars))
		asDefinition
%

category: 'support'
method: RwAbstractTest
packageSetDefinition: packageName classNamed: className super: superClassName comment: comment

	^ (RwPackageSetDefinition new
		addPackage:
			(self
				packageDefinition: packageName
				classNamed: className
				super: superClassName
				comment: comment))
		asDefinition
%

category: 'support'
method: RwAbstractTest
packageSetDefinition: packageName classNamed: className super: superClassName instanceMethods: instanceMethods classMethods: classMethods

	^ (RwPackageSetDefinition new
		addPackage:
			(self
				packageDefinition: packageName
				classNamed: className
				super: superClassName
				instanceMethods: instanceMethods
				classMethods: classMethods))
		asDefinition
%

category: 'support'
method: RwAbstractTest
packageSetDefinition: packageName classNamed: className super: superClassName instVars: instVars

	^ (RwPackageSetDefinition new
		addPackage:
			(self
				packageDefinition: packageName
				classNamed: className
				super: superClassName
				instVars: instVars))
		asDefinition
%

category: 'support'
method: RwAbstractTest
packageSetDefinition: packageName extendClassNamed: className instanceMethods: instanceMethods classMethods: classMethods

	^ (RwPackageSetDefinition new
		addPackage:
			(self
				packageDefinition: packageName
				extendClassNamed: className
				instanceMethods: instanceMethods
				classMethods: classMethods))
		asDefinition
%

category: 'support'
method: RwAbstractTest
propertiesForClassExtensionNamed: className

	| dict |
	dict := Dictionary new.
	dict
		at: 'name' put: className;
		yourself.
	^ dict
%

category: 'support'
method: RwAbstractTest
propertiesForClassNamed: className super: superClassName category: category inPackage: packageName

	^ self
		propertiesForClassNamed: className
		super: superClassName
		instvars: {}
		classinstvars: {}
		classvars: {}
		category: category
		comment: nil
		gs_SymbolDictionary: self _symbolDictionaryName asString
		pools: {}
		type: 'normal'
		gs_options: {}
		inPackage: packageName
%

category: 'support'
method: RwAbstractTest
propertiesForClassNamed: className super: superClassName classVars: classVars inPackage: packageName

	^ self
		propertiesForClassNamed: className
		super: superClassName
		instvars: {}
		classinstvars: {}
		classvars: classVars
		category: nil
		comment: nil
		gs_SymbolDictionary: self _symbolDictionaryName asString
		pools: {}
		type: 'normal'
		gs_options: {}
		inPackage: packageName
%

category: 'support'
method: RwAbstractTest
propertiesForClassNamed: className super: superClassName comment: comment inPackage: packageName

	^ self
		propertiesForClassNamed: className
		super: superClassName
		instvars: {}
		classinstvars: {}
		classvars: {}
		category: nil
		comment: comment
		gs_SymbolDictionary: self _symbolDictionaryName asString
		pools: {}
		type: 'normal'
		gs_options: {}
		inPackage: packageName
%

category: 'support'
method: RwAbstractTest
propertiesForClassNamed: className super: superClassName inPackage: packageName

	^ self
		propertiesForClassNamed: className
		super: superClassName
		instvars: {}
		classinstvars: {}
		classvars: {}
		category: nil
		comment: nil
		gs_SymbolDictionary: self _symbolDictionaryName asString
		pools: {}
		type: 'normal'
		gs_options: {}
		inPackage: packageName
%

category: 'support'
method: RwAbstractTest
propertiesForClassNamed: className super: superClassName instvars: instvars classinstvars: classinstvars classvars: classvars category: category comment: comment gs_SymbolDictionary: gs_SymbolDictionary pools: pools type: type gs_options: gs_options inPackage: packageName

	| dict |
	dict := Dictionary new.
	category
		ifNotNil: [ 
			dict
				at: 'category' put: category;
				yourself ].
	dict
		at: 'classinstvars' put: classinstvars;
		at: 'classvars' put: classvars;
		at: 'gs_SymbolDictionary' put: gs_SymbolDictionary;
		at: 'instvars' put: instvars;
		at: 'name' put: className;
		at: 'pools' put: pools;
		at: 'superclass' put: superClassName;
		at: 'type' put: type.
	comment ifNotNil: [ dict at: 'comment' put: comment ].
	(gs_options _isArray and: [ gs_options isEmpty not ])
		ifTrue: [ 
			dict
				at: 'gs_options'
				put:
					(gs_options collect: [ :each | each asString ]) asSortedCollection asArray ].
	^ dict
%

category: 'support'
method: RwAbstractTest
propertiesForClassNamed: className super: superClassName instvars: instvars classinstvars: classinstvars classvars: classvars comment: comment gs_SymbolDictionary: gs_SymbolDictionary pools: pools type: type gs_options: gs_options inPackage: packageName

	^ self
		propertiesForClassNamed: className
		super: superClassName
		instvars: instvars
		classinstvars: classinstvars
		classvars: classvars
		category: packageName
		comment: comment
		gs_SymbolDictionary: gs_SymbolDictionary
		pools: pools
		type: type
		gs_options: gs_options
		inPackage: packageName
%

category: 'support'
method: RwAbstractTest
propertiesForClassNamed: className super: superClassName instVars: instVars inPackage: packageName

	^ self
		propertiesForClassNamed: className
		super: superClassName
		instvars: instVars
		classinstvars: {}
		classvars: {}
		category: nil
		comment: nil
		gs_SymbolDictionary: self _symbolDictionaryName asString
		pools: {}
		type: 'normal'
		gs_options: {}
		inPackage: packageName
%

category: 'running'
method: RwAbstractTest
setUp

	super setUp.
	self class cleanup.

	Rowan platform _alternateImageClass: Rowan image testImageClass
%

category: 'running'
method: RwAbstractTest
tearDown

	super tearDown.
	Rowan platform _alternateImageClass: nil.
	self class cleanup.
%

category: 'private'
method: RwAbstractTest
_classvars

	^ #('ClassVar1')
%

category: 'private'
method: RwAbstractTest
_loadedPackageDefinitionsNamed: someNames

	"Answer a PackageSetDefinition containing packages with the given names in the image.
 	If any name is not a loaded package, that name is ignored."

	^ (self _loadedPackagesNamed: someNames) asPackageDefinitionSet
%

category: 'private'
method: RwAbstractTest
_loadedPackagesNamed: someNames

	"Answer a PackageSet containing packages with the given names in the image.
 	If any name is not a loaded package, that name is ignored."

	"very likely we should be dealing with a project name 
at this point ... unless there is a use case for loading a collection of packages without directly using the project interface --- loaded packages do know what project they belong to ... so there might be something done behind the scenes"

	| loadedPackages |
	loadedPackages := someNames
		collect: [ :aName | Rowan image loadedPackageNamed: aName ifAbsent: [ nil ] ].
	^ RwEntitySet withAll: (loadedPackages select: [ :each | each notNil ])
%

category: 'private'
method: RwAbstractTest
_loadedProjectsNamed: someNames

	"Answer a RwProjectSetDefinition containing projects with the given names in the image.
 	If any name is not a loaded project, that name is ignored."

	| loadedProjects |
	loadedProjects := someNames
		collect: [ :aName | Rowan image loadedProjectNamed: aName ifAbsent: [ nil ] ].
	^ RwEntitySet withAll: (loadedProjects select: [ :each | each notNil ])
%

category: 'private'
method: RwAbstractTest
_symbolDictionary

	^ Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName
%

category: 'private'
method: RwAbstractTest
_symbolDictionaryName

	^ self class _symbolDictionaryName
%

category: 'private'
method: RwAbstractTest
_symbolDictionaryName1

	^ self class _symbolDictionaryName1
%

category: 'private'
method: RwAbstractTest
_symbolDictionaryName2

	^ self class _symbolDictionaryName2
%

category: 'private'
method: RwAbstractTest
_testRowanProjectsSandbox
	"working repository for use as ROWAN_PROJECTS_HOME for tests"

	^ self class _testRowanProjectsSandbox
%

category: 'private'
method: RwAbstractTest
_unmanagedDictionaryName

	^ self class _unmanagedDictionaryName
%

! Class implementation for 'RwAbstractV2Test'

!		Class methods for 'RwAbstractV2Test'

category: 'private'
classmethod: RwAbstractV2Test
_sampleSymbolDictionaryName1

	^ #'RowanSample9_1'
%

category: 'private'
classmethod: RwAbstractV2Test
_sampleSymbolDictionaryName2

	^ #'RowanSample9_2'
%

category: 'private'
classmethod: RwAbstractV2Test
_sampleSymbolDictionaryName3

	^ #'RowanSample9_3'
%

category: 'private'
classmethod: RwAbstractV2Test
_sampleSymbolDictionaryName4

	^ #'RowanSample9_4'
%

category: 'private'
classmethod: RwAbstractV2Test
_symbolDictionaryNames
	^ super _symbolDictionaryNames
		,
			{(self _sampleSymbolDictionaryName1).
			(self _sampleSymbolDictionaryName2).
			(self _sampleSymbolDictionaryName3).
			(self _sampleSymbolDictionaryName4)}
%

!		Instance methods for 'RwAbstractV2Test'

category: 'running'
method: RwAbstractV2Test
setUp
	| projectsHome |
	super setUp.
	projectsHome := self _testRowanProjectsSandbox.
	self _specListProjectNames
		do: [ :name | 
			Rowan
				projectNamed: name
				ifPresent: [ :prj | Rowan image _removeLoadedProject: prj _loadedProject ].
			self _deleteProjectRepositoryDir
				ifTrue: [ (projectsHome / name) ensureDeleteAll ] ]
%

category: 'running'
method: RwAbstractV2Test
tearDown
	super tearDown.
	self _specListProjectNames
		do: [ :name | 
			Rowan
				projectNamed: name
				ifPresent: [ :prj | Rowan image _removeLoadedProject: prj _loadedProject ] ]
%

category: 'private'
method: RwAbstractV2Test
_addCanonicalRowanSample9ProjectDefinitionsTo: resolvedProject
	| projectName packageName className |
	projectName := resolvedProject projectName.
	resolvedProject
		comment: 'Project created using the V2 project creation api ';
		addComponentNamed: 'Core'
			definedGroupNames:
				(Dictionary new
						add: 'core' -> {};
						add: 'tests' -> {'core'};
						yourself)
			comment: 'Primary component used for loading the system.';
		addPackagesNamed: {(projectName , '-Core')}
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'core';
		addPackageNamed: projectName , '-Tests'
			toComponentNamed: 'Core'
			withConditions: {'common'}
			andGroupName: 'tests';
		addPackageNamed: projectName , '-GemStone-Extensions'
			toComponentNamed: 'Core'
			withConditions: {'gemstone'}
			andGroupName: 'core'
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'Globals';
		addPackageNamed: projectName , '-GemStone-Tests'
			toComponentNamed: 'Core'
			withConditions: {'gemstone'}
			andGroupName: 'tests';
		yourself.
	packageName := projectName , '-Core'.
	className := projectName , 'Class1'.
	((resolvedProject packageNamed: packageName)
		addClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		category: packageName
		comment: 'I am an example class')
		addInstanceMethod: 'foo ^1' protocol: 'accessing';
		yourself.
	packageName := projectName , '-Tests'.
	((resolvedProject packageNamed: packageName)
		addClassNamed: projectName , 'TestCase'
		super: 'TestCase'
		category: packageName
		comment: 'I test the example class')
		addInstanceMethod: 'test  self assert: ' , className , ' new foo = 1'
			protocol: 'tests';
		yourself.
	packageName := projectName , '-GemStone-Extensions'.
	className := projectName , 'RcCounter'.
	((resolvedProject packageNamed: packageName)
		addClassNamed: className
		super: 'RcCounter'
		category: packageName
		comment: 'I am an example GemStone class')
		addClassMethod: 'foo ^1' protocol: 'accessing';
		yourself.
	packageName := projectName , '-GemStone-Tests'.
	((resolvedProject packageNamed: packageName)
		addClassNamed: projectName , 'GsTestCase'
		super: 'TestCase'
		category: packageName
		comment: 'I test the example GemStone class')
		addInstanceMethod: 'test  self assert: ' , className , ' foo = 1'
			protocol: 'tests';
		yourself.
	resolvedProject components do: [ :component | self assert: component validate ].
	self assert: resolvedProject _validate.
	^ resolvedProject
%

category: 'private'
method: RwAbstractV2Test
_canonicalRowanSample9ProjectFor: projectName
	| loadSpecification projectDefinition |
	loadSpecification := RwProjectSpecificationV2 new
		projectName: projectName;
		gemstoneSetDefaultSymbolDictNameTo: self _sampleSymbolDictionaryName1;
		gemstoneSetDefaultUseSessionMethodsForExtensionsTo: false;
		gemstoneSetDefaultMethodEnvTo: 0;
		yourself.
	projectDefinition := (loadSpecification resolve: self _testRowanProjectsSandbox)
		projectNamed: projectName.
	^ self _addCanonicalRowanSample9ProjectDefinitionsTo: projectDefinition
%

category: 'private'
method: RwAbstractV2Test
_deleteProjectRepositoryDir
	^ true
%

category: 'private'
method: RwAbstractV2Test
_sampleSymbolDictionaryName1

	^ self class _sampleSymbolDictionaryName1
%

category: 'private'
method: RwAbstractV2Test
_sampleSymbolDictionaryName2

	^ self class _sampleSymbolDictionaryName2
%

category: 'private'
method: RwAbstractV2Test
_sampleSymbolDictionaryName3

	^ self class _sampleSymbolDictionaryName3
%

category: 'private'
method: RwAbstractV2Test
_sampleSymbolDictionaryName4

	^ self class _sampleSymbolDictionaryName4
%

category: 'private'
method: RwAbstractV2Test
_specListProjectNames
	^ {'RowanSample9'.
	'RowanSample9_Test'.
	'RowanSample10'.
	'RowanSample11'}
%

category: 'private'
method: RwAbstractV2Test
_validateCanonicalRowanSample9ProjectFor: resolvedProject
	| repositoryRoot projectName |
	projectName := resolvedProject projectName.
	repositoryRoot := resolvedProject repositoryRoot.
	{repositoryRoot.
	(repositoryRoot / resolvedProject projectSpecFile).
	(resolvedProject componentsRoot).
	(resolvedProject componentsRoot / 'Core.ston').
	(resolvedProject packagesRoot).
	(resolvedProject packagesRoot / (projectName , '-Core')).
	(resolvedProject packagesRoot / (projectName , '-Core')
		/ (projectName , 'Class1.class.st')).
	(resolvedProject packagesRoot / (projectName , '-GemStone-Extensions')).
	(resolvedProject packagesRoot / (projectName , '-GemStone-Extensions')
		/ (projectName , 'RcCounter.class.st')).
	(resolvedProject packagesRoot / (projectName , '-GemStone-Tests')).
	(resolvedProject packagesRoot / (projectName , '-GemStone-Tests')
		/ (projectName , 'GsTestCase.class.st')).
	(resolvedProject packagesRoot / (projectName , '-Tests')).
	(resolvedProject packagesRoot / (projectName , '-Tests')
		/ (projectName , 'TestCase.class.st')).
	(resolvedProject specsRoot).
	(resolvedProject specsRoot / resolvedProject projectAlias , 'ston').
	(resolvedProject projectsRoot)} do: [ :fileRef | self assert: fileRef exists ]
%

! Class implementation for 'RwResolvedProjectV2Test'

!		Instance methods for 'RwResolvedProjectV2Test'

category: 'tests'
method: RwResolvedProjectV2Test
testBasic
	"Create project ... without errors"

	| projectName projectAlias project stonString  |
	projectName := 'RowanSample9'.
	projectAlias := projectName , '_Test'.
	project := RwResolvedProjectV2 new
		projectName: projectName;
		projectAlias: projectAlias;
		projectsHome: self _testRowanProjectsSandbox;
		gemstoneSetDefaultSymbolDictNameTo: self _sampleSymbolDictionaryName1;
		yourself.

	self assert: project _validate.

	project resolve.
	self _addCanonicalRowanSample9ProjectDefinitionsTo: project.
	stonString := STON toStringPretty: project	"useful to view full structure"
%

category: 'tests'
method: RwResolvedProjectV2Test
testBasicResolve_1
	"excercise basic functionality"

	| project projectName projectAlias stonString projectsHome expectedRepositoryRoot
		 resolvedProjectSpecification projectSpecification loadSpecification resolvedLoadSpecification|
	projectName := 'RowanSample9'.
	projectAlias := projectName , '_Test'.
	projectsHome := self _testRowanProjectsSandbox.
	expectedRepositoryRoot := projectsHome / projectAlias.

	self deny: expectedRepositoryRoot exists.

	project := RwResolvedProjectV2 new
		projectName: projectName;
		projectAlias: projectAlias;
		projectsHome: projectsHome;
		gemstoneSetDefaultSymbolDictNameTo: self _sampleSymbolDictionaryName1;
		yourself.
	projectSpecification := project _projectSpecification.
	loadSpecification := project _loadSpecification.
	self assert: project _validate.

	project resolve.

	self assert: expectedRepositoryRoot exists.
	stonString := STON toStringPretty: project.	"useful in case of error"

	resolvedProjectSpecification := project _projectSpecification.
	resolvedLoadSpecification := project _loadSpecification.
	self assert: project packageNames isEmpty.
	self assert: resolvedProjectSpecification = projectSpecification.
	self assert: resolvedProjectSpecification == projectSpecification.
	self assert: resolvedLoadSpecification = loadSpecification.
	self assert: resolvedLoadSpecification == loadSpecification.	"did not originate project with a loadSpecification so identity is expected"
%

category: 'tests'
method: RwResolvedProjectV2Test
testBasicResolve_2
	"excercise basic functionality"

	"no project alias"

	| project projectName stonString projectsHome expectedRepositoryRoot
		 resolvedProjectSpecification projectSpecification|
	projectName := 'RowanSample9'.
	projectsHome := self _testRowanProjectsSandbox.
	expectedRepositoryRoot := projectsHome / projectName.

	self deny: expectedRepositoryRoot exists.

	project := RwResolvedProjectV2 new
		projectName: projectName;
		projectsHome: projectsHome;
		gemstoneSetDefaultSymbolDictNameTo: self _sampleSymbolDictionaryName1;
		yourself.
	projectSpecification := project _projectSpecification.
	self assert: project _validate.

	project resolve.

	self assert: expectedRepositoryRoot exists.
	stonString := STON toStringPretty: project.	"useful in case of error"

	resolvedProjectSpecification := project _projectSpecification.
	self assert: project packageNames isEmpty.
	self assert: resolvedProjectSpecification = projectSpecification.
%

category: 'tests'
method: RwResolvedProjectV2Test
testBasicResolve_git
	"Create git repository on resolve"

	| projectName projectsHome resolvedProject expectedRepositoryRoot stonString |
	projectName := 'RowanSample9'.
	projectsHome := self _testRowanProjectsSandbox.
	expectedRepositoryRoot := projectsHome / projectName.

	self deny: expectedRepositoryRoot exists.

	resolvedProject := RwResolvedProjectV2 new
		projectName: projectName;
		projectsHome: projectsHome;
		gemstoneSetDefaultSymbolDictNameTo: self _sampleSymbolDictionaryName1;
		repoType: #'git';
		yourself.

	resolvedProject resolve.
	stonString := STON toStringPretty: resolvedProject.

	self assert: expectedRepositoryRoot exists.
	self assert: (expectedRepositoryRoot / '.git') exists
%

category: 'tests'
method: RwResolvedProjectV2Test
testCreateNewDiskProject
	| projectName projectAlias projectSpecification stonString projectsHome projectRoot informed resolvedProject resolvedRepository resolvedRepositoryCopy x |
	projectName := 'RowanSample9'.
	projectAlias := projectName , '_Test'.
	projectsHome := self _testRowanProjectsSandbox.
	projectRoot := projectsHome / projectAlias.

	projectSpecification := RwResolvedProjectV2 new
		projectName: projectName;
		projectAlias: projectAlias;
		projectsHome: projectsHome;
		gemstoneSetDefaultSymbolDictNameTo: self _sampleSymbolDictionaryName1;
		diskUrl: 'file://' , projectRoot pathString;
		yourself.

	self deny: projectRoot exists.

	resolvedProject := projectSpecification resolve.
	self _addCanonicalRowanSample9ProjectDefinitionsTo: resolvedProject.
	stonString := STON toStringPretty: resolvedProject.	"useful in case of error"

	resolvedProject
		export;
		exportLoadSpecification.

	informed := false.
	self
		handleInformDuring: [ resolvedProject commit: 'first commit' ]
		interactionBlock: [ :inform | informed := true ].
	self assert: informed description: 'expected an inform'.

	self _validateCanonicalRowanSample9ProjectFor: resolvedProject.

	self
		assert:
			(x := RwDiskRepositoryDefinitionV2 allInstVarNames)
				= #(#'properties' #'projectsHome' #'repositoryRoot' #'repositoryUrl').	"If inst vars don't match, copy and hash methods have to change"

	resolvedRepository := resolvedProject _projectRepository.
	resolvedRepositoryCopy := resolvedRepository copy.

	self assert: resolvedRepository = resolvedRepositoryCopy.
	self assert: resolvedRepository ~~ resolvedRepositoryCopy
%

category: 'tests'
method: RwResolvedProjectV2Test
testCreateNewGitProject
	| projectName projectAlias projectSpecification stonString resolvedProject projectsHome projectRoot resolvedRepository resolvedRepositoryCopy x |
	projectName := 'RowanSample9'.
	projectAlias := projectName , '_Test'.
	projectsHome := self _testRowanProjectsSandbox.
	projectRoot := projectsHome / projectAlias.

	projectSpecification := RwResolvedProjectV2 new
		projectName: projectName;
		projectAlias: projectAlias;
		projectsHome: projectsHome;
		gemstoneSetDefaultSymbolDictNameTo: self _sampleSymbolDictionaryName1;
		gitUrl: 'file://' , projectRoot pathString;
		yourself.

	self deny: projectRoot exists.

	resolvedProject := projectSpecification resolve.
	self _addCanonicalRowanSample9ProjectDefinitionsTo: resolvedProject.
	stonString := STON toStringPretty: resolvedProject.	"useful in case of error"

	resolvedProject
		export;
		exportLoadSpecification;
		commit: 'first commit'.

	self _validateCanonicalRowanSample9ProjectFor: resolvedProject.
	self
		assert:
			(Rowan projectTools git gitPresentIn: resolvedProject repositoryRoot pathString).

	self
		assert:
			(x := RwGitRepositoryDefinitionV2 allInstVarNames)
				=
					#(#'properties' #'projectsHome' #'repositoryRoot' #'repositoryUrl' #'remote' #'remoteUrl' #'committish').	"If inst vars don't match, copy and hash methods have to change"

	resolvedRepository := resolvedProject _projectRepository.
	resolvedRepositoryCopy := resolvedRepository copy.

	self assert: resolvedRepository = resolvedRepositoryCopy.
	self assert: resolvedRepository ~~ resolvedRepositoryCopy
%

! Class implementation for 'RwRowanSample9Test'

!		Class methods for 'RwRowanSample9Test'

category: 'private'
classmethod: RwRowanSample9Test
_clearLoadSpecSessionCache
	"self _clearLoadSpecSessionCache"

	SessionTemps current removeKey: self _loadSpecSessionCacheKey ifAbsent: [  ].
	SessionTemps current removeKey: self _gitPullSessionCacheKey ifAbsent: [  ]
%

category: 'private'
classmethod: RwRowanSample9Test
_gitPullSessionCacheKey
	^ #'RowanSample9GitBranchDict'
%

category: 'private'
classmethod: RwRowanSample9Test
_loadSpecSessionCacheKey
	^ #'RowanSample9LoadSpecsDict'
%

!		Instance methods for 'RwRowanSample9Test'

category: 'tests'
method: RwRowanSample9Test
testIndexCards
	| projectSpecification indexCards specsDir projectSpecs resolvedProjects |
	projectSpecification := self _rowanSample9_0000_load_spec.
	projectSpecification repositoryRoot ensureDeleteAll.
	projectSpecification revision: 'master'.
	projectSpecification resolveStrict.

	indexCards := (projectSpecification repositoryRoot / 'indexCards') files
		collect: [ :file | 
			file
				readStreamDo: [ :fileStream | 
					| stream |
					stream := ZnBufferedReadStream on: fileStream.	"wrap with buffered stream to bypass https://github.com/GemTalk/FileSystemGs/issues/9"
					STON fromStream: stream ] ].

	indexCards := indexCards sort: [ :a :b | a index <= b index ].

	specsDir := projectSpecification repositoryRoot / 'specs'.
	projectSpecs := indexCards
		collect: [ :indexCard | 
			specsDir / indexCard specName , 'ston'
				readStreamDo: [ :fileStream | 
					| stream |
					stream := ZnBufferedReadStream on: fileStream.	"wrap with buffered stream to bypass https://github.com/GemTalk/FileSystemGs/issues/9"
					STON fromStream: stream ] ].

	resolvedProjects := projectSpecs
		collect: [ :projectSpec | 
			projectSpec projectsHome: self _testRowanProjectsSandbox.
			STON toStringPretty: projectSpec resolve ]
%

category: 'issue 495'
method: RwRowanSample9Test
testIssue495_move_class_and_extension_method_to_new_symbol_dictV2_1
	"https://github.com/dalehenrich/Rowan/issues/495"

	"unsuccessful attempt to duplicate of RwRowanProjectIssuesTest debug: #testIssue495_move_class_and_extension_method_to_new_symbol_dict 
		(during audit: UndefinedObject does not understand  #'name') ... in this test we're loading from RowanSample9 repo and passing in  
		RwRowanProjectIssuesTestV2 debug: #testIssue215_move_class_and_extension_method_to_new_symbol_dict we're using original code which modifies 
		project definition in memory and it fails with the expected error"

	"in this case the class package and extension package are swapping symbol dictionaries"

	| loadSpec projectName resolvedProject loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0011'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolveStrict.

"load project soec_0011"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

"spec_0014"
	loadSpec := self _loadSpecNamed: 'spec_0014'.
	resolvedProject := loadSpec resolveStrict.

"load project soec_0014"
	loadedProjects := resolvedProject load .

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'issue 495'
method: RwRowanSample9Test
testIssue495_move_class_and_extension_method_to_new_symbol_dictV2_2
	"https://github.com/dalehenrich/Rowan/issues/495"

	"this time the test results should matchRwRowanProjectIssuesTestV2 testIssue495_move_class_and_extension_method_to_new_symbol_dict"

	"should involve a movePackage and not a classProperty change as in testIssue495_move_class_and_extension_method_to_new_symbol_dictV2_1"

	| loadSpec projectName resolvedProject loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0011'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolveStrict.

"load project soec_0011"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

"spec_0015"
	loadSpec := self _loadSpecNamed: 'spec_0015'.
	resolvedProject := loadSpec resolveStrict.

"load project soec_0014"
	loadedProjects := resolvedProject load .

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'tests'
method: RwRowanSample9Test
testIssue_254
	"https://github.com/dalehenrich/Rowan/issues/254"

	| loadSpec projectName resolvedProject loadedProjects project testResult 
		packageName1 packageName2 |

	loadSpec := self _loadSpecNamed: 'spec_0003'.	"primer -- spec_0001 with instancesInvariant"
	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed:projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"set up for issue #230 ... RowanSample9Class1 in one symbol dictionary (instancesInvariant);
		RowanSample4IdentityKeyValueDictionary in another symbol dictionary"
	packageName1 := projectName , '-' , 'Core'.
	packageName2 := projectName , '-' , 'Extensions'.

"resolve primer project"
	resolvedProject := loadSpec resolve.
	resolvedProject
		gemstoneSetSymbolDictName: self _sampleSymbolDictionaryName2 
			forPackageNamed: packageName1;
		gemstoneSetSymbolDictName: self _sampleSymbolDictionaryName2 
			forPackageNamed: packageName2;
		yourself.

"load primer project"
	loadedProjects := resolvedProject load.

"validate"
	self assert: loadedProjects size = 1.
	project := loadedProjects at: 1.
	self assert: project audit isEmpty.
	testResult := project testSuite run.
	self deny: testResult hasErrors.
	self deny: testResult hasFailures.

	loadSpec := self _loadSpecNamed: 'spec_0002'.	"basic project (remove instancesInvariant option and move class to default symbol dictionary: self _sampleSymbolDictionaryName1)"

"resolve/load"
	resolvedProject := loadSpec resolve.
	loadedProjects := resolvedProject load.

"validate"
	self assert: loadedProjects size = 1.
	project := loadedProjects at: 1.
	self assert: project audit isEmpty.
	testResult := project testSuite run.
	self deny: testResult hasErrors.
	self deny: testResult hasFailures.
%

category: 'tests'
method: RwRowanSample9Test
testIssue_446
	"Not a real test ... used for V2.0 spec development"

	"https://github.com/GemTalk/Rowan/issues/446"

	"create a project that has 2 components, one component 
		requires the other component; and two load specs, each spec
		loads a different component ... needed to consolidate spec_004 
		creation"

	| project1 project2 projectName projectsHome resolvedProject stonString |
	projectName := 'RowanSample9_testbed'.
	projectsHome := self _testRowanProjectsSandbox.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

	project1 := RwResolvedProjectV2 new
		projectName: projectName;
		projectsHome: projectsHome;
		gemstoneSetDefaultSymbolDictNameTo: self _sampleSymbolDictionaryName1;
		repoType: #'git';
		yourself.

	resolvedProject := project1 resolve.

	(resolvedProject
		addComponentNamed: 'Core1'
		definedGroupNames:
			(Dictionary new
				add: 'core' -> {};
				add: 'tests' -> {'core'};
				yourself)
		comment: 'contains ' , projectName , '-Core1 package and Core2 component')
		componentNames: #('Core2');
		yourself.
	resolvedProject
		addComponentNamed: 'Core2'
		definedGroupNames:
			(Dictionary new
				add: 'core' -> {};
				add: 'tests' -> {'core'};
				yourself)
		comment: 'contains ' , projectName , '-Core2 package'.

	resolvedProject
		componentNames: #('Core1');
		yourself.	"????"

	project2 := RwResolvedProjectV2 new
		componentNames:  #('Core2');
		yourself.	"????"

	stonString := STON toStringPretty: resolvedProject.
	false
		ifTrue: [ self halt ]
%

category: 'issue 493'
method: RwRowanSample9Test
testIssue_493
	"https://github.com/dalehenrich/Rowan/issues/493"

	"duplicate of RwRowanSample2Test debug: #testIssue493 (no existing LoadedMethod found for the old compiledMethod.) ... "

	"Cannot duplicate RwRowanSample4Test>>#testLoadProjectNamed_493 (passing in 3.5.0) because: in v1.2 the default symbol 
		dictionary was a function of the component, so a component without a default
		explicitly defined, gave a different answer as to the expected symbol dict for 
		packages without explicitly defined symbol dicts ... in 3.2.15, the test passes, when deprecated methods are loaded"

	| loadSpec projectName resolvedProject loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0008'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolve.

"load project soec_0008"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

"spec_0010"
	loadSpec := self _loadSpecNamed: 'spec_0010'.
	resolvedProject := loadSpec resolve.

"load project soec_0010"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'issue 495'
method: RwRowanSample9Test
testIssue_495_1
	"https://github.com/dalehenrich/Rowan/issues/495"

	| loadSpec projectName resolvedProject loadedProjects errorHit |

	loadSpec := self _loadSpecNamed: 'spec_0011'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolveStrict.

"load project soec_0011"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

"spec_0012"
	loadSpec := self _loadSpecNamed: 'spec_0012'.
	resolvedProject := loadSpec resolveStrict.

"load project soec_0012"
	errorHit := false.

	[ loadedProjects := resolvedProject load ]
		on: Error
		do: [:ex |
			| x |
			self assert: (x := ex description) = 'UserDefinedError: The extension class named ''RowanSample9Class1'' cannot be found in this symbol dictionary (#''RowanSample9_3''). Packages that extend a class must be loaded into the symbol dictionary in which the class is installed.'.
			errorHit := true ].

"validate"
	self assert: errorHit.
%

category: 'issue 495'
method: RwRowanSample9Test
testIssue_495_2
	"https://github.com/dalehenrich/Rowan/issues/495"

	"in this case the class package and extension package are swapping symbol dictionaries"

	| loadSpec projectName resolvedProject loadedProjects errorHit |

	loadSpec := self _loadSpecNamed: 'spec_0011'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolveStrict.

"load project soec_0011"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

"spec_0013"
	loadSpec := self _loadSpecNamed: 'spec_0013'.
	resolvedProject := loadSpec resolveStrict.

"load project soec_0013"
	errorHit := false.
	[ loadedProjects := resolvedProject load ]
		on: Error
		do: [:ex |
			| x |
			self assert: (x := ex description) = 'UserDefinedError: The extension class named ''RowanSample9Class1'' cannot be found in this symbol dictionary (#''RowanSample9_1''). Packages that extend a class must be loaded into the symbol dictionary in which the class is installed.'.
			errorHit := true ].

"validate"
	self assert: errorHit.
%

category: 'tests'
method: RwRowanSample9Test
testIssue_504_1
	"https://github.com/dalehenrich/Rowan/issues/504"

	"V2.0 replacement for RowanSample4Test>>testIssue230 ... explicit test for issue #504"

	"use spec_0002 and modify resolved project to use correct symbol dictionary mappings"

	| loadSpec projectName resolvedProject loadedProjects |

	loadSpec := self _loadSpecNamed: 'spec_0005'.	"primer -- spec_0001 with instancesInvariant"

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed:projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve primer project"
	resolvedProject := loadSpec resolve.

"load primer project"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

	loadSpec := self _loadSpecNamed: 'spec_0002'.

"resolve"
	resolvedProject := loadSpec resolve.

	resolvedProject
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: projectName , '-' , 'Core';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: projectName , '-' , 'Extensions';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName3 
			forPackageNamed: projectName , '-' , 'GemStone';
		yourself.

"load"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'tests'
method: RwRowanSample9Test
testIssue_504_2
	"https://github.com/dalehenrich/Rowan/issues/504"

	"V2.0 replacement for RowanSample4Test>>testIssue230 ... explicit test for issue #504"

	"use spec_0006 ... use component symbol dictionary mappings"

	| loadSpec projectName resolvedProject loadedProjects |

	loadSpec := self _loadSpecNamed: 'spec_0005'.	"primer -- spec_0001 with instancesInvariant"

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed:projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve primer project"
	resolvedProject := loadSpec resolve.

"load primer project"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

	loadSpec := self _loadSpecNamed: 'spec_0006'.

"resolve"
	resolvedProject := loadSpec resolve.

"load"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'tests'
method: RwRowanSample9Test
testIssue_504_3
	"https://github.com/dalehenrich/Rowan/issues/504"

	"V2.0 replacement for RowanSample4Test>>testIssue230 ... explicit test for issue #504"

	"use spec_0007 ... with instance variables to force the new class version"

	| loadSpec projectName resolvedProject loadedProjects |

	loadSpec := self _loadSpecNamed: 'spec_0007'.	"primer -- spec_0005 with instance variables"

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed:projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve primer project"
	resolvedProject := loadSpec resolve.

"load primer project"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

	loadSpec := self _loadSpecNamed: 'spec_0006'.

"resolve"
	resolvedProject := loadSpec resolve.

"load"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'tests'
method: RwRowanSample9Test
testIssue_504_4
	"https://github.com/dalehenrich/Rowan/issues/504"

	"V2.0 replacement for RowanSample4Test>>testIssue230 ... explicit test for issue #504"

	"reverse the use of spec_0007 and spec_0006"

	| loadSpec projectName resolvedProject loadedProjects |

	loadSpec := self _loadSpecNamed: 'spec_0006'.	

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed:projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve primer project"
	resolvedProject := loadSpec resolve.

"load primer project"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

	loadSpec := self _loadSpecNamed: 'spec_0007'.	"primer -- spec_0005 with instance variables"

"resolve"
	resolvedProject := loadSpec resolve.

"load"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'tests'
method: RwRowanSample9Test
testIssue_527
	"
		self _clearLoadSpecSessionCache
	"

	| loadSpec symDictName className projectName |
	loadSpec := self _loadSpecNamed: 'spec_0001'.

	(Rowan image loadedProjectNamed: loadSpec projectAlias ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

	projectName := loadSpec projectAlias.
	className := projectName , 'Class1'.

	self
		_issue_527_resolve_load_validate: loadSpec
		className: className
		expectedSymDictName: self _sampleSymbolDictionaryName1.

	symDictName := self _sampleSymbolDictionaryName2.
	loadSpec
		gemstoneSetDefaultSymbolDictNameForUser: Rowan image currentUserId
		to: symDictName.

	self
		_issue_527_resolve_load_validate: loadSpec
		className: className
		expectedSymDictName: self _sampleSymbolDictionaryName2
%

category: 'tests'
method: RwRowanSample9Test
testIssue_531_baseline
	"load spec_0004 and validate that symbol dictionary specs are followed"

	"https://github.com/GemTalk/Rowan/issues/531"

	| loadSpec projectName classesToSymDictMap |
	loadSpec := self _loadSpecNamed: 'spec_0004'.

	projectName := loadSpec projectAlias.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve/load/validate"
	self _standard_resolve_load_validate: loadSpec.

"validate that classes are in the correct symbolDictionary"
	classesToSymDictMap := Dictionary new
		at: {projectName , 'Class1'} put: self _sampleSymbolDictionaryName2;
		at: {projectName , 'Class2'} put: self _sampleSymbolDictionaryName3;
		at: {projectName , 'TestCase'} put: self _sampleSymbolDictionaryName1;
		yourself.
	self _validateSymbolDictMapping: classesToSymDictMap.

"unload project"
	(Rowan projectNamed: projectName) unload.

"validate"
	classesToSymDictMap keysDo: [:classNames |
		classNames do: [:className |
			self assert: (Rowan globalNamed: className) isNil ] ].
%

category: 'tests'
method: RwRowanSample9Test
testIssue_532
	"
		self _clearLoadSpecSessionCache
	"

	"https://github.com/GemTalk/Rowan/issues/532"

	| loadSpec hitError |
	hitError := false.
	[ loadSpec := self _loadSpecNamed: 'spec_0004_b' ]
		on: Error
		do: [ :ex | 
			| x |
			self assert: (x := ex description) = 'UserDefinedError: Duplicate package'.
			hitError := true ].
	self assert: hitError description: 'Expected an error'
%

category: 'tests'
method: RwRowanSample9Test
testIssue_549
	"RwProjectDefinitionV2>>removePackageNamed: needs to clean up the component references to the removed package name"

	"https://github.com/dalehenrich/Rowan/issues/549"

	| loadSpec projectName  resolvedProject1 resolvedProject2 loadedProjects project |
	loadSpec := self _loadSpecNamed: 'spec_0014'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject1 := loadSpec resolve.

"load project"
	loadedProjects := resolvedProject1 load.

"validate"
	self _standard_validate: resolvedProject1 loadedProjects: loadedProjects.

"remove package RowanSample9-Extensions"
	project := loadedProjects at: 1.
	resolvedProject2 := project asDefinition.
	resolvedProject2 removePackageNamed: 'RowanSample9-Extensions'.

"validation should pass"
	self assert: resolvedProject2 _validate
%

category: 'tests'
method: RwRowanSample9Test
testIssue_549_errorCondition
	"Verify that when component packages and package definitions are inconsistent we generate an error"

	"https://github.com/dalehenrich/Rowan/issues/549"

	| loadSpec projectName  resolvedProject1 errorHit |
	loadSpec := self _loadSpecNamed: 'spec_0015'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject1 := loadSpec resolve.
	resolvedProject1 repository checkout: 'rowan_issue_549'.	"tag pointing to inconsistent checkout"
	resolvedProject1 read.

"load project"
	errorHit := false.
	[resolvedProject1 _validate ] 
		on: Error
		do: [:ex | 
			| x |
			self assert: (x := ex description) = 'UserDefinedError: Component references package(s) that are not defined
	The following packages are defined, but not referenced in a component:
		RowanSample9-Extensions
'.
			errorHit := true].
	self assert: errorHit
%

category: 'issue 493'
method: RwRowanSample9Test
testMoveClassBetweenSymDicts_changeDefaulSymDict_2_493
	"https://github.com/dalehenrich/Rowan/issues/493"

	"duplicate of RwRowanIssue493Test debug: #testMoveClassBetweenSymDicts_changeDefaulSymDict_2
		(audit failure: Issue493Class>>Missing loaded method>>foo) 
		original test fails with (during audit: UndefinedObject does not understand  #'name')"

	"move a class with a method from one sym dict to another using defaultSymbolDictName"

	| loadSpec projectName resolvedProject loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0008'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolve.

"load project soec_008"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

"spec_009"
	loadSpec := self _loadSpecNamed: 'spec_0009'.
	resolvedProject := loadSpec resolve.

"load project soec_009"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'tests'
method: RwRowanSample9Test
testRowanSample4_basic_504

	| loadSpec projectName resolvedProject  loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0002'.

	projectName := loadSpec projectAlias.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve/load"
	resolvedProject := loadSpec resolve.
	loadedProjects := resolvedProject load.

	resolvedProject
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: projectName , '-' , 'Core';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName2 
			forPackageNamed: projectName , '-' , 'Extensions';
		gemstoneSetSymbolDictName: RwRowanSample9Test _sampleSymbolDictionaryName3 
			forPackageNamed: projectName , '-' , 'GemStone';
		yourself.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

"unload project"
	(Rowan projectNamed: projectName) unload
%

category: 'tests'
method: RwRowanSample9Test
testRowanSample4_primer_504

	| loadSpec projectName resolvedProject packageName1 packageName2 loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0005'.

	projectName := loadSpec projectAlias.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

	packageName1 := projectName , '-' , 'Core1'.
	packageName2 := projectName , '-' , 'Core2'.

"resolve/load"
	resolvedProject := loadSpec resolve.
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.

"unload project"
	(Rowan projectNamed: projectName) unload
%

category: 'tests'
method: RwRowanSample9Test
testSpec_0001_A
	"a UserDefinedError occurred (error 2318), reason:halt, The component 'Core' is undefined"

	"functional variant of testSpec_0001_B"

	| rowanProject fileUrl loadSpecification resolvedProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	fileUrl := 'file:' , rowanProject repositoryRootPath
		, '/test/specs/RowanSample9_0000.ston'.
	loadSpecification := (RwSpecification fromUrl: fileUrl)
		projectsHome: self _testRowanProjectsSandbox;
		yourself.

	(self _testRowanProjectsSandbox / 'RowanSample9') ensureDeleteAll.

	resolvedProject := loadSpecification resolve. "project is not being loaded from disk on resolve"
	resolvedProject
		addPackagesNamed: {(loadSpecification projectName , '-Core')}
		toComponentNamed: 'Core'
		withConditions: {'common'}
		andGroupName: 'core'.
%

category: 'tests'
method: RwRowanSample9Test
testSpec_0001_B
	"a UserDefinedError occurred (error 2318), reason:halt, The component 'Core' is undefined"

	"testSpec_0001_A behavies correctly"

	| rowanProject fileUrl loadSpecification resolvedProject resolvedRepository oldPolicy |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	fileUrl := 'file:' , rowanProject repositoryRootPath
		, '/test/specs/RowanSample9_0000.ston'.
	loadSpecification := (RwSpecification fromUrl: fileUrl)
		projectsHome: self _testRowanProjectsSandbox;
		repositoryResolutionPolicy: #'strict';
		yourself.	"force #strict policy to ensure that the revision is checkout out in the repository"

	(self _testRowanProjectsSandbox / 'RowanSample9') ensureDeleteAll.


	resolvedProject := loadSpecification resolve.

	resolvedRepository := resolvedProject repository.
	resolvedRepository checkout: 'master'.

	oldPolicy := loadSpecification repositoryResolutionPolicy.
	[ 
	"force #strict policy to ensure that the revision is checkout out in the repolicy"
	loadSpecification repositoryResolutionPolicy: #'strict'.
	resolvedProject := loadSpecification resolve ]
		ensure: [ loadSpecification repositoryResolutionPolicy: oldPolicy ].

	resolvedProject
		addPackagesNamed: {(loadSpecification projectName , '-Core')}
		toComponentNamed: 'Core'
		withConditions: {'common'}
		andGroupName: 'core'
%

category: 'tests'
method: RwRowanSample9Test
testSpec_0002_to_0003
	"https://github.com/dalehenrich/Rowan/issues/230"

	"Passing variation"

	| loadSpec projectName resolvedProject loadedProjects project testResult 
		packageName1 packageName2 x |
	loadSpec := self _loadSpecNamed: 'spec_0002'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed:projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"set up for issue #230 ... RowanSample9Class1 in one symbol dictionary (instancesInvariant);
		RowanSample4IdentityKeyValueDictionary in another symbol dictionary"
	packageName1 := projectName , '-' , 'Core'.
	packageName2 := projectName , '-' , 'Extensions'.

"resolve primer project"
	resolvedProject := loadSpec resolve.

"load primer project"
	loadedProjects := resolvedProject load.

"validate"
	self assert: loadedProjects size = 1.
	project := loadedProjects at: 1.
	self assert: project audit isEmpty.
	testResult := project testSuite run.
	self deny: testResult hasErrors.
	self deny: testResult hasFailures.

	loadSpec := self _loadSpecNamed: 'spec_0003'.	"primer -- spec_0001 with instancesInvariant"

"resolve"
	resolvedProject := loadSpec resolve.
	resolvedProject
		gemstoneSetSymbolDictName: self _sampleSymbolDictionaryName2 
			forPackageNamed: packageName1;
		gemstoneSetSymbolDictName: self _sampleSymbolDictionaryName2 
			forPackageNamed: packageName2;
		yourself.

"load"
	loadedProjects := resolvedProject load.

"validate"
	self assert: loadedProjects size = 1.
	project := loadedProjects at: 1.
	self assert: (x := project audit) isEmpty.
	testResult := project testSuite run.
	self deny: testResult hasErrors.
	self deny: testResult hasFailures.
%

category: 'issue 493'
method: RwRowanSample9Test
testSpec_0008
	"https://github.com/dalehenrich/Rowan/issues/493"

	| loadSpec projectName resolvedProject loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0008'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolve.

"load project"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'issue 493'
method: RwRowanSample9Test
testSpec_0009
	"https://github.com/dalehenrich/Rowan/issues/493"

	| loadSpec projectName resolvedProject loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0009'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolve.

"load project"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'issue 493'
method: RwRowanSample9Test
testSpec_0010
	"https://github.com/dalehenrich/Rowan/issues/493"

	| loadSpec projectName resolvedProject loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0010'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolve.

"load project"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'issue 495'
method: RwRowanSample9Test
testSpec_011
	"https://github.com/dalehenrich/Rowan/issues/495"

	| loadSpec projectName resolvedProject loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0011'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolve.

"load project"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'issue 495'
method: RwRowanSample9Test
testSpec_012
	"spec_012 should result in an error when loaded"

	"https://github.com/dalehenrich/Rowan/issues/495"

	| loadSpec projectName resolvedProject loadedProjects errorHit |
	loadSpec := self _loadSpecNamed: 'spec_0012'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolve.

"load project -- expect error"
	errorHit := false.
	[ loadedProjects := resolvedProject load ] 
		on: Error 
		do: [:ex | 
			| x |
			self assert: ( x:=  ex description) = 'UserDefinedError: The extension class named ''RowanSample9Class1'' cannot be found in this symbol dictionary (#''RowanSample9_3''). Packages that extend a class must be loaded into the symbol dictionary in which the class is installed.'.
			errorHit := true ].
	self assert: errorHit.
%

category: 'issue 495'
method: RwRowanSample9Test
testSpec_013
	"spec_013 should result in an error when loaded"

	"https://github.com/dalehenrich/Rowan/issues/495"

	| loadSpec projectName resolvedProject loadedProjects errorHit |
	loadSpec := self _loadSpecNamed: 'spec_0013'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolve.

"load project -- expect error"
	errorHit := false.
	[ loadedProjects := resolvedProject load ] 
		on: Error 
		do: [:ex | 
			| x |
			self assert: ( x:=  ex description) = 'UserDefinedError: The extension class named ''RowanSample9Class1'' cannot be found in this symbol dictionary (#''RowanSample9_1''). Packages that extend a class must be loaded into the symbol dictionary in which the class is installed.'.
			errorHit := true ].
	self assert: errorHit.
%

category: 'issue 495'
method: RwRowanSample9Test
testSpec_014
	"spec_014 should load cleanly"

	"https://github.com/dalehenrich/Rowan/issues/495"

	| loadSpec projectName resolvedProject loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0014'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolve.

"load project"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'issue 495'
method: RwRowanSample9Test
testSpec_015
	"spec_015 should load cleanly"

	"https://github.com/dalehenrich/Rowan/issues/495"

	| loadSpec projectName resolvedProject loadedProjects |
	loadSpec := self _loadSpecNamed: 'spec_0015'.

	projectName := loadSpec projectAlias.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

"resolve project"
	resolvedProject := loadSpec resolve.

"load project"
	loadedProjects := resolvedProject load.

"validate"
	self _standard_validate: resolvedProject loadedProjects: loadedProjects.
%

category: 'private'
method: RwRowanSample9Test
_deleteProjectRepositoryDir
	^ false
%

category: 'private'
method: RwRowanSample9Test
_gitPullSessionCacheKey
	^ self class _gitPullSessionCacheKey
%

category: 'private'
method: RwRowanSample9Test
_issue_527_resolve_load_validate: projectSpec className: className expectedSymDictName: expectedSymDictName
	| resolvedProject loadedProjects symDictName symDict |
	resolvedProject := projectSpec resolve.
	loadedProjects := resolvedProject load.
	self assert: loadedProjects size = 1.
	loadedProjects do: [ :project | self assert: project audit isEmpty ].

	symDictName := projectSpec
		gemstoneDefaultSymbolDictNameForUser: Rowan image currentUserId.

	self assert: symDictName = expectedSymDictName.

	(symDict := Rowan globalNamed: symDictName)
		ifNil: [ 
			self
				assert: false
				description:
					'Expected symbol dictionary ' , symDictName printString , ' not present' ].

	self assert: (symDict at: className asSymbol ifAbsent: [  ]) notNil.

	(loadedProjects at: 1) unload.

	self deny: (symDict at: className asSymbol ifAbsent: [  ]) notNil
%

category: 'private'
method: RwRowanSample9Test
_loadSpecNamed: specName
	"
		self _clearLoadSpecSessionCache
	"

	"The RowanSample9 repository is expected to be 'permanently' located on disk ... 
		we'll use `fetch` and `pull` to update the repo and branches as needed"

	"it is assumed that the load spec on the master branch and the load spec on the branch are the same"

	| loadSpecification resolvedProject resolvedRepository dict theSpec branchDict |
	loadSpecification := self _rowanSample9_0000_load_spec.
	theSpec := (SessionTemps current
		at: self _loadSpecSessionCacheKey
		ifAbsent: [  ])
		ifNotNil: [ :specsDict | specsDict at: specName ]
		ifNil: [ 
			"The first time we access the repository in this session, we'll refresh the 
				master branch and cache the session specs"
			loadSpecification revision: 'master'.
			resolvedProject := loadSpecification resolveStrict.

			resolvedRepository := resolvedProject repository.
			resolvedRepository
				fetch;
				pull: resolvedRepository remote branch: 'master';
				yourself.

			dict := SessionTemps current
				at: self _loadSpecSessionCacheKey
				ifAbsentPut: [ Dictionary new ].
			(resolvedProject repositoryRoot / 'specs') files
				do: [ :file | 
					file
						readStreamDo: [ :fileStream | 
							| stream spec |
							stream := ZnBufferedReadStream on: fileStream.	"wrap with buffered stream to bypass https://github.com/GemTalk/FileSystemGs/issues/9"
							spec := STON fromStream: stream.
							dict at: spec specName put: spec ] ].
			dict at: specName ].
	theSpec := theSpec copy.
	theSpec
		projectsHome: self _testRowanProjectsSandbox;
		yourself.
	resolvedProject := theSpec resolveStrict.	"When we reference a spec, we'll checkout the branch"
	branchDict := SessionTemps current
		at: self _gitPullSessionCacheKey
		ifAbsentPut: [ Dictionary new ].
	(branchDict at: theSpec revision ifAbsent: [  ])
		ifNil: [ 
			"Once per session fetch and pull the latest commits for the branch"
			resolvedRepository := resolvedProject repository.
			resolvedRepository
				fetch;
				pull: resolvedRepository remote branch: theSpec revision;
				yourself.
			branchDict at: theSpec revision put: theSpec ].
	^ theSpec copy
%

category: 'private'
method: RwRowanSample9Test
_loadSpecSessionCacheKey
	^ self class _loadSpecSessionCacheKey
%

category: 'private'
method: RwRowanSample9Test
_rowanSample9_0000_load_spec

	| rowanProject fileUrl |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	fileUrl := 'file:' , rowanProject repositoryRootPath
		, '/test/specs/RowanSample9_0000.ston'.
	^(RwSpecification fromUrl: fileUrl)
		projectsHome: self _testRowanProjectsSandbox;
		yourself.
%

category: 'private'
method: RwRowanSample9Test
_specListProjectNames
	^ super _specListProjectNames
		,
			{'PrimerSample9'.
			'RowanSample9_testbed'}
%

category: 'private'
method: RwRowanSample9Test
_standard_resolve_load_validate: projectSpec
	| resolvedProject loadedProjects |

"resolve/load"
	resolvedProject := projectSpec resolve.
	loadedProjects := resolvedProject load.

	self _standard_validate: resolvedProject loadedProjects: loadedProjects
%

category: 'private'
method: RwRowanSample9Test
_standard_validate: resolvedProject loadedProjects: loadedProjects
	| project testResult loadedProjectDefinition x |

"validate"
	self assert: loadedProjects size = 1.
	project := loadedProjects at: 1.
	self assert: (x := project audit) isEmpty.
	testResult := project testSuite run.
	self deny: testResult hasErrors.
	self deny: testResult hasFailures.

	loadedProjectDefinition := project asDefinition.
	self assert: loadedProjectDefinition class = resolvedProject projectDefinition class.
%

category: 'private'
method: RwRowanSample9Test
_validateSymbolDictMapping: classesToSymDictMap
	| exceptions |
	exceptions := {}.
	classesToSymDictMap
		keysAndValuesDo: [ :classNames :symDictName | 
			| symDict |
			(symDict := Rowan globalNamed: symDictName)
				ifNil: [ 
					exceptions
						add:
							'Expected symbol dictionary ' , symDictName printString , ' not present'.
					classNames
						do: [ :className | 
							"if expected symbol dictionary is not present, confirm that the classes were loaded albeit, the wrong symbol dictionary"
							(Rowan globalNamed: className)
								ifNil: [ 
									exceptions
										add:
											'Class named ' , className printString , ' not loaded as expected' ] ] ]
				ifNotNil: [ 
					classNames
						do: [ :className | 
							(symDict at: className asSymbol ifAbsent: [  ])
								ifNil: [ 
									exceptions
										add:
											'Class named ' , className printString
												, ' not present in the expected symbol dictionary '
												, symDictName printString ] ] ] ].
	self assert: exceptions isEmpty
%

! Class implementation for 'RwProjectTest'

!		Instance methods for 'RwProjectTest'

category: 'tests'
method: RwProjectTest
testProjectCreation

	| project |

	project := RwProject newNamed: 'ProjectInterface'.
%

! Class implementation for 'RwLoadingTest'

!		Class methods for 'RwLoadingTest'

category: 'running'
classmethod: RwLoadingTest
debug

	^self allTestSelectors do: [:selector | self debug: selector]
%

category: 'initlization'
classmethod: RwLoadingTest
initialize
	"self initialize"

	"cannot create useful pool dictionaries on the fly, so need  a set of 
	 canonical pool dictionaries."

	PoolDictionaryDictionary := Dictionary new.
	{(SymbolDictionary new
		at: #'Carrot1' put: 1;
		at: #'Radish1' put: 2;
		name: #'PoolDictionary1';
		yourself).
	(SymbolDictionary new
		at: #'Carrot2' put: 1;
		at: #'Radish2' put: 2;
		name: #'PoolDictionary2';
		yourself).
	(SymbolDictionary new
		at: #'Carrot3' put: 1;
		at: #'Radish3' put: 2;
		name: #'PoolDictionary3';
		yourself)} do: [ :pd | PoolDictionaryDictionary at: pd name put: pd ]
%

category: 'running'
classmethod: RwLoadingTest
run

	^self suite run
%

!		Instance methods for 'RwLoadingTest'

category: 'support - simple definitions'
method: RwLoadingTest
accessorMethodsForSimpleClassNamed: name

	| result |
	result := Dictionary new.

	{('iv1In' , name).
	('iv2In' , name)}
		do: [ :ivName | 
			result
				at: ivName asSymbol
					put:
						(RwMethodDefinition
								withProperties:
									(Dictionary with: 'selector' -> ivName asSymbol with: 'protocol' -> 'accessing')
								source: ivName , ' ^' , ivName);
				at: (ivName , ':') asSymbol
					put:
						(RwMethodDefinition
								withProperties:
									(Dictionary
										with: 'selector' -> (ivName , ':') asSymbol
										with: 'protocol' -> 'accessing')
								source: ivName , ': anObject ' , ivName , ' := anObject') ].
	^ result
%

category: 'support - basic definitions'
method: RwLoadingTest
basicClassDefinitions: packageName
  ^ Dictionary new
    at: 'TestNormalClass'
      put:
        (self definitionOfNormalClassNamed: 'TestNormalClass' inPackage: packageName);
    at: 'TestNormalDbTransientClass'
      put:
        (self
            definitionOfBasicClassNamed: 'TestNormalDbTransientClass'
            type: 'normal'
            instvars: {'instvar1'}
            gs_options: {'dbTransient'}
            inPackage: packageName);
    at: 'TestVariableClass'
      put:
        (self
            definitionOfBasicClassNamed: 'TestVariableClass'
            type: 'variable'
            instvars: {}
            gs_options: nil
            inPackage: packageName);
    at: 'TestMyBagClass'
      put:
        (self
            definitionOfBasicClassNamed: 'TestMyBagClass'
            superclass: 'Bag'
            type: 'normal'
            instvars: {}
            gs_options: {}
            inPackage: packageName);
    at: 'TestMyRcIdentityBagClass'
      put:
        (self
            definitionOfBasicClassNamed: 'TestMyRcIdentityBagClass'
            superclass: 'RcIdentityBag'
            type: 'normal'
            instvars: {}
            gs_options: {}
            inPackage: packageName);
    at: 'TestCustomByteArrayClass'
      put:
        (self
            definitionOfBasicClassNamed: 'TestCustomByteArrayClass'
            superclass: 'Object'
            type: 'byteSubclass'
            instvars: {}
            gs_options: {}
            inPackage: packageName);
    at: 'TestMyByteArrayClass'
      put:
        (self
            definitionOfBasicClassNamed: 'TestMyByteArrayClass'
            superclass: 'ByteArray'
            type: 'normal'
            instvars: {}
            gs_options: {}
            inPackage: packageName);
    at: 'TestMyStringClass'
      put:
        (self
            definitionOfBasicClassNamed: 'TestMyStringClass'
            superclass: 'String'
            type: 'normal'
            instvars: {}
            gs_options: {}
            inPackage: packageName);
    at: 'TestProtoObjectClass'
      put:
        (self
            definitionOfBasicClassNamed: 'TestProtoObjectClass'
            superclass: 'nil'
            type: 'normal'
            instvars: {}
            gs_options: {}
            inPackage: packageName);
    yourself
%

category: 'support - basic definitions'
method: RwLoadingTest
basicClassMethodsForClass: className
  ^ self
    methodDefsFromSpec:
      {{#'classMeth'.
      'accessing'.
      ('classMeth ^''classMeth for class ''' , className printString)}}
%

category: 'support - basic definitions'
method: RwLoadingTest
basicInstanceMethodsForClass: className
  ^ self
    methodDefsFromSpec:
      {{#'instanceMeth'.
      'accessing'.
      ('instanceMeth ^''instanceMeth for class ''' , className printString)}}
%

category: 'support - basic definitions'
method: RwLoadingTest
basicPackageDefinition: packageName
  ^ RwPackageDefinition
    withProperties: (Dictionary with: 'name' -> packageName with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
    classDefinitions: (self basicClassDefinitions: packageName)
    classExtensions: Dictionary new
%

category: 'support - classExtensions definitions'
method: RwLoadingTest
classExtentionsInstanceMethodsForClass2: className inPackage: packageName

	^ self
		methodDefsFromSpec:
			{{#'foo'.
			'*', packageName.
			'foo ^ ''foo'''}}
%

category: 'support - classExtensions definitions'
method: RwLoadingTest
classExtionsClassDefinitions1: packageName className: className in: classDefinitionDictionary

	"Class extension methods"

	^ classDefinitionDictionary
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classExtensions definitions'
method: RwLoadingTest
classExtionsClassDefinitions2: packageName className: className in: classDefinitionDictionary

	"Class extension methods"

	^ classDefinitionDictionary
		at: className
			put:
				(RwClassExtensionDefinition
						withProperties: (self propertiesForClassExtensionNamed: className)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions:
							(self classExtentionsInstanceMethodsForClass2: className inPackage: packageName));
		yourself
%

category: 'support - classInitialization definitions'
method: RwLoadingTest
classInitializationClassMethodsForClass1: className
  ^ self
    methodDefsFromSpec:
      {
			{#'initialize'.
      		'initialization'.
      		('initialize ClassVar1 := classInstVar1 := 1' )}.
			{#'classVar'.
      		'accessing'.
      		('classVar ^ ClassVar1' )}.
			{#'classInstVar1'.
      		'accessing'.
      		('classInstVar1 ^ classInstVar1' )}.
			{#'classInstVar2'.
      		'accessing'.
      		('classInstVar2 ^ classInstVar2' )}.
		}
%

category: 'support - classInitialization definitions'
method: RwLoadingTest
classInitializationClassMethodsForClass2: className
  ^ self
    methodDefsFromSpec:
      {
			{#'initialize'.
      		'initialization'.
      		('initialize ClassVar1 := classInstVar1 := 1. classInstVar2 := 2' )}.
			{#'classVar'.
      		'accessing'.
      		('classVar ^ ClassVar1' )}.
			{#'classInstVar1'.
      		'accessing'.
      		('classInstVar1 ^ classInstVar1' )}.
			{#'classInstVar2'.
      		'accessing'.
      		('classInstVar2 ^ classInstVar2' )}.
		}
%

category: 'support - classInitialization definitions'
method: RwLoadingTest
classInitializePackageDefinition: packageName className: className classMethodDefinitions: classMethodDefinitions
  ^ RwPackageDefinition
    withProperties: (Dictionary with: 'name' -> packageName with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
    classDefinitions:
      (Dictionary new
        at: className
          put:
            (self
                definitionOfClassInitializationClassNamed: className
                inPackage: packageName
                classMethodDefinitions: classMethodDefinitions);
        yourself)
    classExtensions: Dictionary new
%

category: 'support - classInstVarChanges definitions'
method: RwLoadingTest
classInstVarChangeClassDefinitions1: packageName in: classDefinitionDictionary
	"Class Inst Var Changes: "

	^ classDefinitionDictionary
		at: 'TestClassInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestClassInstVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classInstVarChanges definitions'
method: RwLoadingTest
classInstVarChangeClassDefinitions2: packageName in: classDefinitionDictionary
	"Class Inst Var Changes: add classInstVar1"

	^ classDefinitionDictionary
		at: 'TestClassInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestClassInstVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {'classInstVar1'}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classInstVarChanges definitions'
method: RwLoadingTest
classInstVarChangeClassDefinitions3: packageName in: classDefinitionDictionary
	"Class Inst Var Changes: add classInstVar2"

	^ classDefinitionDictionary
		at: 'TestClassInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestClassInstVarClass'
								super: 'Object'
								instvars: {}
								classinstvars:
									{'classInstVar1'.
									'classInstVar2'}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classInstVarChanges definitions'
method: RwLoadingTest
classInstVarChangeClassDefinitions4: packageName in: classDefinitionDictionary
	"Class Inst Var Changes: add classInstVar3 and remove classInstVar1"

	^ classDefinitionDictionary
		at: 'TestClassInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestClassInstVarClass'
								super: 'Object'
								instvars: {}
								classinstvars:
									{'classInstVar2'.
									'classInstVar3'}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classInstVarChanges definitions'
method: RwLoadingTest
classInstVarChangesClassDefinitions1: packageName
	^ self classInstVarChangeClassDefinitions1: packageName in: Dictionary new
%

category: 'support - classInstVarChanges definitions'
method: RwLoadingTest
classInstVarChangesClassDefinitions2: packageName
	^ self classInstVarChangeClassDefinitions2: packageName in: Dictionary new
%

category: 'support - classInstVarChanges definitions'
method: RwLoadingTest
classInstVarChangesClassDefinitions3: packageName
	^ self classInstVarChangeClassDefinitions3: packageName in: Dictionary new
%

category: 'support - classInstVarChanges definitions'
method: RwLoadingTest
classInstVarChangesClassDefinitions4: packageName
	^ self classInstVarChangeClassDefinitions4: packageName in: Dictionary new
%

category: 'support - classProperyChange definitions'
method: RwLoadingTest
classPropertyChangeClassDefinitions1: packageName
  ^ self classPropertyChangeClassDefinitions1: packageName in: Dictionary new
%

category: 'support - classProperyChange definitions'
method: RwLoadingTest
classPropertyChangeClassDefinitions1: packageName in: classDefinitionDictionary
	"Class Property Changes that do not result in new class versions "

	^ classDefinitionDictionary
		at: 'TestAddClassVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddClassVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		at: 'TestChangeCommentClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestChangeCommentClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classProperyChange definitions'
method: RwLoadingTest
classPropertyChangeClassDefinitions2: packageName
  ^ self classPropertyChangeClassDefinitions2: packageName in: Dictionary new
%

category: 'support - classProperyChange definitions'
method: RwLoadingTest
classPropertyChangeClassDefinitions2: packageName in: classDefinitionDictionary
	"Class Property Changes that do not result in new class versions "

	^ classDefinitionDictionary
		at: 'TestAddClassVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddClassVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {'ClassVar1'}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		at: 'TestChangeCommentClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestChangeCommentClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a new comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classVarChanges definitions'
method: RwLoadingTest
classVarChangeClassDefinitions1: packageName in: classDefinitionDictionary
	"Class Var Changes: "

	^ classDefinitionDictionary
		at: 'TestClassVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestClassVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classVarChanges definitions'
method: RwLoadingTest
classVarChangeClassDefinitions2: packageName in: classDefinitionDictionary
	"Class Var Changes: add ClassVar1"

	^ classDefinitionDictionary
		at: 'TestClassVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestClassVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {'ClassVar1'}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classVarChanges definitions'
method: RwLoadingTest
classVarChangeClassDefinitions3: packageName in: classDefinitionDictionary
	"Class Var Changes: add ClassVar2"

	^ classDefinitionDictionary
		at: 'TestClassVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestClassVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars:
									{'ClassVar1'.
									'ClassVar2'}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classVarChanges definitions'
method: RwLoadingTest
classVarChangeClassDefinitions4: packageName in: classDefinitionDictionary
	"Class Var Changes: add ClassVar3 and remove ClassVar1"

	^ classDefinitionDictionary
		at: 'TestClassVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestClassVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars:
									{'ClassVar2'.
									'ClassVar3'}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classVarChanges definitions'
method: RwLoadingTest
classVarChangesClassDefinitions1: packageName
	^ self classVarChangeClassDefinitions1: packageName in: Dictionary new
%

category: 'support - classVarChanges definitions'
method: RwLoadingTest
classVarChangesClassDefinitions2: packageName
	^ self classVarChangeClassDefinitions2: packageName in: Dictionary new
%

category: 'support - classVarChanges definitions'
method: RwLoadingTest
classVarChangesClassDefinitions3: packageName
	^ self classVarChangeClassDefinitions3: packageName in: Dictionary new
%

category: 'support - classVarChanges definitions'
method: RwLoadingTest
classVarChangesClassDefinitions4: packageName
	^ self classVarChangeClassDefinitions4: packageName in: Dictionary new
%

category: 'support - classVersionChanges'
method: RwLoadingTest
classVersionChangeAssociationInstanceMethodsForClass3: className
	^ self
		methodDefsFromSpec:
			{{#'customValue'.
			'accessing'.
			'customValue ^value'}}
%

category: 'support - classVersionChanges'
method: RwLoadingTest
classVersionChangeClassDefinitions1: packageName
	^ self classVersionChangeClassDefinitions1: packageName in: Dictionary new
%

category: 'support - classVersionChanges'
method: RwLoadingTest
classVersionChangeClassDefinitions1: packageName in: classDefinitionDictionary
	"Class Property Changes that result in new class versions "

	^ classDefinitionDictionary
		at: 'TestAddInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddInstVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		at: 'TestAddClassInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddClassInstVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		at: 'TestAddClassVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddClassVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		at: 'TestChangeSuperclassClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestChangeSuperclassClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		at: 'TestChangePoolsClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestChangePoolsClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classVersionChanges'
method: RwLoadingTest
classVersionChangeClassDefinitions2: packageName
	^ self classVersionChangeClassDefinitions2: packageName in: Dictionary new
%

category: 'support - classVersionChanges'
method: RwLoadingTest
classVersionChangeClassDefinitions2: packageName in: classDefinitionDictionary
	"Class Property Changes that result in new class versions "

	^ classDefinitionDictionary
		at: 'TestAddInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddInstVarClass'
								super: 'Object'
								instvars: {'instVar1'}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		at: 'TestAddClassInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddClassInstVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {'classInstVar1'}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		at: 'TestAddClassVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddClassVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {'ClassVar1'}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		at: 'TestChangeSuperclassClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestChangeSuperclassClass'
								super: 'Association'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		at: 'TestChangePoolsClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestChangePoolsClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classVersionChanges'
method: RwLoadingTest
classVersionChangeClassDefinitions3: packageName
	^ self classVersionChangeClassDefinitions3: packageName in: Dictionary new
%

category: 'support - classVersionChanges'
method: RwLoadingTest
classVersionChangeClassDefinitions3: packageName in: classDefinitionDictionary
	"Class Property Changes that result in new class versions "

	"add methods that reference the new class properties"

	^ classDefinitionDictionary
		at: 'TestAddInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddInstVarClass'
								super: 'Object'
								instvars: {'instVar1'}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions:
							(self classVersionChangeInstVarMethodsForClass3: 'TestAddInstVarClass'));
		at: 'TestAddClassInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddClassInstVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {'classInstVar1'}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions:
							(self classVersionChangeClassInstVarMethodsForClass3: 'TestAddInstVarClass')
						instanceMethodDefinitions: Dictionary new);
		at: 'TestAddClassVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestAddClassVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {'ClassVar1'}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions:
							(self classVersionChangeClassVarMethodsForClass3: 'TestAddClassVarClass')
						instanceMethodDefinitions: Dictionary new);
		at: 'TestChangeSuperclassClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestChangeSuperclassClass'
								super: 'Association'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions:
							(self
								classVersionChangeAssociationInstanceMethodsForClass3:
									'TestChangeSuperclassClass'));
		at: 'TestChangePoolsClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestChangePoolsClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - classVersionChanges'
method: RwLoadingTest
classVersionChangeClassInstVarMethodsForClass3: className
	^ self
		methodDefsFromSpec:
			{{#'classInstVar1'.
			'accessing'.
			'classInstVar1 ^classInstVar1'}}
%

category: 'support - classVersionChanges'
method: RwLoadingTest
classVersionChangeClassVarMethodsForClass3: className
	^ self
		methodDefsFromSpec:
			{{#'classVar1'.
			'accessing'.
			'classVar1 ^ClassVar1'}}
%

category: 'support - classVersionChanges'
method: RwLoadingTest
classVersionChangeInstVarMethodsForClass3: className
	^ self
		methodDefsFromSpec:
			{{#'instVar1'.
			'accessing'.
			'instVar1 ^instVar1'}}
%

category: 'support - combined definitions'
method: RwLoadingTest
combinedClassMethodsForClass1: className
  ^ self
    methodDefsFromSpec:
      {{#'initialize'.
      'initialization'.
      'initialize ClassVar1 := classInstVar1 := true'}.
      {#'testClassMethod1'.
      'xxx'.
      'testClassMethod1 ^ ClassVar1'}.
      {#'testClassMethod2'.
      'xxx'.
      'testClassMethod2 ^ classInstVar1'}.
      {#'testClassMethod3'.
      'xxx'.
      'testClassMethod3 ^ 1'}}
%

category: 'support - combined definitions'
method: RwLoadingTest
combinedClassMethodsForClass2: className
  ^ self
    methodDefsFromSpec:
      {{#'initialize'.
      'initialization'.
      'initialize ClassVar1 := classInstVar1 := true'}.
      {#'testClassMethod1'.
      'xxx'.
      'testClassMethod1 ^ ClassVar1'}.
      {#'testClassMethod3'.
      'yyy'.
      'testClassMethod3 ^ 2'}}
%

category: 'support - combined definitions'
method: RwLoadingTest
combinedInstanceMethodsForClass1: className
  ^ self
    methodDefsFromSpec:
      {{#'testInstanceMethod1'.
      'xxx'.
      'testInstanceMethod1 ^ true'}.
      {#'testInstanceMethod2'.
      'xxx'.
      'testInstanceMethod2 ^ true'}.
      {#'testInstanceMethod3'.
      'xxx'.
      'testInstanceMethod3 ^ 1'}}
%

category: 'support - combined definitions'
method: RwLoadingTest
combinedInstanceMethodsForClass2: className
  ^ self
    methodDefsFromSpec:
      {{#'testInstanceMethod1'.
      'xxx'.
      'testInstanceMethod1 ^ true'}.
      {#'testInstanceMethod3'.
      'yyy'.
      'testInstanceMethod3 ^ 2'}}
%

category: 'support - basic definitions'
method: RwLoadingTest
definitionOfBasicClassNamed: className superclass: superclassName type: classType instvars: instvars gs_options: gs_options inPackage: packageName
  ^ RwClassDefinition
    withProperties:
      (self
        propertiesForClassNamed: className
        super: superclassName
        instvars: instvars
        classinstvars: {}
        classvars: {}
        type: classType
        gs_options: gs_options
        inPackage: packageName)
    classMethodDefinitions: (self basicClassMethodsForClass: className)
    instanceMethodDefinitions: (self basicInstanceMethodsForClass: className)
%

category: 'support - basic definitions'
method: RwLoadingTest
definitionOfBasicClassNamed: className type: classType instvars: instvars gs_options: gs_options inPackage: packageName
  ^ self
    definitionOfBasicClassNamed: className
    superclass: 'Object'
    type: classType
    instvars: instvars
    gs_options: gs_options
    inPackage: packageName
%

category: 'support - classInitialization definitions'
method: RwLoadingTest
definitionOfClassInitializationClassNamed: className inPackage: packageName classMethodDefinitions: classMethodDefinitions
  ^ RwClassDefinition
    withProperties:
      (self
        propertiesOfClassInitializationClassNamed: className
        inPackage: packageName)
    classMethodDefinitions: classMethodDefinitions
    instanceMethodDefinitions: Dictionary new
%

category: 'support - methodDeletion definitions'
method: RwLoadingTest
definitionOfMethodDeletionClassNamed: className inPackage: packageName instanceMethodDefinitions: instanceMethodDefinitions classMethodDefinitions: classMethodDefinitions
  ^ RwClassDefinition
    withProperties:
      (self
        propertiesForClassNamed: className
        super: 'Object'
        instvars: {}
        classinstvars: {}
        classvars: {}
        type: 'normal'
        gs_options: {}
        inPackage: packageName)
    classMethodDefinitions: classMethodDefinitions
    instanceMethodDefinitions: instanceMethodDefinitions
%

category: 'support - basic definitions'
method: RwLoadingTest
definitionOfNormalClassNamed: className inPackage: packageName
  ^ self
    definitionOfBasicClassNamed: className
    type: 'normal'
    instvars: {}
    gs_options: {}
    inPackage: packageName
%

category: 'support - simple definitions'
method: RwLoadingTest
definitionOfSimpleClassNamed: name inPackage: packageName

	^RwClassDefinition
		withProperties: (self propertiesForSimpleClassNamed: name inPackage: packageName)
		classMethodDefinitions: (self sillyClassMethodsForClassNamed: name)
		instanceMethodDefinitions: (self accessorMethodsForSimpleClassNamed: name)
%

category: 'running'
method: RwLoadingTest
expectedFailures

	^ {#'testPoolDictionaryChanges'}
%

category: 'support - instVarChanges definitions'
method: RwLoadingTest
instVarChangeClassDefinitions1: packageName in: classDefinitionDictionary
	"Inst Var Changes: "

	^ classDefinitionDictionary
		at: 'TestInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestInstVarClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - instVarChanges definitions'
method: RwLoadingTest
instVarChangeClassDefinitions2: packageName in: classDefinitionDictionary
	"Inst Var Changes: add instVar1"

	^ classDefinitionDictionary
		at: 'TestInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestInstVarClass'
								super: 'Object'
								instvars: {'instVar1'}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - instVarChanges definitions'
method: RwLoadingTest
instVarChangeClassDefinitions3: packageName in: classDefinitionDictionary
	"Inst Var Changes: add instVar2"

	^ classDefinitionDictionary
		at: 'TestInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestInstVarClass'
								super: 'Object'
								instvars:
									{'instVar1'.
									'instVar2'}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - instVarChanges definitions'
method: RwLoadingTest
instVarChangeClassDefinitions4: packageName in: classDefinitionDictionary
	"Inst Var Changes: add instVar3 and remove instVar1"

	^ classDefinitionDictionary
		at: 'TestInstVarClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestInstVarClass'
								super: 'Object'
								instvars:
									{'instVar2'.
									'instVar3'}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - instVarChanges definitions'
method: RwLoadingTest
instVarChangesClassDefinitions1: packageName
	^ self instVarChangeClassDefinitions1: packageName in: Dictionary new
%

category: 'support - instVarChanges definitions'
method: RwLoadingTest
instVarChangesClassDefinitions2: packageName
	^ self instVarChangeClassDefinitions2: packageName in: Dictionary new
%

category: 'support - instVarChanges definitions'
method: RwLoadingTest
instVarChangesClassDefinitions3: packageName
	^ self instVarChangeClassDefinitions3: packageName in: Dictionary new
%

category: 'support - instVarChanges definitions'
method: RwLoadingTest
instVarChangesClassDefinitions4: packageName
	^ self instVarChangeClassDefinitions4: packageName in: Dictionary new
%

category: 'support'
method: RwLoadingTest
loadAndTestPackagesNamed: packageNames loaded: packagesShouldBeLoaded using: myPackageSet

	| imagePackageSet1 diff1 imagePackageSet2 diff2 |
	packagesShouldBeLoaded
		ifFalse: [ packageNames do: [ :name | self assertAbsenceOfPackage: name ] ].

	imagePackageSet1 := self _loadedPackageDefinitionsNamed: packageNames.
	diff1 := myPackageSet compareAgainstBase: imagePackageSet1.
	self deny: diff1 isEmpty.

	[ Rowan packageTools load loadPackageSetDefinition: myPackageSet ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].

	imagePackageSet2 := self _loadedPackageDefinitionsNamed: packageNames.
	diff2 := myPackageSet compareAgainstBase: imagePackageSet2.
	self assert: diff2 isEmpty
%

category: 'support'
method: RwLoadingTest
loadAndTestPackagesNamed: packageNames using: myPackageSet

	self loadAndTestPackagesNamed: packageNames loaded: false using: myPackageSet
%

category: 'support - methodDeletion definitions'
method: RwLoadingTest
methodDeletionClassMethodsForClass1: className
  ^ self
    methodDefsFromSpec:
      {{#'testClassMethod'.
      'class method to be deleted'.
      'testClassMethod ^ true'}.
      {#'testClassMethodSurvivor'.
      'class method to be kept'.
      'testClassMethodSurvivor ^ true'}}
%

category: 'support - methodDeletion definitions'
method: RwLoadingTest
methodDeletionClassMethodsForClass2: className
  ^ self
    methodDefsFromSpec:
      {{#'testClassMethodSurvivor'.
      'class method to be kept'.
      'testClassMethodSurvivor ^ true'}}
%

category: 'support - methodDeletion definitions'
method: RwLoadingTest
methodDeletionInstanceMethodsForClass1: className
  ^ self
    methodDefsFromSpec:
      {{#'testInstanceMethod'.
      'instance method to be deleted'.
      'testInstanceMethod ^ true'}.
      {#'testInstanceMethodSurvivor'.
      'instance method to be kept'.
      'testInstanceMethodSurvivor ^ true'}}
%

category: 'support - methodDeletion definitions'
method: RwLoadingTest
methodDeletionInstanceMethodsForClass2: className
  ^ self
    methodDefsFromSpec:
      {{#'testInstanceMethodSurvivor'.
      'instance method to be kept'.
      'testInstanceMethodSurvivor ^ true'}}
%

category: 'support - methodDeletion definitions'
method: RwLoadingTest
methodDeletionPackageDefinition: packageName className: className instanceMethodDefinitions: instanceMethodDefinitions classMethodDefinitions: classMethodDefinitions
  ^ RwPackageDefinition
    withProperties: (Dictionary with: 'name' -> packageName with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
    classDefinitions:
      (Dictionary new
        at: className
          put:
            (self
                definitionOfMethodDeletionClassNamed: className
                inPackage: packageName
                instanceMethodDefinitions: instanceMethodDefinitions
                classMethodDefinitions: classMethodDefinitions);
        yourself)
    classExtensions: Dictionary new
%

category: 'support - methodProtocolChange definitions'
method: RwLoadingTest
methodProtocolChangeClassMethodsForClass1: className
  ^ self
    methodDefsFromSpec:
      {{#'testClassMethod1'.
      'protocol A'.
      'testClassMethod1 ^ true'}.
      {#'testClassMethod2'.
      'protocol A'.
      'testClassMethod2 ^ true'}}
%

category: 'support - methodProtocolChange definitions'
method: RwLoadingTest
methodProtocolChangeClassMethodsForClass2: className
  ^ self
    methodDefsFromSpec:
      {{#'testClassMethod1'.
      'protocol A'.
      'testClassMethod1 ^ true'}.
      {#'testClassMethod2'.
      'protocol B'.
      'testClassMethod2 ^ true'}}
%

category: 'support - methodProtocolChange definitions'
method: RwLoadingTest
methodProtocolChangeInstanceMethodsForClass1: className
  ^ self
    methodDefsFromSpec:
      {{#'testInstanceMethod1'.
      'protocol A'.
      'testInstanceMethod1 ^ true'}.
      {#'testInstanceMethod2'.
      'protocol A'.
      'testInstanceMethod2 ^ true'}}
%

category: 'support - methodProtocolChange definitions'
method: RwLoadingTest
methodProtocolChangeInstanceMethodsForClass2: className
  ^ self
    methodDefsFromSpec:
      {{#'testInstanceMethod1'.
      'protocol A'.
      'testInstanceMethod1 ^ true'}.
      {#'testInstanceMethod2'.
      'protocol B'.
      'testInstanceMethod2 ^ true'}}
%

category: 'support - methodProtocolChange definitions'
method: RwLoadingTest
methodProtocolChangePackageDefinition: packageName className: className instanceMethodDefinitions: instanceMethodDefinitions classMethodDefinitions: classMethodDefinitions
  ^ self
    methodDeletionPackageDefinition: packageName
    className: className
    instanceMethodDefinitions: instanceMethodDefinitions
    classMethodDefinitions: classMethodDefinitions
%

category: 'support - simple definitions'
method: RwLoadingTest
package1Definition

	^RwPackageDefinition
		withProperties: (Dictionary with: 'name' -> 'TestPackage1'  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
		classDefinitions: (Dictionary
				with: 'TestClass1' -> (self definitionOfSimpleClassNamed: 'TestClass1' inPackage: 'TestPackage1'))
		classExtensions: Dictionary new
%

category: 'support - simple definitions'
method: RwLoadingTest
package2Definition

	^RwPackageDefinition
		withProperties: (Dictionary with: 'name' -> 'TestPackage2'  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
		classDefinitions: (Dictionary
				with: 'TestClass2' -> (self definitionOfSimpleClassNamed: 'TestClass2' inPackage: 'TestPackage2'))
		classExtensions: Dictionary new
%

category: 'support - poolDictionaryChanges definitions'
method: RwLoadingTest
poolDictionaryChangeClassDefinitions1: packageName in: classDefinitionDictionary
	"Pool Dictionary Changes: "

	^ classDefinitionDictionary
		at: 'TestPoolDictionaryClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestPoolDictionaryClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - poolDictionaryChanges definitions'
method: RwLoadingTest
poolDictionaryChangeClassDefinitions2: packageName in: classDefinitionDictionary
	"Pool Dictionary Changes: add PD1"

	^ classDefinitionDictionary
		at: 'TestPoolDictionaryClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestPoolDictionaryClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools: {(PoolDictionaryDictionary at: #'PoolDictionary1')}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - poolDictionaryChanges definitions'
method: RwLoadingTest
poolDictionaryChangeClassDefinitions3: packageName in: classDefinitionDictionary
	"Pool Dictionary Changes: add PD2"

	^ classDefinitionDictionary
		at: 'TestPoolDictionaryClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestPoolDictionaryClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools:
									{(PoolDictionaryDictionary at: #'PoolDictionary1').
									(PoolDictionaryDictionary at: #'PoolDictionary2')}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - poolDictionaryChanges definitions'
method: RwLoadingTest
poolDictionaryChangeClassDefinitions4: packageName in: classDefinitionDictionary
	"Pool Dictionary Changes: add PD3 and remove PD1"

	^ classDefinitionDictionary
		at: 'TestPoolDictionaryClass'
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: 'TestPoolDictionaryClass'
								super: 'Object'
								instvars: {}
								classinstvars: {}
								classvars: {}
								comment: 'a comment'
								pools:
									{(PoolDictionaryDictionary at: #'PoolDictionary2').
									(PoolDictionaryDictionary at: #'PoolDictionary3')}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions: Dictionary new);
		yourself
%

category: 'support - poolDictionaryChanges definitions'
method: RwLoadingTest
poolDictionaryChangesClassDefinitions1: packageName
	^ self poolDictionaryChangeClassDefinitions1: packageName in: Dictionary new
%

category: 'support - poolDictionaryChanges definitions'
method: RwLoadingTest
poolDictionaryChangesClassDefinitions2: packageName
	^ self poolDictionaryChangeClassDefinitions2: packageName in: Dictionary new
%

category: 'support - poolDictionaryChanges definitions'
method: RwLoadingTest
poolDictionaryChangesClassDefinitions3: packageName
	^ self poolDictionaryChangeClassDefinitions3: packageName in: Dictionary new
%

category: 'support - poolDictionaryChanges definitions'
method: RwLoadingTest
poolDictionaryChangesClassDefinitions4: packageName
	^ self poolDictionaryChangeClassDefinitions4: packageName in: Dictionary new
%

category: 'private'
method: RwLoadingTest
projectDefinitionFor: packageNames

	| projectDefinition |
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: 'RwloadingTest')
		comment:
				'This is a simple project created in memory first, then written to disk.';
		packageNames: packageNames;
		defaultSymbolDictName: self _symbolDictionaryName;
		yourself.

	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName.

	^ projectDefinition
%

category: 'support'
method: RwLoadingTest
propertiesForClassNamed: className super: superClassName instvars: instvars classinstvars: classinstvars classvars: classvars comment: comment pools: pools inPackage: packageName

	^ self
		propertiesForClassNamed: className
		super: superClassName
		instvars: instvars
		classinstvars: classinstvars
		classvars: classvars
		comment: comment
		gs_SymbolDictionary: self _symbolDictionaryName asString
		pools: pools
		type: 'normal'
		gs_options: {}
		inPackage: packageName
%

category: 'support'
method: RwLoadingTest
propertiesForClassNamed: className super: superClassName instvars: instvars classinstvars: classinstvars classvars: classvars type: type gs_options: gs_options inPackage: packageName

	^ self
		propertiesForClassNamed: className
		super: superClassName
		instvars: instvars
		classinstvars: classinstvars
		classvars: classvars
		comment:
			'I am a class generated by Cypress tests. My name is ' , className
				, ', what''s yours?'
		gs_SymbolDictionary: self _symbolDictionaryName asString
		pools: {}
		type: type
		gs_options: gs_options
		inPackage: packageName
%

category: 'support - simple definitions'
method: RwLoadingTest
propertiesForSimpleClassNamed: className inPackage: packageName

	| dict |
	dict := Dictionary new.
	dict
		at: 'category' put: packageName;
		at: 'classinstvars' put: Array new;
		at: 'classvars' put: Array new;
		at: 'comment'
			put:
				'I am a class generated by Cypress tests. My name is ' , className
						, ', what''s yours?';
		at: 'gs_SymbolDictionary' put: self _symbolDictionaryName asString;
		at: 'instvars'
			put: (Array with: 'iv1In' , className with: 'iv2In' , className);
		at: 'name' put: className;
		at: 'pools' put: Array new;
		at: 'superclass' put: 'Object';
		at: 'type' put: 'normal'.
	^ dict
%

category: 'support - classInitialization definitions'
method: RwLoadingTest
propertiesOfClassInitializationClassNamed: className inPackage: packageName
  ^ self
    propertiesForClassNamed: className
    super: 'Object'
    instvars: {}
    classinstvars:
      {'classInstVar1'.
      'classInstVar2'}
    classvars: {'ClassVar1'}
    type: 'normal'
    gs_options: {}
    inPackage: packageName
%

category: 'support - simple definitions'
method: RwLoadingTest
sillyClassMethodsForClassNamed: name

	^Dictionary
		with: #'sillyMessage' -> (RwMethodDefinition
						withProperties: (Dictionary with: 'selector' -> #'sillyMessage'
								with: 'protocol' -> 'silliness')
						source: 'sillyMessage
	^ ''You have sent a silly message to the class '' , name')
%

category: 'support - singleClassVersionChange definitions'
method: RwLoadingTest
singleClassVersionChangeClassDefinitions1: packageName className: className

	"Single class with a method #foo. and new class version"

	^ Dictionary new
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: 'Object'
								instvars: #()
								classinstvars: #()
								classvars: #()
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions:
							(self methodDefsFromSpec: {#(#'foo' 'accessing' 'foo ^''foo''')}));
		yourself
%

category: 'support - singleClassVersionChange definitions'
method: RwLoadingTest
singleClassVersionChangeClassDefinitions2: packageName className: className

	"Single class with method foo and new class version."

	"add iva and preserve foo unchanged. "

	^ Dictionary new
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: 'Object'
								instvars: #('iva')
								classinstvars: #()
								classvars: #()
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions:
							(self methodDefsFromSpec: {#(#'foo' 'accessing' 'foo ^''foo''')}));
		yourself
%

category: 'support - singleClassVersionChange definitions'
method: RwLoadingTest
singleClassVersionChangeClassDefinitions3: packageName className: className

	"Single class with method foo and new class version."

	"add civa and change foo. "

	^ Dictionary new
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: 'Object'
								instvars: #('iva')
								classinstvars: #('civa')
								classvars: #()
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions:
							(self methodDefsFromSpec: {#(#'foo' 'accessing' 'foo ^''bar''')}));
		yourself
%

category: 'support - singleClassVersionChange definitions'
method: RwLoadingTest
singleClassVersionChangeClassDefinitions4: packageName className: className

	"Single class with method foo and new class version."

	"add civa and change protocol of foo. "

	^ Dictionary new
		at: className
			put:
				(RwClassDefinition
						withProperties:
							(self
								propertiesForClassNamed: className
								super: 'Object'
								instvars: #('iva')
								classinstvars: #('civa')
								classvars: #('CVA')
								comment: 'a comment'
								pools: {}
								inPackage: packageName)
						classMethodDefinitions: Dictionary new
						instanceMethodDefinitions:
							(self methodDefsFromSpec: {#(#'foo' 'fooing' 'foo ^''foo''')}));
		yourself
%

category: 'tests'
method: RwLoadingTest
testBasicLoading

	"test loading a variety of different class types"

	| packageName packageNames myPackageSet |
	packageName := 'BasicTestPackage'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage: (self basicPackageDefinition: packageName);
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
%

category: 'tests'
method: RwLoadingTest
testClassAdd

	"test class addition"

	| packageName packageNames myPackageSet className testClass loadedClass |
	packageName := 'ClassAdditionTestPackage'.
	className := 'TestClassAdditionClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(self
						methodDeletionPackageDefinition: packageName
						className: className
						instanceMethodDefinitions:
							(self methodDeletionInstanceMethodsForClass1: className)
						classMethodDefinitions:
							(self methodDeletionClassMethodsForClass1: className));
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	loadedClass := self _symbolDictionary rowanSymbolDictionaryRegistry
		existingForClass: testClass
		ifAbsent: [ 
			"expected to find a loaded class"
			self assert: false ].
	self assert: testClass == loadedClass handle
%

category: 'tests'
method: RwLoadingTest
testClassDelete

	"test class deletion"

	| packageName packageNames myPackageSet className testClass testInstance |
	packageName := 'ClassDeletionTestPackage'.
	className := 'TestClassDeletionClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(self
						methodDeletionPackageDefinition: packageName
						className: className
						instanceMethodDefinitions:
							(self methodDeletionInstanceMethodsForClass1: className)
						classMethodDefinitions:
							(self methodDeletionClassMethodsForClass1: className));
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	testClass := Rowan image resolveClassNamed: className asSymbol.
	testInstance := testClass new.
	self
		assert:
				(testClass class compiledMethodAt: #'testClassMethod' otherwise: false) ~~ false;
		assert: (testClass perform: #testClassMethod);
		assert: (testClass perform: #testClassMethodSurvivor).
	self
		assert:
				(testClass compiledMethodAt: #'testInstanceMethod' otherwise: false) ~~ false;
		assert: (testInstance perform: #testInstanceMethod);
		assert: (testInstance perform: #testInstanceMethodSurvivor).
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: Dictionary new
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	self assert: (Rowan image resolveClassNamed: className asSymbol) isNil
%

category: 'tests'
method: RwLoadingTest
testClassExtension

	"test class extenstion methods"

	| packageName1 packageName2 packageNames myPackageSet className testClass testInstance |
	className := 'TestClassExtensionClass'.
	packageName1 := 'ClassExtensionsBaseTestPackage'.
	packageName2 := 'ClassExtensionsExtensionTestPackage'.
	packageNames := {packageName1}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName1  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self
								classExtionsClassDefinitions1: packageName1
								className: className
								in: Dictionary new)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: false using: myPackageSet.
	testClass := Rowan image resolveClassNamed: className asSymbol.
	testInstance := testClass new.
	self should: [ testInstance perform: #foo ] raise: MessageNotUnderstood.
	packageNames := {packageName2}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName2  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: Dictionary new
						classExtensions:
							(self
								classExtionsClassDefinitions2: packageName2
								className: className
								in: Dictionary new));
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: false using: myPackageSet.
	self assert: (testInstance perform: #foo) = 'foo'
%

category: 'tests'
method: RwLoadingTest
testClassInitialization1

	"test that class #initialize method is run when the class #initialize method is added"

	| packageName packageNames myPackageSet className testClass |
	packageName := 'ClassInitializationTestPackage'.
	className := 'TestClassInitializationClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(self
						classInitializePackageDefinition: packageName
						className: className
						classMethodDefinitions:
							(self classInitializationClassMethodsForClass1: className));
		yourself.
	[ self loadAndTestPackagesNamed: packageNames using: myPackageSet ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].
	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: (testClass perform: #classVar) = 1.
	self assert: (testClass perform: #classInstVar1) = 1
%

category: 'tests'
method: RwLoadingTest
testClassInitialization2

	"test that class #initialize method is run when the class #initialize method is changed"

	| packageName packageNames myPackageSet className testClass |
	packageName := 'ClassInitializationTestPackage'.
	className := 'TestClassInitializationClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(self
						classInitializePackageDefinition: packageName
						className: className
						classMethodDefinitions:
							(self classInitializationClassMethodsForClass1: className));
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: (testClass perform: #classVar) = 1.
	self assert: (testClass perform: #classInstVar1) = 1.
	self assert: (testClass perform: #classInstVar2) isNil.	"update the initialization method ... #initialize should run again"
	packageName := 'ClassInitializationTestPackage'.
	className := 'TestClassInitializationClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(self
						classInitializePackageDefinition: packageName
						className: className
						classMethodDefinitions:
							(self classInitializationClassMethodsForClass2: className));
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	self assert: (testClass perform: #classVar) = 1.
	self assert: (testClass perform: #classInstVar1) = 1.
	self assert: (testClass perform: #classInstVar2) = 2
%

category: 'tests'
method: RwLoadingTest
testClassInitialization3

	"test that cadidateClass is set for RwExecuteClassInitializeMethodsAfterLoadNotification when the class #initialize method is added"

	| packageName packageNames myPackageSet className testClass |
	packageName := 'ClassInitializationTestPackage'.
	className := 'TestClassInitializationClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(self
						classInitializePackageDefinition: packageName
						className: className
						classMethodDefinitions:
							(self classInitializationClassMethodsForClass1: className));
		yourself.
	[ self loadAndTestPackagesNamed: packageNames using: myPackageSet ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | 
			self assert: ex candidateClass name asString = className.
			ex resume: true ].
	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: (testClass perform: #classVar) = 1.
	self assert: (testClass perform: #classInstVar1) = 1
%

category: 'tests'
method: RwLoadingTest
testClassInstVarChanges

	"characterize class inst var changes with respect to new version creation"

	"as of GemStone 3.4, .... any change to the class inst vars creates a new class version"

	| packageName packageNames myPackageSet className testClass1 testClass2 testClass3 testClass4 civs1 civs2 civs3 civs4 |
	packageName := 'ClassInstVarChangesTestPackage'.
	className := 'TestClassInstVarClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classInstVarChangesClassDefinitions1: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	testClass1 := Rowan image resolveClassNamed: className asSymbol.
	civs1 := testClass1 _classInstVars copy.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classInstVarChangesClassDefinitions2: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass2 := Rowan image resolveClassNamed: className asSymbol.
	civs2 := testClass2 _classInstVars copy.
	self deny: testClass2 == testClass1.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classInstVarChangesClassDefinitions3: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass3 := Rowan image resolveClassNamed: className asSymbol.
	civs3 := testClass3 _classInstVars copy.
	self deny: testClass3 == testClass1.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classInstVarChangesClassDefinitions4: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass4 := Rowan image resolveClassNamed: className asSymbol.
	civs4 := testClass4 _classInstVars copy.
	self deny: testClass4 == testClass1
%

category: 'tests'
method: RwLoadingTest
testClassPropertyChangesWithNewClassVersion1
	"test class property changes that result in new class versions"

	| packageName packageNames myPackageSet |
	packageName := 'NewClassVersionChangesTestPackage'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classVersionChangeClassDefinitions1: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classVersionChangeClassDefinitions2: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet
%

category: 'tests'
method: RwLoadingTest
testClassPropertyChangesWithNewClassVersion2
	"test class property changes that result in new class versions"

	"add methods that reference the new class properties"

	| packageName packageNames myPackageSet |
	packageName := 'NewClassVersionChangesTestPackage'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classVersionChangeClassDefinitions1: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classVersionChangeClassDefinitions3: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet
%

category: 'tests'
method: RwLoadingTest
testClassPropertyChangesWithNoNewClassVersion
	"test class property changes that do no result in new class versions"

	| packageName packageNames myPackageSet |
	packageName := 'ClassPropertyChangesTestPackage'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classPropertyChangeClassDefinitions1: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classPropertyChangeClassDefinitions2: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet
%

category: 'tests'
method: RwLoadingTest
testClassVarChanges

	"characterize class var changes with respect to new version creation"

	"as of GemStone 3.4, adding and removing Class Vars does not cause the 
		creation of a new class version"

	| packageName packageNames myPackageSet className testClass1 testClass2 testClass3 testClass4 cvs1 cvs2 cvs3 cvs4 |
	packageName := 'ClassVarChangesTestPackage'.
	className := 'TestClassVarClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self  _symbolDictionaryName asString)
						classDefinitions: (self classVarChangesClassDefinitions1: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	testClass1 := Rowan image resolveClassNamed: className asSymbol.
	cvs1 := testClass1 _classVars copy.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classVarChangesClassDefinitions2: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass2 := Rowan image resolveClassNamed: className asSymbol.
	cvs2 := testClass2 _classVars copy.
	self assert: testClass2 == testClass1.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classVarChangesClassDefinitions3: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass3 := Rowan image resolveClassNamed: className asSymbol.
	cvs3 := testClass3 _classVars copy.
	self assert: testClass3 == testClass1.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self classVarChangesClassDefinitions4: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass4 := Rowan image resolveClassNamed: className asSymbol.
	cvs4 := testClass4 _classVars copy.
	self assert: testClass4 == testClass1
%

category: 'tests'
method: RwLoadingTest
testCombinedChanges

	"single package update that includes an example of each kind of change supported"

	| packageName packageNames myPackageSet className testClass testInstance classDefinitionsDictionary deletedClassName |
	packageName := 'CombinedTestPackage'.
	className := 'TestCombinedChangesClass'.
	deletedClassName := 'TestClassDeletionClass'.
	packageNames := {packageName}.
	classDefinitionsDictionary := (self basicClassDefinitions: packageName)
		at: className
			put:
				((self
						definitionOfMethodDeletionClassNamed: className
						inPackage: packageName
						instanceMethodDefinitions:
							(self combinedInstanceMethodsForClass1: className)
						classMethodDefinitions: (self combinedClassMethodsForClass1: className))
						properties:
								(self
										propertiesOfClassInitializationClassNamed: className
										inPackage: packageName);
						yourself);
		at: deletedClassName
			put:
				((self
						definitionOfMethodDeletionClassNamed: deletedClassName
						inPackage: packageName
						instanceMethodDefinitions:
							(self combinedInstanceMethodsForClass1: deletedClassName)
						classMethodDefinitions:
							(self combinedClassMethodsForClass1: deletedClassName))
						properties:
								(self
										propertiesOfClassInitializationClassNamed: deletedClassName
										inPackage: packageName);
						yourself);
		yourself.
	myPackageSet := RwPackageSetDefinition new
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: classDefinitionsDictionary
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	testClass := Rowan image resolveClassNamed: className asSymbol.
	testInstance := testClass new.
	self
		assert: (testClass perform: #testClassMethod1);
		assert: (testClass perform: #testClassMethod2);
		assert: (testClass perform: #testClassMethod3) = 1;
		assert: (testInstance perform: #testInstanceMethod1);
		assert: (testInstance perform: #testInstanceMethod2);
		assert: (testInstance perform: #testInstanceMethod3) = 1.
	packageNames := {packageName}.
	classDefinitionsDictionary := (self basicClassDefinitions: packageName)
		at: className
			put:
				((self
						definitionOfMethodDeletionClassNamed: className
						inPackage: packageName
						instanceMethodDefinitions:
							(self combinedInstanceMethodsForClass2: className)
						classMethodDefinitions: (self combinedClassMethodsForClass2: className))
						properties:
								(self
										propertiesOfClassInitializationClassNamed: className
										inPackage: packageName);
						yourself);
		yourself.
	myPackageSet := RwPackageSetDefinition new
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: classDefinitionsDictionary
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	self
		assert: (testClass perform: #testClassMethod1);
		assert:
				(testClass class compiledMethodAt: #'testClassMethod2' otherwise: false)
						== false;
		assert: (testClass perform: #testClassMethod3) = 2;
		assert: (testInstance perform: #testInstanceMethod1);
		assert:
				(testClass compiledMethodAt: #'testInstanceMethod2' otherwise: false) == false;
		assert: (testInstance perform: #testInstanceMethod3) = 2
%

category: 'tests'
method: RwLoadingTest
testInstVarChanges

	"characterize class inst var changes with respect to new version creation"

	"as of GemStone 3.4, .... any change to the inst vars creates a new class version"

	| packageName packageNames myPackageSet className testClass1 testClass2 testClass3 testClass4 ivs1 ivs2 ivs3 ivs4 |
	packageName := 'InstVarChangesTestPackage'.
	className := 'TestInstVarClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self instVarChangesClassDefinitions1: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	testClass1 := Rowan image resolveClassNamed: className asSymbol.
	ivs1 := testClass1 _instVarNames copy.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self instVarChangesClassDefinitions2: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass2 := Rowan image resolveClassNamed: className asSymbol.
	ivs2 := testClass2 _instVarNames copy.
	self deny: testClass2 == testClass1.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self instVarChangesClassDefinitions3: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass3 := Rowan image resolveClassNamed: className asSymbol.
	ivs3 := testClass3 _instVarNames copy.
	self deny: testClass3 == testClass1.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions: (self instVarChangesClassDefinitions4: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass4 := Rowan image resolveClassNamed: className asSymbol.
	ivs4 := testClass4 _instVarNames copy.
	self deny: testClass4 == testClass1
%

category: 'tests'
method: RwLoadingTest
testMethodDelete

	"test class and instance method deletion"

	| packageName packageNames myPackageSet className testClass testInstance |
	packageName := 'MethodDeletionTestPackage'.
	className := 'TestMethodDeletionClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(self
						methodDeletionPackageDefinition: packageName
						className: className
						instanceMethodDefinitions:
							(self methodDeletionInstanceMethodsForClass1: className)
						classMethodDefinitions:
							(self methodDeletionClassMethodsForClass1: className));
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	testClass := Rowan image resolveClassNamed: className asSymbol.
	testInstance := testClass new.
	self
		assert:
				(testClass class compiledMethodAt: #'testClassMethod' otherwise: false) ~~ false;
		assert: (testClass perform: #testClassMethod);
		assert: (testClass perform: #testClassMethodSurvivor).
	self
		assert:
				(testClass compiledMethodAt: #'testInstanceMethod' otherwise: false) ~~ false;
		assert: (testInstance perform: #testInstanceMethod);
		assert: (testInstance perform: #testInstanceMethodSurvivor).
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(self
						methodDeletionPackageDefinition: packageName
						className: className
						instanceMethodDefinitions:
							(self methodDeletionInstanceMethodsForClass2: className)
						classMethodDefinitions:
							(self methodDeletionClassMethodsForClass2: className));
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	self
		assert:
				(testClass class compiledMethodAt: #'testClassMethod' otherwise: false) == false;
		assert: (testClass perform: #testClassMethodSurvivor).
	self
		assert:
				(testClass compiledMethodAt: #'testInstanceMethod' otherwise: false) == false;
		assert: (testInstance perform: #testInstanceMethodSurvivor)
%

category: 'tests'
method: RwLoadingTest
testMethodProtocolChange

	"test class and instance method protocol changes"

	| packageName packageNames myPackageSet className testClass testInstance |
	packageName := 'MethodProtocolChangedTestPackage'.
	className := 'TestMethodProtocolChangeClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(self
						methodProtocolChangePackageDefinition: packageName
						className: className
						instanceMethodDefinitions:
							(self methodProtocolChangeInstanceMethodsForClass1: className)
						classMethodDefinitions:
							(self methodProtocolChangeClassMethodsForClass1: className));
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	testClass := Rowan image resolveClassNamed: className asSymbol.
	testInstance := testClass new.
	self
		assert: (testClass perform: #testClassMethod1);
		assert: (testClass perform: #testClassMethod2);
		assert: (testInstance perform: #testInstanceMethod1);
		assert: (testInstance perform: #testInstanceMethod2).
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(self
						methodProtocolChangePackageDefinition: packageName
						className: className
						instanceMethodDefinitions:
							(self methodProtocolChangeInstanceMethodsForClass2: className)
						classMethodDefinitions:
							(self methodProtocolChangeClassMethodsForClass2: className));
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	self
		assert: (testClass perform: #testClassMethod1);
		assert: (testClass perform: #testClassMethod2);
		assert: (testInstance perform: #testInstanceMethod1);
		assert: (testInstance perform: #testInstanceMethod2)
%

category: 'tests'
method: RwLoadingTest
testPoolDictionaryChanges

	"characterize pool dictionary changes with respect to new version creation"

	"as of GemStone 3.4, .... "

	| packageName packageNames myPackageSet className testClass1 testClass2 testClass3 testClass4 pds1 pds2 pds3 pds4 |
	packageName := 'TestPoolDictionaryTestPackage'.
	className := 'TestPoolDictionaryClass'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self poolDictionaryChangesClassDefinitions1: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
	testClass1 := Rowan image resolveClassNamed: className asSymbol.
	pds1 := testClass1 _poolDictionaries copy.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self poolDictionaryChangesClassDefinitions2: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass2 := Rowan image resolveClassNamed: className asSymbol.
	pds2 := testClass2 _poolDictionaries copy.
	self deny: testClass2 == testClass1.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self poolDictionaryChangesClassDefinitions3: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass3 := Rowan image resolveClassNamed: className asSymbol.
	pds3 := testClass3 _poolDictionaries copy.
	self deny: testClass3 == testClass1.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self poolDictionaryChangesClassDefinitions4: packageName)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.
	testClass4 := Rowan image resolveClassNamed: className asSymbol.
	pds4 := testClass4 _poolDictionaries copy.
	self deny: testClass4 == testClass1
%

category: 'tests'
method: RwLoadingTest
testSimpleLoading
	"validate functionality loading a simple class"

	| packageNames myPackageSet |
	packageNames := #('TestPackage1' 'TestPackage2').
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage: self package1Definition;
		addPackage: self package2Definition.
	self loadAndTestPackagesNamed: packageNames using: myPackageSet.
%

category: 'tests'
method: RwLoadingTest
testSingleClassVersionChange1

	"add an instance variable to a class that has a single method"

	"No automatic instance migration"

	| packageName packageNames myPackageSet className testClass1 testInstance1 testClass2 testInstance2 |
	packageName := 'SingleClassVersionChangeTestPackage'.
	className := 'TestSingleClassNewVersions'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self
								singleClassVersionChangeClassDefinitions1: packageName
								className: className)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: false using: myPackageSet.

	testClass1 := Rowan image resolveClassNamed: className asSymbol.
	testInstance1 := testClass1 new.
	self assert: (testInstance1 perform: #foo) = 'foo'.
	self assert: (testClass1 categoryOfSelector: #foo) = #'accessing'.

	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self
								singleClassVersionChangeClassDefinitions2: packageName
								className: className)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.

	testClass2 := Rowan image resolveClassNamed: className asSymbol.
	testInstance2 := testClass2 new.
	self deny: testClass2 == testClass1.
	self assert: (testInstance2 perform: #foo) = 'foo'.
	self assert: (testClass2 categoryOfSelector: #foo) = #'accessing'.
%

category: 'tests'
method: RwLoadingTest
testSingleClassVersionChange2

	"add a class instance variable to a class that has a single method and change the method"

	"No automatic instance migration"

	| packageName packageNames myPackageSet className testClass1 testInstance1 testClass2 testInstance2 |
	packageName := 'SingleClassVersionChangeTestPackage'.
	className := 'TestSingleClassNewVersions'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self
								singleClassVersionChangeClassDefinitions2: packageName
								className: className)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: false using: myPackageSet.

	testClass1 := Rowan image resolveClassNamed: className asSymbol.
	testInstance1 := testClass1 new.
	self assert: (testInstance1 perform: #foo) = 'foo'.
	self assert: (testClass1 categoryOfSelector: #foo) = #'accessing'.

	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self
								singleClassVersionChangeClassDefinitions3: packageName
								className: className)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.

	testClass2 := Rowan image resolveClassNamed: className asSymbol.
	testInstance2 := testClass2 new.
	self deny: testClass2 == testClass1.
	self assert: (testInstance2 perform: #foo) = 'bar'.
	self assert: (testClass2 categoryOfSelector: #foo) = #'accessing'.
%

category: 'tests'
method: RwLoadingTest
testSingleClassVersionChange3

	"add a class instance variable to a class that has a single method and change the protocol of the method"

	"No automatic instance migration"

	| packageName packageNames myPackageSet className testClass1 testInstance1 testClass2 testInstance2 |
	packageName := 'SingleClassVersionChangeTestPackage'.
	className := 'TestSingleClassNewVersions'.
	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self
								singleClassVersionChangeClassDefinitions2: packageName
								className: className)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: false using: myPackageSet.

	testClass1 := Rowan image resolveClassNamed: className asSymbol.
	testInstance1 := testClass1 new.
	self assert: (testInstance1 perform: #foo) = 'foo'.
	self assert: (testClass1 categoryOfSelector: #foo) = #'accessing'.

	packageNames := {packageName}.
	myPackageSet := RwPackageSetDefinition new.
	myPackageSet
		addPackage:
				(RwPackageDefinition
						withProperties: (Dictionary with: 'name' -> packageName  with: 'gs_SymbolDictionary' -> self _symbolDictionaryName asString)
						classDefinitions:
							(self
								singleClassVersionChangeClassDefinitions4: packageName
								className: className)
						classExtensions: Dictionary new);
		yourself.
	self loadAndTestPackagesNamed: packageNames loaded: true using: myPackageSet.

	testClass2 := Rowan image resolveClassNamed: className asSymbol.
	testInstance2 := testClass2 new.
	self deny: testClass2 == testClass1.
	self assert: (testInstance2 perform: #foo) = 'foo'.
	self assert: (testClass2 categoryOfSelector: #foo) = #'fooing'.
%

category: 'private'
method: RwLoadingTest
_symbolDictionaryName

	^ self _unmanagedDictionaryName
%

! Class implementation for 'RwProjectComponentDefinitionsTest'

!		Class methods for 'RwProjectComponentDefinitionsTest'

category: 'private'
classmethod: RwProjectComponentDefinitionsTest
_symbolDictionaryNames
	^ super _symbolDictionaryNames , #(#'SampleSymbolDict'  #'RowanSample2' #'RowanSample2_SD')
%

!		Instance methods for 'RwProjectComponentDefinitionsTest'

category: 'tests'
method: RwProjectComponentDefinitionsTest
testCloneComponentProject

	| rowanProject urlString projectDefinition |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	urlString :=  'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample1_masterV2.ston'.

	projectDefinition := (urlString asRwUrl asSpecification asDefinition)
		projectHome: self _testRowanProjectsSandbox;
		yourself.

"setup"
	projectDefinition repositoryRoot ensureDeleteAll.
	self deny: (projectDefinition repositoryRoot / 'rowan' / 'projects' / 'RowanSample2.ston') exists.

"clone"
	projectDefinition clone.

"validate"
	self assert: (projectDefinition repositoryRoot / 'rowan' / 'projects' / 'RowanSample2.ston') exists.	"present in masterV2.0 branch"
%

category: 'tests'
method: RwProjectComponentDefinitionsTest
testCreateComponentProject_01

	"create Rowan project from scratch"

	"execute without errors .. for now"

	| projectName project |
	projectName := 'Example'.
	Rowan projectNamed: projectName ifPresent: [:prj | prj unload ].

	project := RwComponentProjectDefinition
		projectName: projectName 
			componentNamesToLoad: #( 'Core' )
			groupNamesToLoad: #( 'core' 'tests' )
			defaultComponentName: 'Core'
			defaultGroupName: 'core'
			packageFormat: 'tonel'
			projectHome: '$ROWAN_PROJECTS_HOME'
			specsPath: 'rowan/specs'
			componentsPath: 'rowan/componenets'
			packagesPath: 'rowan/src'
			projectsPath: 'rowan/projects'
			useGit: true
			comment: 'Example project exposing the standard project creation api'.
	project
		addComponentNamed: 'Core'
			definedGroupNames: 
				(Dictionary new
					add: 'core'  -> {};
					add: 'tests' -> { 'core' };
					yourself)
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'ExampleCore'
			comment: 'Primary component used for loading entire system.';
		addPackageNamed: 'Example-Core1'
			withConditions: { 'common' };
		addPackageNamed: 'Example-Core2'
			withConditions: { 'common' };
		addPackageNamed: 'Example-Tests'
			withConditions: { 'common' }
			andGroupName: 'tests';
		addPackageNamed: 'Example-Test-Extensions'
			toComponentNamed: 'Core'
			withConditions: { 'gemstone' }
			andGroupName: 'tests';
		addPackageNamed: 'Example-GemStone-Extensions'
			toComponentNamed: 'Core'
			withConditions: { 'gemstone' }
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'Globals';
		addPackageNamed: 'Example-GemStone-Test-Extensions'
			toComponentNamed: 'Core'
			withConditions: { 'gemstone' }
			andGroupName: 'tests'
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'Globals';
		yourself
%

category: 'tests'
method: RwProjectComponentDefinitionsTest
testCreateComponentProject_02


	"Create a Rowan project from scratch, using the available defaults"

	"execute without errors .. for now"

	| projectName project |
	projectName := 'Example'.
	Rowan projectNamed: projectName ifPresent: [:prj | prj unload ].

	project := RwComponentProjectDefinition
		projectName: projectName 
			projectHome: '$ROWAN_PROJECTS_HOME'
			useGit: true
			comment: 'Example project exposing the standard project creation api'.
	project
		addComponentNamed: 'Core'
			comment: 'Primary component used for loading entire system.';
		addPackagesNamed: { 'Example-Core1' . 'Example-Core2' };
		addPackageNamed: 'Example-Core3'
			withConditions: { 'common' };
		addPackageNamed: 'Example-Core4'
			withConditions: { 'common' };
		addPackageNamed: 'Rowan-Tests'
			withConditions: { 'common' }
			andGroupName: 'tests';
		addPackageNamed: 'Example-GemStone-Extensions'
			withConditions: { 'gemstone' }
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'Globals';
		addPackageNamed: 'Example-GemStone-Test-Extensions'
			withConditions: { 'gemstone' }
			andGroupName: 'tests'
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'Globals';
		yourself
%

category: 'tests'
method: RwProjectComponentDefinitionsTest
testCreateComponentProject_03

	"Create a Rowan project from scratch, using array-based apis for sets of packages that have the same
		package attributes"

	"execute without errors .. for now"

	| projectName project |
	projectName := 'Example'.
	Rowan projectNamed: projectName ifPresent: [:prj | prj unload ].

	project := RwComponentProjectDefinition
		projectName: projectName 
			componentNamesToLoad: #( 'Core' )
			groupNamesToLoad: #( 'core' 'tests' )
			defaultComponentName: 'Core'
			defaultGroupName: 'core'
			packageFormat: 'tonel'
			projectHome: '$ROWAN_PROJECTS_HOME'
			specsPath: 'rowan/specs'
			componentsPath: 'rowan/componenets'
			packagesPath: 'rowan/src'
			projectsPath: 'rowan/projects'
			useGit: true
			comment: 'Example project exposing the standard project creation api'.
	project
		addComponentNamed: 'Core'
			definedGroupNames: 
				(Dictionary new
					add: 'core'  -> {};
					add: 'tests' -> { 'core' };
					yourself)
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'ExampleCore'
			comment: 'Primary component used for loading entire system.';
		addPackagesNamed: {'Example-Core1' . 'Example-Core2'}
			withConditions: { 'common' };
		addPackagesNamed: { 'Example-Tests1' . 'Example-Tests2' }
			withConditions: { 'common' }
			andGroupName: 'tests';
		addPackagesNamed: { 'Example-Test-Extensions1' . 'Example-Test-Extensions2' }
			toComponentNamed: 'Core'
			withConditions: { 'common' }
			andGroupName: 'tests';
		addPackagesNamed: { 'Example-GemStone-Extensions1' . 'Example-GemStone-Extensions2' }
			toComponentNamed: 'Core'
			withConditions: { 'gemstone' }
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'Globals';
		addPackagesNamed: { 'Example-GemStone-Extensions3' . 'Example-GemStone-Extensions4' }
			withConditions: { 'gemstone' }
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'Globals';
		addPackagesNamed: { 'Example-GemStone-Test-Extensions1' . 'Example-GemStone-Test-Extensions2' }
			toComponentNamed: 'Core'
			withConditions: { 'gemstone' }
			andGroupName: 'tests'
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'Globals';
		addPackagesNamed: { 'Example-GemStone-Test-Extensions3' . 'Example-GemStone-Test-Extensions4' }
			withConditions: { 'gemstone' }
			andGroupName: 'tests'
			gemstoneDefaultSymbolDictionaryForUser: 'SystemUser' -> 'Globals';
		yourself
%

category: 'tests'
method: RwProjectComponentDefinitionsTest
testLoadRowanSample1_masterV20

	| rowanProject projectsHome urlString projectSample1Definition projectSample2Definition 
		projectSetDefinition1 projectSetDefinition2 x |

	#( 'RowanSample1' 'RowanSample2') do: [:prjName |
		(Rowan image loadedProjectNamed: prjName ifAbsent: [  ])
			ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectsHome := self self _testRowanProjectsSandbox.

	urlString :=  'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample1_masterV2.ston'.
	projectSample1Definition := (urlString asRwUrl asSpecification asDefinition)
		projectHome: projectsHome;
		yourself.

	urlString :=  'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample2_masterV2.ston'.
	projectSample2Definition := (urlString asRwUrl asSpecification asDefinition)
		projectHome: projectsHome;
		yourself.

"setup"
	projectSample1Definition repositoryRoot ensureDeleteAll.
	projectSample2Definition repositoryRoot ensureDeleteAll.

"clone"
	projectSetDefinition2 := projectSample2Definition clone.	"we want RowanSample2 to be freshly cloned into projectsHome"
	projectSetDefinition1 := projectSample1Definition clone.

"validate"
	self assert: (x := projectSetDefinition1 projectNames asArray sort) = #( 'RowanSample1' 'RowanSample2').

"load both 1 and 2"
	projectSample1Definition load.

"validate"
%

category: 'tests'
method: RwProjectComponentDefinitionsTest
testReadComponentProject

	| rowanProject urlString projectDefinition x projectSetDefinition |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	urlString :=  'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample2_masterV2.ston'.

	projectDefinition := (urlString asRwUrl asSpecification asDefinition)
		projectHome: self _testRowanProjectsSandbox;
		yourself.

"setup"
	projectDefinition repositoryRoot ensureDeleteAll.
	self assert: (x := projectDefinition packageNames isEmpty).

"clone"
	projectSetDefinition := projectDefinition clone.	"does a read as part of the clone"

"validate"
	self assert: (x := projectSetDefinition projectNames asArray sort) = #( 'RowanSample2').
	self assert: (x := projectDefinition packageNames asArray sort) = #( 'RowanSample2-Core')
%

category: 'tests'
method: RwProjectComponentDefinitionsTest
testRowanInstall_3

	"derived from platforms/gemstone/topaz/3.5.0/install_3.tpz"

	"install_3.tpz"
 	| projectSetDefinition gitRepoPath  loadedProjectInfo readTool gitRoot x |
	projectSetDefinition := RwProjectSetDefinition new.
	loadedProjectInfo := Dictionary new.
	gitRepoPath := '$ROWAN_PROJECTS_HOME/Rowan'.
	readTool := Rowan projectTools read.
	{	{
			'file:$ROWAN_PROJECTS_HOME/Rowan/rowan/specs/RowanV2.ston'. 
			'$ROWAN_PROJECTS_HOME'
		}	} 
	do: [:ar |
		"Read project and packages from disk, creating a projectSetDefinition with all 5 projects"
		| projectDefinition theProjectSetDefinition specUrl projectHome |
		specUrl := ar at: 1.
		projectHome := ar at: 2.
		gitRoot := '$ROWAN_PROJECTS_HOME/Rowan'.
		projectDefinition := (RwComponentProjectDefinition newForUrl: specUrl) 
			projectHome: projectHome;
			gitRoot: gitRoot;
			yourself.
		theProjectSetDefinition := readTool 
			readProjectSetForComponentProjectDefinition: projectDefinition 
				withConfigurations: projectDefinition defaultConfigurationNames 
				groupNames: projectDefinition defaultGroupNames.
		self assert: #( 'Load' ) sort = (x := (theProjectSetDefinition projectNamed: projectDefinition name) loadedConfigurationNames asArray sort) ]
%

! Class implementation for 'RwSymbolDictionaryTest'

!		Instance methods for 'RwSymbolDictionaryTest'

category: 'tests'
method: RwSymbolDictionaryTest
testClassAdditionPatch

	"RwGsClassAdditionPatch>>installClassInSystem"

	"add a packaged class to a RwPackageSymbolDictionary"

	| dict class assoc packageName className superclassName testClass expectedPackageSet loadedPackageSet diff |
	className := 'TestSymbolDictClass'.
	superclassName := 'Object'.
	class := self _createClassNamed: className superclassName: superclassName.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName := 'TestSymbolDictPackage'.

	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.

	expectedPackageSet := self
		packageSetDefinition: packageName
		classNamed: className
		super: superclassName.
	loadedPackageSet := self _loadedPackageDefinitionsNamed: {packageName}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'tests'
method: RwSymbolDictionaryTest
testClassAdditionPatchWithCategory

	"RwGsClassAdditionPatch>>installClassInSystem"

	"add a packaged class to a RwPackageSymbolDictionary"

	| dict class assoc packageName className superclassName testClass expectedPackageSet loadedPackageSet diff category |
	className := 'TestSymbolDictClass'.
	superclassName := 'Object'.
	category := '*NotAPackageName'.
	class := self _createClassNamed: className superclassName: superclassName.
	class category: category.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName := 'TestSymbolDictPackage'.

	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.

	expectedPackageSet := self
		packageSetDefinition: packageName
		classNamed: className
		super: superclassName
		category: category.
	loadedPackageSet := self _loadedPackageDefinitionsNamed: {packageName}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'tests'
method: RwSymbolDictionaryTest
testClassDeletionPatch

	"RwGsClassDeletionPatch>>deleteClassFromSystem"

	"add a packaged class to a RwPackageSymbolDictionary, then delete it"

	| dict class assoc packageName className testClass expectedPackageSet loadedPackageSet diff |
	className := 'TestSymbolDictClass'.
	class := self _createClassNamed: className superclassName: 'Object'.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName := 'TestSymbolDictPackage'.

	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.

	dict rowanSymbolDictionaryRegistry deleteClassFromPackage: class.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass isNil.

	expectedPackageSet := self packageSetDefinition: packageName.
	loadedPackageSet := self _loadedPackageDefinitionsNamed: {packageName}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'tests'
method: RwSymbolDictionaryTest
testClassPropertiesPatch

	"RwGsClassPropertiesPatch>>installPropertiesPatchFor:"

	"add a packaged class to a RwPackageSymbolDictionary, then update properties (non-class version/class variable properties)"

	| dict class assoc packageName className testClass newClass expectedPackageSet superclassName loadedPackageSet diff |
	className := 'TestSymbolDictClass'.
	superclassName := 'Object'.
	class := self _createClassNamed: className superclassName: 'Object'.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName := 'TestSymbolDictPackage'.
	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.

	newClass := self _applyBenignPropertiesTo: class.
	dict rowanSymbolDictionaryRegistry updateClassProperties: newClass.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.
	self assert: testClass comment = self _classComment.

	expectedPackageSet := self
		packageSetDefinition: packageName
		classNamed: className
		super: superclassName
		comment: self _classComment.
	loadedPackageSet := self _loadedPackageDefinitionsNamed: {packageName}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'tests'
method: RwSymbolDictionaryTest
testClassVariableChangePatch

	"RwGsClassPropertiesPatch>>installPropertiesPatchFor:"

	"add a packaged class to a RwPackageSymbolDictionary, then update class variable properties"

	| dict class assoc packageName className testClass newClass expectedPackageSet superclassName loadedPackageSet diff x y |
	className := 'TestSymbolDictClass'.
	superclassName := 'Object'.
	class := self _createClassNamed: className superclassName: superclassName.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName := 'TestSymbolDictPackage'.

	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.

	newClass := self _applyClassVariableChangeTo: class.
	dict rowanSymbolDictionaryRegistry updateClassProperties: newClass.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.
	self
		assert:
			(x := self _classVars)
				=
					(y := testClass _classVars keys asArray collect: [ :each | each asString ]).

	expectedPackageSet := self
		packageSetDefinition: packageName
		classNamed: className
		super: superclassName
		classVars: self _classVars.
	loadedPackageSet := self _loadedPackageDefinitionsNamed: {packageName}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'tests'
method: RwSymbolDictionaryTest
testClassVersioningPatch

	"RwGsClassPropertiesPatch>>installPropertiesPatchFor:"

	"add a packaged class to a RwPackageSymbolDictionary, then apply some new version inducing class changes"

	| dict class assoc packageName className testClass newClass expectedPackageSet loadedPackageSet diff superclassName x y |
	className := 'TestSymbolDictClass'.
	superclassName := 'Object'.
	class := self _createClassNamed: className superclassName: superclassName.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName := 'TestSymbolDictPackage'.

	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.

	newClass := self _applyClassNewVersionChangesTo: class.
	dict rowanSymbolDictionaryRegistry addNewClassVersionToAssociation: newClass.
	superclassName := 'Association'.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass ~~ class.
	self assert: testClass == newClass.
	self
		assert:
			(x := self _instVars)
				= (y := testClass instVarNames collect: [ :each | each asString ]).

	expectedPackageSet := self
		packageSetDefinition: packageName
		classNamed: className
		super: superclassName
		instVars: self _instVars.
	loadedPackageSet := self _loadedPackageDefinitionsNamed: {packageName}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'tests'
method: RwSymbolDictionaryTest
testMethodAdditionPatch

	"RwGsMethodAdditionPatch>>installMethod"

	"add a packaged class to a RwPackageSymbolDictionary, then add a new method."

	| dict class assoc packageName compiledMethod className testClass testInstance expectedPackageSet superclassName loadedPackageSet diff methodSource methodProtocol methodSelector |
	className := 'TestSymbolDictClass'.
	superclassName := 'Object'.
	class := self _createClassNamed: className superclassName: superclassName.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName := 'TestSymbolDictPackage'.
	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	testInstance := testClass new.
	self assert: testClass == class.
	self should: [ (testInstance perform: #foo) = 'foo' ] raise: MessageNotUnderstood.

	methodSelector := #'foo'.
	methodSource := 'foo ^ ''foo'''.
	methodProtocol := RwGsSymbolDictionaryRegistry defaultProtocolString.
	compiledMethod := self
		_compileMethodIn: class
		source: methodSource
		dictionaries: Rowan image symbolList.

	dict rowanSymbolDictionaryRegistry
		addNewCompiledMethod: compiledMethod
		for: class
		protocol: methodProtocol
		toPackageNamed: packageName.

	self assert: (testInstance perform: #foo) = 'foo'.
	self
		assert:
			(testClass categoryOfSelector: methodSelector) = methodProtocol asSymbol.

	expectedPackageSet := self
		packageSetDefinition: packageName
		classNamed: className
		super: superclassName
		instanceMethods:
			(self
				methodDefsFromSpec:
					{{methodSelector.
					methodProtocol.
					methodSource}})
		classMethods: Dictionary new.
	loadedPackageSet := self _loadedPackageDefinitionsNamed: {packageName}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'tests'
method: RwSymbolDictionaryTest
testMethodDeletionPatch

	"RwGsMethodDeletionPatch>>deleteMethodNewClasses:andExistingClasses:"

	"add a packaged class to a RwPackageSymbolDictionary, add a new method, then delete it."

	| dict class assoc packageName compiledMethod className testClass testInstance expectedPackageSet superclassName loadedPackageSet diff |
	className := 'TestSymbolDictClass'.
	superclassName := 'Object'.
	class := self _createClassNamed: className superclassName: superclassName.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName := 'TestSymbolDictPackage'.
	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.
	testInstance := testClass new.
	self should: [ (testInstance  perform: #foo) = 'foo' ] raise: MessageNotUnderstood.

	compiledMethod := self
		_compileMethodIn: class
		source: 'foo ^ ''foo'''
		dictionaries: Rowan image symbolList.

	dict rowanSymbolDictionaryRegistry
		addNewCompiledMethod: compiledMethod
		for: class
		protocol: 'accessing'
		toPackageNamed: packageName.

	self assert: (testInstance perform: #foo) = 'foo'.

	dict rowanSymbolDictionaryRegistry
		deleteCompiledMethod: compiledMethod
		from: class.

	self should: [ (testInstance  perform: #foo) = 'foo' ] raise: MessageNotUnderstood.

	expectedPackageSet := self
		packageSetDefinition: packageName
		classNamed: className
		super: superclassName
		instanceMethods: Dictionary new
		classMethods: Dictionary new.
	loadedPackageSet := self _loadedPackageDefinitionsNamed: {packageName}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'tests'
method: RwSymbolDictionaryTest
testMethodExtensionPatchInGlobalsExtension

	"extend a class that is NOT owned by user, i.e., the class is in Globals and the user is DataCurator"

	
%

category: 'tests'
method: RwSymbolDictionaryTest
testMethodExtensionPatchInSymbolDictionaryExtension

	"RwGsClassExtensionPatch>>installClassExtensionInSystem"

	"add a packaged class to a RwPackageSymbolDictionary, then add method to class using different package."

	| dict class assoc packageName1 packageName2 compiledMethod className testClass testInstance expectedPackageSet expectedPackage1 expectedPackage2 superclassName loadedPackageSet diff methodSource methodProtocol methodSelector |
	className := 'TestSymbolDictClass'.
	superclassName := 'Object'.
	class := self _createClassNamed: className superclassName: superclassName.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName1 := 'TestSymbolDictPackage'.
	packageName2 := 'TestSymbolDictExtensionPackage'.
	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName1.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	testInstance := testClass new.
	self assert: testClass == class.
	self should: [ (testInstance perform: #foo) = 'foo' ] raise: MessageNotUnderstood.

	expectedPackage1 := self
		packageDefinition: packageName1
		classNamed: className
		super: superclassName.

	methodSelector := #'foo'.
	methodSource := 'foo ^ ''foo'''.
	methodProtocol := 'accessing'.
	compiledMethod := self
		_compileMethodIn: class
		source: methodSource
		dictionaries: Rowan image symbolList.

	dict rowanSymbolDictionaryRegistry
		addExtensionCompiledMethod: compiledMethod
		for: class
		protocol: methodProtocol
		toPackageNamed: packageName2.

	self assert: (testInstance perform: #foo) = 'foo'.
	self
		assert:
			(testClass categoryOfSelector: methodSelector) = methodProtocol asSymbol.

	expectedPackage2 := self
		packageDefinition: packageName2
		extendClassNamed: className
		instanceMethods:
			(self
				methodDefsFromSpec:
					{{methodSelector.
					methodProtocol.
					methodSource}})
		classMethods: Dictionary new.

	expectedPackageSet := (RwPackageSetDefinition new
		addPackage: expectedPackage1;
		addPackage: expectedPackage2;
		yourself) asDefinition.
	loadedPackageSet := self _loadedPackageDefinitionsNamed:
			{packageName1.
			packageName2}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'tests'
method: RwSymbolDictionaryTest
testMethodExtensionPatchInUserExtension

	"extend a class that is owned by user, but not in the same symbol dictionary as package"

	
%

category: 'tests'
method: RwSymbolDictionaryTest
testMethodPropertiesPatch

	"RwGsClassPropertiesPatch>>installPropertiesPatchFor:"

	"add a packaged class to a RwPackageSymbolDictionary, add a new method, then change it's properties."

	| dict class assoc packageName compiledMethod className testClass testInstance x superclassName expectedPackageSet methodSource methodProtocol methodSelector loadedPackageSet diff |
	className := 'TestSymbolDictClass'.
	superclassName := 'Object'.
	class := self _createClassNamed: className superclassName: superclassName.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName := 'TestSymbolDictPackage'.
	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.
	testInstance := testClass new.
	self should: [ (testInstance perform: #foo) = 'foo' ] raise: MessageNotUnderstood.

	methodSelector := #'foo'.
	methodSource := 'foo ^ ''foo'''.
	methodProtocol := 'accessing'.
	compiledMethod := self
		_compileMethodIn: class
		source: methodSource
		dictionaries: Rowan image symbolList.

	dict rowanSymbolDictionaryRegistry
		addNewCompiledMethod: compiledMethod
		for: class
		protocol: methodProtocol
		toPackageNamed: packageName.

	self assert: (testInstance perform: #foo) = 'foo'.
	self
		assert: (x := testClass categoryOfSelector: #'foo') = methodProtocol asSymbol.

	methodProtocol := 'the accessing'.
	dict rowanSymbolDictionaryRegistry
		moveCompiledMethod: compiledMethod
		toProtocol: methodProtocol.

	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testClass categoryOfSelector: #'foo') = methodProtocol asSymbol.

	expectedPackageSet := self
		packageSetDefinition: packageName
		classNamed: className
		super: superclassName
		instanceMethods:
			(self
				methodDefsFromSpec:
					{{methodSelector.
					methodProtocol.
					methodSource}})
		classMethods: Dictionary new.
	loadedPackageSet := self _loadedPackageDefinitionsNamed: {packageName}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'tests'
method: RwSymbolDictionaryTest
testMethodSourcePatch

	"RwGsMethodSourcePatch>>installSourcePatch"

	"add a packaged class to a RwPackageSymbolDictionary, add a new method, then change it's source."

	| dict class assoc packageName compiledMethod className testClass testInstance x newCompiledMethod superclassName methodSource methodProtocol methodSelector expectedPackageSet loadedPackageSet diff |
	className := 'TestSymbolDictClass'.
	superclassName := 'Object'.
	class := self _createClassNamed: className superclassName: superclassName.
	dict := self _symbolDictionary.
	assoc := SymbolAssociation newWithKey: class name asSymbol value: nil.
	packageName := 'TestSymbolDictPackage'.
	dict rowanSymbolDictionaryRegistry
		addClassAssociation: assoc
		forClass: class
		toPackageNamed: packageName.

	testClass := Rowan image resolveClassNamed: className asSymbol.
	self assert: testClass == class.
	testInstance := testClass new.
	self should: [ (testInstance perform: #foo) = 'foo' ] raise: MessageNotUnderstood.

	methodSelector := #'foo'.
	methodSource := 'foo ^ ''foo'''.
	methodProtocol := 'accessing'.
	compiledMethod := self
		_compileMethodIn: class
		source: methodSource
		dictionaries: Rowan image symbolList.

	dict rowanSymbolDictionaryRegistry
		addNewCompiledMethod: compiledMethod
		for: class
		protocol: methodProtocol
		toPackageNamed: packageName.

	self assert: (testInstance perform: #foo) = 'foo'.
	self
		assert: (x := testClass categoryOfSelector: #'foo') = methodProtocol asSymbol.

	methodSource := 'foo ^ ''bar'''.
	newCompiledMethod := self
		_compileMethodIn: class
		source: methodSource
		dictionaries: Rowan image symbolList.

	dict rowanSymbolDictionaryRegistry addRecompiledMethod: newCompiledMethod.

	self assert: (testInstance perform: #foo) = 'bar'.
	self
		assert: (x := testClass categoryOfSelector: #'foo') = methodProtocol asSymbol.

	methodSource := 'foo ^ ''who'''.
	methodProtocol := 'the accessing'.
	newCompiledMethod := self
		_compileMethodIn: class
		source: methodSource
		dictionaries: Rowan image symbolList.

	dict rowanSymbolDictionaryRegistry
		addNewCompiledMethod: newCompiledMethod
		for: class
		protocol: methodProtocol
		toPackageNamed: packageName.	"account for using wrong method to update a method --- perhaps the selector is incorrect?"

	self assert: (testInstance perform: #foo) = 'who'.
	self
		assert: (x := testClass categoryOfSelector: #'foo') = methodProtocol asSymbol.

	expectedPackageSet := self
		packageSetDefinition: packageName
		classNamed: className
		super: superclassName
		instanceMethods:
			(self
				methodDefsFromSpec:
					{{methodSelector.
					methodProtocol.
					methodSource}})
		classMethods: Dictionary new.
	loadedPackageSet := self _loadedPackageDefinitionsNamed: {packageName}.
	diff := expectedPackageSet compareAgainstBase: loadedPackageSet.
	self assert: diff isEmpty
%

category: 'private'
method: RwSymbolDictionaryTest
_applyBenignPropertiesTo: existingClass

	"benign properties are properties that do not cause a new class version or modify class variables"

	| newClass |
	newClass := existingClass superclass
		subclass: existingClass name
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: nil
		newVersionOf: existingClass
		description: self _classComment
		options: #().
	self assert: newClass == existingClass.	"not supposed to create a new class version"
	^ newClass
%

category: 'private'
method: RwSymbolDictionaryTest
_applyClassNewVersionChangesTo: existingClass

	"benign properties are properties that do not cause a new class version or modify class variables"

	| newClass superclass |
	superclass := System myUserProfile objectNamed: 'Association'.
	newClass := superclass
		subclass: existingClass name
		instVarNames: self _instVars
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: nil
		newVersionOf: existingClass
		description: ''
		options: #().
	self assert: newClass ~~ existingClass.	"supposed to create a new class version"
	^ newClass
%

category: 'private'
method: RwSymbolDictionaryTest
_applyClassVariableChangeTo: existingClass

	"benign properties are properties that do not cause a new class version or modify class variables"

	| newClass |
	newClass := existingClass superclass
		subclass: existingClass name
		instVarNames: #()
		classVars: self _classVars
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: nil
		newVersionOf: existingClass
		description: ''
		options: #().
	self assert: newClass == existingClass.	"not supposed to create a new class version"
	^ newClass
%

category: 'private'
method: RwSymbolDictionaryTest
_classComment

	^ 'a comment'
%

category: 'private'
method: RwSymbolDictionaryTest
_classVars

	^ #('ClassVar1')
%

category: 'private'
method: RwSymbolDictionaryTest
_compileMethodIn: behavior source: sourceString dictionaries: symbolList

	^ behavior
		compileMethod: sourceString
		dictionaries: symbolList
		category: nil
		intoMethodDict: false
		intoCategories: nil
		intoPragmas: nil
		environmentId: 0
%

category: 'private'
method: RwSymbolDictionaryTest
_createClassNamed: className superclassName: superclassName

	| superclass |
	superclass := System myUserProfile objectNamed: superclassName.
	^ superclass
		subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: nil
		newVersionOf: nil
		description: ''
		options: #()
%

category: 'private'
method: RwSymbolDictionaryTest
_instVars

	^ #('ivar1')
%

! Class implementation for 'RwToolTest'

!		Instance methods for 'RwToolTest'

category: 'private'
method: RwToolTest
gsInteractionInformFailureHandler

	^ GsInteractionHandler new
		defaultBlock: [ :ignored | self assert: false description: 'unexpected interaction' ];
		informBlock: [ :interaction | self assert: false description: 'unexpected inform' ];
		yourself
%

category: 'private'
method: RwToolTest
handleInformAsFailureDuring: aBlock

	aBlock
		on: GsInteractionRequest
		do: [ :ex | 
			ex
				response:
					(ex interaction interactWith: self gsInteractionInformFailureHandler) ]
%

! Class implementation for 'RwAbstractComponentDefinitionTest'

!		Instance methods for 'RwAbstractComponentDefinitionTest'

category: 'running'
method: RwAbstractComponentDefinitionTest
tearDown

	repositoryRoot ifNotNil: [ repositoryRoot ensureDelete ].
	super tearDown
%

category: 'private'
method: RwAbstractComponentDefinitionTest
_createRepositoryRoot

	self subclassResponsibility: #_createRepositoryRoot
%

category: 'private'
method: RwAbstractComponentDefinitionTest
_repositoryRoot

	^ repositoryRoot
%

! Class implementation for 'RwComponentDefinitionTest'

!		Instance methods for 'RwComponentDefinitionTest'

category: 'tests'
method: RwComponentDefinitionTest
testBasicComponentDefinitionCreation

	| componentDef  componentName1 subComponentName1 subComponentName2 packageName0 packageName1 packageName2 
		className0 className1 className2 |
	componentName1 := 'Example'.
	subComponentName1 := 'Core'.
	subComponentName2 := 'Tests'.
	packageName0 := 'Example-Common'.
	packageName1 := 'Example-Core'.
	packageName2 := 'Example-Tests'.
	className0 := 'ExampleCoreClass'.
	className1 := 'ExampleApplicationClass'.
	className2 := 'ExampleTests'.

	componentDef := RwComponentDefinition newNamed: componentName1.
	(componentDef addPackageNamed: packageName0)
			addClassDefinition: 
				((RwClassDefinition 
					newForClassNamed: className0
					super: 'Object'
					category: packageName0)
						addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'bar ^ 1' protocol: 'accessing');
						addClassMethodDefinition: (RwMethodDefinition newForSource: 'bar ^ 1' protocol: 'accessing');
						yourself);
			yourself.
	((componentDef addSubComponentNamed: subComponentName1)
		addPackageNamed: packageName1)
			addClassDefinition: 
				((RwClassDefinition 
					newForClassNamed: className1
					super: className0
					category: packageName1)
						addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'foo ^ 1' protocol: 'accessing');
						addClassMethodDefinition: (RwMethodDefinition newForSource: 'foo ^ 1' protocol: 'accessing');
						yourself);
			addClassExtensionDefinition: 
				((RwClassExtensionDefinition 
					newForClassNamed: className0)
						addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionMethod ^ 1' protocol: '*', packageName1 asLowercase);
						yourself);
			yourself.
	((componentDef addSubComponentNamed: subComponentName2)
		addPackageNamed: packageName2)
			addClassDefinition: 
				((RwClassDefinition 
					newForClassNamed: className2
					super: 'TestCase'
					category: packageName2)
						addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'test' protocol: 'testing');
						yourself);
			addClassExtensionDefinition: 
				((RwClassExtensionDefinition 
					newForClassNamed: className0)
						addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'testExtensionMethod ^ 1' protocol: '*', packageName2 asLowercase);
						yourself);
			yourself.
%

category: 'private'
method: RwComponentDefinitionTest
_createRepositoryRoot

	repositoryRoot := FileSystem memory * 'componentDefinitionTestRoot'
%

! Class implementation for 'RwProjectReferenceDefinitionTest'

!		Instance methods for 'RwProjectReferenceDefinitionTest'

category: 'tests'
method: RwProjectReferenceDefinitionTest
testSpecificationConversion

	| rowanProject projectHome specUrlString projectSpec_1 projectSpec_2 projectReferenceDefinition memory 
		x y |	
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := rowanProject repositoryRootPath , '/test/testRepositories/'.

"identify spec to be used for reading project"
	specUrlString :=  'file:' , projectHome, '/Issue122/filetree/rowan/specs/Issue122.ston'.

	projectSpec_1 := specUrlString asRwUrl asSpecification.

	projectReferenceDefinition := projectSpec_1 asProjectReferenceDefinition.

	projectSpec_2 := projectReferenceDefinition asSpecification.

	memory := FileSystem currentMemoryFileSystem.
	(memory / 'projectSpec_1') ensureDeleteAll.
	(memory / 'projectSpec_2') ensureDeleteAll.

	(memory / 'projectSpec_1') ensureCreateDirectory.
	(memory / 'projectSpec_2') ensureCreateDirectory.
	projectSpec_1 exportToUrl: 'memory:/projectSpec_1'.
	projectSpec_2 exportToUrl: 'memory:/projectSpec_2'.

	(x := (memory / 'projectSpec_1' / 'Issue122.ston') contents).
	(y := (memory / 'projectSpec_2' / 'Issue122.ston') contents).
	x = y 
		ifFalse: [
			1 to: (x size min: y size) do: [:i |
				| a b |
				(a := x at: i) = (b := y at: i) ifFalse: [ self assert: false description: 'spec mismatch' ] ]].
	self assert: x = y.
%

! Class implementation for 'RwBrowserToolTest'

!		Instance methods for 'RwBrowserToolTest'

category: 'private'
method: RwBrowserToolTest
_assert: foundBlock forClassExtensionsIn: className

	"validate loaded class extension registry structure"

	self
		_assert: foundBlock
		forClassExtensionsIn: className
		ifAbsent: [ 
			self
				assert: false
				description:
					'expected class extension definitions for class ' , className printString
						, ' not found.' ]
%

category: 'private'
method: RwBrowserToolTest
_assert: foundBlock forClassExtensionsIn: className ifAbsent: absentBlock

	"validate loaded class extension registry structure"

	| projectTools |
	projectTools := Rowan projectTools.
	projectTools edit
		definitionsForClassExtensionNamed: className
		ifFound: foundBlock
		ifAbsent: absentBlock
%

category: 'private'
method: RwBrowserToolTest
_assert: foundBlock forClassName: className ifAbsent: absentBlock

	"validate loaded class registry structure"

	| projectTools |
	projectTools := Rowan projectTools.
	projectTools edit
		definitionsForClassNamed: className
		ifFound: foundBlock
		ifAbsent: absentBlock
%

category: 'private'
method: RwBrowserToolTest
_assert: foundBlock forClassNamed: className

	"validate loaded class registry structure"

	self
		_assert: foundBlock
		forClassName: className
		ifAbsent: [ 
			self
				assert: false
				description:
					'expected class definitions for class ' , className printString , ' not found.' ]
%

category: 'private'
method: RwBrowserToolTest
_assertForClassExtensionInClassWithHistory: classHistory ifPresent: presentBlock ifAbsent: absentBlock

	"validate loaded class extension registry structure"

	| found |
	found := IdentitySet new.
	Rowan image symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry classExtensionRegistry at: classHistory ifAbsent: [  ])
						ifNotNil: [ :loadedClassExtensionSet | found addAll: loadedClassExtensionSet ] ] ].
	found isEmpty
		ifFalse: [ ^ presentBlock cull: found ].
	^ absentBlock value
%

category: 'private'
method: RwBrowserToolTest
_assertNoClassExtensionsIn: className

	"validate loaded class extension registry structure"

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			self
				assert: false
				description:
					'No class extensions expected for class ' , className printString ]
		forClassExtensionsIn: className
		ifAbsent: [  ]
%

category: 'private'
method: RwBrowserToolTest
_basicClassDefinition: className superclass: superclass gs_options: gs_options type: type

	| def |
	def := RwClassDefinition
		newForClassNamed: className
		super: superclass
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: ''
		comment: ''
		pools: #()
		type: type.
	gs_options ifNil: [ ^ def ].
	(gs_options _isArray and: [ gs_options isEmpty not ])
		ifTrue: [ 
			def properties
				at: 'gs_options'
				put:
					(gs_options collect: [ :each | each asString ]) asSortedCollection asArray ].
	^ def
%

category: 'private'
method: RwBrowserToolTest
_basicClassDefinition: className superclass: superclass type: type

	^ self
		_basicClassDefinition: className
		superclass: superclass
		gs_options: nil
		type: type
%

category: 'private'
method: RwBrowserToolTest
_globalExtensionsProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment

	| projectDefinition |
	projectDefinition := RwProjectDefinition
		newForGitBasedProjectNamed: projectName.
	projectDefinition
		comment: comment;
		packageNames: packageNames;
		defaultSymbolDictName: defaultSymbolDictName;
		yourself.

	packageNames
		do: [ :packageName | 
			projectDefinition
				setUseSessionMethodsForExtensions: true
				forPackageNamed: packageName ].

	^ projectDefinition
%

category: 'private'
method: RwBrowserToolTest
_issue481_loadProjectDefinition: projectName  packageName1: packageName1 packageName2: packageName2 symDictName: symDictName

	self
		_loadProjectDefinition: projectName
		packageNames: { packageName1 . packageName2}
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.
%

category: 'private'
method: RwBrowserToolTest
_issue481_projectDefinition: projectName  packageName1: packageName1 packageName2: packageName2 className1: className1 className2: className2 symDictName: symDictName

	| theClass1 theClass2 symDict instanceMethod1 classMethod1 symbolList 
		instanceMethod2 classMethod2 |
	symbolList := Rowan image symbolList.

	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

	symDict := Rowan globalNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass1 := Object subclass: className1
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().
	theClass1 category: packageName1.

	instanceMethod1 := theClass1
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	classMethod1 := theClass1 class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	Rowan packageTools adopt 
		adoptClassNamed: className1
		intoPackageNamed: packageName1.

	self assert: theClass1 rowanPackageName = packageName1.
	self assert: instanceMethod1 rowanPackageName = packageName1.
	self assert: classMethod1 rowanPackageName = packageName1.

	theClass2 := Object subclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().
	theClass2 category: packageName2.

	instanceMethod2 := theClass2
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: '*', packageName2 asLowercase
		environmentId: 0.

	classMethod2 := theClass2 class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: '*', packageName2 asLowercase
		environmentId: 0.

	Rowan packageTools adopt 
		adoptClassExtensionNamed: className2  
		instanceSelectors: #(foo) 
		classSelectors: #(bar)
		intoPackageNamed: packageName2.

	self assert: theClass2 rowanPackageName = Rowan unpackagedName.
	self assert: instanceMethod2 rowanPackageName = packageName2.
	self assert: classMethod2 rowanPackageName = packageName2.

	^(Rowan image loadedProjectNamed: projectName) asDefinition
%

category: 'private'
method: RwBrowserToolTest
_loadExtendedProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment className: className inPackageName: packageName1 extensionPackageNames: extensionPackageNames

	| projectDefinition classDefinition classExtensionDefinition projectTools |
	projectTools := Rowan projectTools.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictName
		comment: 'This is a simple project used to test class extension edit API'.

	classDefinition := self _standardClassDefinition: className.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName1
		inProject: projectDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'ivar1:'
						protocol: 'accessing'
						source: 'ivar1: anInteger ivar1 := anInteger');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'cadd:'
						protocol: 'addition'
						source: 'cadd: anInteger ^civar1 + anInteger');
		yourself.

	projectTools edit
		addClassExtension: classExtensionDefinition
		inPackageNamed: (extensionPackageNames at: 1)
		inProject: projectDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'add:'
						protocol: 'addition'
						source: 'add: anInteger ^ivar1 + anInteger');
		yourself.

	projectTools edit
		addClassExtension: classExtensionDefinition
		inPackageNamed: (extensionPackageNames at: 2)
		inProject: projectDefinition.


	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].
%

category: 'private'
method: RwBrowserToolTest
_loadFullMultiProjectDefinition: projectNames packageNames: packageNames defaultSymbolDictName: defaultSymbolDictNames comment: comments className: classNames inPackageName: classPackageNames

	| projectTools projectSetDefinition |
	projectTools := Rowan projectTools.

	projectSetDefinition := RwProjectSetDefinition new.

	1 to: projectNames size do: [ :index | 
		| projectDefinition classDefinition |
		(Rowan image loadedProjectNamed: (projectNames at: index) ifAbsent: [  ])
			ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

		projectDefinition := self
			_standardProjectDefinition: (projectNames at: index)
			packageNames: (packageNames at: index)
			defaultSymbolDictName: (defaultSymbolDictNames at: index)
			comment:
				'This is a simple project used to work out a "classic" class browser-style API'.

		classDefinition := self _standardClassDefinition: (classNames at: index).
		classDefinition category: (classPackageNames at: index).

		projectTools edit
			addClass: classDefinition
			inPackageNamed: (classPackageNames at: index)
			inProject: projectDefinition.

		projectSetDefinition addProject: projectDefinition.

		index = 1
			ifTrue: [ 
				{(self
					_basicClassDefinition: 'SimpleNormal1'
					superclass: 'Object'
					type: 'normal').
				(self
					_basicClassDefinition: 'SimpleVariable1'
					superclass: 'Object'
					type: 'variable').
				(self
					_basicClassDefinition: 'SimpleBag1'
					superclass: 'Bag'
					gs_options: #('disallowGciStore')
					type: 'normal').
				(self
					_basicClassDefinition: 'SimpleCustomByteArray1'
					superclass: 'Object'
					type: 'byteSubclass').
				(self
					_basicClassDefinition: 'SimpleByteArray1'
					superclass: 'ByteArray'
					type: 'byteSubclass').
				(self _basicClassDefinition: 'SimpleProto1' superclass: 'nil' type: 'normal')}
					do: [ :cd | 
						cd category: (classPackageNames at: index).
						projectTools edit
							addClass: cd
							inPackageNamed: (classPackageNames at: index)
							inProject: projectDefinition ] ] ].

	[ projectTools load loadProjectSetDefinition: projectSetDefinition  ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].
%

category: 'private'
method: RwBrowserToolTest
_loadGlobalExtensionsProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment

	| projectDefinition projectTools |
	projectTools := Rowan projectTools.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	projectDefinition := self
		_globalExtensionsProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictName
		comment:
			'This is a simple project used to work out a "classic" class browser-style API'.


	projectTools load loadProjectDefinition: projectDefinition
%

category: 'private'
method: RwBrowserToolTest
_loadMultiProjectDefinition: projectNames packageNames: packageNames defaultSymbolDictName: defaultSymbolDictNames comment: comments className: classNames inPackageName: classPackageNames

	| projectTools projectSetDefinition |
	projectTools := Rowan projectTools.

	projectSetDefinition := RwProjectSetDefinition new.

	1 to: projectNames size do: [ :index | 
		| projectDefinition classDefinition |
		(Rowan image loadedProjectNamed: (projectNames at: index) ifAbsent: [  ])
			ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

		projectDefinition := self
			_standardProjectDefinition: (projectNames at: index)
			packageNames: (packageNames at: index)
			defaultSymbolDictName: (defaultSymbolDictNames at: index)
			comment:
				'This is a simple project used to work out a "classic" class browser-style API'.

		classDefinition := self _standardClassDefinition: (classNames at: index).

		projectTools edit
			addClass: classDefinition
			inPackageNamed: (classPackageNames at: index)
			inProject: projectDefinition.

		projectSetDefinition addProject: projectDefinition ].

	[ projectTools load loadProjectSetDefinition: projectSetDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].
%

category: 'private'
method: RwBrowserToolTest
_loadPackageMappedProjectDefinition: projectName packageNameMap: packageNameMap defaultSymbolDictName: defaultSymbolDictName
	| projectDefinition projectTools |
	projectTools := Rowan projectTools.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	projectDefinition := self
		_standardProjectDefinition: projectName 
		packageNameMap: packageNameMap 
		defaultSymbolDictName: defaultSymbolDictName.

	projectTools load loadProjectDefinition: projectDefinition
%

category: 'private'
method: RwBrowserToolTest
_loadProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment

	| projectDefinition projectTools |
	projectTools := Rowan projectTools.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictName
		comment:
			'This is a simple project used to work out a "classic" class browser-style API'.

	projectTools load loadProjectDefinition: projectDefinition.

	^ projectDefinition
%

category: 'private'
method: RwBrowserToolTest
_loadSessionMethodExtensionProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment

	| projectDefinition projectTools |
	projectTools := Rowan projectTools.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictName
		defaultUseSessionMethodsForExtensions: true
		comment:
			'This is a simple project used to work out a "classic" class browser-style API'.

	projectTools load loadProjectDefinition: projectDefinition
%

category: 'private'
method: RwBrowserToolTest
_loadSimpleProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment className: className inPackageName: packageName

	| projectDefinition classDefinition projectTools |
	projectTools := Rowan projectTools.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictName
		comment:
			'This is a simple project used to work out a "classic" class browser-style API'.

	classDefinition := self _simpleClassDefinition: className.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

	projectTools load loadProjectDefinition: projectDefinition
%

category: 'private'
method: RwBrowserToolTest
_loadStandardProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment className: className inPackageName: packageName

	| projectDefinition classDefinition projectTools |
	projectTools := Rowan projectTools.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictName
		comment:
			'This is a simple project used to work out a "classic" class browser-style API'.

	classDefinition := self _standardClassDefinition: className.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].
%

category: 'private'
method: RwBrowserToolTest
_simpleClassDefinition: className

	^ RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #('civar1')
		classvars: #('Cvar1')
		category: 'Simple Things'
		comment: 'I am a SimpleEdit class'
		pools: #()
		type: 'normal'
%

category: 'private'
method: RwBrowserToolTest
_standardClassDefinition: className

	| classDefinition |
	classDefinition := self _simpleClassDefinition: className.

	classDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize civar1 := 1. Cvar1 := 2.');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'civar1'
						protocol: 'accessing'
						source: 'civar1 ^civar1');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'cvar1'
						protocol: 'accessing'
						source: 'cvar1 ^Cvar1');
		yourself.

	^ classDefinition
%

category: 'private'
method: RwBrowserToolTest
_standardProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment

	^ self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictName
		defaultUseSessionMethodsForExtensions: false
		comment: comment
%

! Class implementation for 'RwAdoptToolApiTest'

!		Instance methods for 'RwAdoptToolApiTest'

category: 'tests'
method: RwAdoptToolApiTest
testAdoptClass
	| projectName packageNames className packageName theClass symDict symDictName instanceMethod classMethod symbolList |
	projectName := 'AdoptProject'.
	packageName := 'Adopt-Core'.
	packageNames := {packageName}.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan image symbolDictNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().

	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = Rowan unpackagedName.
	self assert: classMethod rowanProjectName = Rowan unpackagedName.

	Rowan packageTools adopt 
		adoptClassNamed: className 
		intoPackageNamed: packageName.

	self assert: theClass rowanProjectName = projectName.
	self assert: instanceMethod rowanProjectName = projectName.
	self assert: classMethod rowanProjectName = projectName.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptClassWithExistingExtensionMethods_1
	| projectName packageNames className packageName1 packageName2 theClass symDict symDictName fooMethod barMethod symbolList |
	projectName := 'AdoptProject'.
	packageName1 := 'Adopt-Core1'.
	packageName2 := 'Adopt-Core2'.
	packageNames := {packageName1. packageName2}.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().

	fooMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	barMethod := theClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: fooMethod rowanPackageName = Rowan unpackagedName.
	self assert: barMethod rowanPackageName = packageName2.

	Rowan packageTools adopt 
		adoptClassNamed: className 
		intoPackageNamed: packageName1.

	self assert: theClass rowanProjectName = projectName.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptMethod
	| projectName packageNames className packageName theClass symDict symDictName instanceMethod classMethod symbolList |
	projectName := 'AdoptProject'.
	packageName := 'Adopt-Core'.
	packageNames := {packageName}.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().

	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = Rowan unpackagedName.
	self assert: classMethod rowanProjectName = Rowan unpackagedName.

	Rowan packageTools adopt 
		adoptMethod: #foo 
			protocol: '*', packageName 
			inClassNamed: className  
			isMeta: false 
			intoPackageNamed: packageName;
		adoptMethod: #bar 
			protocol: '*', packageName 
			inClassNamed: className  
			isMeta: true 
			intoPackageNamed: packageName;
		yourself.

	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = projectName.
	self assert: classMethod rowanProjectName = projectName.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptMethod_issue389_1

	"https://github.com/GemTalk/Rowan/issues/389"

	"reproduce original bug using adoptMethod:protocol:inClassNamed:isMeta:intoPackageNamed:"

	| projectName packageNames className packageName1 theClass symDict symDictName instanceMethod classMethod audit |
	projectName := 'AdoptProject'.
	packageName1 := 'Adopt-Core'.
	packageNames := {packageName1 }.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use Rowan api to create class and method"
	theClass := Object
		rwSubclass:className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	instanceMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: 'accessing'.
	classMethod := theClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'.

"validate"
	self assert: theClass rowanPackageName = packageName1.
	self assert: instanceMethod rowanPackageName = packageName1.
	self assert: classMethod rowanPackageName = packageName1.

"audit --> category not correct according to Monticello conventions"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.


"change method using non-Rowan api"
	instanceMethod := theClass
		compileMethod: 'foo ^"comment" ''foo'''
		dictionaries: Rowan image symbolList
		category: 'accessing'
		environmentId: 0.

"confirm conruption"
	self assert: instanceMethod rowanPackageName =  Rowan unpackagedName.

"repair corruption using adopt"
	Rowan packageTools adopt
		adoptMethod: #foo
		protocol: 'accessing'
		inClassNamed: className
		isMeta: false
		intoPackageNamed:  packageName1.

"validate"
	self assert: theClass rowanPackageName = packageName1.
	self assert: instanceMethod rowanPackageName = packageName1.
	self assert: classMethod rowanPackageName = packageName1.

"audit --> category not correct according to Monticello conventions"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty. " with bug: 'AdoptedClass #*adopt-core'->'Missing instance method extension category '"
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptMethod_issue389_2

	"https://github.com/GemTalk/Rowan/issues/389"

	"reproduce original bug using adoptMethod:inClassNamed:isMeta:intoPackageNamed:"

	| projectName packageNames className packageName1 theClass symDict symDictName instanceMethod classMethod audit |
	projectName := 'AdoptProject'.
	packageName1 := 'Adopt-Core'.
	packageNames := {packageName1 }.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use Rowan api to create class and method"
	theClass := Object
		rwSubclass:className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	instanceMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: 'accessing'.
	classMethod := theClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'.

"validate"
	self assert: theClass rowanPackageName = packageName1.
	self assert: instanceMethod rowanPackageName = packageName1.
	self assert: classMethod rowanPackageName = packageName1.

"audit --> category not correct according to Monticello conventions"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.


"change method using non-Rowan api"
	instanceMethod := theClass
		compileMethod: 'foo ^"comment" ''foo'''
		dictionaries: Rowan image symbolList
		category: 'accessing'
		environmentId: 0.

"confirm conruption"
	self assert: instanceMethod rowanPackageName =  Rowan unpackagedName.

"repair corruption using adopt"
	Rowan packageTools adopt
		adoptMethod: #foo
		inClassNamed: className
		isMeta: false
		intoPackageNamed:  packageName1.

"validate"
	self assert: theClass rowanPackageName = packageName1.
	self assert: instanceMethod rowanPackageName = packageName1.
	self assert: classMethod rowanPackageName = packageName1.

"audit --> category not correct according to Monticello conventions"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty. " with bug: 'AdoptedClass #*adopt-core'->'Missing instance method extension category '"
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptMethod_issue389_3

	"https://github.com/GemTalk/Rowan/issues/389"

	"use adoptMethod:protocol:inClassNamed:isMeta:intoPackageNamed: where protocol is using Monticello convention"

	| projectName packageNames className packageName1 theClass symDict symDictName instanceMethod classMethod audit expectedFailure |
	projectName := 'AdoptProject'.
	packageName1 := 'Adopt-Core'.
	packageNames := {packageName1 }.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use Rowan api to create class and method"
	theClass := Object
		rwSubclass:className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	instanceMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: 'accessing'.
	classMethod := theClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'.

"validate"
	self assert: theClass rowanPackageName = packageName1.
	self assert: instanceMethod rowanPackageName = packageName1.
	self assert: classMethod rowanPackageName = packageName1.

"audit --> category not correct according to Monticello conventions"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.


"change method using non-Rowan api"
	instanceMethod := theClass
		compileMethod: 'foo ^"comment" ''foo'''
		dictionaries: Rowan image symbolList
		category: 'accessing'
		environmentId: 0.

"confirm conruption"
	self assert: instanceMethod rowanPackageName =  Rowan unpackagedName.

"repair corruption using adopt"
	Rowan packageTools adopt
		adoptMethod: #foo
		protocol: '*', packageName1 asLowercase "will cause audit to fail"
		inClassNamed: className
		isMeta: false
		intoPackageNamed:  packageName1.

"validate"
	self assert: theClass rowanPackageName = packageName1.
	self assert: instanceMethod rowanPackageName = packageName1.
	self assert: classMethod rowanPackageName = packageName1.

"audit --> category not correct according to Monticello conventions"
	self deny: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty. "expect: 'AdoptedClass #*adopt-core'->'Extension category name can not be same as class package'"

	self assert: audit size = 1.
	expectedFailure := ((audit at: packageName1) at: className).
	self assert: expectedFailure size = 1.
	self assert: expectedFailure first owner name =  'AdoptedClass'.
	self assert: expectedFailure first owner classCategory = 'Adopt-Core'.
	self assert: (expectedFailure first message matchPattern: { 'Extension category name' . $* . 'must not match class package name.'})
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptMethod_issue389_A

	"https://github.com/GemTalk/Rowan/issues/389"

	"adopt methods into a different package than the packaged class; 
		don't use Monticello convention.
	 methods should be extension methods."

	| projectName packageNames className packageName1 packageName2 theClass symDict symDictName instanceMethod classMethod symbolList audit |
	projectName := 'AdoptProject'.
	packageName1 := 'Adopt-Core'.
	packageName2 := 'Adopt-Extension'.
	packageNames := {packageName1. packageName2 }.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().

	self assert: theClass rowanProjectName = Rowan unpackagedName.

	Rowan packageTools adopt 
		adoptClassNamed: className  
			intoPackageNamed: packageName1.

	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	self assert: instanceMethod rowanProjectName = Rowan unpackagedName.
	self assert: classMethod rowanProjectName = Rowan unpackagedName.

	Rowan packageTools adopt 
		adoptMethod: #foo 
			inClassNamed: className  
			isMeta: false 
			intoPackageNamed: packageName2;
		adoptMethod: #bar 
			inClassNamed: className  
			isMeta: true 
			intoPackageNamed: packageName2;
		yourself.

"validate"
	self assert: theClass rowanPackageName = packageName1.
	self assert: instanceMethod rowanPackageName = packageName2.
	self assert: classMethod rowanPackageName = packageName2.

"audit --> category not correct according to Monticello conventions"
	self deny: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

	self _validateExpectedMonticelloConventionFailure_389_A: audit packageNames: packageNames className: className
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptMethod_issue389_B

	"https://github.com/GemTalk/Rowan/issues/389"

	"adopt methods into an unpackaged class; 
		don't use Monticello convention.
	 methods should be extension methods."

	| projectName packageNames className packageName theClass symDict symDictName instanceMethod classMethod symbolList audit |
	projectName := 'AdoptProject'.
	packageName := 'Adopt-Extensions'.
	packageNames := {packageName}.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().

	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = Rowan unpackagedName.
	self assert: classMethod rowanProjectName = Rowan unpackagedName.

	Rowan packageTools adopt 
		adoptMethod: #foo 
			inClassNamed: className  
			isMeta: false 
			intoPackageNamed: packageName;
		adoptMethod: #bar 
			inClassNamed: className  
			isMeta: true 
			intoPackageNamed: packageName;
		yourself.

"validate"
	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = projectName.
	self assert: classMethod rowanProjectName = projectName.

"audit --> category not correct according to Monticello conventions"
	self deny: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

	self _validateExpectedMonticelloConventionFailure_389_B: audit packageName: packageName className: className.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptMethod_issue389_C

	"https://github.com/GemTalk/Rowan/issues/389"

	"adopt methods into a different package than the packaged class; 
		use Monticello convention (_A).
	 methods should be extension methods."

	"adopt methods into a packaged class change protocol to use Monticello convention (_A)"

	| projectName packageNames className packageName1 packageName2 theClass symDict symDictName instanceMethod classMethod symbolList audit |
	projectName := 'AdoptProject'.
	packageName1 := 'Adopt-Core'.
	packageName2 := 'Adopt-Extension'.
	packageNames := {packageName1. packageName2 }.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().
	theClass category: packageName1.

	self assert: theClass rowanProjectName = Rowan unpackagedName.

	Rowan packageTools adopt 
		adoptClassNamed: className  
			intoPackageNamed: packageName1.

	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	self assert: instanceMethod rowanProjectName = Rowan unpackagedName.
	self assert: classMethod rowanProjectName = Rowan unpackagedName.

	Rowan packageTools adopt 
		adoptMethod: #foo 
			protocol: '*', packageName2 asLowercase
			inClassNamed: className  
			isMeta: false 
			intoPackageNamed: packageName2;
		adoptMethod: #bar 
			protocol: '*', packageName2 asLowercase
			inClassNamed: className  
			isMeta: true 
			intoPackageNamed: packageName2;
		yourself.

"validate"
	self assert: theClass rowanPackageName = packageName1.
	self assert: instanceMethod rowanPackageName = packageName2.
	self assert: classMethod rowanPackageName = packageName2.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptMethod_issue389_D

	"https://github.com/GemTalk/Rowan/issues/389"

	"adopt methods into an unpackaged class; 
		don't use Monticello convention (_B).
	 methods should be extension methods."

	"adopt methods change protocol to use Monticello convention (_B)"

	| projectName packageNames className packageName theClass symDict symDictName instanceMethod classMethod symbolList audit |
	projectName := 'AdoptProject'.
	packageName := 'Adopt-Extension'.
	packageNames := {packageName}.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().

	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = Rowan unpackagedName.
	self assert: classMethod rowanProjectName = Rowan unpackagedName.

	Rowan packageTools adopt 
		adoptMethod: #foo 
			protocol: 'accessing'
			inClassNamed: className  
			isMeta: false 
			intoPackageNamed: packageName;
		adoptMethod: #bar 
			protocol: 'accessing'
			inClassNamed: className  
			isMeta: true 
			intoPackageNamed: packageName;
		yourself.

"validate"
	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = projectName.
	self assert: classMethod rowanProjectName = projectName.

"audit --> category not correct according to Monticello conventions"
	self deny: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

	self _validateExpectedMonticelloConventionFailure_389_B: audit packageName: packageName className: className
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptSymbolDictionary_1

	"simplest case"

	"https://github.com/dalehenrich/Rowan/issues/208"

	| projectName packageNames className packageName theClass symDict symDictName instanceMethod classMethod symbolList |
	projectName := 'AdoptProject'.
	packageName := 'Adopt-Core'.
	packageNames := {packageName}.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().

	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = Rowan unpackagedName.
	self assert: classMethod rowanProjectName = Rowan unpackagedName.

	Rowan packageTools adopt 
		adoptSymbolDictionaryNamed: symDictName 
		intoPackageNamed: packageName.

	self assert: theClass rowanProjectName = projectName.
	self assert: instanceMethod rowanProjectName = projectName.
	self assert: classMethod rowanProjectName = projectName.

	self assert: theClass rowanPackageName = packageName.
	self assert: instanceMethod rowanPackageName = packageName.
	self assert: classMethod rowanPackageName = packageName.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptSymbolDictionary_2

	"packaged and unpackaged code sharing a symbol dictionary"

	"https://github.com/dalehenrich/Rowan/issues/208"

	| projectName packageNames className1 className2 packageName1 packageName2 theClass symDict symDictName instanceMethod classMethod symbolList |
	projectName := 'AdoptProject'.
	packageName1 := 'Adopt-Core1'.
	packageName2 := 'Adopt-Core2'.
	packageNames := {packageName1. packageName2.}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AdoptedClass1'.
	className2 := 'AdoptedClass2'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use Rowan api to create package class and methods"

	theClass := Object
		rwSubclass: className1
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	instanceMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: 'accessing'.
	classMethod := theClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'.

	self assert: theClass rowanProjectName = projectName.
	self assert: instanceMethod rowanProjectName = projectName.
	self assert: classMethod rowanProjectName = projectName.

	self assert: theClass rowanPackageName = packageName1.
	self assert: instanceMethod rowanPackageName = packageName1.
	self assert: classMethod rowanPackageName = packageName1.

	"Use non-Rowan api to create unpackaged class and methods"
	theClass := Object subclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().

	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = Rowan unpackagedName.
	self assert: classMethod rowanProjectName = Rowan unpackagedName.

	Rowan packageTools adopt 
		adoptSymbolDictionaryNamed: symDictName 
		intoPackageNamed: packageName2.

	self assert: theClass rowanProjectName = projectName.
	self assert: instanceMethod rowanProjectName = projectName.
	self assert: classMethod rowanProjectName = projectName.

	self assert: theClass rowanPackageName = packageName2.
	self assert: instanceMethod rowanPackageName = packageName2.
	self assert: classMethod rowanPackageName = packageName2.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptSymbolList_1

	"https://github.com/dalehenrich/Rowan/issues/208"

	| projectName packageNames className packageName theClass symDict symDictName instanceMethod classMethod symbolList packageNameMap
		excludedSymbolDictionaries |
	projectName := 'AdoptProject'.
	packageName := 'Adopt-Core'.
	packageNames := {packageName}.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().

	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = Rowan unpackagedName.
	self assert: classMethod rowanProjectName = Rowan unpackagedName.

	packageNameMap := Dictionary new
		at: symDictName asString put: packageName;
		yourself.
	excludedSymbolDictionaries := symbolList reject: [:symbolDictionary | symbolDictionary name = symDictName ].
	Rowan packageTools adopt 
		adoptSymbolList: symbolList 
		excluding: excludedSymbolDictionaries 
		intoPackagesNamed: packageNameMap.

	self assert: theClass rowanProjectName = projectName.
	self assert: instanceMethod rowanProjectName = projectName.
	self assert: classMethod rowanProjectName = projectName.

	self assert: theClass rowanPackageName = packageName.
	self assert: instanceMethod rowanPackageName = packageName.
	self assert: classMethod rowanPackageName = packageName.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdoptSymbolList_2

	"https://github.com/dalehenrich/Rowan/issues/208"

	| projectName packageNames className packageName theClass symDict symDictName instanceMethod classMethod symbolList packageNameMap
		excludedSymbolDictionaryNames |
	projectName := 'AdoptProject'.
	packageName := 'Adopt-Core'.
	packageNames := {packageName}.
	symDictName := self _symbolDictionaryName2.
	className := 'AdoptedClass'.
	symbolList := Rowan image symbolList.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symDictName
		comment: 'project for testing package adopt api'.

	symDict := Rowan globalNamed: symDictName.

	"Use non-Rowan api to create class and methods"
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().

	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	self assert: theClass rowanProjectName = Rowan unpackagedName.
	self assert: instanceMethod rowanProjectName = Rowan unpackagedName.
	self assert: classMethod rowanProjectName = Rowan unpackagedName.

	packageNameMap := Dictionary new
		at: symDictName asString put: packageName;
		yourself.
	excludedSymbolDictionaryNames := (symbolList reject: [:symbolDictionary | symbolDictionary name = symDictName ]) collect: [:each | each name asString ].
	Rowan packageTools adopt 
		adoptSymbolList: symbolList 
		excludingSymbolDictsNamed: excludedSymbolDictionaryNames 
		intoPackagesNamed: packageNameMap.

	self assert: theClass rowanProjectName = projectName.
	self assert: instanceMethod rowanProjectName = projectName.
	self assert: classMethod rowanProjectName = projectName.

	self assert: theClass rowanPackageName = packageName.
	self assert: instanceMethod rowanPackageName = packageName.
	self assert: classMethod rowanPackageName = packageName.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdopt_issue481_A

	"https://github.com/GemTalk/Rowan/issues/481"

	"missing instance method for packaged class"

	| projectName packageNames className1 className2 packageName1 packageName2
		symDictName projectDefinition notified audit |

	projectName := 'AdoptProject_481'.
	packageName1 := 'Adopt-Core'.
	packageName2 := 'Adopt-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AdoptedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create image artifacts and projectDefinition"
	projectDefinition := self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"remove #foo method"
	(Rowan globalNamed: className1) removeSelector: #foo.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and expect an error"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: Error
		do: [:ex | notified := true ].
	self assert: notified.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and handle the missing method"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: RwAdoptAuditMethodErrorNotification
		do: [:ex |
			notified := true.
			self assert: ex className = className1.
			self deny: ex isClassExtension.
			self assert: ex selector = #foo.
			self deny: ex isMetaclass.
			self assert: ex packageName = packageName1.
			ex resume ].
	self assert: notified.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdopt_issue481_A_F

	"https://github.com/GemTalk/Rowan/issues/481"

	"missing unpackaged class and missing instance method for packaged class"

	"test for RwAdoptAuditErrorNotification>>methodErrorDo:classErrorDo:"

	| projectName packageNames className1 className2 packageName1 packageName2
		symDictName projectDefinition notified audit report |

	projectName := 'AdoptProject_481'.
	packageName1 := 'Adopt-Core'.
	packageName2 := 'Adopt-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AdoptedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create image artifacts and projectDefinition"
	projectDefinition := self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"remove #foo method"
	(Rowan globalNamed: className1) removeSelector: #foo.
"remove className2"
	(Rowan globalNamed: symDictName) removeKey: className2 asSymbol.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and expect an error"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: Error
		do: [:ex | notified := true ].
	self assert: notified.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and handle the missing class and missing method"
	notified := false.
	report := WriteStream on: String new.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: RwAdoptMissingMethodErrorNotification, RwAdoptMissingClassErrorNotification
		do: [:ex |
			notified := true.
			ex 
				methodErrorDo: [
					"RwAdoptAuditMethodErrorNotification"
					self assert: ex className = className1.
					self deny: ex isClassExtension.
					self assert: ex selector = #foo.
					self deny: ex isMetaclass.
					self assert: ex packageName = packageName1.
					report nextPutAll: 'Missing loaded method ', ex methodPrintString, ' encountered during adopt ... IGNORED'; lf ]
				classErrorDo: [
					"RwAdoptMissingClassErrorNotification"
					self assert: ex className = className2.
					self assert: ex isClassExtension.
					self assert: ex packageName = packageName2.
					report nextPutAll: 'Missing loaded class ', ex className, ' encountered during adopt ... IGNORED'; lf  ].
			ex resume ].
	self assert: notified.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdopt_issue481_B

	"https://github.com/GemTalk/Rowan/issues/481"

	"missing class method for packaged class"

	| projectName packageNames className1 className2 packageName1 packageName2
		symDictName projectDefinition notified audit |

	projectName := 'AdoptProject_481'.
	packageName1 := 'Adopt-Core'.
	packageName2 := 'Adopt-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AdoptedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create image artifacts and projectDefinition"
	projectDefinition := self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"remove #bar class method"
	(Rowan globalNamed: className1) class removeSelector: #bar.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and expect an error"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: Error
		do: [:ex | notified := true ].
	self assert: notified.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and handle the missing method"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: RwAdoptMissingMethodErrorNotification
		do: [:ex |
			notified := true.
			self assert: ex className = className1.
			self deny: ex isClassExtension.
			self assert: ex selector = #bar.
			self assert: ex isMetaclass.
			self assert: ex packageName = packageName1.
			ex resume ].
	self assert: notified.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdopt_issue481_C

	"https://github.com/GemTalk/Rowan/issues/481"

	"missing instance method extension for unpackaged class"

	| projectName packageNames className1 className2 packageName1 packageName2 
		symDictName projectDefinition notified audit |

	projectName := 'AdoptProject_481'.
	packageName1 := 'Adopt-Core'.
	packageName2 := 'Adopt-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AdoptedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create image artifacts and projectDefinition"
	projectDefinition := self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"remove #foo method"
	(Rowan globalNamed: className2) removeSelector: #foo.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and expect an error"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: Error
		do: [:ex | notified := true ].
	self assert: notified.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and handle the missing method"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: RwAdoptAuditMethodErrorNotification
		do: [:ex |
			notified := true.
			self assert: ex className = className2.
			self assert: ex isClassExtension.
			self assert: ex selector = #foo.
			self deny: ex isMetaclass.
			self assert: ex packageName = packageName2.
			ex resume ].
	self assert: notified.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdopt_issue481_D

	"https://github.com/GemTalk/Rowan/issues/481"

	"missing class method extension for unpackaged class"

	| projectName packageNames className1 className2 packageName1 packageName2
		symDictName projectDefinition notified audit |

	projectName := 'AdoptProject_481'.
	packageName1 := 'Adopt-Core'.
	packageName2 := 'Adopt-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AdoptedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create image artifacts and projectDefinition"
	projectDefinition := self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"remove #bar class method"
	(Rowan globalNamed: className2) class removeSelector: #bar.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and expect an error"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: Error
		do: [:ex | notified := true ].
	self assert: notified.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and handle the missing method"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: RwAdoptAuditMethodErrorNotification
		do: [:ex |
			notified := true.
			self assert: ex className = className2.
			self assert: ex isClassExtension.
			self assert: ex selector = #bar.
			self assert: ex isMetaclass.
			self assert: ex packageName = packageName2.
			ex resume ].
	self assert: notified.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdopt_issue481_E

	"https://github.com/GemTalk/Rowan/issues/481"

	"missing packaged class"

	| projectName packageNames className1 className2 packageName1 packageName2  symDictName projectDefinition notified audit |

	projectName := 'AdoptProject_481'.
	packageName1 := 'Adopt-Core'.
	packageName2 := 'Adopt-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AdoptedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create image artifacts and projectDefinition"
	projectDefinition := self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"remove className1"
	(Rowan globalNamed: symDictName) removeKey: className1 asSymbol.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and expect an error"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: Error
		do: [:ex | notified := true ].
	self assert: notified.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and handle the missing class"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: RwAdoptMissingClassErrorNotification
		do: [:ex |
			notified := true.
			self assert: ex className = className1.
			self deny: ex isClassExtension.
			self assert: ex packageName = packageName1.
			ex resume ].
	self assert: notified.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwAdoptToolApiTest
testAdopt_issue481_F

	"https://github.com/GemTalk/Rowan/issues/481"

	"missing unpackaged class"

	| projectName packageNames className1 className2 packageName1 packageName2  symDictName projectDefinition notified audit|

	projectName := 'AdoptProject_481'.
	packageName1 := 'Adopt-Core'.
	packageName2 := 'Adopt-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AdoptedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create image artifacts and projectDefinition"
	projectDefinition := self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"remove className2"
	(Rowan globalNamed: symDictName) removeKey: className2 asSymbol.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and expect an error"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: Error
		do: [:ex | notified := true ].
	self assert: notified.

"disown the project"
	Rowan projectTools disown disownProjectNamed: projectDefinition name.

"create an empty loaded project"
	self
		_issue481_loadProjectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			symDictName: symDictName.

"adopt and handle the missing class"
	notified := false.
	[ Rowan projectTools adopt adoptProjectDefinition: projectDefinition ]
		on: RwAdoptMissingClassErrorNotification
		do: [:ex |
			notified := true.
			self assert: ex className = className2.
			self assert: ex isClassExtension.
			self assert: ex packageName = packageName2.
			ex resume ].
	self assert: notified.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'private'
method: RwAdoptToolApiTest
_validateExpectedMonticelloConventionFailure_389: audit packageName: packageName className: className

	"validate expected audit failures - according to Monticello conventions"

	| failures unexpectedFailures |
	failures := audit at: packageName.
	self assert: failures size = 1.
	failures := failures at: className.
	self assert: failures size = 2.

	"extension categories not named according to Monticello conventions (no leading $*)"
	unexpectedFailures := failures reject: [:each | (each matches: 'Missing instance method extension category ') or: [ each matches: 'Missing class method extension category ' ] ].
	self assert: unexpectedFailures isEmpty
%

category: 'private'
method: RwAdoptToolApiTest
_validateExpectedMonticelloConventionFailure_389_A: audit packageNames: packageNames className: className

	"validate expected audit failures - according to Monticello conventions"

	| unexpectedFailures |
	self _validateExpectedMonticelloConventionFailure_389: audit packageName: (packageNames at: 2) className: className.
	audit removeKey: (packageNames at: 2).

	"class category not following Monticello conventions"
	unexpectedFailures := ((audit at: (packageNames at: 1)) at: className)
		reject: [:each | (each matches: 'Class category has changed in compiled class v loaded class')
			or: [ (each matches: 'Missing instance method extension category') or: [ (each matches:  'Missing class method extension category')
			or: [ (each matches:  'Missing loaded method') ] ] ] ].
	self assert: unexpectedFailures isEmpty
%

category: 'private'
method: RwAdoptToolApiTest
_validateExpectedMonticelloConventionFailure_389_B: audit packageName: packageName className: className

	"validate expected audit failures - according to Monticello conventions"

	self _validateExpectedMonticelloConventionFailure_389: audit packageName: packageName className: className.
	audit removeKey: packageName.
	self assert: audit isEmpty
%

! Class implementation for 'RwBrowserToolApiTest'

!		Instance methods for 'RwBrowserToolApiTest'

category: 'tests'
method: RwBrowserToolApiTest
testAddMethod

	| projectName packageNames className packageName1 packageName2 packageName3 testClass testInstance browserTool compiledMethod gsNMethod |
	projectName := 'Simple Browser'.
	packageName1 := 'Simple-Core'.
	packageName2 := 'Simple-Extensions1'.
	packageName3 := 'Simple-Extensions2'.
	packageNames := {packageName1.
	packageName2.
	packageName3}.
	className := 'SimpleBrowse'.
	self
		_loadStandardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'
		className: className
		inPackageName: packageName1.

	browserTool := Rowan projectTools browser.

	browserTool
		addOrUpdateMethod: 'ivar1: anInteger ivar1 := anInteger'
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName1.	"add method in the package of the class"

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	testInstance := testClass new.
	testInstance perform: #ivar1: with: 3.
	self assert: (testInstance  perform: #ivar1) = 3.
	self should: [ testInstance  perform: #foo ] raise: MessageNotUnderstood.

	browserTool
		addOrUpdateMethod: 'foo ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName2.

	self assert: (testInstance  perform: #foo) = 'bar'.

	gsNMethod := browserTool
		addOrUpdateMethod: 'foo ^''baz'''
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName2.	"add method in a package as a class extension"

	self assert: (testInstance  perform: #foo) = 'baz'.

	self assert: testClass rowanProjectName = projectName.
	self assert: testClass rowanPackageName = packageName1.

	compiledMethod := testClass compiledMethodAt: #'foo'.
	self assert: gsNMethod == compiledMethod.
	self assert: compiledMethod rowanProjectName = projectName.
	self assert: compiledMethod rowanPackageName = packageName2
%

category: 'tests'
method: RwBrowserToolApiTest
testClassCreationTemplate

	| template x |
	template := Rowan projectTools browser
		classCreationTemplateForSubclassOf: 'Object'
		category: 'MyClasses'.
	self
		assert: template = self _expectedHybridClassCreationTemplate
		description: 'incorrect class creation template'.

	template := Rowan projectTools browser
		classCreationTemplateForSubclassOf: 'Object'
		category: 'MyClasses'
		packageName: 'MyPackage'.
	self
		assert: template = self _expectedClassCreationTemplate
		description: 'incorrect class creation template'.

	template := Rowan projectTools browser
		classCreationTemplateForClass: ByteArray
		hybridBrowser: true.
	self
		assert: template = (x := self _expectedHybridByteArrayCreationTemplate)
		description: 'incorrect class creation template'.

	template := Rowan projectTools browser
		classCreationTemplateForClass: ByteArray
		hybridBrowser: false.
	self
		assert: template = (x := self _expectedHybridByteArrayCreationTemplate)
		description: 'incorrect class creation template'.

	template := Rowan projectTools browser
		classCreationTemplateForClass: Collection
		hybridBrowser: false.
	self
		assert: template = self _expectedCollectionCreationTemplate
		description: 'incorrect class creation template'.

	template := Rowan projectTools browser
		classCreationTemplateForClass: Association
		hybridBrowser: false.
	self
		assert: template = (x := self _expectedAssociationCreationTemplate)
		description: 'incorrect class creation template'
%

category: 'tests'
method: RwBrowserToolApiTest
testCreateClass

	| projectName packageNames className packageName classDefinition browserTool testClass testSymDict |
	projectName := 'Simple Browser'.
	packageName := 'Simple-Core'.
	packageNames := {packageName}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'.

	className := 'SimpleBrowse'.
	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #('civar1')
		classvars: #('Cvar1')
		category: 'Simple Things'
		comment: 'I am a SimpleEdit class'
		pools: #()
		type: 'normal'.

	browserTool := Rowan projectTools browser.
	browserTool createClass: classDefinition inPackageNamed: packageName.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.

	testSymDict := Rowan globalNamed: self _symbolDictionaryName.
	self assert: (testSymDict at: className) == testClass
%

category: 'tests'
method: RwBrowserToolApiTest
testCreateClassWithConstraints

	| projectName packageNames className packageName classDefinition browserTool testClass testSymDict x |
	projectName := 'Simple Browser'.
	packageName := 'Simple-Core'.
	packageNames := {packageName}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'.

	className := 'SimpleBrowseWithConstraints'.
	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #('civar1')
		classvars: #('Cvar1')
		category: 'Simple Things'
		comment: 'I am a SimpleEdit class'
		pools: #()
		type: 'normal'.
	classDefinition gs_constraints: { {'ivar1' . 'Integer'} }.

	browserTool := Rowan projectTools browser.
	browserTool createClass: classDefinition inPackageNamed: packageName.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.

	testSymDict := Rowan globalNamed: self _symbolDictionaryName.
	self assert: (testSymDict at: className) == testClass.

	self assert: (x := testClass _constraintOn: #ivar1) = Integer
%

category: 'tests'
method: RwBrowserToolApiTest
testCreateClassWithOptions

	| projectName packageNames className packageName classDefinition browserTool testClass testSymDict |
	projectName := 'Simple Browser'.
	packageName := 'Simple-Core'.
	packageNames := {packageName}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'.

	className := 'SimpleBrowseWithOptions'.
	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #('civar1')
		classvars: #('Cvar1')
		category: 'Simple Things'
		comment: 'I am a SimpleEdit class'
		pools: #()
		type: 'normal'.
	classDefinition gs_options: #(instancesInvariant).

	browserTool := Rowan projectTools browser.
	browserTool createClass: classDefinition inPackageNamed: packageName.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.

	testSymDict := Rowan globalNamed: self _symbolDictionaryName.
	self assert: (testSymDict at: className) == testClass.

	self assert: testClass instancesInvariant
%

category: 'tests'
method: RwBrowserToolApiTest
testDeleteClass

	| projectName packageNames className packageName1 testClass browserTool testSymDict |
	projectName := 'Simple Browser'.
	packageName1 := 'Simple-Core'.
	packageNames := {packageName1}.
	className := 'SimpleBrowse'.
	self
		_loadSimpleProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'
		className: className
		inPackageName: packageName1.

	self
		_assert: [ :classDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ self assert: classDef name = className ] ]
		forClassNamed: className.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	testSymDict := Rowan globalNamed: self _symbolDictionaryName.
	self assert: (testSymDict at: className) == testClass.

	browserTool := Rowan projectTools browser.

	browserTool removeClassNamed: className.

	testClass := Rowan globalNamed: className.
	self assert: testClass isNil
%

category: 'tests'
method: RwBrowserToolApiTest
testDeleteComplicatedClass

	"The class to be deleted is created in one project and extended by another project ... the method extensions are direct method extensions and session method extensions"

	| projectName1 projectName2 packageNames1 packageNames2 className1 className2 packageName1 packageName2 testClass browserTool 
		testProjectDefinition testPackageNames classDefinition testInstance projectTools symDict registry|
	projectName1 := 'Simple Browser1'.
	packageName1 := 'Simple1-Core'.
	packageName2 := 'Simple1-Extensions'.
	packageNames1 := {packageName1}.
	className1 := 'SimpleBrowse1'.
	className2 := 'SimpleBrowse2'.
	projectName2 := 'Simple Browser2'.
	packageNames2 := {'Simple2-Extensions1'.
	'Simple2-Extensions2'}.
	self
		_loadSimpleProjectDefinition: projectName1
		packageNames: packageNames1
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'
		className: className1
		inPackageName: packageName1.

	testClass := Rowan globalNamed: className1.
	self assert: testClass notNil.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool addPackageNamed: packageName2 toProjectNamed: projectName1.	"new package packageName2"

	packageNames1 := {packageName1.
	packageName2}.
	testProjectDefinition := browserTool projectNamed: projectName1.
	testPackageNames := testProjectDefinition packageNames.
	self assert: testPackageNames size = packageNames1 size.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: 'Fun stuff'
		comment: 'just a class'
		pools: #()
		type: 'normal'.
	browserTool createClass: classDefinition inPackageNamed: packageName2.	"new class className2"

	testClass := Rowan globalNamed: className2.
	self assert: testClass notNil.

	browserTool
		addOrUpdateMethod: 'foo ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: packageName2.	"extension method for className1"

	testClass := Rowan globalNamed: className1.
	self assert: testClass notNil.
	testInstance := testClass new.
	self assert: (testInstance perform: #foo) = 'foo'.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ self assert: classExtensionDef instanceMethodDefinitions size = 0 ].
			packageDef name = packageName2
				ifTrue: [ 
					self
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'foo') ] ]
		forClassExtensionsIn: className1.

	(Rowan image loadedProjectNamed: projectName2 ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	browserTool
		createGitPackageProjectNamed: projectName2
		updateDefinition: [ :projectDef | 
			"create a second project for more extension methods"
			projectDef
				addPackagesNamed: packageNames2;
				defaultSymbolDictName: self _symbolDictionaryName1;
				defaultUseSessionMethodsForExtensions: true;
				comment: 'another project for testing project browser api';
				yourself ].

	testProjectDefinition := browserTool projectNamed: projectName2.
	self
		assert:
			testProjectDefinition defaultSymbolDictName = self _symbolDictionaryName1.

	browserTool
		addOrUpdateMethod: 'bar ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: (packageNames2 at: 1).	"extension method for className1 in projectName2"

	self assert: (testInstance  perform: #bar) = 'bar'.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ 
					self
						assert: projectDef name = projectName1;
						assert: classExtensionDef instanceMethodDefinitions size = 0 ].
			packageDef name = packageName2
				ifTrue: [ 
					self
						assert: projectDef name = projectName1;
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'foo') ].
			packageDef name = (packageNames2 at: 1)
				ifTrue: [ 
					self
						assert: projectDef name = projectName2;
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'bar') ] ]
		forClassExtensionsIn: className1.


	self
		_assertForClassExtensionInClassWithHistory: testClass classHistory
		ifPresent: [ :classExtensionSet | self assert: classExtensionSet size = 2 ]
		ifAbsent: [ 
			self
				assert: false
				description:
					'Expected class extension for class ' , className1 printString , ' not present' ].
	symDict := Rowan globalNamed: self _symbolDictionaryName.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 2.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.

	browserTool removeClassNamed: className1.	"remove class className1"

	self
		_assertForClassExtensionInClassWithHistory: testClass classHistory
		ifPresent: [ :classExtensionSet | 
			self
				assert: false
				description:
					'Unexpected class extension for class ' , className1 printString , ' found' ]
		ifAbsent: [ 
			"expected result"
			 ].

	testClass := Rowan globalNamed: className1.
	self assert: testClass isNil.

	symDict := Rowan globalNamed: self _symbolDictionaryName.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwBrowserToolApiTest
testDeleteComplicatedPackage

	"similar to testDeleteComplicatedClass ... but delete package that contains the class ... should be similar result"

	| projectName1 projectName2 packageNames1 packageNames2 className1 className2 packageName1 packageName2 browserTool classDefinition projectTools testClass testProjectDefinition testPackageNames theProjectNames thePackageNames |
	projectName1 := 'Simple Browser1'.
	packageName1 := 'Simple1-Core'.
	packageName2 := 'Simple1-Extensions'.
	packageNames1 := {packageName1}.
	className1 := 'SimpleBrowse1'.
	className2 := 'SimpleBrowse2'.
	projectName2 := 'Simple Browser2'.
	packageNames2 := {'Simple2-Extensions1'.
	'Simple2-Extensions2'}.
	self
		_loadSimpleProjectDefinition: projectName1
		packageNames: packageNames1
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'
		className: className1
		inPackageName: packageName1.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool addPackageNamed: packageName2 toProjectNamed: projectName1.	"new package packageName2"

	packageNames1 := {packageName1.
	packageName2}.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: 'Fun stuff'
		comment: 'just a class'
		pools: #()
		type: 'normal'.
	browserTool createClass: classDefinition inPackageNamed: packageName2.	"new class className2"

	browserTool
		addOrUpdateMethod: 'foo ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: packageName2.	"extension method for className1"

	(Rowan image loadedProjectNamed: projectName2 ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	browserTool
		createGitPackageProjectNamed: projectName2
		updateDefinition: [ :projectDef | 
			"create a second project for more extension methods"
			projectDef
				addPackagesNamed: packageNames2;
				defaultSymbolDictName: self _symbolDictionaryName1;
				defaultUseSessionMethodsForExtensions: true;
				comment: 'another project for testing project browser api';
				yourself ].

	browserTool
		addOrUpdateMethod: 'bar ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: (packageNames2 at: 1).	"extension method for className1 in projectName2"

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			"validate loaded class extension registry structure"
			packageDef name = packageName1
				ifTrue: [ 
					self
						assert: projectDef name = projectName1;
						assert: classExtensionDef instanceMethodDefinitions size = 0 ].
			packageDef name = packageName2
				ifTrue: [ 
					self
						assert: projectDef name = projectName1;
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'foo') ].
			packageDef name = (packageNames2 at: 1)
				ifTrue: [ 
					self
						assert: projectDef name = projectName2;
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'bar') ] ]
		forClassExtensionsIn: className1.

	testClass := Rowan globalNamed: className1.
	self
		_assertForClassExtensionInClassWithHistory: testClass classHistory
		ifPresent: [ :classExtensionSet | self assert: classExtensionSet size = 2 ]
		ifAbsent: [ 
			self
				assert: false
				description:
					'Expected class extension for class ' , className1 printString , ' not present' ].

	theProjectNames := {projectName1.
	projectName2}.
	thePackageNames := packageNames1 , packageNames2.
	theProjectNames
		do: [ :projectName | 
			| theLoadedProject theLoadedPackage theLoadedClassOrClassExtension |
			"Traverse the loaded package structure and verify that it is valid"
			theLoadedProject := Rowan image loadedProjectNamed: projectName.
			theLoadedProject
				loadedPackagesDo: [ :loadedProject :loadedPackage | 
					self assert: theLoadedProject == loadedProject.
					theLoadedPackage := loadedPackage.
					self
						assert:
							(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
					loadedProject name = projectName1
						ifTrue: [ self assert: (packageNames1 includes: loadedPackage name) ].
					loadedProject name = projectName2
						ifTrue: [ self assert: (packageNames2 includes: loadedPackage name) ] ]
				loadedClassedDo: [ :loadedProject :loadedPackage :loadedClass | 
					self assert: theLoadedProject == loadedProject.
					self assert: theLoadedPackage == loadedPackage.
					self
						assert:
							(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
					theLoadedClassOrClassExtension := loadedClass.
					loadedProject name = projectName1
						ifTrue: [ 
							loadedPackage name = packageName1
								ifTrue: [ self assert: loadedClass name = className1 ].
							loadedPackage name = packageName2
								ifTrue: [ self assert: loadedClass name = className2 ] ].
					loadedProject name = projectName2
						ifTrue: [ 
							loadedPackage name = (packageNames2 at: 1)
								ifTrue: [ 
									self
										assert: false
										description:
											'no classes expected in ' , (packageNames2 at: 1) printString ].
							loadedPackage name = (packageNames2 at: 2)
								ifTrue: [ 
									self
										assert: false
										description:
											'no classes expected in ' , (packageNames2 at: 2) printString ] ] ]
				loadedClassExtensionsDo: [ :loadedProject :loadedPackage :loadedClassExtension | 
					self assert: theLoadedProject == loadedProject.
					self assert: theLoadedPackage == loadedPackage.
					self
						assert:
							(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
					theLoadedClassOrClassExtension := loadedClassExtension.
					loadedProject name = projectName1
						ifTrue: [ 
							loadedPackage name = packageName1
								ifTrue: [ 
									self
										assert: false
										description: 'no classes expected in ' , packageName1 printString ].
							loadedPackage name = packageName2
								ifTrue: [ self assert: loadedClassExtension name = className1 ] ].
					loadedProject name = projectName2
						ifTrue: [ 
							loadedPackage name = (packageNames2 at: 1)
								ifTrue: [ self assert: loadedClassExtension name = className1 ].
							loadedPackage name = (packageNames2 at: 2)
								ifTrue: [ 
									self
										assert: false
										description:
											'no classes expected in ' , (packageNames2 at: 2) printString ] ] ]
				loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
					self assert: theLoadedProject == loadedProject.
					self assert: theLoadedPackage == loadedPackage.
					self
						assert:
							(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
					self assert: theLoadedClassOrClassExtension == loadedClassOrClassExtension.
					loadedProject name = projectName1
						ifTrue: [ 
							loadedPackage name = packageName1
								ifTrue: [ 
									self
										assert: false
										description: 'no classes expected in ' , packageName1 printString ].
							loadedPackage name = packageName2
								ifTrue: [ self assert: loadedMethod selector = #'foo' ] ].
					loadedProject name = projectName2
						ifTrue: [ 
							loadedPackage name = (packageNames2 at: 1)
								ifTrue: [ self assert: loadedMethod selector = #'bar' ].
							loadedPackage name = (packageNames2 at: 2)
								ifTrue: [ 
									self
										assert: false
										description:
											'no classes expected in ' , (packageNames2 at: 2) printString ] ] ]
				loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
					self
						assert: false
						description: 'no class methods should be present in the project structure' ] ].


	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testClass or: [ beh class == testClass ])
						ifTrue: [ self assert: (methodDict size = 1 and: [ methodDict includesKey: #'bar' ]) ] ] ].

	browserTool removePackageNamed: packageName1.	"remove the package and unload definitions"


	self should: [ Rowan image loadedPackageNamed: packageName1 ] raise: Error.

	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testClass or: [ beh class == testClass ])
						ifTrue: [ 
							self
								assert: false
								description:
									'Session methods should not be present for class ' , className1 printString ] ] ].

	self
		_assertForClassExtensionInClassWithHistory: testClass classHistory
		ifPresent: [ :classExtensionSet | 
			self
				assert: false
				description:
					'Unexpected class extension for class ' , className1 printString , ' found' ]
		ifAbsent: [ 
			"expected result"
			 ].

	theProjectNames
		do: [ :projectName | 
			| theLoadedProject theLoadedPackage theLoadedClassOrClassExtension |
			"Traverse the loaded package structure and verify that it is valid"
			theLoadedProject := Rowan image loadedProjectNamed: projectName.
			theLoadedProject
				loadedPackagesDo: [ :loadedProject :loadedPackage | 
					self assert: theLoadedProject == loadedProject.
					theLoadedPackage := loadedPackage.
					self
						assert:
							(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
					loadedProject name = projectName1
						ifTrue: [ 
							loadedPackage name = packageName1
								ifTrue: [ 
									self
										assert: false
										description:
											'the package ' , packageName1 , ' should have been removed' ].
							self assert: (packageNames1 includes: loadedPackage name) ].
					loadedProject name = projectName2
						ifTrue: [ self assert: (packageNames2 includes: loadedPackage name) ] ]
				loadedClassedDo: [ :loadedProject :loadedPackage :loadedClass | 
					self assert: theLoadedProject == loadedProject.
					self assert: theLoadedPackage == loadedPackage.
					self
						assert:
							(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
					theLoadedClassOrClassExtension := loadedClass.
					loadedProject name = projectName1
						ifTrue: [ 
							loadedPackage name = packageName1
								ifTrue: [ 
									self
										assert: false
										description:
											'the package ' , packageName1 printString
												, ' had been removed no loadedClasses should be present.' ].
							loadedPackage name = packageName2
								ifTrue: [ self assert: loadedClass name = className2 ] ].
					loadedProject name = projectName2
						ifTrue: [ 
							loadedPackage name = (packageNames2 at: 1)
								ifTrue: [ 
									self
										assert: false
										description:
											'no classes expected in ' , (packageNames2 at: 1) printString ].
							loadedPackage name = (packageNames2 at: 2)
								ifTrue: [ 
									self
										assert: false
										description:
											'no classes expected in ' , (packageNames2 at: 2) printString ] ] ]
				loadedClassExtensionsDo: [ :loadedProject :loadedPackage :loadedClassExtension | 
					self assert: theLoadedProject == loadedProject.
					self assert: theLoadedPackage == loadedPackage.
					self
						assert:
							(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
					theLoadedClassOrClassExtension := loadedClassExtension.
					loadedProject name = projectName1
						ifTrue: [ 
							loadedPackage name = packageName1
								ifTrue: [ 
									self
										assert: false
										description: 'no classes expected in ' , packageName1 printString ].
							loadedPackage name = packageName2
								ifTrue: [ 
									self
										assert: false
										description:
											'The class ' , className1 printString
												,
													' was removed when packageName1 was removed - no extensions should be present' ] ].
					loadedProject name = projectName2
						ifTrue: [ 
							loadedPackage name = (packageNames2 at: 1)
								ifTrue: [ 
									self
										assert: false
										description:
											'The class ' , className1 printString
												,
													' was removed when packageName1 was removed - no extensions should be present' ].
							loadedPackage name = (packageNames2 at: 2)
								ifTrue: [ 
									self
										assert: false
										description:
											'no classes expected in ' , (packageNames2 at: 2) printString ] ] ]
				loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
					self assert: theLoadedProject == loadedProject.
					self assert: theLoadedPackage == loadedPackage.
					self
						assert:
							(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
					self assert: theLoadedClassOrClassExtension == loadedClassOrClassExtension.
					loadedProject name = projectName1
						ifTrue: [ 
							loadedPackage name = packageName1
								ifTrue: [ 
									self
										assert: false
										description: 'no classes expected in ' , packageName1 printString ].
							loadedPackage name = packageName2
								ifTrue: [ 
									self
										assert: false
										description:
											'The method #foo was removed when packageName1 was removed' ] ].
					loadedProject name = projectName2
						ifTrue: [ 
							loadedPackage name = (packageNames2 at: 1)
								ifTrue: [ 
									self
										assert: false
										description:
											'The method #bar was removed when packageName1 was removed' ].
							loadedPackage name = (packageNames2 at: 2)
								ifTrue: [ 
									self
										assert: false
										description:
											'no classes expected in ' , (packageNames2 at: 2) printString ] ] ]
				loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
					self
						assert: false
						description: 'no class methods should be present in the project structure' ] ].

	testClass := Rowan globalNamed: className1.
	self assert: testClass isNil.
	testProjectDefinition := browserTool projectNamed: projectName1.
	testPackageNames := testProjectDefinition packageNames.
	self assert: testPackageNames = {packageName2}
%

category: 'tests'
method: RwBrowserToolApiTest
testDeleteGlobalExtensionMethod

	| projectName packageNames className packageName1 testClass testInstance browserTool |
	projectName := 'Simple Browser'.
	packageName1 := 'Simple-Global-Extensions1'.
	packageNames := {packageName1}.
	className := 'Object'.
	self
		_loadGlobalExtensionsProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'.

	browserTool := Rowan projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName1.	"add extension method to Object"

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	testInstance := testClass new.
	self assert: (testInstance perform: #foo) = 'bar'.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ 
					self
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'foo') ] ]
		forClassExtensionsIn: className.

	browserTool removeMethod: #'foo' forClassNamed: className isMeta: false.

	self should: [ testInstance perform: #foo ] raise: MessageNotUnderstood.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ self assert: classExtensionDef instanceMethodDefinitions size = 0 ] ]
		forClassExtensionsIn: className
%

category: 'tests'
method: RwBrowserToolApiTest
testDeleteMethod

	| projectName packageNames className packageName1 testClass testInstance browserTool testSymDict |
	projectName := 'Simple Browser'.
	packageName1 := 'Simple-Core'.
	packageNames := {packageName1}.
	className := 'SimpleBrowse'.
	self
		_loadStandardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'
		className: className
		inPackageName: packageName1.
	self
		_assert: [ :classDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ 
					self
						assert: classDef instanceMethodDefinitions size = 1;
						assert: (classDef instanceMethodDefinitions includesKey: #'ivar1') ] ]
		forClassNamed: className.

	browserTool := Rowan projectTools browser.

	browserTool
		addOrUpdateMethod: 'ivar1: anInteger ivar1 := anInteger'
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName1.	"add method in the package of the class"

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	testSymDict := Rowan globalNamed: self _symbolDictionaryName.
	self assert: (testSymDict at: className) == testClass.
	testInstance := testClass new.
	testInstance perform: #ivar1: with: 3.
	self assert: (testInstance  perform: #ivar1) = 3.

	self
		_assert: [ :classDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ 
					self
						assert: classDef instanceMethodDefinitions size = 2;
						assert: (classDef instanceMethodDefinitions includesKey: #'ivar1:') ] ]
		forClassNamed: className.


	browserTool removeMethod: #'ivar1:' forClassNamed: className isMeta: false.

	self should: [ testInstance  perform: #ivar1: with: 2 ] raise: MessageNotUnderstood.
	self assert: (testInstance  perform: #ivar1) = 3.

	self
		_assert: [ :classDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ 
					self
						assert: classDef instanceMethodDefinitions size = 1;
						assert: (classDef instanceMethodDefinitions includesKey: #'ivar1') ] ]
		forClassNamed: className
%

category: 'tests'
method: RwBrowserToolApiTest
testDeletePackage

	| projectName packageNames className packageName1 testClass browserTool testSymDict testProjectDefinition testPackageNames |
	projectName := 'Simple Browser'.
	packageName1 := 'Simple-Core'.
	packageNames := {packageName1}.
	className := 'SimpleBrowse'.
	self
		_loadSimpleProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'
		className: className
		inPackageName: packageName1.

	self
		_assert: [ :classDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ self assert: classDef name = className ] ]
		forClassNamed: className.

	browserTool := Rowan projectTools browser.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	testSymDict := Rowan globalNamed: self _symbolDictionaryName.
	self assert: (testSymDict at: className) == testClass.
	testProjectDefinition := browserTool projectNamed: projectName.
	testPackageNames := testProjectDefinition packageNames.
	self assert: testPackageNames = packageNames.

	browserTool removePackageNamed: packageName1.	"remove the package and unload definitions"

	testClass := Rowan globalNamed: className.
	self assert: testClass isNil.
	testProjectDefinition := browserTool projectNamed: projectName.
	testPackageNames := testProjectDefinition packageNames.
	self assert: testPackageNames isEmpty
%

category: 'tests'
method: RwBrowserToolApiTest
testIsExtensionMethod

	| projectName packageNames className packageName1 packageName2   browserTool |
	projectName := 'Simple Browser'.
	packageName1 := 'Simple-Core'.
	packageName2 := 'Simple-Extensions1'.
	packageNames := {packageName1.
	packageName2}.
	className := 'SimpleBrowse'.
	self
		_loadStandardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'
		className: className
		inPackageName: packageName1.

	browserTool := Rowan projectTools browser.

	browserTool
		addOrUpdateMethod: 'ivar1: anInteger ivar1 := anInteger'
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName1.	"add method in the package of the class"

	browserTool
		addOrUpdateMethod: 'bar ^1'
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: true
		inPackageNamed: packageName1.	"add method in the package of the class"

	self deny: (browserTool isExtensionMethod: 'ivar1' forClassNamed: className isMeta: false).
	self deny: (browserTool isExtensionMethod: 'bar' forClassNamed: className isMeta: true).

	browserTool
		addOrUpdateMethod: 'foo ^1'
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName2.	"add method in a package as a class extension"

	browserTool
		addOrUpdateMethod: 'baz ^1'
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: true
		inPackageNamed: packageName2.	"add method in a package as a class extension"

	self assert: (browserTool isExtensionMethod: 'foo' forClassNamed: className isMeta: false).
	self assert: (browserTool isExtensionMethod: 'baz' forClassNamed: className isMeta: true).

	self deny: (browserTool isExtensionMethod: 'yourself' forClassNamed: 'Object' isMeta: false). "not rowanized at moment"
%

category: 'tests'
method: RwBrowserToolApiTest
testIssue471_1

	"expected failure until issue #471 is addressed"

  "https://github.com/dalehenrich/Rowan/issues/471"

  | projectName  packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
    className4 projectSetDefinition class1 class2 class3 class4 oldClass1 oldClass2 oldClass3  |

  projectName := 'Issue471'.
  packageName1 := 'Issue471-Core'.
  packageName2 := 'Issue471-Extensions'.
  className1 := 'Issue471Class1'.
  className2 := 'Issue471Class2'.
  className3 := 'Issue471Class3'.
  className4 := 'Issue471Class4'.

  {projectName}
    do: [ :pn |
      (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
        ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
  projectDefinition := (RwProjectDefinition
    newForGitBasedProjectNamed: projectName)
    addPackageNamed: packageName1;
    addPackageNamed: packageName2;
    defaultSymbolDictName: self _symbolDictionaryName1;
    yourself.

  packageDefinition := projectDefinition packageNamed: packageName1.

  classDefinition := (RwClassDefinition
    newForClassNamed: className1
      super: 'Object'
      instvars: #(ivar1)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className2
      super: className1
      instvars: #('ivar2')
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className3
      super: className2
      instvars: #('ivar4' 'ivar3')
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
   yourself.
  packageDefinition
    addClassDefinition: classDefinition.

"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).

  class2 := Rowan globalNamed: className2.
  self assert: class2 instVarNames = #(ivar2).
  self assert: class2 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: class3 superClass == class2.

"remove class2 and add class4 -- edit projectDefinition structure in place"
  packageDefinition := projectDefinition packageNamed: packageName1.

  packageDefinition removeClassNamed: className2.

  classDefinition := (RwClassDefinition
    newForClassNamed: className4
      super: className1
      instvars: #('ivar2')
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.
"load"
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  oldClass1 := class1.
  oldClass2 := class2.
  oldClass3 := class3.
 
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: oldClass1 == class1.

  class4 := Rowan globalNamed: className4.
  self assert: class4 instVarNames = #(ivar2).
  self assert: class4 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: class3 superClass == oldClass2.
  self assert: oldClass3 == class3.
%

category: 'tests'
method: RwBrowserToolApiTest
testIssue471_2

  "https://github.com/dalehenrich/Rowan/issues/471"

  | projectName  packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
    className4 projectSetDefinition class1 class2 class3 class4 oldClass1 oldClass2 oldClass3  |

  projectName := 'Issue471'.
  packageName1 := 'Issue471-Core'.
  packageName2 := 'Issue471-Extensions'.
  className1 := 'Issue471Class1'.
  className2 := 'Issue471Class2'.
  className3 := 'Issue471Class3'.
  className4 := 'Issue471Class4'.

  {projectName}
    do: [ :pn |
      (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
        ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
  projectDefinition := (RwProjectDefinition
    newForGitBasedProjectNamed: projectName)
    addPackageNamed: packageName1;
    addPackageNamed: packageName2;
    defaultSymbolDictName: self _symbolDictionaryName1;
    yourself.

  packageDefinition := projectDefinition packageNamed: packageName1.

  classDefinition := (RwClassDefinition
    newForClassNamed: className1
      super: 'Object'
      instvars: #(ivar1)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className2
      super: className1
      instvars: #('ivar2')
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className3
      super: className2
      instvars: #('ivar4' 'ivar3')
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
   yourself.
  packageDefinition
    addClassDefinition: classDefinition.

"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).

  class2 := Rowan globalNamed: className2.
  self assert: class2 instVarNames = #(ivar2).
  self assert: class2 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: class3 superClass == class2.

"remove class2 and add class4 -- edit projectDefinition structure in place"
  projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
  self assert: (projectDefinition projectDefinitionSourceProperty = RwLoadedProject _projectLoadedDefinitionSourceValue).

  packageDefinition := projectDefinition packageNamed: packageName1.

  packageDefinition removeClassNamed: className2.

  classDefinition := (RwClassDefinition
    newForClassNamed: className4
      super: className1
      instvars: #('ivar2')
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.
"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  oldClass1 := class1.
  oldClass2 := class2.
  oldClass3 := class3.
 
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: oldClass1 == class1.

  class4 := Rowan globalNamed: className4.
  self assert: class4 instVarNames = #(ivar2).
  self assert: class4 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: class3 superClass == oldClass2.
  self assert: oldClass3 == class3.
%

category: 'tests'
method: RwBrowserToolApiTest
testLoadFullMultiProjectDefs

	"set up projects and packages for hybrid browser implementation"

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass testInstance rpn |
	projectName1 := 'Simple MultiProject 1'.
	projectName2 := 'Simple MultiProject 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1M-Core'.
	project1PackageName2 := 'Simple1M-Extensions'.
	project2PackageName1 := 'Simple2M-Core'.
	project2PackageName2 := 'Simple2M-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleMultiProject1'.
	className2 := 'SimpleMultiProject2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1M-Core'.
	classPackageNames2 := 'Simple2M-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName2)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadFullMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	rpn := Rowan projectNames.
	projectNames do: [ :projectName | self assert: (rpn includes: projectName) ].
	rpn := Rowan packageNames.
	packageNames
		do: [ :packageNameAr | packageNameAr do: [ :packageName | self assert: (rpn includes: packageName) ] ].

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	testClass := Rowan globalNamed: className1.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	testInstance := testClass new.
	self assert: (testInstance  perform: #ivar1) isNil.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: '*' , project1PackageName2 asLowercase
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: '*' , project1PackageName2 asLowercase
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	browserTool
		projectNamed: projectName2
		updateDefinition: [ :projectDef | 
			projectDef
				setUseSessionMethodsForExtensions: true
				forPackageNamed: project2PackageName2 ].

	browserTool
		addOrUpdateMethod: 'bar "instance" ^''bar'''
		inProtocol: '*' , project2PackageName2 asLowercase
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project2PackageName2.	"session method extension method for className1 in projectName2"

	browserTool
		addOrUpdateMethod: 'bar "class" ^''bar'''
		inProtocol: '*' , project2PackageName2 asLowercase
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project2PackageName2.	"class session method extension method for className1 in projectName2"

	rpn := Rowan projectNames.
	projectNames do: [ :projectName | self assert: (rpn includes: projectName) ].
	rpn := Rowan packageNames.
	packageNames
		do: [ :packageNameAr | packageNameAr do: [ :packageName | self assert: (rpn includes: packageName) ] ]
%

category: 'tests'
method: RwBrowserToolApiTest
testLoadMultiProjectDefs

	"set up projects and packages for hybrid browser implementation"

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass testInstance |
	projectName1 := 'Simple MultiProject 1'.
	projectName2 := 'Simple MultiProject 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1M-Core'.
	project1PackageName2 := 'Simple1M-Extensions'.
	project2PackageName1 := 'Simple2M-Core'.
	project2PackageName2 := 'Simple2M-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleMultiProject1'.
	className2 := 'SimpleMultiProject2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1M-Core'.
	classPackageNames2 := 'Simple2M-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName2)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadFullMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	testClass := Rowan globalNamed: className1.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	testInstance := testClass new.
	self assert: (testInstance  perform: #ivar1) isNil.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: '*' , project1PackageName2 asLowercase
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: '*' , project1PackageName2 asLowercase
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	browserTool
		projectNamed: projectName2
		updateDefinition: [ :projectDef | 
			projectDef
				setUseSessionMethodsForExtensions: true
				forPackageNamed: project2PackageName2 ].

	browserTool
		addOrUpdateMethod: 'bar "instance" ^''bar'''
		inProtocol: '*' , project2PackageName2 asLowercase
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project2PackageName2.	"session method extension method for className1 in projectName2"

	browserTool
		addOrUpdateMethod: 'bar "class" ^''bar'''
		inProtocol: '*' , project2PackageName2 asLowercase
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project2PackageName2	"class session method extension method for className1 in projectName2"
%

category: 'tests'
method: RwBrowserToolApiTest
testMoveGlobalExtensionSessionMethods

	| projectName packageNames className packageName1 packageName2 testClass testInstance browserTool |
	projectName := 'Simple Browser'.
	packageName1 := 'Simple-Global-Extensions1'.
	packageName2 := 'Simple-Global-Extensions2'.
	packageNames := {packageName1.
	packageName2}.
	className := 'Object'.
	self
		_loadGlobalExtensionsProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'.

	browserTool := Rowan projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName1.	"add extension method to Object"

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	testInstance := testClass new.
	self assert: (testInstance perform: #foo) = 'bar'.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ 
					self
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'foo') ].
			packageDef name = packageName2
				ifTrue: [ self assert: classExtensionDef instanceMethodDefinitions size = 0 ] ]
		forClassExtensionsIn: className.

	browserTool
		addOrUpdateMethod: 'foo ^''bif'''
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName2.	"move method to another package as a class extension"

	self assert: (testInstance  perform: #foo) = 'bif'.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ self assert: classExtensionDef instanceMethodDefinitions size = 0 ].
			packageDef name = packageName2
				ifTrue: [ 
					self
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'foo') ] ]
		forClassExtensionsIn: className
%

category: 'tests'
method: RwBrowserToolApiTest
testMoveMethod

	| projectName packageNames className packageName1 packageName2 packageName3 testClass testInstance browserTool testSymDict
		registry |
	projectName := 'Simple Browser'.
	packageName1 := 'Simple-Core'.
	packageName2 := 'Simple-Extensions1'.
	packageName3 := 'Simple-Extensions2'.
	packageNames := {packageName1.
	packageName2.
	packageName3}.
	className := 'SimpleBrowse'.
	self
		_loadStandardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'
		className: className
		inPackageName: packageName1.

	browserTool := Rowan projectTools browser.

	browserTool
		addOrUpdateMethod: 'ivar1: anInteger ivar1 := anInteger'
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName1.	"add method in the package of the class"

"validate"
	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	testSymDict := Rowan globalNamed: self _symbolDictionaryName.
	self assert: (testSymDict at: className) == testClass.
	testInstance := testClass new.
	testInstance perform: #ivar1: with: 3.
	self assert: (testInstance  perform: #ivar1) = 3.
	self should: [ (testInstance  perform: #foo) ] raise: MessageNotUnderstood.
	self _assertNoClassExtensionsIn: className.

	registry := testSymDict rowanSymbolDictionaryRegistry.
	self assert: registry packageRegistry size = 3.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 5.

	browserTool
		addOrUpdateMethod: 'foo ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName2.	"add method in a package as a class extension"

"validate"
	self assert: (testInstance  perform: #foo) = 'bar'.

	registry := testSymDict rowanSymbolDictionaryRegistry.
	self assert: registry packageRegistry size = 3.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 6.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ self assert: classExtensionDef instanceMethodDefinitions size = 0 ].
			packageDef name = packageName2
				ifTrue: [ 
					self
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'foo') ].
			packageDef name = packageName3
				ifTrue: [ self assert: classExtensionDef instanceMethodDefinitions size = 0 ] ]
		forClassExtensionsIn: className.

	browserTool
		addOrUpdateMethod: 'foo ^''baz'''
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName2.	"change class extension method"

"validate"
	self assert: (testInstance  perform: #foo) = 'baz'.

	registry := testSymDict rowanSymbolDictionaryRegistry.
	self assert: registry packageRegistry size = 3.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 6.

	browserTool
		addOrUpdateMethod: 'foo ^''bif'''
		inProtocol: 'accessing'
		forClassNamed: className
		isMeta: false
		inPackageNamed: packageName3.	"move method to another package as a class extension"

"validate"
	self assert: (testInstance  perform: #foo) = 'bif'.

	registry := testSymDict rowanSymbolDictionaryRegistry.
	self assert: registry packageRegistry size = 3.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 6.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ self assert: classExtensionDef instanceMethodDefinitions size = 0 ].
			packageDef name = packageName2
				ifTrue: [ self assert: classExtensionDef instanceMethodDefinitions size = 0 ].
			packageDef name = packageName3
				ifTrue: [ 
					self
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'foo') ] ]
		forClassExtensionsIn: className
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersionA

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass testInstance testNewClass testNewInstance |
	projectName1 := 'Simple NewVersionA 1'.
	projectName2 := 'Simple NewVersionA 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1A-Core'.
	project1PackageName2 := 'Simple1A-Extensions'.
	project2PackageName1 := 'Simple2A-Core'.
	project2PackageName2 := 'Simple2A-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionA1'.
	className2 := 'SimpleNewVersionA2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1A-Core'.
	classPackageNames2 := 'Simple2A-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName2)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	testClass := Rowan globalNamed: className1.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	testInstance := testClass new.
	self assert: (testInstance  perform: #ivar1) isNil.

	browserTool
		classNamed: className1
		updateDefinition: [ :classDef | 
			classDef
				instVarNames: #();
				removeInstanceMethod: #'ivar1';
				classVarNames: #();
				removeClassMethod: #'cvar1';
				updateClassMethodDefinition:
						(RwMethodDefinition
								newForSelector: #'initialize'
								protocol: 'initialization'
								source: 'initialize civar1 := 1.');
				yourself	"shouldn't there be a method to simply add method source and protocol to the class definition?" ].

	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testInstance  perform: #ivar1) isNil.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testNewClass perform: #civar1) = 1.
	self should: [ (testNewClass perform: #cvar1) ] raise: MessageNotUnderstood.
	testNewInstance := testNewClass new.
	self should: [ (testNewInstance perform: #ivar1) ] raise: MessageNotUnderstood.

	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersionB

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass testInstance testNewClass testNewInstance sessionMethodsSeen |
	projectName1 := 'Simple NewVersionB 1'.
	projectName2 := 'Simple NewVersionB 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1B-Core'.
	project1PackageName2 := 'Simple1B-Extensions'.
	project2PackageName1 := 'Simple2B-Core'.
	project2PackageName2 := 'Simple2B-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionB1'.
	className2 := 'SimpleNewVersionB2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1B-Core'.
	classPackageNames2 := 'Simple2B-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName2)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	browserTool
		projectNamed: projectName2
		updateDefinition: [ :projectDef | 
			projectDef
				setUseSessionMethodsForExtensions: true
				forPackageNamed: project2PackageName2 ].

	browserTool
		addOrUpdateMethod: 'bar "instance" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project2PackageName2.	"session method extension method for className1 in projectName2"

	browserTool
		addOrUpdateMethod: 'bar "class" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project2PackageName2.	"class session method extension method for className1 in projectName2"

	testClass := Rowan globalNamed: className1.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.


	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testClass or: [ beh class == testClass ])
						ifTrue: [ 
							self assert: (methodDict includesKey: #'bar').
							sessionMethodsSeen := true ] ] ].
	self assert: sessionMethodsSeen.

	browserTool
		projectsNamed: projectNames
		updateDefinition: [ :projectDef | 
			projectDef name = projectName1
				ifTrue: [ 
					| packageDef classDef classExtensionDef |
					packageDef := projectDef packageNamed: project1PackageName1.
					classDef := packageDef classDefinitions at: className1.
					classDef
						instVarNames: #();
						removeInstanceMethod: #'ivar1';
						classVarNames: #();
						removeClassMethod: #'cvar1';
						updateClassMethodDefinition:
								(RwMethodDefinition
										newForSelector: #'initialize'
										protocol: 'initialization'
										source: 'initialize civar1 := 1.');
						yourself.	"shouldn't there be a method to simply add method source and protocol to the class definition?"
					packageDef := projectDef packageNamed: project1PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef removeInstanceMethod: #'foo' ].
			projectDef name = projectName2
				ifTrue: [ 
					| packageDef classExtensionDef |
					packageDef := projectDef packageNamed: project2PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef removeClassMethod: #'bar' ] ].

	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testNewClass perform: #civar1) = 1.
	self should: [ testNewClass perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testNewClass perform: #foo = 'foo').
	self should: [ (testNewClass perform: #bar) = 'bar' ] raise: MessageNotUnderstood.
	testNewInstance := testNewClass new.
	self should: [ testNewInstance perform: #ivar1 ] raise: MessageNotUnderstood.
	self should: [ (testNewInstance perform: #foo) = 'foo' ] raise: MessageNotUnderstood.
	self assert: (testNewInstance perform: #bar) = 'bar'.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.

	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testNewClass or: [ beh class == testNewClass ])
						ifTrue: [ sessionMethodsSeen := true ] ] ].
	self assert: sessionMethodsSeen
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersion_260_change_extension_method_protocol

	"https://github.com/dalehenrich/Rowan/issues/260"

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 
		project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 
		classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass 
		testInstance testNewClass testNewInstance |
	projectName1 := 'Simple NewVersionD 1'.
	projectName2 := 'Simple NewVersionD 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1D-Core'.
	project1PackageName2 := 'Simple1D-Extensions'.
	project2PackageName1 := 'Simple2D-Core'.
	project2PackageName2 := 'Simple2D-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionD1'.
	className2 := 'SimpleNewVersionD2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1D-Core'.
	classPackageNames2 := 'Simple2D-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName1)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	testClass := Rowan globalNamed: className1.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.

	browserTool
		projectsNamed: projectNames
		updateDefinition: [ :projectDef | 
			projectDef name = projectName1
				ifTrue: [ 
					| packageDef classDef classExtensionDef |
					packageDef := projectDef packageNamed: project1PackageName1.
					classDef := packageDef classDefinitions at: className1.
					classDef
						instVarNames: #();
						removeInstanceMethod: #'ivar1';
						classVarNames: #();
						removeClassMethod: #'cvar1';
						updateClassMethodDefinition:
								(RwMethodDefinition
										newForSelector: #'initialize'
										protocol: 'initialization'
										source: 'initialize civar1 := 1.');
						yourself.	"shouldn't there be a method to simply add method source and protocol to the class definition?"
					packageDef := projectDef packageNamed: project1PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef updateInstanceMethodDefinition: 
								(RwMethodDefinition
										newForSelector: #'foo'
										protocol: 'boom'
										source:  'foo "instance" ^''foo''') ] ].

	self assert: (testClass  perform: #civar1) = 1.
	self assert: (testClass  perform: #cvar1) = 2.
	self assert: (testClass  perform: #foo) = 'foo'.
	self assert: (testInstance  perform: #ivar1) isNil.
	self assert: (testInstance  perform: #foo) = 'foo'.
	self assert: (testClass categoryOfSelector: #foo) = #accessing.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testNewClass  perform: #civar1) = 1.
	self should: [ testNewClass  perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testNewClass  perform: #foo) = 'foo'.
	self assert: (testNewClass categoryOfSelector: #foo) = #boom.

	testNewInstance := testNewClass new.
	self should: [ testNewInstance  perform: #ivar1 ] raise: MessageNotUnderstood.
	self assert: (testNewInstance  perform: #foo) = 'foo'.

	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersion_260_change_extension_method_source

	"https://github.com/dalehenrich/Rowan/issues/260"

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 
		project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 
		classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass 
		testInstance testNewClass testNewInstance |
	projectName1 := 'Simple NewVersionD 1'.
	projectName2 := 'Simple NewVersionD 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1D-Core'.
	project1PackageName2 := 'Simple1D-Extensions'.
	project2PackageName1 := 'Simple2D-Core'.
	project2PackageName2 := 'Simple2D-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionD1'.
	className2 := 'SimpleNewVersionD2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1D-Core'.
	classPackageNames2 := 'Simple2D-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName1)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	testClass := Rowan globalNamed: className1.
	self assert: (testClass  perform: #civar1) = 1.
	self assert: (testClass  perform: #cvar1) = 2.
	self assert: (testClass  perform: #foo) = 'foo'.
	testInstance := testClass new.
	self assert: (testInstance  perform: #ivar1) isNil.
	self assert: (testInstance  perform: #foo) = 'foo'.

	browserTool
		projectsNamed: projectNames
		updateDefinition: [ :projectDef | 
			projectDef name = projectName1
				ifTrue: [ 
					| packageDef classDef classExtensionDef |
					packageDef := projectDef packageNamed: project1PackageName1.
					classDef := packageDef classDefinitions at: className1.
					classDef
						instVarNames: #();
						removeInstanceMethod: #'ivar1';
						classVarNames: #();
						removeClassMethod: #'cvar1';
						updateClassMethodDefinition:
								(RwMethodDefinition
										newForSelector: #'initialize'
										protocol: 'initialization'
										source: 'initialize civar1 := 1.');
						yourself.	"shouldn't there be a method to simply add method source and protocol to the class definition?"
					packageDef := projectDef packageNamed: project1PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef updateInstanceMethodDefinition: 
								(RwMethodDefinition
										newForSelector: #'foo'
										protocol: 'accessing'
										source:  'foo "instance side" ^''foo_''') ] ].

	self assert: (testClass  perform: #civar1) = 1.
	self assert: (testClass  perform: #cvar1) = 2.
	self assert: (testClass  perform: #foo) = 'foo'.
	self assert: (testInstance  perform: #ivar1) isNil.
	self assert: (testInstance  perform: #foo) = 'foo'.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testNewClass  perform: #civar1) = 1.
	self should: [ testNewClass  perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testNewClass  perform: #foo) = 'foo'.
	testNewInstance := testNewClass new.
	self should: [ testNewInstance  perform: #ivar1 ] raise: MessageNotUnderstood.
	self assert: (testNewInstance  perform: #foo) = 'foo_'.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersion_260_unchanged_extension_method_protocol

	"https://github.com/dalehenrich/Rowan/issues/260"

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 
		project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 
		classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass 
		testInstance testNewClass testNewInstance  |
	projectName1 := 'Simple NewVersionD 1'.
	projectName2 := 'Simple NewVersionD 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1D-Core'.
	project1PackageName2 := 'Simple1D-Extensions'.
	project2PackageName1 := 'Simple2D-Core'.
	project2PackageName2 := 'Simple2D-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionD1'.
	className2 := 'SimpleNewVersionD2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1D-Core'.
	classPackageNames2 := 'Simple2D-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName1)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	testClass := Rowan globalNamed: className1.
	self assert: (testClass  perform: #civar1) = 1.
	self assert: (testClass  perform: #cvar1) = 2.
	self assert: (testClass  perform: #foo) = 'foo'.
	testInstance := testClass new.
	self assert: (testInstance  perform: #ivar1) isNil.
	self assert: (testInstance  perform: #foo) = 'foo'.

	browserTool
		projectsNamed: projectNames
		updateDefinition: [ :projectDef | 
			projectDef name = projectName1
				ifTrue: [ 
					| packageDef classDef classExtensionDef |
					packageDef := projectDef packageNamed: project1PackageName1.
					classDef := packageDef classDefinitions at: className1.
					classDef
						instVarNames: #();
						removeInstanceMethod: #'ivar1';
						classVarNames: #();
						removeClassMethod: #'cvar1';
						updateClassMethodDefinition:
								(RwMethodDefinition
										newForSelector: #'initialize'
										protocol: 'initialization'
										source: 'initialize civar1 := 1.');
						yourself.	"shouldn't there be a method to simply add method source and protocol to the class definition?"
					packageDef := projectDef packageNamed: project1PackageName2.
					classExtensionDef := packageDef classExtensions at: className1 ] ].

	self assert: (testClass  perform: #civar1) = 1.
	self assert: (testClass  perform: #cvar1) = 2.
	self assert: (testClass  perform: #foo) = 'foo'.
	self assert: (testInstance  perform: #ivar1) isNil.
	self assert: (testInstance  perform: #foo) = 'foo'.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testNewClass  perform: #civar1) = 1.
	self should: [ testNewClass  perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testNewClass  perform: #foo) = 'foo'.
	testNewInstance := testNewClass new.
	self should: [ testNewInstance  perform: #ivar1 ] raise: MessageNotUnderstood.
	self assert: (testNewInstance  perform: #foo) = 'foo'.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersion_multi_project_change_extension_method_protocol

	"https://github.com/dalehenrich/Rowan/issues/260"

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 
		project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 
		classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass 
		testInstance testNewClass testNewInstance sessionMethodsSeen |
	projectName1 := 'Simple NewVersionD 1'.
	projectName2 := 'Simple NewVersionD 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1D-Core'.
	project1PackageName2 := 'Simple1D-Extensions'.
	project2PackageName1 := 'Simple2D-Core'.
	project2PackageName2 := 'Simple2D-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionD1'.
	className2 := 'SimpleNewVersionD2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1D-Core'.
	classPackageNames2 := 'Simple2D-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName1)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	browserTool
		projectNamed: projectName2
		updateDefinition: [ :projectDef | 
			projectDef
				setUseSessionMethodsForExtensions: false
				forPackageNamed: project2PackageName2 ].

	browserTool
		addOrUpdateMethod: 'bar "instance" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project2PackageName2.

	browserTool
		addOrUpdateMethod: 'bar "class" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project2PackageName2.

	testClass := Rowan globalNamed: className1.
	self assert: (testClass  perform: #civar1) = 1.
	self assert: (testClass  perform: #cvar1) = 2.
	self assert: (testClass  perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	testInstance := testClass new.
	self assert: (testInstance  perform: #ivar1) isNil.
	self assert: (testInstance  perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.


	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testClass or: [ beh class == testClass ])
						ifTrue: [ 
							self assert: (methodDict includesKey: #'bar').
							sessionMethodsSeen := true ] ] ].
	self deny: sessionMethodsSeen.

	browserTool
		projectsNamed: projectNames
		updateDefinition: [ :projectDef | 
			projectDef name = projectName1
				ifTrue: [ 
					| packageDef classDef classExtensionDef |
					packageDef := projectDef packageNamed: project1PackageName1.
					classDef := packageDef classDefinitions at: className1.
					classDef
						instVarNames: #();
						removeInstanceMethod: #'ivar1';
						classVarNames: #();
						removeClassMethod: #'cvar1';
						updateClassMethodDefinition:
								(RwMethodDefinition
										newForSelector: #'initialize'
										protocol: 'initialization'
										source: 'initialize civar1 := 1.');
						yourself.	"shouldn't there be a method to simply add method source and protocol to the class definition?"
					packageDef := projectDef packageNamed: project1PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef updateInstanceMethodDefinition: 
								(RwMethodDefinition
										newForSelector: #'foo'
										protocol: 'boom'
										source:  'foo "instance" ^''foo''') ].
			projectDef name = projectName2
				ifTrue: [ 
					| packageDef classExtensionDef |
					packageDef := projectDef packageNamed: project2PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef updateClassMethodDefinition: 
								(RwMethodDefinition
										newForSelector: #'bar'
										protocol: 'boom'
										source:  'bar "class side" ^''bar''') ] ].

	self assert: (testClass  perform: #civar1) = 1.
	self assert: (testClass  perform: #cvar1) = 2.
	self assert: (testClass  perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	self assert: (testInstance  perform: #ivar1) isNil.
	self assert: (testInstance  perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.
	self assert: (testClass categoryOfSelector: #foo) = #accessing.
	self assert: (testClass class categoryOfSelector: #bar) = #accessing.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testClass  perform: #civar1) = 1.
	self should: [ testNewClass perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testClass  perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	self assert: (testNewClass categoryOfSelector: #foo) = #boom.
	self assert: (testNewClass class categoryOfSelector: #bar) = #boom.

	testNewInstance := testNewClass new.
	self should: [ testNewInstance perform: #ivar1 ] raise: MessageNotUnderstood.
	self assert: (testNewInstance perform: #foo) = 'foo'.
	self assert: (testNewInstance perform: #bar) = 'bar'.

	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.

	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testNewClass or: [ beh class == testNewClass ])
						ifTrue: [ sessionMethodsSeen := true ] ] ].
	self deny: sessionMethodsSeen
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersion_multi_project_change_extension_method_source

	"https://github.com/dalehenrich/Rowan/issues/260"

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 
		project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 
		classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass 
		testInstance testNewClass testNewInstance sessionMethodsSeen |
	projectName1 := 'Simple NewVersionD 1'.
	projectName2 := 'Simple NewVersionD 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1D-Core'.
	project1PackageName2 := 'Simple1D-Extensions'.
	project2PackageName1 := 'Simple2D-Core'.
	project2PackageName2 := 'Simple2D-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionD1'.
	className2 := 'SimpleNewVersionD2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1D-Core'.
	classPackageNames2 := 'Simple2D-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName1)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	browserTool
		projectNamed: projectName2
		updateDefinition: [ :projectDef | 
			projectDef
				setUseSessionMethodsForExtensions: false
				forPackageNamed: project2PackageName2 ].

	browserTool
		addOrUpdateMethod: 'bar "instance" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project2PackageName2.	"extension method for className1 in projectName2"

	browserTool
		addOrUpdateMethod: 'bar "class" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project2PackageName2.	"class extension method for className1 in projectName2"

	testClass := Rowan globalNamed: className1.
	self assert: (testClass  perform: #civar1) = 1.
	self assert: (testClass  perform: #cvar1) = 2.
	self assert: (testClass  perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	testInstance := testClass new.
	self assert: (testInstance  perform: #ivar1) isNil.
	self assert: (testInstance  perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.


	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testClass or: [ beh class == testClass ])
						ifTrue: [ 
							self assert: (methodDict includesKey: #'bar').
							sessionMethodsSeen := true ] ] ].
	self deny: sessionMethodsSeen.

	browserTool
		projectsNamed: projectNames
		updateDefinition: [ :projectDef | 
			projectDef name = projectName1
				ifTrue: [ 
					| packageDef classDef classExtensionDef |
					packageDef := projectDef packageNamed: project1PackageName1.
					classDef := packageDef classDefinitions at: className1.
					classDef
						instVarNames: #();
						removeInstanceMethod: #'ivar1';
						classVarNames: #();
						removeClassMethod: #'cvar1';
						updateClassMethodDefinition:
								(RwMethodDefinition
										newForSelector: #'initialize'
										protocol: 'initialization'
										source: 'initialize civar1 := 1.');
						yourself.	"shouldn't there be a method to simply add method source and protocol to the class definition?"
					packageDef := projectDef packageNamed: project1PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef updateInstanceMethodDefinition: 
								(RwMethodDefinition
										newForSelector: #'foo'
										protocol: 'accessing'
										source:  'foo "instance side" ^''foo_''') ].
			projectDef name = projectName2
				ifTrue: [ 
					| packageDef classExtensionDef |
					packageDef := projectDef packageNamed: project2PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef updateClassMethodDefinition: 
								(RwMethodDefinition
										newForSelector: #'bar'
										protocol: 'accessing'
										source:  'bar "class side" ^''bar_''') ] ].

	self assert: (testClass  perform: #civar1) = 1.
	self assert: (testClass  perform: #cvar1) = 2.
	self assert: (testClass  perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	self assert: (testInstance  perform: #ivar1) isNil.
	self assert: (testInstance  perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testClass  perform: #civar1) = 1.
	self should: [ testNewClass perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testClass  perform: #foo) = 'foo'.
	self assert: (testNewClass perform: #bar) = 'bar_'.
	testNewInstance := testNewClass new.
	self should: [ testNewInstance perform: #ivar1 ] raise: MessageNotUnderstood.
	self assert: (testNewInstance perform: #foo) = 'foo_'.
	self assert: (testNewInstance perform: #bar) = 'bar'.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.

	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testNewClass or: [ beh class == testNewClass ])
						ifTrue: [ sessionMethodsSeen := true ] ] ].
	self deny: sessionMethodsSeen
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersion_multi_project_unchanged_extension_method_protocol

	"https://github.com/dalehenrich/Rowan/issues/260"

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 
		project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 
		classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass 
		testInstance testNewClass testNewInstance sessionMethodsSeen |
	projectName1 := 'Simple NewVersionD 1'.
	projectName2 := 'Simple NewVersionD 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1D-Core'.
	project1PackageName2 := 'Simple1D-Extensions'.
	project2PackageName1 := 'Simple2D-Core'.
	project2PackageName2 := 'Simple2D-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionD1'.
	className2 := 'SimpleNewVersionD2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1D-Core'.
	classPackageNames2 := 'Simple2D-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName1)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	browserTool
		projectNamed: projectName2
		updateDefinition: [ :projectDef | 
			projectDef
				setUseSessionMethodsForExtensions: false
				forPackageNamed: project2PackageName2 ].

	browserTool
		addOrUpdateMethod: 'bar "instance" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project2PackageName2.	"extension method for className1 in projectName2"

	browserTool
		addOrUpdateMethod: 'bar "class" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project2PackageName2.	"class extension method for className1 in projectName2"

	testClass := Rowan globalNamed: className1.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.


	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testClass or: [ beh class == testClass ])
						ifTrue: [ 
							self assert: (methodDict includesKey: #'bar').
							sessionMethodsSeen := true ] ] ].
	self deny: sessionMethodsSeen.

	browserTool
		projectsNamed: projectNames
		updateDefinition: [ :projectDef | 
			projectDef name = projectName1
				ifTrue: [ 
					| packageDef classDef classExtensionDef |
					packageDef := projectDef packageNamed: project1PackageName1.
					classDef := packageDef classDefinitions at: className1.
					classDef
						instVarNames: #();
						removeInstanceMethod: #'ivar1';
						classVarNames: #();
						removeClassMethod: #'cvar1';
						updateClassMethodDefinition:
								(RwMethodDefinition
										newForSelector: #'initialize'
										protocol: 'initialization'
										source: 'initialize civar1 := 1.');
						yourself.	"shouldn't there be a method to simply add method source and protocol to the class definition?"
					packageDef := projectDef packageNamed: project1PackageName2.
					classExtensionDef := packageDef classExtensions at: className1 ].
			projectDef name = projectName2
				ifTrue: [ 
					| packageDef classExtensionDef |
					packageDef := projectDef packageNamed: project2PackageName2.
					classExtensionDef := packageDef classExtensions at: className1 ] ].

	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testNewClass perform: #civar1) = 1.
	self should: [ testNewClass perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testNewClass perform: #foo) = 'foo'.
	self assert: (testNewClass perform: #bar) = 'bar'.
	testNewInstance := testNewClass new.
	self should: [ testNewInstance perform: #ivar1 ] raise: MessageNotUnderstood.
	self assert: (testNewInstance perform: #foo) = 'foo'.
	self assert: (testNewInstance perform: #bar) = 'bar'.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.

	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testNewClass or: [ beh class == testNewClass ])
						ifTrue: [ sessionMethodsSeen := true ] ] ].
	self deny: sessionMethodsSeen
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersion_session_method_change_extension_method_protocol

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 
		project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 
		classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass 
		testInstance testNewClass testNewInstance sessionMethodsSeen |
	projectName1 := 'Simple NewVersionD 1'.
	projectName2 := 'Simple NewVersionD 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1D-Core'.
	project1PackageName2 := 'Simple1D-Extensions'.
	project2PackageName1 := 'Simple2D-Core'.
	project2PackageName2 := 'Simple2D-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionD1'.
	className2 := 'SimpleNewVersionD2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1D-Core'.
	classPackageNames2 := 'Simple2D-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName2)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	browserTool
		projectNamed: projectName2
		updateDefinition: [ :projectDef | 
			projectDef
				setUseSessionMethodsForExtensions: true
				forPackageNamed: project2PackageName2 ].

	browserTool
		addOrUpdateMethod: 'bar "instance" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project2PackageName2.	"session method extension method for className1 in projectName2"

	browserTool
		addOrUpdateMethod: 'bar "class" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project2PackageName2.	"class session method extension method for className1 in projectName2"

	testClass := Rowan globalNamed: className1.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.


	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testClass or: [ beh class == testClass ])
						ifTrue: [ 
							self assert: (methodDict includesKey: #'bar').
							sessionMethodsSeen := true ] ] ].
	self assert: sessionMethodsSeen.

	browserTool
		projectsNamed: projectNames
		updateDefinition: [ :projectDef | 
			projectDef name = projectName1
				ifTrue: [ 
					| packageDef classDef classExtensionDef |
					packageDef := projectDef packageNamed: project1PackageName1.
					classDef := packageDef classDefinitions at: className1.
					classDef
						instVarNames: #();
						removeInstanceMethod: #'ivar1';
						classVarNames: #();
						removeClassMethod: #'cvar1';
						updateClassMethodDefinition:
								(RwMethodDefinition
										newForSelector: #'initialize'
										protocol: 'initialization'
										source: 'initialize civar1 := 1.');
						yourself.	"shouldn't there be a method to simply add method source and protocol to the class definition?"
					packageDef := projectDef packageNamed: project1PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef updateInstanceMethodDefinition: 
								(RwMethodDefinition
										newForSelector: #'foo'
										protocol: 'boom'
										source:  'foo "instance" ^''foo''') ].
			projectDef name = projectName2
				ifTrue: [ 
					| packageDef classExtensionDef |
					packageDef := projectDef packageNamed: project2PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef updateClassMethodDefinition: 
								(RwMethodDefinition
										newForSelector: #'bar'
										protocol: 'boom'
										source:  'bar "class side" ^''bar''') ] ].

	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.
	self assert: (testClass categoryOfSelector: #foo) = #accessing.
	self assert: (testClass class categoryOfSelector: #bar) = #accessing.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testNewClass perform: #civar1) = 1.
	self should: [ testNewClass perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testNewClass perform: #foo) = 'foo'.
	self assert: (testNewClass perform: #bar) = 'bar'.
	self assert: (testNewClass categoryOfSelector: #foo) = #boom.
	self assert: (testNewClass class categoryOfSelector: #bar) = #boom.

	testNewInstance := testNewClass new.
	self should: [ testNewInstance perform: #ivar1 ] raise: MessageNotUnderstood.
	self assert: (testNewInstance perform: #foo) = 'foo'.
	self assert: (testNewInstance perform: #bar) = 'bar'.

	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.

	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testNewClass or: [ beh class == testNewClass ])
						ifTrue: [ sessionMethodsSeen := true ] ] ].
	self assert: sessionMethodsSeen
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersion_session_method_change_extension_method_source

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 
		project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 
		classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass 
		testInstance testNewClass testNewInstance sessionMethodsSeen |
	projectName1 := 'Simple NewVersionD 1'.
	projectName2 := 'Simple NewVersionD 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1D-Core'.
	project1PackageName2 := 'Simple1D-Extensions'.
	project2PackageName1 := 'Simple2D-Core'.
	project2PackageName2 := 'Simple2D-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionD1'.
	className2 := 'SimpleNewVersionD2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1D-Core'.
	classPackageNames2 := 'Simple2D-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName2)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	browserTool
		projectNamed: projectName2
		updateDefinition: [ :projectDef | 
			projectDef
				setUseSessionMethodsForExtensions: true
				forPackageNamed: project2PackageName2 ].

	browserTool
		addOrUpdateMethod: 'bar "instance" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project2PackageName2.	"session method extension method for className1 in projectName2"

	browserTool
		addOrUpdateMethod: 'bar "class" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project2PackageName2.	"class session method extension method for className1 in projectName2"

	testClass := Rowan globalNamed: className1.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.


	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testClass or: [ beh class == testClass ])
						ifTrue: [ 
							self assert: (methodDict includesKey: #'bar').
							sessionMethodsSeen := true ] ] ].
	self assert: sessionMethodsSeen.

	browserTool
		projectsNamed: projectNames
		updateDefinition: [ :projectDef | 
			projectDef name = projectName1
				ifTrue: [ 
					| packageDef classDef classExtensionDef |
					packageDef := projectDef packageNamed: project1PackageName1.
					classDef := packageDef classDefinitions at: className1.
					classDef
						instVarNames: #();
						removeInstanceMethod: #'ivar1';
						classVarNames: #();
						removeClassMethod: #'cvar1';
						updateClassMethodDefinition:
								(RwMethodDefinition
										newForSelector: #'initialize'
										protocol: 'initialization'
										source: 'initialize civar1 := 1.');
						yourself.	"shouldn't there be a method to simply add method source and protocol to the class definition?"
					packageDef := projectDef packageNamed: project1PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef updateInstanceMethodDefinition: 
								(RwMethodDefinition
										newForSelector: #'foo'
										protocol: 'accessing'
										source:  'foo "instance side" ^''foo_''') ].
			projectDef name = projectName2
				ifTrue: [ 
					| packageDef classExtensionDef |
					packageDef := projectDef packageNamed: project2PackageName2.
					classExtensionDef := packageDef classExtensions at: className1.
					classExtensionDef updateClassMethodDefinition: 
								(RwMethodDefinition
										newForSelector: #'bar'
										protocol: 'accessing'
										source:  'bar "class side" ^''bar_''') ] ].

	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testNewClass perform: #civar1) = 1.
	self should: [ testNewClass perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testNewClass perform: #foo) = 'foo'.
	self assert: (testNewClass perform: #bar) = 'bar_'.
	testNewInstance := testNewClass new.
	self should: [ testNewInstance perform: #ivar1 ] raise: MessageNotUnderstood.
	self assert: (testNewInstance perform: #foo) = 'foo_'.
	self assert: (testNewInstance perform: #bar) = 'bar'.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.

	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testNewClass or: [ beh class == testNewClass ])
						ifTrue: [ sessionMethodsSeen := true ] ] ].
	self assert: sessionMethodsSeen
%

category: 'tests'
method: RwBrowserToolApiTest
testNewClassVersion_session_method_unchanged_extension_method_protocol

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 
		project2PackageName1 project2PackageName2 className1 className2 classNames classPackageNames1 
		classPackageNames2 classPackageNames defaultSymbolDictNames comments projectTools browserTool testClass 
		testInstance testNewClass testNewInstance sessionMethodsSeen |
	projectName1 := 'Simple NewVersionD 1'.
	projectName2 := 'Simple NewVersionD 2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'Simple1D-Core'.
	project1PackageName2 := 'Simple1D-Extensions'.
	project2PackageName1 := 'Simple2D-Core'.
	project2PackageName2 := 'Simple2D-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'SimpleNewVersionD1'.
	className2 := 'SimpleNewVersionD2'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'Simple1D-Core'.
	classPackageNames2 := 'Simple2D-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName2)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	projectTools := Rowan projectTools.
	browserTool := projectTools browser.

	browserTool
		addOrUpdateMethod: 'foo "instance" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project1PackageName2.	"extension method for className1 in projectName1"

	browserTool
		addOrUpdateMethod: 'foo "class" ^''foo'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project1PackageName2.	"class extension method for className1 in projectName1"

	browserTool
		projectNamed: projectName2
		updateDefinition: [ :projectDef | 
			projectDef
				setUseSessionMethodsForExtensions: true
				forPackageNamed: project2PackageName2 ].

	browserTool
		addOrUpdateMethod: 'bar "instance" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: false
		inPackageNamed: project2PackageName2.	"session method extension method for className1 in projectName2"

	browserTool
		addOrUpdateMethod: 'bar "class" ^''bar'''
		inProtocol: 'accessing'
		forClassNamed: className1
		isMeta: true
		inPackageNamed: project2PackageName2.	"class session method extension method for className1 in projectName2"

	testClass := Rowan globalNamed: className1.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.


	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testClass or: [ beh class == testClass ])
						ifTrue: [ 
							self assert: (methodDict includesKey: #'bar').
							sessionMethodsSeen := true ] ] ].
	self assert: sessionMethodsSeen.

	browserTool
		projectsNamed: projectNames
		updateDefinition: [ :projectDef | 
			projectDef name = projectName1
				ifTrue: [ 
					| packageDef classDef classExtensionDef |
					packageDef := projectDef packageNamed: project1PackageName1.
					classDef := packageDef classDefinitions at: className1.
					classDef
						instVarNames: #();
						removeInstanceMethod: #'ivar1';
						classVarNames: #();
						removeClassMethod: #'cvar1';
						updateClassMethodDefinition:
								(RwMethodDefinition
										newForSelector: #'initialize'
										protocol: 'initialization'
										source: 'initialize civar1 := 1.');
						yourself.	"shouldn't there be a method to simply add method source and protocol to the class definition?"
					packageDef := projectDef packageNamed: project1PackageName2.
					classExtensionDef := packageDef classExtensions at: className1 ].
			projectDef name = projectName2
				ifTrue: [ 
					| packageDef classExtensionDef |
					packageDef := projectDef packageNamed: project2PackageName2.
					classExtensionDef := packageDef classExtensions at: className1 ] ].

	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #foo) = 'foo'.
	self assert: (testClass perform: #bar) = 'bar'.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.
	self assert: (testInstance perform: #bar) = 'bar'.

	testNewClass := Rowan globalNamed: className1.
	self assert: testNewClass ~~ testClass.
	self assert: (testNewClass perform: #civar1) = 1.
	self should: [ testNewClass perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testNewClass perform: #foo) = 'foo'.
	self assert: (testNewClass perform: #bar) = 'bar'.
	testNewInstance := testNewClass new.
	self should: [ testNewInstance perform: #ivar1 ] raise: MessageNotUnderstood.
	self assert: (testNewInstance perform: #foo) = 'foo'.
	self assert: (testNewInstance perform: #bar) = 'bar'.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'ivar1 ^ivar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: false
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.
	self
		should: [ 
			browserTool
				addOrUpdateMethod: 'cvar1 ^Cvar1'
				inProtocol: 'accessing'
				forClassNamed: className1
				isMeta: true
				inPackageNamed: project1PackageName2 ]
		raise: CompileError.

	sessionMethodsSeen := false.
	GsPackagePolicy current
		packages_Do: [ :gsPackage | 
			gsPackage
				behaviorAndMethodDictDo: [ :beh :methodDict | 
					(beh == testNewClass or: [ beh class == testNewClass ])
						ifTrue: [ sessionMethodsSeen := true ] ] ].
	self assert: sessionMethodsSeen
%

category: 'tests'
method: RwBrowserToolApiTest
testRenameClass_1

  "rename a class with no subclasses"

  "https://github.com/dalehenrich/Rowan/issues/470"

  | projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3
    className4 projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 classExtensionDefinition |

  projectName := 'Issue470'.
  packageName1 := 'Issue470-Core'.
  packageName2 := 'Issue470-Extensions'.
  className1 := 'Issue470Class1'.
  className2 := 'Issue470Class2'.
  className3 := 'Issue470Class3'.
  className4 := 'Issue470Class4'.

  {projectName}
    do: [ :pn |
      (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
        ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
  projectDefinition := (RwProjectDefinition
    newForGitBasedProjectNamed: projectName)
    addPackageNamed: packageName1;
    addPackageNamed: packageName2;
    defaultSymbolDictName: self _symbolDictionaryName1;
    yourself.

  packageDefinition := projectDefinition packageNamed: packageName1.

  classDefinition1 := (RwClassDefinition
    newForClassNamed: className1
      super: 'Object'
      instvars: #(ivar1)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod1 ^1' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod1 ^', className2 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition1.

  classDefinition := (RwClassDefinition
    newForClassNamed: className2
      super: className1
      instvars: #(ivar2)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod2 ^2' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod2 ^', className3 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className3
      super: className2
      instvars: #(ivar4 ivar3)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod3 ^3' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod3 ^', className1 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

"create extension methods"
  packageDefinition := projectDefinition packageNamed: packageName2.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className1)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod1 ^1' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod1 ^1' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className2)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod2 ^2' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod2 ^2' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className3)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod3 ^3' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod3 ^3' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.


"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: (class1 compiledMethodAt: #instanceMethod1) rowanPackageName = packageName1.
  self assert: (class1 class compiledMethodAt: #classMethod1) rowanPackageName = packageName1.
  self assert: (class1 compiledMethodAt: #extensionInstanceMethod1) rowanPackageName = packageName2.
  self assert: (class1 class compiledMethodAt: #extensionClassMethod1) rowanPackageName = packageName2.

  class2 := Rowan globalNamed: className2.
  self assert: class2 instVarNames = #(ivar2).
  self assert: (class2 compiledMethodAt: #instanceMethod2) rowanPackageName = packageName1.
  self assert: (class2 class compiledMethodAt: #classMethod2) rowanPackageName = packageName1.
  self assert: (class2 compiledMethodAt: #extensionInstanceMethod2) rowanPackageName = packageName2.
  self assert: (class2 class compiledMethodAt: #extensionClassMethod2) rowanPackageName = packageName2.
  self assert: class2 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: (class3 compiledMethodAt: #instanceMethod3) rowanPackageName = packageName1.
  self assert: (class3 class compiledMethodAt: #classMethod3) rowanPackageName = packageName1.
  self assert: (class3 compiledMethodAt: #extensionInstanceMethod3) rowanPackageName = packageName2.
  self assert: (class3 class compiledMethodAt: #extensionClassMethod3) rowanPackageName = packageName2.
  self assert: class3 superClass == class2.

"perform rename"
  Rowan projectTools browser
    renameClassNamed: className3 to: className4.

"validate"
  oldClass1 := class1.
  oldClass2 := class2.
  oldClass3 := class3.
 
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: (class1 compiledMethodAt: #instanceMethod1) rowanPackageName = packageName1.
  self assert: (class1 class compiledMethodAt: #classMethod1) rowanPackageName = packageName1.
  self assert: (class1 compiledMethodAt: #extensionInstanceMethod1) rowanPackageName = packageName2.
  self assert: (class1 class compiledMethodAt: #extensionClassMethod1) rowanPackageName = packageName2.
  self assert: oldClass1 == class1.

  class2 := Rowan globalNamed: className2.
  self assert: class2 instVarNames = #(ivar2).
  self assert: (class2 compiledMethodAt: #instanceMethod2) rowanPackageName = packageName1.
  self assert: (class2 class compiledMethodAt: #classMethod2) rowanPackageName = packageName1.
  self assert: (class2 compiledMethodAt: #extensionInstanceMethod2) rowanPackageName = packageName2.
  self assert: (class2 class compiledMethodAt: #extensionClassMethod2) rowanPackageName = packageName2.
  self assert: class2 superClass == class1.
  self assert: oldClass2 == class2.

  class3 := Rowan globalNamed: className4.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: (class3 compiledMethodAt: #instanceMethod3) rowanPackageName = packageName1.
  self assert: (class3 class compiledMethodAt: #classMethod3) rowanPackageName = packageName1.
  self assert: (class3 compiledMethodAt: #extensionInstanceMethod3) rowanPackageName = packageName2.
  self assert: (class3 class compiledMethodAt: #extensionClassMethod3) rowanPackageName = packageName2.
  self assert: class3 superClass == class2.
  self assert: oldClass3 ~~ class3. "renamed class"
%

category: 'tests'
method: RwBrowserToolApiTest
testRenameClass_2

  "rename a class with a subclass - reference to renamed class in methods"

  "https://github.com/dalehenrich/Rowan/issues/470"

  | projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3
    className4 projectSetDefinition class1 class2 class3 class4 oldClass1 oldClass2 oldClass3 classExtensionDefinition |

  projectName := 'Issue470'.
  packageName1 := 'Issue470-Core'.
  packageName2 := 'Issue470-Extensions'.
  className1 := 'Issue470Class1'.
  className2 := 'Issue470Class2'.
  className3 := 'Issue470Class3'.
  className4 := 'Issue470Class4'.

  {projectName}
    do: [ :pn |
      (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
        ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
  projectDefinition := (RwProjectDefinition
    newForGitBasedProjectNamed: projectName)
    addPackageNamed: packageName1;
    addPackageNamed: packageName2;
    defaultSymbolDictName: self _symbolDictionaryName1;
    yourself.

  packageDefinition := projectDefinition packageNamed: packageName1.

  classDefinition1 := (RwClassDefinition
    newForClassNamed: className1
      super: 'Object'
      instvars: #(ivar1)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod1 ^1' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod1 ^', className2 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition1.

  classDefinition := (RwClassDefinition
    newForClassNamed: className2
      super: className1
      instvars: #(ivar2)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod2 ^2' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod2 ^', className3 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className3
      super: className2
      instvars: #(ivar4 ivar3)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod3 ^3' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod3 ^', className1 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

"create extension methods"
  packageDefinition := projectDefinition packageNamed: packageName2.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className1)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod1 ^1' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod1 ^1' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className2)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod2 ^2' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod2 ^2' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className3)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod3 ^3' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod3 ^3' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.


"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: (class1 compiledMethodAt: #instanceMethod1) rowanPackageName = packageName1.
  self assert: (class1 class compiledMethodAt: #classMethod1) rowanPackageName = packageName1.
  self assert: (class1 compiledMethodAt: #extensionInstanceMethod1) rowanPackageName = packageName2.
  self assert: (class1 class compiledMethodAt: #extensionClassMethod1) rowanPackageName = packageName2.

  class2 := Rowan globalNamed: className2.
  self assert: class2 instVarNames = #(ivar2).
  self assert: (class2 compiledMethodAt: #instanceMethod2) rowanPackageName = packageName1.
  self assert: (class2 class compiledMethodAt: #classMethod2) rowanPackageName = packageName1.
  self assert: (class2 compiledMethodAt: #extensionInstanceMethod2) rowanPackageName = packageName2.
  self assert: (class2 class compiledMethodAt: #extensionClassMethod2) rowanPackageName = packageName2.
  self assert: class2 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: (class3 compiledMethodAt: #instanceMethod3) rowanPackageName = packageName1.
  self assert: (class3 class compiledMethodAt: #classMethod3) rowanPackageName = packageName1.
  self assert: (class3 compiledMethodAt: #extensionInstanceMethod3) rowanPackageName = packageName2.
  self assert: (class3 class compiledMethodAt: #extensionClassMethod3) rowanPackageName = packageName2.
  self assert: class3 superClass == class2.

"perform rename"
  Rowan projectTools browser
    renameClassNamed: className2 to: className4.

"validate"
  oldClass1 := class1.
  oldClass2 := class2.
  oldClass3 := class3.
 
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: (class1 compiledMethodAt: #instanceMethod1) rowanPackageName = packageName1.
  self assert: (class1 class compiledMethodAt: #classMethod1) rowanPackageName = packageName1.
  self assert: (class1 compiledMethodAt: #extensionInstanceMethod1) rowanPackageName = packageName2.
  self assert: (class1 class compiledMethodAt: #extensionClassMethod1) rowanPackageName = packageName2.
  self assert: oldClass1 == class1.

  class4 := Rowan globalNamed: className4.
  self assert: class4 instVarNames = #(ivar2).
  self assert: (class4 compiledMethodAt: #instanceMethod2) rowanPackageName = packageName1.
  self assert: (class4 class compiledMethodAt: #classMethod2) rowanPackageName = packageName1.
  self assert: (class4 compiledMethodAt: #extensionInstanceMethod2) rowanPackageName = packageName2.
  self assert: (class4 class compiledMethodAt: #extensionClassMethod2) rowanPackageName = packageName2.
  self assert: class4 superClass == class1.
  self assert: oldClass2 ~~ class4. "renamed class"

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: (class3 compiledMethodAt: #instanceMethod3) rowanPackageName = packageName1.
  self assert: (class3 class compiledMethodAt: #classMethod3) rowanPackageName = packageName1.
  self assert: (class3 compiledMethodAt: #extensionInstanceMethod3) rowanPackageName = packageName2.
  self assert: (class3 class compiledMethodAt: #extensionClassMethod3) rowanPackageName = packageName2.
  self assert: class3 superClass == class4.
  self assert: oldClass3 ~~ class3. "subclass of renamed class"
%

category: 'tests'
method: RwBrowserToolApiTest
testRenameClass_3

  "rename a class with a subclass - no references to renamed class in methods"

  "https://github.com/dalehenrich/Rowan/issues/470"

  | projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3
    className4 projectSetDefinition class1 class2 class3 class4 oldClass1 oldClass2 oldClass3 classExtensionDefinition |

  projectName := 'Issue470'.
  packageName1 := 'Issue470-Core'.
  packageName2 := 'Issue470-Extensions'.
  className1 := 'Issue470Class1'.
  className2 := 'Issue470Class2'.
  className3 := 'Issue470Class3'.
  className4 := 'Issue470Class4'.

  {projectName}
    do: [ :pn |
      (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
        ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
  projectDefinition := (RwProjectDefinition
    newForGitBasedProjectNamed: projectName)
    addPackageNamed: packageName1;
    addPackageNamed: packageName2;
    defaultSymbolDictName: self _symbolDictionaryName1;
    yourself.

  packageDefinition := projectDefinition packageNamed: packageName1.

  classDefinition1 := (RwClassDefinition
    newForClassNamed: className1
      super: 'Object'
      instvars: #(ivar1)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod1 ^1' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod1 ^1' protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition1.

  classDefinition := (RwClassDefinition
    newForClassNamed: className2
      super: className1
      instvars: #(ivar2)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod2 ^2' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod2 ^2' protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className3
      super: className2
      instvars: #(ivar4 ivar3)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod3 ^3' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod3 ^3' protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

"create extension methods"
  packageDefinition := projectDefinition packageNamed: packageName2.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className1)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod1 ^1' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod1 ^1' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className2)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod2 ^2' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod2 ^2' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className3)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod3 ^3' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod3 ^3' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.


"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: (class1 compiledMethodAt: #instanceMethod1) rowanPackageName = packageName1.
  self assert: (class1 class compiledMethodAt: #classMethod1) rowanPackageName = packageName1.
  self assert: (class1 compiledMethodAt: #extensionInstanceMethod1) rowanPackageName = packageName2.
  self assert: (class1 class compiledMethodAt: #extensionClassMethod1) rowanPackageName = packageName2.

  class2 := Rowan globalNamed: className2.
  self assert: class2 instVarNames = #(ivar2).
  self assert: (class2 compiledMethodAt: #instanceMethod2) rowanPackageName = packageName1.
  self assert: (class2 class compiledMethodAt: #classMethod2) rowanPackageName = packageName1.
  self assert: (class2 compiledMethodAt: #extensionInstanceMethod2) rowanPackageName = packageName2.
  self assert: (class2 class compiledMethodAt: #extensionClassMethod2) rowanPackageName = packageName2.
  self assert: class2 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: (class3 compiledMethodAt: #instanceMethod3) rowanPackageName = packageName1.
  self assert: (class3 class compiledMethodAt: #classMethod3) rowanPackageName = packageName1.
  self assert: (class3 compiledMethodAt: #extensionInstanceMethod3) rowanPackageName = packageName2.
  self assert: (class3 class compiledMethodAt: #extensionClassMethod3) rowanPackageName = packageName2.
  self assert: class3 superClass == class2.

"perform rename"
  Rowan projectTools browser
    renameClassNamed: className2 to: className4.

"validate"
  oldClass1 := class1.
  oldClass2 := class2.
  oldClass3 := class3.
 
  class1 := Rowan globalNamed: className1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: (class1 compiledMethodAt: #instanceMethod1) rowanPackageName = packageName1.
  self assert: (class1 class compiledMethodAt: #classMethod1) rowanPackageName = packageName1.
  self assert: (class1 compiledMethodAt: #extensionInstanceMethod1) rowanPackageName = packageName2.
  self assert: (class1 class compiledMethodAt: #extensionClassMethod1) rowanPackageName = packageName2.
  self assert: oldClass1 == class1.

  class4 := Rowan globalNamed: className4.
  self assert: class4 instVarNames = #(ivar2).
  self assert: (class4 compiledMethodAt: #instanceMethod2) rowanPackageName = packageName1.
  self assert: (class4 class compiledMethodAt: #classMethod2) rowanPackageName = packageName1.
  self assert: (class4 compiledMethodAt: #extensionInstanceMethod2) rowanPackageName = packageName2.
  self assert: (class4 class compiledMethodAt: #extensionClassMethod2) rowanPackageName = packageName2.
  self assert: class4 superClass == class1.
  self assert: oldClass2 ~~ class4. "renamed class"

  class3 := Rowan globalNamed: className3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: (class3 compiledMethodAt: #instanceMethod3) rowanPackageName = packageName1.
  self assert: (class3 class compiledMethodAt: #classMethod3) rowanPackageName = packageName1.
  self assert: (class3 compiledMethodAt: #extensionInstanceMethod3) rowanPackageName = packageName2.
  self assert: (class3 class compiledMethodAt: #extensionClassMethod3) rowanPackageName = packageName2.
  self assert: class3 superClass == class4.
  self assert: oldClass3 ~~ class3. "subclass of renamed class"
%

category: 'tests'
method: RwBrowserToolApiTest
testRenameClass_4

  "rename a class with a subclass - reference to renamed class in methods subclass references old superclass in method"

  "https://github.com/dalehenrich/Rowan/issues/470"

  | projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3
    className4 projectSetDefinition class1 class2 class3 classExtensionDefinition validateBlock |

  projectName := 'Issue470'.
  packageName1 := 'Issue470-Core'.
  packageName2 := 'Issue470-Extensions'.
  className1 := 'Issue470Class1'.
  className2 := 'Issue470Class2'.
  className3 := 'Issue470Class3'.
  className4 := 'Issue470Class4'.

  {projectName}
    do: [ :pn |
      (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
        ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
  projectDefinition := (RwProjectDefinition
    newForGitBasedProjectNamed: projectName)
    addPackageNamed: packageName1;
    addPackageNamed: packageName2;
    defaultSymbolDictName: self _symbolDictionaryName1;
    yourself.

  packageDefinition := projectDefinition packageNamed: packageName1.

  classDefinition1 := (RwClassDefinition
    newForClassNamed: className1
      super: 'Object'
      instvars: #(ivar1)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod1 ^1' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod1 ^', className2 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition1.

  classDefinition := (RwClassDefinition
    newForClassNamed: className2
      super: className1
      instvars: #(ivar2)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod2 ^2' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod2 ^', className3 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className3
      super: className2
      instvars: #(ivar4 ivar3)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod3 ^3' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod3 ^', className2 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

"create extension methods"
  packageDefinition := projectDefinition packageNamed: packageName2.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className1)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod1 ^1' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod1 ^1' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className2)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod2 ^2' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod2 ^2' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className3)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod3 ^3' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod3 ^', className1 protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.


"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  validateBlock := [:oldClass1 :oldClass2 :oldClass3 |
  class1 := Rowan globalNamed: className1.
  self assert: class1 == oldClass1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: (class1 compiledMethodAt: #instanceMethod1) rowanPackageName = packageName1.
  self assert: (class1 class compiledMethodAt: #classMethod1) rowanPackageName = packageName1.
  self assert: (class1 compiledMethodAt: #extensionInstanceMethod1) rowanPackageName = packageName2.
  self assert: (class1 class compiledMethodAt: #extensionClassMethod1) rowanPackageName = packageName2.

  class2 := Rowan globalNamed: className2.
  self assert: class2 == oldClass2.
  self assert: class2 instVarNames = #(ivar2).
  self assert: (class2 compiledMethodAt: #instanceMethod2) rowanPackageName = packageName1.
  self assert: (class2 class compiledMethodAt: #classMethod2) rowanPackageName = packageName1.
  self assert: (class2 compiledMethodAt: #extensionInstanceMethod2) rowanPackageName = packageName2.
  self assert: (class2 class compiledMethodAt: #extensionClassMethod2) rowanPackageName = packageName2.
  self assert: class2 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 == oldClass3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: (class3 compiledMethodAt: #instanceMethod3) rowanPackageName = packageName1.
  self assert: (class3 class compiledMethodAt: #classMethod3) rowanPackageName = packageName1.
  self assert: (class3 compiledMethodAt: #extensionInstanceMethod3) rowanPackageName = packageName2.
  self assert: (class3 class compiledMethodAt: #extensionClassMethod3) rowanPackageName = packageName2.
  self assert: class3 superClass == class2 ].

   validateBlock value: (Rowan globalNamed: className1) value: (Rowan globalNamed: className2) value: (Rowan globalNamed: className3).

"perform rename --- expect to fail with compile error at the moment"
	self should: [
		Rowan projectTools browser
			renameClassNamed: className2 to: className4 ]
		raise: CompileError.

"validate"
  validateBlock value: class1 value: class2 value: class3.
%

category: 'tests'
method: RwBrowserToolApiTest
testRenameClass_5

  "rename a class with a subclass - reference to renamed class in methods subclass references old superclass in extension method"

  "https://github.com/dalehenrich/Rowan/issues/470"

  | projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3
    className4 projectSetDefinition class1 class2 class3 validateBlock classExtensionDefinition |

  projectName := 'Issue470'.
  packageName1 := 'Issue470-Core'.
  packageName2 := 'Issue470-Extensions'.
  className1 := 'Issue470Class1'.
  className2 := 'Issue470Class2'.
  className3 := 'Issue470Class3'.
  className4 := 'Issue470Class4'.

  {projectName}
    do: [ :pn |
      (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
        ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
  projectDefinition := (RwProjectDefinition
    newForGitBasedProjectNamed: projectName)
    addPackageNamed: packageName1;
    addPackageNamed: packageName2;
    defaultSymbolDictName: self _symbolDictionaryName1;
    yourself.

  packageDefinition := projectDefinition packageNamed: packageName1.

  classDefinition1 := (RwClassDefinition
    newForClassNamed: className1
      super: 'Object'
      instvars: #(ivar1)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod1 ^1' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod1 ^', className2 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition1.

  classDefinition := (RwClassDefinition
    newForClassNamed: className2
      super: className1
      instvars: #(ivar2)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod2 ^2' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod2 ^', className3 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className3
      super: className2
      instvars: #(ivar4 ivar3)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod3 ^3' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod3 ^', className1 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

"create extension methods"
  packageDefinition := projectDefinition packageNamed: packageName2.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className1)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod1 ^1' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod1 ^1' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className2)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod2 ^2' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod2 ^2' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className3)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod3 ^3' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod3 ^', className2 protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.


"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
  validateBlock := [:oldClass1 :oldClass2 :oldClass3 |
  class1 := Rowan globalNamed: className1.
  self assert: class1 == oldClass1.
  self assert: class1 instVarNames = #(ivar1).
  self assert: (class1 compiledMethodAt: #instanceMethod1) rowanPackageName = packageName1.
  self assert: (class1 class compiledMethodAt: #classMethod1) rowanPackageName = packageName1.
  self assert: (class1 compiledMethodAt: #extensionInstanceMethod1) rowanPackageName = packageName2.
  self assert: (class1 class compiledMethodAt: #extensionClassMethod1) rowanPackageName = packageName2.

  class2 := Rowan globalNamed: className2.
  self assert: class2 == oldClass2.
  self assert: class2 instVarNames = #(ivar2).
  self assert: (class2 compiledMethodAt: #instanceMethod2) rowanPackageName = packageName1.
  self assert: (class2 class compiledMethodAt: #classMethod2) rowanPackageName = packageName1.
  self assert: (class2 compiledMethodAt: #extensionInstanceMethod2) rowanPackageName = packageName2.
  self assert: (class2 class compiledMethodAt: #extensionClassMethod2) rowanPackageName = packageName2.
  self assert: class2 superClass == class1.

  class3 := Rowan globalNamed: className3.
  self assert: class3 == oldClass3.
  self assert: class3 instVarNames = #(ivar4 ivar3).
  self assert: (class3 compiledMethodAt: #instanceMethod3) rowanPackageName = packageName1.
  self assert: (class3 class compiledMethodAt: #classMethod3) rowanPackageName = packageName1.
  self assert: (class3 compiledMethodAt: #extensionInstanceMethod3) rowanPackageName = packageName2.
  self assert: (class3 class compiledMethodAt: #extensionClassMethod3) rowanPackageName = packageName2.
  self assert: class3 superClass == class2 ].

   validateBlock value: (Rowan globalNamed: className1) value: (Rowan globalNamed: className2) value: (Rowan globalNamed: className3).

"perform rename"
	self should: [ 
		Rowan projectTools browser
			renameClassNamed: className2 to: className4]
		raise: CompileError.

"validate"
   validateBlock value: class1 value: class2 value: class3.
%

category: 'tests'
method: RwBrowserToolApiTest
testRenameClass_Issue_490

  "rename a class with no subclasses"

  "https://github.com/dalehenrich/Rowan/issues/490"

  | projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition 
		packageDefinition className1 className2 className3 className4 projectSetDefinition
		class1 class2 class3 oldClass1 oldClass2 oldClass3 classExtensionDefinition audit symDict 
		registry extraMethods methodRegistry seenMethodsMap |

  projectName := 'Issue470'.
  packageName1 := 'Issue490-Core'.
  packageName2 := 'Issue490-Extensions'.
  className1 := 'Issue490Class1'.
  className2 := 'Issue490Class2'.
  className3 := 'Issue490Class3'.
  className4 := 'Issue490Class4'.

  {projectName}
    do: [ :pn |
      (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
        ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
  projectDefinition := (RwProjectDefinition
    newForGitBasedProjectNamed: projectName)
    addPackageNamed: packageName1;
    addPackageNamed: packageName2;
    defaultSymbolDictName: self _symbolDictionaryName1;
    yourself.

  packageDefinition := projectDefinition packageNamed: packageName1.

  classDefinition1 := (RwClassDefinition
    newForClassNamed: className1
      super: 'Object'
      instvars: #(ivar1)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod1 ^1' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod1 ^', className2 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition1.

  classDefinition := (RwClassDefinition
    newForClassNamed: className2
      super: className1
      instvars: #(ivar2)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod2 ^2' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod2 ^', className3 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className3
      super: className2
      instvars: #(ivar4 ivar3)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod3 ^3' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod3 ^', className1 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

"create extension methods"
  packageDefinition := projectDefinition packageNamed: packageName2.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className1)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod1 ^1' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod1 ^1' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className2)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod2 ^2' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod2 ^2' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className3)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod3 ^3' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod3 ^3' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

  class1 := Rowan globalNamed: className1.
  class2 := Rowan globalNamed: className2.
  class3 := Rowan globalNamed: className3.

"perform rename"
  Rowan projectTools browser
    renameClassNamed: className2 to: className4.

  self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
true ifTrue: [ ^self ].	"early exit for now"

"validate"
  oldClass1 := class1.
  oldClass2 := class2.
  oldClass3 := class3.
 
  class1 := Rowan globalNamed: className1.
  self assert: oldClass1 == class1.

  class2 := Rowan globalNamed: className4.
  self assert: class2 superClass == class1.
  self assert: oldClass2 ~~ class2. "renamed class"

  class3 := Rowan globalNamed: className3.
  self assert: class3 superClass == class2.
  self assert: oldClass3 ~~ class3. "new version, since superclass renamed"

"audit"
  symDict := Rowan globalNamed: self _symbolDictionaryName1.
  self assert: (symDict at: className4 asSymbol) == class2.
  registry := symDict at: #RwSymbolDictionaryRegistry.
  methodRegistry := registry methodRegistry.
  seenMethodsMap := Dictionary new.
  methodRegistry keysAndValuesDo: [:method :loadedMethod |
    ((seenMethodsMap at: method inClass name ifAbsentPut: [ Dictionary new])
		at: method selector ifAbsentPut: [ {} ]) add: method ].
  extraMethods := Dictionary new.
  seenMethodsMap keysAndValuesDo: [:className :selectorMap |
    selectorMap keysAndValuesDo: [:selector :ar |
      ar size > 1 
        ifTrue: [
          (extraMethods at: className ifAbsentPut: [ Dictionary new ])
            at: selector put: ar ] ] ].
  true ifTrue: [ self assert: extraMethods size = 0 ].
 false ifTrue: [ "repair"
  extraMethods keysAndValuesDo: [:className :selectorMap |
    selectorMap keysAndValuesDo: [:selector :ar |
      ar do: [:method |
        | theClass x|
        theClass := method inClass.
         theClass :=theClass isMeta
           ifTrue: [ (Rowan globalNamed: theClass theNonMetaClass name) class ]
           ifFalse: [ Rowan globalNamed: theClass name ].
        (x := theClass compiledMethodAt: selector) == method
          ifFalse: [ methodRegistry removeKey: method ] ] ] ].

  seenMethodsMap := Dictionary new.
  methodRegistry keysAndValuesDo: [:method :loadedMethod |
    ((seenMethodsMap at: method inClass name ifAbsentPut: [ Dictionary new])
		at: method selector ifAbsentPut: [ {} ]) add: method ].
  extraMethods := Dictionary new.
  seenMethodsMap keysAndValuesDo: [:className :selectorMap |
    selectorMap keysAndValuesDo: [:selector :ar |
      ar size > 1 
        ifTrue: [
          (extraMethods at: className ifAbsentPut: [ Dictionary new ])
            at: selector put: ar ] ] ].
  true ifTrue: [ self assert: extraMethods size = 0 ] ].
%

category: 'private'
method: RwBrowserToolApiTest
_expectedAssociationCreationTemplate

	^ 'Object subclass: ''Association''
	instVarNames: #( key value)
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #()
'
%

category: 'private'
method: RwBrowserToolApiTest
_expectedClassCreationTemplate

	^ 'Object rwSubclass: ''NameOfSubclass''
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: ''MyClasses''
	packageName: ''MyPackage''
	options: #()
'
%

category: 'private'
method: RwBrowserToolApiTest
_expectedCollectionCreationTemplate

	^ 'Object indexableSubclass: ''Collection''
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #()
'
%

category: 'private'
method: RwBrowserToolApiTest
_expectedHybridByteArrayCreationTemplate

	^ 'SequenceableCollection byteSubclass: ''ByteArray''
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #()
'
%

category: 'private'
method: RwBrowserToolApiTest
_expectedHybridClassCreationTemplate

	^ 'Object rwSubclass: ''NameOfSubclass''
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: ''MyClasses''
	options: #()
'
%

! Class implementation for 'RwDisownToolApiTest'

!		Instance methods for 'RwDisownToolApiTest'

category: 'tests'
method: RwDisownToolApiTest
testDisownClass1

	"disown a class with a method"

	| packageTools projectName packageNames className packageName theClass fooMethod |
	packageTools := Rowan packageTools.
	projectName := 'DisProject'.
	packageName := 'Disown-Core'.
	packageNames := {packageName}.
	className := 'DisownedClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing package disown api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().
	self assert: theClass rowanPackageName = packageName.

	fooMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName asLowercase.

	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: theClass rowanPackageName = packageName.
	self assert: fooMethod rowanPackageName = packageName.

	packageTools disown
		disownClassNamed: className.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: theClass rowanPackageName = Rowan unpackagedName.
	self assert: fooMethod rowanPackageName = Rowan unpackagedName.

	packageTools adopt
		adoptClassNamed: className  intoPackageNamed: packageName.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: theClass rowanPackageName = packageName.
	self assert: fooMethod rowanPackageName = packageName.
%

category: 'tests'
method: RwDisownToolApiTest
testDisownClass2

	"disown a class with a method and an extenstion method"

	| packageTools projectName packageNames className packageName1 packageName2 barMethod fooMethod theClass x |
	packageTools := Rowan packageTools.
	projectName := 'Disown Browser'.
	packageName1 := 'Disown-Core'.
	packageName2 := 'Disown-Extensions1'.
	packageNames := {packageName1.
	packageName2}.
	className := 'DisownedClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing package disown api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: theClass rowanPackageName = packageName1.

	fooMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName1 asLowercase.
	barMethod := theClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.

	packageTools disown
		disownClassNamed: className.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = Rowan unpackagedName.
	self assert: fooMethod rowanPackageName = Rowan unpackagedName.
	self assert: (x := barMethod rowanPackageName) = packageName2.

	packageTools adopt
		adoptClassNamed: className  intoPackageNamed: packageName1.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.
%

category: 'tests'
method: RwDisownToolApiTest
testDisownExtensionMethods

	"disown extension methods in a class"

	| packageTools projectName packageNames className packageName1 packageName2 barMethod fooMethod theClass x  y |
	packageTools := Rowan packageTools.
	projectName := 'Disown Browser'.
	packageName1 := 'Disown-Core'.
	packageName2 := 'Disown-Extensions1'.
	packageNames := {packageName1.
	packageName2}.
	className := 'DisownedClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing package disown api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: theClass rowanPackageName = packageName1.

	fooMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName1 asLowercase.
	barMethod := theClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: (x := (Rowan image loadedPackageNamed: packageName2) loadedClassExtensions size) = 1. 
	self assert: (x := (Rowan image loadedClassExtensionsForClass: theClass) size) = 1.

	packageTools disown
		disownClassExtensionMethodsInClassNamed: className forPackageNamed: packageName2.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = Rowan unpackagedName.
	self assert: (x := (Rowan image loadedPackageNamed: packageName2) loadedClassExtensions size) = 0. 
	self assert: (x := (y := Rowan image loadedClassExtensionsForClass: theClass) size) = 0.

	packageTools adopt
		adoptClassExtensionNamed: className  instanceSelectors: #( #bar) classSelectors: #() intoPackageNamed: packageName2.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: (x := (Rowan image loadedPackageNamed: packageName2) loadedClassExtensions size) = 1. 
	self assert: (x := (y := Rowan image loadedClassExtensionsForClass: theClass) size) = 1.
%

category: 'tests'
method: RwDisownToolApiTest
testDisownMethod
	| packageTools projectName packageNames className packageName theClass fooMethod package |
	packageTools := Rowan packageTools.
	projectName := 'DisProject'.
	packageName := 'Disown-Core'.
	packageNames := {packageName}.
	className := 'DisownedClass'.
	package := RwPackage newNamed: packageName.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing package disown api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().
	self assert: theClass rowanPackageName = packageName.

	fooMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName asLowercase.

	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: theClass rowanPackageName = packageName.
	self assert: fooMethod rowanPackageName = packageName.

	packageTools disown
		disownMethod: #foo inClassNamed: className isMeta: false.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: theClass rowanPackageName = packageName.
	self assert: fooMethod rowanPackageName = Rowan unpackagedName.


	packageTools adopt
		adoptMethod: #foo inClassNamed: className isMeta: false  intoPackageNamed: packageName.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: fooMethod rowanPackageName = packageName.
%

category: 'tests'
method: RwDisownToolApiTest
testDisownPackage1

	| packageTools projectName packageNames className packageName1 packageName2 barMethod fooMethod theClass x |
	packageTools := Rowan packageTools.
	projectName := 'Disown Browser'.
	packageName1 := 'Disown-Core'.
	packageName2 := 'Disown-Extensions1'.
	packageNames := {packageName1.
	packageName2}.
	className := 'DisownedClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing package disown api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: theClass rowanPackageName = packageName1.

	fooMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName1 asLowercase.
	barMethod := theClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: (Rowan image loadedPackageNamed: packageName1 ifAbsent: []) notNil.

	packageTools disown
		disownPackageNamed: packageName1.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = Rowan unpackagedName.
	self assert: fooMethod rowanPackageName = Rowan unpackagedName.
	self assert: (x := barMethod rowanPackageName) = packageName2.
	self assert: (Rowan image loadedPackageNamed: packageName1 ifAbsent: []) isNil.

	Rowan projectTools browser
		addPackageNamed: packageName1 toProjectNamed: projectName.
	packageTools adopt
		adoptClassNamed: className  intoPackageNamed: packageName1.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: (Rowan image loadedPackageNamed: packageName1 ifAbsent: []) notNil.
%

category: 'tests'
method: RwDisownToolApiTest
testDisownPackage2

	| packageTools projectName packageNames className packageName1 packageName2 barMethod fooMethod theClass x |
	packageTools := Rowan packageTools.
	projectName := 'Disown Browser'.
	packageName1 := 'Disown-Core'.
	packageName2 := 'Disown-Extensions1'.
	packageNames := {packageName1.
	packageName2}.
	className := 'DisownedClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing package disown api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: theClass rowanPackageName = packageName1.

	fooMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName1 asLowercase.
	barMethod := theClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: (Rowan image loadedPackageNamed: packageName2 ifAbsent: []) notNil.
	self assert: (x := (Rowan image loadedClassExtensionsForClass: theClass) size) = 1.

	packageTools disown
		disownPackageNamed: packageName2.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = Rowan unpackagedName.
	self assert: (Rowan image loadedPackageNamed: packageName2 ifAbsent: []) isNil.
	self assert: (x := (Rowan image loadedClassExtensionsForClass: theClass) size) = 0.

	Rowan projectTools browser
		addPackageNamed: packageName2 toProjectNamed: projectName.
	packageTools adopt
		adoptClassExtensionNamed: className  instanceSelectors: #( #bar) classSelectors: #() intoPackageNamed: packageName2.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: (Rowan image loadedPackageNamed: packageName2 ifAbsent: []) notNil.
%

category: 'tests'
method: RwDisownToolApiTest
testDisownPackage3

	| packageTools projectName packageNames className packageName1 packageName2 packageName3 barMethod fooMethod theClass x y |
	packageTools := Rowan packageTools.
	projectName := 'Disown Browser'.
	packageName1 := 'Disown-Core'.
	packageName2 := 'Disown-Extensions1'.
	packageName3 := 'Disown-Extensions2'.
	packageNames := {packageName1 . packageName2 . packageName3}.
	className := 'DisownedClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing package disown api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: theClass rowanPackageName = packageName1.

	fooMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName3 asLowercase.
	barMethod := theClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName3.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: (Rowan image loadedPackageNamed: packageName2 ifAbsent: []) notNil.
	self assert: (Rowan image loadedPackageNamed: packageName3 ifAbsent: []) notNil.
	self assert: (x := (y := Rowan image loadedClassExtensionsForClass: theClass) size) = 2.

	packageTools disown
		disownPackageNamed: packageName2.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName3.
	self assert: barMethod rowanPackageName = Rowan unpackagedName.
	self assert: (Rowan image loadedPackageNamed: packageName2 ifAbsent: []) isNil.
	self assert: (Rowan image loadedPackageNamed: packageName3 ifAbsent: []) notNil.
	self assert: (x := (y := Rowan image loadedClassExtensionsForClass: theClass) size) = 1.

	Rowan projectTools browser
		addPackageNamed: packageName2 toProjectNamed: projectName.
	packageTools adopt
		adoptClassExtensionNamed: className  instanceSelectors: #( #bar) classSelectors: #() intoPackageNamed: packageName2.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName3.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: (Rowan image loadedPackageNamed: packageName2 ifAbsent: []) notNil.
	self assert: (Rowan image loadedPackageNamed: packageName3 ifAbsent: []) notNil.
	self assert: (x := (Rowan image loadedClassExtensionsForClass: theClass) size) = 2.
%

category: 'tests'
method: RwDisownToolApiTest
testDisownProject

	| projectTools projectName packageNames className packageName1 packageName2 barMethod fooMethod 
		theClass x projectDefinitionToLoad projectDefinitionToAdopt |

	projectTools := Rowan projectTools.
	projectName := 'Disown Browser'.
	packageName1 := 'Disown-Core'.
	packageName2 := 'Disown-Extensions1'.
	packageNames := {packageName1.
	packageName2}.
	className := 'DisownedClass'.

	projectDefinitionToLoad := self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing package disown api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: theClass rowanPackageName = packageName1.

	fooMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName1 asLowercase.
	barMethod := theClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar)= 'bar'.
	self assert: theClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: (Rowan image loadedPackageNamed: packageName1 ifAbsent: []) notNil.
	self assert: (Rowan image loadedProjectNamed: projectName ifAbsent: []) notNil.

	projectDefinitionToAdopt := (Rowan image loadedProjectNamed: projectName) asDefinition.
	self assert: (projectDefinitionToAdopt projectDefinitionSourceProperty = RwLoadedProject _projectLoadedDefinitionSourceValue).

	projectTools disown
		disownProjectNamed: projectName.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: (x := theClass rowanPackageName) = Rowan unpackagedName.
	self assert: fooMethod rowanPackageName = Rowan unpackagedName.
	self assert: (x := barMethod rowanPackageName) = Rowan unpackagedName.
	self assert: (Rowan image loadedPackageNamed: packageName1 ifAbsent: []) isNil.
	self assert: (Rowan image loadedProjectNamed: projectName ifAbsent: []) isNil.

	"reload original project definition --- project and packages only"
	projectTools load loadProjectDefinition: projectDefinitionToLoad.

	"adopt the complete project definition --- includes class, methods and extension methods"
	projectTools adopt
		adoptProjectDefinition: projectDefinitionToAdopt.

	theClass := Rowan globalNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
	self assert: (theClass new perform: #bar) = 'bar'.
	self assert: (x := theClass rowanPackageName) = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: (Rowan image loadedPackageNamed: packageName1 ifAbsent: []) notNil.
	self assert: (Rowan image loadedProjectNamed: projectName ifAbsent: []) notNil.
%

! Class implementation for 'RwHybridBrowserToolTest'

!		Instance methods for 'RwHybridBrowserToolTest'

category: 'tests'
method: RwHybridBrowserToolTest
testHybridClassComment

	| normalClass projectName packageNames packageName comment |
	projectName := 'Hybrid Project A'.
	packageName := 'HybridA-Core'.
	packageNames := {packageName}.
	comment := 'a comment'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().
	self assert: normalClass rowanPackageName = packageName.

	normalClass rwComment: comment.
	self assert: normalClass comment = comment
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridClassCopy

	|  normalClass projectName packageNames packageName1 packageName2 comment newClassName newClass className |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	comment := 'a comment'.
	className :=  'SimpleHybridNormal1'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(foo)
		classVars: #(Bar)
		classInstVars: #(baz)
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	normalClass
		rwCompileMethod: 'foo ^foo'
		category: '*' , packageName2 asLowercase.
	normalClass class
		rwCompileMethod: 'bar ^Bar'
		category: 'accessing'.
	normalClass class
		rwCompileMethod: 'baz ^baz'
		category: 'accessing'.
	normalClass rwComment: comment.

	self assert: (normalClass new perform: #foo) isNil.
	self assert: (normalClass  perform: #bar) isNil.
	self assert: (normalClass  perform: #baz) isNil.
	self assert: normalClass comment = comment.

	newClassName := 'SimpleHybridNormal1Copy'.
	newClass := Rowan projectTools browser copyClassNamed: className to: newClassName.

	self assert: (newClass new  perform: #foo) isNil.
	self assert: (newClass  perform: #bar) isNil.
	self assert: (newClass  perform: #baz) isNil.
	self assert: newClass comment = comment.

	self assert: (Rowan globalNamed: className) == normalClass
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridClassCreation

	| byteClass indexableClass normalClass projectName packageNames packageName1 packageName2 |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	byteClass := Object
		rwByteSubclass: 'SimpleHybridByte1'
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: byteClass rowanPackageName = packageName1.

	indexableClass := Object
		rwIndexableSubclass: 'SimpleHybridIndexable1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: indexableClass rowanPackageName = packageName1.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridClassCreationWithClassCreationTemplateA

	"https://github.com/dalehenrich/Rowan/issues/17"

	"make sure that we actually evaluate the class creation templates"

	| category normalClass projectName packageNames packageName1 packageName2 browserTool template |
	category := 'Category'.
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	browserTool := Rowan projectTools browser.

	template := browserTool
		classCreationTemplateForSubclassOf: 'Object'
		className: 'SimpleHybridNormal1'
		category: packageName1.
	normalClass := template evaluate.
	self assert: normalClass rowanPackageName = packageName1.
	self assert: normalClass category = packageName1.

	template := browserTool
		classCreationTemplateForSubclassOf: 'Object'
		className: 'SimpleHybridNormal1'
		category: category
		packageName: packageName1.
	normalClass := template evaluate.
	self assert: normalClass rowanPackageName = packageName1.
	self assert: normalClass category = category.

	template := browserTool
		classCreationTemplateForClass: normalClass
		hybridBrowser: false.
	normalClass := template evaluate.
	self assert: normalClass rowanPackageName = packageName1.
	self assert: normalClass category = category.

	template := browserTool
		classCreationTemplateForClass: normalClass
		hybridBrowser: true.	" packageName does not equal category, so hyrbridBrowser form cannot be used"
	normalClass := template evaluate.
	self assert: normalClass rowanPackageName = packageName1.
	self assert: normalClass category = category.

	normalClass category: packageName1.	"now we can use hybridBrowser form again"
	template := browserTool
		classCreationTemplateForClass: normalClass
		hybridBrowser: true.
	normalClass := template evaluate.
	self assert: normalClass rowanPackageName = packageName1.
	self assert: normalClass category = packageName1
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridClassCreationWithClassCreationTemplateB

	"https://github.com/dalehenrich/Rowan/issues/17"

	"make sure that we actually evaluate the class creation templates"

	| category byteClass variableClass projectName packageNames packageName1 packageName2 browserTool template |
	category := 'Category'.
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	browserTool := Rowan projectTools browser.

	template := browserTool
		classCreationTemplateForSubclassOf: 'Object'
		className: 'SimpleHybridByte1'
		type: 'byteSubclass'
		category: packageName1
		packageName: nil.
	byteClass := template evaluate.
	self assert: byteClass rowanPackageName = packageName1.
	self assert: byteClass category = packageName1.

	template := browserTool
		classCreationTemplateForSubclassOf: 'Object'
		className: 'SimpleHybridIndexable1'
		type: 'variable'
		category: category
		packageName: packageName1.
	variableClass := template evaluate.
	self assert: variableClass rowanPackageName = packageName1.
	self assert: variableClass category = category
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridClassRename

	|  normalClass projectName packageNames packageName1 packageName2 comment newClassName newClass className |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	comment := 'a comment'.
	className :=  'SimpleHybridNormal1'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(foo)
		classVars: #(Bar)
		classInstVars: #(baz)
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	normalClass
		rwCompileMethod: 'foo ^foo'
		category: '*' , packageName1 asLowercase.
	normalClass class
		rwCompileMethod: 'bar ^Bar'
		category: 'accessing'.
	normalClass class
		rwCompileMethod: 'baz ^baz'
		category: 'accessing'.
	normalClass rwComment: comment.

	self assert: (normalClass new perform: #foo) isNil.
	self assert: (normalClass perform: #bar) isNil.
	self assert: (normalClass perform: #baz) isNil.
	self assert: normalClass comment = comment.

	newClassName := 'SimpleHybridNormal1Copy'.
	newClass := Rowan projectTools browser renameClassNamed: className to: newClassName.

	self assert: (newClass new perform: #foo) isNil.
	self assert: (newClass perform: #bar) isNil.
	self assert: (newClass perform: #baz) isNil.
	self assert: newClass comment = comment.

	self assert: (Rowan globalNamed: className) isNil
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridCompileMethod

	| normalClass projectName packageNames packageName1 packageName2 fooMethod barMethod normalInstance |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	fooMethod := normalClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName1 asLowercase.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'
		packageName: packageName2.

	self assert: (normalClass perform: #bar) = 'bar'.
	normalInstance := normalClass new.
	self assert: (normalInstance perform: #foo) = 'foo'.

	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridCompileMethodMoveToProtocol

	| normalClass projectName packageNames packageName1 packageName2 fooMethod barMethod normalInstance x |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	fooMethod := normalClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName1 asLowercase.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'.

	self assert: (normalClass perform: #bar) = 'bar'.
	normalInstance := normalClass new.
	self assert: (normalInstance perform: #foo) = 'foo'.
	self
		assert:
			(x := normalClass class categoryOfSelector: #'bar') asString = 'accessing'.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName1.

	barMethod := normalClass class
		rwCompileMethod: 'bar "" ^''bar'''
		category: 'new category'.

	self assert: (normalClass perform: #bar) = 'bar'.
	self
		assert:
			(x := normalClass class categoryOfSelector: #'bar') asString = 'new category'.
	self assert: barMethod rowanPackageName = packageName1
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridCompileMethodRemove

	| normalClass projectName packageNames packageName1 packageName2 fooMethod barMethod normalInstance |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	normalClass := Object
		rwSubclass: 'SimpleHybridNormal3'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	fooMethod := normalClass rwCompileMethod: 'foo ^''foo''' category: 'accessing'.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

	self assert: (normalClass perform: #bar) = 'bar'.
	normalInstance := normalClass new.
	self assert: (normalInstance perform: #foo) = 'foo'.

	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.

	normalClass rwRemoveSelector: #'foo'.
	normalClass class rwRemoveSelector: #'bar'.

	self should: [ normalClass perform: #bar ] raise: MessageNotUnderstood.
	self should: [ normalInstance perform: #foo ] raise: MessageNotUnderstood.

	fooMethod := normalClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName2 asLowercase.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'.

	self assert: fooMethod rowanPackageName = packageName2.
	self assert: barMethod rowanPackageName = packageName1.

	self assert: (normalClass perform: #bar) = 'bar'.
	self assert: (normalInstance perform: #foo) = 'foo'.

	normalClass rwRemoveSelector: #'foo'.
	normalClass class rwRemoveSelector: #'bar'.

	self should: [ normalClass perform: #bar ] raise: MessageNotUnderstood.
	self should: [ normalInstance perform: #foo ] raise: MessageNotUnderstood
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridCompileMethodRemove_315

	"https://github.com/dalehenrich/Rowan/issues/315"

	| normalClass projectName packageNames packageName1 packageName2 fooMethod barMethod normalInstance
		symDict registry |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	normalClass := Object
		rwSubclass: 'SimpleHybridNormal3'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

"add methods"
	fooMethod := normalClass rwCompileMethod: 'foo ^''foo''' category: 'accessing'.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

"validate"
	self assert: (normalClass perform: #bar) = 'bar'.
	normalInstance := normalClass new.
	self assert: (normalInstance perform: #foo) = 'foo'.

	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName2.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 2.

"remove methods"
	normalClass rwRemoveSelector: #'foo'.
	normalClass class rwRemoveSelector: #'bar'.

"validate"
	self should: [ normalClass perform: #bar ] raise: MessageNotUnderstood.
	self should: [ normalInstance perform: #foo ] raise: MessageNotUnderstood.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

"re-add methods"
	fooMethod := normalClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName2 asLowercase.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'.

"validate"
	self assert: fooMethod rowanPackageName = packageName2.
	self assert: barMethod rowanPackageName = packageName1.

	self assert: (normalClass perform: #bar) = 'bar'.
	self assert: (normalInstance perform: #foo) = 'foo'.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 2.

"remove methods"
	normalClass rwRemoveSelector: #'foo'.
	normalClass class rwRemoveSelector: #'bar'.

"validate"
	self should: [ normalClass perform: #bar ] raise: MessageNotUnderstood.
	self should: [ normalInstance perform: #foo ] raise: MessageNotUnderstood.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridComplicatedClassCopy

	| projectNames projectName1 projectName2 packageNames project1PackageName1 project1PackageName2 project2PackageName1
		project2PackageName2 className1 className2 classNames classPackageNames1 classPackageNames2 classPackageNames 
		defaultSymbolDictNames comments newClassName testClass meth newClass |

	projectName1 := 'HybridClassCopy1'.
	projectName2 := 'HybridClassCopy2'.
	projectNames := {projectName1.
	projectName2}.
	project1PackageName1 := 'ClassCopy1-Core'.
	project1PackageName2 := 'ClassCopy12-Extensions'.
	project2PackageName1 := 'ClassCopy2-Core'.
	project2PackageName2 := 'ClassCopy2-Extensions'.
	packageNames := {{project1PackageName1.
	project1PackageName2}.
	{project2PackageName1.
	project2PackageName2}}.
	className1 := 'HybridCopyClass1'.
	className2 := 'HybridCopyClass2'.
	newClassName := 'HybridCopyClass1Copy'.
	classNames := {className1.
	className2}.
	classPackageNames1 := 'ClassCopy1-Core'.
	classPackageNames2 := 'ClassCopy2-Core'.
	classPackageNames := {classPackageNames1.
	classPackageNames2}.
	defaultSymbolDictNames := {(self _symbolDictionaryName1).
	(self _symbolDictionaryName1)}.
	comments := {'new class version project 1'.
	'new class version project2'}.
	self
		_loadMultiProjectDefinition: projectNames
		packageNames: packageNames
		defaultSymbolDictName: defaultSymbolDictNames
		comment: comments
		className: classNames
		inPackageName: classPackageNames.

	testClass := Rowan globalNamed: className1.

	meth := testClass
		rwCompileMethod: 'foo ^1'
		category: '*' , project1PackageName2 asLowercase.
	self assert: meth rowanPackageName = project1PackageName2. 
	meth := testClass class
		rwCompileMethod: 'fooClass ^1'
		category: '*' , project1PackageName2 asLowercase.
	self assert: meth rowanPackageName = project1PackageName2. 
	meth := testClass
		rwCompileMethod: 'bar ^1'
		category: '*' , project2PackageName2 asLowercase.
	self assert: meth rowanPackageName = project2PackageName2. 
	meth := testClass class
		rwCompileMethod: 'barClass ^1'
		category: '*' , project2PackageName2 asLowercase.
	self assert: meth rowanPackageName = project2PackageName2. 

	self assert: testClass notNil.
	self assert: (testClass perform: #cvar1) = 2.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #fooClass) = 1.
	self assert: (testClass perform: #barClass) = 1.

	self assert: (testClass new perform: #ivar1) isNil.
	self assert: (testClass new perform: #foo) = 1.
	self assert: (testClass new perform: #bar) = 1.

	self assert: (testClass categoryOfSelector: #foo) = ( '*' , project1PackageName2 asLowercase) asSymbol.
	self assert: (testClass class categoryOfSelector: #fooClass) = ( '*' , project1PackageName2 asLowercase) asSymbol.
	self assert: (testClass categoryOfSelector: #bar) = ( '*' , project2PackageName2 asLowercase) asSymbol.
	self assert: (testClass class categoryOfSelector: #barClass) = ( '*' , project2PackageName2 asLowercase) asSymbol.

	newClass := Rowan projectTools browser copyClassNamed: className1 to: newClassName.
	newClass initialize.

	self assert: newClass == (Rowan globalNamed: newClassName).

	self assert: newClass ~~ testClass.
	self assert: (newClass perform: #cvar1) = 2.
	self assert: (newClass perform: #civar1) = 1.
	self assert: (newClass perform: #fooClass) = 1.
	self assert: (newClass perform: #barClass) = 1.

	self assert: (newClass new perform: #ivar1) isNil.
	self assert: (newClass new perform: #foo) = 1.
	self assert: (newClass new perform: #bar) = 1.

	self assert: (newClass categoryOfSelector: #foo) = ( '*' , project1PackageName2 asLowercase) asSymbol.
	self assert: (newClass class categoryOfSelector: #fooClass) = ( '*' , project1PackageName2 asLowercase) asSymbol.
	self assert: (newClass categoryOfSelector: #bar) = ( '*' , project2PackageName2 asLowercase) asSymbol.
	self assert: (newClass class categoryOfSelector: #barClass) = ( '*' , project2PackageName2 asLowercase) asSymbol.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridDeletePackage

	"add 2 classes in 2 packages, extend each class from the other package ... remove the package"

	| normalClass projectName packageNames packageName1 packageName2 otherClass className1 className2 theLoadedProject theLoadedPackage theLoadedClassOrClassExtension classNames |
	className1 := 'SimpleHybridNormal1'.
	className2 := 'SimpleHybridOther1'.
	classNames := {className1.
	className2}.
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: className1
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	normalClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName2 asLowercase.
	self assert: (normalClass new perform: #foo) = 'foo'.

	otherClass := Object
		rwSubclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().
	self assert: otherClass rowanPackageName = packageName2.

	otherClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName1 asLowercase.
	self assert: (otherClass new perform: #foo) = 'foo'.

	Rowan projectTools browser removePackageNamed: packageName1.

	self assert: (Rowan globalNamed: className1) isNil.
	self assert: (Rowan globalNamed: className2) == otherClass.
	self should: [ otherClass new perform: #foo ] raise: MessageNotUnderstood.

	theLoadedProject := Rowan image loadedProjectNamed: projectName.	"Traverse the loaded thing structure and verify that it matches the expected structure"

	theLoadedProject
		loadedPackagesDo: [ :loadedProject :loadedPackage | 
			self assert: theLoadedProject == loadedProject.
			theLoadedPackage := loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			self assert: (packageNames includes: loadedPackage name) ]
		loadedClassedDo: [ :loadedProject :loadedPackage :loadedClass | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			theLoadedClassOrClassExtension := loadedClass.

			loadedPackage name = packageName1
				ifTrue: [ 
					self
						assert: false
						description:
							'unexpected class ' , loadedClass name , ' in package ' , loadedPackage name ]
				ifFalse: [ 
					loadedPackage name = packageName2
						ifTrue: [ self assert: loadedClass name = className2 ]
						ifFalse: [ self assert: false description: 'unexpected package ' , loadedPackage name ] ] ]
		loadedClassExtensionsDo: [ :loadedProject :loadedPackage :loadedClassExtension | 
			self assert: false description: 'no class extensions expected in package '.
			loadedPackage name ]
		loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
			self assert: false description: 'no instance methods expected in class'.
			loadedClassOrClassExtension name ]
		loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
			self assert: false description: 'no class methods expected in class'.
			loadedClassOrClassExtension name ]
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridModifyExtensionCompileMethod

	| normalClass projectName packageNames packageName1 packageName2 fooMethod normalInstance protocol x barMethod |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadSessionMethodExtensionProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	protocol := '*' , packageName2 asLowercase.

	fooMethod := normalClass rwCompileMethod: 'foo ^''foo''' category: protocol.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: protocol.

	self assert: normalClass bar = 'bar'.
	self
		assert:
			(x := normalClass class categoryOfSelector: #'bar') asString = protocol.
	self assert: barMethod rowanPackageName = packageName2.

	normalInstance := normalClass new.
	self assert: (normalInstance perform: #foo) = 'foo'.
	self assert: (x := normalClass categoryOfSelector: #'foo') asString = protocol.
	self assert: fooMethod rowanPackageName = packageName2.

	fooMethod := normalClass rwCompileMethod: 'foo ^''bar''' category: protocol.

	self assert: (x := normalInstance perform: #foo) = 'bar'.
	self assert: (x := normalClass categoryOfSelector: #'foo') asString = protocol.
	self assert: fooMethod rowanPackageName = packageName2.

	barMethod := normalClass class
		rwCompileMethod: 'bar ^''foo'''
		category: protocol.

	self assert: (x := normalClass perform: #bar) = 'foo'.
	self
		assert:
			(x := normalClass class categoryOfSelector: #'bar') asString = protocol.
	self assert: barMethod rowanPackageName = packageName2
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveClassToPackage

	| normalClass projectName packageNames packageName1 packageName2 movedNormalClass |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	movedNormalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().
	self assert: movedNormalClass == normalClass.
	self assert: movedNormalClass rowanPackageName = packageName2
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveClassToPackageInAlternaterSymbolDict

	| normalClass projectName packageNames packageName1 packageName2 movedNormalClass packageNameMap symDict registry project audit |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	packageNameMap := Dictionary new
		at: packageName1 put: self _symbolDictionaryName1;
		at: packageName2 put: self _symbolDictionaryName2;
		yourself.

	self
		_loadPackageMappedProjectDefinition: projectName 
		packageNameMap: packageNameMap 
		defaultSymbolDictName: self _symbolDictionaryName1.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.
	self assert: normalClass category= packageName1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	movedNormalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	self assert: movedNormalClass == normalClass.
	self assert: movedNormalClass rowanPackageName = packageName2.
	self assert: movedNormalClass category= packageName2.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveClassToPackageInAlternaterSymbolDict_class_vars

	| normalClass projectName packageNames packageName1 packageName2 movedNormalClass packageNameMap symDict registry project audit |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	packageNameMap := Dictionary new
		at: packageName1 put: self _symbolDictionaryName1;
		at: packageName2 put: self _symbolDictionaryName2;
		yourself.

	self
		_loadPackageMappedProjectDefinition: projectName 
		packageNameMap: packageNameMap 
		defaultSymbolDictName: self _symbolDictionaryName1.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.
	self assert: normalClass category= packageName1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	movedNormalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #(Cvar1)
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	self assert: movedNormalClass == normalClass.
	self assert: movedNormalClass rowanPackageName = packageName2.
	self assert: movedNormalClass category= packageName2.
	self assert: (movedNormalClass classVarNames includes: #Cvar1).

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveClassToPackageInAlternaterSymbolDict_class_vars_constraints

	| normalClass projectName packageNames packageName1 packageName2 movedNormalClass packageNameMap symDict registry project audit |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	packageNameMap := Dictionary new
		at: packageName1 put: self _symbolDictionaryName1;
		at: packageName2 put: self _symbolDictionaryName2;
		yourself.

	self
		_loadPackageMappedProjectDefinition: projectName 
		packageNameMap: packageNameMap 
		defaultSymbolDictName: self _symbolDictionaryName1.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(ivar1)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.
	self assert: normalClass category= packageName1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	movedNormalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(ivar1)
		classVars: #(Cvar1)
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		constraints: {{#ivar1 . Association}}
		options: #().

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	self assert: movedNormalClass == normalClass.
	self assert: movedNormalClass rowanPackageName = packageName2.
	self assert: movedNormalClass category= packageName2.
	self assert: (movedNormalClass classVarNames includes: #Cvar1).
	self assert: (movedNormalClass _constraintOn: #ivar1) = Association.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveClassToPackageInAlternaterSymbolDict_class_vars_constraints_new_class_version

	| normalClass projectName packageNames packageName1 packageName2 movedNormalClass packageNameMap symDict registry project audit |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	packageNameMap := Dictionary new
		at: packageName1 put: self _symbolDictionaryName1;
		at: packageName2 put: self _symbolDictionaryName2;
		yourself.

	self
		_loadPackageMappedProjectDefinition: projectName 
		packageNameMap: packageNameMap 
		defaultSymbolDictName: self _symbolDictionaryName1.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(ivar1)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.
	self assert: normalClass category= packageName1.
	self assert: (normalClass instVarNames includes: #ivar1).
	self deny: (normalClass instVarNames includes: #ivar2).

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	movedNormalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(ivar1 ivar2)
		classVars: #(Cvar1)
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		constraints: {{#ivar1 . Association}}
		options: #().

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	self assert: movedNormalClass ~~ normalClass.
	self assert: movedNormalClass rowanPackageName = packageName2.
	self assert: movedNormalClass category= packageName2.
	self assert: (movedNormalClass classVarNames includes: #Cvar1).
	self assert: (movedNormalClass _constraintOn: #ivar1) = Association.
	self assert: (movedNormalClass instVarNames includes: #ivar1).
	self assert: (movedNormalClass instVarNames includes: #ivar2).

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveClassToPackageWithClassModifications

	| normalClass projectName packageNames packageName1 packageName2 movedNormalClass |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	movedNormalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #('ivar1')
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().
	self assert: movedNormalClass ~= normalClass.
	self assert: movedNormalClass rowanPackageName = packageName2
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveClassWithMethodsAndExtensionMethodsToExtensionPackage

	| normalClass projectName packageNames packageName1 packageName2 packageName3 movedNormalClass fooMethod barMethod ext1Method ext2Method |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core1'.
	packageName2 := 'HybridA-Core2'.
	packageName3 := 'HybridA-Extensions'.
	packageNames := {packageName1. packageName2. packageName3}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	fooMethod := normalClass
		rwCompileMethod: 'foo ^''foo'''
		category: 'accessing'.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'.
	ext1Method := normalClass
		rwCompileMethod: 'ext1 ^''ext1'''
		category: '*', packageName3 asLowercase.
	ext2Method := normalClass class
		rwCompileMethod: 'ext2 ^''ext2'''
		category: '*', packageName3 asLowercase.

	self assert: (normalClass new perform: #foo) = 'foo'.
	self assert: (normalClass new perform: #ext1) = 'ext1'.
	self assert: (normalClass perform: #bar) = 'bar'.
	self assert: (normalClass perform: #ext2) = 'ext2'.

	self assert: normalClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName1.
	self assert: ext1Method rowanPackageName = packageName3.
	self assert: ext2Method rowanPackageName = packageName3.

	movedNormalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName3
		options: #().

	self assert: (normalClass new perform: #foo) = 'foo'.
	self assert: (normalClass new perform: #ext1) = 'ext1'.
	self assert: (normalClass perform: #bar) = 'bar'.
	self assert: (normalClass perform: #ext2) = 'ext2'.

	fooMethod := movedNormalClass compiledMethodAt: #foo.
	barMethod := movedNormalClass class compiledMethodAt: #bar.
	ext1Method := movedNormalClass compiledMethodAt: #ext1.
	ext2Method := movedNormalClass class compiledMethodAt: #ext2.

	self assert: movedNormalClass == normalClass.
	self assert: movedNormalClass rowanPackageName = packageName3.
	self assert: fooMethod rowanPackageName = packageName3.
	self assert: barMethod rowanPackageName = packageName3.
	self assert: ext1Method rowanPackageName = packageName3.
	self assert: ext2Method rowanPackageName = packageName3.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveClassWithMethodsAndExtensionMethodsToPackage

	| normalClass projectName packageNames packageName1 packageName2 packageName3 movedNormalClass fooMethod barMethod ext1Method ext2Method |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core1'.
	packageName2 := 'HybridA-Core2'.
	packageName3 := 'HybridA-Extensions'.
	packageNames := {packageName1. packageName2. packageName3}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	fooMethod := normalClass
		rwCompileMethod: 'foo ^''foo'''
		category: 'accessing'.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'.
	ext1Method := normalClass
		rwCompileMethod: 'ext1 ^''ext1'''
		category: '*', packageName3 asLowercase.
	ext2Method := normalClass class
		rwCompileMethod: 'ext2 ^''ext2'''
		category: '*', packageName3 asLowercase.

	self assert: (normalClass new perform: #foo) = 'foo'.
	self assert: (normalClass new perform: #ext1) = 'ext1'.
	self assert: (normalClass perform: #bar) = 'bar'.
	self assert: (normalClass perform: #ext2) = 'ext2'.

	self assert: normalClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName1.
	self assert: ext1Method rowanPackageName = packageName3.
	self assert: ext2Method rowanPackageName = packageName3.

	movedNormalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().

	self assert: (normalClass new perform: #foo) = 'foo'.
	self assert: (normalClass new perform: #ext1) = 'ext1'.
	self assert: (normalClass perform: #bar) = 'bar'.
	self assert: (normalClass perform: #ext2) = 'ext2'.

	fooMethod := movedNormalClass compiledMethodAt: #foo.
	barMethod := movedNormalClass class compiledMethodAt: #bar.
	ext1Method := movedNormalClass compiledMethodAt: #ext1.
	ext2Method := movedNormalClass class compiledMethodAt: #ext2.

	self assert: movedNormalClass == normalClass.
	self assert: movedNormalClass rowanPackageName = packageName2.
	self assert: fooMethod rowanPackageName = packageName2.
	self assert: barMethod rowanPackageName = packageName2.
	self assert: ext1Method rowanPackageName = packageName3.
	self assert: ext2Method rowanPackageName = packageName3.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveClassWithMethodsToPackage

	| normalClass projectName packageNames packageName1 packageName2 movedNormalClass fooMethod barMethod |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core1'.
	packageName2 := 'HybridA-Core2'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	fooMethod := normalClass
		rwCompileMethod: 'foo ^''foo'''
		category: 'accessing'.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing'.

	self assert: normalClass rowanPackageName = packageName1.
	self assert: fooMethod rowanPackageName = packageName1.
	self assert: barMethod rowanPackageName = packageName1.

	movedNormalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().

	fooMethod := movedNormalClass compiledMethodAt: #foo.
	barMethod := movedNormalClass class compiledMethodAt: #bar.


	self assert: movedNormalClass == normalClass.
	self assert: movedNormalClass rowanPackageName = packageName2.
	self assert: fooMethod rowanPackageName = packageName2.
	self assert: barMethod rowanPackageName = packageName2.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveMethod

	|  normalClass projectName packageNames packageName1 packageName2 packageName3 className |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions1'.
	packageName3 := 'HybridA-Extensions2'.
	packageNames := {packageName1.
	packageName2.
	packageName3}.
	className :=  'SimpleHybridNormal1'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(foo)
		classVars: #(Bar)
		classInstVars: #(baz)
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	normalClass
		rwCompileMethod: 'foo ^foo'
		category: '*' , packageName2 asLowercase.
	normalClass
		rwCompileMethod: 'bar ^Bar'
		category: 'accessing'.
	normalClass class
		rwCompileMethod: 'baz ^baz'
		category: 'accessing'.

	self assert: (normalClass categoryOfSelector: #foo) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass categoryOfSelector: #bar) = #accessing.
	self assert: (normalClass class categoryOfSelector: #baz) = #accessing.

	Rowan projectTools browser
		moveMethod: #'foo' forClassNamed: 'SimpleHybridNormal1' isMeta: false toProtocol: 'accessing';
		moveMethod: #'bar' forClassNamed: 'SimpleHybridNormal1' isMeta: false toProtocol: ( '*' , packageName2 asLowercase);
		moveMethod: #'baz' forClassNamed: 'SimpleHybridNormal1' isMeta: true toProtocol: ( '*' , packageName2 asLowercase);
		yourself.

	self assert: (normalClass categoryOfSelector: #foo) = #accessing.
	self assert: (normalClass categoryOfSelector: #bar) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass class categoryOfSelector: #baz) = ( '*' , packageName2 asLowercase) asSymbol.

	Rowan projectTools browser
		moveMethod: #'foo' forClassNamed: 'SimpleHybridNormal1' isMeta: false toProtocol: ( '*' , packageName3 asLowercase);
		moveMethod: #'bar' forClassNamed: 'SimpleHybridNormal1' isMeta: false toProtocol: ( '*' , packageName3 asLowercase);
		moveMethod: #'baz' forClassNamed: 'SimpleHybridNormal1' isMeta: true toProtocol: ( '*' , packageName3 asLowercase);
		yourself.

	self assert: (normalClass categoryOfSelector: #foo) = ( '*' , packageName3 asLowercase) asSymbol.
	self assert: (normalClass categoryOfSelector: #bar) = ( '*' , packageName3 asLowercase) asSymbol.
	self assert: (normalClass class categoryOfSelector: #baz) = ( '*' , packageName3 asLowercase) asSymbol.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveMethodFromSessionMethodsIntoSessionMethods

	|  normalClass projectName packageNames packageName1 packageName2 packageName3 className |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions1'.
	packageName3 := 'HybridA-Extensions2'.
	packageNames := {packageName1.
	packageName2.
	packageName3}.
	className :=  'SimpleHybridNormal1'.

	self
		_loadSessionMethodExtensionProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(foo)
		classVars: #(Bar)
		classInstVars: #(baz)
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	normalClass
		rwCompileMethod: 'foo ^foo'
		category: '*' , packageName2 asLowercase.
	normalClass
		rwCompileMethod: 'bar ^Bar'
		category: 'accessing'.
	normalClass class
		rwCompileMethod: 'baz ^baz'
		category: 'accessing'.

	self assert: (normalClass categoryOfSelector: #foo) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass categoryOfSelector: #bar) = #accessing.
	self assert: (normalClass class categoryOfSelector: #baz) = #accessing.

	Rowan projectTools browser
		moveMethod: #'bar' forClassNamed: 'SimpleHybridNormal1' isMeta: false toProtocol: ( '*' , packageName2 asLowercase);
		moveMethod: #'baz' forClassNamed: 'SimpleHybridNormal1' isMeta: true toProtocol: ( '*' , packageName2 asLowercase);
		moveMethod: #'foo' forClassNamed: 'SimpleHybridNormal1' isMeta: false toProtocol: 'accessing';
		yourself.

	self assert: (normalClass categoryOfSelector: #foo) = #accessing.
	self assert: (normalClass categoryOfSelector: #bar) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass class categoryOfSelector: #baz) = ( '*' , packageName2 asLowercase) asSymbol.

	Rowan projectTools browser
		moveMethod: #'bar' forClassNamed: 'SimpleHybridNormal1' isMeta: false toProtocol: ( '*' , packageName3 asLowercase);
		moveMethod: #'baz' forClassNamed: 'SimpleHybridNormal1' isMeta: true toProtocol: ( '*' , packageName3 asLowercase);
		moveMethod: #'foo' forClassNamed: 'SimpleHybridNormal1' isMeta: false toProtocol: ( '*' , packageName3 asLowercase);
		yourself.

	self assert: (normalClass categoryOfSelector: #foo) = ( '*' , packageName3 asLowercase) asSymbol.
	self assert: (normalClass categoryOfSelector: #bar) = ( '*' , packageName3 asLowercase) asSymbol.
	self assert: (normalClass class categoryOfSelector: #baz) = ( '*' , packageName3 asLowercase) asSymbol.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveMethodIntoSessionMethods

	|  normalClass projectName packageNames packageName1 packageName2 className |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	className :=  'SimpleHybridNormal1'.

	self
		_loadSessionMethodExtensionProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(foo)
		classVars: #(Bar)
		classInstVars: #(baz)
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	normalClass
		rwCompileMethod: 'foo ^foo'
		category: '*' , packageName2 asLowercase.
	normalClass
		rwCompileMethod: 'bar ^Bar'
		category: 'accessing'.
	normalClass class
		rwCompileMethod: 'baz ^baz'
		category: 'accessing'.

	self assert: (normalClass categoryOfSelector: #foo) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass categoryOfSelector: #bar) = #accessing.
	self assert: (normalClass class categoryOfSelector: #baz) = #accessing.

	Rowan projectTools browser
		moveMethod: #'bar' forClassNamed: 'SimpleHybridNormal1' isMeta: false toProtocol: ( '*' , packageName2 asLowercase);
		moveMethod: #'baz' forClassNamed: 'SimpleHybridNormal1' isMeta: true toProtocol: ( '*' , packageName2 asLowercase);
		moveMethod: #'foo' forClassNamed: 'SimpleHybridNormal1' isMeta: false toProtocol: 'accessing';
		yourself.

	self assert: (normalClass categoryOfSelector: #foo) = #accessing.
	self assert: (normalClass categoryOfSelector: #bar) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass class categoryOfSelector: #baz) = ( '*' , packageName2 asLowercase) asSymbol.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveMethod_185

	"tighten down on the bare minimum set of changes needed to reproduce an #185 issue exposed byt RwBrowserTooApiTest>>testMoveMethod"

	|  normalClass projectName packageNames packageName1 packageName2 packageName3 className fooMethod |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions1'.
	packageName3 := 'HybridA-Extensions2'.
	packageNames := {packageName1.
	packageName2.
	packageName3}.
	className :=  'SimpleHybridNormal1'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(foo)
		classVars: #(Bar)
		classInstVars: #(baz)
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	fooMethod := normalClass
		rwCompileMethod: 'foo ^foo'
		category: '*' , packageName2 asLowercase.

	self assert: (normalClass categoryOfSelector: #foo) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: fooMethod rowanPackageName = packageName2.

	fooMethod := normalClass
		rwCompileMethod: 'foo ^foo'
		category: '*' , packageName3 asLowercase.

	self assert: (normalClass categoryOfSelector: #foo) = ( '*' , packageName3 asLowercase) asSymbol.
	self assert: fooMethod rowanPackageName = packageName3.

	fooMethod := normalClass
		rwCompileMethod: 'foo ^foo'
		category: '*' , packageName2 asLowercase.

	self assert: (normalClass categoryOfSelector: #foo) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: fooMethod rowanPackageName = packageName2.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridMoveMethod_309

	"https://github.com/dalehenrich/Rowan/issues/309"

	|  normalClass projectName packageNames packageName1 packageName2 packageName3 className symDict registry |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions1'.
	packageName3 := 'HybridA-Extensions2'.
	packageNames := {packageName1.
	packageName2.
	packageName3}.
	className :=  'SimpleHybridNormal1'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: className
		instVarNames: #(foo)
		classVars: #(Bar)
		classInstVars: #(baz)
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	normalClass
		rwCompileMethod: 'foo ^foo'
		category: '*' , packageName2 asLowercase.
	normalClass
		rwCompileMethod: 'bar ^Bar'
		category: 'accessing'.
	normalClass class
		rwCompileMethod: 'baz ^baz'
		category: 'accessing'.

"validate"
	self assert: (normalClass categoryOfSelector: #foo) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass categoryOfSelector: #bar) = #accessing.
	self assert: (normalClass class categoryOfSelector: #baz) = #accessing.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 3.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 3.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [self assert: false description: 'no class extensions expected in package ', packageDef name printString ].
			packageDef name = packageName2
				ifTrue: [
					| classExtension |
					classExtension := packageDef classExtensions at: className.
					self assert: (classExtension instanceMethodDefinitions includesKey: #foo).
					self assert: (classExtension classMethodDefinitions isEmpty) ].
			packageDef name = packageName3
				ifTrue: [self assert: false description: 'no class extensions expected in package ', packageDef name printString ] ]
		forClassExtensionsIn: className.
	self
		_assert: [ :classDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ 
					| instanceMethodDict |
					self assert: classDef name = className.
					instanceMethodDict := classDef instanceMethodDefinitions.
					self deny: (instanceMethodDict includesKey: #foo).
					self assert: (instanceMethodDict includesKey: #bar).
					self assert: (classDef classMethodDefinitions includesKey: #baz) ]
				ifFalse: [ self assert: false description: 'no class definitions expected in package ', packageDef name printString ]  ]
		forClassNamed: className.

"load"
	Rowan projectTools browser
		moveMethod: #'foo' forClassNamed: className isMeta: false toProtocol: 'accessing';
		moveMethod: #'bar' forClassNamed: className isMeta: false toProtocol: ( '*' , packageName2 asLowercase);
		moveMethod: #'baz' forClassNamed: className isMeta: true toProtocol: ( '*' , packageName2 asLowercase);
		yourself.

"validate"
	self assert: (normalClass categoryOfSelector: #foo) = #accessing.
	self assert: (normalClass categoryOfSelector: #bar) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass class categoryOfSelector: #baz) = ( '*' , packageName2 asLowercase) asSymbol.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 3.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 3.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ self assert: false description: 'no class extensions expected in package ', packageDef name printString ].
			packageDef name = packageName2
				ifTrue: [
					| classExtension |
					classExtension := packageDef classExtensions at: className.
					self deny: (classExtension instanceMethodDefinitions includesKey: #foo).
					self assert: (classExtension instanceMethodDefinitions includesKey: #bar).
					self assert: (classExtension classMethodDefinitions includesKey: #baz) ].
			packageDef name = packageName3
				ifTrue: [ self assert: false description: 'no class extensions expected in package ', packageDef name printString ] ]
		forClassExtensionsIn: className.
	self
		_assert: [ :classDef :packageDef :projectDef | 
			packageDef name = packageName1
				ifTrue: [ 
					self assert: classDef name = className.
					self assert: (classDef instanceMethodDefinitions includesKey: #foo).
					self deny: (classDef instanceMethodDefinitions includesKey: #bar).
					self assert: classDef classMethodDefinitions isEmpty ]
				ifFalse: [ self assert: false description: 'no class definitions expected in package ', packageDef name printString ] ]
		forClassNamed: className.

"load"
	Rowan projectTools browser
		moveMethod: #'foo' forClassNamed: className isMeta: false toProtocol: ( '*' , packageName3 asLowercase);
		moveMethod: #'bar' forClassNamed: className isMeta: false toProtocol: ( '*' , packageName3 asLowercase);
		moveMethod: #'baz' forClassNamed: className isMeta: true toProtocol: ( '*' , packageName3 asLowercase);
		yourself.
"validate"
	self assert: (normalClass categoryOfSelector: #foo) = ( '*' , packageName3 asLowercase) asSymbol.
	self assert: (normalClass categoryOfSelector: #bar) = ( '*' , packageName3 asLowercase) asSymbol.
	self assert: (normalClass class categoryOfSelector: #baz) = ( '*' , packageName3 asLowercase) asSymbol.

	self
		_assert: [ :classExtensionDef :packageDef :projectDef | 
			(classExtensionDef instanceMethodDefinitions isEmpty and: [classExtensionDef classMethodDefinitions isEmpty])
				ifFalse: [ 
					packageDef name = packageName1
						ifTrue: [ self assert: false description: 'no class extensions expected in package ', packageDef name printString ].
					packageDef name = packageName2
						ifTrue: [ self assert: false description: 'no class extensions expected in package ', packageDef name printString ].
					packageDef name = packageName3
						ifTrue: [
							| classExtension |
							classExtension := packageDef classExtensions at: className.
							self assert: (classExtension instanceMethodDefinitions includesKey: #foo).
							self assert: (classExtension instanceMethodDefinitions includesKey: #bar).
							self assert: (classExtension classMethodDefinitions includesKey: #baz) ] ] ]
		forClassExtensionsIn: className.
	self
		_assert: [ :classDef :packageDef :projectDef | 
					self assert: packageDef name = packageName1.
					self assert: classDef name = className.
					self assert: classDef instanceMethodDefinitions isEmpty.
					self assert: classDef classMethodDefinitions isEmpty ]
		forClassNamed: className.
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridNewClassVersionWithSubclassesA

	| class subclass projectName packageNames packageName1 newClassVersion newSubclassVersion |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageNames := {packageName1}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	class := Object
		rwSubclass: 'SimpleHybrid1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	subclass := class
		rwSubclass: 'SimpleHybridSubclass1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: subclass superClass == class.

	newClassVersion := Object
		rwSubclass: 'SimpleHybrid1'
		instVarNames: #('ivar1')
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self assert: newClassVersion ~~ class.
	newSubclassVersion := Rowan globalNamed: subclass name.
	self assert: newSubclassVersion ~~ subclass.
	self assert: newSubclassVersion superClass == newClassVersion
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridNewClassVersionWithSubclassesAndMethodsA

	| class subclass projectName packageNames packageName1 newClassVersion newSubclassVersion |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageNames := {packageName1}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	class := Object
		rwSubclass: 'SimpleHybrid1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	class rwCompileMethod: 'foo ^''foo''' category: '*' , packageName1 asLowercase.
	class class
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName1 asLowercase.

	subclass := class
		rwSubclass: 'SimpleHybridSubclass1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	subclass
		rwCompileMethod: 'foo1 ^''foo'''
		category: '*' , packageName1 asLowercase.
	subclass class
		rwCompileMethod: 'foo1 ^''foo'''
		category: '*' , packageName1 asLowercase.

	self assert: subclass superClass == class.

	newClassVersion := Object
		rwSubclass: 'SimpleHybrid1'
		instVarNames: #('ivar1')
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self assert: newClassVersion ~~ class.
	newSubclassVersion := Rowan globalNamed: subclass name.
	self assert: newSubclassVersion ~~ subclass.
	self assert: newSubclassVersion superClass == newClassVersion.
	self assert: (newSubclassVersion perform: #foo) = 'foo'.
	self assert: (newSubclassVersion perform: #foo1) = 'foo'.
	self assert: (newSubclassVersion new perform: #foo) = 'foo'.
	self assert: (newSubclassVersion new perform: #foo1) = 'foo'
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridNewClassVersionWithSubclassesAndMethodsB

	| class subclass projectName packageNames packageName1 newClassVersion newSubclassVersion |
	projectName := 'Hybrid Project B'.
	packageName1 := 'HybridB-Core'.
	packageNames := {packageName1}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	class := Object
		rwSubclass: 'SimpleHybrid1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	class rwCompileMethod: 'foo ^''foo''' category: 'accessing'.
	class class rwCompileMethod: 'foo ^''foo''' category: 'accessing'.

	subclass := class
		rwSubclass: 'SimpleHybridSubclass1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	subclass rwCompileMethod: 'foo1 ^''foo''' category: 'accessing'.
	subclass class rwCompileMethod: 'foo1 ^''foo''' category: 'accessing'.

	self assert: subclass superClass == class.

	newClassVersion := Object
		rwSubclass: 'SimpleHybrid1'
		instVarNames: #('ivar1')
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self assert: newClassVersion ~~ class.
	newSubclassVersion := Rowan globalNamed: subclass name.
	self assert: newSubclassVersion ~~ subclass.
	self assert: newSubclassVersion superClass == newClassVersion.
	self assert: (newSubclassVersion perform: #foo) = 'foo'.
	self assert: (newSubclassVersion perform: #foo1) = 'foo'.
	self assert: (newSubclassVersion new perform: #foo) = 'foo'.
	self assert: (newSubclassVersion new perform: #foo1) = 'foo'
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridNewClassVersionWithSubclassesAndMethodsC

	| class subclass projectName packageNames packageName1 packageName2 newClassVersion newSubclassVersion |
	projectName := 'Hybrid Project C'.
	packageName1 := 'HybridC-Core'.
	packageName2 := 'HybridC-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	class := Object
		rwSubclass: 'SimpleHybrid1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	class rwCompileMethod: 'foo ^''foo''' category: '*' , packageName2 asLowercase.
	class class rwCompileMethod: 'foo ^''foo''' category: 'accessing'.

	subclass := class
		rwSubclass: 'SimpleHybridSubclass1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	subclass rwCompileMethod: 'foo1 ^''foo''' category: 'accessing'.
	subclass class
		rwCompileMethod: 'foo1 ^''foo'''
		category: '*' , packageName2 asLowercase.

	self assert: subclass superClass == class.

	newClassVersion := Object
		rwSubclass: 'SimpleHybrid1'
		instVarNames: #('ivar1')
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self assert: newClassVersion ~~ class.
	newSubclassVersion := Rowan globalNamed: subclass name.
	self assert: newSubclassVersion ~~ subclass.
	self assert: newSubclassVersion superClass == newClassVersion.
	self assert: (newSubclassVersion perform: #foo) = 'foo'.
	self assert: (newSubclassVersion perform: #foo1) = 'foo'.
	self assert: (newSubclassVersion new perform: #foo) = 'foo'.
	self assert: (newSubclassVersion new perform: #foo1) = 'foo'
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridNewClassVersionWithSubclassesB

	| class subclass1 subclass2 subclass3 subclass4 projectName packageNames packageName1 newClassVersion newSubclassVersion1 newSubclassVersion2 newSubclassVersion3 newSubclassVersion4 |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageNames := {packageName1}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
	class := Object
		rwSubclass: 'SimpleHybrid1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	subclass1 := class
		rwSubclass: 'SimpleHybridSubclass1'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: subclass1 superClass == class.

	subclass2 := subclass1
		rwSubclass: 'SimpleHybridSubclass2'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: subclass2 superClass == subclass1.

	subclass3 := subclass2
		rwSubclass: 'SimpleHybridSubclass3'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: subclass3 superClass == subclass2.

	subclass4 := subclass3
		rwSubclass: 'SimpleHybridSubclass4'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: subclass4 superClass == subclass3.

	newClassVersion := Object
		rwSubclass: 'SimpleHybrid1'
		instVarNames: #('ivar1')
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self assert: newClassVersion ~~ class.
	newSubclassVersion1 := Rowan globalNamed: subclass1 name.
	self assert: newSubclassVersion1 ~~ subclass1.
	self assert: newSubclassVersion1 superClass == newClassVersion.

	newSubclassVersion2 := Rowan globalNamed: subclass2 name.
	self assert: newSubclassVersion2 ~~ subclass2.
	self assert: newSubclassVersion2 superClass == newSubclassVersion1.

	newSubclassVersion3 := Rowan globalNamed: subclass3 name.
	self assert: newSubclassVersion3 ~~ subclass3.
	self assert: newSubclassVersion3 superClass == newSubclassVersion2.

	newSubclassVersion4 := Rowan globalNamed: subclass4 name.
	self assert: newSubclassVersion4 ~~ subclass4.
	self assert: newSubclassVersion4 superClass == newSubclassVersion3
%

category: 'tests'
method: RwHybridBrowserToolTest
testHybridRemoveCategory

	|  normalClass projectName packageNames packageName1 packageName2 className |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageName2 := 'HybridA-Extensions1'.
	packageNames := {packageName1.
	packageName2}.
	className :=  'SimpleHybridNormal1'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.

	normalClass := Object
		rwSubclass: 'SimpleHybridNormal1'
		instVarNames: #(foo fah)
		classVars: #(Bar)
		classInstVars: #(baz)
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	normalClass
		rwCompileMethod: 'foo1 ^foo'
		category: '*' , packageName2 asLowercase.
	normalClass
		rwCompileMethod: 'foo2 ^foo'
		category: '*' , packageName2 asLowercase.
	normalClass class
		rwCompileMethod: 'fah1 ^baz'
		category: '*' , packageName2 asLowercase.
	normalClass class
		rwCompileMethod: 'fah2 ^Bar'
		category: '*' , packageName2 asLowercase.
	normalClass
		rwCompileMethod: 'bar1 ^Bar'
		category: 'accessing'.
	normalClass class
		rwCompileMethod: 'bar2 ^baz'
		category: 'accessing'.
	normalClass
		rwCompileMethod: 'bee1 ^Bar'
		category: 'accessing'.
	normalClass class
		rwCompileMethod: 'bee2 ^baz'
		category: 'accessing'.

	self assert: (normalClass categoryOfSelector: #foo1) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass categoryOfSelector: #foo2) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass class categoryOfSelector: #fah1) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass class categoryOfSelector: #fah2) = ( '*' , packageName2 asLowercase) asSymbol.
	self assert: (normalClass categoryOfSelector: #bar1) = #accessing.
	self assert: (normalClass class categoryOfSelector: #bar2) = #accessing.
	self assert: (normalClass categoryOfSelector: #bee1) = #accessing.
	self assert: (normalClass class categoryOfSelector: #bee2) = #accessing.

	self assert: normalClass categoryNames size = 2.
	self assert: normalClass class categoryNames size = 2.

	normalClass
		rwRemoveCategory: 'accessing';
		rwRemoveCategory: ( '*' , packageName2 asLowercase);
		yourself.

	normalClass class
		rwRemoveCategory: 'accessing';
		rwRemoveCategory: ( '*' , packageName2 asLowercase);
		yourself.

	self assert: normalClass categoryNames size = 0.
	self assert: normalClass class categoryNames size = 0.
%

category: 'private'
method: RwHybridBrowserToolTest
_standardProjectDefinition: projectName packageNameMap: packageNameMap defaultSymbolDictName: defaultSymbolDictName

	| projectDefinition |
	projectDefinition := RwProjectDefinition
		newForGitBasedProjectNamed: projectName.
	packageNameMap keysAndValuesDo: [:packageName :symDictName |
		projectDefinition
			addPackageNamed: packageName;
			setSymbolDictName: symDictName forPackageNamed: packageName
			yourself ].
	projectDefinition defaultSymbolDictName: defaultSymbolDictName.

	^ projectDefinition
%

! Class implementation for 'RwProjectAuditToolTest'

!		Instance methods for 'RwProjectAuditToolTest'

category: 'tests'
method: RwProjectAuditToolTest
testAuditAndRepair_issue481_A

	"https://github.com/GemTalk/Rowan/issues/481"

	"extra instance method for packaged class"

	| projectName packageNames className1 className2 packageName1 packageName2
		symDictName audit symbolList |

	symbolList := Rowan image symbolList.

	projectName := 'AuditProject_481'.
	packageName1 := 'Audit-Core'.
	packageName2 := 'Audit-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AuditedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create loadedProject"
	self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"add extra instance method"
	(Rowan globalNamed: className1)
		compileMethod: 'foobar ^''foobar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

"audit - audit errors expected"
	self deny: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

"audit - repair audit errors"
	[audit := Rowan projectTools audit auditForProjectNamed: projectName ]
		on: RwAuditMethodErrorNotification
		do: [:ex | 
			"adopt the method"
			Rowan packageTools adopt 
				adoptMethod: ex selector 
					inClassNamed: ex className  
					isMeta: ex isMetaclass 
					intoPackageNamed: ex packageName.
			ex resume: false ].
	self assert: audit isEmpty.

"double check audit - pass"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwProjectAuditToolTest
testAuditAndRepair_issue481_B

	"https://github.com/GemTalk/Rowan/issues/481"

	"extra class method for packaged class"

	| projectName packageNames className1 className2 packageName1 packageName2
		symDictName audit symbolList |

	symbolList := Rowan image symbolList.

	projectName := 'AuditProject_481'.
	packageName1 := 'Audit-Core'.
	packageName2 := 'Audit-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AuditedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create loadedProject"
	self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"add extra class method"
	(Rowan globalNamed: className1) class
		compileMethod: 'foobar ^''foobar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

"audit - audit errors expected"
	self deny: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

"audit - repair audit errors"
	[audit := Rowan projectTools audit auditForProjectNamed: projectName ]
		on: RwAuditMethodErrorNotification
		do: [:ex | 
			"adopt the method"
			Rowan packageTools adopt 
				adoptMethod: ex selector 
					inClassNamed: ex className  
					isMeta: ex isMetaclass 
					intoPackageNamed: ex packageName.
			ex resume: false ].
	self assert: audit isEmpty.

"double check audit - pass"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwProjectAuditToolTest
testAuditAndRepair_issue481_C
	"https://github.com/GemTalk/Rowan/issues/481"

	"extra instance method for unpackaged class"

	| projectName packageNames className1 className2 packageName1 packageName2
		symDictName audit symbolList |

	symbolList := Rowan image symbolList.

	projectName := 'AuditProject_481'.
	packageName1 := 'Audit-Core'.
	packageName2 := 'Audit-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AuditedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create loadedProject"
	self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"add extra instance method"
	(Rowan globalNamed: className2)
		compileMethod: 'foobar ^''foobar'''
		dictionaries: symbolList
		category: '*' , packageName2 asLowercase
		environmentId: 0.

"audit - audit errors expected"
	self deny: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

"audit - repair audit errors"
	[audit := Rowan projectTools audit auditForProjectNamed: projectName ]
		on: RwAuditMethodErrorNotification
		do: [:ex | 
			"adopt the method"
			Rowan packageTools adopt 
				adoptMethod: ex selector 
					inClassNamed: ex className  
					isMeta: ex isMetaclass 
					intoPackageNamed: ex packageName.
			ex resume: false ].
	self assert: audit isEmpty.

"validate that method is packaged properly"
	self assert: ((Rowan globalNamed: className2) compiledMethodAt: #foobar) rowanPackageName = packageName2.

"double check audit - pass"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwProjectAuditToolTest
testAuditAndRepair_issue481_D
	"https://github.com/GemTalk/Rowan/issues/481"

	"extra class method for unpackaged class"

	| projectName packageNames className1 className2 packageName1 packageName2
		symDictName audit symbolList |

	symbolList := Rowan image symbolList.

	projectName := 'AuditProject_481'.
	packageName1 := 'Audit-Core'.
	packageName2 := 'Audit-Extension'.
	packageNames := {packageName1 .  packageName2}.
	symDictName := self _symbolDictionaryName2.
	className1 := 'AuditedClass'.
	className2 := 'ExtendedUnpackagedClass'.

"create loadedProject"
	self 
		_issue481_projectDefinition: projectName  
			packageName1: packageName1 
			packageName2: packageName2 
			className1: className1 
			className2: className2 
			symDictName: symDictName.

"add extra instance method"
	(Rowan globalNamed: className2) class
		compileMethod: 'foobar ^''foobar'''
		dictionaries: symbolList
		category: '*' , packageName2 asLowercase
		environmentId: 0.

"audit - audit errors expected"
	self deny: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

"audit - repair audit errors"
	[audit := Rowan projectTools audit auditForProjectNamed: projectName ]
		on: RwAuditMethodErrorNotification
		do: [:ex | 
			"adopt the method"
			Rowan packageTools adopt 
				adoptMethod: ex selector 
					inClassNamed: ex className  
					isMeta: ex isMetaclass 
					intoPackageNamed: ex packageName.
			ex resume: false ].
	self assert: audit isEmpty.

"validate that method is packaged properly"
	self assert: ((Rowan globalNamed: className2) class compiledMethodAt: #foobar) rowanPackageName = packageName2.

"double check audit - pass"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwProjectAuditToolTest
testClassBadExtensionName

| packageTools projectName packageNames className packageName1 packageName2 theClass fooMethod x y|
	packageTools := Rowan packageTools.
	projectName := 'AuditProject'.
	packageName1 := 'Audit-Core'.
	packageName2 := 'Audit-Extensions'.
	packageNames := {packageName1 . packageName2}.
	className := 'AuditClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing audit api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #(bar)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self assert: theClass rowanPackageName = packageName1.

   theClass 
		rwCompileMethod: 'bar ^bar'
	    category: 'Accessing' "'*'  packageName1 asLowercase".

	fooMethod := theClass
		rwCompileExtensionMethod: 'foo ^''foo'''
		package: packageName2.

self assert: (x := Rowan projectTools audit auditForProjectNamed:  projectName) isEmpty.
 
 "lets break it"
	fooMethod := theClass
		compileMethod: 'foo ^2'
		dictionaries:  #() 
		category: '*' , packageName1 asLowercase .

	self assert: (x := Rowan projectTools audit auditForProjectNamed:  projectName) size = 2.
	self assert: ( y := x at: packageName1) notNil; 
		assert: y size = 1;
		assert: (y at: className) size = 1;
		assert: (y := x at: packageName2 ) notNil;
		assert: y size = 1;
		assert: (y at: className) size = 2
%

category: 'tests'
method: RwProjectAuditToolTest
testClassExtension

| packageTools projectName packageNames className packageName1 packageName2 packageName3 theClass fooMethod x y|
	packageTools := Rowan packageTools.
	projectName := 'AuditProject'.
	packageName1 := 'Audit-Core'.
	packageName2 := 'Audit-Extensions'.
	packageName3 := 'Audit-Class-Extensions'.
	packageNames := {packageName1 . packageName2 . packageName3}.
	className := 'AuditClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing audit api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #(bar)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self assert: theClass rowanPackageName = packageName1.
	"self assert: theClass classHistory isEmpty."
	"compile good class"
   theClass class 
		rwCompileMethod: 'new ^super new '
		category: 'Instance creation'.
	
	theClass class
		rwCompileExtensionMethod: 'new2 ^self new'
		package: packageName2.

	theClass class
		rwCompileExtensionMethod: 'new3 ^self new initialize'
		package: packageName3.

   theClass 
		rwCompileMethod: 'bar ^bar'
	    category: 'Accessing' "'*'  packageName1 asLowercase".

	fooMethod := theClass
		rwCompileExtensionMethod: 'foo ^''foo'''
		package: packageName2.
	
x := Rowan projectTools audit auditForProjectNamed:  'AuditProject'.


self assert: x isEmpty.
"lets mess up the class extension"


    fooMethod := theClass
		compileMethod: 'bar: aBar bar := aBar'
		dictionaries:  #() 
		category: '*' , packageName2 asLowercase.

	 fooMethod := theClass class
		compileMethod: 'new2 ^self new'
		dictionaries: #()
		category: '*' , packageName2 asLowercase.

	fooMethod := theClass class
		compileMethod: 'new3 ^self new initialize'
		dictionaries: #()
		category: '*' , packageName3 asLowercase.

	 theClass class compileMethod: 'new ^super new '
		dictionaries: #()
		category: '*Instance creation'. "non existing extension/package"
x := Rowan projectTools audit auditForProjectNamed:  'AuditProject'.


	self 
	  assert: x size = 3;
	  assert: ((y := x at: packageName1) at: className) size = 1;
	  assert: ((y := x at: packageName2) at: className) size = 3;
	  assert: ((y := x at: packageName3) at: className) size = 2
%

category: 'tests'
method: RwProjectAuditToolTest
testClassVars
	| projectName packageNames className packageName classDefinition browserTool testClass testClassB  x |
	projectName := 'AuditProject'.
	packageName := 'Audit-Core'.
	packageNames := {packageName}.
    className := 'ClassWithVars'.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'project for testing project browser api'.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #('ivar1' 'ivar2')
		classinstvars: #('civar1' 'civar2')
		classvars: #('Cvar1' 'Cvar2')
		category: 'Simple Things'
		comment: 'I am a Simple class with various vars'
		pools: #()
		type: 'normal'.

	browserTool := Rowan projectTools browser.
	browserTool createClass: classDefinition inPackageNamed: packageName.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.

	self assert: (x := Rowan projectTools audit auditForProjectNamed:  'AuditProject') isEmpty.
	
	testClassB := DateTime subclass: className
	instVarNames: #('ivar1' 'ivar3' )
	classVars: #( 'Cvar1' 'Cvar3')
	classInstVars: #('civar3')
	poolDictionaries: #()
	inDictionary: (System myUserProfile resolveSymbol: self _symbolDictionaryName) value
	newVersionOf: testClass
	description: 'Unrowanized class'
	options: #().

	self assert: testClassB == (System myUserProfile resolveSymbol: className asSymbol) value.	
	self assert: testClassB == (Rowan globalNamed: className) description: 'Rowan does not resolve new version of class'.
	self deny: testClassB == testClass.
	self assert: (x := Rowan projectTools audit auditForProjectNamed:  'AuditProject') size = 1.
	self assert: ((x at: packageName) at: className) size = 5 description: 'expected 5 failures superclass instvars classvars comment and loaded class not latest'
%

category: 'tests'
method: RwProjectAuditToolTest
testInvalidCategory

| packageTools projectName packageNames className packageName theClass  x category|
	packageTools := Rowan packageTools.
	projectName := 'AuditProject'.
	packageName := 'Audit-Core'.
	packageNames := {packageName}.
	className := 'AuditClass'.
	category := 'Accessing'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing audit api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #(bar)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().
	self assert: theClass rowanPackageName = packageName.

	theClass
		rwCompileMethod: 'bar ^bar'
		category: category.
	 
	theClass class
		rwCompileMethod: 'new ^self basicNew'
		category: 'Instance creation'.
	 
	theClass renameCategory: category to: 'testing new category'.
	theClass class renameCategory: 'Instance creation' to: 'testing'.

	self assert: (x := Rowan projectTools audit auditForProjectNamed:  projectName) size = 1.
	self assert: ((x at: packageName) at: className) size = 2
%

category: 'tests'
method: RwProjectAuditToolTest
testInvalidExtensionCategory

| packageTools projectName packageNames className packageName theClass  x|
	packageTools := Rowan packageTools.
	projectName := 'AuditProject'.
	packageName := 'Audit-Core'.
	packageNames := {packageName}.
	className := 'AuditClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing audit api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #(bar)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().
	self assert: theClass rowanPackageName = packageName.

	theClass
		rwCompileExtensionMethod: 'bar ^bar'
		package: "'*' , "packageName asLowercase.
	 
	theClass class
		rwCompileExtensionMethod: 'new ^self basicNew'
		package: "'*' , "packageName asLowercase.
	 
	theClass class
		rwCompileMethod: 'new2 ^self basicNew'
		category: '*' , packageName.

	self assert: (x := Rowan projectTools audit auditForProjectNamed:  projectName) size = 1.
	self assert: ((x at: packageName) at: className) size = 3
%

category: 'tests'
method: RwProjectAuditToolTest
testMissingBehavior

| packageTools projectName packageNames className packageName theClass  x|
	packageTools := Rowan packageTools.
	projectName := 'AuditProject'.
	packageName := 'Audit-Core'.
	packageNames := {packageName}.
	className := 'AuditClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing audit api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #(bar)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().
	
	(System myUserProfile resolveSymbol: self _symbolDictionaryName1) value removeKey: theClass name asSymbol.
	self assert: (x := Rowan projectTools audit auditForProjectNamed:  'AuditProject') size = 1.
	self assert: ((x at: packageName) at: className) size = 1
%

category: 'tests'
method: RwProjectAuditToolTest
testMissingMethods

| packageTools projectName packageNames className packageName theClass fooMethod x|
	packageTools := Rowan packageTools.
	projectName := 'AuditProject'.
	packageName := 'Audit-Core'.
	packageNames := {packageName}.
	className := 'AuditClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing audit api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #(bar)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().
	self assert: theClass rowanPackageName = packageName.

	fooMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: "'*' , "packageName asLowercase.
	 
	fooMethod := theClass class
		compileMethod: 'new ^super new'
		dictionaries: #()
		category: 'Instance Creation'.

	theClass compileMissingAccessingMethods. "this should add: #bar #bar:"


	((Rowan image loadedPackageNamed: 'Audit-Core') loadedClassForClass: (GsSession currentSession resolveSymbol: className asSymbol) value ifAbsent: [nil error: 'expected a class']) 
			loadedInstanceMethodsDo: [:anLMethod | (anLMethod name isEquivalent: 'bar') ifTrue: [self error: 'bar was compiled without Rowan']] 
			loadedClassMethodsDo: [:cMethod | "do nothing"].

	self assert: (x := Rowan projectTools audit auditForProjectNamed:  'AuditProject') size = 1.
	self assert: ((x at: packageName) at: className) size = 3
%

category: 'tests'
method: RwProjectAuditToolTest
testNotification

| packageTools projectName packageNames className packageName theClass fooMethod |
	packageTools := Rowan packageTools.
	projectName := 'AuditProject'.
	packageName := 'Audit-Core'.
	packageNames := {packageName}.
	className := 'AuditClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing audit api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #(bar)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().
	self assert: theClass rowanPackageName = packageName.

	fooMethod := theClass
		rwCompileMethod: 'foo ^''foo'''
		category: "'*' , "packageName asLowercase.
	 
	fooMethod := theClass class
		compileMethod: 'new ^super new'
		dictionaries: #()
		category: 'Instance Creation'.

	theClass compileMissingAccessingMethods. "this should add: #bar #bar:"


	[Rowan projectTools audit auditForProjectNamed:  'AuditProject'] on: Notification do: [:ex | self assert: (ex description matchPattern: {$* . 'Missing loaded method' . $*})].
%

category: 'tests'
method: RwProjectAuditToolTest
test_issue478

	"https://github.com/GemTalk/Rowan/issues/478"

	| projectName packageNames className packageName1 packageName2 theClass  audit |
	projectName := 'AuditProject'.
	packageName1 := 'Audit-Core'.
	packageName2 := 'Audit-Extensions'.
	packageNames := {packageName1 .  packageName2}.
	className := 'AuditClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'project for testing audit api'.

	theClass := Object
		rwSubclass: className
		instVarNames: #(bar)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: theClass rowanPackageName = packageName1.

	theClass
		rwCompileMethod: 'bar ^bar'
		category: '*' , packageName2 asLowercase.
	 	 
	theClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , 'audit-extenSions'.

	self assert: (theClass compiledMethodAt: #bar) rowanPackageName = packageName2.
	self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName2.

	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty
%

category: 'tests'
method: RwProjectAuditToolTest
test_Issue_535

  "https://github.com/dalehenrich/Rowan/issues/535"

  | projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition 
		packageDefinition className1 className2 className3 className4 projectSetDefinition
		class1 class2 class3  classExtensionDefinition audit |

  projectName := 'Issue534'.
  packageName1 := 'Issue534-Core'.
  packageName2 := 'Issue534-Extensions'.
  className1 := 'Issue534Class1'.
  className2 := 'Issue534Class2'.
  className3 := 'Issue534Class3'.
  className4 := 'Issue534Class4'.

  {projectName}
    do: [ :pn |
      (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
        ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
  projectDefinition := (RwProjectDefinition
    newForGitBasedProjectNamed: projectName)
    addPackageNamed: packageName1;
    addPackageNamed: packageName2;
    defaultSymbolDictName: self _symbolDictionaryName1;
    yourself.

  packageDefinition := projectDefinition packageNamed: packageName1.

  classDefinition1 := (RwClassDefinition
    newForClassNamed: className1
      super: 'Object'
      instvars: #(ivar1)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod1 ^1' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod1 ^', className2 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition1.

  classDefinition := (RwClassDefinition
    newForClassNamed: className2
      super: className1
      instvars: #(ivar2)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod2 ^2' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod2 ^', className3 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

  classDefinition := (RwClassDefinition
    newForClassNamed: className3
      super: className2
      instvars: #(ivar4 ivar3)
      classinstvars: #()
      classvars: #()
      category: packageName1
      comment: 'comment'
      pools: #()
      type: 'normal')
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'instanceMethod3 ^3' protocol: 'accessing');
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'classMethod3 ^', className1 protocol: 'accessing');
    yourself.
  packageDefinition
    addClassDefinition: classDefinition.

"create extension methods"
  packageDefinition := projectDefinition packageNamed: packageName2.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className1)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod1 ^1' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod1 ^1' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className2)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod2 ^2' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod2 ^2' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

  classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className3)
    addInstanceMethodDefinition: (RwMethodDefinition newForSource: 'extensionInstanceMethod3 ^3' protocol: '*', packageName2 asLowercase);
    addClassMethodDefinition: (RwMethodDefinition newForSource: 'extensionClassMethod3 ^3' protocol: '*', packageName2 asLowercase); 
    yourself.
  packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"load"
  projectSetDefinition := RwProjectSetDefinition new.
  projectSetDefinition addDefinition: projectDefinition.
  Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

  class1 := Rowan globalNamed: className1.
  class2 := Rowan globalNamed: className2.
  class3 := Rowan globalNamed: className3.

"perform rename"
  Rowan projectTools browser
    renameClassNamed: className2 to: className4.

"audit"
  self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty
%

category: 'tests'
method: RwProjectAuditToolTest
_auditBlock

	|  res  loadedProject auditLoadedClassBlock auditLoadedClassExtensionBlock |
	GsFile gciLogServer: '--STARTING ROWAN AUDIT'.
	res := KeyValueDictionary new.
	auditLoadedClassBlock := self _auditLoadedClassBlock.

	auditLoadedClassExtensionBlock := self _auditLoadedClassBlock.
		
	Rowan projectNames do: [:projectName |
		GsFile gciLogServer: '---Auditing project: ', projectName printString.
		loadedProject := Rowan image loadedProjectNamed: projectName.
		loadedProject loadedPackages do: [:loadedPackage |
			loadedPackage
				loadedClasses
					valuesDo: [:aLoadedClass |
						(auditLoadedClassBlock value: aLoadedClass) 
							ifNotEmpty: [:aColl | res at: aLoadedClass name put: aColl ] ].
			loadedPackage
				loadedClassExtensions
					valuesDo: [:aLoadedClass | 
						(auditLoadedClassExtensionBlock value: aLoadedClass) 
							ifNotEmpty: [:aColl | res at: aLoadedClass name put: aColl ] ] ] ].
	UserGlobals at: #ROWAN_AUDIT_issue_365_results put: res.
	GsFile gciLogServer: '--ENDING ROWAN AUDIT'.
^true
%

category: 'tests'
method: RwProjectAuditToolTest
_auditLoadedClassBlock 

	^[:aLoadedClass |
		| ar |
		ar := {}.
		(Rowan globalNamed: aLoadedClass name) 
			ifNil: [
				ar addAll: { 'Class does not exists ' -> aLoadedClass name }.
				GsFile gciLogServer: 'Class does not exist ', aLoadedClass name ]
			ifNotNil: [:aBehavior |
				"check for non-extension methods that are not packaged in Rowan" 
				(aBehavior selectors reject: [:e |  
					((aBehavior categoryOfSelector: e) first == $*) or: [
						aLoadedClass includesSelector: e isMeta: false]]) 
							do: [:aSelector |
								ar addAll: { aSelector  -> ' Missing loaded method '  }.
								GsFile gciLogServer: 'Missing loaded method ', aLoadedClass name, '>>', aSelector ].
				(aBehavior class selectors reject: [:e | 
					((aBehavior class categoryOfSelector: e) first == $*) or: [
						aLoadedClass includesSelector: e isMeta: true]]) 
							do: [:aSelector |
								ar addAll: {aSelector  -> 'Missing loaded class method ' }.
								GsFile gciLogServer: 'Missing loaded method ', aLoadedClass name, ' class>>', aSelector ].
				"look for methods removed outside of Rowan API"
				aLoadedClass 
					loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClass :aLoadedMethod | 
						(aBehavior compiledMethodAt: aLoadedMethod name otherwise: nil) 
							ifNil: [
								ar addAll: { aLoadedMethod name  -> 'Missing compiled method: ' }.
								GsFile gciLogServer: 'Missing compiled method ', loadedClass name, '>>', aLoadedMethod name ] ]
					loadedClassMethodsDo: [:loadedProject :loadedPackage :loadedClass :aLoadedMethod |
						(aBehavior class compiledMethodAt: aLoadedMethod name otherwise: nil) 
							ifNil: [
								ar addAll: { aLoadedMethod name  -> 'Missing compiled class method ' }.
								GsFile gciLogServer: 'Missing compiled method ', loadedClass name, ' class>>', aLoadedMethod name ] ] ].
		ar ].
%

category: 'tests'
method: RwProjectAuditToolTest
_auditLoadedClassExtensionBlock

^[:aLoadedClassExtension |
		| ar |
		ar := {}.
		(Rowan globalNamed: aLoadedClassExtension name) 
			ifNil: [ 
				ar addAll: { 'Class does not exists '-> aLoadedClassExtension name }.
				GsFile gciLogServer: 'Class does not exist ', aLoadedClassExtension name ]
			ifNotNil: [ :aBehavior |
				| selectors extensionCategoryName categories |
				extensionCategoryName := '*', aLoadedClassExtension loadedPackage name asLowercase.

				categories := (aBehavior _baseCategorys: 0)
					ifNil: [ #() ]
					ifNotNil: [:catDict | catDict keys ].
				(categories
						detect: [:each | each equalsNoCase: extensionCategoryName ]
						ifNone: [ ])
					ifNotNil: [:categoryName |
						selectors := aBehavior selectorsIn: categoryName.
						(selectors reject: [:e | 
							aLoadedClassExtension includesSelector: e isMeta: false]) 
								do: [:aSelector |
									ar addAll: { aSelector -> 'Missing loaded extension method' ->  aSelector }.
									GsFile gciLogServer: 'Missing loaded extension method ', aLoadedClassExtension name, '>>', aSelector ].
						selectors do: [:sel |
							| cMeth lMeth |
							(cMeth := aBehavior compiledMethodAt: sel otherwise: nil) == (lMeth := (aLoadedClassExtension loadedInstanceMethods at: sel) handle)
								ifFalse: [
									ar addAll: { sel -> 'compiled Method is not identical to loaded Method' }.
									GsFile gciLogServer: 
										'Compiled Method (oop: ', 
										cMeth asOop printString, 
										') is not identical to loaded Method (oop: ',
									  lMeth asOop printString, 
										') ', 
										aLoadedClassExtension name, 
										'>>', 
										sel ] ] ]
					ifNil: [ 
						aLoadedClassExtension loadedInstanceMethods isEmpty not
							ifTrue: [
								ar addAll: 
									{('expected methods in the category ', extensionCategoryName printString, ' are missing') -> aLoadedClassExtension name }.
								GsFile gciLogServer: 'expected methods in category ', extensionCategoryName printString, 'for class ', aLoadedClassExtension name printString ] 
				].

				categories := (aBehavior class _baseCategorys: 0)
					ifNil: [ #() ]
					ifNotNil: [:catDict | catDict keys ].
				(categories
						detect: [:each | each equalsNoCase: extensionCategoryName ]
						ifNone: [ ])
					ifNotNil: [:categoryName |
						selectors := aBehavior class selectorsIn: categoryName.
						(selectors reject: [:e | aLoadedClassExtension includesSelector: e isMeta: true]) do: [:aSelector |
								ar addAll: {aSelector -> 'Missing loaded extensions class method: ' }.
								GsFile gciLogServer: 'Missing loaded extension method ', aLoadedClassExtension name, ' class>>', aSelector ].
						selectors do: [:sel |
							| cMeth lMeth |
							(cMeth := aBehavior class compiledMethodAt: sel otherwise: nil) == (lMeth := (aLoadedClassExtension loadedClassMethods at: sel) handle)
								ifFalse: [
									ar addAll: { sel -> 'class compiled Method is not identical to loaded Method' }.
									GsFile gciLogServer: 
										'Compiled Method (oop: ', 
										cMeth asOop printString, 
										') is not identical to loaded Method (oop: ',
									  lMeth asOop printString, 
										') ', 
										aLoadedClassExtension name, 
										' class>>', 
										sel ] ]  ]
					ifNil: [
						aLoadedClassExtension loadedClassMethods isEmpty not
							ifTrue: [ 
								ar addAll: {('expected class methods in the category ', extensionCategoryName printString, ' are missing') -> aLoadedClassExtension name }.
								GsFile gciLogServer: 'expected methods in category ', extensionCategoryName printString, 'for class ', aLoadedClassExtension name printString, ' class' ] 
				].

				"look for methods removed outside of Rowan API"
				aLoadedClassExtension 
					loadedInstanceMethodsDo: [:loadedProject :loadedPackage :loadedClass :aLoadedMethod | 
						(aBehavior compiledMethodAt: aLoadedMethod name otherwise: nil) 
							ifNil: [
								ar addAll: {aLoadedMethod name -> 'Missing compiled method: ' }.
								GsFile gciLogServer: 'Missing compiled  method ', loadedClass name, '>>', aLoadedMethod name ] ]
					loadedClassMethodsDo: [:loadedProject :loadedPackage :loadedClass :aLoadedMethod |
						(aBehavior class compiledMethodAt: aLoadedMethod name otherwise: nil) 
							ifNil: [
								ar addAll: { aLoadedMethod name -> 'Missing compiled class method: ' }.
								GsFile gciLogServer: 'Missing compiled  class method ', loadedClass name, ' class>>', aLoadedMethod name ] ] ].
		ar ].
%

! Class implementation for 'RwProjectDeleteToolTest'

!		Instance methods for 'RwProjectDeleteToolTest'

category: 'tests'
method: RwProjectDeleteToolTest
testDeleteProjectWithExtensionMethods


	| class projectName1 projectName2 packageName1 packageName2 className1 className2 classDefinition
		symDict registry projectDefinition1 projectDefinition2 packageDefinition projectNames classExtensionDefinition
		projectSetDefinition |

	projectName1 := 'DeleteProject'.
	projectName2 := 'ExtensionProject'.
	packageName1 := 'DeleteProject-Core'.
	packageName2 := 'ExtensionProject-Core'.
	className1 := 'DeleteProjectClass'.
	className2 := 'ExtensionProjectClass'.
	projectNames := {projectName1 . projectName2 }.

	projectNames do: [:projectName | 
		(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
			ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

"create projects"
	projectDefinition1 := (RwProjectDefinition newForGitBasedProjectNamed: projectName1)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.
	projectDefinition2 := (RwProjectDefinition newForGitBasedProjectNamed: projectName2)
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"create classes and methods for project1"
	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className2.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition 
		addClassDefinition: classDefinition;
		addClassExtensionDefinition: classExtensionDefinition.

"create classes and methods for project2"
	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName2
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition 
		addClassDefinition: classDefinition.

"load project definitions"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition 
		addDefinition: projectDefinition1;
		addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validation"
	class := Rowan globalNamed: className1.
	self assert: class rowanPackageName = packageName1.
	self assert: class category= packageName1.
	class := Rowan globalNamed: className2.
	self assert: class rowanPackageName = packageName2.
	self assert: class category= packageName2.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 2.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.

"delete project"
	Rowan projectTools delete deleteProjectNamed: projectName1.

"validation"
	class := Rowan globalNamed: className1.
	self assert: class isNil.
	class := Rowan globalNamed: className2.
	self assert: class rowanPackageName = packageName2.
	self assert: class category= packageName2.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwProjectDeleteToolTest
testDeleteProjectWithExtensionMethods_345

	"https://github.com/dalehenrich/Rowan/issues/342"

	| class projectName1 packageName1 packageName2 className1 classDefinition
		symDict registry projectDefinition1 packageDefinition projectNames classExtensionDefinition
		projectSetDefinition |

	projectName1 := 'DeleteProject'.
	packageName1 := 'DeleteProject-Core'.
	packageName2 := 'DeleteProject-Extension'.
	className1 := 'DeleteProjectClass'.
	projectNames := {projectName1  }.

	projectNames do: [:projectName | 
		(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
			ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

"create projects"
	projectDefinition1 := (RwProjectDefinition newForGitBasedProjectNamed: projectName1)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"create classes and methods for project1"
	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition 
		addClassDefinition: classDefinition;
		yourself.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition 
		addClassExtensionDefinition: classExtensionDefinition.

"load project definitions"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition 
		addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validation"
	class := Rowan globalNamed: className1.
	self assert: class rowanPackageName = packageName1.
	self assert: class category= packageName1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.

"delete project"
	Rowan projectTools delete deleteProjectNamed: projectName1.

"validation"
	class := Rowan globalNamed: className1.
	self assert: class isNil.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwProjectDeleteToolTest
testDeleteSimpleProject

	| class projectName packageName className classDefinition symDict registry projectDefinition packageDefinition |

	projectName := 'DeleteProject'.
	packageName := 'DeleteProject-Core'.
	className := 'DeleteProjectClass'.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

"create project"
	projectDefinition := (RwProjectDefinition newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"create classes and methods"
	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition addClassDefinition: classDefinition.

"load project definition"
	Rowan projectTools load loadProjectDefinition: projectDefinition.

"validation"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName.
	self assert: class category= packageName.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.

"delete project"
	Rowan projectTools delete deleteProjectNamed: projectName.

"validation"
	class := Rowan globalNamed: className.
	self assert: class isNil.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwProjectDeleteToolTest
testForceDeleteProjectWithExtensionMethods


	| class projectName1 projectName2 packageName1 packageName2 className1 className2 classDefinition
		symDict registry projectDefinition1 projectDefinition2 packageDefinition projectNames classExtensionDefinition
		projectSetDefinition |

	projectName1 := 'DeleteProject'.
	projectName2 := 'ExtensionProject'.
	packageName1 := 'DeleteProject-Core'.
	packageName2 := 'ExtensionProject-Core'.
	className1 := 'DeleteProjectClass'.
	className2 := 'ExtensionProjectClass'.
	projectNames := {projectName1 . projectName2 }.

	projectNames do: [:projectName | 
		(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
			ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

"create projects"
	projectDefinition1 := (RwProjectDefinition newForGitBasedProjectNamed: projectName1)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.
	projectDefinition2 := (RwProjectDefinition newForGitBasedProjectNamed: projectName2)
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"create classes and methods for project1"
	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className2.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition 
		addClassDefinition: classDefinition;
		addClassExtensionDefinition: classExtensionDefinition.

"create classes and methods for project2"
	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName2
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition 
		addClassDefinition: classDefinition.

"load project definitions"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition 
		addDefinition: projectDefinition1;
		addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validation"
	class := Rowan globalNamed: className1.
	self assert: class rowanPackageName = packageName1.
	self assert: class category= packageName1.
	class := Rowan globalNamed: className2.
	self assert: class rowanPackageName = packageName2.
	self assert: class category= packageName2.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 2.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.

"delete project"
	Rowan projectTools delete forceDeleteProjectNamed: projectName1.

"validation"
	class := Rowan globalNamed: className1.
	self assert: class isNil.
	class := Rowan globalNamed: className2.
	self assert: class rowanPackageName = packageName2.
	self assert: class category= packageName2.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwProjectDeleteToolTest
testForceDeleteSimpleProject

	| class projectName packageName className classDefinition symDict registry projectDefinition packageDefinition |

	projectName := 'DeleteProject'.
	packageName := 'DeleteProject-Core'.
	className := 'DeleteProjectClass'.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

"create project"
	projectDefinition := (RwProjectDefinition newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"create classes and methods"
	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition addClassDefinition: classDefinition.

"load project definition"
	Rowan projectTools load loadProjectDefinition: projectDefinition.

"validation"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName.
	self assert: class category= packageName.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.

"delete project"
	Rowan projectTools delete forceDeleteProjectNamed: projectName.

"validation"
	class := Rowan globalNamed: className.
	self assert: class isNil.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

! Class implementation for 'RwProjectReaderWriterTest'

!		Class methods for 'RwProjectReaderWriterTest'

category: 'testing'
classmethod: RwProjectReaderWriterTest
isAbstract
  "Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

  ^ self sunitName = #'RwProjectReaderWriterTest'
%

!		Instance methods for 'RwProjectReaderWriterTest'

category: 'running'
method: RwProjectReaderWriterTest
setUp
	super setUp.
	filesystem := self _createFileSystem.
	toDelete := OrderedCollection new.
	projectsToDelete := OrderedCollection new.
%

category: 'running'
method: RwProjectReaderWriterTest
tearDown
	toDelete
		select: [ :aFileRef | aFileRef exists ]
		thenDo: [ :aFileRef | aFileRef deleteAll ].
	projectsToDelete
		do: [ :projectName | 
		(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
			ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].
	super tearDown
%

category: 'private'
method: RwProjectReaderWriterTest
_createFileSystem
	^ FileSystem disk "currentMemoryFileSystem"
%

category: 'private'
method: RwProjectReaderWriterTest
_markForCleanup: aFileReference
	toDelete add: aFileReference
%

category: 'private'
method: RwProjectReaderWriterTest
_markForProjectCleanup: aProjectName
	projectsToDelete add: aProjectName
%

! Class implementation for 'RwProjectFiletreeTonelReaderWriterTest'

!		Class methods for 'RwProjectFiletreeTonelReaderWriterTest'

category: 'testing'
classmethod: RwProjectFiletreeTonelReaderWriterTest
isAbstract
  "Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

  ^ self sunitName = #'RwProjectFiletreeTonelReaderWriterTest'
%

!		Instance methods for 'RwProjectFiletreeTonelReaderWriterTest'

category: 'tests'
method: RwProjectFiletreeTonelReaderWriterTest
testWriterReader_A

	"multiple class extensions from multiple packages for multiple classes"

	| projectName writtenProjectDefinition readProjectDefinition readProjectSetDefinition projectSetModification writeProjectSetDefinition |
	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

	readProjectDefinition := writtenProjectDefinition copy.
	readProjectSetDefinition := readProjectDefinition readProjectSet.

"validation"
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: writtenProjectDefinition; yourself.
	projectSetModification := readProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.
%

category: 'tests'
method: RwProjectFiletreeTonelReaderWriterTest
testWriterReader_B_moveClass_518

	"https://github.com/GemTalk/Rowan/issues/128"

	"Set of tests that add, change, and remove classes, methods, and extension methods; write to an existing disk repo.
		Expecting to incrementally write only the changed definitions"

	| projectName writtenProjectDefinition readProjectSetDefinition changedProjectSetDefinition visitor
		projectSetModification writeProjectSetDefinition changedProjectDefinition 
		changedProjectSetModification writerVisitorClass writtenPojectSetDefinition  x repositoryRoot 
		movedClassDef |

	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

	repositoryRoot := writtenProjectDefinition repositoryRoot.
	self assert: (x := self _classRemovedArtifactFileReference: repositoryRoot) exists.

"copy and make desired modifications"

	changedProjectDefinition := writtenProjectDefinition copy.
	movedClassDef := (changedProjectDefinition packageNamed: 'Issue361-Core')
		removeClassNamed: 'Issue361Class2'.
	movedClassDef category:  'Issue361-Extension1'.
	(changedProjectDefinition packageNamed: 'Issue361-Extension1')
		addClassDefinition: movedClassDef.

"write changes"
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	changedProjectSetDefinition:= RwProjectSetDefinition new.
	changedProjectSetDefinition addDefinition: changedProjectDefinition.
	writtenPojectSetDefinition:= RwProjectSetDefinition new.
	writtenPojectSetDefinition addDefinition: writtenProjectDefinition.
	changedProjectSetModification := changedProjectSetDefinition compareAgainstBase: writtenPojectSetDefinition.
	visitor := writerVisitorClass new.

	visitor visit: changedProjectSetModification.

"validation"
	readProjectSetDefinition := writtenProjectDefinition readProjectSet.
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: changedProjectDefinition; yourself.
	projectSetModification := readProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.

	self deny: (self _classMovedArtifactFileReference: repositoryRoot) exists.
%

category: 'tests'
method: RwProjectFiletreeTonelReaderWriterTest
testWriterReader_B_removeClass

	"https://github.com/GemTalk/Rowan/issues/361"

	"Set of tests that add, change, and remove classes, methods, and extension methods; write to an existing disk repo.
		Expecting to incrementally write only the changed definitions"

	| projectName writtenProjectDefinition readProjectSetDefinition changedProjectSetDefinition visitor
		projectSetModification writeProjectSetDefinition changedProjectDefinition 
		changedProjectSetModification writerVisitorClass writtenPojectSetDefinition  x repositoryRoot |

	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

	repositoryRoot := writtenProjectDefinition repositoryRoot.
	self assert: (x := self _classRemovedArtifactFileReference: repositoryRoot) exists.

"copy and make desired modifications"

	changedProjectDefinition := writtenProjectDefinition copy.
	(changedProjectDefinition packageNamed: 'Issue361-Core')
		removeClassNamed: 'Issue361Class1'.

"write changes"
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	changedProjectSetDefinition:= RwProjectSetDefinition new.
	changedProjectSetDefinition addDefinition: changedProjectDefinition.
	writtenPojectSetDefinition:= RwProjectSetDefinition new.
	writtenPojectSetDefinition addDefinition: writtenProjectDefinition.
	changedProjectSetModification := changedProjectSetDefinition compareAgainstBase: writtenPojectSetDefinition.
	visitor := writerVisitorClass new.

	visitor visit: changedProjectSetModification.

"validation"
	readProjectSetDefinition := writtenProjectDefinition readProjectSet.
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: changedProjectDefinition; yourself.
	projectSetModification := readProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.

	self deny: (self _classRemovedArtifactFileReference: repositoryRoot) exists.
%

category: 'tests'
method: RwProjectFiletreeTonelReaderWriterTest
testWriterReader_B_removeExtensionClass

	"https://github.com/GemTalk/Rowan/issues/361"

	"Set of tests that add, change, and remove classes, methods, and extension methods; write to an existing disk repo.
		Expecting to incrementally write only the changed definitions"

	| projectName writtenProjectDefinition readProjectSetDefinition changedProjectSetDefinition visitor
		projectSetModification writeProjectSetDefinition changedProjectDefinition changedProjectSetModification
		writerVisitorClass writtenPojectSetDefinition repositoryRoot x |

	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

	repositoryRoot := writtenProjectDefinition repositoryRoot.
	self assert: (x := self _classExtensionRemovedArtifactFileReference: repositoryRoot) exists.

"copy and make desired modifications"

	changedProjectDefinition := writtenProjectDefinition copy.
	(changedProjectDefinition packageNamed: 'Issue361-Extension1')
		removeClassExtensionDefinitionNamed: 'Issue361Class1'.

"write changes"
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	changedProjectSetDefinition:= RwProjectSetDefinition new.
	changedProjectSetDefinition addDefinition: changedProjectDefinition.
	writtenPojectSetDefinition:= RwProjectSetDefinition new.
	writtenPojectSetDefinition addDefinition: writtenProjectDefinition.
	changedProjectSetModification := changedProjectSetDefinition compareAgainstBase: writtenPojectSetDefinition.
	visitor := writerVisitorClass new.

	visitor visit: changedProjectSetModification.

"validation"
	readProjectSetDefinition := writtenProjectDefinition readProjectSet.
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: changedProjectDefinition; yourself.
	projectSetModification := writeProjectSetDefinition compareAgainstBase: readProjectSetDefinition.
	self assert: projectSetModification isEmpty.

	self deny: (self _classExtensionRemovedArtifactFileReference: repositoryRoot) exists
%

category: 'tests'
method: RwProjectFiletreeTonelReaderWriterTest
testWriterReader_B_removePackage

	"https://github.com/GemTalk/Rowan/issues/361"

	"Set of tests that add, change, and remove classes, methods, and extension methods; write to an existing disk repo.
		Expecting to incrementally write only the changed definitions"

	| projectName writtenProjectDefinition readProjectSetDefinition changedProjectSetDefinition visitor
		projectSetModification writeProjectSetDefinition changedProjectDefinition 
		changedProjectSetModification writerVisitorClass writtenPojectSetDefinition x repositoryRoot |

	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

	repositoryRoot := writtenProjectDefinition repositoryRoot.
	self assert: (x := self _packageRemovedArtifactFileReference: repositoryRoot) exists.

"copy and make desired modifications"

	changedProjectDefinition := writtenProjectDefinition copy.
	changedProjectDefinition removePackageNamed: 'Issue361-Extension2'.

"write changes"
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	changedProjectSetDefinition:= RwProjectSetDefinition new.
	changedProjectSetDefinition addDefinition: changedProjectDefinition.
	writtenPojectSetDefinition:= RwProjectSetDefinition new.
	writtenPojectSetDefinition addDefinition: writtenProjectDefinition.
	changedProjectSetModification := changedProjectSetDefinition compareAgainstBase: writtenPojectSetDefinition.
	visitor := writerVisitorClass new.

	visitor visit: changedProjectSetModification.

"validation"
	readProjectSetDefinition := writtenProjectDefinition readProjectSet.
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: changedProjectDefinition; yourself.
	projectSetModification := readProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.

	self deny: (self _packageRemovedArtifactFileReference: repositoryRoot) exists.
%

category: 'tests'
method: RwProjectFiletreeTonelReaderWriterTest
testWriterReader_C

	"https://github.com/GemTalk/Rowan/issues/361"

	"write repository to an alternate root directory"

	| projectName writtenProjectDefinition copyProjectDefinition copyProjectSetDefinition 
		projectSetModification writeProjectSetDefinition oldRepositoryRoot newRepositoryRoot |
	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

"copy project definition and write to an alternate repository root"
	copyProjectDefinition := writtenProjectDefinition copy.
	oldRepositoryRoot := writtenProjectDefinition repositoryRoot.
	newRepositoryRoot := oldRepositoryRoot parent / (copyProjectDefinition name, '_COPY').
	newRepositoryRoot ensureDeleteAll.
	copyProjectDefinition repositoryRoot: newRepositoryRoot.

	copyProjectDefinition export.

"read from alternate root directory"
	copyProjectSetDefinition := copyProjectDefinition readProjectSet.

"validation"
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: writtenProjectDefinition; yourself.
	projectSetModification := copyProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.
%

category: 'tests'
method: RwProjectFiletreeTonelReaderWriterTest
testWriterReader_D_changeClass

	"https://github.com/GemTalk/Rowan/issues/361"

	"Set of tests that add, change, and remove classes, methods, and extension methods; write to an existing disk repo.
		Expecting to incrementally write only the changed definitions"

	| projectName writtenProjectDefinition readProjectSetDefinition changedProjectSetDefinition visitor
		projectSetModification writeProjectSetDefinition changedProjectDefinition 
		changedProjectSetModification writerVisitorClass writtenPojectSetDefinition
		classDef packageDef |

	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

"copy and make desired modifications"

	changedProjectDefinition := writtenProjectDefinition copy.
	packageDef := changedProjectDefinition packageNamed: 'Issue361-Core'.
	classDef := packageDef classDefinitionNamed: 'Issue361Class1'.
	classDef instVarNames: classDef instVarNames, #( 'iv1').
	packageDef updateClassDefinition: classDef.

"write changes"
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	changedProjectSetDefinition:= RwProjectSetDefinition new.
	changedProjectSetDefinition addDefinition: changedProjectDefinition.
	writtenPojectSetDefinition:= RwProjectSetDefinition new.
	writtenPojectSetDefinition addDefinition: writtenProjectDefinition.
	changedProjectSetModification := changedProjectSetDefinition compareAgainstBase: writtenPojectSetDefinition.
	visitor := writerVisitorClass new.

	self deny: changedProjectSetModification isEmpty.
	visitor visit: changedProjectSetModification.

"validation"
	readProjectSetDefinition := writtenProjectDefinition readProjectSet.
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: changedProjectDefinition; yourself.
	projectSetModification := readProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.
%

category: 'tests'
method: RwProjectFiletreeTonelReaderWriterTest
testWriterReader_D_changeMethods

	"https://github.com/GemTalk/Rowan/issues/361"

	"Set of tests that add, change, and remove classes, methods, and extension methods; write to an existing disk repo.
		Expecting to incrementally write only the changed definitions"

	| projectName writtenProjectDefinition readProjectSetDefinition changedProjectSetDefinition visitor
		projectSetModification writeProjectSetDefinition changedProjectDefinition 
		changedProjectSetModification writerVisitorClass writtenPojectSetDefinition
		classDef packageDef |

	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

"copy and make desired modifications"

	changedProjectDefinition := writtenProjectDefinition copy.
	packageDef := changedProjectDefinition packageNamed: 'Issue361-Core'.
	classDef := packageDef classDefinitionNamed: 'Issue361Class1'.
	classDef 
		updateInstanceMethodDefinition: 
			(RwMethodDefinition
					newForSelector: #'method6'
					protocol: 'instance accessing'
					source: 'method6 "changed" ^6');
		updateClassMethodDefinition: 
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'class accessing'
					source: 'method2 "changed" ^2').

"write changes"
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	changedProjectSetDefinition:= RwProjectSetDefinition new.
	changedProjectSetDefinition addDefinition: changedProjectDefinition.
	writtenPojectSetDefinition:= RwProjectSetDefinition new.
	writtenPojectSetDefinition addDefinition: writtenProjectDefinition.
	changedProjectSetModification := changedProjectSetDefinition compareAgainstBase: writtenPojectSetDefinition.
	visitor := writerVisitorClass new.

	self deny: changedProjectSetModification isEmpty.
	visitor visit: changedProjectSetModification.

"validation"
	readProjectSetDefinition := writtenProjectDefinition readProjectSet.
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: changedProjectDefinition; yourself.
	projectSetModification := readProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.
%

category: 'tests'
method: RwProjectFiletreeTonelReaderWriterTest
testWriterReader_E

	"https://github.com/GemTalk/Rowan/issues/361"

	"write repository to an alternate root directory and rewrite ... without error"

	| projectName writtenProjectDefinition copyProjectDefinition copyProjectSetDefinition 
		projectSetModification writeProjectSetDefinition oldRepositoryRoot newRepositoryRoot |
	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

"copy project definition and write to an alternate repository root"
	copyProjectDefinition := writtenProjectDefinition copy.
	oldRepositoryRoot := writtenProjectDefinition repositoryRoot.
	newRepositoryRoot := oldRepositoryRoot parent / (copyProjectDefinition name, '_COPY').
	newRepositoryRoot ensureDeleteAll.
	copyProjectDefinition repositoryRoot: newRepositoryRoot.

	copyProjectDefinition export.

"should be able to writeover and over and over again ... once is enough for me:)"
	copyProjectDefinition export.

"read from alternate root directory"
	copyProjectSetDefinition := copyProjectDefinition readProjectSet.

"validation"
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: writtenProjectDefinition; yourself.
	projectSetModification := copyProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.
%

category: 'private'
method: RwProjectFiletreeTonelReaderWriterTest
_classExtensionRemovedArtifactFileReference: repositoryRoot

	self subclassResponsibility: #_classExtensionRemovedArtifactFileReference:
%

category: 'private'
method: RwProjectFiletreeTonelReaderWriterTest
_classMovedArtifactFileReference: repositoryRoot

	self subclassResponsibility: #_classMovedArtifactFileReference:
%

category: 'private'
method: RwProjectFiletreeTonelReaderWriterTest
_classRemovedArtifactFileReference: repositoryRoot

	self subclassResponsibility: #_classRemovedArtifactFileReference:
%

category: 'private'
method: RwProjectFiletreeTonelReaderWriterTest
_packageRemovedArtifactFileReference: repositoryRoot

	self subclassResponsibility: #_packageRemovedArtifactFileReference:
%

category: 'private'
method: RwProjectFiletreeTonelReaderWriterTest
_repositoryFormat

	^ self subclassResponsibility: #_repositoryFormat
%

category: 'private'
method: RwProjectFiletreeTonelReaderWriterTest
_validateIssue122ProjectDefinitionSet: projectDefinitionSet projectName: projectName

	self assert: projectDefinitionSet  projects size = 1.
	projectDefinitionSet  projects keysAndValuesDo: [:projName :projectDefinition |  
		self assert: projectDefinition name = projectName.
		self assert: projectDefinition packages size = 2.
		projectDefinition  packages keysAndValuesDo: [:packageName :packageDefinition |
			packageDefinition name = 'Issue122-Core'
				ifTrue: [
					self assert: packageDefinition classExtensions isEmpty.
					self assert: packageDefinition classDefinitions size = 3.
					packageDefinition classDefinitions keysAndValuesDo: [:className :classDefinition | 
						classDefinition name = 'Issue122Class1'
							ifTrue: [
								self assert: classDefinition category = packageName.
								self assert: classDefinition instanceMethodDefinitions size = 1.
								self assert: classDefinition classMethodDefinitions size = 1 ]
							ifFalse: [
								classDefinition name = 'Issue122Class2'
								ifTrue: [
									self assert: classDefinition category = packageName.
									self assert: classDefinition instanceMethodDefinitions size = 1.
									self assert: classDefinition classMethodDefinitions size = 0 ]
								ifFalse: [
									classDefinition name = 'Issue122Class3'
									ifTrue: [
										self assert: classDefinition instanceMethodDefinitions size = 1.
										self assert: classDefinition category = packageName.
										self assert: classDefinition classMethodDefinitions size = 1 ]
									ifFalse: [ self assert: false description: 'unexpected class definition ', classDefinition name printString ] ] ] ] ]
				ifFalse: [
					packageDefinition name = 'Issue122-Extension1'
						ifTrue: [
							self assert: packageDefinition classDefinitions isEmpty.
							self assert: packageDefinition classExtensions size = 1.
							packageDefinition classExtensions keysAndValuesDo: [:className :classExtension | 
								classExtension name = 'Issue122Class1'
									ifTrue: [ 
										self assert: classExtension classMethodDefinitions isEmpty.
										self assert: classExtension instanceMethodDefinitions size = 2.
										classExtension instanceMethodDefinitions keysAndValuesDo: [:selector :methodDefinition | 
											selector = #method1
												ifTrue: [	self assert: methodDefinition protocol = '*issue122-extension1' ]
												ifFalse: [
													selector = #method122
														ifTrue: [	self assert: methodDefinition protocol = '*issue122-extension1' ]
														ifFalse: [ self assert: false description: 'unexpected method definition ', methodDefinition selector printString ] ] ] ]
									ifFalse: [ self assert: false description: 'unexpected classExtenstion definition ', classExtension name printString ] ] ]
						ifFalse: [ self assert: false description: 'unexpected package definition ', packageDefinition name printString ] ] ] ]
%

category: 'private'
method: RwProjectFiletreeTonelReaderWriterTest
_validateIssue122Repaired_CategoryValidationError_ProjectDefinitionSet: projectDefinitionSet projectName: projectName

	self assert: projectDefinitionSet  projects size = 1.
	projectDefinitionSet  projects keysAndValuesDo: [:projName :projectDefinition |  
		self assert: projectDefinition name = projectName.
		self assert: projectDefinition packages size = 1.
		projectDefinition  packages keysAndValuesDo: [:packageName :packageDefinition |
			packageDefinition name = 'Issue122-Core-CategoryValidationError'
				ifTrue: [
					self assert: packageDefinition classExtensions isEmpty.
					self assert: packageDefinition classDefinitions size = 1.
					packageDefinition classDefinitions keysAndValuesDo: [:className :classDefinition | 
						classDefinition name = 'Issue122Class1'
							ifTrue: [
								self assert: classDefinition category = packageName.
								self assert: classDefinition instanceMethodDefinitions size = 1.
								self assert: classDefinition classMethodDefinitions size = 1 ]
							ifFalse: [  self assert: false description: 'unexpected class definition ', classDefinition name printString  ] ] ]
				ifFalse: [ self assert: false description: 'unexpected package definition ', packageDefinition name printString ] ] ]
%

category: 'private'
method: RwProjectFiletreeTonelReaderWriterTest
_validateIssue122Repaired_CoreProtocolValidationError_ProjectDefinitionSet: projectDefinitionSet projectName: projectName

	self assert: projectDefinitionSet  projects size = 1.
	projectDefinitionSet  projects keysAndValuesDo: [:projName :projectDefinition |  
		self assert: projectDefinition name = projectName.
		self assert: projectDefinition packages size = 1.
		projectDefinition  packages keysAndValuesDo: [:packageName :packageDefinition |
			packageDefinition name = 'Issue122-Core-ProtocolValidationError'
				ifTrue: [
					self assert: packageDefinition classExtensions isEmpty.
					self assert: packageDefinition classDefinitions size = 1.
					packageDefinition classDefinitions keysAndValuesDo: [:className :classDefinition | 
						classDefinition name = 'Issue122Class1'
							ifTrue: [
								self assert: classDefinition category = packageName.
								self assert: classDefinition instanceMethodDefinitions size = 1.
								self assert: classDefinition classMethodDefinitions size = 1.
								classDefinition instanceMethodDefinitions keysAndValuesDo: [:selector :methodDefinition | 
									self assert: selector = #method6.
									self assert: methodDefinition protocol = 'repaired' ] ]
							ifFalse: [  self assert: false description: 'unexpected class definition ', classDefinition name printString  ] ] ]
				ifFalse: [ self assert: false description: 'unexpected package definition ', packageDefinition name printString ] ] ]
%

category: 'private'
method: RwProjectFiletreeTonelReaderWriterTest
_validateIssue122Repaired_ExtensionProtocolValidationError_ProjectDefinitionSet: projectDefinitionSet projectName: projectName


	self assert: projectDefinitionSet  projects size = 1.
	projectDefinitionSet  projects keysAndValuesDo: [:projName :projectDefinition |  
		self assert: projectDefinition name = projectName.
		self assert: projectDefinition packages size = 2.
		projectDefinition  packages keysAndValuesDo: [:packageName :packageDefinition |
			packageDefinition name = 'Issue122-Core'
				ifTrue: [
					self assert: packageDefinition classExtensions isEmpty.
					self assert: packageDefinition classDefinitions size = 3.
					packageDefinition classDefinitions keysAndValuesDo: [:className :classDefinition | 
						classDefinition name = 'Issue122Class1'
							ifTrue: [
								self assert: classDefinition category = packageName.
								self assert: classDefinition instanceMethodDefinitions size = 1.
								self assert: classDefinition classMethodDefinitions size = 1 ]
							ifFalse: [
								classDefinition name = 'Issue122Class2'
								ifTrue: [
									self assert: classDefinition category = packageName.
									self assert: classDefinition instanceMethodDefinitions size = 1.
									self assert: classDefinition classMethodDefinitions size = 0 ]
								ifFalse: [
									classDefinition name = 'Issue122Class3'
									ifTrue: [
										self assert: classDefinition instanceMethodDefinitions size = 1.
										self assert: classDefinition category = packageName.
										self assert: classDefinition classMethodDefinitions size = 1 ]
									ifFalse: [ self assert: false description: 'unexpected class definition ', classDefinition name printString ] ] ] ] ]
				ifFalse: [
					packageDefinition name = 'Issue122-Extension1-ProtocolValidationError'
						ifTrue: [
							self assert: packageDefinition classDefinitions isEmpty.
							self assert: packageDefinition classExtensions size = 1.
							packageDefinition classExtensions keysAndValuesDo: [:className :classExtension | 
								classExtension name = 'Issue122Class1'
									ifTrue: [ 
										self assert: classExtension classMethodDefinitions size = 0.
										self assert: classExtension instanceMethodDefinitions size = 2.
										classExtension instanceMethodDefinitions keysAndValuesDo: [:selector :methodDefinition | 
											selector = #method1
												ifTrue: [	self assert: methodDefinition protocol = '*issue122-extension1-protocolvalidationerror' ]
												ifFalse: [
													selector = #method20
														ifTrue: [	self assert: methodDefinition protocol = '*issue122-extension1-protocolvalidationerror' ]
														ifFalse: [ self assert: false description: 'unexpected method definition ', methodDefinition selector printString ] ] ] ]
											ifFalse: [ self assert: false description: 'unexpected classExtenstion definition ', classExtension name printString ] ] ]
						ifFalse: [ self assert: false description: 'unexpected package definition ', packageDefinition name printString ] ] ] ]
%

category: 'private'
method: RwProjectFiletreeTonelReaderWriterTest
_validateIssue361ProjectDefinitionSet: projectDefinitionSet projectName: projectName

	"on disk the class extions directory/file exists, but is empty ... need to properly read from disk without errors"

	self assert: projectDefinitionSet  projects size = 1.
	projectDefinitionSet  projects keysAndValuesDo: [:projName :projectDefinition |  
		self assert: projectDefinition name = projectName.
		self assert: projectDefinition packages size = 2.
		projectDefinition  packages keysAndValuesDo: [:packageName :packageDefinition |
			packageDefinition name = 'Issue122-Core'
				ifTrue: [
					self assert: packageDefinition classExtensions isEmpty.
					self assert: packageDefinition classDefinitions size = 3.
					packageDefinition classDefinitions keysAndValuesDo: [:className :classDefinition | 
						classDefinition name = 'Issue122Class1'
							ifTrue: [
								self assert: classDefinition category = packageName.
								self assert: classDefinition instanceMethodDefinitions size = 1.
								self assert: classDefinition classMethodDefinitions size = 1 ]
							ifFalse: [
								classDefinition name = 'Issue122Class2'
								ifTrue: [
									self assert: classDefinition category = packageName.
									self assert: classDefinition instanceMethodDefinitions size = 1.
									self assert: classDefinition classMethodDefinitions size = 0 ]
								ifFalse: [
									classDefinition name = 'Issue122Class3'
									ifTrue: [
										self assert: classDefinition instanceMethodDefinitions size = 1.
										self assert: classDefinition category = packageName.
										self assert: classDefinition classMethodDefinitions size = 1 ]
									ifFalse: [ self assert: false description: 'unexpected class definition ', classDefinition name printString ] ] ] ] ]
				ifFalse: [
					packageDefinition name = 'Issue122-Extension1'
						ifTrue: [
							self assert: packageDefinition classDefinitions isEmpty.
							self assert: packageDefinition classExtensions size = 1.
							packageDefinition classExtensions keysAndValuesDo: [:className :classExtension | 
								classExtension name = 'Issue122Class1'
									ifTrue: [ 
										self assert: classExtension instanceMethodDefinitions isEmpty.
										self assert: classExtension classMethodDefinitions isEmpty ]
									ifFalse: [ self assert: false description: 'unexpected classExtenstion definition ', classExtension name printString ] ] ]
						ifFalse: [ self assert: false description: 'unexpected package definition ', packageDefinition name printString ] ] ] ]
%

! Class implementation for 'RwProjectFiletreeReaderWriterTest'

!		Instance methods for 'RwProjectFiletreeReaderWriterTest'

category: 'tests'
method: RwProjectFiletreeReaderWriterTest
testWriterReader_B_moveInstanceClassMethods_518

	"https://github.com/GemTalk/Rowan/issues/518"

	"Set of tests that add, change, and remove classes, methods, and extension methods; write to an existing disk repo.
		Expecting to incrementally write only the changed definitions"

	"only applies to filetree, since methods are not stored in separate files for tonel"

	"delete instance/class directory when last instance/class method is removed"

	| projectName writtenProjectDefinition readProjectSetDefinition changedProjectSetDefinition visitor
		projectSetModification writeProjectSetDefinition changedProjectDefinition 
		changedProjectSetModification writerVisitorClass writtenPojectSetDefinition  x repositoryRoot
		movedMethod |

	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

	repositoryRoot := writtenProjectDefinition repositoryRoot.
	self assert: (x := self _instanceMethodMovedArtifactFileReference: repositoryRoot) exists.

"copy and make desired modifications"

	changedProjectDefinition := writtenProjectDefinition copy.
	movedMethod := ((changedProjectDefinition packageNamed: 'Issue361-Core')
		classDefinitionNamed: 'Issue361Class3'ifAbsent: [])
		removeInstanceMethod: #method9.
	((changedProjectDefinition packageNamed: 'Issue361-Core')
		classDefinitionNamed: 'Issue361Class2'ifAbsent: [])
		addInstanceMethodDefinition: movedMethod.

"write changes"
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	changedProjectSetDefinition:= RwProjectSetDefinition new.
	changedProjectSetDefinition addDefinition: changedProjectDefinition.
	writtenPojectSetDefinition:= RwProjectSetDefinition new.
	writtenPojectSetDefinition addDefinition: writtenProjectDefinition.
	changedProjectSetModification := changedProjectSetDefinition compareAgainstBase: writtenPojectSetDefinition.
	visitor := writerVisitorClass new.

	visitor visit: changedProjectSetModification.

"validation"
	readProjectSetDefinition := writtenProjectDefinition readProjectSet.
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: changedProjectDefinition; yourself.
	projectSetModification := readProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.

	self deny: (x := self _instanceMethodMovedArtifactFileReference: repositoryRoot) exists.
	self assert: (x := self _instanceMethodMovedArtifactFileReference: repositoryRoot) parent exists.	"instance dir should not be deleted"
%

category: 'tests'
method: RwProjectFiletreeReaderWriterTest
testWriterReader_B_moveLastInstanceClassMethods_518

	"https://github.com/GemTalk/Rowan/issues/518"

	"Set of tests that add, change, and remove classes, methods, and extension methods; write to an existing disk repo.
		Expecting to incrementally write only the changed definitions"

	"only applies to filetree, since methods are not stored in separate files for tonel"

	"remove the instance or class method file"

	| projectName writtenProjectDefinition readProjectSetDefinition changedProjectSetDefinition visitor
		projectSetModification writeProjectSetDefinition changedProjectDefinition 
		changedProjectSetModification writerVisitorClass writtenPojectSetDefinition  x repositoryRoot movedMethod |

	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

	repositoryRoot := writtenProjectDefinition repositoryRoot.
	self assert: (x := self _lastInstanceMethodMovedArtifactFileReference: repositoryRoot) exists.

"copy and make desired modifications"

	changedProjectDefinition := writtenProjectDefinition copy.
	movedMethod := ((changedProjectDefinition packageNamed: 'Issue361-Core')
		classDefinitionNamed: 'Issue361Class1'ifAbsent: [])
		removeInstanceMethod: #method6.
	((changedProjectDefinition packageNamed: 'Issue361-Core')
		classDefinitionNamed: 'Issue361Class2'ifAbsent: [])
		addInstanceMethodDefinition: movedMethod.

"write changes"
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	changedProjectSetDefinition:= RwProjectSetDefinition new.
	changedProjectSetDefinition addDefinition: changedProjectDefinition.
	writtenPojectSetDefinition:= RwProjectSetDefinition new.
	writtenPojectSetDefinition addDefinition: writtenProjectDefinition.
	changedProjectSetModification := changedProjectSetDefinition compareAgainstBase: writtenPojectSetDefinition.
	visitor := writerVisitorClass new.

	visitor visit: changedProjectSetModification.

"validation"
	readProjectSetDefinition := writtenProjectDefinition readProjectSet.
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: changedProjectDefinition; yourself.
	projectSetModification := readProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.

	self deny: (x := self _lastInstanceMethodMovedArtifactFileReference: repositoryRoot) exists.
%

category: 'tests'
method: RwProjectFiletreeReaderWriterTest
testWriterReader_B_removeInstanceClassMethods

	"https://github.com/GemTalk/Rowan/issues/361"

	"Set of tests that add, change, and remove classes, methods, and extension methods; write to an existing disk repo.
		Expecting to incrementally write only the changed definitions"

	"only applies to filetree, since methods are not stored in separate files for tonel"

	"delete instance/class directory when last instance/class method is removed"

	| projectName writtenProjectDefinition readProjectSetDefinition changedProjectSetDefinition visitor
		projectSetModification writeProjectSetDefinition changedProjectDefinition 
		changedProjectSetModification writerVisitorClass writtenPojectSetDefinition  x repositoryRoot |

	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

	repositoryRoot := writtenProjectDefinition repositoryRoot.
	self assert: (x := self _classMethodRemovedArtifactFileReference: repositoryRoot) exists.
	self assert: (x := self _instanceMethodRemovedArtifactFileReference: repositoryRoot) exists.

"copy and make desired modifications"

	changedProjectDefinition := writtenProjectDefinition copy.
	((changedProjectDefinition packageNamed: 'Issue361-Core')
		classDefinitionNamed: 'Issue361Class3'ifAbsent: [])
		removeInstanceMethod: #method9;
		removeClassMethod: #method10.

"write changes"
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	changedProjectSetDefinition:= RwProjectSetDefinition new.
	changedProjectSetDefinition addDefinition: changedProjectDefinition.
	writtenPojectSetDefinition:= RwProjectSetDefinition new.
	writtenPojectSetDefinition addDefinition: writtenProjectDefinition.
	changedProjectSetModification := changedProjectSetDefinition compareAgainstBase: writtenPojectSetDefinition.
	visitor := writerVisitorClass new.

	visitor visit: changedProjectSetModification.

"validation"
	readProjectSetDefinition := writtenProjectDefinition readProjectSet.
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: changedProjectDefinition; yourself.
	projectSetModification := readProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.

	self deny: (x := self _classMethodRemovedArtifactFileReference: repositoryRoot) exists.
	self deny: (x := self _instanceMethodRemovedArtifactFileReference: repositoryRoot) exists.
	self assert: (x := self _classMethodRemovedArtifactFileReference: repositoryRoot) parent exists.		"class dir should not be deleted"
	self assert: (x := self _instanceMethodRemovedArtifactFileReference: repositoryRoot) parent exists.	"instance dir should not be deleted"
%

category: 'tests'
method: RwProjectFiletreeReaderWriterTest
testWriterReader_B_removeLastInstanceClassMethods

	"https://github.com/GemTalk/Rowan/issues/361"

	"Set of tests that add, change, and remove classes, methods, and extension methods; write to an existing disk repo.
		Expecting to incrementally write only the changed definitions"

	"only applies to filetree, since methods are not stored in separate files for tonel"

	"remove the instance or class method file"

	| projectName writtenProjectDefinition readProjectSetDefinition changedProjectSetDefinition visitor
		projectSetModification writeProjectSetDefinition changedProjectDefinition 
		changedProjectSetModification writerVisitorClass writtenPojectSetDefinition  x repositoryRoot |

	projectName := 'Issue361'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

"write projectDefinition to disk"
	writtenProjectDefinition := self _projectDefinitionForStructureWriters_A: projectName format: self _repositoryFormat.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	writtenProjectDefinition repositoryRoot ensureDeleteAll.
	writtenProjectDefinition create.

	repositoryRoot := writtenProjectDefinition repositoryRoot.
	self assert: (x := self _lastClassMethodRemovedArtifactFileReference: repositoryRoot) exists.
	self assert: (x := self _lastInstanceMethodRemovedArtifactFileReference: repositoryRoot) exists.

"copy and make desired modifications"

	changedProjectDefinition := writtenProjectDefinition copy.
	((changedProjectDefinition packageNamed: 'Issue361-Core')
		classDefinitionNamed: 'Issue361Class1'ifAbsent: [])
		removeInstanceMethod: #method6;
		removeClassMethod: #method2.

"write changes"
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	changedProjectSetDefinition:= RwProjectSetDefinition new.
	changedProjectSetDefinition addDefinition: changedProjectDefinition.
	writtenPojectSetDefinition:= RwProjectSetDefinition new.
	writtenPojectSetDefinition addDefinition: writtenProjectDefinition.
	changedProjectSetModification := changedProjectSetDefinition compareAgainstBase: writtenPojectSetDefinition.
	visitor := writerVisitorClass new.

	visitor visit: changedProjectSetModification.

"validation"
	readProjectSetDefinition := writtenProjectDefinition readProjectSet.
	writeProjectSetDefinition := RwProjectSetDefinition new addProject: changedProjectDefinition; yourself.
	projectSetModification := readProjectSetDefinition compareAgainstBase: writeProjectSetDefinition.
	self assert: projectSetModification isEmpty.

	self deny: (x := self _lastClassMethodRemovedArtifactFileReference: repositoryRoot) exists.
	self deny: (x := self _lastInstanceMethodRemovedArtifactFileReference: repositoryRoot) exists.
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_classExtensionRemovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Extension1.package' / 'Issue361Class1.extension'
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_classMethodRemovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Core.package' / 'Issue361Class3.class' / 'class' / 'method10', 'st'
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_classMovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Core.package' / 'Issue361Class2.class'
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_classRemovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Core.package' / 'Issue361Class1.class'
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_instanceMethodMovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Core.package' / 'Issue361Class3.class' / 'instance' / 'method9', 'st'
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_instanceMethodRemovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Core.package' / 'Issue361Class3.class' / 'instance' / 'method9', 'st'
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_lastClassMethodRemovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Core.package' / 'Issue361Class1.class' / 'class'
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_lastInstanceMethodMovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Core.package' / 'Issue361Class1.class' / 'instance'
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_lastInstanceMethodRemovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Core.package' / 'Issue361Class1.class' / 'instance'
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_packageRemovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Extension2.package'
%

category: 'private'
method: RwProjectFiletreeReaderWriterTest
_repositoryFormat

	^ 'filetree'
%

! Class implementation for 'RwProjectTonelReaderWriterTest'

!		Instance methods for 'RwProjectTonelReaderWriterTest'

category: 'private'
method: RwProjectTonelReaderWriterTest
_classExtensionRemovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Extension1' / 'Issue361Class1.extension.st'
%

category: 'private'
method: RwProjectTonelReaderWriterTest
_classMovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Core' / 'Issue361Class2.class.st'
%

category: 'private'
method: RwProjectTonelReaderWriterTest
_classRemovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Core' / 'Issue361Class1.class.st'
%

category: 'private'
method: RwProjectTonelReaderWriterTest
_packageRemovedArtifactFileReference: repositoryRoot

	^ repositoryRoot / 'rowan' / 'src' / 'Issue361-Extension2'
%

category: 'private'
method: RwProjectTonelReaderWriterTest
_repositoryFormat

	^ 'tonel'
%

! Class implementation for 'RwProjectTopazWriterTest'

!		Instance methods for 'RwProjectTopazWriterTest'

category: 'tests'
method: RwProjectTopazWriterTest
testGsTopazWriter_A

	"simple case with only two packages and a single set of extensions for a class"

	|  projectName packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
		classExtensionDefinition projectSetDefinition projectSetModification visitor repositoryRootPath x stream y |

	projectName := 'Issue361'.
	packageName1 := 'Issue361-Core'.
	packageName2 := 'Issue361-Extension'.
	className1 := 'Issue361Class1'. 
	className2 := 'Issue361Class2'. 
	className3 := 'Issue361Class3'. 

"create definitions"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Array'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: className1
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: '*', packageName2 asLowercase
					source: 'method1 ^1').
	packageDefinition := projectDefinition packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"diff"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

"write"
	repositoryRootPath := filesystem workingDirectory / projectName / 'topaz'.
	self _markForCleanup: (filesystem workingDirectory / projectName).
	repositoryRootPath ensureCreateDirectory.

	projectSetModification := projectSetDefinition compareAgainstBase: RwProjectSetDefinition new.
	visitor := RwGsModificationTopazWriterVisitor new
		repositoryRootPath: repositoryRootPath;
		topazFilename: projectName;
		yourself.
	visitor visit: projectSetModification.

	stream := ZnBufferedReadStream on: visitor topazFileReference readStream.
	x := stream contents.
	y := self _expectedGsTopazWriterFileContents_A.
	self assert: x = y
%

category: 'tests'
method: RwProjectTopazWriterTest
testGsTopazWriter_B

	"ramp up to multiple class extensions from multiple packages for multiple classes"

	|  projectName packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
		classExtensionDefinition projectSetDefinition projectSetModification visitor repositoryRootPath x stream y
		packageName3 |

	projectName := 'Issue361'.
	packageName1 := 'Issue361-Core'.
	packageName2 := 'Issue361-Extension1'.
	packageName3 := 'Issue361-Extension2'.
	className1 := 'Issue361Class1'. 
	className2 := 'Issue361Class2'. 
	className3 := 'Issue361Class3'. 

"create definitions"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Array'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: className1
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: '*', packageName2 asLowercase
					source: 'method1 ^1').
	packageDefinition := projectDefinition packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	packageDefinition := projectDefinition packageNamed: packageName3.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method5'
					protocol: '*', packageName3 asLowercase
					source: 'method5 ^5').
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"diff"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

"write"
	repositoryRootPath := filesystem workingDirectory / projectName / 'topaz'.
	self _markForCleanup: (filesystem workingDirectory / projectName).
	repositoryRootPath ensureCreateDirectory.

	projectSetModification := projectSetDefinition compareAgainstBase: RwProjectSetDefinition new.
	visitor := RwGsModificationTopazWriterVisitor new
		repositoryRootPath: repositoryRootPath;
		topazFilename: projectName;
		yourself.
	visitor visit: projectSetModification.

	stream := ZnBufferedReadStream on: visitor topazFileReference readStream.
	x := stream contents.
	y := self _expectedGsTopazWriterFileContents_B.
	self assert: x = y
%

category: 'tests'
method: RwProjectTopazWriterTest
testGsTopazWriter_C

	"ramp up to multiple class extensions from multiple packages for multiple classes"

	"write each package into a separate topaz file"

	|  projectName packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
		classExtensionDefinition projectSetDefinition projectSetModification visitor repositoryRootPath x stream y
		packageName3 |

	projectName := 'Issue361'.
	packageName1 := 'Issue361-Core'.
	packageName2 := 'Issue361-Extension1'.
	packageName3 := 'Issue361-Extension2'.
	className1 := 'Issue361Class1'. 
	className2 := 'Issue361Class2'. 
	className3 := 'Issue361Class3'. 

"create definitions"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Array'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: className1
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: '*', packageName2 asLowercase
					source: 'method1 ^1').
	packageDefinition := projectDefinition packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	packageDefinition := projectDefinition packageNamed: packageName3.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method5'
					protocol: '*', packageName3 asLowercase
					source: 'method5 ^5').
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"diff"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

"write"
	repositoryRootPath := filesystem workingDirectory / projectName / 'topaz'.
	self _markForCleanup: (filesystem workingDirectory / projectName).
	repositoryRootPath ensureCreateDirectory.

	projectSetModification := projectSetDefinition compareAgainstBase: RwProjectSetDefinition new.
	visitor := RwGsModificationTopazWriterVisitor new
		repositoryRootPath: repositoryRootPath;
		topazFilenamePackageNamesMap: 
			(Dictionary new
				at: packageName1 put: {packageName1};
				at: packageName2 put: {packageName2};
				at: packageName3 put: {packageName3};
				yourself)
		yourself.
	visitor visit: projectSetModification.

	{ packageName1. packageName2. packageName3 }
		do: [:packageName |
			stream := ZnBufferedReadStream on: (repositoryRootPath / packageName, visitor filenameExtension) readStream.
			x := stream contents.
			y := self perform: #'_expectedGsTopazWriterFileContents_C_', (packageName copyWithout: $-).
			self assert: x = y ].
%

category: 'tests'
method: RwProjectTopazWriterTest
testGsTopazWriter_D

	"ramp up to multiple class extensions from multiple packages for multiple classes"

	"write each package into a separate topaz file"

	"include class initialization methods"

	|  projectName packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
		classExtensionDefinition projectSetDefinition projectSetModification visitor repositoryRootPath x stream y
		packageName3 |

	projectName := 'Issue361'.
	packageName1 := 'Issue361-Core'.
	packageName2 := 'Issue361-Extension1'.
	packageName3 := 'Issue361-Extension2'.
	className1 := 'Issue361Class1'. 
	className2 := 'Issue361Class2'. 
	className3 := 'Issue361Class3'. 

"create definitions"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2');
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'initialize'
					protocol: 'initialization'
					source: 'initialize "noop"').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Array'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: className1
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: '*', packageName2 asLowercase
					source: 'method1 ^1').
	packageDefinition := projectDefinition packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	packageDefinition := projectDefinition packageNamed: packageName3.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method5'
					protocol: '*', packageName3 asLowercase
					source: 'method5 ^5').
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className2.
	classExtensionDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'initialize'
					protocol: '*', packageName3 asLowercase
					source: 'initialize "another noop"').
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.


"diff"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

"write"
	repositoryRootPath := filesystem workingDirectory / projectName / 'topaz'.
	self _markForCleanup: (filesystem workingDirectory / projectName).
	repositoryRootPath ensureCreateDirectory.

	projectSetModification := projectSetDefinition compareAgainstBase: RwProjectSetDefinition new.
	visitor := RwGsModificationTopazWriterVisitor new
		repositoryRootPath: repositoryRootPath;
		topazFilenamePackageNamesMap: 
			(Dictionary new
				at: packageName1 put: {packageName1};
				at: packageName2 put: {packageName2};
				at: packageName3 put: {packageName3};
				yourself)
		yourself.
	visitor visit: projectSetModification.

	{ packageName1. packageName2. packageName3 }
		do: [:packageName |
			stream := ZnBufferedReadStream on: (repositoryRootPath / packageName, visitor filenameExtension) readStream.
			x := stream contents.
			y := self perform: #'_expectedGsTopazWriterFileContents_D_', (packageName copyWithout: $-).
			self assert: x = y ].
%

category: 'tests'
method: RwProjectTopazWriterTest
testGsTopazWriter_error

	"try to write to multiple files when no configs are available"

	|  projectName packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
		classExtensionDefinition projectSetDefinition projectSetModification visitor repositoryRootPath
		packageName3 |

	projectName := 'Issue361'.
	packageName1 := 'Issue361-Core'.
	packageName2 := 'Issue361-Extension1'.
	packageName3 := 'Issue361-Extension2'.
	className1 := 'Issue361Class1'. 
	className2 := 'Issue361Class2'. 
	className3 := 'Issue361Class3'. 

"create definitions"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Array'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: className1
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: '*', packageName2 asLowercase
					source: 'method1 ^1').
	packageDefinition := projectDefinition packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	packageDefinition := projectDefinition packageNamed: packageName3.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method5'
					protocol: '*', packageName3 asLowercase
					source: 'method5 ^5').
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"diff"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

"write"
	repositoryRootPath := filesystem workingDirectory / projectName / 'topaz'.
	self _markForCleanup: (filesystem workingDirectory / projectName).
	repositoryRootPath ensureCreateDirectory.

	projectSetModification := projectSetDefinition compareAgainstBase: RwProjectSetDefinition new.
	visitor := RwGsModificationTopazWriterVisitor new
				repositoryRootPath: repositoryRootPath;
				topazFilenameConfigsMap: (Dictionary new
						at: 'rowan_bootstrap_app' put: {{'Kernel'}. {}};
						at: 'rowan_bootstrap_globals' put: {{'Globals'}. {}};
						at: 'rowan_bootstrap_user_globals' put: {{'UserGlobals'}. {}};
						yourself);
				yourself.
	self should: [ visitor visit: projectSetModification ] raise: Error
%

category: 'tests'
method: RwProjectTopazWriterTest
testGsTopazWriter_MultiProject_A

	"ramp up to multiple class extensions from multiple packages and multiple projects"

	"write a single topaz file"

	"include class initialization methods"

	|  projectName packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
		classExtensionDefinition projectSetDefinition projectSetModification visitor repositoryRootPath x stream y
		packageName3 |

	projectName := 'Issue361'.
	packageName1 := 'Issue361-Core'.
	packageName2 := 'Issue361-Extension1'.
	packageName3 := 'Issue361-Extension2'.
	className1 := 'Issue361Class1'. 
	className2 := 'Issue361Class2'. 
	className3 := 'Issue361Class3'. 

	projectSetDefinition := RwProjectSetDefinition new.

	{1 . 2 } do: [:projectIndex |
		| projectExt |
		projectExt := '_', projectIndex asString.

"create definitions"
		projectDefinition := (RwProjectDefinition
			newForGitBasedProjectNamed: projectName, projectExt)
			addPackageNamed: packageName1, projectExt;
			addPackageNamed: packageName2, projectExt;
			addPackageNamed: packageName3, projectExt;
			setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1, projectExt;
			setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName2, projectExt;
			yourself.

		packageDefinition := projectDefinition packageNamed: packageName1, projectExt.

		classDefinition := RwClassDefinition
			newForClassNamed: className1, projectExt
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1, projectExt
			comment: ''
			pools: #()
			type: 'normal'.
		classDefinition
			addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'method2'
						protocol: 'accessing'
						source: 'method2 ^2');
			addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize "noop"').
		packageDefinition addClassDefinition: classDefinition.

		classDefinition := RwClassDefinition
			newForClassNamed: className2, projectExt
			super: 'Array'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1, projectExt
			comment: ''
			pools: #()
			type: 'normal'.
		classDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'method3'
						protocol: 'accessing'
						source: 'method3 ^3').
		packageDefinition addClassDefinition: classDefinition.

		classDefinition := RwClassDefinition
			newForClassNamed: className3, projectExt
			super: className1
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1, projectExt
			comment: ''
			pools: #()
			type: 'normal'.
		classDefinition
			addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'method4'
						protocol: 'accessing'
						source: 'method4 ^4').
		packageDefinition addClassDefinition: classDefinition.

		classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1, projectExt.
		classExtensionDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'method1'
						protocol: '*', (packageName2, projectExt) asLowercase
						source: 'method1 ^1').
		packageDefinition := projectDefinition packageNamed: packageName2, projectExt.
		packageDefinition addClassExtensionDefinition: classExtensionDefinition.

		packageDefinition := projectDefinition packageNamed: packageName3, projectExt.

		classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1, projectExt.
		classExtensionDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'method5'
						protocol: '*', (packageName3, projectExt) asLowercase
						source: 'method5 ^5').
		packageDefinition addClassExtensionDefinition: classExtensionDefinition.

		classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className2, projectExt.
		classExtensionDefinition
			addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: '*', (packageName3, projectExt) asLowercase
						source: 'initialize "another noop"').
		packageDefinition addClassExtensionDefinition: classExtensionDefinition.

		projectSetDefinition addDefinition: projectDefinition ].

"export"
	repositoryRootPath := filesystem workingDirectory / projectName / 'topaz'.
	self _markForCleanup: (filesystem workingDirectory / projectName).
	repositoryRootPath ensureCreateDirectory.

	projectSetModification := projectSetDefinition compareAgainstBase: RwProjectSetDefinition new.
	visitor := RwGsModificationTopazWriterVisitor new
		repositoryRootPath: repositoryRootPath;
		topazFilename: projectName;
		yourself.
	visitor visit: projectSetModification.

"validate"
	stream := ZnBufferedReadStream on: visitor topazFileReference readStream.
	x := stream contents.
	y := self _expectedGsTopazWriterFileContents_Multi_A.
	self assert: x = y
%

category: 'tests'
method: RwProjectTopazWriterTest
testGsTopazWriter_MultiProject_B

	"ramp up to multiple class extensions from multiple packages and multiple projects"

	"write each package pair into a separate topaz file"

	"include class initialization methods"

	|  projectName packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
		classExtensionDefinition projectSetDefinition projectSetModification visitor repositoryRootPath x stream y
		packageName3 |

	projectName := 'Issue361'.
	packageName1 := 'Issue361-Core'.
	packageName2 := 'Issue361-Extension1'.
	packageName3 := 'Issue361-Extension2'.
	className1 := 'Issue361Class1'. 
	className2 := 'Issue361Class2'. 
	className3 := 'Issue361Class3'. 

	projectSetDefinition := RwProjectSetDefinition new.

	{1 . 2 } do: [:projectIndex |
		| projectExt |
		projectExt := '_', projectIndex asString.

"create definitions"
		projectDefinition := (RwProjectDefinition
			newForGitBasedProjectNamed: projectName, projectExt)
			addPackageNamed: packageName1, projectExt;
			addPackageNamed: packageName2, projectExt;
			addPackageNamed: packageName3, projectExt;
			setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1, projectExt;
			setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName2, projectExt;
			yourself.

		packageDefinition := projectDefinition packageNamed: packageName1, projectExt.

		classDefinition := RwClassDefinition
			newForClassNamed: className1, projectExt
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1, projectExt
			comment: ''
			pools: #()
			type: 'normal'.
		classDefinition
			addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'method2'
						protocol: 'accessing'
						source: 'method2 ^2');
			addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize "noop"').
		packageDefinition addClassDefinition: classDefinition.

		classDefinition := RwClassDefinition
			newForClassNamed: className2, projectExt
			super: 'Array'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1, projectExt
			comment: ''
			pools: #()
			type: 'normal'.
		classDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'method3'
						protocol: 'accessing'
						source: 'method3 ^3').
		packageDefinition addClassDefinition: classDefinition.

		classDefinition := RwClassDefinition
			newForClassNamed: className3, projectExt
			super: className1
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1, projectExt
			comment: ''
			pools: #()
			type: 'normal'.
		classDefinition
			addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'method4'
						protocol: 'accessing'
						source: 'method4 ^4').
		packageDefinition addClassDefinition: classDefinition.

		classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1, projectExt.
		classExtensionDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'method1'
						protocol: '*', (packageName2, projectExt) asLowercase
						source: 'method1 ^1').
		packageDefinition := projectDefinition packageNamed: packageName2, projectExt.
		packageDefinition addClassExtensionDefinition: classExtensionDefinition.

		packageDefinition := projectDefinition packageNamed: packageName3, projectExt.

		classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1, projectExt.
		classExtensionDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'method5'
						protocol: '*', (packageName3, projectExt) asLowercase
						source: 'method5 ^5').
		packageDefinition addClassExtensionDefinition: classExtensionDefinition.

		classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className2, projectExt.
		classExtensionDefinition
			addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: '*', (packageName3, projectExt) asLowercase
						source: 'initialize "another noop"').
		packageDefinition addClassExtensionDefinition: classExtensionDefinition.

		projectSetDefinition addDefinition: projectDefinition ].

"export"
	repositoryRootPath := filesystem workingDirectory / projectName / 'topaz'.
	self _markForCleanup: (filesystem workingDirectory / projectName).
	repositoryRootPath ensureCreateDirectory.

	projectSetModification := projectSetDefinition compareAgainstBase: RwProjectSetDefinition new.
	visitor := RwGsModificationTopazWriterVisitor new
		repositoryRootPath: repositoryRootPath;
		topazFilenamePackageNamesMap: 
			(Dictionary new
				at: packageName1 put: {packageName1, '_1' . packageName1, '_2' };
				at: packageName2 put: {packageName2, '_1' . packageName2, '_2' };
				at: packageName3 put: {packageName3, '_1' . packageName3, '_2' };
				yourself)
		yourself.
	visitor visit: projectSetModification.

"validate"
	{ packageName1. packageName2. packageName3 }
		do: [:packageName |
			stream := ZnBufferedReadStream on: (repositoryRootPath / packageName, visitor filenameExtension) readStream.
			x := stream contents.
			y := self perform: #'_expectedGsTopazWriterFileContents_MULTI_B_', (packageName copyWithout: $-).

			self assert: x size = y size.
			1 to: x size do: [:i |
				| a b |
				a := x at: i.
				b := y at: i.
				self assert: a = b ].

			self assert: x = y ].
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_A

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class Declarations
! Generated file, do not Edit

doit
(Array
	subclass: ''Issue361Class2''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Object
	subclass: ''Issue361Class1''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Issue361Class1
	subclass: ''Issue361Class3''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

! Class implementation for ''Issue361Class2''

!		Instance methods for ''Issue361Class2''

category: ''accessing''
method: Issue361Class2
method3 ^3
', percent, '

! Class implementation for ''Issue361Class1''

!		Class methods for ''Issue361Class1''

category: ''accessing''
classmethod: Issue361Class1
method2 ^2
', percent, '

! Class implementation for ''Issue361Class3''

!		Class methods for ''Issue361Class3''

category: ''accessing''
classmethod: Issue361Class3
method4 ^4
', percent, '

! Class extensions for ''Issue361Class1''

!		Instance methods for ''Issue361Class1''

category: ''*issue361-extension''
method: Issue361Class1
method1 ^1
', percent, '

'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_B

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class Declarations
! Generated file, do not Edit

doit
(Array
	subclass: ''Issue361Class2''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Object
	subclass: ''Issue361Class1''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Issue361Class1
	subclass: ''Issue361Class3''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

! Class implementation for ''Issue361Class2''

!		Instance methods for ''Issue361Class2''

category: ''accessing''
method: Issue361Class2
method3 ^3
', percent, '

! Class implementation for ''Issue361Class1''

!		Class methods for ''Issue361Class1''

category: ''accessing''
classmethod: Issue361Class1
method2 ^2
', percent, '

! Class implementation for ''Issue361Class3''

!		Class methods for ''Issue361Class3''

category: ''accessing''
classmethod: Issue361Class3
method4 ^4
', percent, '

! Class extensions for ''Issue361Class1''

!		Instance methods for ''Issue361Class1''

category: ''*issue361-extension1''
method: Issue361Class1
method1 ^1
', percent, '

category: ''*issue361-extension2''
method: Issue361Class1
method5 ^5
', percent, '

'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_C_Issue361Core

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class Declarations
! Generated file, do not Edit

doit
(Array
	subclass: ''Issue361Class2''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Object
	subclass: ''Issue361Class1''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Issue361Class1
	subclass: ''Issue361Class3''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

! Class implementation for ''Issue361Class2''

!		Instance methods for ''Issue361Class2''

category: ''accessing''
method: Issue361Class2
method3 ^3
', percent, '

! Class implementation for ''Issue361Class1''

!		Class methods for ''Issue361Class1''

category: ''accessing''
classmethod: Issue361Class1
method2 ^2
', percent, '

! Class implementation for ''Issue361Class3''

!		Class methods for ''Issue361Class3''

category: ''accessing''
classmethod: Issue361Class3
method4 ^4
', percent, '

'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_C_Issue361Extension1

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class extensions for ''Issue361Class1''

!		Instance methods for ''Issue361Class1''

category: ''*issue361-extension1''
method: Issue361Class1
method1 ^1
', percent, '

'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_C_Issue361Extension2

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class extensions for ''Issue361Class1''

!		Instance methods for ''Issue361Class1''

category: ''*issue361-extension2''
method: Issue361Class1
method5 ^5
', percent, '

'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_D_Issue361Core

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class Declarations
! Generated file, do not Edit

doit
(Array
	subclass: ''Issue361Class2''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Object
	subclass: ''Issue361Class1''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Issue361Class1
	subclass: ''Issue361Class3''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

! Class implementation for ''Issue361Class2''

!		Instance methods for ''Issue361Class2''

category: ''accessing''
method: Issue361Class2
method3 ^3
', percent, '

! Class implementation for ''Issue361Class1''

!		Class methods for ''Issue361Class1''

category: ''initialization''
classmethod: Issue361Class1
initialize "noop"
', percent, '

category: ''accessing''
classmethod: Issue361Class1
method2 ^2
', percent, '

! Class implementation for ''Issue361Class3''

!		Class methods for ''Issue361Class3''

category: ''accessing''
classmethod: Issue361Class3
method4 ^4
', percent, '

! Class Initialization

run
Issue361Class1 initialize.
true
', percent, '
'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_D_Issue361Extension1

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class extensions for ''Issue361Class1''

!		Instance methods for ''Issue361Class1''

category: ''*issue361-extension1''
method: Issue361Class1
method1 ^1
', percent, '

'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_D_Issue361Extension2

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class extensions for ''Issue361Class1''

!		Instance methods for ''Issue361Class1''

category: ''*issue361-extension2''
method: Issue361Class1
method5 ^5
', percent, '

! Class extensions for ''Issue361Class2''

!		Class methods for ''Issue361Class2''

category: ''*issue361-extension2''
classmethod: Issue361Class2
initialize "another noop"
', percent, '

! Class Initialization

run
Issue361Class2 initialize.
true
', percent, '
'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_Multi_A

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class Declarations
! Generated file, do not Edit

doit
(Array
	subclass: ''Issue361Class2_1''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_1'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Array
	subclass: ''Issue361Class2_2''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_2'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Issue361Class1
	subclass: ''Issue361Class3_1''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_1'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Issue361Class1
	subclass: ''Issue361Class3_2''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_2'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Object
	subclass: ''Issue361Class1_1''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_1'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Object
	subclass: ''Issue361Class1_2''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_2'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

! Class implementation for ''Issue361Class2_1''

!		Instance methods for ''Issue361Class2_1''

category: ''accessing''
method: Issue361Class2_1
method3 ^3
', percent, '

! Class implementation for ''Issue361Class2_2''

!		Instance methods for ''Issue361Class2_2''

category: ''accessing''
method: Issue361Class2_2
method3 ^3
', percent, '

! Class implementation for ''Issue361Class3_1''

!		Class methods for ''Issue361Class3_1''

category: ''accessing''
classmethod: Issue361Class3_1
method4 ^4
', percent, '

! Class implementation for ''Issue361Class3_2''

!		Class methods for ''Issue361Class3_2''

category: ''accessing''
classmethod: Issue361Class3_2
method4 ^4
', percent, '

! Class implementation for ''Issue361Class1_1''

!		Class methods for ''Issue361Class1_1''

category: ''initialization''
classmethod: Issue361Class1_1
initialize "noop"
', percent, '

category: ''accessing''
classmethod: Issue361Class1_1
method2 ^2
', percent, '

! Class implementation for ''Issue361Class1_2''

!		Class methods for ''Issue361Class1_2''

category: ''initialization''
classmethod: Issue361Class1_2
initialize "noop"
', percent, '

category: ''accessing''
classmethod: Issue361Class1_2
method2 ^2
', percent, '

! Class extensions for ''Issue361Class1_1''

!		Instance methods for ''Issue361Class1_1''

category: ''*issue361-extension1_1''
method: Issue361Class1_1
method1 ^1
', percent, '

category: ''*issue361-extension2_1''
method: Issue361Class1_1
method5 ^5
', percent, '

! Class extensions for ''Issue361Class1_2''

!		Instance methods for ''Issue361Class1_2''

category: ''*issue361-extension1_2''
method: Issue361Class1_2
method1 ^1
', percent, '

category: ''*issue361-extension2_2''
method: Issue361Class1_2
method5 ^5
', percent, '

! Class extensions for ''Issue361Class2_1''

!		Class methods for ''Issue361Class2_1''

category: ''*issue361-extension2_1''
classmethod: Issue361Class2_1
initialize "another noop"
', percent, '

! Class extensions for ''Issue361Class2_2''

!		Class methods for ''Issue361Class2_2''

category: ''*issue361-extension2_2''
classmethod: Issue361Class2_2
initialize "another noop"
', percent, '

! Class Initialization

run
Issue361Class1_1 initialize.
Issue361Class1_2 initialize.
Issue361Class2_1 initialize.
Issue361Class2_2 initialize.
true
', percent, '
'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_MULTI_B_Issue361Core

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class Declarations
! Generated file, do not Edit

doit
(Array
	subclass: ''Issue361Class2_1''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_1'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Array
	subclass: ''Issue361Class2_2''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_2'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Issue361Class1
	subclass: ''Issue361Class3_1''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_1'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Issue361Class1
	subclass: ''Issue361Class3_2''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_2'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Object
	subclass: ''Issue361Class1_1''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_1'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

doit
(Object
	subclass: ''Issue361Class1_2''
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: CypressTestData
	options: #()
)
		category: ''Issue361-Core_2'';
		comment: '''';
		immediateInvariant.
true.
', percent, '

! Class implementation for ''Issue361Class2_1''

!		Instance methods for ''Issue361Class2_1''

category: ''accessing''
method: Issue361Class2_1
method3 ^3
', percent, '

! Class implementation for ''Issue361Class2_2''

!		Instance methods for ''Issue361Class2_2''

category: ''accessing''
method: Issue361Class2_2
method3 ^3
', percent, '

! Class implementation for ''Issue361Class3_1''

!		Class methods for ''Issue361Class3_1''

category: ''accessing''
classmethod: Issue361Class3_1
method4 ^4
', percent, '

! Class implementation for ''Issue361Class3_2''

!		Class methods for ''Issue361Class3_2''

category: ''accessing''
classmethod: Issue361Class3_2
method4 ^4
', percent, '

! Class implementation for ''Issue361Class1_1''

!		Class methods for ''Issue361Class1_1''

category: ''initialization''
classmethod: Issue361Class1_1
initialize "noop"
', percent, '

category: ''accessing''
classmethod: Issue361Class1_1
method2 ^2
', percent, '

! Class implementation for ''Issue361Class1_2''

!		Class methods for ''Issue361Class1_2''

category: ''initialization''
classmethod: Issue361Class1_2
initialize "noop"
', percent, '

category: ''accessing''
classmethod: Issue361Class1_2
method2 ^2
', percent, '

! Class Initialization

run
Issue361Class1_1 initialize.
Issue361Class1_2 initialize.
true
', percent, '
'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_MULTI_B_Issue361Extension1

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class extensions for ''Issue361Class1_1''

!		Instance methods for ''Issue361Class1_1''

category: ''*issue361-extension1_1''
method: Issue361Class1_1
method1 ^1
', percent, '

! Class extensions for ''Issue361Class1_2''

!		Instance methods for ''Issue361Class1_2''

category: ''*issue361-extension1_2''
method: Issue361Class1_2
method1 ^1
', percent, '

'
%

category: 'private'
method: RwProjectTopazWriterTest
_expectedGsTopazWriterFileContents_MULTI_B_Issue361Extension2

| percent|
percent := '%'.	"a method containing % in the first column cannot be loaded into GemStone using topaz"
	^ '! Class extensions for ''Issue361Class1_1''

!		Instance methods for ''Issue361Class1_1''

category: ''*issue361-extension2_1''
method: Issue361Class1_1
method5 ^5
', percent, '

! Class extensions for ''Issue361Class1_2''

!		Instance methods for ''Issue361Class1_2''

category: ''*issue361-extension2_2''
method: Issue361Class1_2
method5 ^5
', percent, '

! Class extensions for ''Issue361Class2_1''

!		Class methods for ''Issue361Class2_1''

category: ''*issue361-extension2_1''
classmethod: Issue361Class2_1
initialize "another noop"
', percent, '

! Class extensions for ''Issue361Class2_2''

!		Class methods for ''Issue361Class2_2''

category: ''*issue361-extension2_2''
classmethod: Issue361Class2_2
initialize "another noop"
', percent, '

! Class Initialization

run
Issue361Class2_1 initialize.
Issue361Class2_2 initialize.
true
', percent, '
'
%

! Class implementation for 'RwReconcileToolApiTest'

!		Instance methods for 'RwReconcileToolApiTest'

category: 'tests'
method: RwReconcileToolApiTest
testReconcileGlobalExtensionMethods

	| projectDefinitionSet projectName  packageName1 packageName2 packageName3 projectDefinition 
		classDefinition classExtensionDefinition packageDefinition1 packageDefinition2 packageDefinition3
		className |

	projectName := 'GlobalsExtensionMethods'.
	packageName1 := 'GlobalsExtensionMethods-Core1'.
	packageName2 := 'GlobalsExtensionMethods-Extension1'.
	packageName3 := 'GlobalsExtensionMethods-Extension2'.
	className := 'GlobalsExtensionMethods'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		repositoryRootPath: self _testRowanProjectsSandbox pathString, '/rowanTest/';					"reconcile expects the repo to be on disk"
		repositoryUrl: 'cypress:', self _testRowanProjectsSandbox pathString, '/rowanTest/rowan/src/';	"reconcile expects the repo to be on disk"
		addPackagesNamed: { packageName1 . packageName2 . packageName3 };
		yourself.

	packageDefinition1 := projectDefinition packageNamed: packageName1.
	packageDefinition2 := projectDefinition packageNamed: packageName2.
	packageDefinition3 := projectDefinition packageNamed: packageName3.

"packageName1 contents"
	classDefinition := (RwClassDefinition
		newForClassNamed: className
			super: 'Object'
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: nil
			comment: ''
			pools: #()
			type: 'normal')
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'foo'
				protocol: 'accessing'
				source: 'foo ^1 ');
		yourself.
	packageDefinition1 
		addClassDefinition: classDefinition.

"packageName2 contents"
	classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className)
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'bar'
				protocol: '*', packageName2 asLowercase
				source: 'bar ^1 ');
		yourself.
	packageDefinition2 
		addClassExtensionDefinition: classExtensionDefinition.

	classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: 'Object')
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'bar'
				protocol: '*', packageName2 asLowercase
				source: 'bar ^1 ');
		addClassMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'bar'
				protocol: '*', packageName2 asLowercase
				source: 'bar ^1 ');
		yourself.
	packageDefinition2 
		addClassExtensionDefinition: classExtensionDefinition.

"packageName3 contents"

	classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: 'Object')
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'foo'
				protocol: '*', packageName3 asLowercase
				source: 'foo ^1 ');
		addClassMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'foo'
				protocol: '*', packageName3 asLowercase
				source: 'foo ^1 ');
		yourself.
	packageDefinition3 
		addClassExtensionDefinition: classExtensionDefinition.

	classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: 'ByteArray')
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'foo'
				protocol: '*', packageName3 asLowercase
				source: 'foo ^1 ');
		yourself.
	packageDefinition3 
		addClassExtensionDefinition: classExtensionDefinition.

"reconcile"
	projectDefinitionSet := (RwProjectSetDefinition new)
		addProject: projectDefinition;
		yourself.

	Rowan projectTools reconcile
		reconcileGlobalClassExtensionsForProjectDefinitionSet: projectDefinitionSet
		defaultGroupName: 'default' 
		globalsGroupName: 'globals' 
		globalsUserId: 'SystemUser'.

"validate"
%

category: 'tests'
method: RwReconcileToolApiTest
testReconcileGlobalExtensionMethods_issue_290

	"https://github.com/dalehenrich/Rowan/issues/290"

	| projectDefinitionSet projectName  packageName1 packageName2 packageName3 projectDefinition 
		classDefinition classExtensionDefinition packageDefinition1 packageDefinition2 packageDefinition3
		className classFileString |

	projectName := 'GlobalsExtensionMethods'.
	packageName1 := 'GlobalsExtensionMethods-Core1'.
	packageName2 := 'GlobalsExtensionMethods-Extension1'.
	packageName3 := 'GlobalsExtensionMethods-Extension2'.
	className := 'GlobalsExtensionMethods'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		repositoryRootPath: self _testRowanProjectsSandbox pathString, '/rowanTest/';					"reconcile expects the repo to be on disk"
		repositoryUrl: 'tonel:', self _testRowanProjectsSandbox pathString, '/rowanTest/rowan/src/';	"reconcile expects the repo to be on disk"
		addPackagesNamed: { packageName1 . packageName2 . packageName3 };
		yourself.

	packageDefinition1 := projectDefinition packageNamed: packageName1.
	packageDefinition2 := projectDefinition packageNamed: packageName2.
	packageDefinition3 := projectDefinition packageNamed: packageName3.

"packageName1 contents"
	classDefinition := (RwClassDefinition
		newForClassNamed: className
			super: 'Object'
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: ''
			comment: ''
			pools: #()
			type: 'normal')
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'foo'
				protocol: 'accessing'
				source: 'foo ^1 ');
		yourself.
	packageDefinition1 
		addClassDefinition: classDefinition.

"packageName2 contents"
	classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: className)
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'bar'
				protocol: '*', packageName2 asLowercase
				source: 'bar ^1 ');
		addClassMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'bar'
				protocol: 'accessing'
				source: 'bar ^1 ');
		yourself.
	packageDefinition2 
		addClassExtensionDefinition: classExtensionDefinition.

	classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: 'Object')
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'bar'
				protocol: '*', packageName2 asLowercase
				source: 'bar ^1 ');
		addClassMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'bar'
				protocol: '*', packageName2 asLowercase
				source: 'bar ^1 ');
		yourself.
	packageDefinition2 
		addClassExtensionDefinition: classExtensionDefinition.

"packageName3 contents"

	classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: 'Object')
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'foo'
				protocol: '*', packageName3 asLowercase
				source: 'foo ^1 ');
		addClassMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'foo'
				protocol: '*', packageName3 asLowercase
				source: 'foo ^1 ');
		yourself.
	packageDefinition3 
		addClassExtensionDefinition: classExtensionDefinition.

	classExtensionDefinition := (RwClassExtensionDefinition newForClassNamed: 'ByteArray')
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'foo'
				protocol: '*', packageName3 asLowercase
				source: 'foo ^1 ');
		yourself.
	packageDefinition3 
		addClassExtensionDefinition: classExtensionDefinition.

"reconcile"
	projectDefinitionSet := (RwProjectSetDefinition new)
		addProject: projectDefinition;
		yourself.

	Rowan projectTools reconcile
		reconcileGlobalClassExtensionsForProjectDefinitionSet: projectDefinitionSet
		defaultGroupName: 'default' 
		globalsGroupName: 'globals' 
		globalsUserId: 'SystemUser'.

	Rowan projectTools write writeProjectDefinition: projectDefinition.
"validate"

	Rowan fileUtilities 
		readStreamFor: self _testRowanProjectsSandbox pathString, '/rowanTest/rowan/src/GlobalsExtensionMethods-Extension1/GlobalsExtensionMethods.extension.st' 
		do: [:fileStream | classFileString := fileStream contents ].
	self deny: (classFileString includesString: 'classSide')
%

! Class implementation for 'RwRowanProjectIssuesTest'

!		Class methods for 'RwRowanProjectIssuesTest'

category: 'private'
classmethod: RwRowanProjectIssuesTest
_symbolDictionaryNames

	^ 	super _symbolDictionaryNames, 
			#( #'RowanSample4SymbolDict' #'SampleSymbolDict')
%

!		Instance methods for 'RwRowanProjectIssuesTest'

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_bothModificationsMustShareCommonAfter_1

	"https://github.com/dalehenrich/Rowan/issues/114"

	"new class version of superclass and new method in subclass"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition instVarNames: #(ivar1).	"new class version"
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition addInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1') .
	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: (theClass2 new perform: #ivar1) isNil.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_bothModificationsMustShareCommonAfter_2

	"https://github.com/dalehenrich/Rowan/issues/114"

	"new class version of superclass and changed comment in subclass"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition comment |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.
	comment := 'a class comment'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition instVarNames: #(ivar1).	"new class version"
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition comment: comment.
	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: theClass2 comment = comment.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_bothModificationsMustShareCommonAfter_3

	"https://github.com/dalehenrich/Rowan/issues/114"

	"existing method in subclass, new class version of superclass and new method in subclass"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass1  inPackage: packageName1 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass2  inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 1.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition instVarNames: #(ivar1).	"new class version"
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition addInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1') .
	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #ivar1) isNil.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_bothModificationsMustShareCommonAfter_4

	"https://github.com/dalehenrich/Rowan/issues/114"

	"existing method in subclass, new class version of superclass and change of existing method in subclass, new method in subclass"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass1  inPackage: packageName1 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass2  inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 1.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition instVarNames: #(ivar1).	"new class version"
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition 
		addInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		updateInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'foo'
						protocol: 'accessing'
						source: 'foo ^2').

	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 2.
	self assert: (theClass2 new perform: #ivar1) isNil.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_bothModificationsMustShareCommonAfter_5

	"https://github.com/dalehenrich/Rowan/issues/114"

	"existing method in subclass, new class version of superclass and change of existing method in subclass, new method in subclass and change comment in subclass"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass1  inPackage: packageName1 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass2  inPackage: packageName2 inProjectNamed: projectName validate: false.
	theClass2 comment: 'a comment'.

	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 1.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition instVarNames: #(ivar1).	"new class version"
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition 
		addInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		updateInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'foo'
						protocol: 'accessing'
						source: 'foo ^2');
		comment: 'a new comment'.

	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 2.
	self assert: (theClass2 new perform: #ivar1) isNil.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_classComment

	"https://github.com/dalehenrich/Rowan/issues/114"

	"new class version of superclass, where both superclass and subclass have a class comment"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.
	theClass1 rwComment: 'theClass1 comment'.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	theClass2 rwComment: 'theClass2 comment'.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition instVarNames: #(ivar1).	"new class version"
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.

	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: theClass1 comment = 'theClass1 comment'.
	self assert: theClass2 comment = 'theClass2 comment'.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_classCommentChange_1

	"https://github.com/dalehenrich/Rowan/issues/114"

	"new class version of superclass, where both superclass and subclass have a class comment, change superclass 
		comment"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.
	theClass1 rwComment: 'theClass1 comment'.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	theClass2 rwComment: 'theClass2 comment'.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition 
		instVarNames: #(ivar1);	"new class version"
		comment: 'a new comment'.
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.

	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: theClass1 comment = 'a new comment'.
	self assert: theClass2 comment = 'theClass2 comment'.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_classCommentChange_2

	"https://github.com/dalehenrich/Rowan/issues/114"

	"new class version of superclass, where both superclass and subclass have a class comment, change subclass 
		comment"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.
	theClass1 rwComment: 'theClass1 comment'.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	theClass2 rwComment: 'theClass2 comment'.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition 
		instVarNames: #(ivar1).	"new class version"
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition
				comment: 'a new comment'.
	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: theClass1 comment = 'theClass1 comment'.
	self assert: theClass2 comment = 'a new comment'.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_classCommentChange_3

	"https://github.com/dalehenrich/Rowan/issues/114"

	"new class version of superclass, where both superclass and subclass have a class comment, change superclass and change subclass 
		comment"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.
	theClass1 rwComment: 'theClass1 comment'.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	theClass2 rwComment: 'theClass2 comment'.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition 
		instVarNames: #(ivar1);	"new class version"
		comment: 'a new comment'.
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition
			comment: 'a new comment'.
	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: theClass1 comment = 'a new comment'.
	self assert: theClass2 comment = 'a new comment'.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_methodSourceIsNotTheSame_0

	"https://github.com/dalehenrich/Rowan/issues/114"

	"existing method and comment in subclass, new class version of superclass, new method, update old method,
		and change method protocol"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	theClass2 rwComment: 'a comment'.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass1  inPackage: packageName1 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass2  inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 1.
	self assert: theClass2 comment = 'a comment'.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition instVarNames: #(ivar1).	"new class version"
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition 
		addInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		updateInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'foo'
						protocol: 'accessing'
						source: 'foo ^2').
	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 2.
	self assert: (theClass2 new perform: #ivar1) isNil.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_methodSourceIsNotTheSame_1

	"https://github.com/dalehenrich/Rowan/issues/114"

	"existing method and comment in subclass, new class version of superclass, new method, update old method,
		change method protocol and update comment in subclass -- combo"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	theClass2 rwComment: 'a comment'.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass1  inPackage: packageName1 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass2  inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 1.
	self assert: theClass2 comment = 'a comment'.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition instVarNames: #(ivar1).	"new class version"
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition 
		addInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		updateInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'foo'
						protocol: 'accessing'
						source: 'foo ^2');
		comment: 'a new comment'.
	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 2.
	self assert: (theClass2 new perform: #ivar1) isNil.
	self assert: theClass2 comment = 'a new comment'.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_methodSourceIsNotTheSame_2

	"https://github.com/dalehenrich/Rowan/issues/114"

	"existing method and comment in subclass, new class version of superclass, new method, update 
		old method in superclass and subclass,change method protocol and update comment in subclass -- combo"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Issue114Class_1' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	theClass2 rwComment: 'a comment'.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass1  inPackage: packageName1 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass2  inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 1.
	self assert: theClass2 comment = 'a comment'.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition 
		instVarNames: #(ivar1);	"new class version"
		updateInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'foo'
						protocol: 'accessing'
						source: 'foo ^2').
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition 
		addInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		updateInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'foo'
						protocol: 'accessing'
						source: 'foo ^2');
		comment: 'a new comment'.
	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: (theClass1 new perform: #foo) = 2.
	self assert: (theClass2 new perform: #foo) = 2.
	self assert: (theClass2 new perform: #ivar1) isNil.
	self assert: theClass2 comment = 'a new comment'.
%

category: 'tests-issue 114'
method: RwRowanProjectIssuesTest
testIssue114_missingClassModification

	"https://github.com/dalehenrich/Rowan/issues/114"

	"RwGsClassVersioningSymbolDictPatch>>updatePatchesForNewClassVersion:"

	| projectName packageName1 packageName2 theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue114_project'.
	packageName1 := 'Issue114-Core1'.
	packageName2 := 'Issue114-Core2'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue114Class_1' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName1 
		inProjectNamed: projectName 
		validate: false.

	theClass2 := self 
		_addClassNamed: 'Issue114Class_2' 
		superclassName: 'Object' 
		classVars: #(  )
		toPackageNamed: packageName2
		inProjectNamed: projectName
		validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass1  inPackage: packageName1 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass2  inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass2 new perform: #foo) = 1.

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at:  'Issue114Class_1'.
	classDefinition instVarNames: #(ivar1).	"new class version"
	classDefinition updateInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'foo'
						protocol: 'accessing'
						source: 'foo ^2').
	classDefinition updateInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1').
	classDefinition := (projectDefinition packageNamed: packageName2) classDefinitions at:  'Issue114Class_2'.
	classDefinition instVarNames: #().
	classDefinition updateInstanceMethodDefinition:  (RwMethodDefinition
						newForSelector: #'foo'
						protocol: 'accessing'
						source: 'foo ^ 2') .
	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	theClass1 := Rowan globalNamed: 'Issue114Class_1'.
	theClass2 := Rowan globalNamed: 'Issue114Class_2'.
	self assert: (theClass1 new perform: #foo) = 2.
	self assert: (theClass1 new perform: #ivar1) isNil.
	self assert: (theClass2 new perform: #foo) = 2.
%

category: 'tests-issue 123'
method: RwRowanProjectIssuesTest
testIssue123_definition_based_moveExistingClassWithMethodsAndSubclassesToNewPackageAndNewClassVersion
	"https://github.com/dalehenrich/Rowan/issues/123"

"
    Create class Issue91 in Package RowanSample1-XXX.
    Add non-extension method .
     Using the class definition template, create a new version of Issue91 with new inst var 'abc' in RowanSample1-Extensions
"

	| projectName packageName1 packageName2 className1 className2 projectDefinition classDefinition1 classDefinition2 packageDefinition
		projectSetDefinition theClass1 theClass2 ivNames oldClass1 oldClass2 project audit |
	projectName := 'Issue123_Project'.
	packageName1 := 'Issue123-Core'.
	packageName2 := 'Issue123-Extensions'.
	className1 := 'Issue123Class'.
	className2 := 'Issue123SubClass'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project definitions"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition1
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'foo ^1').
	classDefinition2 := RwClassDefinition
		newForClassNamed: className2
		super: className1
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition packageNamed: packageName1.
	packageDefinition 
		addClassDefinition: classDefinition1;
		addClassDefinition: classDefinition2.

"load project1"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validation"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	theClass1 := Rowan globalNamed: className1.
	theClass2 := Rowan globalNamed: className2.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: theClass1 category = packageName1.
	self assert: theClass1 rowanPackageName = packageName1.
	self assert: (theClass1 categoryOfSelector: #foo) asString = 'accessing'.
	self assert: (theClass1 compiledMethodAt: #foo) rowanPackageName = packageName1.
	self assert: (theClass2 new perform: #foo) = 1.
	self assert: theClass2 category = packageName1.
	self assert: theClass2 rowanPackageName = packageName1.

"create new version of project"
	classDefinition1 := packageDefinition classDefinitions at: className1.
	packageDefinition removeClassDefinition: classDefinition1.

	ivNames := classDefinition1 instVarNames copy.
	ivNames add: 'ivar1'.
	classDefinition1 instVarNames: ivNames.
	classDefinition1 category: packageName2.

	packageDefinition := projectDefinition packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition1.

"load project1"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validation"
	self assert: (audit := project audit) isEmpty.
	oldClass1 := theClass1.
	oldClass2 := theClass2.
	theClass1 := Rowan globalNamed: className1.
	theClass2 := Rowan globalNamed: className2.
	self assert: oldClass1 ~~ theClass1.
	self assert: oldClass2 ~~ theClass2.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: theClass1 category = packageName2.
	self assert: theClass1 rowanPackageName = packageName2.
	self assert: (theClass1 categoryOfSelector: #foo) asString = 'accessing'.
	self assert: (theClass1 compiledMethodAt: #foo) rowanPackageName = packageName2.
	self assert: (theClass2 new perform: #foo) = 1.
	self assert: theClass2 category = packageName1.
	self assert: theClass2 rowanPackageName = packageName1.
%

category: 'tests-issue 123'
method: RwRowanProjectIssuesTest
testIssue123_moveExistingClassWithExtensionMethodsAndSubclassesToNewPackageAndNewClassVersion
	"https://github.com/dalehenrich/Rowan/issues/123"

"
    Create class Issue91 in Package RowanSample1-XXX.
    Add non-extension method .
     Using the class definition template, create a new version of Issue91 with new inst var 'abc' in RowanSample1-Extensions
"

	| projectName packageName1 packageName2 className1 className2 theClass1  theClass2 |
	projectName := 'Issue123_Project'.
	packageName1 := 'Issue123-Core'.
	packageName2 := 'Issue123-Extensions'.
	className1 := 'Issue123Class'.
	className2 := 'Issue123SubClass'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := Object
		rwSubclass: className1
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	theClass2 := (Rowan globalNamed: className1)
		rwSubclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass1  inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass1 new perform: #foo) = 1.
	self assert: theClass1 category = packageName1.
	self assert: theClass1 rowanPackageName = packageName1.
	self assert: (theClass1 categoryOfSelector: #foo) asString = ('*' , packageName2 asLowercase).
	self assert: (theClass1 compiledMethodAt: #foo) rowanPackageName = packageName2.
	self assert: (theClass2 new perform: #foo) = 1.
	self assert: theClass2 category = packageName1.
	self assert: theClass2 rowanPackageName = packageName1.

	theClass1 := Object
		rwSubclass: className1
		instVarNames: #( ivar1 )
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().

	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: theClass1 category = packageName2.
	self assert: theClass1 rowanPackageName = packageName2.
	self assert: (theClass1 categoryOfSelector: #foo) asString = ('*' , packageName2 asLowercase).
	self assert: (theClass1 compiledMethodAt: #foo) rowanPackageName = packageName2.
	self assert: (Rowan globalNamed: className2) ~~ theClass2.
	theClass2 := Rowan globalNamed: className2.
	self assert: (theClass2 new perform: #foo) = 1.
	self assert: theClass2 category = packageName1.
	self assert: theClass2 rowanPackageName = packageName1.
%

category: 'tests-issue 123'
method: RwRowanProjectIssuesTest
testIssue123_moveExistingClassWithExtensionMethodsToNewPackage
	"https://github.com/dalehenrich/Rowan/issues/123"

"
    Create class Issue91 in Package RowanSample1-XXX.
    Add extension method category, *rowansample1-extensions, in class Issue91
    Add method extendedMethod in new category.
    Verify by Show Changes that RowanSample1-Extensions package shows the new method was added.
    Using the class definition template, move the class to RowanSample1-Extensions
"

	| projectName packageName1 packageName2 className theClass  |
	projectName := 'Issue123_Project'.
	packageName1 := 'Issue123-Core'.
	packageName2 := 'Issue123-Extensions'.
	className := 'Issue123Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass  inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass new perform: #foo)= 1.
	self assert: theClass category = packageName1.
	self assert: theClass rowanPackageName = packageName1.
	self assert: (theClass categoryOfSelector: #foo) asString = ('*' , packageName2 asLowercase).
	self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName2.

	theClass := Object
		rwSubclass: className
		instVarNames: #( )
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().

	self assert: theClass category = packageName2.
	self assert: theClass rowanPackageName = packageName2.
	self assert: (theClass new perform: #foo) = 1.
	self assert: (theClass categoryOfSelector: #foo) asString = ('*' , packageName2 asLowercase).
	self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName2.
%

category: 'tests-issue 123'
method: RwRowanProjectIssuesTest
testIssue123_moveExistingClassWithExtensionMethodsToNewPackageAndNewClassVersion
	"https://github.com/dalehenrich/Rowan/issues/123"

"
    Create class Issue91 in Package RowanSample1-XXX.
    Add extension method category, *rowansample1-extensions, in class Issue91
    Add method extendedMethod in new category.
    Verify by Show Changes that RowanSample1-Extensions package shows the new method was added.
    Using the class definition template, create a new version of Issue91 with new inst var 'abc' in RowanSample1-Extensions
    Verify Issue91 has moved to RowanSample1-Extensions package.
    Bug is that method extendedMethod was not brought into the new class version. No methods are shown.
"

	| projectName packageName1 packageName2 className theClass  |
	projectName := 'Issue123_Project'.
	packageName1 := 'Issue123-Core'.
	packageName2 := 'Issue123-Extensions'.
	className := 'Issue123Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass  inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass new perform: #foo) = 1.
	self assert: theClass category = packageName1.
	self assert: theClass rowanPackageName = packageName1.
	self assert: (theClass categoryOfSelector: #foo) asString = ('*' , packageName2 asLowercase).
	self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName2.

	theClass := Object
		rwSubclass: className
		instVarNames: #( ivar1 )
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().

	self assert: (theClass new perform: #foo) = 1.
	self assert: theClass category = packageName2.
	self assert: theClass rowanPackageName = packageName2.
	self assert: (theClass categoryOfSelector: #foo) asString = ('*' , packageName2 asLowercase).
	self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName2.
%

category: 'tests-issue 123'
method: RwRowanProjectIssuesTest
testIssue123_moveExistingClassWithMethodsAndSubclassesToNewPackageAndNewClassVersion
	"https://github.com/dalehenrich/Rowan/issues/123"

"
    Create class Issue91 in Package RowanSample1-XXX.
    Add non-extension method .
     Using the class definition template, create a new version of Issue91 with new inst var 'abc' in RowanSample1-Extensions
"

	| projectName packageName1 packageName2 className1 className2 theClass1  theClass2 x oldClass |
	projectName := 'Issue123_Project'.
	packageName1 := 'Issue123-Core'.
	packageName2 := 'Issue123-Extensions'.
	className1 := 'Issue123Class'.
	className2 := 'Issue123SubClass'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass1 := Object
		rwSubclass: className1
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	theClass2 := (Rowan globalNamed: className1)
		rwSubclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass1  inPackage: packageName1 inProjectNamed: projectName validate: false.

	self assert: (theClass1 new perform: #foo) = 1.
	self assert: theClass1 category = packageName1.
	self assert: theClass1 rowanPackageName = packageName1.
	self assert: (theClass1 categoryOfSelector: #foo) asString = 'other'.
	self assert: (theClass1 compiledMethodAt: #foo) rowanPackageName = packageName1.
	self assert: (theClass2 new perform: #foo) = 1.
	self assert: theClass2 category = packageName1.
	self assert: theClass2 rowanPackageName = packageName1.

	oldClass := theClass1.
	theClass1 := Object
		rwSubclass: className1
		instVarNames: #( ivar1 )
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().

	self assert: oldClass ~~ theClass1.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: (theClass1 new perform: #foo) = 1.
	self assert: theClass1 category = packageName2.
	self assert: theClass1 rowanPackageName = packageName2.
	self assert: (theClass1 categoryOfSelector: #foo) asString = 'other'.
	self assert: (theClass1 compiledMethodAt: #foo) rowanPackageName = packageName2.
	self assert: (x := Rowan globalNamed: className2) ~~ theClass2.
	theClass2 := Rowan globalNamed: className2.
	self assert: (theClass2 new perform: #foo) = 1.
	self assert: theClass2 category = packageName1.
	self assert: theClass2 rowanPackageName = packageName1
%

category: 'tests-issue 123'
method: RwRowanProjectIssuesTest
testIssue123_moveExistingClassWithMethodsToNewPackage
	"https://github.com/dalehenrich/Rowan/issues/123"

"
    Create class Issue91 in Package RowanSample1-XXX.
    Add non-extension method .
     Using the class definition template, move the class to RowanSample1-Extensions
"

	| projectName packageName1 packageName2 className theClass  |
	projectName := 'Issue123_Project'.
	packageName1 := 'Issue123-Core'.
	packageName2 := 'Issue123-Extensions'.
	className := 'Issue123Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass  inPackage: packageName1 inProjectNamed: projectName validate: false.

	self assert: (theClass new perform: #foo) = 1.
	self assert: theClass category = packageName1.
	self assert: theClass rowanPackageName = packageName1.
	self assert: (theClass categoryOfSelector: #foo) asString = 'other'.
	self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName1.

	theClass := Object
		rwSubclass: className
		instVarNames: #( )
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().

	self assert: (theClass new perform: #foo) = 1.
	self assert: theClass category = packageName2.
	self assert: theClass rowanPackageName = packageName2.
	self assert: (theClass categoryOfSelector: #foo) asString = 'other'.
	self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName2.
%

category: 'tests-issue 123'
method: RwRowanProjectIssuesTest
testIssue123_moveExistingClassWithMethodsToNewPackageAndNewClassVersion
	"https://github.com/dalehenrich/Rowan/issues/123"

"
    Create class Issue91 in Package RowanSample1-XXX.
    Add non-extension method .
     Using the class definition template, create a new version of Issue91 with new inst var 'abc' in RowanSample1-Extensions
"

	| projectName packageName1 packageName2 className theClass oldClass |
	projectName := 'Issue123_Project'.
	packageName1 := 'Issue123-Core'.
	packageName2 := 'Issue123-Extensions'.
	className := 'Issue123Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	self _addOrUpdateMethod: 'foo ^1' forBehavior: theClass  inPackage: packageName1 inProjectNamed: projectName validate: false.

	self assert: (theClass new perform: #foo) = 1.
	self assert: theClass category = packageName1.
	self assert: theClass rowanPackageName = packageName1.
	self assert: (theClass categoryOfSelector: #foo) asString = 'other'.
	self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName1.

	oldClass := theClass.
	theClass := Object
		rwSubclass: className
		instVarNames: #( ivar1 )
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName2
		options: #().

	self assert: oldClass ~= theClass.
	self assert: (theClass new perform: #foo) = 1.
	self assert: (theClass new perform: #foo) = 1.
	self assert: theClass category = packageName2.
	self assert: theClass rowanPackageName = packageName2.
	self assert: (theClass categoryOfSelector: #foo) asString = 'other'.
	self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName2.
%

category: 'tests-issue 125'
method: RwRowanProjectIssuesTest
testIssue125_1

	"https://github.com/dalehenrich/Rowan/issues/125"

	"move a method to an extension package ... unchanged"

	"RwGsPatchSetBasic does not understand:
		addPatchedExtendedClassMethodProperties:inClass:inPackage:inProject:
		addPatchedExtendedInstanceMethodProperties:inClass:inPackage:inProject:
	"
	| projectName packageName1 packageName2 className theClass  | 
	projectName := 'Issue125_Project'.
	packageName1 := 'Issue125-Core'.
	packageName2 := 'Issue125-Extensions'.
	className := 'Issue125Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	theClass rwCompileMethod: 'foo ^1' category: 'accessing'.

	self assert: (theClass new perform: #foo) = 1.
	self assert: (theClass categoryOfSelector: #foo) asString = 'accessing'.

	theClass rwCompileMethod: 'foo ^1' category: '*' , packageName2 asLowercase.

	self assert: (theClass new perform: #foo) = 1.
	self assert: (theClass categoryOfSelector: #foo) asString = ('*' , packageName2 asLowercase)
%

category: 'tests-issue 125'
method: RwRowanProjectIssuesTest
testIssue125_2

	"https://github.com/dalehenrich/Rowan/issues/125"

	"move a method from an extension method ... unchanged"

	"RwGsPatchSetBasic does not understand:
		addPatchedExtendedClassMethodProperties:inClass:inPackage:inProject:
		addPatchedExtendedInstanceMethodProperties:inClass:inPackage:inProject:
	"
	| projectName packageName1 packageName2 className theClass  x |
	projectName := 'Issue125_Project'.
	packageName1 := 'Issue125-Core'.
	packageName2 := 'Issue125-Extensions'.
	className := 'Issue125Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	theClass rwCompileMethod: 'foo ^1' category: '*' , packageName2 asLowercase.

	self assert: (theClass new perform: #foo) = 1.
	self assert: (theClass categoryOfSelector: #foo) asString = ('*' , packageName2 asLowercase).

	theClass rwCompileMethod: 'foo ^1' category: 'accessing'.

	self assert: (theClass new perform: #foo) = 1.
	self assert: (x := (theClass categoryOfSelector: #foo) asString) = 'accessing'
%

category: 'tests-issue 125'
method: RwRowanProjectIssuesTest
testIssue125_3

	"https://github.com/dalehenrich/Rowan/issues/125"

	"move a method from an extension method in one package ... unchanged to an extension method in another package"

	"RwGsPatchSetBasic does not understand:
		addPatchedExtendedClassMethodProperties:inClass:inPackage:inProject:
		addPatchedExtendedInstanceMethodProperties:inClass:inPackage:inProject:
	"
	| projectName packageName1 packageName2 packageName3 className theClass  |
	projectName := 'Issue125_Project'.
	packageName1 := 'Issue125-Core'.
	packageName2 := 'Issue125-Extensions1'.
	packageName3 := 'Issue125-Extensions2'.
	className := 'Issue125Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName3 toProjectNamed: projectName validate: false.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	theClass rwCompileMethod: 'foo ^1' category: '*' , packageName2 asLowercase.

	self assert: (theClass new perform: #foo) = 1.
	self assert: (theClass categoryOfSelector: #foo) asString = ('*' , packageName2 asLowercase).

	theClass rwCompileMethod: 'foo ^1' category:'*' , packageName3 asLowercase.

	self assert: (theClass new perform: #foo) = 1.
	self assert: (theClass categoryOfSelector: #foo) asString = ('*' , packageName3 asLowercase).
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_254_move_class_to_package

	"https://github.com/dalehenrich/Rowan/issues/185"

	"https://github.com/dalehenrich/Rowan/issues/254"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core1'.
	packageName2 := 'Issue185-Core2'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].


	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition classDefinitions removeKey: classDefinition key.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_254_rename_package_move_class_to_symbolDict_3

	"https://github.com/dalehenrich/Rowan/issues/185"

	"initial load uses custom symbol dictionary, second load uses default symbol dictionary -- change category of class"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		ar oldClass x y project audit |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core'.
	packageName2 := 'Issue185-RenamedCore'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: nil forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	classDefinition category: packageName2.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (x := (ar first at: 1) name) = (y := self _symbolDictionaryName1 asSymbol).

	self assert: class == oldClass.
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_254_rename_package_move_class_to_symbolDict_add_remove_and_remove_methods_1

	"https://github.com/dalehenrich/Rowan/issues/185"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		ar oldClass x y project audit |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core'.
	packageName2 := 'Issue185-RenamedCore'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #method2) = 2.

	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: nil forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	classDefinition category: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	classDefinition
		removeInstanceMethod: #method2;
		removeInstanceMethod: #method3;
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^5');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (x := (ar first at: 1) name) = (y := self _symbolDictionaryName1 asSymbol).
	self assert: (class new perform: #method1) = 1.
	self should: [ (class new perform: #method2) = 2 ] raise: MessageNotUnderstood.
	self assert: (x := class new perform: #method3) = 5.
	self assert: (class new perform: #method4) = 4.

	self assert: class == oldClass.
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_254_rename_package_move_class_to_symbolDict_add_remove_and_remove_methods_2

	"https://github.com/dalehenrich/Rowan/issues/185"

	"minimal version of #testIssue185_rename_package_move_class_to_symbolDict_add_remove_and_remove_methods_1 isolating a particular failure
		that I'm trying to resolve"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class x project audit |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core'.
	packageName2 := 'Issue185-RenamedCore'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: nil forPackageNamed: packageName2.


	packageDefinition := projectDefinition2 packageNamed: packageName2.
	classDefinition category: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	classDefinition
		removeInstanceMethod: #method3;
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^5').

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.

	self assert: (x := class new perform: #method3) = 5.
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_move_class_to_package

	"https://github.com/dalehenrich/Rowan/issues/185"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core1'.
	packageName2 := 'Issue185-Core2'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].


	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition classDefinitions removeKey: classDefinition key.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_rename_package

	"https://github.com/dalehenrich/Rowan/issues/185"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core'.
	packageName2 := 'Issue185-RenamedCore'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].


	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		yourself.
	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_rename_package_move_class_to_symbolDict_1

	"https://github.com/dalehenrich/Rowan/issues/185"

	"initial load uses default symbol dictionary, second load uses custom symbol dictionary"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		ar oldClass project audit |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core'.
	packageName2 := 'Issue185-RenamedCore'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.


	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class == oldClass.
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_rename_package_move_class_to_symbolDict_2

	"https://github.com/dalehenrich/Rowan/issues/185"

	"initial load uses custom symbol dictionary, second load uses default symbol dictionary"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		ar oldClass x y project audit |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core'.
	packageName2 := 'Issue185-RenamedCore'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: nil forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (x := (ar first at: 1) name) = (y := self _symbolDictionaryName1 asSymbol).

	self assert: class == oldClass.
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_rename_package_move_class_to_symbolDict_3

	"https://github.com/dalehenrich/Rowan/issues/185"

	"initial load uses custom symbol dictionary, second load uses default symbol dictionary -- change category of class"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		ar oldClass x y project audit |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core'.
	packageName2 := 'Issue185-RenamedCore'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: nil forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	classDefinition category: packageName2.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (x := (ar first at: 1) name) = (y := self _symbolDictionaryName1 asSymbol).

	self assert: class == oldClass.
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_rename_package_move_class_to_symbolDict_add_remove_and_remove_methods_1

	"https://github.com/dalehenrich/Rowan/issues/185"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		ar oldClass x y project audit |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core'.
	packageName2 := 'Issue185-RenamedCore'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #method2) = 2.

	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: nil forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	classDefinition category: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	classDefinition
		removeInstanceMethod: #method2;
		removeInstanceMethod: #method3;
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^5');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (x := (ar first at: 1) name) = (y := self _symbolDictionaryName1 asSymbol).
	self assert: (class new perform: #method1) = 1.
	self should: [ (class new perform: #method2) = 2 ] raise: MessageNotUnderstood.
	self assert: (x := class new perform: #method3) = 5.
	self assert: (class new perform: #method4) = 4.

	self assert: class == oldClass.
%

category: 'tests-issue 185'
method: RwRowanProjectIssuesTest
testIssue185_rename_package_move_class_to_symbolDict_add_remove_and_remove_methods_2

	"https://github.com/dalehenrich/Rowan/issues/185"

	"minimal version of #testIssue185_rename_package_move_class_to_symbolDict_add_remove_and_remove_methods_1 isolating a particular failure
		that I'm trying to resolve"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class x project audit |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core'.
	packageName2 := 'Issue185-RenamedCore'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: nil forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	classDefinition category: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	classDefinition
		removeInstanceMethod: #method3;
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^5').

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.

	self assert: (x := class new perform: #method3) = 5.
%

category: 'tests-issue 198'
method: RwRowanProjectIssuesTest
testIssue198A

	"https://github.com/dalehenrich/Rowan/issues/198"

	"in attempting to reproduce issue #198, hit this issue. See https://github.com/dalehenrich/Rowan/issues/198#issuecomment-391831224
		for characterization."

	"subclass of class with new version, which is referenced by a method in a third class, is moved to a different package ... 
		failure occurs when the new superclass version and move to different package occurs in one atomic load. "

	| projectName projectNames packageName1 packageName2 className1 className2 theClass 
		theSubclass projectDefinition theClassDefinition theSubclassDefinition 
		packageDefinition1 packageDefinition2 |

	projectName := 'Issue198Project'.
	projectNames := {projectName}.
	packageName1 := 'Issue198-Core'.
	packageName2 := 'Issue198-Deprecated'.
	className1 := 'Issue198Class'.
	className2 := 'Issue198Subclass'.

	self
		_loadProjectDefinition: projectName
		packageNames: {packageName1. packageName2}
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: ''.

	theClass := Object
		rwSubclass: className1
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	theSubclass := theClass
		rwSubclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	packageDefinition1 := projectDefinition packageNamed: packageName1.
	packageDefinition2 := projectDefinition packageNamed: packageName2.

	theClassDefinition := packageDefinition1 classDefinitions at: className1.
	theClassDefinition instVarNames: #( 'ivar1').																	"force new version of className1 and className2"

	theSubclassDefinition := packageDefinition1 classDefinitions at: className2.
	packageDefinition1 classDefinitions removeKey: theSubclassDefinition key.
	packageDefinition2 classDefinitions at: theSubclassDefinition key put: theSubclassDefinition.	"move subclass to different package"

	Rowan projectTools load loadProjectDefinition: projectDefinition.

	self assert: theSubclass rowanPackageName = packageName2.
%

category: 'tests-issue 198'
method: RwRowanProjectIssuesTest
testIssue198B

	"https://github.com/dalehenrich/Rowan/issues/198"

	"subclass of class with new version, which is referenced by a method in a third class, is moved to a different package ... 
		failure occurs when the new superclass version and move to different package occurs in one atomic load. "

	| projectName projectNames packageName1 packageName2 className1 className2 className3 theClass 
		theSubclass theReferenceClass projectDefinition theClassDefinition theSubclassDefinition 
		packageDefinition1 packageDefinition2 theReferenceClassDefinition |

	projectName := 'Issue198Project'.
	projectNames := {projectName}.
	packageName1 := 'Issue198-Core'.
	packageName2 := 'Issue198-Deprecated'.
	className1 := 'Issue198Class'.
	className2 := 'Issue198Subclass'.
	className3 := 'Issue198ReferenceClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: {packageName1. packageName2}
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: ''.

	theClass := Object
		rwSubclass: className1
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	theSubclass := theClass
		rwSubclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	theReferenceClass := Object
		rwSubclass: className3
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	packageDefinition1 := projectDefinition packageNamed: packageName1.
	packageDefinition2 := projectDefinition packageNamed: packageName2.

	theClassDefinition := packageDefinition1 classDefinitions at: className1.
	theClassDefinition instVarNames: #( 'ivar1').																	"force new version of className1 and className2"

	theSubclassDefinition := packageDefinition1 classDefinitions at: className2.
	packageDefinition1 classDefinitions removeKey: theSubclassDefinition key.
	packageDefinition2 classDefinitions at: theSubclassDefinition key put: theSubclassDefinition.	"move subclass to different package"

	theReferenceClassDefinition := packageDefinition1 classDefinitions at: className3.
	theReferenceClassDefinition addInstanceMethodDefinition: 
		(RwMethodDefinition
						newForSelector: #'boom'
						protocol: 'accessing'
						source: 'boom ^ ', className2).																"add method referencing moved class"

	Rowan projectTools load loadProjectDefinition: projectDefinition.

	self assert: ((Rowan globalNamed: className3) new perform: #boom) == (Rowan globalNamed: className2).
	self assert: theSubclass rowanPackageName = packageName2.
%

category: 'tests-issue 198'
method: RwRowanProjectIssuesTest
testIssue198C

	"https://github.com/dalehenrich/Rowan/issues/198"

	"Need to make sure that classes moved between packages (unrelated to new class versions) are processed correctly"

	| projectName projectNames packageName1 packageName2 className1 className2 className3 theClass 
		theSubclass theUnrelatedMovedClass projectDefinition theClassDefinition 
		packageDefinition1 packageDefinition2 theUnrelatedMovedClassDefinition |

	projectName := 'Issue198Project'.
	projectNames := {projectName}.
	packageName1 := 'Issue198-Core'.
	packageName2 := 'Issue198-Deprecated'.
	className1 := 'Issue198Class'.
	className2 := 'Issue198Subclass'.
	className3 := 'Issue198UnrelatedMovedClass'.

	self
		_loadProjectDefinition: projectName
		packageNames: {packageName1. packageName2}
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: ''.

	theClass := Object
		rwSubclass: className1
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	theSubclass := theClass
		rwSubclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	theUnrelatedMovedClass := Object
		rwSubclass: className3
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	packageDefinition1 := projectDefinition packageNamed: packageName1.
	packageDefinition2 := projectDefinition packageNamed: packageName2.

	theClassDefinition := packageDefinition1 classDefinitions at: className1.
	theClassDefinition instVarNames: #( 'ivar1').																	"force new version of className1 and className2"

	theUnrelatedMovedClassDefinition := packageDefinition1 classDefinitions at: className3.
	packageDefinition1 classDefinitions removeKey: theUnrelatedMovedClassDefinition key.
	packageDefinition2 classDefinitions at: theUnrelatedMovedClassDefinition key put: theUnrelatedMovedClassDefinition.	"move unrelated moved class to different package"

	Rowan projectTools load loadProjectDefinition: projectDefinition.
%

category: 'tests-issue 199'
method: RwRowanProjectIssuesTest
testIssue199

	"https://github.com/dalehenrich/Rowan/issues/199"

	"rename superclass of a class"

	| projectName projectNames packageName1  className1 className2 className3 theClass theSubclass projectDefinition theClassDefinition 
		theSubclassDefinition packageDefinition1 |

	projectName := 'Issue199Project'.
	projectNames := {projectName}.
	packageName1 := 'Issue199-Core'.
	className1 := 'Issue199Class'.
	className2 := 'Issue199Subclass'.
	className3 := 'Issue199ClassNew'.

	self
		_loadProjectDefinition: projectName
		packageNames: {packageName1}
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: ''.

	theClass := Object
		rwSubclass: className1
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	theSubclass := theClass
		rwSubclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	packageDefinition1 := projectDefinition packageNamed: packageName1.

	theClassDefinition := packageDefinition1 classDefinitions at: className1.
	packageDefinition1 classDefinitions removeKey: theClassDefinition key.
	theClassDefinition name: className3.
	packageDefinition1 addClassDefinition: theClassDefinition.										"rename className1 to className3"

	theSubclassDefinition := packageDefinition1 classDefinitions at: className2.
	theSubclassDefinition superclassName: className3.												"change className2 superclass to className3"

	Rowan projectTools load loadProjectDefinition: projectDefinition.
%

category: 'tests-issue 206'
method: RwRowanProjectIssuesTest
testIssue206_move_extension_method_to_new_package

	"https://github.com/dalehenrich/Rowan/issues/206"

	"based on testIssue185_move_extension_method_to_new_package_1"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		classExtensionDefinition packageName3 |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core1'.
	packageName2 := 'Issue185-Core2'.
	packageName3 := 'Issue185-Core3'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	"create extension method in different package"
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName2 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #mover) = 2.

	"move the method to new package"
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition classExtensions removeKey: className.										"this is the source of the bug ... as a new class extensions without the proper class name is created
																															during the comparison"

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName3 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"validate"
	self assert: (class new perform: #mover) = 2. "method not installed when class extension does not have a proper class name"
%

category: 'tests-issue 208'
method: RwRowanProjectIssuesTest
testIssue208_move_method_from_project_to_project

	"create class and method in same project/package"

	"move class to one package in new project and method to another package in new project"

	"simulating extension method moves during an adopt"

	"simplification of RwRowanSample4Test>>testIssue208_adopt_load"

	| projectName1 projectName2 packageName1 packageName2 packageName3 className projectDefinition1 classDefinition
		packageDefinition projectSetDefinition projectDefinition2 classExtensionDefinition class ar symDict registry oldClass |
	projectName1 := 'Issue208_moveMethodBetweenProjects1'.
	projectName2 := 'Issue208_moveMethodBetweenProjects2'.
	packageName1 := 'Issue208-Core1'.
	packageName2 := 'Issue208-Core2'.
	packageName3 := 'Issue208-Extension2'.
	className := 'Issue208Class'.

	{projectName1. projectName2}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project 1"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName1)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load project1"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validation"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

"create project2"
	projectDefinition2 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName2)
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName2;
		yourself.

	packageDefinition := projectDefinition2 packageNamed: packageName2.

	classDefinition 
		category: packageName2;
		removeInstanceMethod: #method1.
	packageDefinition addClassDefinition: classDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: '*', packageName3 asLowercase
					source: 'method1 ^1').
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"load project2"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validation"
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: oldClass == class.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName3.
	self assert: (class new perform: #method1) = 1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.
%

category: 'tests-issue 217'
method: RwRowanProjectIssuesTest
testIssue217

	"https://github.com/dalehenrich/Rowan/issues/217"

	| spec specExportString |
	[spec := (Rowan image _projectForNonTestProject: 'Rowan') specification asSpecification ] 
		on: Deprecated 
		do: [:ex | 
			"ignore any Deprecation errors ... we're specification testing the speciciation"
			ex resume ].
	specExportString := STON toStringPretty: spec.
	self assert: (specExportString includes: Character lf).
%

category: 'tests-issue 24'
method: RwRowanProjectIssuesTest
testIssue24_addProject

	| projectName |
	projectName := 'Issue24_addProject'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _writeProjectNamed: projectName
%

category: 'tests-issue 24'
method: RwRowanProjectIssuesTest
testIssue24_addRemovePackage

	| projectName packageName |
	projectName := 'Issue24_addRemovePackage'.
	packageName := 'Issue24-Core'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _writeProjectNamed: projectName.

	self _addPackageNamed: packageName toProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	self _removePackageNamed: packageName from: projectName.

	self _writeProjectNamed: projectName.
%

category: 'tests-issue 24'
method: RwRowanProjectIssuesTest
testIssue24_addUpdateRemoveClass

	| projectName packageName className  |
	projectName := 'Issue24_addUpdateRemoveClass'.
	packageName := 'Issue24-Core'.
	className := 'Issue24Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _writeProjectNamed: projectName.

	self _addPackageNamed: packageName toProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	self _addClassNamed: className toPackageNamed: packageName inProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	self _updateClassNamed: className toPackageNamed: packageName inProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	self _removeClassNamed: className fromProjectNamed: projectName.

	self _writeProjectNamed: projectName.
%

category: 'tests-issue 24'
method: RwRowanProjectIssuesTest
testIssue24_addUpdateRemoveMethods

	| projectName packageName className theClass |
	projectName := 'Issue24_addUpdateRemoveMethods'.
	packageName := 'Issue24-Core'.
	className := 'Issue24Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _writeProjectNamed: projectName.

	self _addPackageNamed: packageName toProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	theClass := self _addClassNamed: className toPackageNamed: packageName inProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	self _addOrUpdateMethod:  'foo ^''foo''' forBehavior: theClass inPackage: packageName inProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	self _addOrUpdateMethod:  'foo ^''foo''' forBehavior: theClass class inPackage: packageName inProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	self _addOrUpdateMethod:  'foo ^''bar''' forBehavior: theClass inPackage: packageName inProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	self _addOrUpdateMethod:  'foo ^''bar''' forBehavior: theClass class inPackage: packageName inProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	self _removeSelector: #foo fromBehavior: theClass inProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	self _removeSelector: #foo fromBehavior: theClass class inProjectNamed: projectName.

	self _writeProjectNamed: projectName.
%

category: 'tests-issue 24'
method: RwRowanProjectIssuesTest
testIssue24_loadProject

	| projectName packageName className theClass project |
	projectName := 'Issue24_loadProject'.
	packageName := 'Issue24-Core'.
	className := 'Issue24Class'.

	self _createLoadedProjectNamed: projectName packageNames: {packageName} root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'  validate: false.
	theClass := self _addClassNamed: className toPackageNamed: packageName inProjectNamed: projectName  validate: false.
	self _addOrUpdateMethod:  'foo ^''foo''' forBehavior: theClass inPackage: packageName inProjectNamed: projectName  validate: false.
	self _addOrUpdateMethod:  'foo ^''foo''' forBehavior: theClass class inPackage: packageName inProjectNamed: projectName  validate: false.
	self _writeProjectNamed: projectName  validate: false.

	project := RwProject newNamed: projectName.

	self deny: project isDirty.

	Rowan projectTools load loadProjectNamed: projectName.

	self deny: project isDirty.

	self _addOrUpdateMethod:  'foo ^''bar''' forBehavior: theClass inPackage: packageName inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod:  'foo ^''bar''' forBehavior: theClass class inPackage: packageName inProjectNamed: projectName validate: false.

	self assert: project isDirty.
	self assert: (theClass new perform: #foo) = 'bar'.

	Rowan projectTools load loadProjectNamed: projectName.

	self deny: project isDirty.

	theClass := Rowan image objectNamed: className.
	self assert: theClass notNil.

	self _removeClassNamed: className fromProjectNamed: projectName.

	theClass := Rowan image objectNamed: className.
	self assert: theClass isNil.

	self assert: project isDirty.

	Rowan projectTools load loadProjectNamed: projectName.

	self deny: project isDirty.

	theClass := Rowan image objectNamed: className.
	self assert: theClass notNil.
	self assert: (theClass new perform: #foo) = 'foo'.
%

category: 'tests-issue 24'
method: RwRowanProjectIssuesTest
testIssue24_moveClassBetweenPackages

	"move a class from one package to another"

	| projectName packageName1 packageName2 className testClass |
	projectName := 'Issue24_moveClassBetweenPackages'.
	packageName1 := 'Issue24-Core1'.
	packageName2 := 'Issue24-Core2'.
	className := 'Issue24Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	self _writeProjectNamed: projectName.

	self _addClassNamed: className toPackageNamed: packageName1 inProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	testClass := Rowan globalNamed: className.
	self assert: testClass rowanPackageName = packageName1.

	self _updateClassNamed: className toPackageNamed: packageName2 inProjectNamed: projectName.

	self _writeProjectNamed: projectName.

	testClass := Rowan globalNamed: className.
	self assert: testClass rowanPackageName = packageName2
%

category: 'tests-issue 24'
method: RwRowanProjectIssuesTest
testIssue24_moveClassBetweenProjects

	| projectName1 projectName2 packageName1 packageName2 className testClass |
	projectName1 := 'Issue24_moveClassBetweenProjects1'.
	projectName2 := 'Issue24_moveClassBetweenProjects2'.
	packageName1 := 'Issue24-Core1'.
	packageName2 := 'Issue24-Core2'.
	className := 'Issue24Class'.

	self _createLoadedProjectNamed: projectName1 root: self _testRowanProjectsSandbox pathString,'/rowanIssuesProject1/'.
	self _createLoadedProjectNamed: projectName2 root: self _testRowanProjectsSandbox pathString,'/rowanIssuesProject2/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName1 validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName2 validate: false.

	self _writeProjectNamed: projectName1.
	self _writeProjectNamed: projectName2.

	self _addClassNamed: className toPackageNamed: packageName1 inProjectNamed: projectName1.

	self _writeProjectNamed: projectName1.

	testClass := Rowan globalNamed: className.
	self assert: testClass rowanPackageName = packageName1.

	self _updateClassNamed: className toPackageNamed: packageName2 inProjectNamed: projectName2.

	self _writeProjectNamed: projectName1.
	self _writeProjectNamed: projectName2.

	testClass := Rowan globalNamed: className.
	self assert: testClass rowanPackageName = packageName2
%

category: 'tests-issue 24'
method: RwRowanProjectIssuesTest
testIssue24_moveMethodBetweenPackages

	"move a method from one package to another"

	| projectName packageName1 packageName2 className theClass |

	projectName := 'Issue24_moveMethodBetweenPackages'.
	packageName1 := 'Issue24-Core1'.
	packageName2 := 'Issue24-Core2'.
	className := 'Issue24Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.

	self _writeProjectNamed: projectName.

	theClass := self _addClassNamed: className toPackageNamed: packageName1 inProjectNamed: projectName.

	self _addOrUpdateMethod:  'foo ^''foo''' forBehavior: theClass inPackage: packageName1 inProjectNamed: projectName validate: false.

	self _writeProjectNamed: projectName.

	self _addOrUpdateMethod:  'foo ^''foo''' forBehavior: theClass inPackage: packageName2 inProjectNamed: projectName.

	self _writeProjectNamed: projectName.
%

category: 'tests-issue 24'
method: RwRowanProjectIssuesTest
testIssue24_moveMethodBetweenProjects

	"move a method from one package to another"

	| projectName1 projectName2 packageName1 packageName2 className theClass |
	projectName1 := 'Issue24_moveMethodBetweenProjects1'.
	projectName2 := 'Issue24_moveMethodBetweenProjects2'.
	packageName1 := 'Issue24-Core1'.
	packageName2 := 'Issue24-Core2'.
	className := 'Issue24Class'.

	self _createLoadedProjectNamed: projectName1 root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject1/'.
	self _createLoadedProjectNamed: projectName2 root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject2/'.

	self _addPackageNamed: packageName1 toProjectNamed: projectName1 validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName2 validate: false.

	self _writeProjectNamed: projectName1.
	self _writeProjectNamed: projectName2.

	theClass := self _addClassNamed: className toPackageNamed: packageName1 inProjectNamed: projectName1.

	self _addOrUpdateMethod:  'foo ^''foo''' forBehavior: theClass inPackage: packageName1 inProjectNamed: projectName1 validate: false.

	self _writeProjectNamed: projectName1.

	self _addOrUpdateMethod:  'foo ^''foo''' forBehavior: theClass inPackage: packageName2 inProjectNamed: projectName2.

	self _writeProjectNamed: projectName1.
	self _writeProjectNamed: projectName2.
%

category: 'tests-issue 255'
method: RwRowanProjectIssuesTest
testIssue255_class_modification_constraints

	"test modifying constraints"
	"https://github.com/dalehenrich/Rowan/issues/255"

	| projectName  packageName projectDefinition classDefinition1 packageDefinition className1 
		projectSetDefinition class1 oldClass x |

	projectName := 'Issue255'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #(ivar1)
		classinstvars: #()
		classvars: #()
		category: 'category'
		comment: 'comment'
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: class1 instVarNames = #(ivar1).
	self assert: (x := class1 classVarNames asSortedCollection) = #() asSortedCollection.
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.

"modify class -- no new version"
	classDefinition1
		classVarNames: #(Cvar1 Cvar2 Cvar3);
		category: 'newer category';
		comment: 'newer comment';
		gs_constraints: { { 'ivar1' . 'Association' } }.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass := class1.
	class1 := Rowan globalNamed: className1.
	self assert: oldClass == class1.
	self assert: class1 instVarNames = #(ivar1).
	self assert: (x := class1 classVarNames asSortedCollection) = #(Cvar1 Cvar2 Cvar3) asSortedCollection.
	self assert: class1 category = 'newer category'.
	self assert: class1 comment = 'newer comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar1' . Association } }).

"modify class -- new version"
	classDefinition1
		instVarNames: #(ivar1 ivar2);
		classVarNames: #(Cvar1 Cvar2 Cvar3);
		category: 'new category';
		comment: 'new comment';
		gs_constraints: { { 'ivar1' . 'Association' } . { 'ivar2' . 'Number' } }.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass := class1.
	class1 := Rowan globalNamed: className1.
	self assert: oldClass ~~ class1.
	self assert: class1 instVarNames = #(ivar1 ivar2).
	self assert: (x := class1 classVarNames asSortedCollection) = #(Cvar1 Cvar2 Cvar3) asSortedCollection.
	self assert: class1 category = 'new category'.
	self assert: class1 comment = 'new comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar1' . Association } . { #'ivar2' . Number } }).
%

category: 'tests-issue 255'
method: RwRowanProjectIssuesTest
testIssue255_class_modification_no_constraints

	"test modifying constraints"
	"https://github.com/dalehenrich/Rowan/issues/255"

	| projectName  packageName projectDefinition classDefinition1 packageDefinition className1 
		projectSetDefinition class1 oldClass x |

	projectName := 'Issue255'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #(ivar1)
		classinstvars: #()
		classvars: #()
		category: 'category'
		comment: 'comment'
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: class1 instVarNames = #(ivar1).
	self assert: (x := class1 classVarNames asSortedCollection) = #() asSortedCollection.
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.

"modify class -- no new version"
	classDefinition1
		classVarNames: #(Cvar1 Cvar2 Cvar3);
		category: 'newer category';
		comment: 'newer comment'.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass := class1.
	class1 := Rowan globalNamed: className1.
	self assert: oldClass == class1.
	self assert: class1 instVarNames = #(ivar1).
	self assert: (x := class1 classVarNames asSortedCollection) = #(Cvar1 Cvar2 Cvar3) asSortedCollection.
	self assert: class1 category = 'newer category'.
	self assert: class1 comment = 'newer comment'.

"modify class -- new version"
	classDefinition1
		instVarNames: #(ivar1 ivar2);
		classVarNames: #(Cvar1 Cvar2 Cvar3);
		category: 'new category';
		comment: 'new comment'.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass := class1.
	class1 := Rowan globalNamed: className1.
	self assert: oldClass ~~ class1.
	self assert: class1 instVarNames = #(ivar1 ivar2).
	self assert: (x := class1 classVarNames asSortedCollection) = #(Cvar1 Cvar2 Cvar3) asSortedCollection.
	self assert: class1 category = 'new category'.
	self assert: class1 comment = 'new comment'.
%

category: 'tests-issue 255'
method: RwRowanProjectIssuesTest
testIssue255_constraints

	"test modifying constraints"
	"https://github.com/dalehenrich/Rowan/issues/255"

	| projectName  packageName projectDefinition classDefinition1 packageDefinition className1 projectSetDefinition class1 |
	projectName := 'Issue255'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #(ivar1)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition1 gs_constraints: { { 'ivar1' . 'Association' } }.


	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: (class1 _constraintsEqual: { { #'ivar1' . Association } })
%

category: 'tests-issue 255'
method: RwRowanProjectIssuesTest
testIssue255_external_constraints

	"basic test case"
	"https://github.com/dalehenrich/Rowan/issues/255"

	| projectName  packageName projectDefinition classDefinition1 classDefinition2 classDefinition3 packageDefinition className1 className2 projectSetDefinition 
		class1 class2 className3 class3 |
	projectName := 'Issue255'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.
	className2 := 'Issue255Class2'.
	className3 := 'Issue255Array3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #(ivar1)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition1 gs_constraints: { { 'ivar1' . 'Association' } }.

	classDefinition2 := RwClassDefinition
		newForClassNamed: className2
		super: 'Object'
		instvars: #(ivar2)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition2 gs_constraints: { { 'ivar2' . 'Array' } }.

	classDefinition3 := RwClassDefinition
		newForClassNamed: className3
		super: 'Array'
		instvars: #()
		classinstvars: #( )
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition3 gs_constraints: { 'SmallInteger' }.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1;
		addClassDefinition: classDefinition2;
		addClassDefinition: classDefinition3.

"load"	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.
	self assert: class1 rowanPackageName = packageName.
	self assert: class2 rowanPackageName = packageName.
	self assert: (class1 _constraintOn: #ivar1) == Association.
	self assert: (class2 _constraintOn: #ivar2) == Array.
	self assert: class3 _varyingConstraint == SmallInteger
%

category: 'tests-issue 255'
method: RwRowanProjectIssuesTest
testIssue255_internal_constraints_1

	"reproduce bug"
	"https://github.com/dalehenrich/Rowan/issues/255"

	| projectName  packageName projectDefinition classDefinition1 classDefinition2 packageDefinition className1 className2 projectSetDefinition 
		class1 class2 |
	projectName := 'Issue255'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.
	className2 := 'Issue255Class2'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #(ivar1)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition1 gs_constraints: { { 'ivar1' . className2 } }.

	classDefinition2 := RwClassDefinition
		newForClassNamed: className2
		super: 'Object'
		instvars: #(ivar2)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition2 gs_constraints: { { 'ivar2' . className1 } }.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1;
		addClassDefinition: classDefinition2.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class1 rowanPackageName = packageName.
	self assert: class2 rowanPackageName = packageName.
%

category: 'tests-issue 255'
method: RwRowanProjectIssuesTest
testIssue255_internal_constraints_2

	"varian of bug"
	"https://github.com/dalehenrich/Rowan/issues/255"

	| projectName  packageName projectDefinition classDefinition1 classDefinition2 classDefinition3 packageDefinition className1 className2 projectSetDefinition 
		class1 class2 className3 |
	projectName := 'Issue255'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.
	className2 := 'Issue255Class2'.
	className3 := 'Issue255Array3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #(ivar1)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition1 gs_constraints: { { 'ivar1' . className2 } }.

	classDefinition2 := RwClassDefinition
		newForClassNamed: className2
		super: 'Object'
		instvars: #(ivar2)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition2 gs_constraints: { { 'ivar2' . className3 } }.

	classDefinition3 := RwClassDefinition
		newForClassNamed: className3
		super: 'Array'
		instvars: #()
		classinstvars: #( )
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition3 gs_constraints: { className2 }.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1;
		addClassDefinition: classDefinition2;
		addClassDefinition: classDefinition3.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class1 rowanPackageName = packageName.
	self assert: class2 rowanPackageName = packageName.
%

category: 'tests-issue 255'
method: RwRowanProjectIssuesTest
testIssue255_internal_constraints_3

	"reproduce bug encountered at client site - constraints on subclasses"
	"https://github.com/dalehenrich/Rowan/issues/255"

	| projectName  packageName projectDefinition classDefinition1 classDefinition2 classDefinition3 packageDefinition className1 className2 projectSetDefinition 
		class1 class2 className3 |
	projectName := 'Issue255'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.
	className2 := 'Issue255Class2'.
	className3 := 'Issue255Array3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #(ivar1)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition1 gs_constraints: { { 'ivar1' . className2 } }.

	classDefinition2 := RwClassDefinition
		newForClassNamed: className2
		super: className1
		instvars: #(ivar2)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition2 gs_constraints: { { 'ivar2' . className3 } }.

	classDefinition3 := RwClassDefinition
		newForClassNamed: className3
		super: 'Array'
		instvars: #()
		classinstvars: #( )
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition3 gs_constraints: { className2 }.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1;
		addClassDefinition: classDefinition2;
		addClassDefinition: classDefinition3.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class1 rowanPackageName = packageName.
	self assert: class2 rowanPackageName = packageName.
%

category: 'tests-issue 255'
method: RwRowanProjectIssuesTest
testIssue255_modification

	"test modifying constraints"
	"https://github.com/dalehenrich/Rowan/issues/255"

	| projectName  packageName projectDefinition classDefinition1 packageDefinition className1 projectSetDefinition class1 |

	projectName := 'Issue255'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #(ivar1 ivar2)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition1 gs_constraints: { { 'ivar1' . 'Association' } }.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: class1 rowanPackageName = packageName.
	self assert: (class1 _constraintOn: #ivar1) = Association.

"modify constraints"
	classDefinition1 gs_constraints: { { 'ivar1' . 'Association' } . { 'ivar2' . 'SmallInteger' } }.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: class1 rowanPackageName = packageName.
	self assert: (class1 _constraintOn: #ivar1) = Association.
	self assert: (class1 _constraintOn: #ivar2) = SmallInteger.
%

category: 'tests-issue 263'
method: RwRowanProjectIssuesTest
testIssue263
	"https://github.com/dalehenrich/Rowan/issues/263"

	| projectName packageName projectDefinition projectSetDefinition |
	projectName := 'Issue263'.
	packageName := 'Issue263-Kernel'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: 'Globals';
		yourself.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	[
"test"
		"add an extension method to a kernel class (unpackaged class)"
		Object
			rwCompileMethod: 'bar ^''bar'''
			category: '*', packageName asLowercase.

		Boolean
			rwCompileMethod: 'bar ^''bar'''
			category: '*', packageName asLowercase.

"validate"
		(Rowan image loadedClassExtensionsForClass: Object) 
			detect: [:ce |  ce loadedProject name = projectName ] ifNone: [ self assert: false description: 'no class extension found' ].

		(Rowan image loadedClassExtensionsForClass: Boolean) 
			detect: [:ce |  ce loadedProject name = projectName ] ifNone: [ self assert: false description: 'no class extension found' ] ]
				ensure: [ 
					Object rwRemoveSelector: #'bar'.
					Boolean rwRemoveSelector: #'bar']
%

category: 'tests-issue 275'
method: RwRowanProjectIssuesTest
testIssue275_delete_class_handle_keep_in_system

	"https://github.com/dalehenrich/Rowan/issues/275"

	| projectName  packageName projectDefinition classDefinition1 packageDefinition className1 
		projectSetDefinition class1 oldClass |

	projectName := 'Issue275'.
	packageName := 'Issue275-Core'.
	className1 := 'Issue275Class1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: 'category'
		comment: 'comment'
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: class1 isBehavior.
	self assert: class1 name asString = className1.

"remove class from system"
	packageDefinition
		removeClassDefinition: classDefinition1.

"load -- remove from loaded things, but leave in system"
	[ Rowan projectTools load loadProjectSetDefinition: projectSetDefinition ]
		on: RwDeleteClassFromSystemNotification
		do: [:ex | 
			ex candidateClass == class1 
				ifTrue: [ ex resume: false ]
				ifFalse: [ ex pass ] ].

"validate"
	oldClass := class1.
	class1 := Rowan globalNamed: className1.
	self assert: class1 == oldClass.
	self assert: class1 rowanProjectName = Rowan unpackagedName.
%

category: 'tests-issue 275'
method: RwRowanProjectIssuesTest
testIssue275_delete_class_handle_remove_from_system

	"https://github.com/dalehenrich/Rowan/issues/275"

	| projectName  packageName projectDefinition classDefinition1 packageDefinition className1 
		projectSetDefinition class1 oldClass handled |

	projectName := 'Issue275'.
	packageName := 'Issue275-Core'.
	className1 := 'Issue275Class1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: 'category'
		comment: 'comment'
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: class1 isBehavior.
	self assert: class1 name asString = className1.

"remove class from system"
	packageDefinition
		removeClassDefinition: classDefinition1.

"load"
	handled := false.
	[ Rowan projectTools load loadProjectSetDefinition: projectSetDefinition ]
		on: RwDeleteClassFromSystemNotification
		do: [:ex | 
			ex candidateClass == class1 
				ifTrue: [ 
					handled := true.
					ex resume: true ]
				ifFalse: [ ex pass ] ].
	self assert: handled.

"validate"
	oldClass := class1.
	class1 := Rowan globalNamed: className1.
	self assert: class1 isNil.
%

category: 'tests-issue 275'
method: RwRowanProjectIssuesTest
testIssue275_delete_class_remove_from_system

	"https://github.com/dalehenrich/Rowan/issues/275"

	| projectName  packageName projectDefinition classDefinition1 packageDefinition className1 
		projectSetDefinition class1 oldClass |

	projectName := 'Issue275'.
	packageName := 'Issue275-Core'.
	className1 := 'Issue275Class1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: 'category'
		comment: 'comment'
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: class1 isBehavior.
	self assert: class1 name asString = className1.

"remove class from system"
	packageDefinition
		removeClassDefinition: classDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass := class1.
	class1 := Rowan globalNamed: className1.
	self assert: class1 isNil.
%

category: 'tests-issue 275'
method: RwRowanProjectIssuesTest
testIssue275_delete_subclass_handle_keep_in_system

	"https://github.com/dalehenrich/Rowan/issues/275"

	| projectName  packageName projectDefinition classDefinition1 classDefinition2 packageDefinition className1 className2 
		projectSetDefinition class1 class2 oldClass1 oldClass2 handled |

	projectName := 'Issue275'.
	packageName := 'Issue275-Core'.
	className1 := 'Issue275Class1'.
	className2 := 'Issue275Subclass1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: 'category'
		comment: 'comment'
		pools: #()
		type: 'normal'.

	classDefinition2 := RwClassDefinition
		newForClassNamed: className2
		super: className1
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: 'category'
		comment: 'comment'
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1;
		addClassDefinition: classDefinition2.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class1 isBehavior.
	self assert: class1 name asString = className1.
	self assert: class2 isBehavior.
	self assert: class2 name asString = className2.
	self assert: class1 rowanPackageName = packageName.
	self assert: class2 rowanPackageName = packageName.

"remove class2 from system new version of class1"
	classDefinition1 instVarNames: #(ivar1).
	packageDefinition
		removeClassDefinition: classDefinition2.

"load -- remove from loaded things, but leave in system"
	handled := false.
	[ Rowan projectTools load loadProjectSetDefinition: projectSetDefinition ]
		on: RwDeleteClassFromSystemNotification
		do: [:ex | 
			ex candidateClass name asString = className2 
				ifTrue: [ 
					handled := true.
					ex resume: false ]
				ifFalse: [ ex pass ] ].
	self assert: handled.

"validate"
	oldClass1 := class1.
	oldClass2 := class2.
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class1 ~~ oldClass1.
	self assert: class1 rowanPackageName = packageName.
	self assert: class2 notNil.
	self assert: class2 superclass == oldClass1.
	self assert: class2 == oldClass2.
	self assert: class2 rowanPackageName = Rowan unpackagedName.
%

category: 'tests-issue 291'
method: RwRowanProjectIssuesTest
testIssue291_new_version_class_with_subclass_constraints_1

	"https://github.com/dalehenrich/Rowan/issues/291"

	| projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 |

	projectName := 'Issue291'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.
	className2 := 'Issue255Class2'.
	className3 := 'Issue255Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar1' . 'Association' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar2)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar2' . 'Association' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className3
			super: className2
			instvars: #(ivar4 ivar3)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar3' . 'Association' }. { 'ivar4' . 'Association' }. };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: class1 instVarNames = #(ivar1).
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar1' . Association } }).
	class2 := Rowan globalNamed: className2.
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: { { #'ivar2' . Association } }).
	class3 := Rowan globalNamed: className3.
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar4' . Association }. { #'ivar3' . Association }. }).



"modify class -- new version"
	classDefinition1
		instVarNames: #(ivar5 ivar1);
		gs_constraints: { { 'ivar1' . 'Association' } . { 'ivar5' . 'Number' } }.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass1 := class1.
	class1 := Rowan globalNamed: className1.
	self assert: oldClass1 ~~ class1.
	self assert: class1 instVarNames = #(ivar5 ivar1).
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar5' . Number }. { #'ivar1' . Association }. }).
	oldClass2 := class2.
	class2 := Rowan globalNamed: className2.
	self assert: oldClass2 ~~ class2.
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: { { #'ivar2' . Association } }).
	oldClass3 := class3.
	class3 := Rowan globalNamed: className3.
	self assert: oldClass3 ~~ class3.
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar4' . Association }. { #'ivar3' . Association }. }).
%

category: 'tests-issue 291'
method: RwRowanProjectIssuesTest
testIssue291_new_version_class_with_subclass_constraints_2

	"https://github.com/dalehenrich/Rowan/issues/291"

	| projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 newClass1 |

	projectName := 'Issue291'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.
	className2 := 'Issue255Class2'.
	className3 := 'Issue255Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar1' . 'Association' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar2)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar2' . 'Association' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className3
			super: className2
			instvars: #(ivar4 ivar3)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar3' . 'Association' }. { 'ivar4' . 'Association' }. };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: class1 instVarNames = #(ivar1).
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar1' . Association } }).
	class2 := Rowan globalNamed: className2.
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: { { #'ivar2' . Association } }).
	class3 := Rowan globalNamed: className3.
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar4' . Association }. { #'ivar3' . Association }. }).



"create new version"
	newClass1 := Object 
		rwSubclass: className1 
		instVarNames: #('ivar5' 'ivar1') 
		classVars: #() 
		classInstVars: #() 
		poolDictionaries: #() 
		category: 'category' 
		packageName:  packageName
		constraints: { { #'ivar1' . Association } . { #'ivar5' . Number } } 
		options: #().

"validate"
	oldClass1 := class1.
	class1 := Rowan globalNamed: className1.
	self assert: class1 == newClass1.
	self assert: oldClass1 ~~ class1.
	self assert: class1 instVarNames = #(ivar5 ivar1).
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar5' . Number }. { #'ivar1' . Association }. }).
	oldClass2 := class2.
	class2 := Rowan globalNamed: className2.
	self assert: oldClass2 ~~ class2.
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: { { #'ivar2' . Association } }).
	oldClass3 := class3.
	class3 := Rowan globalNamed: className3.
	self assert: oldClass3 ~~ class3.
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar4' . Association }. { #'ivar3' . Association }. }).
%

category: 'tests-issue 291'
method: RwRowanProjectIssuesTest
testIssue291_new_version_class_with_subclass_constraints_3

	"https://github.com/dalehenrich/Rowan/issues/291"

	"super class has constraint on instance of subclass"

	| projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 newClass1 |

	projectName := 'Issue291'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.
	className2 := 'Issue255Class2'.
	className3 := 'Issue255Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar1' . className2 } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar2)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar2' . 'Association' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className3
			super: className2
			instvars: #(ivar4 ivar3)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar3' . 'Association' }. { 'ivar4' . 'Association' }. };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.
	self assert: class1 instVarNames = #(ivar1).
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar1' . class2 } }).
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: { { #'ivar2' . Association } }).
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar4' . Association }. { #'ivar3' . Association }. }).



"create new version"
	newClass1 := Object 
		rwSubclass: className1 
		instVarNames: #('ivar5' 'ivar1') 
		classVars: #() 
		classInstVars: #() 
		poolDictionaries: #() 
		category: 'category' 
		packageName:  packageName
		constraints: { { #'ivar1' . class2 } . { #'ivar5' . Number } } 
		options: #().

"validate"
	oldClass1 := class1.
	class1 := Rowan globalNamed: className1.
	oldClass2 := class2.
	class2 := Rowan globalNamed: className2.
	oldClass3 := class3.
	class3 := Rowan globalNamed: className3.
	self assert: class1 == newClass1.
	self assert: oldClass1 ~~ class1.
	self assert: class1 instVarNames = #(ivar5 ivar1).
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar5' . Number }. { #'ivar1' . oldClass2 }. }).
	self assert: oldClass2 ~~ class2.
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: { { #'ivar2' . Association } }).
	self assert: oldClass3 ~~ class3.
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar4' . Association }. { #'ivar3' . Association }. }).
%

category: 'tests-issue 291'
method: RwRowanProjectIssuesTest
testIssue291_new_version_class_with_subclass_constraints_4

	"https://github.com/dalehenrich/Rowan/issues/291"

	"subclass overrides constraint of superclass (ivar1 has different constraint for each of classes)"

	| projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 newClass1 |

	projectName := 'Issue291'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.
	className2 := 'Issue255Class2'.
	className3 := 'Issue255Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar1' . 'Number' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar2)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar2' . 'Association' } . { 'ivar1' . 'Integer' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className3
			super: className2
			instvars: #(ivar4 ivar3)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar3' . 'Association' }. { 'ivar4' . 'Association' }.  { 'ivar1' . 'SmallInteger' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.
	self assert: class1 instVarNames = #(ivar1).
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar1' . Number } }).
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: {  { #'ivar1' . Integer } . { #'ivar2' . Association } }).
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar1' . SmallInteger } . { #'ivar4' . Association }. { #'ivar3' . Association }. }).



"create new version"
	newClass1 := Object 
		rwSubclass: className1 
		instVarNames: #('ivar5' 'ivar1') 
		classVars: #() 
		classInstVars: #() 
		poolDictionaries: #() 
		category: 'category' 
		packageName:  packageName
		constraints: { { #'ivar1' . Number } . { #'ivar5' . Number } } 
		options: #().

"validate"
	oldClass1 := class1.
	class1 := Rowan globalNamed: className1.
	oldClass2 := class2.
	class2 := Rowan globalNamed: className2.
	oldClass3 := class3.
	class3 := Rowan globalNamed: className3.
	self assert: class1 == newClass1.
	self assert: oldClass1 ~~ class1.
	self assert: class1 instVarNames = #(ivar5 ivar1).
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar5' . Number }. { #'ivar1' . Number }. }).
	self assert: oldClass2 ~~ class2.
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: { { #'ivar1' . Integer } . { #'ivar2' . Association } }).
	self assert: oldClass3 ~~ class3.
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar1' . SmallInteger } . { #'ivar4' . Association }. { #'ivar3' . Association }. }).
%

category: 'tests-issue 293'
method: RwRowanProjectIssuesTest
testIssue293_constraint_ordering

	"https://github.com/dalehenrich/Rowan/issues/293"

	"constraints should be displayed in inst var order, not alphabetical order"

	| projectName  packageName projectDefinition classDefinition packageDefinition className1 className2 
		className3 projectSetDefinition class |
	projectName := 'Issue255'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.
	className2 := 'Issue255Subclass2'.
	className3 := 'Issue255Subclass3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].
"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #( ivar2 ivar3 ivar4 ivar1)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition gs_constraints: { { 'ivar4' . 'Association' }. { 'ivar3' . 'Association' }. { 'ivar2' . 'Association' }. { 'ivar1' . 'Association' }. }.
	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: className1
		instvars: #( ivar7 ivar6)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition gs_constraints: { { 'ivar7' . 'Association' }. { 'ivar6' . 'Association' }. }.
	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: className2
		instvars: #( ivar8 ivar9)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition gs_constraints: { { 'ivar9' . 'Association' }. { 'ivar8' . 'Association' }. }.
	packageDefinition 
		addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class := Rowan globalNamed: className1.
	self assert: (class _constraintsEqual: {  { #'ivar1' . Association }.  { #'ivar2' . Association }. { #'ivar3' . Association }. { #'ivar4' . Association }.  }).

	class := Rowan globalNamed: className2.
	self assert: (class _constraintsEqual: {  { #'ivar7' . Association }.  { #'ivar6' . Association }. }).

	class := Rowan globalNamed: className3.
	self assert: (class _constraintsEqual: {  { #'ivar8' . Association }.  { #'ivar9' . Association }. }).
%

category: 'tests-issue 305'
method: RwRowanProjectIssuesTest
testIssue305_delete_package_with_class

	"https://github.com/dalehenrich/Rowan/issues/305"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class |
	projectName := 'Issue305'.
	packageName1 := 'Issue305-Core1'.
	packageName2 := 'Issue305-Core2'.
	className := 'Issue305Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	projectDefinition2 removePackageNamed: packageName2.

	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class isNil.
%

category: 'tests-issue 305'
method: RwRowanProjectIssuesTest
testIssue305_delete_package_with_extension_method

	"https://github.com/dalehenrich/Rowan/issues/305"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition 
		classExtension packageDefinition className projectSetDefinition class oldClass |
	projectName := 'Issue305'.
	packageName1 := 'Issue305-Core1'.
	packageName2 := 'Issue305-Core2'.
	className := 'Issue305Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	classExtension := (RwClassExtensionDefinition newForClassNamed: className)
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'foo'
						protocol: '*', packageName2 asLowercase
						source: 'foo ^ ''foo''');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'foo'
						protocol: '*', packageName2 asLowercase
						source: 'foo ^ ''foo''');
		yourself.

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtension.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class perform: #foo) = 'foo'.
	self assert: (class new perform: #foo) = 'foo'.

"remove package"
	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	projectDefinition2 removePackageNamed: packageName2.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

"validate"
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class == oldClass.
	self should: [ (class perform: #foo) = 'foo' ] raise: MessageNotUnderstood.
	self should: [ (class new perform: #foo) = 'foo' ] raise: MessageNotUnderstood.
%

category: 'tests-issue 310'
method: RwRowanProjectIssuesTest
testIssue310

       "https://github.com/dalehenrich/Rowan/issues/310"

       "original test case for HR9880 - testing interactive api load and unpackaged (disowned) subclasses"

		"unpackaged subclasses of a packaged class are to be ignored when a new version of the packaged class is created"

       | projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition 
			className1 projectSetDefinition baseClass oldClass project audit |

       projectName := 'HR9880'.
       packageName := 'HR9880-Core'.
       className1 := 'HR9880'.
       {projectName}
               do: [ :pn | 
                       (Rowan image loadedProjectNamed: pn ifAbsent: [  ])
                               ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
       projectDefinition := (RwProjectDefinition
               newForGitBasedProjectNamed: projectName)
               addPackageNamed: packageName;
               defaultSymbolDictName: self _symbolDictionaryName1;
               yourself.

       packageDefinition := projectDefinition packageNamed: packageName.

       classDefinition1 := RwClassDefinition
               newForClassNamed: className1 
                       super: 'Object'
                       instvars: #(iv1 iv2)
                       classinstvars: #()
                       classvars: #()
                       category:packageName
                       comment: 'comment'
                       pools: #()
                       type: 'normal'.
       packageDefinition 
               addClassDefinition: classDefinition1.

       1 to: 10 do: [:index | 

               classDefinition := RwClassDefinition
                       newForClassNamed: className1, '_', index printString
                               super: className1
                               instvars: #()
                               classinstvars: #()
                               classvars: #()
                               category: packageName
                               comment: 'comment'
                               pools: #()
                               type: 'normal'.
               packageDefinition 
                       addClassDefinition: classDefinition.

               classDefinition
                       addInstanceMethodDefinition:
                               (RwMethodDefinition
                                               newForSelector: #'mover'
                                               protocol: 'accessing'
                                               source: 'foo ^1') ].


"load"
       projectSetDefinition := RwProjectSetDefinition new.
       projectSetDefinition addDefinition: projectDefinition.
       Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"

	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
       baseClass := Rowan globalNamed: className1.
       1 to: 10 do: [:index | 
               | theClass |

               theClass := Rowan globalNamed: className1 , '_', index printString.

               self assert: theClass superclass == baseClass.
               self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName ].

"disown the subclasses"
       1 to: 10 do: [:index | 
               Rowan packageTools disown disownClassNamed: className1 , '_', index printString ].
 
"modify class -- new version"

       TestCase rwSubclass:className1
       instVarNames: #( iv1 iv2)
       classVars: #()
       classInstVars: #()
       poolDictionaries: #()
       category: packageName
       options: #().

"validate"
	self assert: (audit := project audit) isEmpty.
       oldClass := baseClass.
       baseClass := Rowan globalNamed: className1.
       self assert: oldClass ~~ baseClass.
       1 to: 10 do: [:index | 
               | theClass |

               theClass := Rowan globalNamed: className1 , '_', index printString.

               self assert: theClass superclass == oldClass.
               self assert: (theClass compiledMethodAt: #foo) rowanPackageName = Rowan unpackagedName ].
%

category: 'tests-issue 313'
method: RwRowanProjectIssuesTest
testIssue313_1

	"https://github.com/dalehenrich/Rowan/issues/313"

	"initial test case for HR9880 - testing definition based load"

	| projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition 
		className1 projectSetDefinition baseClass oldClass project audit |

	projectName := 'HR9880'.
	packageName := 'HR9880-Core'.
	className1 := 'HR9880'.
	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1 
			super: 'Object'
			instvars: #(iv1 iv2)
			classinstvars: #()
			classvars: #()
			category:packageName
			comment: 'comment'
			pools: #()
			type: 'normal'.
	packageDefinition 
		addClassDefinition: classDefinition1.

	1 to: 10 do: [:index | 

		classDefinition := RwClassDefinition
			newForClassNamed: className1, '_', index printString
				super: className1
				instvars: #()
				classinstvars: #()
				classvars: #()
				category: packageName
				comment: 'comment'
				pools: #()
				type: 'normal'.
		packageDefinition 
			addClassDefinition: classDefinition.

		classDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'mover'
						protocol: 'accessing'
						source: 'foo ^1') ].


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"

	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	baseClass := Rowan globalNamed: className1.
	1 to: 10 do: [:index | 
		| theClass |

		theClass := Rowan globalNamed: className1 , '_', index printString.

		self assert: theClass superclass == baseClass.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName ].

"modify class -- new version"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	packageDefinition := projectDefinition packageNamed: packageName.
	classDefinition1 := packageDefinition classDefinitions at: className1.
	classDefinition1 instVarNames: #(iv3).

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := baseClass.
	baseClass := Rowan globalNamed: className1.
	self assert: oldClass ~~ baseClass.
	1 to: 10 do: [:index | 
		| theClass |

		theClass := Rowan globalNamed: className1 , '_', index printString.

		self assert: theClass superclass == baseClass.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName ].
%

category: 'tests-issue 313'
method: RwRowanProjectIssuesTest
testIssue313_2

	"https://github.com/dalehenrich/Rowan/issues/313"

	"test case for HR9880 - testing definition based load"

	"change superclass to TestCase to create new version ... instead of inst var addition"

	| projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition 
		className1 projectSetDefinition baseClass oldClass project audit |

	projectName := 'HR9880'.
	packageName := 'HR9880-Core'.
	className1 := 'HR9880'.
	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1 
			super: 'Object'
			instvars: #(iv1 iv2)
			classinstvars: #()
			classvars: #()
			category:packageName
			comment: 'comment'
			pools: #()
			type: 'normal'.
	packageDefinition 
		addClassDefinition: classDefinition1.

	1 to: 10 do: [:index | 

		classDefinition := RwClassDefinition
			newForClassNamed: className1, '_', index printString
				super: className1
				instvars: #()
				classinstvars: #()
				classvars: #()
				category: packageName
				comment: 'comment'
				pools: #()
				type: 'normal'.
		packageDefinition 
			addClassDefinition: classDefinition.

		classDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'mover'
						protocol: 'accessing'
						source: 'foo ^1') ].


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"

	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	baseClass := Rowan globalNamed: className1.
	1 to: 10 do: [:index | 
		| theClass |

		theClass := Rowan globalNamed: className1 , '_', index printString.

		self assert: theClass superclass == baseClass.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName ].

"modify class -- new version"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	packageDefinition := projectDefinition packageNamed: packageName.
	classDefinition1 := packageDefinition classDefinitions at: className1.
	classDefinition1 superclassName: 'TestCase'.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := baseClass.
	baseClass := Rowan globalNamed: className1.
	self assert: oldClass ~~ baseClass.
	1 to: 10 do: [:index | 
		| theClass |

		theClass := Rowan globalNamed: className1 , '_', index printString.

		self assert: theClass superclass == baseClass.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName ].
%

category: 'tests-issue 313'
method: RwRowanProjectIssuesTest
testIssue313_3

	"https://github.com/dalehenrich/Rowan/issues/313"

	"test case for HR9880 - testing interactive api load"

	| projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition className1 
		projectSetDefinition baseClass oldClass |

	projectName := 'HR9880'.
	packageName := 'HR9880-Core'.
	className1 := 'HR9880'.
	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1 
			super: 'Object'
			instvars: #(iv1 iv2)
			classinstvars: #()
			classvars: #()
			category:packageName
			comment: 'comment'
			pools: #()
			type: 'normal'.
	packageDefinition 
		addClassDefinition: classDefinition1.

	1 to: 10 do: [:index | 

		classDefinition := RwClassDefinition
			newForClassNamed: className1, '_', index printString
				super: className1
				instvars: #()
				classinstvars: #()
				classvars: #()
				category: packageName
				comment: 'comment'
				pools: #()
				type: 'normal'.
		packageDefinition 
			addClassDefinition: classDefinition.

		classDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'mover'
						protocol: 'accessing'
						source: 'foo ^1') ].


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"

	baseClass := Rowan globalNamed: className1.
	1 to: 10 do: [:index | 
		| theClass |

		theClass := Rowan globalNamed: className1 , '_', index printString.

		self assert: theClass superclass == baseClass.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName ].

"modify class -- new version"

	TestCase rwSubclass:className1
	instVarNames: #( iv1 iv2)
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: packageName
	options: #().

"validate"
	oldClass := baseClass.
	baseClass := Rowan globalNamed: className1.
	self assert: oldClass ~~ baseClass.
	1 to: 10 do: [:index | 
		| theClass |

		theClass := Rowan globalNamed: className1 , '_', index printString.

		self assert: theClass superclass == baseClass.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName ].
%

category: 'tests-issue 313'
method: RwRowanProjectIssuesTest
testIssue313_4

	"https://github.com/dalehenrich/Rowan/issues/313"

	"test case for HR9880 - testing interactive api load and test methods as extension methods"

	| projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition 
		packageDefinition1 packageDefinition2 className1 projectSetDefinition baseClass oldClass 
		classExtensionDefinition project audit |

	projectName := 'HR9880'.
	packageName1 := 'HR9880-Core'.
	packageName2 := 'HR9880-Extension'.
	className1 := 'HR9880'.
	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition1 := projectDefinition packageNamed: packageName1.
	packageDefinition2 := projectDefinition packageNamed: packageName2.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1 
			super: 'Object'
			instvars: #(iv1 iv2)
			classinstvars: #()
			classvars: #()
			category:packageName1
			comment: 'comment'
			pools: #()
			type: 'normal'.
	packageDefinition1
		addClassDefinition: classDefinition1.

	1 to: 10 do: [:index | 
		| className |

		className := className1, '_', index printString.

		classDefinition := RwClassDefinition
			newForClassNamed: className
				super: className1
				instvars: #()
				classinstvars: #()
				classvars: #()
				category: packageName1
				comment: 'comment'
				pools: #()
				type: 'normal'.
		packageDefinition1 addClassDefinition: classDefinition.

		classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
		classExtensionDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'mover'
						protocol: '*', packageName2 asLowercase
						source: 'foo ^1').
		packageDefinition2 addClassExtensionDefinition: classExtensionDefinition ].


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"

	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	baseClass := Rowan globalNamed: className1.
	1 to: 10 do: [:index | 
		| theClass |

		theClass := Rowan globalNamed: className1 , '_', index printString.

		self assert: theClass superclass == baseClass.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName2 ].

"modify class -- new version"

	TestCase rwSubclass:className1
	instVarNames: #( iv1 iv2)
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: packageName1
	options: #().

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := baseClass.
	baseClass := Rowan globalNamed: className1.
	self assert: oldClass ~~ baseClass.
	1 to: 10 do: [:index | 
		| theClass |

		theClass := Rowan globalNamed: className1 , '_', index printString.

		self assert: theClass superclass == baseClass.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = packageName2 ].
%

category: 'tests-issue 313'
method: RwRowanProjectIssuesTest
testIssue313_5

	"https://github.com/dalehenrich/Rowan/issues/313"

	"test case for HR9880 - testing interactive api load and subclasses in different packages"

	| projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition className1 
		projectSetDefinition baseClass oldClass |

	projectName := 'HR9880'.
	packageName := 'HR9880-Core'.
	className1 := 'HR9880'.
	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.
	1 to: 10 do: [:index | 
		projectDefinition addPackageNamed: packageName, '-', index printString ].


	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1 
			super: 'Object'
			instvars: #(iv1 iv2)
			classinstvars: #()
			classvars: #()
			category:packageName
			comment: 'comment'
			pools: #()
			type: 'normal'.
	packageDefinition 
		addClassDefinition: classDefinition1.

	1 to: 10 do: [:index | 
		| thePackageName thePackageDefinition |
		thePackageName := packageName, '-', index printString.
		thePackageDefinition := projectDefinition packageNamed: thePackageName.

		classDefinition := RwClassDefinition
			newForClassNamed: className1, '_', index printString
				super: className1
				instvars: #()
				classinstvars: #()
				classvars: #()
				category: packageName
				comment: 'comment'
				pools: #()
				type: 'normal'.
		thePackageDefinition 
			addClassDefinition: classDefinition.

		classDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'mover'
						protocol: 'accessing'
						source: 'foo ^1') ].


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"

	baseClass := Rowan globalNamed: className1.
	1 to: 10 do: [:index | 
		| theClass thePackageName |

		theClass := Rowan globalNamed: className1 , '_', index printString.
		thePackageName := packageName, '-', index printString.

		self assert: theClass superclass == baseClass.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = thePackageName ].

"modify class -- new version"

	TestCase rwSubclass:className1
	instVarNames: #( iv1 iv2)
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: packageName
	options: #().

"validate"
	oldClass := baseClass.
	baseClass := Rowan globalNamed: className1.
	self assert: oldClass ~~ baseClass.
	1 to: 10 do: [:index | 
		| theClass thePackageName |

		theClass := Rowan globalNamed: className1 , '_', index printString.
		thePackageName := packageName, '-', index printString.

		self assert: theClass superclass == baseClass.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = thePackageName ].
%

category: 'tests-issue 313'
method: RwRowanProjectIssuesTest
testIssue313_6

	"https://github.com/dalehenrich/Rowan/issues/313"

	"test case for HR9880 - testing interactive api load and subclasses in different projects"

	| projectName1 projectName2  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition1 
		classDefinition packageDefinition className1 projectSetDefinition baseClass oldClass |

	projectName1 := 'HR9880_1'.
	projectName2 := 'HR9880_2'.
	packageName1 := 'HR9880_1-Core'.
	packageName2 := 'HR9880_2-Core'.
	className1 := 'HR9880'.
	{projectName1 . projectName2 }
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create projects"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName1)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.
	projectDefinition2 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName2)
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	1 to: 10 do: [:index | 
		projectDefinition2 addPackageNamed: packageName2, '-', index printString ].


	packageDefinition := projectDefinition1 packageNamed: packageName1.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1 
			super: 'Object'
			instvars: #(iv1 iv2)
			classinstvars: #()
			classvars: #()
			category:packageName1
			comment: 'comment'
			pools: #()
			type: 'normal'.
	packageDefinition 
		addClassDefinition: classDefinition1.

	1 to: 10 do: [:index | 
		| thePackageName thePackageDefinition |
		thePackageName := packageName2, '-', index printString.
		thePackageDefinition := projectDefinition2 packageNamed: thePackageName.

		classDefinition := RwClassDefinition
			newForClassNamed: className1, '_', index printString
				super: className1
				instvars: #()
				classinstvars: #()
				classvars: #()
				category: thePackageName
				comment: 'comment'
				pools: #()
				type: 'normal'.
		thePackageDefinition 
			addClassDefinition: classDefinition.

		classDefinition
			addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'mover'
						protocol: 'accessing'
						source: 'foo ^1') ].

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition 
		addDefinition: projectDefinition1;
		addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"

	baseClass := Rowan globalNamed: className1.
	self assert: baseClass rowanPackageName = packageName1.
	1 to: 10 do: [:index | 
		| theClass thePackageName |

		theClass := Rowan globalNamed: className1 , '_', index printString.
		thePackageName := packageName2, '-', index printString.

		self assert: theClass superclass == baseClass.
		self assert: theClass rowanPackageName = thePackageName.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = thePackageName ].

"modify class -- new version"

	TestCase rwSubclass:className1
	instVarNames: #( iv1 iv2)
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: packageName1
	options: #().

"validate"
	oldClass := baseClass.
	baseClass := Rowan globalNamed: className1.
	self assert: baseClass rowanPackageName = packageName1.
	self assert: oldClass ~~ baseClass.
	1 to: 10 do: [:index | 
		| theClass thePackageName |

		theClass := Rowan globalNamed: className1 , '_', index printString.
		thePackageName := packageName2, '-', index printString.

		self assert: theClass superclass == baseClass.
		self assert: theClass rowanPackageName = thePackageName.
		self assert: (theClass compiledMethodAt: #foo) rowanPackageName = thePackageName ].
%

category: 'tests-issue 325'
method: RwRowanProjectIssuesTest
testIssue325

	"https://github.com/dalehenrich/Rowan/issues/325"

	| projectName  packageName1 packageName2 packageName3 projectDefinition1 classDefinition packageDefinition 
		className1 className2 className3 projectSetDefinition theSymbolDict myUserProfile mySymbolList theSymDictIndex |

	projectName := 'Issue325'.
	packageName1 := 'Issue325-Core1'.
	packageName2 := 'Issue325-Core2'.
	packageName3 := 'Issue325-Core3'.
	className1 := 'Issue325Class1'. 
	className2 := 'Issue325Class2'. 
	className3 := 'Issue325Class3'. 

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create definitions"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName1 forPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName3;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName2
		comment: ''
		pools: #()
		type: 'normal'.
	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName3
		comment: ''
		pools: #()
		type: 'normal'.
	packageDefinition := projectDefinition1 packageNamed: packageName3.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"test"
	theSymbolDict := Rowan globalNamed: self _symbolDictionaryName.
	self assert: theSymbolDict class == SymbolDictionary.			"symbol dictionary is accessible in my symbol list"

	self assert: (Rowan image packageNames includes: packageName1).	"package 1 is visible"
	self assert: (Rowan globalNamed: className1) notNil.							"and class1 is visible"
	self assert: (Rowan image packageNames includes: packageName2).	"package 2 is visible"
	self assert: (Rowan globalNamed: className2) notNil.							"and class1 3 is visible"
	self assert: (Rowan image packageNames includes: packageName3).	"package is visible"
	self assert: (Rowan globalNamed: className3) notNil.							"and class1 is visible"

	myUserProfile := System myUserProfile.
	mySymbolList := System myUserProfile symbolList.
	theSymDictIndex := mySymbolList indexOf: theSymbolDict.
	myUserProfile removeDictionaryAt: theSymDictIndex.				"remove symbol dictionary from my symbol list"

	self deny: (Rowan image packageNames includes: packageName1).	"package 1 is visible"
	self deny: (Rowan globalNamed: className1) notNil.							"and class1 is visible"
	self assert: (Rowan image packageNames includes: packageName2).	"package 2 is visible"
	self assert: (Rowan globalNamed: className2) notNil.							"and class1 3 is visible"
	self assert: (Rowan image packageNames includes: packageName3).	"package is visible"
	self assert: (Rowan globalNamed: className3) notNil.							"and class1 is visible"

	self assert: (Rowan image packageNamesForLoadedProjectNamed: projectName) sort = {packageName2. packageName3} sort
%

category: 'tests-issue 326'
method: RwRowanProjectIssuesTest
testIssue326_class_modification_remove_constraint

	"test modifying constraints remove constraint"
	"https://github.com/dalehenrich/Rowan/issues/326"

	| projectName  packageName projectDefinition classDefinition1 packageDefinition className1 
		projectSetDefinition class1 oldClass x |

	projectName := 'Issue326'.
	packageName := 'Issue326-Core'.
	className1 := 'Issue326Class1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project - class with constraints"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #(ivar1 ivar2)
		classinstvars: #()
		classvars: #()
		category: 'category'
		comment: 'comment'
		pools: #()
		type: 'normal'.
	classDefinition1
		gs_constraints: { { 'ivar1' . 'Association' } . { 'ivar2' . 'Number' } }.

	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition 
		addClassDefinition: classDefinition1.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	self assert: class1 instVarNames = #(ivar1  ivar2).
	self assert: (x := class1 classVarNames asSortedCollection) = #() asSortedCollection.
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar2' . Number } . { #'ivar1' . Association } }).

"remove a constraint"
	classDefinition1
		gs_constraints: { { 'ivar2' . 'Number' } }.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass := class1.
	class1 := Rowan globalNamed: className1.
	self assert: oldClass == class1.
	self assert: class1 instVarNames = #(ivar1 ivar2).
	self assert: (class1 _constraintsEqual: { { #'ivar2' . Number } }).
%

category: 'tests-issue 326'
method: RwRowanProjectIssuesTest
testIssue326_new_version_class_with_subclass_constraints_remove_constraint

	"https://github.com/dalehenrich/Rowan/issues/326"

	"subclass overrides constraint of superclass (ivar1 has different constraint for each of classes)"

	| projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 newClass1 |

	projectName := 'Issue326'.
	packageName := 'Issue326-Core'.
	className1 := 'Issue326Class1'.
	className2 := 'Issue326Class2'.
	className3 := 'Issue326Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #(ivar1 ivar5)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar1' . 'Number' } . { 'ivar5' . 'Number' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar2)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar2' . 'Association' }  };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className3
			super: className2
			instvars: #(ivar4 ivar3)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar3' . 'Association' }. { 'ivar4' . 'Association' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.
	self assert: class1 instVarNames = #(ivar1 ivar5).
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar1' . Number } . { #'ivar5' . Number } }).
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: {  { #'ivar1' . Number } . { #'ivar5' . Number } . { #'ivar2' . Association } }).
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar1' . Number } . { #'ivar5' . Number } . { #'ivar4' . Association }. { #'ivar3' . Association }. }).

"remove constraints in className1 (superclass)"
	newClass1 := Object 
		rwSubclass: className1 
		instVarNames: #('ivar1' 'ivar5') 
		classVars: #() 
		classInstVars: #() 
		poolDictionaries: #() 
		category: 'category' 
		packageName:  packageName
		constraints: { { 'ivar5' . Number } } 
		options: #().

"validate"
	oldClass1 := class1.
	class1 := Rowan globalNamed: className1.
	oldClass2 := class2.
	class2 := Rowan globalNamed: className2.
	oldClass3 := class3.
	class3 := Rowan globalNamed: className3.
	self assert: class1 == newClass1.
	self assert: oldClass1 == class1.
	self assert: class1 instVarNames = #(ivar1 ivar5).
	self assert: (class1 _constraintsEqual: { { #'ivar5' . Number } }).
	self assert: oldClass2 == class2.
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: {  { #'ivar5' . Number } . { #'ivar2' . Association } }).
	self assert: oldClass3 == class3.
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar5' . Number } . { #'ivar4' . Association }. { #'ivar3' . Association }. }).
%

category: 'tests-issue 326'
method: RwRowanProjectIssuesTest
testIssue326_new_version_class_with_subclass_constraints_remove_subclass_constraint

	"https://github.com/dalehenrich/Rowan/issues/326"

	"subclass overrides constraint of superclass (ivar1 has different constraint for each of classes)"

	| projectName  packageName projectDefinition classDefinition1 classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 newClass |

	projectName := 'Issue326'.
	packageName := 'Issue326-Core'.
	className1 := 'Issue326Class1'.
	className2 := 'Issue326Class2'.
	className3 := 'Issue326Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #(ivar1 ivar5)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar1' . 'Number' } . { 'ivar5' . 'Number' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar2)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar2' . 'Association' }  };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className3
			super: className2
			instvars: #(ivar4 ivar3)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		gs_constraints: { { 'ivar3' . 'Association' }. { 'ivar4' . 'Association' } };
		yourself.
	packageDefinition 
		addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.
	self assert: class1 instVarNames = #(ivar1 ivar5).
	self assert: class1 category = 'category'.
	self assert: class1 comment = 'comment'.
	self assert: (class1 _constraintsEqual: { { #'ivar1' . Number } . { #'ivar5' . Number } }).
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: {  { #'ivar1' . Number } . { #'ivar5' . Number } . { #'ivar2' . Association } }).
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: { { #'ivar1' . Number } . { #'ivar5' . Number } . { #'ivar4' . Association }. { #'ivar3' . Association }. }).

"remove constraints in className1 (superclass)"
	newClass := class2 
		rwSubclass: className3 
		instVarNames: #('ivar4' 'ivar3') 
		classVars: #() 
		classInstVars: #() 
		poolDictionaries: #() 
		category: 'category' 
		packageName:  packageName
		constraints: { { 'ivar3' . Association } } 
		options: #().

"validate"
	oldClass1 := class1.
	class1 := Rowan globalNamed: className1.
	oldClass2 := class2.
	class2 := Rowan globalNamed: className2.
	oldClass3 := class3.
	class3 := Rowan globalNamed: className3.
	self assert: class3 == newClass.
	self assert: oldClass1 == class1.
	self assert: class1 instVarNames = #(ivar1 ivar5).
	self assert: (class1 _constraintsEqual: {  { #'ivar1' . Number } . { #'ivar5' . Number } }).
	self assert: oldClass2 == class2.
	self assert: class2 instVarNames = #(ivar2).
	self assert: (class2 _constraintsEqual: {   { #'ivar1' . Number } . { #'ivar5' . Number } . { #'ivar2' . Association } }).
	self assert: oldClass3 == class3.
	self assert: class3 instVarNames = #(ivar4 ivar3).
	self assert: (class3 _constraintsEqual: {  { #'ivar1' . Number } . { #'ivar5' . Number } . { #'ivar3' . Association }. }).
%

category: 'tests-issue 353'
method: RwRowanProjectIssuesTest
testIssue353_new_version_class_with_subclass_with_method_deletion_A

	"reproduce bug"
	"https://github.com/dalehenrich/Rowan/issues/353"

	| projectName  packageName projectDefinition classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition audit |

	projectName := 'Issue326'.
	packageName := 'Issue326-Core'.
	className1 := 'Issue326Class1'.
	className2 := 'Issue326Class2'.
	className3 := 'Issue326Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition := (RwClassDefinition
		newForClassNamed: 'SuperMan'
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className1
			super: 'SuperMan'
			instvars: #(ivar1 ivar5)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').

	packageDefinition 
		addClassDefinition: classDefinition.


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.


"new class version of SuperMan and remove methods"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className1.
	classDefinition
		removeInstanceMethod: #method3;
		removeClassMethod: #method2;
		yourself.

	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: 'SuperMan'.
	classDefinition instVarNames: #(ivar0).

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 353'
method: RwRowanProjectIssuesTest
testIssue353_new_version_class_with_subclass_with_method_deletion_B

	"(passing) companion test case"
	"https://github.com/dalehenrich/Rowan/issues/353"

	| projectName  packageName projectDefinition classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition audit |

	projectName := 'Issue326'.
	packageName := 'Issue326-Core'.
	className1 := 'Issue326Class1'.
	className2 := 'Issue326Class2'.
	className3 := 'Issue326Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition := (RwClassDefinition
		newForClassNamed: 'SuperMan'
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className1
			super: 'SuperMan'
			instvars: #(ivar1 ivar5)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').

	packageDefinition 
		addClassDefinition: classDefinition.


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.


"new class version of className1 and remove methods"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className1.
	classDefinition instVarNames: #(ivar0 ivar1 ivar5).
	classDefinition
		removeInstanceMethod: #method3;
		removeClassMethod: #method2;
		yourself.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 353'
method: RwRowanProjectIssuesTest
testIssue353_new_version_class_with_subclass_with_method_deletion_C

	"additional test case (fails as well)"
	"https://github.com/dalehenrich/Rowan/issues/353"

	| projectName  packageName projectDefinition classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition audit |

	projectName := 'Issue326'.
	packageName := 'Issue326-Core'.
	className1 := 'Issue326Class1'.
	className2 := 'Issue326Class2'.
	className3 := 'Issue326Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition := (RwClassDefinition
		newForClassNamed: 'SuperMan'
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className1
			super: 'SuperMan'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^3').
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method5'
					protocol: 'accessing'
					source: 'method5 ^2').

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className2
			super:className1
			instvars: #(ivar1 ivar5)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').

	packageDefinition 
		addClassDefinition: classDefinition.


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.


"new class version of SuperMan and remove methods"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className1.
	classDefinition
		removeInstanceMethod: #method4;
		removeClassMethod: #method5;
		yourself.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className2.
	classDefinition
		removeInstanceMethod: #method3;
		removeClassMethod: #method2;
		yourself.

	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: 'SuperMan'.
	classDefinition instVarNames: #(ivar0).

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 353'
method: RwRowanProjectIssuesTest
testIssue353_new_version_class_with_subclass_with_method_deletion_D

	"new test case: both superclass and subclass have new class versions and method removed from each sublclass"
	"https://github.com/dalehenrich/Rowan/issues/353"

	| projectName  packageName projectDefinition classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition audit |

	projectName := 'Issue326'.
	packageName := 'Issue326-Core'.
	className1 := 'Issue326Class1'.
	className2 := 'Issue326Class2'.
	className3 := 'Issue326Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition := (RwClassDefinition
		newForClassNamed: 'SuperMan'
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className1
			super: 'SuperMan'
			instvars: #(ivar4 ivar6)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^3').
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method5'
					protocol: 'accessing'
					source: 'method5 ^2').

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className2
			super: 'SuperMan'
			instvars: #(ivar1 ivar5 ivar3)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').

	packageDefinition 
		addClassDefinition: classDefinition.


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.


"new class version of SuperMan and remove methods"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className1.
	classDefinition instVarNames: #(ivar4).
	classDefinition
		removeInstanceMethod: #method4;
		removeClassMethod: #method5;
		yourself.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className2.
	classDefinition instVarNames: #(ivar1 ivar5).
	classDefinition
		removeInstanceMethod: #method3;
		removeClassMethod: #method2;
		yourself.

	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: 'SuperMan'.
	classDefinition instVarNames: #(ivar0).

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 393'
method: RwRowanProjectIssuesTest
testIssue393_new_version_class_with_subclass_with_extension_method_deletion_A

	"new test case:superclass has new class version ... the subclass has an extension method removed --- simplest case"
	"https://github.com/dalehenrich/Rowan/issues/393"

	| projectName  packageName1 packageName2 projectDefinition classDefinition packageDefinition className1  
		projectSetDefinition audit classExtensionDefinition |

	projectName := 'Issue326'.
	packageName1 := 'Issue326-Core'.
	packageName2 := 'Issue326-Extension'.
	className1 := 'Issue326Class1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition := (RwClassDefinition
		newForClassNamed: 'SuperMan'
			super: 'Object'
			instvars: #(ivar0)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className1
			super: 'SuperMan'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.

	packageDefinition 
		addClassDefinition: classDefinition.

	packageDefinition := projectDefinition packageNamed: packageName2.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: '*', packageName2 asLowercase
					source: 'method1 ^1').

	packageDefinition 
		addClassExtensionDefinition: classExtensionDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.


"new class version of SuperMan and remove extension method"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at: className1.

	classDefinition := (projectDefinition packageNamed: packageName1) classDefinitions at: 'SuperMan'.
	classDefinition instVarNames: #().

	classExtensionDefinition := (projectDefinition packageNamed: packageName2) classExtensions at:className1.
	classExtensionDefinition
		removeInstanceMethod: #method1;
		yourself.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 393'
method: RwRowanProjectIssuesTest
testIssue393_new_version_class_with_subclass_with_method_deletion_E

	"new test case:superclass has new class version ... each subclass has methods removed"
	"https://github.com/dalehenrich/Rowan/issues/393"

	| projectName  packageName projectDefinition classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition audit |

	projectName := 'Issue326'.
	packageName := 'Issue326-Core'.
	className1 := 'Issue326Class1'.
	className2 := 'Issue326Class2'.
	className3 := 'Issue326Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition := (RwClassDefinition
		newForClassNamed: 'SuperMan'
			super: 'Object'
			instvars: #(ivar0)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className1
			super: 'SuperMan'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^3').
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method5'
					protocol: 'accessing'
					source: 'method5 ^2').

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className2
			super: 'SuperMan'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').

	packageDefinition 
		addClassDefinition: classDefinition.


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.


"new class version of SuperMan and remove methods"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className1.
	classDefinition
		removeInstanceMethod: #method4;
		removeClassMethod: #method5;
		yourself.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className2.
	classDefinition
		removeInstanceMethod: #method3;
		removeClassMethod: #method2;
		yourself.

	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: 'SuperMan'.
	classDefinition instVarNames: #().

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

"validate"
	self assert: ((Rowan image loadedClassNamed: className1) loadedInstanceMethods values select: [:loadedMethod | loadedMethod selector == #method4 ]) isEmpty
%

category: 'tests-issue 393'
method: RwRowanProjectIssuesTest
testIssue393_new_version_class_with_subclass_with_method_deletion_F

	"new test case:superclass has new class version ... each subclass has SOME methods removed"
	"https://github.com/dalehenrich/Rowan/issues/393"

	| projectName  packageName projectDefinition classDefinition packageDefinition className1 className2 className3 
		projectSetDefinition audit |

	projectName := 'Issue326'.
	packageName := 'Issue326-Core'.
	className1 := 'Issue326Class1'.
	className2 := 'Issue326Class2'.
	className3 := 'Issue326Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition := (RwClassDefinition
		newForClassNamed: 'SuperMan'
			super: 'Object'
			instvars: #(ivar0)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className1
			super: 'SuperMan'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^3').
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method5'
					protocol: 'accessing'
					source: 'method5 ^2').

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className2
			super: 'SuperMan'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').

	packageDefinition 
		addClassDefinition: classDefinition.


"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.


"new class version of SuperMan and remove methods"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className1.
	classDefinition
		removeInstanceMethod: #method4;
		yourself.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className2.
	classDefinition
		removeInstanceMethod: #method3;
		yourself.

	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: 'SuperMan'.
	classDefinition instVarNames: #().

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

"validate"
	self assert: ((Rowan image loadedClassNamed: className1) loadedInstanceMethods values select: [:loadedMethod | loadedMethod selector == #method4 ]) isEmpty
%

category: 'tests-issue 393'
method: RwRowanProjectIssuesTest
testIssue393_new_version_class_with_subclass_with_method_deletion_G

	"new test case:superclass has new class version ... the subclass has a method removed --- simplest case"
	"https://github.com/dalehenrich/Rowan/issues/393"

	| projectName  packageName projectDefinition classDefinition packageDefinition className1  
		projectSetDefinition audit |

	projectName := 'Issue326'.
	packageName := 'Issue326-Core'.
	className1 := 'Issue326Class1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition := (RwClassDefinition
		newForClassNamed: 'SuperMan'
			super: 'Object'
			instvars: #(ivar0)
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.

	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := (RwClassDefinition
		newForClassNamed: className1
			super: 'SuperMan'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: 'category'
			comment: 'comment'
			pools: #()
			type: 'normal')
		yourself.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition 
		addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.


"new class version of SuperMan and remove method"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: className1.
	classDefinition
		removeInstanceMethod: #method1;
		yourself.

	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at: 'SuperMan'.
	classDefinition instVarNames: #().

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 40'
method: RwRowanProjectIssuesTest
testIssue40

	"https://github.com/dalehenrich/Rowan/issues/40"

	| projectName packageName theClass1 theClass2 projectDefinition classDefinition |
	projectName := 'Issue40_project'.
	packageName := 'Issue40-Core'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName toProjectNamed: projectName validate: false.

	theClass1 := self 
		_addClassNamed: 'Issue40Class_1' 
		superclassName: 'Object' 
		classVars: #( CVar1 )
		toPackageNamed: packageName 
		inProjectNamed: projectName 
		validate: false.

	theClass2 := self 
		_addClassNamed: 'Issue40Class_2' 
		superclassName: 'Issue40Class_1' 
		classVars: #( CVar2 )
		toPackageNamed: packageName 
		inProjectNamed: projectName 
		validate: false.

	self _addOrUpdateMethod: 'cvar1 ^CVar1' forBehavior: theClass2 class inPackage: packageName inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar2 ^CVar2' forBehavior: theClass2 class inPackage: packageName inProjectNamed: projectName validate: false.

	"add both class initializationMethods at once, so that order will be important - probably random order, unfortunately"
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at:  'Issue40Class_1'.
	classDefinition addClassMethodDefinition: (RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize CVar1 := 1.').
	classDefinition := (projectDefinition packageNamed: packageName) classDefinitions at:  'Issue40Class_2'.
	classDefinition addClassMethodDefinition: (RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize CVar2 := CVar1 + 1.').
	[ Rowan projectTools load loadProjectDefinition: projectDefinition ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].

	self assert: (theClass2 perform: #cvar1) = 1.
	self assert: (theClass2 perform: #cvar2) = 2.
%

category: 'tests-issue 41'
method: RwRowanProjectIssuesTest
testIssue41_addUpdateInitializeExtensionMethods

	"https://github.com/dalehenrich/Rowan/issues/41"

	"Are extension method initialization methods run correctly for add and update"

	| projectName packageName1 packageName2 className theClass initializeRun |
	projectName := 'Issue41_project'.
	packageName1 := 'Issue41-Core'.
	packageName2 := 'Issue41-Extensions'.
	className := 'Issue41Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.
	theClass := self _updateClassNamed: className toPackageNamed: packageName1 inProjectNamed: projectName validate: false.

	self _addOrUpdateMethod: 'cvar1 ^CVar1' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar2 ^CVar2' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	
	initializeRun := false.
	[ self _addOrUpdateMethod: 'initialize CVar1 := 1' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | 
			initializeRun := true.
			ex resume: true ].

	self assert: initializeRun.
	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) isNil.

	initializeRun := false.
	[ self _addOrUpdateMethod: 'initialize CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | 
			initializeRun := true.
			ex resume: true ].

	self assert: initializeRun.
	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) = 2.
%

category: 'tests-issue 41'
method: RwRowanProjectIssuesTest
testIssue41_interactiveAddUpdateInitializeExtensionMethods

	"https://github.com/dalehenrich/Rowan/issues/41"

	"Are extension method initialization methods run correctly for add and update - interactive edits should not trigger updates "

	| projectName packageName1 packageName2 className theClass  |
	projectName := 'Issue41_project'.
	packageName1 := 'Issue41-Core'.
	packageName2 := 'Issue41-Extensions'.
	className := 'Issue41Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.
	theClass := self _updateClassNamed: className toPackageNamed: packageName1 inProjectNamed: projectName validate: false.

	self _addOrUpdateMethod: 'cvar1 ^CVar1' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar2 ^CVar2' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	
	self _addOrUpdateMethod: 'initialize CVar1 := 1' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) isNil.

	self _addOrUpdateMethod: 'initialize CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) = 2.
%

category: 'tests-issue 41'
method: RwRowanProjectIssuesTest
testIssue41_interactiveMoveInitializeExtensionMethodToPackage

	"https://github.com/dalehenrich/Rowan/issues/41"

	"Are extension method initialization methods run correctly for add and update"

	| projectName packageName1 packageName2 packageName3 className theClass loadedPackage loadedClassExtensions |
	projectName := 'Issue41_project'.
	packageName1 := 'Issue41-Core'.
	packageName2 := 'Issue41-Extensions1'.
	packageName3 := 'Issue41-Extensions2'.
	className := 'Issue41Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName3 toProjectNamed: projectName validate: false.
	theClass := self _updateClassNamed: className toPackageNamed: packageName1 inProjectNamed: projectName validate: false.

	self _addOrUpdateMethod: 'cvar1 ^CVar1' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar2 ^CVar2' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar1: anInt CVar1 := anInt' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar2: anInt CVar2 := anInt' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	
	"create initialize package as an extension method"
	self _addOrUpdateMethod: 'initialize CVar1 := 1' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) isNil.

	theClass 
		perform: #cvar1: with: 3;
		perform: #cvar2: with: 4.
	self assert: (theClass perform: #cvar1) = 3.
	self assert: (theClass perform: #cvar2) = 4.

	"initialize method changed in same package"
	self _addOrUpdateMethod: 'initialize "" CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) = 2.

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) classMethodDefinitions includesKey: #initialize).

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: (loadedClassExtensions at: className ifAbsent: []) isNil.

	theClass 
		perform: #cvar1: with: 5;
		perform: #cvar2: with: 6.
	self assert: (theClass perform: #cvar1) = 5.
	self assert: (theClass perform: #cvar2) = 6.

	"initialize method not changed and moved to new package"
	self _addOrUpdateMethod: 'initialize "" CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName3 inProjectNamed: projectName validate: false.

	self assert: (theClass perform: #cvar1) = 5.
	self assert: (theClass perform: #cvar2) = 6.

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) classMethodDefinitions includesKey: #initialize).

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self deny: ((loadedClassExtensions at: className) classMethodDefinitions includesKey: #initialize).

	theClass 
		perform: #cvar1: with: 5;
		perform: #cvar2: with: 6.
	self assert: (theClass perform: #cvar1) = 5.
	self assert: (theClass perform: #cvar2) = 6.

	"initialize method not changed and left in same package"
	self _addOrUpdateMethod: 'initialize "" CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName3 inProjectNamed: projectName validate: false.

	self assert: (theClass perform: #cvar1) = 5.
	self assert: (theClass perform: #cvar2) = 6.

	"initialize method not changed and moved to new package"
	self _addOrUpdateMethod: 'initialize "" CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.

	self assert: (theClass perform: #cvar1) = 5.
	self assert: (theClass perform: #cvar2) = 6.

	theClass initialize.

	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) = 2.

	theClass 
		perform: #cvar1: with: 5;
		perform: #cvar2: with: 6.
	self assert: (theClass perform: #cvar1) = 5.
	self assert: (theClass perform: #cvar2) = 6.

	"initialize method changed and moved to new package"
	self _addOrUpdateMethod: 'initialize CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName3 inProjectNamed: projectName validate: false.

	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) = 2.
%

category: 'tests-issue 41'
method: RwRowanProjectIssuesTest
testIssue41_moveInitializeExtensionMethodToPackage

	"https://github.com/dalehenrich/Rowan/issues/41"

	"Are extension method initialization methods run correctly for add and update"

	| projectName packageName1 packageName2 packageName3 className theClass initializeRun |
	projectName := 'Issue41_project'.
	packageName1 := 'Issue41-Core'.
	packageName2 := 'Issue41-Extensions1'.
	packageName3 := 'Issue41-Extensions2'.
	className := 'Issue41Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName3 toProjectNamed: projectName validate: false.
	theClass := self _updateClassNamed: className toPackageNamed: packageName1 inProjectNamed: projectName validate: false.

	self _addOrUpdateMethod: 'cvar1 ^CVar1' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar2 ^CVar2' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar1: anInt CVar1 := anInt' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar2: anInt CVar2 := anInt' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false.
	
	initializeRun := false.
	[ self _addOrUpdateMethod: 'initialize CVar1 := 1' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | 
			initializeRun := true.
			ex resume: true ].

	self assert: initializeRun.
	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) isNil.

	theClass 
		perform: #cvar1: with: 3;
		perform: #cvar2: with: 4.
	self assert: (theClass perform: #cvar1) = 3.
	self assert: (theClass perform: #cvar2) = 4.

	initializeRun := false.
	[	"initialize method changed in same package"
		self _addOrUpdateMethod: 'initialize "" CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | 
				initializeRun := true.
				ex resume: true ].

	self assert: initializeRun.
	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) = 2.

	theClass 
		perform: #cvar1: with: 5;
		perform: #cvar2: with: 6.
	self assert: (theClass perform: #cvar1) = 5.
	self assert: (theClass perform: #cvar2) = 6.

	initializeRun := false.
	[	"initialize method changed and moved to new package"
		self _addOrUpdateMethod: 'initialize CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName3 inProjectNamed: projectName validate: false ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | 
				initializeRun := true.
				ex resume: true ].

	self assert: initializeRun.
	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) = 2.

	theClass 
		perform: #cvar1: with: 5;
		perform: #cvar2: with: 6.
	self assert: (theClass perform: #cvar1) = 5.
	self assert: (theClass perform: #cvar2) = 6.

	initializeRun := false.
	[	"initialize method not changed and left in same package"
		self _addOrUpdateMethod: 'initialize CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName3 inProjectNamed: projectName validate: false ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | 
				initializeRun := true.
				ex resume: true ].

	self deny: initializeRun.
	self assert: (theClass perform: #cvar1) = 5.
	self assert: (theClass perform: #cvar2) = 6.

	theClass initialize.

	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) = 2.
%

category: 'tests-issue 41'
method: RwRowanProjectIssuesTest
testIssue41_moveUnchangedInitializeExtensionMethodToPackage

	"https://github.com/dalehenrich/Rowan/issues/41"

	"initialize method not changed and moved to new package"

	| projectName packageName1 packageName2 packageName3 className theClass initializeRun |
	projectName := 'Issue41_project'.
	packageName1 := 'Issue41-Core'.
	packageName2 := 'Issue41-Extensions1'.
	packageName3 := 'Issue41-Extensions2'.
	className := 'Issue41Class'.

	self _createLoadedProjectNamed: projectName root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' validate: false.
	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName2 toProjectNamed: projectName validate: false.
	self _addPackageNamed: packageName3 toProjectNamed: projectName validate: false.
	theClass := self _updateClassNamed: className toPackageNamed: packageName1 inProjectNamed: projectName validate: false.

	self _addOrUpdateMethod: 'cvar1 ^CVar1' forBehavior: theClass class inPackage: packageName1 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar2 ^CVar2' forBehavior: theClass class inPackage: packageName1 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar1: anInt CVar1 := anInt' forBehavior: theClass class inPackage: packageName1 inProjectNamed: projectName validate: false.
	self _addOrUpdateMethod: 'cvar2: anInt CVar2 := anInt' forBehavior: theClass class inPackage: packageName1 inProjectNamed: projectName validate: false.

	initializeRun := false.
	[ self _addOrUpdateMethod: 'initialize CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName1 inProjectNamed: projectName validate: false ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | 
				initializeRun := true.
				ex resume: true ].

	self assert: initializeRun.
	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) = 2.

	theClass 
		perform: #cvar1: with: 3;
		perform: #cvar2: with: 4.
	self assert: (theClass perform: #cvar1) = 3.
	self assert: (theClass perform: #cvar2) = 4.

	initializeRun := false.
	[	"initialize method not changed and moved to new package"
		self _addOrUpdateMethod: 'initialize CVar1 := 1. CVar2 := 2' forBehavior: theClass class inPackage: packageName2 inProjectNamed: projectName validate: false ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | 
				initializeRun := true.
				ex resume: true ].

	self deny: initializeRun.
	self assert: (theClass perform: #cvar1) = 3.
	self assert: (theClass perform: #cvar2) = 4.

	theClass initialize.

	self assert: (theClass perform: #cvar1) = 1.
	self assert: (theClass perform: #cvar2) = 2.
%

category: 'tests-issue 467'
method: RwRowanProjectIssuesTest
testIssue467_new_version_class_with_subclasses_1

	"https://github.com/dalehenrich/Rowan/issues/467"

	"
	1. move shared/common inst var to superclass. [pass]
	2. move shared/common inst var to superclass. One subclass in different symbol dictionary. [pass]
	3. scenario 2 with extra subclasses in hierarchy [reproduce bug]
	4. senario 3 with a few more extra subclasses (passing)
	5. senario 4 moving a subclass to another package (in same symbol dictionary)
	6. senario 4 moving a subclass to another package (in different symbol dictionary)
	"

	| projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition2 classDefinition3 packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 audit |

	projectName := 'Issue467'.
	packageName1 := 'Issue467-Core1'.
	packageName2 := 'Issue467-Core2'.
	className1 := 'Issue461Class1'.
	className2 := 'Issue467Class2'.
	className3 := 'Issue467Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition2 := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition2.

	packageDefinition := projectDefinition packageNamed: packageName2.

	classDefinition3 := (RwClassDefinition
		newForClassNamed: className3
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition3.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class2 instVarNames = #(ivar1).
	self assert: class2 superclass == class1.
	class3 := Rowan globalNamed: className3.
	self assert: class3 instVarNames = #(ivar1).
	self assert: class3 superclass == class1.

"modify class -- new version"
	classDefinition1 instVarNames: #(ivar1).
	classDefinition2 instVarNames: #().
	classDefinition3 instVarNames: #().

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass1 := class1.
	oldClass2 := class2.
	oldClass3 := class3.
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.

	self assert: class1 ~~ oldClass1.
	self assert: class1 instVarNames = #(ivar1).

	self assert: class2 ~~ oldClass2.
	self assert: class2 instVarNames = #().
	self assert: class2 superclass == class1.

	self assert: class3 ~~ oldClass3.
	self assert: class3 instVarNames = #().
	self assert: class3 superclass == class1.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 467'
method: RwRowanProjectIssuesTest
testIssue467_new_version_class_with_subclasses_2

	"https://github.com/dalehenrich/Rowan/issues/467"

	"
	1. move shared/common inst var to superclass. [pass]
	2. move shared/common inst var to superclass. One subclass in different symbol dictionary. [pass]
	3. scenario 2 with extra subclasses in hierarchy [reproduce bug]
	4. senario 3 with a few more extra subclasses (passing)
	5. senario 4 moving a subclass to another package (in same symbol dictionary)
	6. senario 4 moving a subclass to another package (in different symbol dictionary)
	"

	| projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition2 classDefinition3 packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 audit |

	projectName := 'Issue467'.
	packageName1 := 'Issue467-Core1'.
	packageName2 := 'Issue467-Core2'.
	className1 := 'Issue461Class1'.
	className2 := 'Issue467Class2'.
	className3 := 'Issue467Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition2 := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition2.

	packageDefinition := projectDefinition packageNamed: packageName2.

	classDefinition3 := (RwClassDefinition
		newForClassNamed: className3
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition3.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class2 instVarNames = #(ivar1).
	self assert: class2 superclass == class1.
	class3 := Rowan globalNamed: className3.
	self assert: class3 instVarNames = #(ivar1).
	self assert: class3 superclass == class1.

"modify class -- new version"
	classDefinition1 instVarNames: #(ivar1).
	classDefinition2 instVarNames: #().
	classDefinition3 instVarNames: #().

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass1 := class1.
	oldClass2 := class2.
	oldClass3 := class3.
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.

	self assert: class1 ~~ oldClass1.
	self assert: class1 instVarNames = #(ivar1).

	self assert: class2 ~~ oldClass2.
	self assert: class2 instVarNames = #().
	self assert: class2 superclass == class1.

	self assert: class3 ~~ oldClass3.
	self assert: class3 instVarNames = #().
	self assert: class3 superclass == class1.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 467'
method: RwRowanProjectIssuesTest
testIssue467_new_version_class_with_subclasses_3

	"https://github.com/dalehenrich/Rowan/issues/467"

	"
	1. move shared/common inst var to superclass. [pass]
	2. move shared/common inst var to superclass. One subclass in different symbol dictionary. [pass]
	3. scenario 2 with extra subclasses in hierarchy [reproduce bug]
	4. senario 3 with a few more extra subclasses (passing)
	5. senario 4 moving a subclass to another package (in same symbol dictionary)
	6. senario 4 moving a subclass to another package (in different symbol dictionary)
	"

	| projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition2 classDefinition3 packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 extraClassDefinition audit |

	projectName := 'Issue467'.
	packageName1 := 'Issue467-Core1'.
	packageName2 := 'Issue467-Core2'.
	className1 := 'Issue461Class1'.
	className2 := 'Issue467Class2'.
	className3 := 'Issue467Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition2 := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition2.

	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className2, '_extra'
			super: className2
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.

	packageDefinition := projectDefinition packageNamed: packageName2.

	classDefinition3 := (RwClassDefinition
		newForClassNamed: className3
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition3.

	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className3, '_extra'
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class2 instVarNames = #(ivar1).
	self assert: class2 superclass == class1.
	class3 := Rowan globalNamed: className3.
	self assert: class3 instVarNames = #(ivar1).
	self assert: class3 superclass == class1.

"modify class -- new version"
	classDefinition1 instVarNames: #(ivar1).
	classDefinition2 instVarNames: #().
	classDefinition3 instVarNames: #().

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass1 := class1.
	oldClass2 := class2.
	oldClass3 := class3.
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.

	self assert: class1 ~~ oldClass1.
	self assert: class1 instVarNames = #(ivar1).

	self assert: class2 ~~ oldClass2.
	self assert: class2 instVarNames = #().
	self assert: class2 superclass == class1.

	self assert: class3 ~~ oldClass3.
	self assert: class3 instVarNames = #().
	self assert: class3 superclass == class1.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 467'
method: RwRowanProjectIssuesTest
testIssue467_new_version_class_with_subclasses_4

	"https://github.com/dalehenrich/Rowan/issues/467"

	"
	1. move shared/common inst var to superclass. [pass]
	2. move shared/common inst var to superclass. One subclass in different symbol dictionary. [pass]
	3. scenario 2 with extra subclasses in hierarchy [reproduce bug]
	4. senario 3 with a few more extra subclasses (passing)
	5. senario 4 moving a subclass to another package (in same symbol dictionary)
	6. senario 4 moving a subclass to another package (in different symbol dictionary)
	"

	| projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition2 classDefinition3 packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 extraClassDefinition audit |

	projectName := 'Issue467'.
	packageName1 := 'Issue467-Core1'.
	packageName2 := 'Issue467-Core2'.
	className1 := 'Issue461Class1'.
	className2 := 'Issue467Class2'.
	className3 := 'Issue467Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition2 := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition2.

	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className2, '_extra_1'
			super: className2
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.
	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className2, '_extra_2'
			super: className2
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.
	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className2, '_extra_3'
			super: className2, '_extra_2'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.

	packageDefinition := projectDefinition packageNamed: packageName2.

	classDefinition3 := (RwClassDefinition
		newForClassNamed: className3
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition3.

	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className3, '_extra_1'
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.
	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className3, '_extra_2'
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.
	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className3, '_extra_3'
			super:  className3, '_extra_2'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class2 instVarNames = #(ivar1).
	self assert: class2 superclass == class1.
	class3 := Rowan globalNamed: className3.
	self assert: class3 instVarNames = #(ivar1).
	self assert: class3 superclass == class1.

"modify class -- new version"
	classDefinition1 instVarNames: #(ivar1).
	classDefinition2 instVarNames: #().
	classDefinition3 instVarNames: #().

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass1 := class1.
	oldClass2 := class2.
	oldClass3 := class3.
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.

	self assert: class1 ~~ oldClass1.
	self assert: class1 instVarNames = #(ivar1).

	self assert: class2 ~~ oldClass2.
	self assert: class2 instVarNames = #().
	self assert: class2 superclass == class1.

	self assert: class3 ~~ oldClass3.
	self assert: class3 instVarNames = #().
	self assert: class3 superclass == class1.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 467'
method: RwRowanProjectIssuesTest
testIssue467_new_version_class_with_subclasses_5

	"https://github.com/dalehenrich/Rowan/issues/467"

	"
	1. move shared/common inst var to superclass. [pass]
	2. move shared/common inst var to superclass. One subclass in different symbol dictionary. [pass]
	3. scenario 2 with extra subclasses in hierarchy [reproduce bug]
	4. senario 3 with a few more extra subclasses (passing)
	5. senario 4 moving a subclass to another package (in same symbol dictionary)
	6. senario 4 moving a subclass to another package (in different symbol dictionary)
	"

	| projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition2 classDefinition3 packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 extraClassDefinition packageName3 audit |

	projectName := 'Issue467'.
	packageName1 := 'Issue467-Core1'.
	packageName2 := 'Issue467-Core2'.
	packageName3 := 'Issue467-Core3'.
	className1 := 'Issue461Class1'.
	className2 := 'Issue467Class2'.
	className3 := 'Issue467Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName3;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition2 := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition2.

	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className2, '_extra_1'
			super: className2
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.
	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className2, '_extra_2'
			super: className2
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.
	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className2, '_extra_3'
			super: className2, '_extra_2'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.

	packageDefinition := projectDefinition packageNamed: packageName2.

	classDefinition3 := (RwClassDefinition
		newForClassNamed: className3
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition3.

	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className3, '_extra_1'
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.
	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className3, '_extra_2'
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.

	packageDefinition := projectDefinition packageNamed: packageName3.

	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className3, '_extra_3'
			super:  className3, '_extra_2'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName3
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class2 instVarNames = #(ivar1).
	self assert: class2 superclass == class1.
	class3 := Rowan globalNamed: className3.
	self assert: class3 instVarNames = #(ivar1).
	self assert: class3 superclass == class1.

"modify class -- new version"
	classDefinition1 instVarNames: #(ivar1).
	classDefinition2 instVarNames: #().
	classDefinition3 instVarNames: #().

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass1 := class1.
	oldClass2 := class2.
	oldClass3 := class3.
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.

	self assert: class1 ~~ oldClass1.
	self assert: class1 instVarNames = #(ivar1).

	self assert: class2 ~~ oldClass2.
	self assert: class2 instVarNames = #().
	self assert: class2 superclass == class1.

	self assert: class3 ~~ oldClass3.
	self assert: class3 instVarNames = #().
	self assert: class3 superclass == class1.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 467'
method: RwRowanProjectIssuesTest
testIssue467_new_version_class_with_subclasses_6

	"https://github.com/dalehenrich/Rowan/issues/467"

	"
	1. move shared/common inst var to superclass. [pass]
	2. move shared/common inst var to superclass. One subclass in different symbol dictionary. [pass]
	3. scenario 2 with extra subclasses in hierarchy [reproduce bug]
	4. senario 3 with a few more extra subclasses (passing)
	5. senario 4 moving a subclass to another package (in same symbol dictionary)
	6. senario 4 moving a subclass to another package (in different symbol dictionary)
	"

	| projectName  packageName1 packageName2 projectDefinition classDefinition1 classDefinition2 classDefinition3 packageDefinition className1 className2 className3 
		projectSetDefinition class1 class2 class3 oldClass1 oldClass2 oldClass3 extraClassDefinition packageName3 audit |

	projectName := 'Issue467'.
	packageName1 := 'Issue467-Core1'.
	packageName2 := 'Issue467-Core2'.
	packageName3 := 'Issue467-Core3'.
	className1 := 'Issue461Class1'.
	className2 := 'Issue467Class2'.
	className3 := 'Issue467Class3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName3;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition1 := (RwClassDefinition
		newForClassNamed: className1
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition1.

	classDefinition2 := (RwClassDefinition
		newForClassNamed: className2
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition2.

	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className2, '_extra_1'
			super: className2
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.
	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className2, '_extra_2'
			super: className2
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.
	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className2, '_extra_3'
			super: className2, '_extra_2'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.

	packageDefinition := projectDefinition packageNamed: packageName2.

	classDefinition3 := (RwClassDefinition
		newForClassNamed: className3
			super: className1
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: classDefinition3.

	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className3, '_extra_1'
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.
	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className3, '_extra_2'
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.

	packageDefinition := projectDefinition packageNamed: packageName3.

	extraClassDefinition := (RwClassDefinition
		newForClassNamed: className3, '_extra_3'
			super:  className3, '_extra_2'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName3
			comment: 'comment'
			pools: #()
			type: 'normal').
	packageDefinition 
		addClassDefinition: extraClassDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	self assert: class2 instVarNames = #(ivar1).
	self assert: class2 superclass == class1.
	class3 := Rowan globalNamed: className3.
	self assert: class3 instVarNames = #(ivar1).
	self assert: class3 superclass == class1.

"modify class -- new version"
	classDefinition1 instVarNames: #(ivar1).
	classDefinition2 instVarNames: #().
	classDefinition3 instVarNames: #().

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass1 := class1.
	oldClass2 := class2.
	oldClass3 := class3.
	class1 := Rowan globalNamed: className1.
	class2 := Rowan globalNamed: className2.
	class3 := Rowan globalNamed: className3.

	self assert: class1 ~~ oldClass1.
	self assert: class1 instVarNames = #(ivar1).

	self assert: class2 ~~ oldClass2.
	self assert: class2 instVarNames = #().
	self assert: class2 superclass == class1.

	self assert: class3 ~~ oldClass3.
	self assert: class3 instVarNames = #().
	self assert: class3 superclass == class1.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests-issue 498'
method: RwRowanProjectIssuesTest
testIssue498_constraint_ordering_2

	"https://github.com/dalehenrich/Rowan/issues/498 -- expanded validation over https://github.com/dalehenrich/Rowan/issues/293"

	"constraints should be displayed in inst var order, not alphabetical order"

	"rowan variant of test ... _1 uses non-Rowan api"

	| projectName  packageName projectDefinition classDefinition packageDefinition className1 className2 
		className3 projectSetDefinition class constraintBlock1 constraintBlock2 constraintBlock3 x |
	projectName := 'Issue255'.
	packageName := 'Issue255-Core'.
	className1 := 'Issue255Class1'.
	className2 := 'Issue255Subclass2'.
	className3 := 'Issue255Subclass3'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].
"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #( ivar2 ivar3 ivar4 ivar1)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition gs_constraints: { { 'ivar4' . 'Association' }. { 'ivar3' . 'Association' }. { 'ivar2' . 'Association' }. { 'ivar1' . 'Association' }. }.
	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: className1
		instvars: #( ivar7 ivar6)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition gs_constraints: { { 'ivar7' . 'Association' }. { 'ivar6' . 'Association' }. }.
	packageDefinition 
		addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: className2
		instvars: #( ivar8 ivar9)
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition gs_constraints: { { 'ivar9' . 'Association' }. { 'ivar8' . 'Association' }. }.
	packageDefinition 
		addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class := Rowan globalNamed: className1.
	self assert: (class _constraintsEqual: {  { #'ivar1' . Association }.  { #'ivar2' . Association }. { #'ivar3' . Association }. { #'ivar4' . Association }.  }).

	class := Rowan globalNamed: className2.
	self assert: (class _constraintsEqual: {  { #'ivar7' . Association }.  { #'ivar6' . Association }. }).

	class := Rowan globalNamed: className3.
	self assert: (class _constraintsEqual: {  { #'ivar8' . Association }.  { #'ivar9' . Association }. }).

	constraintBlock1 := [:theClass |
		self assert: (x := theClass _constraintOn: #ivar1) == Association.
		self assert: (x := theClass _constraintOn: #ivar2) == Association.
		self assert: (x := theClass _constraintOn: #ivar3) == Association.
		self assert: (x := theClass _constraintOn: #ivar4) == Association ].
	constraintBlock2 := [:theClass |
		self assert: (x := theClass _constraintOn: #ivar6) == Association.
		self assert: (x := theClass _constraintOn: #ivar7) == Association ].
	constraintBlock3 := [:theClass |
		self assert: (x := theClass _constraintOn: #ivar8) == Association.
		self assert: (x := theClass _constraintOn: #ivar9) == Association ].

	constraintBlock1 value: (Rowan globalNamed: className1).

	constraintBlock1 value: (Rowan globalNamed: className2).
	constraintBlock2 value: (Rowan globalNamed: className2).

	constraintBlock1 value: (Rowan globalNamed: className3).
	constraintBlock2 value: (Rowan globalNamed: className3).
	constraintBlock3 value: (Rowan globalNamed: className3).
%

category: 'tests-issue 72'
method: RwRowanProjectIssuesTest
testIssue72_addMethod
	"https://github.com/dalehenrich/Rowan/issues/72"

	| x |
	self 
		should: [
			"add an unpackaged method - expect error"
			Object
				rwCompileMethod: 'bar ^''bar'''
				category: 'accessing' ]
		raise: Error.

	(Object compiledMethodAt: #bar environmentId: 0 otherwise: nil)
		ifNotNil: [ Object removeSelector: #'bar' ].

	[
		"handle notification and abort the operation"
		Object
			rwCompileMethod: 'bar ^''bar'''
			category: 'accessing' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | "abort"].
	self assert: (x := Object compiledMethodAt: #bar environmentId: 0 otherwise: nil) isNil.

	[
		"handle notification and complete operation"
		Object
			rwCompileMethod: 'bar ^''bar'''
			category: 'accessing' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].

	"ensure that the new method is not packaged"
	Rowan image 
		loadedMethod: #bar 
		inClassNamed: 'Object' 
		isMeta: false 
		ifFound: [self assert: false description: 'unexpected loaded method' ] 
		ifAbsent: ["expected"].

	self assert: Object new bar = 'bar'.
	Object removeSelector: #'bar'
%

category: 'tests-issue 72'
method: RwRowanProjectIssuesTest
testIssue72_removeClass
	"https://github.com/dalehenrich/Rowan/issues/72"

	"nothing special really needed when adding/updating an uppackaged class, just use the standard class creation protocol"

	| className browser |
	className := 'Issue72TestClass'.
	Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: self _symbolDictionary
		options: #().
	self assert: (Rowan image objectNamed: className) notNil.

	browser := Rowan projectTools browser.

	self 
		should: [ browser removeClassNamed: className ]
		raise: Error.
	self assert: (Rowan image objectNamed: className) notNil.

	[
		"handle notification and abort the remove"
		browser removeClassNamed: className ]
			on: RwPerformingUnpackagedEditNotification
			do: [:ex | "abort"].
	self assert: (Rowan image objectNamed: className) notNil.

	[
		"handle notification and complete removal"
		browser removeClassNamed: className  ]
			on: RwPerformingUnpackagedEditNotification
			do: [:ex | ex resume ].
	self assert: (Rowan image objectNamed: className) isNil.
%

category: 'tests-issue 72'
method: RwRowanProjectIssuesTest
testIssue72_removeClassWithExtensions
	"https://github.com/dalehenrich/Rowan/issues/72"

	"Need to worry about removing an unpackaged class that has extension methods"

	| className theClass projectName packageName packageNames |

	className := 'Issue72TestClass'.
	theClass := Object subclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: self _symbolDictionary
		options: #().
	self assert: (Rowan image objectNamed: className) notNil.
	self assert: (Rowan image loadedClassNamed: className ifAbsent: []) isNil.
	self assert: ((Rowan image loadedClassExtensionsForClass: theClass) select: [:each | each isEmpty not ]) isEmpty.

	projectName := 'Issue72Project'.
	packageName := 'Issue72Project-Extensions'.
	packageNames := {packageName}.
	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName
		comment: 'issue 72 project'.

	theClass rwCompileMethod: 'bar ^''bar'''
				category: '*', packageName asLowercase.

	self assert: (Rowan image objectNamed: className) notNil.
	self assert: (Rowan image loadedClassNamed: className ifAbsent: []) isNil.
	self assert: ((Rowan image loadedClassExtensionsForClass: theClass) select: [:each | each isEmpty not ]) notEmpty.

	[
		"handle notification and complete removal"
		Rowan projectTools browser removeClassNamed: className  ]
			on: RwPerformingUnpackagedEditNotification
			do: [:ex | ex resume ].
	self assert: (Rowan image objectNamed: className) isNil.
	self assert: (Rowan image loadedClassNamed: className ifAbsent: []) isNil.
	self assert: ((Rowan image loadedClassExtensionsForClass: theClass) select: [:each | each isEmpty not ]) isEmpty.
%

category: 'tests-issue 72'
method: RwRowanProjectIssuesTest
testIssue72_removeMethod
	"https://github.com/dalehenrich/Rowan/issues/72"

	[
		"add unpackaged method"
		Object
			rwCompileMethod: 'bar ^''bar'''
			category: 'accessing' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].
	self assert: Object new bar = 'bar'.

	self 
		should: [
			"attempt to remove existing unpackaged method - expect error"
			Object rwRemoveSelector: #bar ]
		raise: Error.
	self assert: Object new bar = 'bar'.

	[
		"handle notification and abort the remove"
		Object rwRemoveSelector: #bar ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | "abort"].
	self assert: Object new bar = 'bar'.

	[
		"handle notification and complete removal"
		Object rwRemoveSelector: #bar  ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].
	self should: [ Object new bar ] raise: MessageNotUnderstood.
%

category: 'tests-issue 72'
method: RwRowanProjectIssuesTest
testIssue72_updateMethod
	"https://github.com/dalehenrich/Rowan/issues/72"

	[
		"add unpackaged method"
		Object
			rwCompileMethod: 'bar ^''bar'''
			category: 'accessing' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].
	self assert: Object new bar = 'bar'.

	self 
		should: [
			"attempt to update existing unpackaged method - expect error"
			Object
				rwCompileMethod: 'bar ^''foo'''
				category: 'accessing' ]
		raise: Error.
	self assert: Object new bar = 'bar'.

	[
		"handle notification and abort the operation"
		Object
			rwCompileMethod: 'bar ^''foo'''
			category: 'accessing' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | "abort"].
	self assert: Object new bar = 'bar'.

	[
		"handle notification and complete operation"
		Object
			rwCompileMethod: 'bar ^''foo'''
			category: 'accessing' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].
	self assert: Object new bar = 'foo'.

	Object removeSelector: #'bar'
%

category: 'tests-issue 91'
method: RwRowanProjectIssuesTest
testIssue91
	"add class in one package, add extension in another package, new version of class, 
		update extension method - boom?"

	"https://github.com/dalehenrich/Rowan/issues/91"

	| projectName packageNames packageName1 packageName2 className testClass testInstance newClass fooMethod |
	projectName := 'Issue91'.
	packageName1 := 'Issue91-Core'.
	packageName2 := 'Issue91-Extensions'.
	packageNames := {packageName1. packageName2}.
	className := 'Issue91Class'.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	self
		_loadStandardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment:
			'This project is being used to reproduce the problem reported in Issue #91.'
		className: className
		inPackageName: packageName1.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.

	testClass
		rwCompileMethod: 'foo ^''foo'''
		category: '*' , packageName2 asLowercase. "create extension method"

	newClass := Object rwSubclass: 'Issue91Class'
		instVarNames: #( ivar1 ivar2)
		classVars: #( Cvar1)
		classInstVars: #( civar1)
		poolDictionaries: #()
		category: 'Simple Things'
		packageName: 'Issue91-Core'
		constraints: #()
		options: #().

	self assert: newClass ~~ testClass.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.
	self assert: (testInstance perform: #foo) = 'foo'.

	fooMethod := testClass
		rwCompileMethod: 'foo ^''bar'''
		category: '*' , packageName2 asLowercase. "create extension method"

	self assert: (testInstance perform: #foo) = 'bar'.
	self assert: fooMethod rowanPackageName = packageName2.
%

category: 'private'
method: RwRowanProjectIssuesTest
_addClassNamed: className superclassName: superclassName classVars: classVars toPackageNamed: packageName inProjectNamed: projectName validate: validate

	"validate the dirty state of project before and after class is added"

	| project package theClass |

	project := RwProject newNamed: projectName.
	package := RwPackage newNamed: packageName.

	validate ifTrue: [ 
		self deny: project isDirty.
		self deny: package isDirty ].

	theClass := (Rowan globalNamed: superclassName)
		rwSubclass: className
		instVarNames: #()
		classVars: classVars
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().

	validate ifTrue: [ 
		self assert: project isDirty.
		self assert: package isDirty ].

	^theClass
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_addClassNamed: className toPackageNamed: packageName inProjectNamed: projectName

	^ self _addClassNamed: className toPackageNamed: packageName inProjectNamed: projectName validate: true
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_addClassNamed: className toPackageNamed: packageName inProjectNamed: projectName validate: validate

	"validate the dirty state of project before and after class is added"

	| project package theClass |

	project := RwProject newNamed: projectName.
	package := RwPackage newNamed: packageName.

	validate ifTrue: [ 
		self deny: project isDirty.
		self deny: package isDirty ].

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().

	validate ifTrue: [ 
		self assert: project isDirty.
		self assert: package isDirty ].

	^theClass
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_addOrUpdateMethod: methodSource forBehavior: theBehavior inPackage: packageName inProjectNamed: projectName

	^ self _addOrUpdateMethod: methodSource forBehavior: theBehavior inPackage: packageName inProjectNamed: projectName validate: true
%

category: 'private'
method: RwRowanProjectIssuesTest
_addOrUpdateMethod: methodSource forBehavior: theBehavior inPackage: packageName inProjectNamed: projectName validate: validate

	"validate the dirty state of project before and after method is added or updated"

	| project package |

	project := RwProject newNamed: projectName.
	package := RwPackage newNamed: packageName.

	validate ifTrue: [ 
		self deny: project isDirty.
		self deny: package isDirty].

	theBehavior rowanPackageName = packageName
		ifTrue: [
			theBehavior
				rwCompileMethod: methodSource
				category:  'other' ]
		ifFalse: [
			theBehavior
				rwCompileMethod: methodSource
				category:  '*' , packageName asLowercase ].

	validate ifTrue: [ 
		self assert: project isDirty.
		self assert: package isDirty ].
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_addPackageNamed: packageName toProjectNamed: projectName

	^ self _addPackageNamed: packageName toProjectNamed: projectName validate: true
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_addPackageNamed: packageName toProjectNamed: projectName validate: validate

	"validate the dirty state of project before and after add package call"

	| project |

	project := RwProject newNamed: projectName.

	validate ifTrue: [ self deny: project isDirty ].

	Rowan projectTools browser addPackageNamed: packageName toProjectNamed: projectName.

	validate ifTrue: [ self assert: project isDirty ].
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_createLoadedProjectNamed: projectName packageNames: packageNames root: rootPath validate: validate

	^ self 
		_createLoadedProjectNamed: projectName
		packageNames: packageNames
		root: rootPath 
		symbolDictionaryName: self _symbolDictionaryName 
		validate: validate
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_createLoadedProjectNamed: projectName root: rootPath

	^ self _createLoadedProjectNamed: projectName root: rootPath validate: true
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_createLoadedProjectNamed: projectName root: rootPath symbolDictionaryName: symbolDictionaryName validate: validate

	^ self _createLoadedProjectNamed: projectName packageNames: #() root: rootPath symbolDictionaryName: symbolDictionaryName validate: validate
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_createLoadedProjectNamed: projectName root: rootPath validate: validate

	^ self 
		_createLoadedProjectNamed: projectName 
		root: rootPath 
		symbolDictionaryName: self _symbolDictionaryName 
		validate: validate
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_removeClassNamed: className fromProjectNamed: projectName

	^ self _removeClassNamed: className fromProjectNamed: projectName validate: true
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_removeClassNamed: className fromProjectNamed: projectName validate: validate

	"validate the dirty state of project before and after class is added"

	| project package |

	project := RwProject newNamed: projectName.
	package := RwPackage newNamed: (Rowan globalNamed: className) rowanPackageName.

	validate ifTrue: [ 
		self deny: project isDirty.
		self deny: package isDirty ].

	Rowan projectTools browser removeClassNamed: className.

	validate ifTrue: [ 
		self assert: project isDirty.
		self assert: package isDirty ].
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_removePackageNamed: packageName from: projectName

	^ self _removePackageNamed: packageName from: projectName validate: true
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_removePackageNamed: packageName from: projectName validate: validate

	"validate the dirty state of project before and after remove package call"

	| project |

	project := RwProject newNamed: projectName.

	validate ifTrue: [ self deny: project isDirty ].

	Rowan projectTools browser removePackageNamed: packageName.

	(Rowan image loadedPackageNamed: packageName ifAbsent: [])
		ifNotNil: [:loadedPackage | self assert: false description: 'unexpected loaded package ', packageName printString ].

	validate ifTrue: [ self assert: project isDirty ].
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_removeSelector: selector fromBehavior: theBehavior inProjectNamed: projectName

	^ self _removeSelector: selector fromBehavior: theBehavior inProjectNamed: projectName validate: true
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_removeSelector: selector fromBehavior: theBehavior inProjectNamed: projectName validate: validate

	"validate the dirty state of project before and after method is removed"

	| project |

	project := RwProject newNamed: projectName.

	validate ifTrue: [ self deny: project isDirty ].

	theBehavior rwRemoveSelector: selector.

	validate ifTrue: [ self assert: project isDirty ].
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_updateClassNamed: className toPackageNamed: packageName inProjectNamed: projectName

	^ self _updateClassNamed: className toPackageNamed: packageName inProjectNamed: projectName validate: true
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_updateClassNamed: className toPackageNamed: packageName inProjectNamed: projectName validate: validate

	"validate the dirty state of project before and after class is added"

	| project package theClass |

	project := RwProject newNamed: projectName.
	package := RwPackage newNamed: packageName.

	validate ifTrue: [ 
		self deny: project isDirty.
		self deny: package isDirty ].

	theClass := Object
		rwSubclass: className
		instVarNames: #(ivar1)
		classVars: #(CVar1 CVar2)
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().

	validate ifTrue: [ 
		self assert: project isDirty.
		self assert: package isDirty ].

	^theClass
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_writeProjectNamed: projectName

	^ self _writeProjectNamed: projectName validate: true
%

category: 'private-issue 24'
method: RwRowanProjectIssuesTest
_writeProjectNamed: projectName validate: validate

	"validate the dirty state of project before and after write"

	| project |

	project := RwProject newNamed: projectName.

	validate ifTrue: [ self assert: project isDirty ]. "a project is dirty if it has changes that are not written to disk"

	Rowan projectTools write writeProjectNamed: projectName.

	validate ifTrue: [ self deny: project isDirty ]. "a project is not dirty if it has been written to disk"
%

! Class implementation for 'RwCloneSymbolDictionaryTest'

!		Class methods for 'RwCloneSymbolDictionaryTest'

category: 'Testing'
classmethod: RwCloneSymbolDictionaryTest
shouldInheritSelectors

	^false
%

!		Instance methods for 'RwCloneSymbolDictionaryTest'

category: 'tests'
method: RwCloneSymbolDictionaryTest
testClassVarSystemDictionaryClone

	| projectName packageName1 className symDictName theOriginalClass theSymbolDict validationBlock clonedSymbolDict 
		clonedClass clonedSymDictName | 

	projectName := 'SystemDictionaryClone_Project'.
	packageName1 := 'SystemDictionaryClone-Core'.
	className := 'SystemDictionaryCloneClass'.
	symDictName := self _symbolDictionaryName2.
	clonedSymDictName :=  (symDictName, '_CLONE') asSymbol.

	self 
		_createLoadedProjectNamed: projectName 
		root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' 
		symbolDictionaryName: symDictName 
		validate: false.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.

	theOriginalClass := Object
		rwSubclass: className
		instVarNames: #(iv1)
		classVars: #(CV1)
		classInstVars: #(civ1)
		poolDictionaries: #()
		category: packageName1
		options: #().

	theOriginalClass class rwCompileMethod: 'cv1 ^CV1' category: 'accessing'.
	theOriginalClass class rwCompileMethod: 'cv1: x CV1 := x' category: 'accessing'.

	validationBlock := [:aClass :expectedValue |
		| x |
		self assert: (x := aClass perform: #cv1) = expectedValue.
	].

	theOriginalClass perform: #cv1: with: #one.

	validationBlock value: theOriginalClass value: #one.

	theSymbolDict := Rowan globalNamed: symDictName.

	clonedSymbolDict := theSymbolDict _rowanCloneSymbolDictionaryNamed: clonedSymDictName symbolList: GsCurrentSession currentSession symbolList.
	self assert: clonedSymbolDict name == clonedSymDictName.

	clonedClass := clonedSymbolDict at: className asSymbol.

	self assert: clonedClass ~~ theOriginalClass.
	self assert: clonedClass classHistory ~~ theOriginalClass classHistory.

	validationBlock value: clonedClass value: #one.
	validationBlock value: theOriginalClass value: #one.

	clonedClass perform: #cv1: with: #ONE.

	validationBlock value: clonedClass value: #ONE.
	validationBlock value: theOriginalClass value: #one.
%

category: 'tests'
method: RwCloneSymbolDictionaryTest
testMultiDependentClassSystemDictionaryClone

	| projectName packageName1 className1 className2 className3 symDictName theOriginalClass1 theOriginalClass2 theOriginalClass3 theSymbolDict validationBlock clonedSymbolDict 
		clonedClass1 clonedClass2 clonedClass3 clonedSymDictName | 

	projectName := 'SystemDictionaryClone_Project'.
	packageName1 := 'SystemDictionaryClone-Core'.
	className1 := 'SystemDictionaryCloneClass_1'.
	className2 := 'SystemDictionaryCloneClass_2'.
	className3 := 'SystemDictionaryCloneClass_3'.
	symDictName := self _symbolDictionaryName2.
	clonedSymDictName :=  (symDictName, '_CLONE') asSymbol.

	self 
		_createLoadedProjectNamed: projectName 
		root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' 
		symbolDictionaryName: symDictName 
		validate: false.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.

	theOriginalClass1 := Object
		rwSubclass: className1
		instVarNames: #(iv1 )
		classVars: #(CV1)
		classInstVars: #(civ1)
		poolDictionaries: #()
		category: packageName1
		options: #().
	theOriginalClass2 := theOriginalClass1
		rwSubclass: className2
		instVarNames: #(iv2)
		classVars: #(CV2)
		classInstVars: #(civ2)
		poolDictionaries: #()
		category: packageName1
		options: #().
	theOriginalClass3 := Object
		rwSubclass: className3
		instVarNames: #(iv3)
		classVars: #(CV3)
		classInstVars: #(civ3)
		poolDictionaries: #()
		category: packageName1
		options: #().
	theOriginalClass1 rwCompileMethod: 'iv1 ^iv1' category: 'accessing'.
	theOriginalClass1 rwCompileMethod: 'iv2 ^#none' category: 'accessing'.
	theOriginalClass1 rwCompileMethod: 'cv1 ^', className1, ' cv1' category: 'accessing'.
	theOriginalClass1 rwCompileMethod: 'cv2 ^', className2, ' cv2' category: 'accessing'.
	theOriginalClass1 rwCompileMethod: 'cv3 ^', className3, ' cv3' category: 'accessing'.
	theOriginalClass1 rwCompileMethod: 'civ1 ^', className1, ' civ1' category: 'accessing'.
	theOriginalClass1 rwCompileMethod: 'civ2 ^', className2, ' civ2' category: 'accessing'.
	theOriginalClass1 rwCompileMethod: 'civ3 ^', className3, ' civ3' category: 'accessing'.
	theOriginalClass1 class rwCompileMethod: 'cv1 ^CV1' category: 'accessing'.
	theOriginalClass1 class rwCompileMethod: 'cv1: x CV1 := x' category: 'accessing'.
	theOriginalClass1 class rwCompileMethod: 'civ1 ^civ1' category: 'accessing'.
	theOriginalClass1 class rwCompileMethod: 'civ1: x civ1 := x' category: 'accessing'.

	theOriginalClass2 rwCompileMethod: 'iv1 ^iv1' category: 'accessing'.
	theOriginalClass2 rwCompileMethod: 'iv2 ^iv2' category: 'accessing'.
	theOriginalClass2 rwCompileMethod: 'cv1 ^', className1, ' cv1' category: 'accessing'.
	theOriginalClass2 rwCompileMethod: 'cv2 ^', className2, ' cv2' category: 'accessing'.
	theOriginalClass2 rwCompileMethod: 'cv3 ^', className3, ' cv3' category: 'accessing'.
	theOriginalClass2 rwCompileMethod: 'civ1 ^', className1, ' civ1' category: 'accessing'.
	theOriginalClass2 rwCompileMethod: 'civ2 ^', className2, ' civ2' category: 'accessing'.
	theOriginalClass2 rwCompileMethod: 'civ3 ^', className3, ' civ3' category: 'accessing'.
	theOriginalClass2 class rwCompileMethod: 'cv2 ^CV2' category: 'accessing'.
	theOriginalClass2 class rwCompileMethod: 'cv2: x CV2 := x' category: 'accessing'.
	theOriginalClass2 class rwCompileMethod: 'civ2 ^civ2' category: 'accessing'.
	theOriginalClass2 class rwCompileMethod: 'civ2: x civ2 := x' category: 'accessing'.

	theOriginalClass3 rwCompileMethod: 'iv1 ^#none' category: 'accessing'.
	theOriginalClass3 rwCompileMethod: 'iv2 ^#none' category: 'accessing'.
	theOriginalClass3 rwCompileMethod: 'cv1 ^', className1, ' cv1' category: 'accessing'.
	theOriginalClass3 rwCompileMethod: 'cv2 ^', className2, ' cv2' category: 'accessing'.
	theOriginalClass3 rwCompileMethod: 'cv3 ^', className3, ' cv3' category: 'accessing'.
	theOriginalClass3 rwCompileMethod: 'civ1 ^', className1, ' civ1' category: 'accessing'.
	theOriginalClass3 rwCompileMethod: 'civ2 ^', className2, ' civ2' category: 'accessing'.
	theOriginalClass3 rwCompileMethod: 'civ3 ^', className3, ' civ3' category: 'accessing'.
	theOriginalClass3 class rwCompileMethod: 'cv3 ^CV3' category: 'accessing'.
	theOriginalClass3 class rwCompileMethod: 'cv3: x CV3 := x' category: 'accessing'.
	theOriginalClass3 class rwCompileMethod: 'civ3 ^civ3' category: 'accessing'.
	theOriginalClass3 class rwCompileMethod: 'civ3: x civ3 := x' category: 'accessing'.

	theOriginalClass1 perform: #cv1: with: #one; perform: #civ1: with: #one.
	theOriginalClass2 perform: #cv2: with: #two; perform: #civ2: with: #two.
	theOriginalClass3 perform: #cv3: with: #three; perform: #civ3: with: #three.

	validationBlock := [:aClass :cv1 :cv2 :cv3|
		| x |
		aClass new perform: #iv1; perform: #iv2.	"no MNU is sufficient"
		self assert: (x := aClass new perform: #civ1) = cv1.
		self assert: (x := aClass new perform: #civ2) = cv2.
		self assert: (x := aClass new perform: #civ3) = cv3.
		self assert: (x := aClass new perform: #cv1) = cv1.
		self assert: (x := aClass new perform: #cv2) = cv2.
		self assert: (x := aClass new perform: #cv3) = cv3.
	].

	validationBlock value: theOriginalClass1 value: #one value: #two value: #three.
	validationBlock value: theOriginalClass2 value: #one value: #two value: #three.
	validationBlock value: theOriginalClass3 value: #one value: #two value: #three.

	theSymbolDict := Rowan globalNamed: symDictName.
	clonedSymbolDict := theSymbolDict _rowanCloneSymbolDictionaryNamed: clonedSymDictName symbolList: GsCurrentSession currentSession symbolList.
	self assert: clonedSymbolDict name == clonedSymDictName.

	clonedClass1 := clonedSymbolDict at: className1 asSymbol.
	clonedClass2 := clonedSymbolDict at: className2 asSymbol.
	clonedClass3 := clonedSymbolDict at: className3 asSymbol.

	self assert: clonedClass2 superclass == clonedClass1.

	self assert: clonedClass1 ~~ theOriginalClass1.
	self assert: clonedClass1 classHistory ~~ theOriginalClass1 classHistory.
	self assert: clonedClass2 ~~ theOriginalClass2.
	self assert: clonedClass2 classHistory ~~ theOriginalClass2 classHistory.
	self assert: clonedClass3 ~~ theOriginalClass3.
	self assert: clonedClass3 classHistory ~~ theOriginalClass3 classHistory.

	validationBlock value: clonedClass1 value: #one value: #two value: #three.
	validationBlock value: clonedClass2 value: #one value: #two value: #three.
	validationBlock value: clonedClass3 value: #one value: #two value: #three.

	clonedClass1 perform: #cv1: with: #ONE; perform: #civ1: with: #ONE.
	clonedClass2 perform: #cv2: with: #TWO; perform: #civ2: with: #TWO.
	clonedClass3 perform: #cv3: with: #THREE; perform: #civ3: with: #THREE.

	validationBlock value: theOriginalClass1 value: #one value: #two value: #three.
	validationBlock value: theOriginalClass2 value: #one value: #two value: #three.
	validationBlock value: theOriginalClass3 value: #one value: #two value: #three.

	validationBlock value: clonedClass1 value: #ONE value: #TWO value: #THREE.
	validationBlock value: clonedClass2 value: #ONE value: #TWO value: #THREE.
	validationBlock value: clonedClass3 value: #ONE value: #TWO value: #THREE.
%

category: 'tests'
method: RwCloneSymbolDictionaryTest
testRowanLoaderSystemDictionaryClone

	| rowanLoaderSymbolDict clonedSymDictName clonedSymbolDict |
	rowanLoaderSymbolDict := Rowan globalNamed: 'RowanLoader'.
	clonedSymDictName := #'RowanLoader_cloned'.
	clonedSymbolDict := rowanLoaderSymbolDict 
		_rowanCloneSymbolDictionaryNamed: clonedSymDictName 
		symbolList: GsCurrentSession currentSession symbolList.
%

category: 'tests'
method: RwCloneSymbolDictionaryTest
testSimpleSystemDictionaryClone

	| projectName packageName1 className symDictName theOriginalClass theSymbolDict validationBlock clonedSymbolDict 
		clonedClass clonedSymDictName | 

	projectName := 'SystemDictionaryClone_Project'.
	packageName1 := 'SystemDictionaryClone-Core'.
	className := 'SystemDictionaryCloneClass'.
	symDictName := self _symbolDictionaryName2.
	clonedSymDictName :=  (symDictName, '_CLONE') asSymbol.

	self 
		_createLoadedProjectNamed: projectName 
		root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' 
		symbolDictionaryName: symDictName 
		validate: false.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.

	theOriginalClass := Object
		rwSubclass: className
		instVarNames: #(iv1)
		classVars: #(CV1)
		classInstVars: #(civ1)
		poolDictionaries: #()
		category: packageName1
		options: #().
	theOriginalClass rwCompileMethod: 'foo ^''foo''' category: 'accessing'.
	theOriginalClass rwCompileMethod: 'iv1 ^iv1' category: 'accessing'.
	theOriginalClass rwCompileMethod: 'initialize iv1:=3' category: 'initialization'.

	theOriginalClass class rwCompileMethod: 'bar ^''bar''' category: 'accessing'.
	theOriginalClass class rwCompileMethod: 'cv1 ^CV1' category: 'accessing'.
	theOriginalClass class rwCompileMethod: 'civ1 ^civ1' category: 'accessing'.
	theOriginalClass class rwCompileMethod: 'initialize civ1:=1. CV1:=2.' category: 'initialization'.
	theOriginalClass class rwCompileMethod: 'new ^ self basicNew initialize; yourself' category: 'instance creation'.

	theOriginalClass initialize.
	validationBlock := [:aClass |
		self assert: (aClass perform: #cv1) = 2.
		self assert: (aClass perform: #civ1) = 1.
		self assert: (aClass perform: #bar) = 'bar'.
		self assert: (aClass new perform: #iv1) = 3.
		self assert: (aClass new perform: #foo) = 'foo'.
	].

	validationBlock value: theOriginalClass.
	theSymbolDict := Rowan globalNamed: symDictName.

	clonedSymbolDict := theSymbolDict _rowanCloneSymbolDictionaryNamed: clonedSymDictName symbolList: GsCurrentSession currentSession symbolList.
	self assert: clonedSymbolDict name == clonedSymDictName.

	clonedClass := clonedSymbolDict at: className asSymbol.

	self assert: clonedClass ~~ theOriginalClass.
	self assert: clonedClass classHistory ~~ theOriginalClass classHistory.

	validationBlock value: clonedClass.
%

category: 'tests'
method: RwCloneSymbolDictionaryTest
testSubclassSystemDictionaryClone

	| projectName packageName1 className1 className2 symDictName theOriginalClass theSymbolDict clonedSymbolDict 
		clonedClass1 clonedClass2 clonedSymDictName theOriginalSubclass x | 

	projectName := 'SystemDictionaryClone_Project'.
	packageName1 := 'SystemDictionaryClone-Core'.
	className1 := 'SystemDictionaryCloneClass_1'.
	className2 := 'SystemDictionaryCloneClass_2'.
	symDictName := self _symbolDictionaryName2.
	clonedSymDictName :=  (symDictName, '_CLONE') asSymbol.

	self 
		_createLoadedProjectNamed: projectName 
		root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' 
		symbolDictionaryName: symDictName 
		validate: false.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.

	theOriginalClass := Object
		rwSubclass: className1
		instVarNames: #(iv1)
		classVars: #(CV1)
		classInstVars: #(civ1)
		poolDictionaries: #()
		category: packageName1
		options: #().
	theOriginalSubclass := theOriginalClass
		rwSubclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	theSymbolDict := Rowan globalNamed: symDictName.

	clonedSymbolDict := theSymbolDict _rowanCloneSymbolDictionaryNamed: clonedSymDictName symbolList: GsCurrentSession currentSession symbolList.
	self assert: clonedSymbolDict name == clonedSymDictName.

	clonedClass1 := clonedSymbolDict at: className1 asSymbol.

	self assert: clonedClass1 ~~ theOriginalClass.
	self assert: clonedClass1 classHistory ~~ theOriginalClass classHistory.

	clonedClass2 := clonedSymbolDict at: className2 asSymbol.

	self assert: clonedClass2 ~~ theOriginalSubclass.
	self assert: clonedClass2 classHistory ~~ theOriginalSubclass classHistory.

	self assert: (x := clonedClass2 superclass) == clonedClass1
%

! Class implementation for 'RwRowanIssue188Test'

!		Class methods for 'RwRowanIssue188Test'

category: 'Testing'
classmethod: RwRowanIssue188Test
shouldInheritSelectors

	^false
%

!		Instance methods for 'RwRowanIssue188Test'

category: 'tests'
method: RwRowanIssue188Test
testBaselineScenario

	"https://github.com/dalehenrich/Rowan/issues/188"

	"
		Set up baseline:
			1. Class A and B
			2. Class B has a method w that returns class A.
		In a single load:
			1. Create new version of class A
		Verify method w in class B returns the new version of class A
	"

	| projectName packageName className1 className2  theClass1 theClass2 oldTheClass1 |
	projectName := 'Issue_188'.
	packageName := 'Issue_188-Core'.
	className1 := 'Issue_188_A'.
	className2 := 'Issue_188_B'.

	self _createBaselineClassesInSingleLoad: projectName packageName: packageName classNames: {className1. className2}.

	oldTheClass1 := theClass1 := Rowan globalNamed: className1.
	theClass2 := Rowan globalNamed: className2.

	self assert: (theClass2 new perform: #w) == oldTheClass1.

	theClass1 := Object
		rwSubclass: className1
		instVarNames: #(xxx)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().

	self assert: theClass1 ~~ oldTheClass1.
	self assert: (theClass1 classHistory includes: oldTheClass1).
	self assert: (theClass2 new perform: #w) == theClass1.
%

category: 'tests'
method: RwRowanIssue188Test
testNewClassAndNewClassReferences

	"https://github.com/dalehenrich/Rowan/issues/188"

	"newly created classes end up adding the (new) association in tempSymbols to the target symbol dictionary,
		so they are not exposed to same bug"

	"
	Baseline:
		Set up baseline:
			1. Class A and B
			2. Class B has a method w that returns class A.
		Verify method w in class B returns the new version of class A
	Setup new class and new class reference:
		In a single load:
			1. Create new class C
			2. add method x in B to return class C
	Failiure:
			1. Create a new version of class A
		Verify that when method x is invoked that the new method w is called
			and verify that method z returns the current version of C
	"

	| projectName packageName className1 className2 className3 theClass1 theClass2 theClass3 oldTheClass1 oldTheClass3 |
	projectName := 'Issue_188'.
	packageName := 'Issue_188-Core'.
	className1 := 'Issue_188_A'.
	className2 := 'Issue_188_B'.
	className3 := 'Issue_188_C'.

	"Baseline"
	self 
		_createBaselineClassesInSingleLoad: projectName 
		packageName: packageName 
		classNames: {className1. className2}.

	oldTheClass1 := theClass1 := Rowan globalNamed: className1.
	theClass2 := Rowan globalNamed: className2.

	self assert: (theClass2 new perform: #w) == oldTheClass1.

	"Setup new class and new class reference:"
	self 
		_createNewClassAndReferenceMethodsInSingleLoad: projectName 
		packageName: packageName 
		classNames: {className1. className2. className3}.

	oldTheClass3 := theClass3 := Rowan globalNamed: className3.

	self assert: (theClass2 new perform: #w) == oldTheClass1.
	self assert: (theClass2 new perform: #x) == oldTheClass3.

	"Failure: the methods compiled with references to C as a newly created class are incorrect"
	theClass3 := Object
		rwSubclass: className3
		instVarNames: #(xxx)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().

	self assert: theClass3 ~~ oldTheClass3.
	self assert: (theClass3 classHistory includes: oldTheClass3).
	self assert: (theClass2 new perform: #w) == theClass1.		"association in method #w is still correct"
	self assert: (theClass2 new perform: #x) == theClass3.		"association in method #x is correct"
%

category: 'tests'
method: RwRowanIssue188Test
testOriginalFailureMode

	"https://github.com/dalehenrich/Rowan/issues/188"

	"
	Baseline:
		Set up baseline:
			1. Class A and B
			2. Class B has a method w that returns class A.
		In a single load:
			1. Create new version of class A
		Verify method w in class B returns the new version of class A
	Original Setup:
		In a single load:
			1. create new version of B
	Original Failure:
		In a single load:
			1. Create new version of class A
		Verify method w in class B returns the correct version of class A
	"

	| projectName packageName className1 className2  theClass1 theClass2 oldTheClass1 |
	projectName := 'Issue_188'.
	packageName := 'Issue_188-Core'.
	className1 := 'Issue_188_A'.
	className2 := 'Issue_188_B'.

	"Baseline"
	self _createBaselineClassesInSingleLoad: projectName packageName: packageName classNames: {className1. className2}.

	oldTheClass1 := theClass1 := Rowan globalNamed: className1.
	theClass2 := Rowan globalNamed: className2.

	self assert: (theClass2 new perform: #w) == oldTheClass1.

	theClass1 := Object
		rwSubclass: className1
		instVarNames: #(xxx)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().

	self assert: theClass1 ~~ oldTheClass1.
	self assert: (theClass1 classHistory includes: oldTheClass1).
	self assert: (theClass2 new perform: #w) == theClass1.

	"Original Setup: the method #w is compiled with a reference to className1, but it is in an incorrect association -- not yet apparent"
	theClass2 := Object
		rwSubclass: className2
		instVarNames: #(xxx)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().

	self assert: (theClass2 new perform: #w) == theClass1.

	"Original Failure: the incorrect association in method #w is not updated with the new version of className1 - boom"
	oldTheClass1 := theClass1.
	theClass1 := Object
		rwSubclass: className1
		instVarNames: #(xxx yyy)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().

	self assert: theClass1 ~~ oldTheClass1.
	self assert: (theClass1 classHistory includes: oldTheClass1).
	self assert: (theClass2 new perform: #w) == theClass1.		"association in method #w incorrect"
%

category: 'tests'
method: RwRowanIssue188Test
testOriginalSetupMode

	"https://github.com/dalehenrich/Rowan/issues/188"

	"
	Baseline:
		Set up baseline:
			1. Class A and B
			2. Class B has a method w that returns class A.
		In a single load:
			1. Create new version of class A
		Verify method w in class B returns the new version of class A
	Original Setup:
		In a single load:
			1. create new version of B
		Verify method w in class B returns the correct version of class A
	"

	| projectName packageName className1 className2  theClass1 theClass2 oldTheClass1 |
	projectName := 'Issue_188'.
	packageName := 'Issue_188-Core'.
	className1 := 'Issue_188_A'.
	className2 := 'Issue_188_B'.

	"Baseline"
	self _createBaselineClassesInSingleLoad: projectName packageName: packageName classNames: {className1. className2}.

	oldTheClass1 := theClass1 := Rowan globalNamed: className1.
	theClass2 := Rowan globalNamed: className2.

	self assert: (theClass2 new perform: #w) == oldTheClass1.

	theClass1 := Object
		rwSubclass: className1
		instVarNames: #(xxx)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().

	self assert: theClass1 ~~ oldTheClass1.
	self assert: (theClass1 classHistory includes: oldTheClass1).
	self assert: (theClass2 new perform: #w) == theClass1.

	"Original Setup: the method #w is compiled with a reference to className1, but it is in an incorrect association -- not yet apparent"
	theClass2 := Object
		rwSubclass: className2
		instVarNames: #(xxx)
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName
		options: #().

	self assert: (theClass2 new perform: #w) == theClass1.
%

category: 'private'
method: RwRowanIssue188Test
_createBaselineClassesInSingleLoad: projectName packageName: packageName classNames: classNames

	"
		Set up baseline:
			1. Class A and B
			2. Class B has a method w that returns class A.
	"

	| projectDefinition packageDefinition |
	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	projectDefinition := RwProjectDefinition
		newForGitBasedProjectNamed: projectName.
	projectDefinition
		addPackagesNamed: {packageName};
		yourself.
	projectDefinition defaultSymbolDictName: self _symbolDictionaryName1.

	packageDefinition := projectDefinition packageNamed: packageName.

	classNames do: [:className |
		| classDefinition |
		classDefinition := RwClassDefinition
			newForClassNamed: className
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: nil
			comment: 'I am a ', className, ' class'
			pools: #()
			type: 'normal'.
		packageDefinition addClassDefinition: classDefinition ].

	(packageDefinition classDefinitions at: (classNames at: 2))
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'w'
						protocol: 'accessing'
						source: 'w ^ ', (classNames at: 1)).

	Rowan projectTools load loadProjectDefinition: projectDefinition
%

category: 'private'
method: RwRowanIssue188Test
_createNewClassAndReferenceMethodsInSingleLoad: projectName packageName: packageName classNames: classNames

	"
	Setup new class and new class reference:
		In a single load:
			1. Create new class C
			2. add method x in B to return class C
	"

	| projectDefinition packageDefinition classDefinition |

	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition packageNamed: packageName.

	classDefinition := RwClassDefinition
		newForClassNamed: (classNames at: 3)
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	packageDefinition addClassDefinition: classDefinition.

	(packageDefinition classDefinitions at: (classNames at: 2))
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'x'
						protocol: 'accessing'
						source: 'x ^ ', (classNames at: 3)).

	Rowan projectTools load loadProjectDefinition: projectDefinition
%

! Class implementation for 'RwRowanIssue493Test'

!		Instance methods for 'RwRowanIssue493Test'

category: 'tests'
method: RwRowanIssue493Test
testMoveClassBetweenSymDicts_changeDefaulSymDict_1

	"https://github.com/dalehenrich/Rowan/issues/493"

	"move a class with no methods from one sym dict to another using defaultSymbolDictName"

	| className packageName projectName projectDefinition project audit |

	projectName := 'Issue493'.
	packageName := 'Issue493-Core'.
	className := 'Issue493Class'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	projectDefinition := (RwComponentProjectDefinition projectName: projectName)
		defaultSymbolDictName: self _symbolDictionaryName1;
		addPackageNamed: packageName;
		yourself.

	((projectDefinition packageNamed: packageName)
		addClassNamed: className super: 'Object' category: '*', packageName asLowercase).

"load"
	projectDefinition load.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit isEmpty).

"switch default symbol dict"
	projectDefinition defaultSymbolDictName: self _symbolDictionaryName2.

"load"
	projectDefinition load.

"validate"
	self assert: (audit := project audit) isEmpty.
%

category: 'tests'
method: RwRowanIssue493Test
testMoveClassBetweenSymDicts_changeDefaulSymDict_2

	"https://github.com/dalehenrich/Rowan/issues/493"

	"move a class with a method from one sym dict to another using defaultSymbolDictName"

	| className packageName projectName projectDefinition project audit |

	projectName := 'Issue493'.
	packageName := 'Issue493-Core'.
	className := 'Issue493Class'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	projectDefinition := (RwComponentProjectDefinition projectName: projectName)
		defaultSymbolDictName: self _symbolDictionaryName1;
		addPackageNamed: packageName;
		yourself.

	((projectDefinition packageNamed: packageName)
		addClassNamed: className super: 'Object' category: '*', packageName asLowercase)
			addInstanceMethod: 'foo ^ 1' protocol: 'accessing'.

"load"
	projectDefinition load.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit isEmpty).

"switch default symbol dict"
	projectDefinition defaultSymbolDictName: self _symbolDictionaryName2.

"load"
	projectDefinition load.

"validate"
	self assert: (audit := project audit) isEmpty.
%

! Class implementation for 'RwRowanProjectIssuesTestV2'

!		Instance methods for 'RwRowanProjectIssuesTestV2'

category: 'tests'
method: RwRowanProjectIssuesTestV2
testIssue495_move_class_and_extension_method_to_new_symbol_dict

	"Port of RwRowanProjectIssuesTest debug: #testIssue215_move_class_and_extension_method_to_new_symbol_dict
		to V2 api and reproduce Issue #495"

	"https://github.com/dalehenrich/Rowan/issues/495"

	| projectName  packageName1 packageName2 packageName3 project1 project2 
		classDefinition packageDefinition className1 className2 class projectSetDefinition
		classExtensionDefinition oldClass project audit |
	projectName := 'Issue215'.
	packageName1 := 'Issue215-Core1'.
	packageName2 := 'Issue215-Tools'.
	packageName3 := 'Issue215-Tools-Extensions'.
	className1 := 'Issue215Class1'.
	className2 := 'Issue215Class2'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	project1 := RwResolvedProjectV2 new
		projectName: projectName;
		addComponentNamed: 'Core' 
			definedGroupNames: 
				(Dictionary new
						add: 'core' -> {};
						yourself) 
			comment: '';
		addPackageNamed: packageName1 
			toComponentNamed: 'Core' 
			withConditions: #('common') 
			andGroupName: #('core');
		addPackageNamed: packageName2 
			toComponentNamed: 'Core' 
			withConditions: #('common') 
			andGroupName: #('core');
		gemstoneSetSymbolDictName: self _symbolDictionaryName1
			forPackageNamed: packageName1;
		gemstoneSetSymbolDictName: self _symbolDictionaryName1
			forPackageNamed: packageName2;
		yourself.

	packageDefinition := project1 packageNamed: packageName1.
	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	packageDefinition addClassDefinition: classDefinition.

	packageDefinition := project1 packageNamed: packageName2.
	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName2
		comment: ''
		pools: #()
		type: 'normal'.
	packageDefinition addClassDefinition: classDefinition.

	"create extension method in different package"
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'mover'
				protocol: '*', packageName2 asLowercase
				source: 'mover ^2').
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: project1.
	Rowan projectTools loadV2 loadProjectSetDefinition: projectSetDefinition.

	"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className1.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName2.
	self assert: (class new perform: #mover) = 2.

	"move the class to different symbol dictionary and move extension methods to new package"
	project2 := (Rowan image loadedProjectNamed: projectName) asDefinition.
	project2
		addPackageNamed: packageName3 
			toComponentNamed: 'Core' 
			withConditions: #('common') 
			andGroupName: #('core');
		gemstoneSetSymbolDictName: self _symbolDictionaryName2
			forPackageNamed: packageName2;
		gemstoneSetSymbolDictName: self _symbolDictionaryName1
			forPackageNamed: packageName3.

	packageDefinition := project2 packageNamed: packageName2.
	(packageDefinition classExtensions at: className1) removeInstanceMethod: #mover.

	packageDefinition := project2 packageNamed: packageName3.
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'mover'
				protocol: '*', packageName3 asLowercase
				source: 'mover ^2').
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.
	
	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: project2.
	Rowan projectTools loadV2 loadProjectSetDefinition: projectSetDefinition.

	"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className1.
	self assert: class == oldClass.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName3.
	self assert: (class new perform: #mover) = 2.
%

! Class implementation for 'RwUnpackagedBrowserApiTest'

!		Instance methods for 'RwUnpackagedBrowserApiTest'

category: 'running'
method: RwUnpackagedBrowserApiTest
setUp
	"test class will be removed along with symbol dictionary during teardown"

	| symDict |
	super setUp.
	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName1.
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	Object subclass: self _testClassName
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #()
%

category: 'tests'
method: RwUnpackagedBrowserApiTest
testAddUnpackagedClassMethod

	"https://github.com/GemTalk/Rowan/issues/547"

	"Add unpackaged method to an upackaged class"

	| testClass audit |

	testClass := self _testClass.
	[ testClass class
		rwCompileMethod: 'bar ^''bar'''
		category: 'issue 364' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].	

"validate"
	self assert: (testClass class compiledMethodAt: 'bar' otherwise: nil) notNil.

	[ testClass class rwRemoveSelector: #bar ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) isNil.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: 'Rowan') isEmpty.
%

category: 'tests'
method: RwUnpackagedBrowserApiTest
testAddUnpackagedMethod

	"https://github.com/GemTalk/Rowan/issues/364"

	"Add unpackaged method to an upackaged class"

	| testClass audit |

	testClass := self _testClass.
	[ testClass
		rwCompileMethod: 'bar ^''bar'''
		category: 'issue 364' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.

	[ testClass rwRemoveSelector: #bar ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) isNil.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: 'Rowan') isEmpty.
%

category: 'tests'
method: RwUnpackagedBrowserApiTest
testIssue263

	"https://github.com/GemTalk/Rowan/issues/263"

	"Add extension method to an unpackaged class"

	| projectName  packageName projectDefinition projectSetDefinition audit testClass |

	projectName := 'Issue263_A'.
	packageName := 'Issue263_A-Extension'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	self assert: (projectDefinition projectDefinitionSourceProperty = RwLoadedProject _projectUnknownDefinitionSourceValue).

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	testClass := self _testClass.
	testClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName asLowercase.

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

"load -- effectively unload extension methods"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) isNil.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwUnpackagedBrowserApiTest
testIssue420_A

	"https://github.com/GemTalk/Rowan/issues/420"

	"move method from packaged category to another packaged category (different package) (class is unpackaged)"

	| projectName  packageName1 packageName2 projectDefinition projectSetDefinition audit testClass symDict registry |

	projectName := 'Issue364'.
	packageName1 := 'Issue364-Extension-1'.
	packageName2 := 'Issue364-Extension-2'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	testClass := self _testClass.
	testClass addCategory: '*' , packageName1 asLowercase.
	testClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName1 asLowercase.

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (testClass categoryOfSelector: #bar) = ('*' , packageName1 asLowercase) asSymbol.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.

"move"
	testClass addCategory: '*' , packageName2 asLowercase.
	testClass rwMoveMethod: #bar toCategory: '*' , packageName2 asLowercase.

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (testClass categoryOfSelector: #bar) = ('*' , packageName2 asLowercase) asSymbol.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.

"load -- effectively unload extension methods"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) isNil.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwUnpackagedBrowserApiTest
testIssue420_B

	"https://github.com/GemTalk/Rowan/issues/420"

	"move method from extension category to packaged category (class is packaged)"

	| projectName  packageName1 packageName2 projectDefinition projectSetDefinition audit testClass symDict registry |

	projectName := 'Issue364'.
	packageName1 := 'Issue364-Core-1'.
	packageName2 := 'Issue364-Extension-2'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	testClass := Object rwSubclass: self _testPackagedClassName
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	testClass addCategory: '*' , packageName2 asLowercase.
	testClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (testClass categoryOfSelector: #bar) = ('*' , packageName2 asLowercase) asSymbol.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.

"move"
	testClass addCategory: 'accessing'.
	testClass rwMoveMethod: #bar toCategory: 'accessing'.

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (testClass categoryOfSelector: #bar) = #'accessing'.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.

"load -- effectively unload extension methods"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (Rowan globalNamed: self _testPackagedClassName) isNil.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwUnpackagedBrowserApiTest
testIssue420_C

	"https://github.com/GemTalk/Rowan/issues/420"

	"move method from packaged category to unpackaged category (class is unpackaged)"

	| projectName  packageName1 packageName2 projectDefinition projectSetDefinition audit testClass symDict registry |

	projectName := 'Issue364'.
	packageName1 := 'Issue364-Extension-1'.
	packageName2 := 'Issue364-Extension-2'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	testClass := self _testClass.
	testClass addCategory: '*' , packageName1 asLowercase.
	testClass
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName1 asLowercase.

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (testClass categoryOfSelector: #bar) = ('*' , packageName1 asLowercase) asSymbol.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.

"move"
	testClass addCategory: 'accessing'.
	[ testClass rwMoveMethod: #bar toCategory:  'accessing' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (testClass categoryOfSelector: #bar) = 'accessing'  asSymbol.
"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

"load -- effectively unload extension methods"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	[ testClass rwRemoveSelector: #bar ]
			on: RwPerformingUnpackagedEditNotification
			do: [:ex | ex resume ].	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) isNil.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
%

category: 'tests'
method: RwUnpackagedBrowserApiTest
testIssue420_D

	"https://github.com/GemTalk/Rowan/issues/420"

	"move method from unpackaged category to packaged category (class is unpackaged)"

	| projectName  packageName1 projectDefinition projectSetDefinition audit testClass symDict registry |

	projectName := 'Issue364'.
	packageName1 := 'Issue364-Extension-1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	testClass := self _testClass.
	testClass addCategory: 'accessing'.
	[ testClass
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing' ]
			on: RwPerformingUnpackagedEditNotification
			do: [:ex | ex resume ].	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (testClass categoryOfSelector: #bar) = 'accessing' asSymbol.
"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

"move"
	testClass addCategory: '*' , packageName1 asLowercase.
	testClass rwMoveMethod: #bar toCategory: '*' , packageName1 asLowercase.	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (testClass categoryOfSelector: #bar) = ('*' , packageName1 asLowercase) asSymbol.
"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.

"load -- effectively unload extension methods"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) isNil.
"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwUnpackagedBrowserApiTest
testIssue420_E

	"https://github.com/GemTalk/Rowan/issues/420"

	"move method from unpackaged category to category in another unpackaged category (class is unpackaged)"

	| projectName  packageName1 projectDefinition projectSetDefinition audit testClass symDict registry |

	projectName := 'Issue364'.
	packageName1 := 'Issue364-Extension-1'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	testClass := self _testClass.
	testClass addCategory: 'accessing'.
	[ testClass
		rwCompileMethod: 'bar ^''bar'''
		category: 'accessing' ]
			on: RwPerformingUnpackagedEditNotification
			do: [:ex | ex resume ].	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (testClass categoryOfSelector: #bar) = 'accessing' asSymbol.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

"move"
	testClass addCategory: 'other accessing'.
	testClass rwMoveMethod: #bar toCategory: 'other accessing'.	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (testClass categoryOfSelector: #bar) = #'other accessing'.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

"load -- effectively unload extension methods"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	[ testClass rwRemoveSelector: #bar ]
			on: RwPerformingUnpackagedEditNotification
			do: [:ex | ex resume ].	
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) isNil.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.
"registry check"
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwUnpackagedBrowserApiTest
testMoveUnpackagedMethod

	"https://github.com/GemTalk/Rowan/issues/364"

	"Add unpackaged method"

	| audit x testClass |

	testClass := self _testClass.
	[ testClass
		rwCompileMethod: 'bar ^''bar'''
		category: 'issue 364' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (x := testClass categoryOfSelector: #bar) = #'issue 364'.

	testClass addCategory: 'issue 364 other'.
	testClass rwMoveMethod: #bar toCategory: 'issue 364 other'.	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) notNil.
	self assert: (x := testClass categoryOfSelector: #bar) = #'issue 364 other'.

	[ testClass rwRemoveSelector: #bar  ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].	

"validate"
	self assert: (testClass compiledMethodAt: 'bar' otherwise: nil) isNil.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: 'Rowan') isEmpty.
%

category: 'tests'
method: RwUnpackagedBrowserApiTest
testUpdateUnpackagedClassComment

	"https://github.com/GemTalk/Rowan/issues/364"

	"Add comment to unpackaged class"

	| audit testClass |

	testClass := self _testClass.
	[ testClass
		rwComment: 'a comment' ]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ].	

"validate"
	self assert: testClass comment = 'a comment'.

"audit"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: 'Rowan') isEmpty.
%

category: 'private'
method: RwUnpackagedBrowserApiTest
_testClass

	^ Rowan globalNamed: self _testClassName
%

category: 'private'
method: RwUnpackagedBrowserApiTest
_testClassName

	^  'Issue364_class'
%

category: 'private'
method: RwUnpackagedBrowserApiTest
_testPackagedClassName

	^  'Issue364_class_packaged'
%

! Class implementation for 'RwEditToolTest'

!		Instance methods for 'RwEditToolTest'

category: 'running'
method: RwEditToolTest
setUp

	| preferenceSymbol |
	super setUp.

"get current black list values"
	preferenceSymbol := Rowan platform _automaticClassInitializationBlackList_symbol.
	globalBlackList :=	(Rowan platform 
		globalPreferenceFor: preferenceSymbol 
		ifAbsent: []) copy.
	userBlackList :=	(Rowan platform 
		userPreferenceFor: preferenceSymbol 
		ifAbsent: []) copy.
	sessionBlackList :=	(Rowan platform 
		sessionPreferenceFor: preferenceSymbol 
		ifAbsent: []) copy.
%

category: 'running'
method: RwEditToolTest
tearDown

	| preferenceSymbol |

	super tearDown.

"clean up blackList"
	preferenceSymbol := Rowan platform _automaticClassInitializationBlackList_symbol.
	globalBlackList
		ifNil: [ Rowan clearDefaultAutomaticClassInitializationBlackList ]
		ifNotNil: [
			Rowan platform 
				setDefaultPreferenceFor: preferenceSymbol 
				to: globalBlackList ].
	userBlackList
		ifNil: [ Rowan clearUserAutomaticClassInitializationBlackList ]
		ifNotNil: [
			Rowan platform 
				setUserPreferenceFor: preferenceSymbol 
				to: userBlackList ].
	sessionBlackList
		ifNil: [ Rowan clearSessionAutomaticClassInitializationBlackList ]
		ifNotNil: [
			Rowan platform 
				setSessionPreferenceFor: preferenceSymbol 
				to: sessionBlackList ].
%

category: 'tests - classes'
method: RwEditToolTest
testAddAndRemoveClass

	| projectName projectDefinition projectTools packageNames classDefinition packageName testClass testInstance className |
	projectName := 'Simple'.
	packageName := 'Simple-Core'.
	packageNames := {packageName}.
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment:
			'This is a simple project used to work out a "classic" class browser-style API'.

	className := 'SimpleEdit'.
	classDefinition := self _standardClassDefinition: className.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.


	projectTools edit
		removeClassNamed: className
		fromPackageNamed: packageName
		inProject: projectDefinition.

	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].

	testClass := Rowan globalNamed: className.
	self assert: testClass isNil
%

category: 'tests - classes'
method: RwEditToolTest
testAddClassExtension

	| projectName packageNames packageName1 packageName2 className testClass testInstance |
	projectName := 'SimpleClassExtension'.
	packageName1 := 'Simple-Core'.
	packageName2 := 'Simple-Extension'.
	packageNames := {packageName1.
	packageName2}.
	className := 'SimpleEdit'.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	self
		_loadExtendedProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment:
			'This is a simple project used to illustrate how to edit an existing class.'
		className: className
		inPackageName: packageName1
		extensionPackageName: packageName2.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cadd: with: 1) = 2.
	self assert: (testClass perform: #cvar1) = 2.
	testInstance := testClass new.
	(testInstance perform: #ivar1: with: 2).
	self assert: (testInstance perform: #ivar1) = 2.
	self assert: (testInstance add: 1) = 3
%

category: 'tests - classes'
method: RwEditToolTest
testAddClass_blackList_A

	"https://github.com/GemTalk/Rowan/issues/447"

	"test that blackList is used to block class initialization - sessionAutomaticClassInitializationBlackList"

	| projectName projectDefinition projectTools packageNames classDefinition packageName testClass testInstance className |
	projectName := 'Simple'.
	packageName := 'Simple-Core'.
	packageNames := {packageName}.
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

"create project definition"
	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment:
			'Testing class initialization blackList'.

	className := 'SimpleEdit'.
	classDefinition := self _standardClassDefinition: className.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

"add project to session blackList"
	Rowan sessionAutomaticClassInitializationBlackList add: projectName.

"load project - initialization should not be triggered"
	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | self assert: false description: 'unexpected signal of RwExecuteClassInitializeMethodsAfterLoadNotification'  ].

"validate"
	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) isNil.
	self assert: (testClass perform: #cvar1) isNil.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.
%

category: 'tests - classes'
method: RwEditToolTest
testAddClass_blackList_B

	"https://github.com/GemTalk/Rowan/issues/447"

	"test that blackList is used to block class initialization - userAutomaticClassInitializationBlackList"

	| projectName projectDefinition projectTools packageNames classDefinition packageName testClass testInstance className |
	projectName := 'Simple'.
	packageName := 'Simple-Core'.
	packageNames := {packageName}.
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

"create project definition"
	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment:
			'Testing class initialization blackList'.

	className := 'SimpleEdit'.
	classDefinition := self _standardClassDefinition: className.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

"add project to user blackList"
	Rowan userAutomaticClassInitializationBlackList add: projectName.

"load project - initialization should not be triggered"
	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | self assert: false description: 'unexpected signal of RwExecuteClassInitializeMethodsAfterLoadNotification'  ].

"validate"
	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) isNil.
	self assert: (testClass perform: #cvar1) isNil.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.
%

category: 'tests - classes'
method: RwEditToolTest
testAddUpdateAndRemoveClass

	| projectName projectDefinition projectTools packageNames classDefinition packageName testClass testInstance className |
	projectName := 'Simple'.
	packageName := 'Simple-Core'.
	packageNames := {packageName}.
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment:
			'This is a simple project used to work out a "classic" class browser-style API'.

	className := 'SimpleEdit'.
	classDefinition := self _standardClassDefinition: className.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.

	classDefinition
		instVarNames: #();
		removeInstanceMethod: #'ivar1';
		classVarNames: #();
		removeClassMethod: #'cvar1';
		updateClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize civar1 := 1.');
		yourself.

	projectTools edit
		updateOrAddClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

	projectTools load loadProjectDefinition: projectDefinition.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self should: [ testClass perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testClass perform: #civar1) = 1.
	testInstance := testClass new.
	self should: [ testInstance perform: #ivar1 ] raise: MessageNotUnderstood.

	projectTools edit
		removeClass: classDefinition
		fromPackageNamed: packageName
		inProject: projectDefinition.

	projectTools load loadProjectDefinition: projectDefinition.

	testClass := Rowan globalNamed: className.
	self assert: testClass isNil
%

category: 'test api'
method: RwEditToolTest
testPreferences

	| projectName |
	projectName := '__Test-Preferences__'.

"standard API - user in GemStone"
	Rowan automaticClassInitializationBlackList add: projectName.
	self assert: (Rowan automaticClassInitializationBlackList includes: projectName).

	Rowan clearAutomaticClassInitializationBlackList.
	self deny: (Rowan automaticClassInitializationBlackList includes: projectName).

"globals"
	Rowan globalAutomaticClassInitializationBlackList add: projectName.
	self assert: (Rowan globalAutomaticClassInitializationBlackList includes: projectName).

	Rowan clearGlobalAutomaticClassInitializationBlackList.
	self deny: (Rowan globalAutomaticClassInitializationBlackList includes: projectName).

"users"
	Rowan userAutomaticClassInitializationBlackList add: projectName.
	self assert: (Rowan userAutomaticClassInitializationBlackList includes: projectName).

	Rowan clearUserAutomaticClassInitializationBlackList.
	self deny: (Rowan userAutomaticClassInitializationBlackList includes: projectName).

"session"
	Rowan  sessionAutomaticClassInitializationBlackList add: projectName.
	self assert: (Rowan sessionAutomaticClassInitializationBlackList includes: projectName).

	Rowan clearSessionAutomaticClassInitializationBlackList.
	self deny: (Rowan sessionAutomaticClassInitializationBlackList includes: projectName).
%

category: 'tests - classes'
method: RwEditToolTest
testUpdateClass

	| projectName packageNames packageName className projectTools projectDefinition classDefinition testClass testInstance |
	projectName := 'Simple'.
	packageName := 'Simple-Core'.
	packageNames := {packageName}.
	className := 'SimpleEdit'.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	self
		_loadStandardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment:
			'This is a simple project used to illustrate how to edit an existing class.'
		className: className
		inPackageName: packageName.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cvar1) = 2.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.

	projectTools := Rowan projectTools.
	projectTools edit
		definitionsForClassNamed: className
		ifFound: [ :classDef :packageDef :projectDef | 
			projectDefinition := projectDef.
			classDefinition := classDef ]
		ifAbsent: [ 
			self
				assert: false
				description:
					'expected class definition for class ' , className printString , ' not found.' ].

	classDefinition
		instVarNames: #();
		removeInstanceMethod: #'ivar1';
		classVarNames: #();
		removeClassMethod: #'cvar1';
		updateClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize civar1 := 1.');
		yourself.

	projectTools edit
		updateOrAddClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

	projectTools load loadProjectDefinition: projectDefinition.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self should: [ testClass perform: #cvar1 ] raise: MessageNotUnderstood.
	self assert: (testClass perform: #civar1) = 1.
	testInstance := testClass new.
	self should: [ testInstance perform: #ivar1 ] raise: MessageNotUnderstood
%

category: 'tests - classes'
method: RwEditToolTest
testUpdateClassExtension

	| projectName packageNames packageName1 packageName2 packageName3 className projectTools testClass testInstance classExtensionDefinitions |
	projectName := 'SimpleClassExtension'.
	packageName1 := 'Simple-Core'.
	packageName2 := 'Simple-Extension1'.
	packageName3 := 'Simple-Extension2'.
	packageNames := {packageName1.
	packageName2.
	packageName3}.
	className := 'SimpleEdit'.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	self
		_loadExtendedProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment:
			'This is a simple project used to illustrate how to edit an existing class.'
		className: className
		inPackageName: packageName1
		extensionPackageNames:
			{packageName2.
			packageName3}.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) = 1.
	self assert: (testClass perform: #cadd: with: 1) = 2.
	self assert: (testClass perform: #cvar1) = 2.
	testInstance := testClass new.
	testInstance perform: #ivar1: with: 2.
	self assert: (testInstance perform: #ivar1) = 2.
	self assert: (testInstance add: 1) = 3.

	classExtensionDefinitions := {}.
	projectTools := Rowan projectTools.
	projectTools edit
		definitionsForClassExtensionNamed: className
		ifFound: [ :classExtensionDef :packageDef :projectDef | 
			classExtensionDefinitions
				add:
					{classExtensionDef.
					packageDef.
					projectDef} ]
		ifAbsent: [ 
			self
				assert: false
				description:
					'expected class extension definitions for class ' , className printString
						, ' not found.' ].
	self
		assert: classExtensionDefinitions size = 2
		description:
			'two packages contain extensions for this class ... classExtensionRegistry does not record multiple extensions correctly'.

	classExtensionDefinitions
		do: [ :ar | 
			| classExtensionDef packageDef projectDef |
			classExtensionDef := ar at: 1.
			packageDef := ar at: 2.
			projectDef := ar at: 3.
			self assert: projectDef name = projectName.
			self assert: (packageNames includes: packageDef name).
			packageDef name = packageName2
				ifTrue: [ 
					self
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert:
								(classExtensionDef instanceMethodDefinitions includesKey: #'ivar1:');
						assert: classExtensionDef classMethodDefinitions size = 1;
						assert: (classExtensionDef classMethodDefinitions includesKey: #'cadd:') ].
			packageDef name = packageName3
				ifTrue: [ 
					self
						assert: classExtensionDef instanceMethodDefinitions size = 1;
						assert: (classExtensionDef instanceMethodDefinitions includesKey: #'add:') ] ]
%

category: 'private'
method: RwEditToolTest
_loadExtendedProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment className: className inPackageName: packageName1 extensionPackageName: packageName2

	| projectDefinition classDefinition classExtensionDefinition projectTools |
	projectTools := Rowan projectTools.

	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'This is a simple project used to test class extension edit API'.

	classDefinition := self _standardClassDefinition: className.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName1
		inProject: projectDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'ivar1:'
						protocol: 'accessing'
						source: 'ivar1: anInteger ivar1 := anInteger');
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'add:'
						protocol: 'addition'
						source: 'add: anInteger ^ivar1 + anInteger');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'cadd:'
						protocol: 'addition'
						source: 'cadd: anInteger ^civar1 + anInteger');
		yourself.

	projectTools edit
		addClassExtension: classExtensionDefinition
		inPackageNamed: packageName2
		inProject: projectDefinition.

	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].
%

category: 'private'
method: RwEditToolTest
_loadExtendedProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment className: className inPackageName: packageName1 extensionPackageNames: extensionPackageNames

	| projectDefinition classDefinition classExtensionDefinition projectTools |
	projectTools := Rowan projectTools.

	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'This is a simple project used to test class extension edit API'.

	classDefinition := self _standardClassDefinition: className.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName1
		inProject: projectDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'ivar1:'
						protocol: 'accessing'
						source: 'ivar1: anInteger ivar1 := anInteger');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'cadd:'
						protocol: 'addition'
						source: 'cadd: anInteger ^civar1 + anInteger');
		yourself.

	projectTools edit
		addClassExtension: classExtensionDefinition
		inPackageNamed: (extensionPackageNames at: 1)
		inProject: projectDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'add:'
						protocol: 'addition'
						source: 'add: anInteger ^ivar1 + anInteger');
		yourself.

	projectTools edit
		addClassExtension: classExtensionDefinition
		inPackageNamed: (extensionPackageNames at: 2)
		inProject: projectDefinition.


	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].
%

category: 'private'
method: RwEditToolTest
_loadStandardProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment className: className inPackageName: packageName

	| projectDefinition classDefinition projectTools |
	projectTools := Rowan projectTools.

	projectDefinition := self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment:
			'This is a simple project used to work out a "classic" class browser-style API'.

	classDefinition := self _standardClassDefinition: className.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].
%

category: 'private'
method: RwEditToolTest
_standardClassDefinition: className

	| classDefinition |
	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #('civar1')
		classvars: #('Cvar1')
		category: 'Simple Things'
		comment: 'I am a SimpleEdit class'
		pools: #()
		type: 'normal'.

	classDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize civar1 := 1. Cvar1 := 2.');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'civar1'
						protocol: 'accessing'
						source: 'civar1 ^civar1');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'cvar1'
						protocol: 'accessing'
						source: 'cvar1 ^Cvar1');
		yourself.

	^ classDefinition
%

category: 'private'
method: RwEditToolTest
_standardProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment

	| projectDefinition |
	projectDefinition := RwProjectDefinition
		newForGitBasedProjectNamed: projectName.
	projectDefinition
		comment: comment;
		packageNames: packageNames;
		yourself.
	projectDefinition defaultSymbolDictName: defaultSymbolDictName.

	^ projectDefinition
%

! Class implementation for 'RwMoveTest'

!		Instance methods for 'RwMoveTest'

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_between_existing_packages_and_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/316"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		ar oldClass loadedClass symDict registry |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.


	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition removeClassDefinition: classDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class == oldClass.

	loadedClass := Rowan image loadedClassNamed: className. "no error is success"

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_between_packages

	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/254"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class symDict registry |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition classDefinitions removeKey: classDefinition key.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_between_packages_and_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/254"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		ar oldClass loadedClass symDict registry |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.


	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class == oldClass.

	loadedClass := Rowan image loadedClassNamed: className. "no error is success"

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_with_changed_method_between_packages

	"https://github.com/dalehenrich/Rowan/issues/316"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class oldClass symDict registry loadedClass |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].
"setup defintions"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.

"move class and add change method"
	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition classDefinitions removeKey: classDefinition key.

	classDefinition
		updateInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^2').

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class == oldClass.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_with_changed_method_between_packages_and_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/316"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition 
		packageDefinition className projectSetDefinition class project audit
		ar oldClass loadedClass symDict registry |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"setup definitions"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

"move class; change method"
	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.

	classDefinition
		updateInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^2').

	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class == oldClass.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_with_extension_method_between_packages

	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/316"

	| projectName  packageName1 packageName2 packageName3 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class oldClass symDict registry loadedClass classExtensionDefinition |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	packageName3 := 'Issue254-Extension3'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"set up  definitions"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #ext1
						protocol: 'extension'
						source: 'ext1 ^ 1').

	packageDefinition := projectDefinition1 packageNamed: packageName3.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.

"move class"
	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition classDefinitions removeKey: classDefinition key.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class == oldClass.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #ext1) rowanPackageName = packageName3.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 3.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 2.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_with_extension_method_between_packages_and_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/316"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 packageName3 packageName4 projectDefinition1
		projectDefinition2 classDefinition packageDefinition className projectSetDefinition class 
		classExtensionDefinition ar oldClass loadedClass symDict registry project audit|
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Extension2'.
	packageName3 := 'Issue254-Core3'.
	packageName4 := 'Issue254-Extension4'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"setup"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #ext1
						protocol: '*', packageName2 asLowercase
						source: 'ext1 ^ 1').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #ext1) rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

	projectSetDefinition := RwProjectSetDefinition new.

"move class and extension method to different packages and symbol dictionaries"
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		removePackageNamed: packageName2;
		addPackageNamed: packageName3;
		addPackageNamed: packageName4;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName3;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName4.

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassDefinition: classDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName4.
	(classExtensionDefinition instanceMethodDefinitions at: #ext1)
		protocol: '*', packageName4 asLowercase.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectSetDefinition addDefinition: projectDefinition2.
"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName3.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName3.
	self assert: (class compiledMethodAt: #ext1) rowanPackageName = packageName4.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class == oldClass.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 2.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_with_method_between_packages

	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/254"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class oldClass symDict registry loadedClass |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition classDefinitions removeKey: classDefinition key.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class == oldClass.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_with_method_between_packages_and_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/254"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition 
		packageDefinition className projectSetDefinition class ar oldClass loadedClass symDict registry
		project audit |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class == oldClass.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_with_new_method_between_packages

	"https://github.com/dalehenrich/Rowan/issues/316"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class oldClass symDict registry loadedClass |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].
"setup defintions"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.

"move class and add new method"
	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition classDefinitions removeKey: classDefinition key.

	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class == oldClass.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 2.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_class_with_new_method_between_packages_and_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/316"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition 
		packageDefinition className projectSetDefinition class ar oldClass loadedClass symDict registry
		project audit |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].
"setup definitions"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

"move class; add new method"
	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

	packageDefinition := projectDefinition2 packageNamed: packageName2.

	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').

	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method2) rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class == oldClass.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 2.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_method_between_packages

	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/254"

	| projectName  packageName1 packageName2 packageName3 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class symDict registry classExtensionDefinition oldClass loadedPackage loadedClass loadedClassExtensions |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Extension2'.
	packageName3 := 'Issue254-Extension3'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: 'accessing'
					source: 'mover ^1').

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: (class new perform: #mover) = 1.
	self assert: class rowanPackageName = packageName1.
	self assert: (class categoryOfSelector: #mover) asString = 'accessing'.
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName1.

	loadedPackage := Rowan image loadedPackageNamed: packageName1.
	loadedClass := loadedPackage loadedClasses at: className.
	self assert: (loadedClass loadedInstanceMethods includesKey: #mover).
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: loadedClassExtensions isEmpty.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 3.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	classDefinition := packageDefinition classDefinitions at: classDefinition key.
	classDefinition removeInstanceMethod: #mover.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName2 asLowercase
					source: 'mover ^1').

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class == oldClass.
	self assert: (class new perform: #mover) = 1.
	self assert: class rowanPackageName = packageName1.
	self assert: (class categoryOfSelector: #mover) asString =  ('*', packageName2 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName2.

	loadedPackage := Rowan image loadedPackageNamed: packageName1.
	loadedClass := loadedPackage loadedClasses at: className.
	self assert: loadedClass instanceMethodDefinitions isEmpty.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: loadedClassExtensions isEmpty.

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClass := loadedPackage loadedClasses at: className ifAbsent: [].
	self assert: loadedClass isNil.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) loadedInstanceMethods includesKey: #mover).

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 3.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 1.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_modified_class_structure_between_packages

	"https://github.com/dalehenrich/Rowan/issues/286"

	"Class structure moved to a new package located in same symbol dictionary (precursor to #testProjectSet_move_modified_class_structure_between_packages_and_symbol_dicts)"

	"Old package structure:
		Issue_Command
			IssueSaveCommand
		IssueCommand
			IssueFileout
			IssueListClasses
	"

	"New packages structure:
		IssueCommand
			IssueFileout
			IssueListClasses
			IssueHelp
			IssueReport
	"


	| projectName  packageName1 packageName2  projectDefinition1 projectDefinition2 packageDefinition 
		className1 className2 className3 className4 className5 className6 className7
		projectSetDefinition class3 class4 class5  oldClass3 oldClass4 oldClass5 |

	projectName := 'Issue'.
	packageName1 := 'Issue-Core1'.
	packageName2 := 'Issue-Core2'.
	className1 := 'Issue_Command'.
	className2 := 'IssueSaveCommand'.
	className3 := 'IssueCommand'.
	className4 := 'IssueFileout'.
	className5 := 'IssueListClasses'.
	className6 := 'IssueHelp'.
	className7 := 'IssueReport'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create old package structure"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	packageDefinition := projectDefinition1 packageNamed: packageName1.

	packageDefinition 
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className1
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className2
			super: className1
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className3
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className4
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className5
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		yourself.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"verify"
	class3 := Rowan globalNamed: className3.
	class4 := Rowan globalNamed: className4.
	class5 := Rowan globalNamed: className5.
	self assert: class3 notNil.
	self assert: class4 notNil.
	self assert: class5 notNil.

"create new package structure"
	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.
	projectSetDefinition addDefinition: projectDefinition2.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition
		removeClassNamed: className1;	"deleted"
		removeClassNamed: className2;	"deleted"
		removeClassNamed: className3;	"moved"
		removeClassNamed: className4;	"moved"
		removeClassNamed: className5;	"moved"
		yourself.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition 
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className3
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className4
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className5
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className6
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className7
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		yourself.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"verify"
	oldClass3 := class3.
	oldClass4 := class4.
	oldClass5 := class5.

	class3 := Rowan globalNamed: className3.
	class4 := Rowan globalNamed: className4.
	class5 := Rowan globalNamed: className5.
	self assert: class3 notNil.
	self assert: class4 notNil.
	self assert: class5 notNil.
	self assert: class3 == oldClass3.
	self assert: class4 == oldClass4.
	self assert: class5 == oldClass5.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_modified_class_structure_between_packages_and_symbol_dicts

	"https://github.com/dalehenrich/Rowan/issues/286"

	"Class structure moved to a new package located in a different symbol dictionary"

	"Old package structure:
		Issue_Command
			IssueSaveCommand
		IssueCommand
			IssueFileout
			IssueListClasses
	"

	"New packages structure:
		IssueCommand
			IssueFileout
			IssueListClasses
			IssueHelp
			IssueReport
	"


	| projectName  packageName1 packageName2  projectDefinition1 projectDefinition2 packageDefinition 
		className1 className2 className3 className4 className5 className6 className7
		projectSetDefinition class3 class4 class5  oldClass3 oldClass4 oldClass5 project audit |

	projectName := 'Issue'.
	packageName1 := 'Issue-Core1'.
	packageName2 := 'Issue-Core2'.
	className1 := 'Issue_Command'.
	className2 := 'IssueSaveCommand'.
	className3 := 'IssueCommand'.
	className4 := 'IssueFileout'.
	className5 := 'IssueListClasses'.
	className6 := 'IssueHelp'.
	className7 := 'IssueReport'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create old package structure"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition1 packageNamed: packageName1.

	packageDefinition 
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className1
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className2
			super: className1
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className3
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className4
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className5
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		yourself.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"verify"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class3 := Rowan globalNamed: className3.
	class4 := Rowan globalNamed: className4.
	class5 := Rowan globalNamed: className5.
	self assert: class3 notNil.
	self assert: class4 notNil.
	self assert: class5 notNil.

"create new package structure"
	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.
	projectSetDefinition addDefinition: projectDefinition2.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition
		removeClassNamed: className1;	"deleted"
		removeClassNamed: className2;	"deleted"
		removeClassNamed: className3;	"moved"
		removeClassNamed: className4;	"moved"
		removeClassNamed: className5;	"moved"
		yourself.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition 
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className3
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className4
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className5
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className6
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className7
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		yourself.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"verify"
	self assert: (audit := project audit) isEmpty.
	oldClass3 := class3.
	oldClass4 := class4.
	oldClass5 := class5.

	class3 := Rowan globalNamed: className3.
	class4 := Rowan globalNamed: className4.
	class5 := Rowan globalNamed: className5.
	self assert: class3 notNil.
	self assert: class4 notNil.
	self assert: class5 notNil.
	self assert: class3 == oldClass3.
	self assert: class4 == oldClass4.
	self assert: class5 == oldClass5.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_modified_class_structure_with_new_class_version_between_packages_and_symbol_dicts_286

	"https://github.com/dalehenrich/Rowan/issues/286"

	"Class structure moved to a new package located in a different symbol dictionary. The surviving superclass has a new class version"

	"Old package structure:
		Issue_Command
			IssueSaveCommand
		IssueCommand
			IssueFileout
			IssueListClasses
	"

	"New packages structure:
		IssueCommand
			IssueFileout
			IssueListClasses
			IssueHelp
			IssueReport
	"


	| projectName  packageName1 packageName2  projectDefinition1 projectDefinition2 packageDefinition 
		className1 className2 className3 className4 className5 className6 className7
		projectSetDefinition class3 class4 class5  oldClass3 oldClass4 oldClass5 project audit |

	projectName := 'Issue'.
	packageName1 := 'Issue-Core1'.
	packageName2 := 'Issue-Core2'.
	className1 := 'Issue_Command'.
	className2 := 'IssueSaveCommand'.
	className3 := 'IssueCommand'.
	className4 := 'IssueFileout'.
	className5 := 'IssueListClasses'.
	className6 := 'IssueHelp'.
	className7 := 'IssueReport'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create old package structure"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition1 packageNamed: packageName1.

	packageDefinition 
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className1
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className2
			super: className1
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className3
			super: 'Object'
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className4
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className5
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName1
			comment: ''
			pools: #()
			type: 'normal');
		yourself.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"verify"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class3 := Rowan globalNamed: className3.
	class4 := Rowan globalNamed: className4.
	class5 := Rowan globalNamed: className5.
	self assert: class3 notNil.
	self assert: class4 notNil.
	self assert: class5 notNil.

"create new package structure"
	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.
	projectSetDefinition addDefinition: projectDefinition2.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition
		removeClassNamed: className1;	"deleted"
		removeClassNamed: className2;	"deleted"
		removeClassNamed: className3;	"moved"
		removeClassNamed: className4;	"moved"
		removeClassNamed: className5;	"moved"
		yourself.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition 
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className3
			super: 'Object'
			instvars: #(ivar1)
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className4
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className5
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className6
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		addClassDefinition: (RwClassDefinition
			newForClassNamed: className7
			super: className3
			instvars: #()
			classinstvars: #()
			classvars: #()
			category: packageName2
			comment: ''
			pools: #()
			type: 'normal');
		yourself.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"verify"
	self assert: (audit := project audit) isEmpty.
	oldClass3 := class3.
	oldClass4 := class4.
	oldClass5 := class5.

	class3 := Rowan globalNamed: className3.
	class4 := Rowan globalNamed: className4.
	class5 := Rowan globalNamed: className5.
	self assert: class3 notNil.
	self assert: class4 notNil.
	self assert: class5 notNil.
	self assert: class3 ~~ oldClass3.
	self assert: class4 ~~ oldClass4.
	self assert: class5 ~~ oldClass5.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_between_packages
	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/254"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class x newClass symDict registry |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition classDefinitions removeKey: classDefinition key.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	newClass := Rowan globalNamed: className.
	self assert: (x := class rowanPackageName) = packageName2.
	self assert: newClass ~~ class.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_between_packages_and_symbolDict
	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/254"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class oldClass ar symDict registry project audit |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

";oad"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class ~~ oldClass.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_with_extension_method_between_existing_packages

	"https://github.com/dalehenrich/Rowan/issues/316"

	| projectName  packageName1 packageName2 packageName3 packageName4 projectDefinition1 projectDefinition2 
		classDefinition packageDefinition className projectSetDefinition class x newClass symDict registry 
		classExtensionDefinition |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Extension2'.
	packageName3 := 'Issue254-Core3'.
	packageName4 := 'Issue254-Extension4'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].
"setup"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		addPackageNamed: packageName4;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #ext1
						protocol: 'extension'
						source: 'ext1 ^ 1').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #ext1) rowanPackageName = packageName2.

"move class with new version and extension method to new packages"
	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition removeClassDefinition: classDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition removeClassExtensionDefinition: classExtensionDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassDefinition: classDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName4.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	newClass := Rowan globalNamed: className.
	self assert: (x := newClass rowanPackageName) = packageName3.
	self assert: (newClass compiledMethodAt: #method1) rowanPackageName = packageName3.
	self assert: (x := (newClass compiledMethodAt: #ext1) rowanPackageName) = packageName4.
	self assert: newClass ~~ class.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 4.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 2.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_with_extension_method_between_existing_packages_and_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/316"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 packageName3 packageName4 projectDefinition1 
		projectDefinition2 classDefinition packageDefinition className projectSetDefinition class 
		oldClass ar loadedClass symDict registry classExtensionDefinition project audit |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Extension2'.
	packageName3 := 'Issue254-Core3'.
	packageName4 := 'Issue254-Extension4'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].
"setup"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		addPackageNamed: packageName4;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #ext1
						protocol: '*', packageName2 asLowercase
						source: 'ext1 ^ 1').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validation"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #ext1) rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

"move class with new version and extension methods"
	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName3;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName4.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition removeClassDefinition: classDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition removeClassExtensionDefinition: classExtensionDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassDefinition: classDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName4.
	(classExtensionDefinition instanceMethodDefinitions at: #ext1)
		protocol: '*', packageName4 asLowercase.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName3.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName3.
	self assert: (class compiledMethodAt: #ext1) rowanPackageName = packageName4.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class ~~ oldClass.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 2.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_with_extension_method_between_packages

	"https://github.com/dalehenrich/Rowan/issues/316"

	| projectName  packageName1 packageName2 packageName3 packageName4 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class x newClass symDict registry classExtensionDefinition |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Extension2'.
	packageName3 := 'Issue254-Core3'.
	packageName4 := 'Issue254-Extension4'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].
"setup"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #ext1
						protocol: 'extension'
						source: 'ext1 ^ 1').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #ext1) rowanPackageName = packageName2.

"move class with new version and extension method to new packages"
	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.
	projectDefinition2
		removePackageNamed: packageName1;
		removePackageNamed: packageName2;
		addPackageNamed: packageName3;
		addPackageNamed: packageName4.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassDefinition: classDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName4.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	newClass := Rowan globalNamed: className.
	self assert: (x := newClass rowanPackageName) = packageName3.
	self assert: (newClass compiledMethodAt: #method1) rowanPackageName = packageName3.
	self assert: (x := (newClass compiledMethodAt: #ext1) rowanPackageName) = packageName4.
	self assert: newClass ~~ class.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 2.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_with_extension_method_between_packages_and_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/316"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 packageName3 packageName4 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class oldClass ar loadedClass symDict registry classExtensionDefinition project audit |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Extension2'.
	packageName3 := 'Issue254-Core3'.
	packageName4 := 'Issue254-Extension4'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].
"setup"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #ext1
						protocol: '*', packageName2 asLowercase
						source: 'ext1 ^ 1').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validation"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #ext1) rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

"move class with new version and extension methods"
	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName3;
		removePackageNamed: packageName2;
		addPackageNamed: packageName4;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName3;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName4.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassDefinition: classDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName4.
	(classExtensionDefinition instanceMethodDefinitions at: #ext1)
		protocol: '*', packageName4 asLowercase.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName3.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName3.
	self assert: (class compiledMethodAt: #ext1) rowanPackageName = packageName4.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class ~~ oldClass.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 2.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_with_method_between_existing_packages

	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/316"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class x newClass symDict registry |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition classDefinitions removeKey: classDefinition key.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	newClass := Rowan globalNamed: className.
	self assert: (x := newClass rowanPackageName) = packageName2.
	self assert: (newClass compiledMethodAt: #method1) rowanPackageName = packageName2.
	self assert: newClass ~~ class.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_with_method_between_existing_packages_and_symbolDict
	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/316"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class oldClass ar loadedClass symDict registry project audit |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition removeClassNamed: classDefinition name.
	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class ~~ oldClass.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_with_method_between_packages

	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/316"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class x newClass symDict registry |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	projectDefinition2 removePackageNamed: packageName1.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition addDefinition: projectDefinition2.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	newClass := Rowan globalNamed: className.
	self assert: (x := newClass rowanPackageName) = packageName2.
	self assert: (newClass compiledMethodAt: #method1) rowanPackageName = packageName2.
	self assert: newClass ~~ class.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_with_method_between_packages_and_symbolDict
	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/316"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class oldClass ar loadedClass symDict registry project audit |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class ~~ oldClass.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 1.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_with_new_method_between_packages

	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/316"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class x newClass symDict registry |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

"create project"
	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.

"load"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.

"create new version and add new method"
	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName1.
	packageDefinition classDefinitions removeKey: classDefinition key.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.

"validate"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	newClass := Rowan globalNamed: className.
	self assert: (x := newClass rowanPackageName) = packageName2.
	self assert: (newClass compiledMethodAt: #method1) rowanPackageName = packageName2.
	self assert: newClass ~~ class.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 2.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_new_class_version_with_new_method_between_packages_and_symbolDict
	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/316"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition 
		className projectSetDefinition class oldClass ar loadedClass symDict registry project audit |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName1 asSymbol.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

	classDefinition 
		instVarNames: (classDefinition instVarNames copy add: 'ivar1'; yourself). "force new class version"

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').

	packageDefinition addClassDefinition: classDefinition.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass := Rowan image loadedClassNamed: className.
	loadedClass loadedInstanceMethods includesKey: #method1.

"validate"
	self assert: (audit := project audit) isEmpty.
	oldClass := class.
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method2) rowanPackageName = packageName2.
	ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
	self assert: ar size = 1.
	self assert: (ar first at: 1) name = self _symbolDictionaryName2 asSymbol.

	self assert: class ~~ oldClass.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 2.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_move_packages_between_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/316"

	"initial load uses symbol dictionary _1, second load uses symbol dictionary _2"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 projectSetDefinition
		symDict registry x project audit |
	projectName := 'Issue254'.
	packageName1 := 'Issue254-Core1'.
	packageName2 := 'Issue254-Core2'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].
"create packages"
	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 2.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	self assert: symDict isNil.

"move package to alternate symbol dict"
	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2.

"load"
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"validate"
	self assert: (audit := project audit) isEmpty.
	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: (x := registry packageRegistry size) = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_rename_package

	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/254"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		symDict registry |
	projectName := 'Issue254'.
	packageName1 := 'Issue1254-Core'.
	packageName2 := 'Issue254-RenamedCore'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].


	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		yourself.
	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_rename_package_add_change_remove_method

	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/254"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		symDict registry x |
	projectName := 'Issue254'.
	packageName1 := 'Issue1254-Core'.
	packageName2 := 'Issue254-RenamedCore'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].


	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method2) rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method3) rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #method2) = 2.
	self assert: (class new perform: #method3) = 3.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		yourself.
	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	classDefinition
		removeInstanceMethod: #method2;
		removeInstanceMethod: #method3;
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^5');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').

	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method3) rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method4) rowanPackageName = packageName2.
	self assert: (class new perform: #method1) = 1.
	self should: [ (class new perform: #method2) = 2 ] raise: MessageNotUnderstood.
	self assert: (x := class new perform: #method3) = 5.
	self assert: (class new perform: #method4) = 4.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 3.
%

category: 'tests - issue 254'
method: RwMoveTest
testProjectSet_rename_package_and_symbolDict_add_change_remove_method

	"Use the regular load stack"

	"https://github.com/dalehenrich/Rowan/issues/254"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		symDict registry x |
	projectName := 'Issue254'.
	packageName1 := 'Issue1254-Core'.
	packageName2 := 'Issue254-RenamedCore'.
	className := 'Issue254Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].


	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName1 forPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: packageName2;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method2) rowanPackageName = packageName1.
	self assert: (class compiledMethodAt: #method3) rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #method2) = 2.
	self assert: (class new perform: #method3) = 3.

	projectSetDefinition := RwProjectSetDefinition new.
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition
		removePackageNamed: packageName1;
		addPackageNamed: packageName2;
		yourself.
	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition addClassDefinition: classDefinition.

	classDefinition
		removeInstanceMethod: #method2;
		removeInstanceMethod: #method3;
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^5');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').

	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method1) rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method3) rowanPackageName = packageName2.
	self assert: (class compiledMethodAt: #method4) rowanPackageName = packageName2.
	self assert: (class new perform: #method1) = 1.
	self should: [ (class new perform: #method2) = 2 ] raise: MessageNotUnderstood.
	self assert: (x := class new perform: #method3) = 5.
	self assert: (class new perform: #method4) = 4.

	symDict := Rowan globalNamed: self _symbolDictionaryName1.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.

	symDict := Rowan globalNamed: self _symbolDictionaryName2.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 1.
	self assert: registry classRegistry size = 1.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 3.
%

! Class implementation for 'RwPlatformInstanceTest'

!		Instance methods for 'RwPlatformInstanceTest'

category: 'running'
method: RwPlatformInstanceTest
tearDown

	super tearDown.
	Rowan platform clearAllPreferencesFor: self _testPreference
%

category: 'test preferences (issue #448)'
method: RwPlatformInstanceTest
testDefaultPrecedence

	"https://github.com/GemTalk/Rowan/issues/448"

	| platformInstance  x preference |
	platformInstance := Rowan platform.
	preference := self _testPreference.

	platformInstance setDefaultPreferenceFor: preference to: #default.
	self assert: (x := platformInstance preferenceFor: preference) == #default.

	platformInstance setPreferenceFor: preference to: #user.
	self assert: (x := platformInstance preferenceFor: preference) == #user. 

	self assert: (x := platformInstance defaultPreferenceFor: preference) == #default. 

"testing GemStone implementation"
	self assert: (x := platformInstance  globalPreferenceFor: preference ifAbsent: [#absent ]) == #default. 
	self assert: (x := platformInstance  userPreferenceFor: preference ifAbsent: [#absent ]) == #user. 
	self assert: (x := platformInstance  sessionPreferenceFor: preference ifAbsent: [ #absent ]) == #absent. 

	platformInstance clearPreferenceFor: preference.
	platformInstance clearDefaultPreferenceFor: preference.
	self should: [ platformInstance preferenceFor: preference ] raise: Error
%

category: 'test preferences (issue #448)'
method: RwPlatformInstanceTest
testGlobalPreferences

	"https://github.com/GemTalk/Rowan/issues/448"

	| platformInstance  x preference |
	platformInstance := Rowan platform.
	preference := self _testPreference.

	platformInstance clearGlobalPreferenceFor: preference.
	self should: [ x := platformInstance globalPreferenceFor: preference ] raise: Error.

	platformInstance setGlobalPreferenceFor: preference to: true.
	self assert: (platformInstance preferenceFor: preference).
%

category: 'test preferences (issue #448)'
method: RwPlatformInstanceTest
testPreferencePrecedence

	"https://github.com/GemTalk/Rowan/issues/448"

	| platformInstance  x preference |
	platformInstance := Rowan platform.
	preference := self _testPreference.

	platformInstance setGlobalPreferenceFor: preference to: #global.
	self assert: (platformInstance preferenceFor: preference) == #global.

	platformInstance setUserPreferenceFor: preference to: #user.
	self assert: (platformInstance preferenceFor: preference) == #user.

	platformInstance setSessionPreferenceFor: preference to: #session.
	self assert: (platformInstance preferenceFor: preference) == #session.

	platformInstance setPreferenceFor: preference to: #default.
	self assert: (x := platformInstance preferenceFor: preference) == #default. 

	self assert: (x := platformInstance userPreferenceFor: preference ifAbsent: [ #absent ]) == #default. 		"session prefs cleared and user prefs set"
	self assert: (x := platformInstance sessionPreferenceFor: preference ifAbsent: [ #absent ]) == #absent. 	"session prefs cleared and user prefs set"

	platformInstance setSessionPreferenceFor: preference to: #session.
	platformInstance clearPreferenceFor: preference.										"session and user prefs cleared"
	self assert: (x := platformInstance preferenceFor: preference) == #global.
%

category: 'test preferences (issue #448)'
method: RwPlatformInstanceTest
testPreferences

	"https://github.com/GemTalk/Rowan/issues/448"

	| platformInstance  x preference |
	platformInstance := Rowan platform.
	preference := self _testPreference.

	self assert: (platformInstance isKindOf: RwPlatform).

	platformInstance clearPreferenceFor: preference.
	self should: [ x := platformInstance preferenceFor: preference ] raise: Error.

	platformInstance setPreferenceFor: preference to: true.
	self assert: (platformInstance preferenceFor: preference).
%

category: 'test preferences (issue #448)'
method: RwPlatformInstanceTest
testSessionPreferences

	"https://github.com/GemTalk/Rowan/issues/448"

	| platformInstance  x preference |
	platformInstance := Rowan platform.
	preference := self _testPreference.

	platformInstance clearSessionPreferenceFor: preference.
	self should: [ x := platformInstance sessionPreferenceFor: preference ] raise: Error.

	platformInstance setSessionPreferenceFor: preference to: true.
	self assert: (platformInstance preferenceFor: preference).
%

category: 'test preferences (issue #448)'
method: RwPlatformInstanceTest
testUserPreferences

	"https://github.com/GemTalk/Rowan/issues/448"

	| platformInstance  x preference |
	platformInstance := Rowan platform.
	preference := self _testPreference.

	platformInstance clearUserPreferenceFor: preference.
	self should: [ x := platformInstance userPreferenceFor: preference ] raise: Error.

	platformInstance setUserPreferenceFor: preference to: true.
	self assert: (platformInstance preferenceFor: preference).
%

category: 'private'
method: RwPlatformInstanceTest
_testPreference

	^#'unknown_preference'
%

! Class implementation for 'RwProjectSetTest'

!		Instance methods for 'RwProjectSetTest'

category: 'tests'
method: RwProjectSetTest
testProjectAdoptTool

	"Create project definition structure (2 projects), build classes and methods using traditional methods, 
		then adopt the structure"

	| projectTools projectName1 projectName2 projectDefinition1 projectDefinition2 projectSetDefinition projectNames
		classDefinition packageNames1 packageNames2 classNames1 classNames2 classExtensionDefinition 
		symDict1 symDict2 symbolList theClass loadedProjectSet diff classComment |

	projectTools := Rowan projectTools.
	projectName1 := 'AdoptProject1'.
	projectName2 := 'AdoptProject2'.
	projectNames := {projectName1.
		projectName2}.
	packageNames1 := #('Adopt1-Core' 'Adopt1-Extensions').
	packageNames2 := #('Adopt2-Core' 'Adopt2-Extensions').
	classNames1 := #('Adopt1Class1').
	classNames2 := #('Adopt2Class1').
	classComment := ''.

	projectNames
		do: [ :projectName | 
			(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName1.
	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName2.

	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition1 := RwProjectDefinition
		newForGitBasedProjectNamed: projectName1.
	projectDefinition1
		packageNames: packageNames1;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: (packageNames1 at: 2).

	projectSetDefinition addDefinition: projectDefinition1.

	projectDefinition2 := RwProjectDefinition
		newForGitBasedProjectNamed: projectName2.
	projectDefinition2
		addPackagesNamed: packageNames2;
		defaultSymbolDictName: self _symbolDictionaryName2;
		setSymbolDictName: self _symbolDictionaryName1 forPackageNamed: (packageNames2 at: 2).
	projectSetDefinition addDefinition: projectDefinition2.

	projectTools load loadProjectSetDefinition: projectSetDefinition. "create loaded project and empty loaded packages"

	"construct project definition structures"
	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition1 := (Rowan image loadedProjectNamed: projectName1) asDefinition.
	projectSetDefinition addProject: projectDefinition1.

	classDefinition := RwClassDefinition
		newForClassNamed: (classNames1 at: 1)
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: (packageNames1 at: 1)
		comment: classComment
		pools: #()
		type: 'normal'.
	classDefinition
		gs_symbolDictionary: self _symbolDictionaryName1;
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'instanceFoo'
				protocol: 'accessing'
				source: 'instanceFoo ^true');
		addClassMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'classFoo'
				protocol: 'accessing'
				source: 'classFoo ^true').

	(projectDefinition1 packageNamed: (packageNames1 at: 1))
		addClassDefinition: classDefinition.

	classExtensionDefinition := (RwClassExtensionDefinition
			newForClassNamed: (classNames2 at: 1))
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'instanceExtensionFoo'
						protocol: '*', (packageNames1 at: 2)
						source: 'instanceExtensionFoo ^true');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'classExtensionFoo'
						protocol:'*', (packageNames1 at: 2)
						source: 'classExtensionFoo ^true');		
		yourself.

	(projectDefinition1 packageNamed: (packageNames1 at: 2))
		addClassExtensionDefinition: classExtensionDefinition.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName2) asDefinition.
	projectSetDefinition addProject: projectDefinition2.

	classDefinition := RwClassDefinition
		newForClassNamed: (classNames2 at: 1)
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: (packageNames2 at: 1)
		comment: classComment
		pools: #()
		type: 'normal'.
	classDefinition
		gs_symbolDictionary: self _symbolDictionaryName2;
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'instanceBar'
				protocol: 'accessing'
				source: 'instanceBar ^true');
		addClassMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'classBar'
				protocol: 'accessing'
				source: 'classBar ^true').

	(projectDefinition2 packageNamed: (packageNames2 at: 1))
		addClassDefinition: classDefinition.

	classExtensionDefinition := (RwClassExtensionDefinition
			newForClassNamed: (classNames1 at: 1))
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'instanceExtensionBar'
						protocol: '*', (packageNames2 at: 2)
						source: 'instanceExtensionBar ^true');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'classExtensionBar'
						protocol:'*', (packageNames2 at: 2)
						source: 'classExtensionBar ^true');		
		yourself.

	(projectDefinition2 packageNamed: (packageNames2 at: 2))
		addClassExtensionDefinition: classExtensionDefinition.

	"construct class structures using traditional methods"
	symbolList := Rowan image symbolList.

	symDict1 := Rowan globalNamed: self _symbolDictionaryName1.
	theClass := Object subclass: (classNames1 at: 1)
			instVarNames: #()
			classVars: #()
			classInstVars: #()
			poolDictionaries: #()
			inDictionary: symDict1
			options: #().
	theClass 
		comment: classComment;
		category: (packageNames1 at: 1).
	theClass
		compileMethod: 'instanceFoo ^true'
			dictionaries: symbolList
			category: 'accessing';
		compileMethod: 'instanceExtensionBar ^true'
			dictionaries: symbolList
			category: '*', (packageNames2 at: 2).
	theClass class
		compileMethod: 'classFoo ^true'
			dictionaries: symbolList
			category: 'accessing';
		compileMethod: 'classExtensionBar ^true'
			dictionaries: symbolList
			category: '*', (packageNames2 at: 2).

	symDict2 := Rowan globalNamed: self _symbolDictionaryName2.
	theClass := Object subclass: (classNames2 at: 1)
			instVarNames: #()
			classVars: #()
			classInstVars: #()
			poolDictionaries: #()
			inDictionary: symDict2
			options: #().
	theClass 
		comment: classComment;
		category: (packageNames2 at: 1).
	theClass
		compileMethod: 'instanceBar ^true'
			dictionaries: symbolList
			category: 'accessing';
		compileMethod: 'instanceExtensionFoo ^true'
			dictionaries: symbolList
			category: '*', (packageNames1 at: 2).
	theClass class
		compileMethod: 'classBar ^true'
			dictionaries: symbolList
			category: 'accessing';
		compileMethod: 'classExtensionFoo ^true'
			dictionaries: symbolList
			category: '*', (packageNames1 at: 2).

	"adopt the class structure using the project definitions"
	projectTools adopt adoptProjectSetDefinition: projectSetDefinition.

	"validate that adopted project structure matches the project defintions"
	loadedProjectSet := projectSetDefinition deriveLoadedThings
		asProjectDefinitionSet.
	diff := projectSetDefinition compareAgainstBase: loadedProjectSet.
	self assert: diff isEmpty.
%

category: 'tests'
method: RwProjectSetTest
testProjectAdoptTool_existing_project

	"Create project definition structure (2 projects), build classes and methods using traditional methods, 
		then adopt the structure"

	"test for RwPkgCreateTool>>createLoadedPackageNamed:inProjectNamed:"

	| projectTools projectName1 projectName2 projectDefinition1 projectDefinition2 projectSetDefinition projectNames
		classDefinition packageNames1 packageNames2 classNames1 classNames2 classExtensionDefinition 
		symDict1 symDict2 symbolList theClass loadedProjectSet diff classComment pkgCreateTool |

	projectTools := Rowan projectTools.
	projectName1 := 'AdoptProject1'.
	projectName2 := 'AdoptProject2'.
	projectNames := {projectName1.
		projectName2}.
	packageNames1 := #('Adopt1-Core' 'Adopt1-Extensions').
	packageNames2 := #('Adopt2-Core' 'Adopt2-Extensions').
	classNames1 := #('Adopt1Class1').
	classNames2 := #('Adopt2Class1').
	classComment := ''.

	projectNames
		do: [ :projectName | 
			(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName1.
	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName2.

	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition1 := RwProjectDefinition
		newForGitBasedProjectNamed: projectName1.
	projectDefinition1
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2 forPackageNamed: (packageNames1 at: 2).

	projectSetDefinition addDefinition: projectDefinition1.

	projectDefinition2 := RwProjectDefinition
		newForGitBasedProjectNamed: projectName2.
	projectDefinition2
		defaultSymbolDictName: self _symbolDictionaryName2;
		setSymbolDictName: self _symbolDictionaryName1 forPackageNamed: (packageNames2 at: 2).
	projectSetDefinition addDefinition: projectDefinition2.

	"create projects with no packages"
	projectTools load loadProjectSetDefinition: projectSetDefinition. "create loaded project and empty loaded packages"

	"add new packages to loaded projects"
	pkgCreateTool := Rowan packageTools create.
	
	packageNames1 do: [:packageName |
		pkgCreateTool createLoadedPackageNamed: packageName inProjectNamed: projectName1 ].
	packageNames2 do: [:packageName |
		pkgCreateTool createLoadedPackageNamed: packageName inProjectNamed: projectName2 ].

	"construct project definition structures"
	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition1 := (Rowan image loadedProjectNamed: projectName1) asDefinition.
	projectSetDefinition addProject: projectDefinition1.

	classDefinition := RwClassDefinition
		newForClassNamed: (classNames1 at: 1)
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: (packageNames1 at: 1)
		comment: classComment
		pools: #()
		type: 'normal'.
	classDefinition
		gs_symbolDictionary: self _symbolDictionaryName1;
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'instanceFoo'
				protocol: 'accessing'
				source: 'instanceFoo ^true');
		addClassMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'classFoo'
				protocol: 'accessing'
				source: 'classFoo ^true').

	(projectDefinition1 packageNamed: (packageNames1 at: 1))
		addClassDefinition: classDefinition.

	classExtensionDefinition := (RwClassExtensionDefinition
			newForClassNamed: (classNames2 at: 1))
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'instanceExtensionFoo'
						protocol: '*', (packageNames1 at: 2)
						source: 'instanceExtensionFoo ^true');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'classExtensionFoo'
						protocol:'*', (packageNames1 at: 2)
						source: 'classExtensionFoo ^true');		
		yourself.

	(projectDefinition1 packageNamed: (packageNames1 at: 2))
		addClassExtensionDefinition: classExtensionDefinition.

	projectDefinition2 := (Rowan image loadedProjectNamed: projectName2) asDefinition.
	projectSetDefinition addProject: projectDefinition2.

	classDefinition := RwClassDefinition
		newForClassNamed: (classNames2 at: 1)
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: (packageNames2 at: 1)
		comment: classComment
		pools: #()
		type: 'normal'.
	classDefinition
		gs_symbolDictionary: self _symbolDictionaryName2;
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'instanceBar'
				protocol: 'accessing'
				source: 'instanceBar ^true');
		addClassMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'classBar'
				protocol: 'accessing'
				source: 'classBar ^true').

	(projectDefinition2 packageNamed: (packageNames2 at: 1))
		addClassDefinition: classDefinition.

	classExtensionDefinition := (RwClassExtensionDefinition
			newForClassNamed: (classNames1 at: 1))
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'instanceExtensionBar'
						protocol: '*', (packageNames2 at: 2)
						source: 'instanceExtensionBar ^true');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'classExtensionBar'
						protocol:'*', (packageNames2 at: 2)
						source: 'classExtensionBar ^true');		
		yourself.

	(projectDefinition2 packageNamed: (packageNames2 at: 2))
		addClassExtensionDefinition: classExtensionDefinition.

	"construct class structures using traditional methods"
	symbolList := Rowan image symbolList.

	symDict1 := Rowan globalNamed: self _symbolDictionaryName1.
	theClass := Object subclass: (classNames1 at: 1)
			instVarNames: #()
			classVars: #()
			classInstVars: #()
			poolDictionaries: #()
			inDictionary: symDict1
			options: #().
	theClass 
		comment: classComment;
		category: (packageNames1 at: 1).
	theClass
		compileMethod: 'instanceFoo ^true'
			dictionaries: symbolList
			category: 'accessing';
		compileMethod: 'instanceExtensionBar ^true'
			dictionaries: symbolList
			category: '*', (packageNames2 at: 2).
	theClass class
		compileMethod: 'classFoo ^true'
			dictionaries: symbolList
			category: 'accessing';
		compileMethod: 'classExtensionBar ^true'
			dictionaries: symbolList
			category: '*', (packageNames2 at: 2).

	symDict2 := Rowan globalNamed: self _symbolDictionaryName2.
	theClass := Object subclass: (classNames2 at: 1)
			instVarNames: #()
			classVars: #()
			classInstVars: #()
			poolDictionaries: #()
			inDictionary: symDict2
			options: #().
	theClass 
		comment: classComment;
		category: (packageNames2 at: 1).
	theClass
		compileMethod: 'instanceBar ^true'
			dictionaries: symbolList
			category: 'accessing';
		compileMethod: 'instanceExtensionFoo ^true'
			dictionaries: symbolList
			category: '*', (packageNames1 at: 2).
	theClass class
		compileMethod: 'classBar ^true'
			dictionaries: symbolList
			category: 'accessing';
		compileMethod: 'classExtensionFoo ^true'
			dictionaries: symbolList
			category: '*', (packageNames1 at: 2).

	"adopt the class structure using the project definitions"
	projectTools adopt adoptProjectSetDefinition: projectSetDefinition.

	"validate that adopted project structure matches the project defintions"
	loadedProjectSet := projectSetDefinition deriveLoadedThings
		asProjectDefinitionSet.
	diff := projectSetDefinition compareAgainstBase: loadedProjectSet.
	self assert: diff isEmpty.
%

category: 'tests'
method: RwProjectSetTest
testProjectSetLoad1

	| projectTools projectName1 projectName2 projectDefinition1 projectDefinition2 projectSetDefinition projectNames loadedProjects |
	projectTools := Rowan projectTools.
	projectName1 := 'Simple1'.
	projectName2 := 'Simple2'.
	projectNames := {projectName1.
	projectName2}.


	projectNames
		do: [ :projectName | 
			(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName1.
	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName2.

	projectSetDefinition := RwProjectSetDefinition new.

	projectDefinition1 := RwProjectDefinition
		newForGitBasedProjectNamed: projectName1.
	projectDefinition1
		packageNames: #('Simple1-Core');
		defaultSymbolDictName: self _symbolDictionaryName1.
	projectSetDefinition addDefinition: projectDefinition1.

	projectDefinition2 := RwProjectDefinition
		newForGitBasedProjectNamed: projectName2.
	projectDefinition2
		addPackagesNamed: #('Simple2-Core');
		defaultSymbolDictName: self _symbolDictionaryName2.
	projectSetDefinition addDefinition: projectDefinition2.

	projectTools load loadProjectSetDefinition: projectSetDefinition.

	self
		assert:
			(loadedProjects := self _loadedProjectsNamed: projectNames) size
				= projectNames size.
	loadedProjects entities
		do: [ :loadedProject | self assert: (projectNames includes: loadedProject name) ]
%

! Class implementation for 'RwProjectToolTest'

!		Instance methods for 'RwProjectToolTest'

category: 'tests'
method: RwProjectToolTest
testProjectClassExtensionsInSeparateSymbolDictionary

	"This test attempts to add extension methods to a class that is not in the dictionary that the package is being loaded into ... this should actually error out ... all definitions in a package should be applied to a single symbol dictionary ... create separate packages to do cross symbol dictionary updateds ... or possibly use session methods (yet to be determined."

	| projectName1 projectName2 projectDefinition1 projectDefinition2 projectTools classDefinition packageDefinition1 packageNames1 packageDefinition2 packageNames2 className classExtensionDefinition |
	projectName1 := 'Simple'.
	packageNames1 := #('Simple-Core' 'Simple-Tests').
	projectName2 := 'Simple Extensions'.
	packageNames2 := #('Simple-Extensions').
	projectTools := Rowan projectTools.

	{projectName1.
	projectName2}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName1)
		comment:
				'This is a simple project created in memory first, then written to disk.';
		packageNames: #('Simple-Core' 'Simple-Tests');
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName1.

	className := 'Simple'.
	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #(#'civar1')
		classvars: #()
		category: nil
		comment: 'I am a Simple class with extensions'
		pools: #()
		type: 'normal'.

	packageDefinition1 := projectDefinition1 packageNamed: 'Simple-Core'.
	packageDefinition1 addClassDefinition: classDefinition.

	projectTools load loadProjectDefinition: projectDefinition1.

	projectDefinition2 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName2)
		comment:
				'This is a class extension project created in memory first, then written to disk. Uses a separate symbol dictionary from project 1';
		addPackagesNamed: #('Simple-Extensions');
		defaultSymbolDictName: self _symbolDictionaryName2;
		yourself.

	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName2.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize civar1 := 1.');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'civar1'
						protocol: 'accessing'
						source: 'civar1 ^civar1');
		yourself.

	packageDefinition2 := projectDefinition2 packageNamed: 'Simple-Extensions'.
	packageDefinition2 addClassExtensionDefinition: classExtensionDefinition.
	self
		should: [ 
			"class extensions need to be made by packages loaded into the symbol dictionary in which the class is defined"
			projectTools load loadProjectDefinition: projectDefinition2 ]
		raise: Error
%

category: 'tests'
method: RwProjectToolTest
testProjectClassExtensionsInSessionMethods

	"This test attempts to add extension methods to a class that is not in the dictionary that the package is being loaded into ... and the extension methods are kept in session methods in the package's symbol dictionary ..."

	| projectName projectDefinition projectTools classDefinition1 classDefinition2 packageDefinition1 packageDefinition2 className1 className2 testClass1 testInstance1 testClass2 testInstance2 classExtensionDefinition packageNames |
	projectName := 'Simple'.
	packageNames := #('Simple-Core' 'Simple-Extensions' 'Simple-Tests').
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		comment:
				'This is a simple project created in memory first, then written to disk.';
		packageNames: packageNames;
		defaultSymbolDictName: self _symbolDictionaryName1;
		setSymbolDictName: self _symbolDictionaryName2
			forPackageNamed: 'Simple-Extensions';
		defaultUseSessionMethodsForExtensions: false;
		setUseSessionMethodsForExtensions: true forPackageNamed: 'Simple-Extensions';
		yourself.

	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName1.
	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName2.

	className1 := 'Simple'.
	className2 := 'SimpleAssociation'.

	classDefinition1 := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #(#'civar1')
		classvars: #()
		category: nil
		comment: 'I am a Simple class with extensions'
		pools: #()
		type: 'normal'.

	packageDefinition1 := projectDefinition packageNamed: 'Simple-Core'.
	packageDefinition1 addClassDefinition: classDefinition1.

	projectTools load loadProjectDefinition: projectDefinition.

	testClass1 := Rowan globalNamed: className1.
	self assert: testClass1 notNil.
	testInstance1 := testClass1 new.
	testClass2 := Rowan globalNamed: className2.
	self assert: testClass2 isNil.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize civar1 := 1.');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'civar1'
						protocol: 'accessing'
						source: 'civar1 ^civar1');
		yourself.
	classDefinition2 := RwClassDefinition
		newForClassNamed: className2
		super: 'Association'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: 'I am a SimpleAssociation class'
		pools: #()
		type: 'normal'.
	classDefinition2
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'foo'
				protocol: 'accessing'
				source: 'foo ^ true').

	packageDefinition2 := projectDefinition packageNamed: 'Simple-Extensions'.
	packageDefinition2 addClassDefinition: classDefinition2.
	packageDefinition2 addClassExtensionDefinition: classExtensionDefinition.

	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].

	self assert: (testClass1 perform: #civar1) == 1.
	self assert: (testInstance1 perform: #ivar1) isNil.
	testClass2 := Rowan globalNamed: className2.
	self assert: testClass2 notNil.
	testInstance2 := testClass2 new.
	self assert: (testInstance2 perform: #foo)
%

category: 'tests'
method: RwProjectToolTest
testProjectGlobalsClassesExtensionsInSessionMethods

	"This test attempts to add extension methods to a class is in Globals --- a symbol dictionary owned by another user ... and the extension methods are kept in session methods in the package's symbol dictionary ..."

	| projectName projectDefinition projectTools packageDefinition className classExtensionDefinition packageNames |
	projectName := 'Simple'.
	packageNames := #('Simple-Globals-Extensions').
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	projectDefinition := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		comment:
				'This is a simple project created in memory first, then written to disk.';
		packageNames: packageNames;
		defaultSymbolDictName: self _symbolDictionaryName;
		setUseSessionMethodsForExtensions: true
			forPackageNamed: 'Simple-Globals-Extensions';
		yourself.

	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName.

	className := 'Object'.

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'instanceFoo'
						protocol: 'accessing'
						source: 'instanceFoo ^''foo''');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'classFoo'
						protocol: 'accessing'
						source: 'classFoo ^''bar''');
		yourself.

	packageDefinition := projectDefinition
		packageNamed: 'Simple-Globals-Extensions'.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	projectTools load loadProjectDefinition: projectDefinition.

	self assert: (Object perform: #classFoo) = 'bar'.
	self assert: (Object new perform: #instanceFoo) = 'foo'
%

! Class implementation for 'RwRowanSample1Test'

!		Class methods for 'RwRowanSample1Test'

category: 'private'
classmethod: RwRowanSample1Test
_symbolDictionaryNames

	^ 	super _symbolDictionaryNames, 
			#( #'SampleSymbolDict')
%

!		Instance methods for 'RwRowanSample1Test'

category: 'tests'
method: RwRowanSample1Test
testIssue345

	"https://github.com/GemTalk/Rowan/issues/514"

	"This test (for 3.5.0) is actually about being able to change the component
		properties before loading ... post clone ... Right now I am not completely
		sure what sematics should be applied:
			- disallow changing component properteis - if you want different properties
				edit the component --- NOT COOL
			- somehow arrange for changes made to the ""loaded project"" to survive
				the read that ??must happend?? before being able to load the project 
				from disk
			- require that the project be read from disk before making changes and
				then somehow arranging to do a load of the project in memory and avoid
				re-reading from disk ... THIS PROBABLY THE RIGHT ANSWER ... need to 
				get second and third opinions on this one ... and expand test coverage,
				I assume that there are existing tests (the extension methods in this 
				package are good clues) that have hacked some sort of behavior in this
				area, but we need a REAL solution with some logic behind it more than
				""this is how it works:)"""

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName projectDef 
		symDict registry |
	projectName := 'RowanSample1'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample1LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: gitRootPath
		registerProject: false.

	projectDef
		defaultSymbolDictName: self _symbolDictionaryName;
		yourself.

	gitRootPath := projectDef repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: self _issue_345_branch_name.

"load project"
	projectDef load.

"validation"
	self assert: (Rowan image loadedProjectNamed: projectName ifAbsent: []) notNil.

	symDict := Rowan globalNamed: self _symbolDictionaryName.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 3.
	self assert: registry classRegistry size = 2.
	self assert: registry classExtensionRegistry size = 1.
	self assert: registry methodRegistry size = 6.

"delete project"
	Rowan projectTools delete deleteProjectNamed: projectName.

"validation"
	self assert: (Rowan image loadedProjectNamed: projectName ifAbsent: []) isNil.

	symDict := Rowan globalNamed: self _symbolDictionaryName.
	registry := symDict rowanSymbolDictionaryRegistry.

	self assert: registry packageRegistry size = 0.
	self assert: registry classRegistry size = 0.
	self assert: registry classExtensionRegistry size = 0.
	self assert: registry methodRegistry size = 0.
%

category: 'tests'
method: RwRowanSample1Test
testIssue514

	"https://github.com/GemTalk/Rowan/issues/514"

	"Explicitly confirm that the property change was made and propogated to loaded project ... 
		hmmm and loaded project needs to be dirty because it doesn't match disk"

	| specUrlString projectTools rowanProject gitRootPath projectName projectDef propertyModValidationBlock
		loadedProjectDefinition diskProjectSet imageProjectSet projectSetModification project |
	projectName := 'RowanSample1'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :proj | Rowan image _removeLoadedProject: proj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample1LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: gitRootPath
		registerProject: false.

	projectDef
		defaultSymbolDictName: self _symbolDictionaryName;
		yourself.

"load project"
	projectDef load.

"validation"
	self assert: (Rowan image loadedProjectNamed: projectName ifAbsent: []) notNil.

	self assert: (Rowan globalNamed: self _symbolDictionaryName) notNil.

	project := Rowan projectNamed: projectName.
	self assert: project isDirty.	"since project not loaded from source that came from disk, it should be dirty"

"compare"
	loadedProjectDefinition := project asDefinition.
	diskProjectSet :=  loadedProjectDefinition copy readProjectSet.
	imageProjectSet := RwProjectSetDefinition new
		addProject: loadedProjectDefinition;
		yourself.
	projectSetModification :=  imageProjectSet compareAgainstBase: diskProjectSet. "new vs. old"
	self deny: projectSetModification isEmpty.

"validate that property changes are correct"
	propertyModValidationBlock := [ :propertiesModification | 
		"property modification should have a new value for gs_SymbolDictionary equal to <self _symbolDictionaryName>"
		| propertyElementsModified propertyModification |
		self deny: propertiesModification isEmpty.
		propertyElementsModified := propertiesModification elementsModified.
		self assert: propertyElementsModified size = 1.
		propertyModification := propertyElementsModified at: 'gs_SymbolDictionary'.
		self assert: propertyModification oldValue isNil.
		self assert: propertyModification newValue = self _symbolDictionaryName asString ].
	(RwSample1TestValidationVisitor new)
		defaultNoopBlock: [ self assert: false description: 'unexpected modification' ];
		changedProjectBlock: [:projectModification | self assert: projectModification propertiesModification isEmpty ];
		changedPackageBlock: [:packageModification | 
			| packageName |
			packageName := packageModification key.
			(#('RowanSample1-Extensions' 'RowanSample1-Core' 'RowanSample1-Tests' ) includes: packageName)
				ifTrue: [ 
					packageName = 'RowanSample1-Extensions'
						ifTrue: [ self assert: packageModification classesModification isEmpty ]
						ifFalse: [ self deny: packageModification classesModification isEmpty ].
					self assert: packageModification classExtensionsModification isEmpty.
					propertyModValidationBlock value: packageModification propertiesModification ]
				ifFalse: [
					self assert: packageModification propertiesModification isEmpty ] ];
		changedClassBlock: [ :classModification :visitor |
			| packageName |
			packageName := visitor currentPackageDefinition key.
			self assert: (#('RowanSample1-Core' 'RowanSample1-Tests' ) includes: packageName).
			self assert: classModification instanceMethodsModification isEmpty.
			self assert: classModification classMethodsModification isEmpty.
			propertyModValidationBlock value: classModification propertiesModification ];
		visit: projectSetModification.
%

category: 'private'
method: RwRowanSample1Test
_issue_345_branch_name

	^ 'issue_345_v2'
%

category: 'private'
method: RwRowanSample1Test
_rowanSample1LoadSpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath , '/samples/RowanSample1_v2.ston'
%

! Class implementation for 'RwRowanSample2Test'

!		Class methods for 'RwRowanSample2Test'

category: 'private'
classmethod: RwRowanSample2Test
_symbolDictionaryNames
	^ super _symbolDictionaryNames , #(#'SampleSymbolDict'  #'RowanSample2' #'RowanSample2_SD')
%

!		Instance methods for 'RwRowanSample2Test'

category: 'tests'
method: RwRowanSample2Test
testAutomaticMigration

	"load migration_1, set all of the instance variables (a-f, ivar0-ivar2), then load migration_2. after automtic migration the permanent instance variables (a-f) should retain the values, while the moved instance variables (ivar0-ivar2) should be niled out"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName instanceMap projectDef |
	projectName := 'RowanSample2'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

  	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample2SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := (self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: self _testRowanProjectsSandbox
		registerProject: false) asDefinition.

	projectDef defaultSymbolDictName: self _symbolDictionaryName.

	gitRootPath := projectDef repositoryRoot.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: self _migration_1_branchName.
	projectDef read; load.

	instanceMap := IdentityKeyValueDictionary new.
	self _migrationClassMap
		do: [ :ar | 
			| className ivs class instance |
			className := ar at: 1.
			class := Rowan globalNamed: className.
			instance := class new.
			ivs := ar at: 2.
			ivs do: [ :ivName | instance perform: ivName , ':' with: ivName ].
			instanceMap at: instance put: ar -> class ].

	gitTool gitcheckoutIn: gitRootPath with: self _migration_2_branchName.

	(Rowan projectNamed: projectName) asDefinition
		defaultSymbolDictName: self _symbolDictionaryName;
		read;
		load: RwGsInstanceMigrator aggressiveMigration.

	instanceMap
		keysAndValuesDo: [ :instance :assoc | 
			| ivNames ar oldClass className class |
			ar := assoc key.
			oldClass := assoc value.
			className := ar at: 1.
			class := Rowan globalNamed: className.
			self assert: oldClass ~= class.
			self assert: instance class == class.
			ivNames := ar at: 2.
			1 to: ivNames size do: [ :index | 
				| ivName |
				ivName := ivNames at: index.
				self assert: (instance perform: ivName) == ivName ] ]
%

category: 'tests'
method: RwRowanSample2Test
testDeferredMigration

	"load migration_1, set all of the instance variables (a-f, ivar0-ivar2), then load migration_2. after deferred migration ..."

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName 
		instanceMigrator classesToMigrate expectedClassesToMigrate projectDef |
	projectName := 'RowanSample2'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

  	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample2SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := (self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: self _testRowanProjectsSandbox
		registerProject: false) asDefinition.

	projectDef defaultSymbolDictName: self _symbolDictionaryName.

	gitRootPath := projectDef repositoryRoot.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: self _migration_1_branchName.
	projectDef  read; load.

	gitTool gitcheckoutIn: gitRootPath with: self _migration_2_branchName.
	instanceMigrator := RwGsDeferredInstanceMigrator noMigration.

	(Rowan projectNamed: projectName) asDefinition
		defaultSymbolDictName: self _symbolDictionaryName;
		read;
		load: instanceMigrator.

	classesToMigrate := (instanceMigrator classesToMigrate collect: [:each | each name ]) sort.
	expectedClassesToMigrate := (self _migrationClassMap collect: [:each | each at: 1 ]) sort.
	self assert: classesToMigrate = expectedClassesToMigrate
%

category: 'tests'
method: RwRowanSample2Test
testNoMigration

	"load migration_1, set all of the instance variables (a-f, ivar0-ivar2), then load migration_2. with no migration all of the instance variables (a-f, ivar0-ivar2) should be niled out"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName 
		instanceMap projectDef |
	projectName := 'RowanSample2'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample2SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath /projectName) ensureDeleteAll.

	projectDef := (self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: self _testRowanProjectsSandbox
		registerProject: false) asDefinition.

	projectDef defaultSymbolDictName: self _symbolDictionaryName.

	gitRootPath := projectDef repositoryRoot.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: self _migration_1_branchName.
	projectDef read; load.

	instanceMap := IdentityKeyValueDictionary new.
	self _migrationClassMap
		do: [ :ar | 
			| className ivs class instance |
			className := ar at: 1.
			class := Rowan globalNamed: className.
			instance := class new.
			ivs := ar at: 2.
			ivs do: [ :ivName | instance perform: ivName , ':' with: ivName ].
			instanceMap at: instance put: ar -> class ].

	gitTool gitcheckoutIn: gitRootPath with: self _migration_2_branchName.

	(Rowan projectNamed: projectName) asDefinition
		defaultSymbolDictName: self _symbolDictionaryName;
		read;
		load: RwGsInstanceMigrator noMigration.

	instanceMap
		keysAndValuesDo: [ :instance :assoc | 
			| ivNames ar oldClass className class |
			ar := assoc key.
			oldClass := assoc value.
			className := ar at: 1.
			class := Rowan globalNamed: className.
			self assert: oldClass ~= class.
			self assert: instance class == oldClass.
			ivNames := ar at: 2.
			1 to: ivNames size do: [ :index | 
				| ivName |
				ivName := ivNames at: index.
				self assert: (instance perform: ivName) == ivName ] ]
%

category: 'tests'
method: RwRowanSample2Test
testNoMigration_bitbucket

	"load migration_1, set all of the instance variables (a-f, ivar0-ivar2), then load migration_2. with no migration all of the instance variables (a-f, ivar0-ivar2) should be niled out"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName instanceMap projectDef |
	projectName := 'RowanSample2'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample2_bitbucketSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := (self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: self _testRowanProjectsSandbox
		registerProject: false) asDefinition.

	projectDef defaultSymbolDictName: self _symbolDictionaryName.

	gitRootPath := projectDef repositoryRoot.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: self _migration_1_branchName.
	projectDef read; load.

	instanceMap := IdentityKeyValueDictionary new.
	self _migrationClassMap
		do: [ :ar | 
			| className ivs class instance |
			className := ar at: 1.
			class := Rowan globalNamed: className.
			instance := class new.
			ivs := ar at: 2.
			ivs do: [ :ivName | instance perform: ivName , ':' with: ivName ].
			instanceMap at: instance put: ar -> class ].

	gitTool gitcheckoutIn: gitRootPath with: self _migration_2_branchName.

	(Rowan projectNamed: projectName) asDefinition
		defaultSymbolDictName: self _symbolDictionaryName;
		read;
		load.

	instanceMap
		keysAndValuesDo: [ :instance :assoc | 
			| ivNames ar oldClass className class |
			ar := assoc key.
			oldClass := assoc value.
			className := ar at: 1.
			class := Rowan globalNamed: className.
			self assert: oldClass ~= class.
			self assert: instance class == oldClass.
			ivNames := ar at: 2.
			1 to: ivNames size do: [ :index | 
				| ivName |
				ivName := ivNames at: index.
				self assert: (instance perform: ivName) == ivName ] ]
%

category: 'tests'
method: RwRowanSample2Test
testNoMigration_gitlab

	"load migration_1, set all of the instance variables (a-f, ivar0-ivar2), then load migration_2. with no migration all of the instance variables (a-f, ivar0-ivar2) should be niled out"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName projectDef instanceMap |
	projectName := 'RowanSample2'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample2_gitlabSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := (self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: self _testRowanProjectsSandbox
		registerProject: false) asDefinition.

	projectDef defaultSymbolDictName: self _symbolDictionaryName.

	gitRootPath := projectDef repositoryRoot.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: self _migration_1_branchName.
	projectDef read; load.

	instanceMap := IdentityKeyValueDictionary new.
	self _migrationClassMap
		do: [ :ar | 
			| className ivs class instance |
			className := ar at: 1.
			class := Rowan globalNamed: className.
			instance := class new.
			ivs := ar at: 2.
			ivs do: [ :ivName | instance perform: ivName , ':' with: ivName ].
			instanceMap at: instance put: ar -> class ].

	gitTool gitcheckoutIn: gitRootPath with: self _migration_2_branchName.

	(Rowan projectNamed: projectName) asDefinition
		defaultSymbolDictName: self _symbolDictionaryName;
		read;
		load.

	instanceMap
		keysAndValuesDo: [ :instance :assoc | 
			| ivNames ar oldClass className class |
			ar := assoc key.
			oldClass := assoc value.
			className := ar at: 1.
			class := Rowan globalNamed: className.
			self assert: oldClass ~= class.
			self assert: instance class == oldClass.
			ivNames := ar at: 2.
			1 to: ivNames size do: [ :index | 
				| ivName |
				ivName := ivNames at: index.
				self assert: (instance perform: ivName) == ivName ] ]
%

category: 'tests'
method: RwRowanSample2Test
testNoMigration_gitolite

	"load migration_1, set all of the instance variables (a-f, ivar0-ivar2), then load migration_2. with no migration all of the instance variables (a-f, ivar0-ivar2) should be niled out"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName projectDef instanceMap |
	projectName := 'RowanSample2'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample2_gitoliteSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := (self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: self _testRowanProjectsSandbox
		registerProject: false) asDefinition.

	projectDef defaultSymbolDictName: self _symbolDictionaryName.

	gitRootPath := projectDef repositoryRoot.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: self _migration_1_branchName.
	projectDef read; load.

	instanceMap := IdentityKeyValueDictionary new.
	self _migrationClassMap
		do: [ :ar | 
			| className ivs class instance |
			className := ar at: 1.
			class := Rowan globalNamed: className.
			instance := class new.
			ivs := ar at: 2.
			ivs do: [ :ivName | instance perform: ivName , ':' with: ivName ].
			instanceMap at: instance put: ar -> class ].

	gitTool gitcheckoutIn: gitRootPath with: self _migration_2_branchName.

	(Rowan projectNamed: projectName) asDefinition
		defaultSymbolDictName: self _symbolDictionaryName;
		read;
		load.

	instanceMap
		keysAndValuesDo: [ :instance :assoc | 
			| ivNames ar oldClass className class |
			ar := assoc key.
			oldClass := assoc value.
			className := ar at: 1.
			class := Rowan globalNamed: className.
			self assert: oldClass ~= class.
			self assert: instance class == oldClass.
			ivNames := ar at: 2.
			1 to: ivNames size do: [ :index | 
				| ivName |
				ivName := ivNames at: index.
				self assert: (instance perform: ivName) == ivName ] ]
%

category: 'tests'
method: RwRowanSample2Test
testRemoveSubclassOfClassWithNewVersion

	"#RowanSample2 project
		## branch migration_1
			class structure:
				RowanSample2
				    instVarNames: #( ivar0)
				 RowanSample2A
				    instVarNames: #( a ivar1)
				  RowanSample2C
				    instVarNames: #( c ivar2)
				  RowanSample2D
				    instVarNames: #( d ivar2)
				 RowanSample2B
				    instVarNames: #( b ivar1)
				  RowanSample2E
				    instVarNames: #( e ivar2)
				  RowanSample2F
				    instVarNames: #( f ivar2)
		## branch migration_0
			class structure:
				RowanSample2
"

	"load migration_1, then load migration_0 (new version of RowanSample2 and all subclasses deleted"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName rowanSample2Class 
		subclasses projectDef |
	projectName := 'RowanSample2'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample2SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := (self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: gitRootPath
		registerProject: false) asDefinition.

	projectDef defaultSymbolDictName: self _symbolDictionaryName.

	gitRootPath := projectDef repositoryRoot.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: self _migration_1_branchName.
	projectDef read; load.

	rowanSample2Class := Rowan globalNamed: 'RowanSample2'.
	subclasses := ClassOrganizer new allSubclassesOf: rowanSample2Class.
	self assert: subclasses size = 6.

	gitTool gitcheckoutIn: gitRootPath with: self _migration_0_branchName.

	(Rowan projectNamed: projectName) asDefinition
		defaultSymbolDictName: self _symbolDictionaryName;
		read;
		load: RwGsInstanceMigrator aggressiveMigration.

	rowanSample2Class := Rowan globalNamed: 'RowanSample2'.
	subclasses := ClassOrganizer new allSubclassesOf: rowanSample2Class.
	self assert: subclasses size = 0
%

category: 'tests'
method: RwRowanSample2Test
testSampleDefaultConfiguration

	"SampleDefault configuration is an instance of RwProjectConfiguration"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x projectDef |
	projectName := 'RowanSample2'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample2SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := (self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: gitRootPath
		registerProject: false) asDefinition.

	projectDef defaultSymbolDictName: self _symbolDictionaryName.

	gitRootPath := projectDef repositoryRoot.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with:  self _migration_0_branchName.
	projectDef read; load.

	project := RwProject newNamed: projectName.
	self assert: (x := project packageNames) = #('RowanSample2-Core')
%

category: 'private'
method: RwRowanSample2Test
_migrationClassMap

	^ {#(#'RowanSample2' #(#'ivar0')).
	#(#'RowanSample2A' #(#'ivar0' #'a' #'ivar1')).
	#(#'RowanSample2C' #(#'ivar0' #'a' #'ivar1' #'c' #'ivar2')).
	#(#'RowanSample2D' #(#'ivar0' #'a' #'ivar1' #'d' #'ivar2')).
	#(#'RowanSample2B' #(#'ivar0' #'b' #'ivar1')).
	#(#'RowanSample2E' #(#'ivar0' #'b' #'ivar1' #'e' #'ivar2')).
	#(#'RowanSample2F' #(#'ivar0' #'b' #'ivar1' #'f' #'ivar2'))}
%

! Class implementation for 'RwRowanSample4Test'

!		Class methods for 'RwRowanSample4Test'

category: 'private'
classmethod: RwRowanSample4Test
_symbolDictionaryNames

	^ 	super _symbolDictionaryNames, 
			#( #'RowanSample4SymbolDict' #'RowanSample4DictionarySymbolDict' #'RowanSample4DictionarySymbolDict_295'
					#'RowanSample4DictionarySymbolDict_295_3' #'SampleSymbolDict')
%

!		Instance methods for 'RwRowanSample4Test'

category: 'running'
method: RwRowanSample4Test
setUp

	super setUp.
	Transcript cr; show: self printString
%

category: 'tests'
method: RwRowanSample4Test
testCreateProjectDefinition

	| specUrlString projectTools rowanProject gitRootPath projectName projectDefinition x |
	projectName := 'RowanSample4'.
	Rowan
		projectNamed: projectName 
		ifPresent: [:prj | Rowan image _removeLoadedProject: prj _loadedProject ].
	Rowan 
		projectNamed: projectName 
		ifPresent: [ :prj | self error: 'The project ', projectName printString, ' should not be loaded' ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	"attach a project definition to the Rowan project on disk ... not loaded and not registered"
	projectDefinition := self _cloneAndCreateProjectDefinitionFromSpecUrl: specUrlString projectRootPath: gitRootPath / projectName.

	self assert: (projectDefinition projectDefinitionSourceProperty = RwLoadedProject _projectDiskDefinitionSourceValue).

	self assert: (x := projectDefinition packageNames asArray sort) = #('RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-GemStone' 'RowanSample4-GemStone-Tests' 'RowanSample4-Tests') sort.

	Rowan 
		projectNamed: projectName 
			ifPresent: [:project | self assert: false description: 'The project ', projectName printString. ' is not expected to be loaded.' ].
%

category: 'tests'
method: RwRowanSample4Test
testCreateProjectFromUrl

	| specUrlString projectTools projectName |
	projectName := 'RowanSample4'.
	Rowan
		projectNamed: projectName 
		ifPresent: [:prj | Rowan image _removeLoadedProject: prj _loadedProject ].
	Rowan 
		projectNamed: projectName 
		ifPresent: [ :prj | self error: 'The project ', projectName printString, ' should not be loaded' ].

	specUrlString := self _rowanSample4SpecificationUrl.
	projectTools := Rowan projectTools.

	self _createProjectDefinitionFromSpecUrl: specUrlString projectName: projectName.

	self assert: (Rowan image loadedProjectNamed: projectName ifAbsent: []) notNil.

	projectTools load loadProjectNamed: projectName.

	Rowan 
		projectNamed: projectName 
			ifPresent: [:project | "noop" ]
			ifAbsent: [ self assert: false description: 'expected project ', projectName printString, ' to be loaded' ].
%

category: 'tests'
method: RwRowanSample4Test
testIssue14

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project 
		x repoRootPath theClass constraint |
	projectName := 'RowanSample4'.
	Rowan
		projectNamed: projectName 
		ifPresent: [:prj | Rowan image _removeLoadedProject: prj _loadedProject ].
	Rowan 
		projectNamed: projectName 
		ifPresent: [ :prj | self error: 'The project ', projectName printString, ' should not be loaded' ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	repoRootPath := (Rowan projectNamed: projectName) repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_231_0'.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	project := RwProject newNamed: projectName.
	self
		assert:
			(x := project packageNames asArray sort)
				= #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 'RowanSample4-GemStone-Tests') sort.

	self assert: (x := project loadedGroupNames asArray) = #('tests').
	self assert: (x := project loadedConfigurationNames asArray) = #('Load').

	theClass := Rowan globalNamed: 'RowanSample4'.
	self assert: (x := theClass _constraintOn: #instvar1) = Integer.
	self assert: (x := theClass _constraintOn: #instvar2) = Array.
	self assert: (x := theClass _constraintOn: #instvar3) = Boolean.
	self assert: (x := theClass _constraintOn: #instvar4) = Array.

	theClass := Rowan globalNamed: 'RowanSample4IdentityBag'.
	constraint := theClass _varyingConstraint.
	self assert: constraint = String.
%

category: 'tests'
method: RwRowanSample4Test
testIssue185_move_class_to_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/185"

	"issue_185_1 --> issue_185_3	:: move NewRowanSample4 class to RowanSample4SymbolDict symbol dictionary (no package rename)"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar |

	projectName := 'RowanSample4'.
	Rowan
		projectNamed: projectName 
		ifPresent: [:prj | Rowan image _removeLoadedProject: prj _loadedProject ].
	Rowan 
		projectNamed: projectName 
		ifPresent: [ :prj | self error: 'The project ', projectName printString, ' should not be loaded' ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_3'.				"Move NewRowanSample4 class to RowanSample4SymbolDict"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4SymbolDict'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testIssue185_move_newClassVariable_to_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/185"

	"issue_185_1 --> issue_185_7	:: move NewRowanSample4 class with new class var to RowanSample4SymbolDict symbol dictionary (no package rename)"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar oldClass |

	projectName := 'RowanSample4'.
	Rowan
		projectNamed: projectName 
		ifPresent: [:prj | Rowan image _removeLoadedProject: prj _loadedProject ].
	Rowan 
		projectNamed: projectName 
		ifPresent: [ :prj | self error: 'The project ', projectName printString, ' should not be loaded' ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	project := RwProject newNamed: projectName.
	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_7'.				"move NewRowanSample4 class with new class var to RowanSample4SymbolDict symbol dictionary (no package rename)"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	oldClass := newClass.
	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: oldClass == newClass.
	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4SymbolDict'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testIssue185_move_newClassVersion_to_symbolDict

	"https://github.com/dalehenrich/Rowan/issues/185"

	"issue_185_1 --> issue_185_5	:: move new version NewRowanSample4 class to RowanSample4SymbolDict symbol dictionary (no package rename)"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar oldClass |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_5'.				"Move new version of NewRowanSample4 class to RowanSample4SymbolDict"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	oldClass := newClass.
	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: oldClass ~~ newClass.
	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4SymbolDict'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testIssue185_rename_package_move_class

	"https://github.com/dalehenrich/Rowan/issues/185"

	"issue_185_1 --> issue_185_2	:: rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
													move NewRowanSample4 to RowanSample4SymbolDict"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_2'.				"Rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
																								move NewRowanSample4 to RowanSample4SymbolDict"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4SymbolDict'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testIssue185_rename_package_move_classVariable

	"https://github.com/dalehenrich/Rowan/issues/185"

	"issue_185_1 --> issue_185_8	:: rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
													move NewRowanSample4 with new class variable to RowanSample4SymbolDict"

	| specUrlString projectTools gitTool rowanProject gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_8'.				"Rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
																								move NewRowanSample4 with new class variable to RowanSample4SymbolDict"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4SymbolDict'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testIssue185_rename_package_move_newClassVersion

	"https://github.com/dalehenrich/Rowan/issues/185"

	"issue_185_1 --> issue_185_6	:: rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
													move new version of NewRowanSample4 to RowanSample4SymbolDict"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar oldClass |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_6'.				"Rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
																								move new version of NewRowanSample4 to RowanSample4SymbolDict"
	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	oldClass := newClass.
	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: oldClass ~~ newClass.
	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4SymbolDict'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testIssue185_simple_package_rename

	"https://github.com/dalehenrich/Rowan/issues/185"

	"issue_185_1 --> issue_185_4	:: Simply rename RowanSample4-NewPackage to RowanSample4-RenamedPackage (no symbol dictionary move)"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	self assert: (x := newClass rowanPackageName) = 'RowanSample4-NewPackage'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_4'.				"Simply rename RowanSample4-NewPackage to RowanSample4-RenamedPackage (no symbol dictionary move)"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4DictionarySymbolDict'.

	self assert: (x := newClass rowanPackageName) = 'RowanSample4-RenamedPackage'.

	self deny: ((Rowan globalNamed: 'RowanSample4SymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testIssue208_adopt_load

	"https://github.com/dalehenrich/Rowan/issues/208"

	"Using non-Rowan api, create the classes in the appropriate symbol dictionaries, adopt into Primer project, then load branch issue_208_0 ...
		the primer project should be empty"

		"Create classes in a couple of symbol dictionaries"
		"Create and load the primer project ... with two packages (one for each symbol dictionary) into which the classes will be adopted"
		"Adopt the classes into the primer project"
		"load the RowanSample4 project from disk - overly the correct project structure over the primer project classes"
		"validate that the primer project packages are empty"

	| primerProjectName specUrlString projectTools rowanProject gitTool gitRootPath projectName project repoRootPath symDictName1 
		symDictName2 symDict theClass instanceMethod classMethod symbolList projectDefinition primerPackageName1 primerPackageName2 
		loadedPrimerProject |

	projectTools := Rowan projectTools.
	primerProjectName := 'PrimerSample4'.
	symDictName1 := 'RowanSample4SymbolDict'.
	symDictName2 := 'RowanSample4DictionarySymbolDict'.
	primerPackageName1 := primerProjectName, '-', symDictName1.
	primerPackageName2 := primerProjectName, '-', symDictName2.
	projectName := 'RowanSample4'.
	symbolList := Rowan image symbolList.

	{ primerProjectName. projectName} 
		do: [:pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
					ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	"Create classes in a couple of symbol dictionaries"
	symDict := Rowan image newOrExistingSymbolDictionaryNamed: symDictName1.
	theClass := Object subclass: 'RowanSample4'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().
	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	symDict := Rowan image newOrExistingSymbolDictionaryNamed: symDictName2.
	theClass := IdentityKeyValueDictionary
		subclass: 'RowanSample4IdentityKeyValueDictionary'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().
	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	"Create and load the primer project ... with two packages (one for each symbol dictionary) into which the classes will be adopted"
	projectDefinition := RwProjectDefinition
		newForGitBasedProjectNamed: primerProjectName.
	projectDefinition
		addPackageNamed: primerPackageName1;
		addPackageNamed: primerPackageName2;
		setSymbolDictName: symDictName1 forPackageNamed: primerPackageName1;
		setSymbolDictName: symDictName2 forPackageNamed: primerPackageName2;
		defaultSymbolDictName: self _symbolDictionaryName1.
	projectTools load loadProjectDefinition: projectDefinition.

	"Adopt the classes into the primer project"
	Rowan packageTools adopt
		adoptSymbolDictionaryNamed: symDictName1 intoPackageNamed: primerPackageName1;
		adoptSymbolDictionaryNamed: symDictName2 intoPackageNamed: primerPackageName2.

	"load the RowanSample4 project from disk - overly the correct project structure over the primer project classes"
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4_208_LoadSpecificationUrl.
	gitRootPath := self _testRowanProjectsSandbox.
	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_208_0'.	

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	"validate that the primer project packages are empty"
	loadedPrimerProject := Rowan image loadedProjectNamed: primerProjectName.
	loadedPrimerProject loadedPackages 
		do: [:loadedPackage |
			self assert: loadedPackage isEmpty ].

	self assert: loadedPrimerProject isDirty.
	self deny: (Rowan image loadedProjectNamed: projectName) isDirty
%

category: 'tests'
method: RwRowanSample4Test
testIssue210

	"https://github.com/dalehenrich/Rowan/issues/210"

	"based on testIssue208_adopt_load"

	| primerProjectName specUrlString projectTools rowanProject gitTool gitRootPath projectName project repoRootPath symDictName1 
		symDictName2 symDict theClass instanceMethod classMethod symbolList projectDefinition primerPackageName1 primerPackageName2 |

	projectTools := Rowan projectTools.
	primerProjectName := 'PrimerSample4'.
	symDictName1 := 'RowanSample4SymbolDict'.
	symDictName2 := 'RowanSample4DictionarySymbolDict'.
	primerPackageName1 := primerProjectName, '-', symDictName1.
	primerPackageName2 := primerProjectName, '-', symDictName2.
	projectName := 'RowanSample4'.
	symbolList := Rowan image symbolList.

	{ primerProjectName. projectName} 
		do: [:pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
					ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	"Create classes in a couple of symbol dictionaries"
	symDict := Rowan image newOrExistingSymbolDictionaryNamed: symDictName1.
	theClass := Object subclass: 'RowanSample4'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().
	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	symDict := Rowan image newOrExistingSymbolDictionaryNamed: symDictName2.
	theClass := IdentityKeyValueDictionary
		subclass: 'RowanSample4IdentityKeyValueDictionary'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().
	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	"Create and load the primer project ... with two packages into which the classes will be adopted"
	projectDefinition := RwProjectDefinition
		newForGitBasedProjectNamed: primerProjectName.
	projectDefinition
		addPackageNamed: primerPackageName1;
		addPackageNamed: primerPackageName2;
		setSymbolDictName: symDictName1 forPackageNamed: primerPackageName1;
		setSymbolDictName: symDictName2 forPackageNamed: primerPackageName2;
		defaultSymbolDictName: self _symbolDictionaryName1.
	projectTools load loadProjectDefinition: projectDefinition.

	"Adopt the classes into the primer project"
	Rowan packageTools adopt
		adoptSymbolDictionaryNamed: symDictName1 intoPackageNamed: primerPackageName1;
		adoptSymbolDictionaryNamed: symDictName2 intoPackageNamed: primerPackageName2.

	"now load the RowanSample4 project from disk"
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4_208_LoadSpecificationUrl.
	gitRootPath := self _testRowanProjectsSandbox.
	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_208_0'.	

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.
%

category: 'tests'
method: RwRowanSample4Test
testIssue230

	"This test is also important for validating the fix to Issue #504:
		https://github.com/GemTalk/Rowan/issues/504#issuecomment-530599164
		At least confirm that it is NOT a good candidate, since this test is now failing
		with the new error introduced in the partial for for Issue #504"
	"https://github.com/dalehenrich/Rowan/issues/230"

	"new class version for class being loaded in after adopt --- initial RowanSample4 class created with instancesInvariant option, 
		so we get new version when class is loaded from disk"

	| primerProjectName specUrlString projectTools rowanProject gitTool gitRootPath projectName project repoRootPath symDictName1 
		symDictName2 symDict theClass instanceMethod classMethod symbolList projectDefinition primerPackageName1 primerPackageName2 |

	projectTools := Rowan projectTools.
	primerProjectName := 'PrimerSample4'.
	symDictName1 := 'RowanSample4SymbolDict'.
	symDictName2 := 'RowanSample4DictionarySymbolDict'.
	primerPackageName1 := primerProjectName, '-', symDictName1.
	primerPackageName2 := primerProjectName, '-', symDictName2.
	projectName := 'RowanSample4'.
	symbolList := Rowan image symbolList.

	{ primerProjectName. projectName} 
		do: [:pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
					ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	"Create classes in a couple of symbol dictionaries"
	symDict := Rowan image newOrExistingSymbolDictionaryNamed: symDictName1.
	theClass := Object subclass: 'RowanSample4'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #(instancesInvariant).
	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.
	classMethod := theClass class
		compileMethod: 'bar ^''bar'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	symDict := Rowan image newOrExistingSymbolDictionaryNamed: symDictName2.
	theClass := IdentityKeyValueDictionary
		subclass: 'RowanSample4IdentityKeyValueDictionary'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		inDictionary: symDict
		options: #().
	instanceMethod := theClass
		compileMethod: 'foo ^''foo'''
		dictionaries: symbolList
		category: 'accessing'
		environmentId: 0.

	"Create and load the primer project ... with two packages into which the classes will be adopted"
	projectDefinition := RwProjectDefinition
		newForGitBasedProjectNamed: primerProjectName.
	self assert: (projectDefinition projectDefinitionSourceProperty = RwLoadedProject _projectUnknownDefinitionSourceValue).
	projectDefinition
		addPackageNamed: primerPackageName1;
		addPackageNamed: primerPackageName2;
		setSymbolDictName: symDictName1 forPackageNamed: primerPackageName1;
		setSymbolDictName: symDictName2 forPackageNamed: primerPackageName2;
		defaultSymbolDictName: self _symbolDictionaryName1.
	projectTools load loadProjectDefinition: projectDefinition.

	"Adopt the classes into the primer project"
	Rowan packageTools adopt
		adoptSymbolDictionaryNamed: symDictName1 intoPackageNamed: primerPackageName1;
		adoptSymbolDictionaryNamed: symDictName2 intoPackageNamed: primerPackageName2.

	"now load the RowanSample4 project from disk"
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4_208_LoadSpecificationUrl.
	gitRootPath := self _testRowanProjectsSandbox.
	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_208_0'.	

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.
%

category: 'tests'
method: RwRowanSample4Test
testIssue284

	"https://github.com/dalehenrich/Rowan/issues/284"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project repoRootPath loadedCommitId |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	loadedCommitId := project loadedCommitId.
	self assert: loadedCommitId = '0f7683b'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_284_0'.				"README commit"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	loadedCommitId := project loadedCommitId.
	self assert: loadedCommitId = '8a4a450'
%

category: 'tests'
method: RwRowanSample4Test
testIssue295_rename_package_move_newClassVersion_newProject_1

	"This test is also important for validating the fix to Issue #504:
		https://github.com/GemTalk/Rowan/issues/504#issuecomment-530599164
		At least confirm that it is NOT a good candidate, since this test is now failing
		with the new error introduced in the partial for for Issue #504"

	"https://github.com/dalehenrich/Rowan/issues/295"

	"Error creating a new class version while moving to a new package in a new project and a new symbol dictionary"

	"issue_295_1 --> issue_295_2	:: rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
													move new version of NewRowanSample4 to RowanSample4SymbolDict in new project"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar oldClass |

	projectName := 'RowanSample4'.
	{ projectName . projectName, '_295'} do: [:pn |
		(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
			ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_2'.				"Rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
																								move new version of NewRowanSample4 to RowanSample4SymbolDict"
"trigger the bug on this load"
	specUrlString := self _rowanSample4LoadSpecificationUrl_295.
	self
		_loadProjectFromSpecUrl: specUrlString
		repoRootPath: repoRootPath.

	oldClass := newClass.
	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: oldClass ~~ newClass.
	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4DictionarySymbolDict_295'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4').
	project unload.
	(Rowan projectNamed: projectName, '_295') unload
%

category: 'tests'
method: RwRowanSample4Test
testIssue295_rename_package_move_newClassVersion_with_subclass_newProject

	"attempting to reproduce the actual issue (_1 doesn't reproduce problem, but should remain static to ensure behavior does not change detrimentally"

	"https://github.com/dalehenrich/Rowan/issues/295"

	"Error creating a new class version of a superclass while moving to a new package in a new project and a new symbol dictionary"

	"issue_295_4 --> issue_295_5	:: rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
													move new version of NewRowanSample4  with subclass to RowanSample4SymbolDict in new project"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar oldClass projectDefinition projectSetDefinition oldProjectDefinition |

	projectName := 'RowanSample4'.
	{ projectName . projectName, '_295'} do: [:pn |
		(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
			ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_4'.				"New package added to the project, along with a subclass of NewRowanSample4"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_5'.				"Rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
																								move new version of NewRowanSampleSubclass4 to RowanSample4SymbolDict"
"trigger the bug on this load"
	specUrlString := self _rowanSample4LoadSpecificationUrl_295.

"need to add old project definition with all classes and extensions removed to the projectSet Definition to reproduce bug"
	projectSetDefinition := self _projectDefinitionFromSpecUrl: specUrlString projectRootPath: repoRootPath.
	projectDefinition := projectSetDefinition projectNamed: projectName, '_295'.

	self assert: (projectDefinition projectDefinitionSourceProperty = RwLoadedProject _projectDiskDefinitionSourceValue).

oldProjectDefinition := (Rowan image loadedProjectNamed: 'RowanSample4') asDefinition.
projectSetDefinition addProject: oldProjectDefinition.

	oldProjectDefinition packages values do: [:pkgDefinition |
	    pkgDefinition classDefinitions values do: [:classDefinition |
	        pkgDefinition removeClassDefinition: classDefinition ].
	    pkgDefinition classExtensions values do: [:classExtension |
        	pkgDefinition removeClassExtensionDefinition: classExtension ]].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.
	Rowan projectTools load markProjectSetNotDirty: projectSetDefinition.


	oldClass := newClass.
	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: oldClass ~~ newClass.
	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4DictionarySymbolDict_295_3'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testIssue304

	"https://github.com/dalehenrich/Rowan/issues/304"

	"load a different config and group using the spec url load api ... SHA needs to change as well"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project repoRootPath 
		x masterBranchSHA |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_302'.				"no tests loaded"

	self 
		_loadProjectFromSpecUrl: (self _rowanSample4_coreSpecificationUrl: repoRootPath)
		repoRootPath: repoRootPath.

	self assert: (Rowan globalNamed: 'RowanSample4Test') isNil.

	masterBranchSHA := 'ea371eb'.

	self assert: (x := project loadedConfigurationNames) asArray = #('Load').
	self assert: (x := project loadedGroupNames) asArray = #('core').
	self deny: (x := project loadedCommitId) = masterBranchSHA.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: masterBranchSHA.

"now load tests group"
	self 
		_loadProjectFromSpecUrl: (self _rowanSample4_loadSpecificationUrl: repoRootPath)
		repoRootPath: repoRootPath.
"
	projectTools load
		loadProjectFromSpecUrl: 'file:' , repoRootPath pathString, '/rowan/specs/RowanSample4_load.ston'.
"

	self assert: (Rowan globalNamed: 'RowanSample4Test') notNil.
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').
	self assert: (x := project  loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedCommitId) = masterBranchSHA.
%

category: 'tests'
method: RwRowanSample4Test
testIssue305

	"https://github.com/dalehenrich/Rowan/issues/305"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project repoRootPath |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.
	self assert: (Rowan globalNamed: 'RowanSample4Test') notNil.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_302'.				"useful spec --- no tests group"

	self 
		_loadProjectFromSpecUrl: (self _rowanSample4_coreSpecificationUrl: repoRootPath)
		repoRootPath: repoRootPath.

	self assert: (Rowan globalNamed: 'RowanSample4Test') isNil.
%

category: 'tests'
method: RwRowanSample4Test
testIssue460_1

	"https://github.com/dalehenrich/Rowan/issues/260"

	"Error creating a new class version of a superclass while moving to a new package in a new project and a new symbol dictionary"

	"issue_295_6 --> issue_295_5	:: rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
													move new version of NewRowanSample4  with subclass (and method) to RowanSample4SymbolDict in new project"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar oldClass projectDefinition projectSetDefinition oldProjectDefinition |

	projectName := 'RowanSample4'.
	{ projectName . projectName, '_295'} do: [:pn |
		(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
			ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_6'.				"New package added to the project, along with a subclass of NewRowanSample4 with method"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_5'.				"Rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
																								move new version of NewRowanSampleSubclass4 to RowanSample4SymbolDict"
"trigger the bug on this load"
	specUrlString := self _rowanSample4LoadSpecificationUrl_295.

"need to add old project definition with all classes and extensions removed to the projectSet Definition to reproduce bug"
	projectSetDefinition := self _projectDefinitionFromSpecUrl: specUrlString projectRootPath: repoRootPath.
	projectDefinition := projectSetDefinition projectNamed: projectName, '_295'.

	self assert: (projectDefinition projectDefinitionSourceProperty = RwLoadedProject _projectDiskDefinitionSourceValue).

oldProjectDefinition := (Rowan image loadedProjectNamed: 'RowanSample4') asDefinition.
projectSetDefinition addProject: oldProjectDefinition.

	oldProjectDefinition packages values do: [:pkgDefinition |
	    pkgDefinition classDefinitions values do: [:classDefinition |
	        pkgDefinition removeClassDefinition: classDefinition ].
	    pkgDefinition classExtensions values do: [:classExtension |
        	pkgDefinition removeClassExtensionDefinition: classExtension ]].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.
	Rowan projectTools load markProjectSetNotDirty: projectSetDefinition.


	oldClass := newClass.
	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: oldClass ~~ newClass.
	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4DictionarySymbolDict_295_3'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testIssue460_2

	"As of today the test is passing, so it's not a candidate for Issue #504"

	"https://github.com/dalehenrich/Rowan/issues/260"

	"Error creating a new class version of a superclass while moving to a new package in a new project and a new symbol dictionary"

	"issue_295_6 --> issue_295_7	:: rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
													move new version of NewRowanSample4  with subclass (and method) to RowanSample4SymbolDict in new project"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar oldClass projectDefinition projectSetDefinition oldProjectDefinition subclass |

	projectName := 'RowanSample4'.
	{ projectName . projectName, '_295'} do: [:pn |
		(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
			ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox pathString.

	(Rowan fileUtilities directoryExists: gitRootPath , projectName)
		ifTrue: [ Rowan fileUtilities deleteAll: gitRootPath , projectName ].

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames)asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_6'.				"New package added to the project, along with a subclass of NewRowanSample4 with method"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_7'.				"Rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
																								move new version of NewRowanSampleSubclass4 to RowanSample4SymbolDict"
"trigger the bug on this load"
	specUrlString := self _rowanSample4LoadSpecificationUrl_295.

"need to add old project definition with all classes and extensions removed to the projectSet Definition to reproduce bug"
	projectSetDefinition := self _projectDefinitionFromSpecUrl: specUrlString projectRootPath: repoRootPath.
	projectDefinition := projectSetDefinition projectNamed: projectName, '_295'.

	self assert: (projectDefinition projectDefinitionSourceProperty = RwLoadedProject _projectDiskDefinitionSourceValue).

oldProjectDefinition := (Rowan image loadedProjectNamed: 'RowanSample4') asDefinition.
projectSetDefinition addProject: oldProjectDefinition.

	oldProjectDefinition packages values do: [:pkgDefinition |
	    pkgDefinition classDefinitions values do: [:classDefinition |
	        pkgDefinition removeClassDefinition: classDefinition ].
	    pkgDefinition classExtensions values do: [:classExtension |
        	pkgDefinition removeClassExtensionDefinition: classExtension ]].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.
	Rowan projectTools load markProjectSetNotDirty: projectSetDefinition.


	oldClass := newClass.
	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: oldClass ~~ newClass.
	self assert: (newClass new perform: #foo) = 'foo'.

	subclass := Rowan globalNamed: 'NewRowanSampleSubclass4'.
	self assert: (subclass new perform: #foo) = 'foo'.
	self assert: (subclass perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4DictionarySymbolDict_295_3'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testIssue490_rename_package_move_newClassVersion_newProject_1

	"https://github.com/dalehenrich/Rowan/issues/490"

	"extension package that should have been emptied when loading a new project that is taking over management of the classes and axtensions methods"

	"issue_295_1 --> issue_295_2	:: rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
													move new version of NewRowanSample4 to RowanSample4SymbolDict in new project"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar oldClass audit |

	projectName := 'RowanSample4'.
	{ projectName . projectName, '_295'} do: [:pn |
		(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
			ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_2'.				"Rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
																								move new version of NewRowanSample4 to RowanSample4SymbolDict"
"trigger the bug on this load"
	specUrlString := self _rowanSample4LoadSpecificationUrl_295.
	self
		_loadProjectFromSpecUrl: specUrlString
		repoRootPath: repoRootPath.

"expose bug"
	self assert: (audit := Rowan projectTools audit auditForProjectNamed: projectName) isEmpty.

	self assert: (((Rowan image loadedProjectNamed: projectName)
	loadedPackages at: 'RowanSample4-Extensions')
		loadedClassExtensions isEmpty).

	oldClass := newClass.
	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: oldClass ~~ newClass.
	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4DictionarySymbolDict_295'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: 'tests'
method: RwRowanSample4Test
testLoadProjectFromUrl_1

	| specUrlString projectTools rowanProject gitRootPath projectName projectRootPath projectSetDefinition
		projectDefinition theClass |
	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath registerProject: false.

	projectRootPath := gitRootPath / projectName.
	projectSetDefinition := self 
		_projectDefinitionFromSpecUrl: (self _rowanSample4_loadSpecificationUrl: projectRootPath)
		projectRootPath: projectRootPath.

	projectDefinition := projectSetDefinition projectNamed: projectName.
	projectDefinition register.

	self assert: (projectDefinition projectDefinitionSourceProperty = RwLoadedProject _projectDiskDefinitionSourceValue).

	projectTools load loadProjectNamed: projectName.

	theClass := Rowan globalNamed: 'RowanSample4'.

	self assert: (theClass new perform: #foo) = 'foo'
%

category: 'tests'
method: RwRowanSample4Test
testLoadProjectFromUrl_2

	| specUrlString projectTools rowanProject gitRootPath projectName projectRootPath theClass x |
	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath registerProject: false.

"load project into stone"
	projectRootPath := gitRootPath / projectName.
	self 
		_loadProjectFromSpecUrl: (self _rowanSample4_loadSpecificationUrl: projectRootPath)
		repoRootPath: projectRootPath.

	self assert: (x := (Rowan projectNamed: projectName) loadedCommitId) = 'fb3fdc5'.

	theClass := Rowan globalNamed: 'RowanSample4'.

	self assert: (theClass new perform: #foo) = 'foo'
%

category: 'tests'
method: RwRowanSample4Test
testLoadProjectFromUrl_300_1

	"https://github.com/dalehenrich/Rowan/issues/300"

	"validation for testLoadProjectFromUrl_300_1, that a non-symbolic link clone/load works"

	| specUrlString projectTools rowanProject gitRootPath projectName projectRootPath theClass |
	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath registerProject: false.

"load project into stone"
	projectRootPath := gitRootPath / projectName.
	self 
		_loadProjectFromSpecUrl: (self _rowanSample4_loadSpecificationUrl: projectRootPath)
		repoRootPath: projectRootPath.

	theClass := Rowan globalNamed: 'RowanSample4'.

	self assert: (theClass new perform: #foo) = 'foo'
%

category: 'tests'
method: RwRowanSample4Test
testLoadProjectFromUrl_300_2

	"https://github.com/dalehenrich/Rowan/issues/300"

	"regression test for bug ... mixed symbolic link and absolute path referencing same git repository"

	| specUrlString projectTools rowanProject gitRootPath projectName theClass commandLine
		symLinkName gitRootPath_symLink repoRootPath |
	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath_symLink  := self _testRowanProjectsSandbox pathString, '/rowan_issue_300/'.
	gitRootPath :=  self _testRowanProjectsSandbox / 'issue_300_dir/'.

	commandLine := 'set -e;  rm -rf ', gitRootPath pathString.
	Rowan gitTools performOnServer: commandLine logging: true.

	commandLine := 'set -e;  rm -rf ', gitRootPath_symLink.
	Rowan gitTools performOnServer: commandLine logging: true.

"clone project to make sure that we have an existing git project"
	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath registerProject: false.

	self assert: (gitRootPath / projectName) exists.

"create symbolic link..."
	symLinkName := 'issue_300_symLink'.
	commandLine := 'set -e;  cd ' , gitRootPath pathString, '; mkdir ', gitRootPath_symLink, '; ln -s ', gitRootPath pathString , ' ', gitRootPath_symLink, '/', symLinkName.
	Rowan gitTools performOnServer: commandLine logging: true.

"...and now run clone again using symbolic link" 
	self
		_cloneProjectFromSpecUrl_300: specUrlString 
		projectsHome: gitRootPath_symLink, '/', symLinkName 
		registerProject: true.

"load project into stone"
	repoRootPath := gitRootPath / projectName.
	self 
		_loadProjectFromSpecUrl: (self _rowanSample4_loadSpecificationUrl: repoRootPath) 
		repoRootPath: repoRootPath.

	theClass := Rowan globalNamed: 'RowanSample4'.

	self assert: (theClass new perform: #foo) = 'foo'.
%

category: 'tests'
method: RwRowanSample4Test
testLoadProjectFromUrl_issue180

	"https://github.com/dalehenrich/Rowan/issues/180"

	| specUrlString projectTools rowanProject gitRootPath projectName projectRootPath |
	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

		(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath registerProject: false.

"load project into stone"
	projectRootPath := gitRootPath / projectName.
	self 
		_loadProjectFromSpecUrl: (self _rowanSample4_loadSpecificationUrl: projectRootPath)
		repoRootPath: projectRootPath.

	"load project into stone, again ... should be legal"
	self 
		_loadProjectFromSpecUrl: (self _rowanSample4_loadSpecificationUrl: projectRootPath)
		repoRootPath: projectRootPath.
%

category: 'tests'
method: RwRowanSample4Test
testLoadProjectNamed_221B

	"https://github.com/dalehenrich/Rowan/issues/221"

	"do spec url load changing the default configs and groups"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName rowanSampleSpec repoRootPath x |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: gitRootPath.

	rowanSampleSpec := (Rowan image loadedProjectNamed: projectName) specification.
	repoRootPath := rowanSampleSpec repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_302'.

"load Load_tests configuration and core group"
	projectTools load
		loadProjectFromSpecUrl: 'file:' , repoRootPath pathString, '/rowan/specs/RowanSample4_load.ston'
		withConfigurations: #( 'Load' )
		groupNames: #( 'core' ). 

"validate"
	self assert: (Rowan globalNamed: 'RowanSample4Test') isNil.
	self assert: (x := (Rowan image loadedProjectNamed: projectName) specification imageSpec loadedConfigurationNames) = #('Load').
	self assert: (x := (Rowan image loadedProjectNamed: projectName) specification imageSpec loadedGroupNames) = #('core').
%

category: 'tests'
method: RwRowanSample4Test
testLoadProjectNamed_221C

	"https://github.com/dalehenrich/Rowan/issues/221"

	"do spec url load changing the default configs and groups"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName rowanSampleSpec repoRootPath x |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: gitRootPath.

	rowanSampleSpec := (Rowan image loadedProjectNamed: projectName) specification.
	repoRootPath := rowanSampleSpec repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_302'.

"load Load_tests configuration and tests group"
	projectTools load
		loadProjectFromSpecUrl: 'file:' , repoRootPath pathString, '/rowan/specs/RowanSample4_load.ston'
		withConfigurations: #( 'Load' )
		groupNames: #( 'tests' ). 

"validate"
	self assert: (Rowan globalNamed: 'RowanSample4Test') notNil.
	self assert: (x := (Rowan image loadedProjectNamed: projectName) specification imageSpec loadedConfigurationNames) = #('Load').
	self assert: (x := (Rowan image loadedProjectNamed: projectName) specification imageSpec loadedGroupNames) = #('tests').
%

category: 'tests'
method: RwRowanSample4Test
testLoadProjectNamed_221D

	"https://github.com/dalehenrich/Rowan/issues/221"

	"do spec url load changing the default configs and groups"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName rowanSampleSpec repoRootPath x |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath  / projectName) ensureDeleteAll.

	self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: gitRootPath.

	rowanSampleSpec := (Rowan image loadedProjectNamed: projectName) specification.
	repoRootPath := rowanSampleSpec repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_302'.

"load Common configuration and empty groups ... groups do not apply to Common config"
	projectTools load
		loadProjectFromSpecUrl: 'file:' , repoRootPath pathString, '/rowan/specs/RowanSample4_load.ston'
		withConfigurations: #( 'Common' )
		groupNames: #(  ). 

"validate"
	self assert: (Rowan globalNamed: 'RowanSample4Test') isNil.
	self assert: (x := (Rowan image loadedProjectNamed: projectName) specification imageSpec loadedConfigurationNames) = #('Common').
	self assert: (x := (Rowan image loadedProjectNamed: projectName) specification imageSpec loadedGroupNames) = #().
%

category: 'tests'
method: RwRowanSample4Test
testLoadProjectNamed_493

	"https://github.com/dalehenrich/Rowan/issues/493"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName repoRootPath 
		project audit |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath registerProject: true.

	repoRootPath := gitRootPath / projectName.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_493'.

"load core group"
	self 
		_loadProjectFromSpecUrl: (self _rowanSample4_coreSpecificationUrl: repoRootPath)
		repoRootPath: repoRootPath.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.

"load core group of Load component"
	projectTools load
		loadProjectNamed: 'RowanSample4' withConfigurations: #( 'Load' ) groupNames: #('core').
	self assert: (audit := project audit) isEmpty.

"load tests group of Issue_493 component"
	projectTools load
		loadProjectNamed: 'RowanSample4' withConfigurations: #( 'Issue_493' ) groupNames: #().
	self assert: (audit := project audit) isEmpty.
%

category: 'tests'
method: RwRowanSample4Test
testSampleCompoundConfiguration

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName rowanSampleSpec project x |
	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: gitRootPath.

	rowanSampleSpec := (Rowan image loadedProjectNamed: projectName) specification.
	(rowanSampleSpec platformSpec at: 'gemstone')
		projectOwnerId: Rowan image currentUserId;
		defaultSymbolDictName: self _symbolDictionaryName;
		yourself.

	gitRootPath := rowanSampleSpec repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: 'master'.
	projectTools load
		loadProjectNamed: projectName
		withConfigurations: #( 'Test' )
		groupNames: #()
		instanceMigrator: RwGsInstanceMigrator noMigration.

	project := RwProject newNamed: projectName.
	self
		assert:
			(x := project packageNames asArray sort)
				= #('RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests') sort
%

category: 'tests'
method: RwRowanSample4Test
testSampleProjectLoadConfiguration

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName rowanSampleSpec project x repoRootPath |
	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: gitRootPath.

	rowanSampleSpec := (Rowan image loadedProjectNamed: projectName) specification.
	repoRootPath := rowanSampleSpec repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'master'.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	project := RwProject newNamed: projectName.
	self
		assert:
			(x := project packageNames asArray sort)
				= #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 'RowanSample4-GemStone-Tests') sort.

	rowanSampleSpec := (Rowan image loadedProjectNamed: projectName) specification.
	self assert: (x := rowanSampleSpec loadedGroupNames) asArray = #('tests').
	self assert: (x := rowanSampleSpec loadedConfigurationNames) asArray = #('Load').
%

category: 'private'
method: RwRowanSample4Test
_rowanSample4_200_LoadSpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample4_200_load.ston'
%

! Class implementation for 'RwRowanSample7Test'

!		Instance methods for 'RwRowanSample7Test'

category: 'running'
method: RwRowanSample7Test
tearDown

	self _repositoryRoot ifNotNil: [:root | root ensureDelete ].
	super tearDown
%

category: 'tests'
method: RwRowanSample7Test
testCreateComponentProject

	"Excercise RwComponentProjectDefinition instance creation protocol ... 
		create the project on disk -- this is the full deal"

	| projectUrl projectName configurationNames groupNames comment projectHome
		rowanProject cpd x y packageName className testClassName|

	projectName := 'RowanSample7_component'.
	configurationNames := #( 'Main' ).
	groupNames := #( 'core'  'tests').
	projectUrl := self _gitHubProjectUrl.
	comment := 'test project reference'.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := self _testRowanProjectsSandbox pathString.

"create project definition"
	cpd := RwComponentProjectDefinition
		projectName: projectName 
			configurationNames: configurationNames 
			groupNames: groupNames 
			useGit: true 
			projectUrl: projectUrl 
			comment: comment.

"create package definitions"
	cpd
		addPackageNamed: projectName, '-Extension' 
			toComponentNamed: 'Main' 
			withConditions: #( 'common' ) 
			andGroupName: 'core';
		addPackageNamed: projectName, '-Core' 
			toComponentNamed: 'Main' 
			withConditions: #( 'common' ) 
			andGroupName: 'core';
		addPackageNamed: projectName, '-GemStone-Core' 
			toComponentNamed: 'Main' 
			withConditions: #( 'gemstone' ) 
			andGroupName: 'core';
		addPackageNamed: projectName, '-Tests_Main' 
			toComponentNamed: 'Main' 
			withConditions: #( 'common' ) 
			andGroupName: 'tests';
		addPackageNamed: projectName, '-Tests-GemStone_Main' 
			toComponentNamed: 'Main' 
			withConditions: #( 'gemstone' ) 
			andGroupName: 'tests';
		yourself.

"create class and method definitions"
	packageName := projectName, '-Core'.
	className := projectName, 'Core'.
	((cpd packageNamed: packageName)
		addClassNamed: className
			super: 'Object' 
			category: packageName)
		addInstanceMethod: 'foo ^''self foo_platform''' protocol: '*', packageName asLowercase.

	packageName := projectName, '-Extension'.
	((cpd packageNamed: packageName) addClassExtensionNamed: className)
		addClassMethod: 'foo ^''foo''' protocol: '*', packageName asLowercase.

	packageName := projectName, '-GemStone-Core'.
	((cpd packageNamed: packageName) addClassExtensionNamed: className)
		addInstanceMethod: 'foo_platform ^''foo_gemstone''' protocol: '*', packageName asLowercase.

	packageName := projectName, '-Tests_Main'.
	testClassName := projectName, 'Tests_Main'.
	((cpd packageNamed: packageName)
		addClassNamed: testClassName
			super: 'TestCase' 
			category: packageName)
		addInstanceMethod: 'test1 self assert: ', className, ' new foo = self _platform_response' protocol: '*', packageName asLowercase.

	packageName := projectName, '-Tests-GemStone_Main'.
	((cpd packageNamed: packageName) addClassExtensionNamed:testClassName)
		addInstanceMethod: '_platform_response ^ ''foo_gemstone''' protocol: '*', packageName asLowercase.

"prepare to export component project definition"
	cpd projectHome: projectHome.
	cpd repositoryRoot ensureDeleteAll.

"create component project on disk"
	cpd create.

"validate"
	self assert: cpd repositoryRoot exists.

	self assert: cpd configsRoot exists.
	self assert: (cpd configsRoot / (configurationNames at: 1) , 'ston') exists.
	self assert: (x := (cpd configsRoot / (configurationNames at: 1) , 'ston') readStream contents) = ( y:= self _expected_rowanSample7_component_configuration).

	self assert: cpd specsRoot exists.
	self assert: (cpd specsRoot / projectName , 'ston') exists.
	self assert: (x := (cpd specsRoot / projectName , 'ston') readStream contents) = ( y:= self _expected_rowanSample7_component_specification).

	self assert: cpd packagesRoot exists.
	self assert: (cpd packagesRoot /  'properties' , 'st') exists.
	self assert: (x := (cpd packagesRoot /  'properties' , 'st') readStream contents) = ( y:= self _expected_rowanSample7_project_st).
	{ projectName, '-GemStone-Core'. projectName, '-Core' . projectName, '-Tests-GemStone_Main'. 
		projectName, '-Extension' . projectName, '-Tests_Main' . projectName, '-Tests-GemStone_Main'
	}
		do: [:pName | 
			| packageDir |
			packageDir := cpd packageFormat = 'tonel'
				ifTrue: [ cpd packagesRoot / pName ]
				ifFalse: [ cpd packagesRoot / pName , 'package' ].
			self assert: packageDir exists ].

	self assert: cpd projectsRoot exists.

	self assert: (Rowan image loadedProjectNamed: projectName ifAbsent: [  ]) notNil.
%

category: 'tests'
method: RwRowanSample7Test
testCreateNewProjectFromUrl

	"
		1. clone RowanSample7 using non-component API (v1.2.x style)
		2. read project from disk into a project definition
		3. create a new git project on disk using component API
		4. write the project definition to the new project.
	"

	| specUrlString rowanProject gitRootPath projectName projectSpec_1 projectDefinition_2 projectDefinition_3 projectName_3 |

	projectName := 'RowanSample7'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	gitRootPath := self _testRowanProjectsSandbox pathString.

"1. clone RowanSample7 using non-component API (v1.2.x style)"
	specUrlString :=  self _rowanSample7SpecificationUrl_12x.
	projectSpec_1 := specUrlString asRwUrl asSpecification.
	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	Rowan projectTools clone
		cloneSpecification: projectSpec_1
		gitRootPath: gitRootPath
		useSsh: true
		registerProject: false.	"does not register the project, so it is not visible in project list ... does however clone the project to local disk"

"2. read project from disk into a project definition, using component API (v2.0 style)"
	specUrlString := self _rowanSample7SpecificationUrl.
	projectDefinition_2 := (RwComponentProjectDefinition newForUrl: specUrlString)
		repositoryRoot: gitRootPath / projectName;
		yourself.

	projectDefinition_2 readProjectSet.

"3. create a new git project on disk using component API"

	projectName_3 := projectName, '_3'.

	projectDefinition_3 := RwComponentProjectDefinition
		projectName: projectName_3
			configurationNames: #( 'Main' ) 
			groupNames: #('core')  
			defaultComponentName: 'Main'
			useGit: true
			projectUrl: 'https://github.com/dalehenrich/RowanSample7' 
			projectHome: gitRootPath
			committish: 'candidateV1.0' 
			committishType: 'branch'
			comment: 'sample project created from scratch -- copied programatically from RowanSample7'.

	projectDefinition_3 repositoryRoot ensureDeleteAll.

	projectDefinition_3 create.

"validate"
	self assert: projectDefinition_3 repositoryRoot exists.

"4. write the project definition to the new project location"

	projectDefinition_2 projectRef: projectDefinition_3 projectRef.
	projectDefinition_2 export.

"validate"
	self assert: (gitRootPath asFileReference / projectName_3 / 'rowan' / 'components' / 'Main', 'ston') exists
%

category: 'tests'
method: RwRowanSample7Test
testCreateProjectReference

	"Excercise RwProjectReferenceDefinition instance creation protocol ... 
		create the project reference on disk"

	| prd projectUrl projectName configurationNames groupNames comment projectHome
		rowanProject|

	projectName := 'RowanSample7_test'.
	configurationNames := #( 'Main' ).
	groupNames := #( 'core' ).
	projectUrl := self _gitHubProjectUrl.
	comment := 'test project reference'.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := self _testRowanProjectsSandbox pathString.

"create definition"
	prd := RwProjectReferenceDefinition
		projectName: projectName 
			configurationNames: configurationNames 
			groupNames: groupNames 
			useGit: true 
			projectUrl: projectUrl 
			comment: comment.
	prd projectHome: projectHome.

	prd repositoryRoot ensureDeleteAll.

"create project reference on disk"
	prd create.

"validate"
	self assert: prd repositoryRoot exists.
	self assert: prd configsRoot exists.
	self assert: prd specsRoot exists.
	self assert: prd packagesRoot exists.
	self assert: prd projectsRoot exists.

	self deny: prd configsRoot hasChildren.
	self deny: prd packagesRoot hasChildren.
	self deny: prd projectsRoot hasChildren.
	self assert: prd specsRoot hasChildren.

	self assert: (Rowan image loadedProjectNamed: projectName ifAbsent: [  ]) isNil.
%

category: 'tests'
method: RwRowanSample7Test
testCreateProjectReferenceFromScratch

	| rowanProject gitRootPath projectName projectReferenceDefinition projectSpec |

	projectName := 'RowanSample7'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	gitRootPath := self _testRowanProjectsSandbox pathString.

	projectSpec := RwComponentSpecification new
		specName: projectName;
		repoSpec: RwDiskRepositorySpecification new; "want to create a disk-based repository"
		yourself.

"create project reference definitions"
	projectReferenceDefinition := RwProjectReferenceDefinition 
		projectName: projectName 
			configurationNames: #( 'Default'  )
			groupNames: #( 'core' )
			useGit: true
			projectUrl: self _gitHubProjectUrl
			comment: ''.

	projectReferenceDefinition projectHome: gitRootPath.

"validate"
	self assert: projectReferenceDefinition projectName = projectName.
	self assert: projectReferenceDefinition projectAlias = projectReferenceDefinition projectName.
	self assert: projectReferenceDefinition configurationNames = #( 'Default').
	self assert: projectReferenceDefinition groupNames asArray = #( 'core').
	self assert: projectReferenceDefinition committish = 'master'.
	self assert: projectReferenceDefinition committishType = 'branch'.
	self assert: projectReferenceDefinition projectUrl = self _gitHubProjectUrl.

	self assert: projectReferenceDefinition projectHome pathString = gitRootPath asFileReference pathString.
%

category: 'tests'
method: RwRowanSample7Test
testCreateProjectReferenceFromUrl

	| specUrlString rowanProject gitRootPath projectName projectSpec projectReferenceDefinition x y |

	projectName := 'RowanSample7'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	gitRootPath := self _testRowanProjectsSandbox pathString.

	specUrlString := self _rowanSample7SpecificationUrl.
	projectSpec := specUrlString asRwUrl asSpecification.

"create project reference definitions"
	projectReferenceDefinition := RwProjectReferenceDefinition 
		newForSpecification: projectSpec 
		projectHome: gitRootPath.

"validate"
	self assert: projectReferenceDefinition projectName = projectName.
	self assert: projectReferenceDefinition projectAlias = projectReferenceDefinition projectName.
	self assert: projectReferenceDefinition configurationNames = #( 'Main').
	self assert: projectReferenceDefinition groupNames asArray = #( 'core').
	self assert: projectReferenceDefinition defaultComponentName = 'Main'.
	self assert: projectReferenceDefinition projectUrl = 'https://github.com/dalehenrich/RowanSample7'.

	self assert: (x := projectReferenceDefinition projectHome pathString) = (y := gitRootPath asFileReference pathString).

"create project reference definitions"
	projectReferenceDefinition := RwProjectReferenceDefinition newForSpecification: projectSpec.

"validate"
	self assert: (x := projectReferenceDefinition projectHome pathString) = (y := FileLocator rowanProjectsHome pathString).
%

category: 'tests'
method: RwRowanSample7Test
testCreateRepositoryDefinition

	"exercise the RwAbstractRepositoryDefinition class creation protocol"

	| rowanProject gitRootPath repositoryName repositoryDefinition_1  repositoryDefinition_2 repoRoot
		projectVersionString gitHubProjectUrl gitHubRemoteUrl x y |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	gitRootPath := self _testRowanProjectsSandbox pathString.

	repositoryName := 'RowanSample7'.
	repoRoot := gitRootPath asFileReference / repositoryName.
	projectVersionString := self _projectVersionString.
	gitHubProjectUrl := self _gitHubProjectUrl.
	gitHubRemoteUrl := self _gitHubRemoteUrl.

"create repository definitions using #newNamed:repositoryRoot:"
	repositoryDefinition_1 := RwDiskRepositoryDefinition
		newNamed: repositoryName 
		repositoryRoot: repoRoot.

	repositoryDefinition_2 := RwDiskRepositoryDefinition
		newNamed: repositoryName 
		repositoryRoot: repoRoot pathString.

"validate"
	self assert: repositoryDefinition_1  name = repositoryDefinition_2 name.
	self assert: repositoryDefinition_1  repositoryRoot = repositoryDefinition_2 repositoryRoot.
	self assert:  repositoryDefinition_1 repositoryRoot = repoRoot asFileReference.

"create repository definitions using #newNamed:repositoryRoot:projectUrl:"
	repositoryDefinition_1 := RwDiskRepositoryDefinition
		newNamed: repositoryName 
		repositoryRoot: repoRoot
		projectUrl: gitHubProjectUrl.

	repositoryDefinition_2 := RwDiskRepositoryDefinition
		newNamed: repositoryName 
		repositoryRoot: repoRoot pathString
		projectUrl: gitHubProjectUrl.

"validate"
	self assert: repositoryDefinition_1  name = repositoryDefinition_2 name.
	self assert: repositoryDefinition_1  repositoryRoot = repositoryDefinition_2 repositoryRoot.
	self assert: repositoryDefinition_1  projectUrl = repositoryDefinition_2 projectUrl.

"create repository definitions using #newNamed:repositoryRoot:version:"
	repositoryDefinition_1 := RwDiskRepositoryDefinition
		newNamed: repositoryName 
		repositoryRoot: repoRoot.

	repositoryDefinition_2 := RwDiskRepositoryDefinition
		newNamed: repositoryName 
		repositoryRoot: repoRoot pathString.

"validate"
	self assert: repositoryDefinition_1  name = repositoryDefinition_2 name.
	self assert: repositoryDefinition_1  repositoryRoot = repositoryDefinition_2 repositoryRoot.

	self assert:  repositoryDefinition_1 repositoryRoot = repoRoot asFileReference.

"create repository definitions using #newNamed:repositoryRoot:projectUrl:version:"
	repositoryDefinition_1 := RwGitRepositoryDefinition
		newNamed: repositoryName 
		repositoryRoot: repoRoot
		projectUrl: gitHubProjectUrl
		remoteUrl: gitHubRemoteUrl
		committish: 'master'
		committishType: 'branch'.

	repositoryDefinition_2 := RwGitRepositoryDefinition
		newNamed: repositoryName 
		repositoryRoot: repoRoot pathString
		projectUrl: gitHubProjectUrl
		remoteUrl: gitHubRemoteUrl
		committish: 'master'
		committishType: 'branch'.

"validate"
	self assert: repositoryDefinition_1  name = repositoryDefinition_2 name.
	self assert: repositoryDefinition_1  repositoryRoot = repositoryDefinition_2 repositoryRoot.
	self assert: (x := repositoryDefinition_1  committish) = (y := repositoryDefinition_2 committish).
	self assert: repositoryDefinition_1  projectUrl = repositoryDefinition_2 projectUrl.
	self assert: repositoryDefinition_1  remoteUrl = repositoryDefinition_2 remoteUrl.

	self assert:  repositoryDefinition_1 projectUrl = gitHubProjectUrl.
	self assert: repositoryDefinition_1 remoteUrl = gitHubRemoteUrl.
	self assert: repositoryDefinition_1 committish = 'master'.
%

category: 'tests'
method: RwRowanSample7Test
testCreateRepositoryDefinitionFromUrl_1

	"exercise the RwAbstractRepositoryDefinition class creation protocol"

	| specUrlString rowanProject gitRootPath projectName projectSpec repositoryDefinition_1 x y |

	projectName := 'RowanSample7'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	gitRootPath := self _testRowanProjectsSandbox pathString.

	specUrlString := self _rowanSample7SpecificationUrl.
	projectSpec := specUrlString asRwUrl asSpecification.


"create repository definitions"
	repositoryDefinition_1 := RwAbstractRepositoryDefinition 
		newForSpecification: projectSpec 
			projectHome: gitRootPath.

	self assert: repositoryDefinition_1  name = projectSpec specName.
	self assert: repositoryDefinition_1  repositoryRoot = (gitRootPath asFileReference / projectName).
	self assert: (x := repositoryDefinition_1  committish) =  (y := 'v', self _projectVersionString).
	self assert: repositoryDefinition_1  projectUrl = self _gitHubProjectUrl
%

category: 'tests'
method: RwRowanSample7Test
testCreateRepositoryDefinitionFromUrl_2

	"verify that the repository root can be dynamically swapped out (if desired) ... repository definitioin can be ointed wholesale to another $ROWAN_PROJECTS_HOME"

	| specUrlString rowanProject gitRootPath projectName projectSpec repositoryDefinition x y  memoryRoot repositoryDefinition_1 |

	projectName := 'RowanSample7'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	gitRootPath := self _testRowanProjectsSandbox.

	specUrlString := self _rowanSample7SpecificationUrl.
	projectSpec := specUrlString asRwUrl asSpecification.

"create repository definition based on disk"
	repositoryDefinition := RwDiskRepositoryDefinition 
		newForSpecification: projectSpec 
			projectHome: gitRootPath.

	self assert: repositoryDefinition  repositoryRoot fileSystem isDiskFileSystem.
	self assert: repositoryDefinition class == RwDiskRepositoryDefinition.

"validate"
	self assert: (x := repositoryDefinition repositoryRoot pathString) = (y := (gitRootPath / projectName) pathString).

"create repository definition based on memory"
	memoryRoot := FileSystem memory * 'repoDefinitionTestRoot'.
	self _repositoryRoot: memoryRoot.

	gitRootPath := memoryRoot / 'repos'.
	repositoryDefinition repositoryRoot: gitRootPath / projectName.

"validate"
	self assert: repositoryDefinition  repositoryRoot fileSystem isMemoryFileSystem.
	self assert: (x := repositoryDefinition repositoryRoot pathString) = (y := (gitRootPath / projectName) pathString).

"create from scratch and it should be using RwMemoryRepositoryDefinition"
	repositoryDefinition_1 := RwAbstractRepositoryDefinition 
		newForSpecification: projectSpec 
			projectHome: gitRootPath.

"validate"
	self assert: repositoryDefinition_1  repositoryRoot fileSystem isMemoryFileSystem.
	self assert: repositoryDefinition_1 class == RwMemoryRepositoryDefinition.

	self assert: repositoryDefinition  name = repositoryDefinition_1 name.
	self assert: repositoryDefinition  repositoryRoot = repositoryDefinition_1 repositoryRoot.
%

category: 'tests'
method: RwRowanSample7Test
testResolveProjectReference

	"clone a repository from github, attach to an existing git repository, clone to an alternate projectHome"

	| specUrlString rowanProject projectHome projectName projectSpec projectReferenceDefinition_1 projectReferenceDefinition_2 |

	projectName := 'RowanSample7'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := self _testRowanProjectsSandbox pathString.

	specUrlString := self _rowanSample7SpecificationUrl.
	projectSpec := specUrlString asRwUrl asSpecification.

"create project reference definitions"
	projectReferenceDefinition_1 := RwProjectReferenceDefinition 
		newForSpecification: projectSpec 
		projectHome: projectHome.

	projectReferenceDefinition_1 repositoryRoot ensureDeleteAll.

"1. clone repository"
	projectReferenceDefinition_1 resolve.

"validate"
	self assert: projectReferenceDefinition_1 repositoryRoot exists.

"2. create second project reference definitions"
	projectReferenceDefinition_2 := RwProjectReferenceDefinition 
		newForSpecification: projectSpec 
		projectHome: projectHome.

"attach to repository"
	projectReferenceDefinition_2 resolve.

"validate"
	self assert: projectReferenceDefinition_1 projectHome = projectReferenceDefinition_2 projectHome.

"3. now clone to a different spot by just changing the project home"
	projectReferenceDefinition_2 repositoryRoot ensureDeleteAll.

	projectHome := projectHome asFileReference / 'sample7_repos'.
	projectHome ensureDeleteAll.
	projectHome ensureCreateDirectory.

	projectReferenceDefinition_2 projectHome: projectHome.

"clone to new location"
	projectReferenceDefinition_2 resolve.

"validate"
	self assert: projectReferenceDefinition_2 repositoryRoot exists.
	self deny: projectReferenceDefinition_1 repositoryRoot exists.	"confirm that the repo wasn't cloned to old location"
%

category: 'tests'
method: RwRowanSample7Test
testResolveRepositoryDefinition

	"clone a repository from github using repositoryDefinition"

	| specUrlString rowanProject gitRootPath projectName projectSpec repositoryDefinition |

	projectName := 'RowanSample7'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	gitRootPath := self _testRowanProjectsSandbox.

	specUrlString := self _rowanSample7SpecificationUrl.
	projectSpec := specUrlString asRwUrl asSpecification.

"create repository definitions using standard git repo name"
	repositoryDefinition := RwAbstractRepositoryDefinition 
		newForSpecification: projectSpec 
			projectHome: gitRootPath.

	repositoryDefinition repositoryRoot ensureDeleteAll.

"clone repository "
	self 
		handleInformDuring: [ repositoryDefinition resolve ] 
		interactionBlock: [:inform | self assert: false description: 'unexpected inform' ].

"validate"
	self assert: gitRootPath exists.
	self assert: repositoryDefinition repositoryExists.

	repositoryDefinition repositoryRoot ensureDeleteAll.

"create repository definitions using alternat git repo name"
	projectName := projectName, '_alt'.
	repositoryDefinition := RwGitRepositoryDefinition 
		newNamed: projectName 
			forSpecification: projectSpec 
			repositoryRoot: gitRootPath / projectName.

	repositoryDefinition repositoryRoot ensureDeleteAll.

"clone repository"
	self 
		handleInformDuring: [ repositoryDefinition resolve ] 
		interactionBlock: [:inform | self assert: false description: 'unexpected inform' ].

"validate"
	self assert: gitRootPath exists.
	self assert: repositoryDefinition repositoryExists.
%

category: 'private'
method: RwRowanSample7Test
_expected_rowanSample7_component_configuration

	^ 'RwComponentLoadConfiguration {
	#name : ''Main'',
	#comment : '''',
	#version : ''0.1.0'',
	#conditionalPackages : {
		[
			''common''
		] : {
			''core'' : {
				#packageNames : [
					''RowanSample7_component-Core'',
					''RowanSample7_component-Extension''
				]
			},
			''tests'' : {
				#packageNames : [
					''RowanSample7_component-Tests_Main''
				]
			}
		},
		[
			''gemstone''
		] : {
			''core'' : {
				#packageNames : [
					''RowanSample7_component-GemStone-Core''
				]
			},
			''tests'' : {
				#packageNames : [
					''RowanSample7_component-Tests-GemStone_Main''
				]
			}
		}
	}
}'
%

category: 'private'
method: RwRowanSample7Test
_expected_rowanSample7_component_specification

^ 'RwComponentSpecification {
	#specName : ''RowanSample7_component'',
	#version : ''0.3.0'',
	#projectUrl : ''https://github.com/dalehenrich/RowanSample7'',
	#configsPath : ''rowan/components'',
	#specsPath : ''rowan/specs'',
	#repoSpec : RwGitRepositorySpecification {
		#committish : ''master'',
		#committishType : ''branch'',
		#remoteUrl : ''git@github.com:dalehenrich/RowanSample7.git ''
	},
	#repoPath : ''rowan/src'',
	#comment : ''test project reference'',
	#defaultConfigurationNames : [
		''Main''
	],
	#defaultGroupNames : [
		''core'',
		''tests''
	],
	#projectsPath : ''rowan/projects'',
	#defaultComponentName : ''Core''
}'
%

category: 'private'
method: RwRowanSample7Test
_expected_rowanSample7_project_st

^ '{ 
	#format : ''tonel'',
	#convention : ''RowanHybrid''
}
'
%

category: 'private'
method: RwRowanSample7Test
_gitHubProjectUrl

	^ 'https://github.com/dalehenrich/RowanSample7'
%

category: 'private'
method: RwRowanSample7Test
_gitHubRemoteUrl

	^ 'git@github.com:dalehenrich/RowanSample7.git'
%

category: 'private'
method: RwRowanSample7Test
_projectVersionString

	^ '0.0.3'
%

category: 'private'
method: RwRowanSample7Test
_repositoryRoot

	^ repositoryRoot
%

category: 'private'
method: RwRowanSample7Test
_repositoryRoot: anObject

	repositoryRoot := anObject
%

category: 'private'
method: RwRowanSample7Test
_rowanSample7SpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample7.ston'
%

category: 'private'
method: RwRowanSample7Test
_rowanSample7SpecificationUrl_12x

	"1.2.x compat project spec"

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample7_12x.ston'
%

category: 'private'
method: RwRowanSample7Test
_rowanSample7_ColorsSpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample7_Colors.ston'
%

! Class implementation for 'RwUrlTest'

!		Class methods for 'RwUrlTest'

category: 'as yet unclassified'
classmethod: RwUrlTest
testParseNoErrors
  "list of all of the url strings that should at least parse ... other tests should go into specific details of accessing fields"

  {'github://GsDevKit/GsDevKit:master/repository'.
  'gitfiletree://gitlab.com/GsDevKit/GsDevKit:350/repository'.
  'file:$GS_HOME/shared/repos/rowan/sample/'.
  'cypress:$GS_HOME/shared/repos/rowan/sample/'.
  'filetree://$GS_HOME/shared/repos/rowan/sample/'.
  'tonel://$GS_HOME/shared/repos/rowan/sample/'.
  'https://raw.githubusercontent.com/dalehenrich/sample/master/specs/Sample.ston'.
  'cypress:$GS_HOME/shared/repos/rowan/sample/repository/'.
  'smalltalk://github.com/dalehenrich/CypressReferenceImplementation:rowan/tonel'.
  'smalltalk://github.com/dalehenrich/CypressReferenceImplementation:rowan/tonel/'.
  'smalltalk://github.com/dalehenrich/CypressReferenceImplementation:rowan/'.
  'smalltalk://github.com/dalehenrich/CypressReferenceImplementation/'.
  'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'.
  'msw://chaos.resnet.gatech.edu:9000/testbook?top'.
  'telnet:chaos.resnet.gatech.edu'}
    do: [ :urlString | RwUrl fromString: urlString ]
%

!		Instance methods for 'RwUrlTest'

category: 'private'
method: RwUrlTest
sampleFileUrlStrings
	"file: url, pathString pairs"

	"the complicated bit is the env variable in the url"

	^ {
		{ 'file:/home/dhenrich/_home/shared/repos/rowan/sample/' . '/home/dhenrich/_home/shared/repos/rowan/sample/' }.
		{ 'file:/home/dhenrich/_home/shared/repos/rowan/sample/spec.ston' . '/home/dhenrich/_home/shared/repos/rowan/sample/spec.ston' }.
		{ 'file:$GS_HOME/shared/repos/rowan/sample/' . '$GS_HOME/shared/repos/rowan/sample/' }.
		{ 'file:$GS_HOME/shared/repos/rowan/sample/spec.ston' . '$GS_HOME/shared/repos/rowan/sample/spec.ston' }.
	}
%

category: 'private'
method: RwUrlTest
sampleUrlStrings
  ^ {'github://GsDevKit/GsDevKit:master/repository'.
  'gitfiletree://gitlab.com/GsDevKit/GsDevKit:350/repository'.
  'file:$GS_HOME/shared/repos/rowan/sample/'.
  'cypress:$GS_HOME/shared/repos/rowan/sample/'.
  'filetree://$GS_HOME/shared/repos/rowan/sample/'.
  'tonel://$GS_HOME/shared/repos/rowan/sample/'.
  'https://raw.githubusercontent.com/dalehenrich/sample/master/specs/Sample.ston'.
  'cypress:$GS_HOME/shared/repos/rowan/sample/repository/'.
  'metacello://github.com/dalehenrich/CypressReferenceImplementation:rowan/tonel'.
  'metacello://github.com/dalehenrich/CypressReferenceImplementation:rowan/tonel/'.
  'metacello://github.com/dalehenrich/CypressReferenceImplementation:rowan/'.
  'metacello://github.com/dalehenrich/CypressReferenceImplementation/'.
  'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'.
  'msw://chaos.resnet.gatech.edu:9000/testbook?top'.
  'telnet:chaos.resnet.gatech.edu'}
%

category: 'tests'
method: RwUrlTest
testAsRwRepository

	| repos repoRoot testRepoPath loadedProject |
	loadedProject := Rowan image _projectForNonTestProject: 'Rowan'.
	repoRoot :=  loadedProject repositoryRootPath.
	testRepoPath := self _testRowanProjectsSandbox pathString.
	repos := {('cypress:' , testRepoPath , '/cypress/').
	('filetree://' , testRepoPath , '/filetree/').
	('tonel:' , testRepoPath , '/tonel/')}
		collect: [ :urlString | urlString -> urlString asRwRepository ].
	repos
		do: [ :assoc | 
			| repo x y |
			repo := assoc value.
			self assert: (x := repo url) = (y := assoc key) ]
%

category: 'tests'
method: RwUrlTest
testAsRwUrl
  self sampleUrlStrings
    do: [ :urlString | 
      | url |
      RwUrl fromString: urlString.
      url := urlString asRwUrl.
      self assert: url printString = urlString ]
%

category: 'tests'
method: RwUrlTest
testAsRwUrlForFileUrls

	self sampleFileUrlStrings
		do: [ :ar | 
			| url urlString fileString pathString dirString x |
			urlString := ar at: 1.
			fileString := ar at: 2.
			RwUrl fromString: urlString.
			url := urlString asRwUrl.
			pathString := url pathString.
			dirString := url pathDirString.
			self assert: (pathString = fileString).
			self assert: url printString = urlString.
			pathString last = $/
				ifTrue: [  self assert: dirString = pathString ]
				ifFalse: [ 
					"use asFileReference to expand env vars in path"
					self assert: (dirString asFileReference pathString) = (x :=  pathString asFileReference parent pathString) ] ]
%

! Class implementation for 'RwGemStoneVersionNumberTestCase'

!		Class methods for 'RwGemStoneVersionNumberTestCase'

category: 'Tests'
classmethod: RwGemStoneVersionNumberTestCase
shouldInheritSelectors

	^true
%

!		Instance methods for 'RwGemStoneVersionNumberTestCase'

category: 'test alpha/numeric version numbers'
method: RwGemStoneVersionNumberTestCase
testAlphaNumericVersion1

	"Use numeric comparison for pure numbers. If you non-numeric version separate with '-'"
	
	| x y |
	self assert: ((x := self versionClass fromString: '2.9.0') < (y := self versionClass fromString: '2.10.0')).
%

category: 'test approximately greater than'
method: RwGemStoneVersionNumberTestCase
testApproxVersion01

	self assert: '1.1.1' asRwGemStoneVersionNumber ~> '1.1' asRwGemStoneVersionNumber
%

category: 'test approximately greater than'
method: RwGemStoneVersionNumberTestCase
testApproxVersion02

	self deny: '1.1' asRwGemStoneVersionNumber ~> '1' asRwGemStoneVersionNumber
%

category: 'test approximately greater than'
method: RwGemStoneVersionNumberTestCase
testApproxVersion03

	self assert: '1.1' asRwGemStoneVersionNumber ~> '1.1' asRwGemStoneVersionNumber
%

category: 'test approximately greater than'
method: RwGemStoneVersionNumberTestCase
testApproxVersion04

	self assert: '3.2.0' asRwGemStoneVersionNumber approximateBase asString = '4'.
	self assert: '3.2' asRwGemStoneVersionNumber approximateBase asString = '4'.
%

category: 'test approximately greater than'
method: RwGemStoneVersionNumberTestCase
testApproxVersion05

	self assert: '3.2.16' asRwGemStoneVersionNumber ~> '3.2.15' asRwGemStoneVersionNumber.
	self deny: '3.2.14' asRwGemStoneVersionNumber ~> '3.2.15' asRwGemStoneVersionNumber.
	self deny: '3.3' asRwGemStoneVersionNumber ~> '3.2.15' asRwGemStoneVersionNumber.
	self deny: '3.3.0' asRwGemStoneVersionNumber ~> '3.2.15' asRwGemStoneVersionNumber.

	self assert: '3.2.15.5' asRwGemStoneVersionNumber ~> '3.2.15.1' asRwGemStoneVersionNumber.
	self deny: '3.2.15.0' asRwGemStoneVersionNumber ~> '3.2.15.1' asRwGemStoneVersionNumber.
	self deny: '3.2.16' asRwGemStoneVersionNumber ~> '3.2.15.1' asRwGemStoneVersionNumber.
	self deny: '3.3' asRwGemStoneVersionNumber ~> '3.2.15.1' asRwGemStoneVersionNumber.
	self deny: '3.3.0' asRwGemStoneVersionNumber ~> '3.2.15.1' asRwGemStoneVersionNumber.

	self assert: '3.3' asRwGemStoneVersionNumber ~> '3.2' asRwGemStoneVersionNumber.
	self assert: '3.3.0' asRwGemStoneVersionNumber ~> '3.2' asRwGemStoneVersionNumber.
	self assert: '3.3.1' asRwGemStoneVersionNumber ~> '3.2' asRwGemStoneVersionNumber.
	self assert: '3.4' asRwGemStoneVersionNumber ~> '3.2' asRwGemStoneVersionNumber.

	self assert: '3.3.1' asRwGemStoneVersionNumber ~> '3.2.0' asRwGemStoneVersionNumber.
	self assert: '3.3.0' asRwGemStoneVersionNumber ~> '3.2.0' asRwGemStoneVersionNumber.
	self assert: '3.3' asRwGemStoneVersionNumber ~> '3.2.0' asRwGemStoneVersionNumber.
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testCollapseZeros

	self assert: (RwGemStoneVersionNumber fromString: '1.0') collapseZeros printString = '1'.
	self assert: (RwGemStoneVersionNumber fromString: '1.0') collapseZeros printString = '1'.
	self assert: (RwGemStoneVersionNumber fromString: '1.0.0') collapseZeros printString = '1'.
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion01

	self assert: ((self versionClass fromString: '1.1.1') versionString = '1.1.1')
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion02

	| v1 v2 |
	v1 := self versionClass fromString: '1.1.1'.
	v2 := self versionClass fromString: '1.0.0'.
	self assert: (v1 = v1).	
	self assert: (v2 = v2).
	self assert: (v1 > v2)
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion03

	| v1 v2 |
	v1 := self versionClass fromString: '1.0.0.1'.
	v2 := self versionClass fromString: '1.0.0'.
	self assert: (v1 > v2)
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion04

	| v1 v2 |
	v1 := self versionClass fromString: '1.0.1'.
	v2 := self versionClass fromString: '1.0.0'.
	self assert: (v1 > v2)
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion05

	| v1 v2 |
	v1 := self versionClass fromString: '3'.
	v2 := self versionClass fromString: '2'.
	self assert: (v1 > v2)
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion06

	| v1 v2 |
	v1 := self versionClass fromString: '3.'.
	v2 := self versionClass fromString: '2'.
	self assert: (v1 > v2)
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion07

	| v1 v2 |
	v1 := self versionClass fromString: '3.0.0'.
	v2 := self versionClass fromString: '2'.
	self assert: (v1 > v2)
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion09

	| v1 v2 |
	v1 := self versionClass fromString: '1.0'.
	v2 := self versionClass fromString: '0.7'.
	self assert: (v1 >= v2).
	self assert: (v2 <= v1)
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion10

	| x y |
	self assert: ((x := (({
		self versionClass fromString: '1.0'.
		self versionClass fromString: '0.7'.
		self versionClass fromString: '0.8'.
		self versionClass fromString: '0.9'.
		self versionClass fromString: '1.0.1'
	} sort: [:a :b | a <= b ]) collect: [:each | each versionString ]) asArray) = (y := #( '0.7' '0.8' '0.9' '1.0' '1.0.1')))
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion11

	| v1 v2 |
	v1 := self versionClass fromString: '1.0.1b'.
	v2 := self versionClass fromString: '1.0.1a'.
	self assert: (v1 >= v2).
	self assert: (v2 <= v1)
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion12

	self deny: ((self versionClass fromString: '1.0') <= (self versionClass fromString: '0.7'))
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion13

	self deny: ((self versionClass fromString: '0.8') <= (self versionClass fromString: '0.7')).
	self deny: ((self versionClass fromString: '0.8.1.8') <= (self versionClass fromString: '0.7.0.5')).
	
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion17

	self assert: ((self versionClass fromString: '1.0') = (self versionClass fromString: '1.0.0')).
	self assert: ((self versionClass fromString: '1') = (self versionClass fromString: '1.0')).
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion18

	self deny: ((self versionClass fromString: '1.0') < (self versionClass fromString: '1')).
	self deny: ((self versionClass fromString: '1.0') < (self versionClass fromString: '1-0')).
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion20

	self assert: (RwGemStoneVersionNumber fromString: '') printString = ''.
%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion21

	self deny: (RwGemStoneVersionNumber fromString: '') > (RwGemStoneVersionNumber fromString: '0').
	self assert: (RwGemStoneVersionNumber fromString: '') < (RwGemStoneVersionNumber fromString: '0').
	self assert: (RwGemStoneVersionNumber fromString: '') = (RwGemStoneVersionNumber fromString: '').

%

category: 'tests'
method: RwGemStoneVersionNumberTestCase
testVersion24

	self assert: (RwGemStoneVersionNumber fromString: '1.0.0.1.0.0') = (RwGemStoneVersionNumber fromString: '1.0.0.1').
	self assert: (RwGemStoneVersionNumber fromString: '1.0.0.1') ~= (RwGemStoneVersionNumber fromString: '1..1').
%

category: 'private'
method: RwGemStoneVersionNumberTestCase
versionClass

	^RwGemStoneVersionNumber
%

! Class implementation for 'RwProjectConfigurationsTest'

!		Instance methods for 'RwProjectConfigurationsTest'

category: 'tests'
method: RwProjectConfigurationsTest
testBasicProjectCompoundConfiguration

	| url rowanProject config |
	rowanProject := self _rowanProject.
	url := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanProjectCompoundConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	self assert: config class == RwProjectCompoundConfiguration
%

category: 'tests'
method: RwProjectConfigurationsTest
testBasicProjectLoadConfiguration

	"https://github.com/dalehenrich/Rowan/issues/189"

	| url rowanProject config |
	rowanProject := self _rowanProject.
	url := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	self assert: config class == RwProjectLoadConfiguration
%

category: 'tests'
method: RwProjectConfigurationsTest
testProjectCompoundConfigurationApi

	| packageNames config visitor x packageMapSpecs packagePropertiesMap map |
	packageNames :=  #('p1' 'p2').
	config := RwProjectLoadConfiguration new
		name: 'Testing';
		addDefinedGroupName: 'core';
		addDefinedGroupName: 'deprecated' includeGroups: #( 'core' );
		addDefinedGroupName: 'tests' includeGroups: #( 'deprecated' 'core'  );
		conditionalPackagesAtConditions: {'common'}
			andGroup: 'core' 
			addPackageNames: packageNames;
		conditionalPackageMapSpecsAtGemStoneUserId: 'SystemUser' 
			setDefaultSymbolDictNameTo: 'RowanKernel';
		conditionalPackageMapSpecsAtGemStoneUserId: 'SystemUser' 
			andPackageName: (packageNames at: 1)
			setSymbolDictNameTo: 'SymDict1';
		conditionalPackageMapSpecsAtGemStoneUserId: 'SystemUser' 
			andPackageName: (packageNames at: 2)
			setSymbolDictNameTo: 'SymDict2';
		yourself.
	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: { 'common'. 'gemstone'. (System stoneVersionReport at: 'gsVersion') asRwGemStoneVersionNumber};
		groupNames: #('core' 'tests');
		yourself.
	visitor visit: config.

	self assert: (x := visitor packageNames asArray sort) = packageNames.

	packageMapSpecs := visitor packageMapSpecs.
	self assert: packageMapSpecs notNil.

	self assert: (packageMapSpecs at: #'defaultSymbolDictName') = 'RowanKernel'.

	packagePropertiesMap := packageMapSpecs at: #packageNameToPlatformPropertiesMap.

	map := packagePropertiesMap at: (packageNames at: 1).
	self assert: (map at: 'symbolDictName') = 'SymDict1'.

	map := packagePropertiesMap at: (packageNames at: 2).
	self assert: (map at: 'symbolDictName') = 'SymDict2'.

	map := config conditionalPackageMapSpecsAtGemStoneUserId: 'SystemUser' andPackageName: (packageNames at: 1).
	self assert: (map at: 'symbolDictName') = 'SymDict1'.

	map := config conditionalPackageMapSpecsAtGemStoneUserId: 'SystemUser' andPackageName: (packageNames at: 2).
	self assert: (map at: 'symbolDictName') = 'SymDict2'.
%

category: 'tests'
method: RwProjectConfigurationsTest
testRowanLoadConfiguration

	| configurationBasePath configurationUrl rowanProject config visitor packageNames gemStoneVersion packageMapSpecs packagePropertiesMap x |

	rowanProject := self _rowanProject.

	configurationBasePath :=  rowanProject repositoryRootPath , '/rowan/configs/'.
	configurationUrl := 'file:' , configurationBasePath, 'Load.ston'.

	config := RwAbstractProjectConfiguration fromUrl: configurationUrl.

	gemStoneVersion := System stoneVersionReport at: 'gsVersion'.
	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: { 'common'. 'gemstone'. gemStoneVersion asRwGemStoneVersionNumber};
		groupNames: #('core' 'tests');
		configurationBasePath: configurationBasePath;
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = (x := (self _expectedRowan_LoadPackageNames, self _expectedLoadPackageNames_gemstone_tests) sort).

	packageMapSpecs := visitor packageMapSpecs.
	self assert: packageMapSpecs notNil.

	self assert: (packageMapSpecs at: #'defaultSymbolDictName') = 'RowanKernel'.
	self assert: (packageMapSpecs at: #'defaultUseSessionMethodsForExtensions') = false.

	packagePropertiesMap := packageMapSpecs at: #packageNameToPlatformPropertiesMap.
	#('Rowan-GemStone-Loader') 
		do: [:packageName | 
			| map | 
			map := packagePropertiesMap at: packageName.
			self assert: (map at: 'symbolDictName') = 'RowanLoader' ].
%

category: 'tests'
method: RwProjectConfigurationsTest
testRowanSample4ProjectLoadConfiguration

	| configurationUrl rowanProject config visitor packageNames gemStoneVersion packageMapSpecs packagePropertiesMap|

	rowanProject := self _rowanProject.
	configurationUrl := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanSampleProject4_LoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: configurationUrl.

	gemStoneVersion := System stoneVersionReport at: 'gsVersion'.
	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: { 'common'. 'gemstone'. gemStoneVersion asRwGemStoneVersionNumber};
		groupNames: #('core' 'tests');
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = self _expectedRowanSampleProject4_LoadPackageNames.

	packageMapSpecs := visitor packageMapSpecs.
	self assert: packageMapSpecs notNil.

	self assert: (packageMapSpecs at: #'defaultSymbolDictName') = 'RowanSample4SymbolDict'.
	self assert: (packageMapSpecs at: #'defaultUseSessionMethodsForExtensions') = false.

	packagePropertiesMap := packageMapSpecs at: #packageNameToPlatformPropertiesMap.
	#('RowanSample4-GemStone') 
		do: [:packageName | 
			| map | 
			map := packagePropertiesMap at: packageName.
			self assert: (map at: 'symbolDictName') = 'RowanSample4DictionarySymbolDict' ].
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitNestedProjectLoadConfiguration_common_core

	| url rowanProject config visitor packageNames configurationBasePath |
	rowanProject := self _rowanProject.
	configurationBasePath :=  rowanProject repositoryRootPath , '/test/configs/'.
	url := 'file:' , configurationBasePath, 'RowanTopLevelProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: #('common');
		groupNames: #('core');
		configurationBasePath: configurationBasePath;
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = self _expectedLoadPackageNames_common_core.
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitNestedProjectLoadConfiguration_common_core_tests

	| url rowanProject config visitor packageNames configurationBasePath |
	rowanProject := self _rowanProject.
	configurationBasePath :=  rowanProject repositoryRootPath , '/test/configs/'.
	url := 'file:' , configurationBasePath, 'RowanTopLevelProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: #('common');
		groupNames: #('core' 'tests');
		configurationBasePath: configurationBasePath;
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = self _expectedLoadPackageNames_common_core_tests.
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitNestedProjectLoadConfiguration_common_deprecated

	| url rowanProject config visitor packageNames configurationBasePath |
	rowanProject := self _rowanProject.
	configurationBasePath :=  rowanProject repositoryRootPath , '/test/configs/'.
	url := 'file:' , configurationBasePath, 'RowanTopLevelProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: #('common');
		groupNames: #('deprecated');
		configurationBasePath: configurationBasePath;
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = self _expectedLoadPackageNames_common_deprecated.
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitNestedProjectLoadConfiguration_common_tests

	| url rowanProject config visitor packageNames configurationBasePath |
	rowanProject := self _rowanProject.
	configurationBasePath :=  rowanProject repositoryRootPath , '/test/configs/'.
	url := 'file:' , configurationBasePath, 'RowanTopLevelProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: #('common');
		groupNames: #('tests');
		configurationBasePath: configurationBasePath;
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = self _expectedLoadPackageNames_common_tests.
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitNestedProjectLoadConfiguration_Master

	"https://github.com/dalehenrich/Rowan/issues/252"

	| url rowanProject config visitor packageNames configurationBasePath |
	rowanProject := self _rowanProject.
	configurationBasePath :=  rowanProject repositoryRootPath , '/test/configs/'.
	url := 'file:' , configurationBasePath, 'RowanTopLevelProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: #('common');
		groupNames: #('Master');
		configurationBasePath: configurationBasePath;
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = self _expectedLoadPackageNames_common_deprecated.
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitProjectCompoundConfiguration

	| url rowanProject config visitor packageNames |
	rowanProject := self _rowanProject.
	url := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanProjectCompoundConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = self _expectedCompoundPackageNames.
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitProjectLoadConfiguration_common

	| url rowanProject config visitor packageNames x |
	rowanProject := self _rowanProject.
	url := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: #('common');
		groupNames: #('core' 'tests');
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = (x := self _expectedLoadPackageNames_common).
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitProjectLoadConfiguration_gemstone

	| url rowanProject config visitor packageNames packageMapSpecs packagePropertiesMap x |
	rowanProject := self _rowanProject.
	url := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: #( 'common' 'gemstone' );
		groupNames: #('core' 'tests');
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.
	self assert: packageNames = (x := self _expectedLoadPackageNames_gemstone).

	packageMapSpecs := visitor packageMapSpecs.
	self assert: packageMapSpecs notNil.

	Rowan image currentUserId = 'SystemUser'
		ifTrue: [
			self assert: (packageMapSpecs at: #'defaultSymbolDictName') = 'RowanKernel'.
			self assert: (packageMapSpecs at: #'defaultUseSessionMethodsForExtensions') = false.

			packagePropertiesMap := packageMapSpecs at: #packageNameToPlatformPropertiesMap.
			#('Rowan-Cypress-Kernel' 'Rowan-GemStone-Kernel' 'Rowan-Tools-Kernel' 'GemStone-Interactions-Kernel' 'Rowan-GemStone-3215') 
				do: [:packageName | 
					| map | 
					map := packagePropertiesMap at: packageName.
					self assert: (map at: 'symbolDictName') = 'Globals' ].

			#('Rowan-GemStone-Loader') 
				do: [:packageName | 
					| map | 
					map := packagePropertiesMap at: packageName.
					self assert: (map at: 'symbolDictName') = 'RowanLoader' ] ]
		ifFalse: [
			"default"
			self assert: (packageMapSpecs at: #'defaultSymbolDictName') = 'UserGlobals'.
			self assert: (packageMapSpecs at: #'defaultUseSessionMethodsForExtensions') = false ]
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitProjectLoadConfiguration_gs3_2_14

	| url rowanProject config visitor packageNames |
	rowanProject := self _rowanProject.
	url := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: { 'common'. 'gemstone'. '3.2.14' asRwGemStoneVersionNumber};
		groupNames: #('core' 'tests');
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = self _expectedLoadPackageNames_gs3_2_14.
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitProjectLoadConfiguration_gs3_2_15

	| url rowanProject config visitor packageNames x |
	rowanProject := self _rowanProject.
	url := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: { 'common'. 'gemstone'. '3.2.15' asRwGemStoneVersionNumber};
		groupNames: #('core' 'tests');
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = (x := self _expectedLoadPackageNames_gs3_2_15).
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitProjectLoadConfiguration_gs3_2_16

	| url rowanProject config visitor packageNames x |
	rowanProject := self _rowanProject.
	url := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: { 'common'. 'gemstone'. '3.2.16' asRwGemStoneVersionNumber};
		groupNames: #('core' 'tests');
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = (x := self _expectedLoadPackageNames_gs3_2_16).
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitProjectLoadConfiguration_gs3_2_18

	| url rowanProject config visitor packageNames x |
	rowanProject := self _rowanProject.
	url := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: { 'common'. 'gemstone'. '3.2.18' asRwGemStoneVersionNumber};
		groupNames: #('core' 'tests');
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = (x := self _expectedLoadPackageNames_gs3_2_18).
%

category: 'tests'
method: RwProjectConfigurationsTest
testVisitProjectLoadConfiguration_gs3_3_0

	| url rowanProject config visitor packageNames x |
	rowanProject := self _rowanProject.
	url := 'file:' , rowanProject repositoryRootPath , '/test/configs/RowanProjectLoadConfiguration.ston'.

	config := RwAbstractProjectConfiguration fromUrl: url.

	visitor := RwProjectLoadConfigurationVisitor new
		platformAttributes: { 'common'. 'gemstone'. '3.3.0' asRwGemStoneVersionNumber};
		groupNames: #('core' 'tests');
		yourself.
	visitor visit: config.

	packageNames := visitor packageNames asArray sort.

	self assert: packageNames = (x := self _expectedLoadPackageNames_gs3_3_0).
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedCompoundPackageNames

	^ #( 'Rowan-Configurations' 'Rowan-Core' 'Rowan-Cypress-Core' 'Rowan-Cypress-Kernel' 'Rowan-Definitions' 
			'Rowan-Deprecated' 'Rowan-GemStone-Core' 'Rowan-GemStone-Kernel' 'Rowan-GemStone-Loader' 
			'Rowan-GemStone-Loader-Extensions' 'Rowan-Services-Core' 'Rowan-Services-Extensions' 'Rowan-Services-Tests' 
			'Rowan-Specifications' 'Rowan-Tests' 'Rowan-Tools-Core' 'Rowan-Tools-Extensions' 'Rowan-Tools-Kernel' 'Rowan-Url-Core') sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_common

	^ #('Rowan-Url-Core' 'Rowan-Cypress-Core' 'Rowan-Cypress-Kernel' 'Rowan-Definitions' 
			'Rowan-Specifications' 'Rowan-Configurations' 'Rowan-Components-Kernel' 'Rowan-Components' 
			'Rowan-Core' 'Rowan-Tools-Core' 'Rowan-Tools-Kernel' 'Rowan-Tools-Extensions' 'Rowan-Tests') sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_common_core

	^ #('Rowan-Url-Core' 'Rowan-Cypress-Core' 'Rowan-Cypress-Kernel' 'Rowan-Definitions' 'Rowan-Specifications' 'Rowan-Configurations'
			'Rowan-Core' 'Rowan-Tools-Core' 'Rowan-Tools-Extensions' 'Rowan-Tools-Kernel') sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_common_core_tests

	^ (self _expectedLoadPackageNames_common_core, #('Rowan-Tests')) sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_common_deprecated

	^ (self _expectedLoadPackageNames_common_core , #('Rowan-Deprecated')) sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_common_tests

	^ self _expectedLoadPackageNames_common_core_tests
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_gemstone

	^ (self _expectedLoadPackageNames_common , 
			#('Rowan-Services-Extensions' 'Rowan-Services-Core' 'Rowan-GemStone-Core' 
					'Rowan-GemStone-Kernel' 'Rowan-GemStone-Loader' 'Rowan-GemStone-Components'
					'Rowan-GemStone-Components-Extensions'
					'Rowan-GemStone-Loader-Extensions' 'Rowan-Services-Tests' ) ) sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_gs3_2_14

	^ (self _expectedLoadPackageNames_gemstone , 
			#('Rowan-GemStone-32' 'Rowan-Url-32' 'GemStone-Interactions-Core' 'GemStone-Interactions-Kernel') ) sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_gs3_2_15

	^ (self _expectedLoadPackageNames_gemstone , 
			#('Rowan-GemStone-3215' 'Rowan-Url-3215' 'Rowan-GemStone-3215.x' 'Rowan-Url-3215.x' 'Rowan-GemStone-3215x' 'Rowan-Url-3215x' 'Rowan-GemStone-3215x17'
					'Rowan-Url-3215x17' 'Rowan-GemStone-32' 'Rowan-Url-32' 'GemStone-Interactions-Core' 'GemStone-Interactions-Kernel') ) sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_gs3_2_16

	^ (self _expectedLoadPackageNames_gemstone , 
			#( 'Rowan-GemStone-3215x' 'Rowan-Url-3215x'  'Rowan-GemStone-3215x17'
					'Rowan-Url-3215x17' 'Rowan-GemStone-32' 'Rowan-Url-32' 'GemStone-Interactions-Core' 'GemStone-Interactions-Kernel') ) sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_gs3_2_18

	^ (self _expectedLoadPackageNames_gemstone , 
			#('Rowan-GemStone-32' 'Rowan-Url-32' 'Rowan-GemStone-3215x' 'Rowan-Url-3215x' 'GemStone-Interactions-Core' 'GemStone-Interactions-Kernel') ) sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_gs3_3_0

	^ (self _expectedLoadPackageNames_gemstone , 
			#( 'Rowan-GemStone-33' 'Rowan-Url-33' ) ) sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedRowanSampleProject4_LoadPackageNames

	^ #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 'RowanSample4-GemStone-Tests') sort
%

category: 'private'
method: RwProjectConfigurationsTest
_expectedRowan_LoadPackageNames

	^ (self _expectedLoadPackageNames_gemstone , 
			self _expectedLoadPackageNames_gemstone_version, 
			#('AST-Core' 'AST-Kernel-Core' 'AST-Kernel-Tests-Core' 'AST-Tests-Core' 
				'Rowan-GemStone-3215' 'Rowan-Url-3215' 'GemStone-Interactions-Core' 
				'GemStone-Interactions-Kernel' 'Rowan-Url-Extensions' 'Rowan-Kernel' 
				'Rowan-GemStone-Specifications' 'Rowan-Core-Definitions-Extensions' 
				'Rowan-GemStone-Definitions' 'Rowan-Cypress-Definitions' 'Rowan-Url-Cypress' 
				'Rowan-Tools-GemStone' 'Rowan-Tools-Extensions-GemStone') ) sort
%

category: 'private'
method: RwProjectConfigurationsTest
_rowanProject

	^ Rowan image loadedProjectNamed: 'Rowan'
%

! Class implementation for 'RwSemanticVersionNumber200TestCase'

!		Instance methods for 'RwSemanticVersionNumber200TestCase'

category: 'tests'
method: RwSemanticVersionNumber200TestCase
testGitDescribe

	"https://github.com/GemTalk/Rowan/issues/381#issuecomment-450502212"

	"
`git describe --match v0.0.1` can produce a version number that looks like the following v0.0.1-1-g832d2b5 ... ensure that we can use this result to compare version numbers ... the leading `-` needs to be transformed to `+`, but other than that I think that the following comparisons are correct for what we are trying to do o
	"
	| s1 s2 s3 s4 v1 v2 v3 v4 |
	s1 := '0.0.1'.
	s2 := '0.0.1+1-g832d2b5'. "git describe output .. compares equal to 0.0.1, which is acceptable - I think"
	s3 := '0.0.1+2-g59a4bdf'.	"git describe output .. compares equal to 0.0.1, which is acceptable - I think"
	s4 := '0.0.2'.

	v1 := s1 asRwSemanticVersionNumber.
	v2 := s2 asRwSemanticVersionNumber.
	v3 := s3 asRwSemanticVersionNumber.
	v4 := s4 asRwSemanticVersionNumber.

	self assert: v1 printString = s1.
	self assert: v2 printString = s2.
	self assert: v3 printString = s3.
	self assert: v4 printString = s4.

	self assert: v1 = v2.	"acceptable, I think"

	self assert: v1 = v3.	"acceptable, I think"
	self assert: v2 = v3.	"acceptable, I think"

	self assert: v1 < v4.
	self assert: v2 < v4.
	self assert: v3 < v4.

	self assert: v1 = v1.
	self assert: v2 = v2.
	self assert: v3 = v3.
	self assert: v4 = v4.
%

category: 'tests'
method: RwSemanticVersionNumber200TestCase
testSpec_02

	"
A normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.
	"
	| s1 s2 s3 v1 v2 v3 |
	s1 := '1.9.0' .
	s2 := '1.10.0' .
	s3 := '1.11.0' .

	v1 := s1 asRwSemanticVersionNumber.
	v2 := s2 asRwSemanticVersionNumber.
	v3 := s3 asRwSemanticVersionNumber.

	self assert: v1 printString = s1.
	self assert: v2 printString = s2.
	self assert: v3 printString = s3.

	self assert: v1 < v2.
	self assert: v2 < v3.
	self assert: v1 < v3.

	self assert: v1 = v1.
	self assert: v2 = v2.
	self assert: v3 = v3.
%

category: 'tests'
method: RwSemanticVersionNumber200TestCase
testSpec_09

	"
A pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphen
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
	"
	| s1 s2 s3 s4 s5 v1 v2 v3 v4 v5 |
	s1 := '1.0.0-alpha' .
	s2 := '1.0.0-alpha.1' .
	s3 := '1.0.0-0.3.7' .
	s4 := '1.0.0-x.7.z.92' .

	s5 := '1.0.0' .

	v1 := s1 asRwSemanticVersionNumber.
	v2 := s2 asRwSemanticVersionNumber.
	v3 := s3 asRwSemanticVersionNumber.
	v4 := s4 asRwSemanticVersionNumber.
	v5 := s5 asRwSemanticVersionNumber.

	self assert: v1 printString = s1.
	self assert: v2 printString = s2.
	self assert: v3 printString = s3.
	self assert: v4 printString = s4.

	self assert: v1 < v5.
	self assert: v2 < v5.
	self assert: v3 < v5.
	self assert: v4 < v5.

	self assert: v1 = v1.
	self assert: v2 = v2.
	self assert: v3 = v3.
	self assert: v4 = v4.
	self assert: v5 = v5.
%

category: 'tests'
method: RwSemanticVersionNumber200TestCase
testSpec_10

	"
Build metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.
	"

	| s1 s2 s3 s4 v1 v2 v3 v4 |
	s1 := '1.0.0-alpha+001' .
	s2 := '1.0.0-beta+exp.sha.5114f85' .
	s3 := '1.0.0+20130313144700' .
	s4 := '1.0.0+99999999999999' .

	v1 := s1 asRwSemanticVersionNumber.
	v2 := s2 asRwSemanticVersionNumber.
	v3 := s3 asRwSemanticVersionNumber.
	v4 := s4 asRwSemanticVersionNumber.

	self assert: v1 printString = s1.
	self assert: v2 printString = s2.
	self assert: v3 printString = s3.
	self assert: v4 printString = s4.

	self assert: v1 < v2.
	self assert: v2 < v3.
	self assert: v1 < v3.
	self assert: v1 < v4.

	self assert: v1 = v1.
	self assert: v2 = v2.
	self assert: v3 = v3.
	self assert: v4 = v4.
	self assert: v4 = v3.
%

category: 'tests'
method: RwSemanticVersionNumber200TestCase
testSpec_11

	"
Precedence refers to how versions are compared to each other when ordered.
Precedence MUST be calculated by separating the version into major, minor, patch
and pre-release identifiers in that order (Build metadata does not figure
into precedence). Precedence is determined by the first difference when
comparing each of these identifiers from left to right as follows: Major, minor,
and patch versions are always compared numerically. Example: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. When major, minor, and patch are equal, a pre-release version has
lower precedence than a normal version. Example: 1.0.0-alpha < 1.0.0. Precedence
for two pre-release versions with the same major, minor, and patch version MUST
be determined by comparing each dot separated identifier from left to right
until a difference is found as follows: identifiers consisting of only digits
are compared numerically and identifiers with letters or hyphens are compared
lexically in ASCII sort order. Numeric identifiers always have lower precedence
than non-numeric identifiers. A larger set of pre-release fields has a higher
precedence than a smaller set, if all of the preceding identifiers are equal.
Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
	"

	| vrsns vrsna vrsnb |
	vrsns := #( '1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-alpha.beta' '1.0.0-beta' '1.0.0-beta.2' '1.0.0-beta.11' '1.0.0-rc.1' '1.0.0').
	vrsns
		do: [:str |
			vrsnb := str asRwSemanticVersionNumber.
			self assert: vrsnb printString = str.
			self assert: vrsnb = vrsnb.
			vrsna ifNotNil: [ self assert: vrsna < vrsnb ].
			vrsna := vrsnb ].
	vrsna := nil.
	vrsns reverse
		do: [:str |
			vrsnb := str asRwSemanticVersionNumber.
			self assert: vrsnb printString = str.
			self assert: vrsnb = vrsnb.
			vrsna ifNotNil: [ self assert: vrsna > vrsnb ].
			vrsna := vrsnb ].

	self deny: '1.0.0-alpha.beta' asRwSemanticVersionNumber < '1.0.0-alpha.1' asRwSemanticVersionNumber
%

! Class implementation for 'RwSemanticVersionNumberTestCase'

!		Class methods for 'RwSemanticVersionNumberTestCase'

category: 'Tests'
classmethod: RwSemanticVersionNumberTestCase
shouldInheritSelectors

	^true
%

!		Instance methods for 'RwSemanticVersionNumberTestCase'

category: 'tests'
method: RwSemanticVersionNumberTestCase
sampleVersionStrings
    ^ #('1.0.0+-' '1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-0.3.7' '1.0.0-x.7.z.92')
        , #('1.0.0+build.1' '1.3.7+build.11.e0f985a')
        ,
            #('1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-beta.2' '1.0.0-beta.11' '1.0.0-rc.1' '1.0.0-rc.1+build.1' '1.0.0' '1.0.0+0.3.7' '1.3.7+build' '1.3.7+build.2.b8f12d7' '1.3.7+build.11.e0f985a')
        , #('1.0.0-alp-h-a' '1.0.0-r-c.1' '1.0.0+alp-h-a' '1.0.0+r-c.1')
%

category: 'test alpha/numeric version numbers'
method: RwSemanticVersionNumberTestCase
testAlphaNumericVersion1

	"Use numeric comparison for pure numbers. If you non-numeric version separate with '-'"
	
	| x y |
	self assert: ((x := self versionClass fromString: '2.9.0') < (y := self versionClass fromString: '2.10.0')).
%

category: 'test alpha/numeric version numbers'
method: RwSemanticVersionNumberTestCase
testAlphaNumericVersion2

	self assert: ((self versionClass fromString: '2.9.0-alpha.2') < (self versionClass fromString: '2.9.0-alpha.3')).
%

category: 'test alpha/numeric version numbers'
method: RwSemanticVersionNumberTestCase
testAlphaNumericVersion3

	self assert: ((self versionClass fromString: '2.9.9-alpha.2') < (self versionClass fromString: '2.9.10')).
%

category: 'test alpha/numeric version numbers'
method: RwSemanticVersionNumberTestCase
testAlphaNumericVersion4

	self assert: ((self versionClass fromString: '2.9.9-alpha.2') < (self versionClass fromString: '2.9.9')).
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testEqualityComparison
    self deny: '1.0.0+-' asRwSemanticVersionNumber = '1.0.0--' asRwSemanticVersionNumber.
	self assert: '1.0.0+-' asRwSemanticVersionNumber = '1.0.0+a' asRwSemanticVersionNumber.
	self sampleVersionStrings
        do: [ :versionString | self assert: versionString asRwSemanticVersionNumber = versionString asRwSemanticVersionNumber ]
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testLessThanComparison
    self assert: '1.0.0-rc.1+build.1' asRwSemanticVersionNumber < '1.0.0' asRwSemanticVersionNumber.
    self
        assert: '1.0.0-rc.1+build.1' asRwSemanticVersionNumber < '1.0.0+build.0' asRwSemanticVersionNumber.
    self assert:  '1.0.0-0.3.7' asRwSemanticVersionNumber < '1.0.0-alpha.1' asRwSemanticVersionNumber.
    self assert: '1.0.0-alpha' asRwSemanticVersionNumber < '1.0.0-alpha.1' asRwSemanticVersionNumber.
    self assert: '1.0.0-0.3.7' asRwSemanticVersionNumber < '1.0.0-x.7.z.92' asRwSemanticVersionNumber
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testOfficialInvalidSemanticVersions
	"https://github.com/semver/semver/issues/232#issuecomment-430813095"

	"https://github.com/GemTalk/Rowan/issues/381"

    | vrsn |
    {
		'1'.
		'1.2'.
		'1.2.3-0123'.
		'1.2.3-0123.0123'.
		'1.1.2+.123'.
		'+invalid'.
		'-invalid'.
		'-invalid+invalid'.
		'-invalid.01'.
		'alpha'.
		'alpha.beta'.
		'alpha.beta.1'.
		'alpha.1'.
		'alpha+beta'.
		'alpha_beta'.
		'alpha.'.
		'alpha..'.
		'beta'.
		'1.0.0-alpha_beta'.
		'-alpha.'.
		'1.0.0-alpha..'.
		'1.0.0-alpha..1'.
		'1.0.0-alpha...1'.
		'1.0.0-alpha....1'.
		'1.0.0-alpha.....1'.
		'1.0.0-alpha......1'.
		'1.0.0-alpha.......1'.
		'01.1.1'.
		'1.01.1'.
		'1.1.01'.
		'1.2'.
		'1.2.3.DEV'.
		'1.2-SNAPSHOT'.
		'1.2.31.2.3----RC-SNAPSHOT.12.09.1--..12+788'.
		'1.2-RC-SNAPSHOT'.
		'-1.0.3-gamma+b7718'.
		'+justmeta'.
		'9.8.7+meta+meta'.
		'9.8.7-whatever+meta+meta'.
		'99999999999999999999999.999999999999999999.99999999999999999----RC-SNAPSHOT.12.09.1--------------------------------..12'.
	}
	do: [ :versionString |
		self should: [ vrsn := versionString asRwSemanticVersionNumber ] raise: Error ]
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testOfficialValidSemanticVersions
	"https://github.com/semver/semver/issues/232#issuecomment-430813095"

	"https://github.com/GemTalk/Rowan/issues/381"

	| x vrsn |
    {
		'0.0.0'.
		'0.0.1'.
		'0.0.4'.
		'1.2.3'.
		'10.20.30'.
		'1.1.2-prerelease+meta'.
		'1.1.2+meta'.
		'1.1.2+meta-valid'.
		'1.0.0-alpha'.
		'1.0.0-beta'.
		'1.0.0-alpha.beta'.
		'1.0.0-alpha.beta.1'.
		'1.0.0-alpha.1'.
		'1.0.0-alpha0.valid'.
		'1.0.0-alpha.0valid'.
		'1.0.0-alpha-a.b-c-somethinglong+build.1-aef.1-its-okay'.
		'1.0.0-rc.1+build.1'.
		'2.0.0-rc.1+build.123'.
		'1.2.3-beta'.
		'10.2.3-DEV-SNAPSHOT'.
		'1.2.3-SNAPSHOT-123'.
		'1.0.0'.
		'2.0.0'.
		'1.1.7'.
		'2.0.0+build.1848'.
		'2.0.1-alpha.1227'.
		'1.0.0-alpha+beta'.
		'1.2.3----RC-SNAPSHOT.12.9.1--.12+788'.
		'1.2.3----R-S.12.9.1--.12+meta'.
		'1.2.3----RC-SNAPSHOT.12.9.1--.12'.
		'1.0.0+0.build.1-rc.10000aaa-kk-0.1'.
		'99999999999999999999999.999999999999999999.99999999999999999'.
		'1.0.0-0A.is.legal'.
		}
	do: [ :versionString | self assert: versionString = (x := (vrsn := versionString asRwSemanticVersionNumber) printString) ]
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testPrinting
    | x vrsn |
    self sampleVersionStrings
        do: [ :versionString | self assert: versionString = (x := (vrsn := versionString asRwSemanticVersionNumber) printString) ]
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testSemanticVersioning
    self validateSemanticVersionStrings: #('1.0.0-rc.1' '1.0.0-rc.1.0' '1.0.0-rc.2').
    self validateSemanticVersionStrings: #('1.0.0-rc.1' '1.0.0').
    self validateSemanticVersionStrings: #('1.0.0-1' '1.0.0-alpha').
    self validateSemanticVersionStrings: #('1.0.0-alpha' '1.0.0+1').
    self validateSemanticVersionStrings: #('1.0.0' '1.0.1').
    self validateSemanticVersionStrings: #('1.0.0--' '1.0.0-a').
    self validateSemanticVersionStrings: #('1.0.0-rc.1' '1.0.0' '1.0.1').
    self validateSemanticVersionStrings: #('1.0.0-rc.1' '1.0.0-rc.2' '1.0.0-rc.3').
    self validateSemanticVersionStrings: #('1.0.0-10000' '1.0.0-a')
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testSemanticVersioningSpecItem10
    "[Semantic Versioning 2.0.0-rc.1](http://semver.org/)"

    self validateSemanticVersionStrings: #( '1.0.0-0.3.7' '1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-x.7.z.92')
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testSemanticVersioningSubsetCompliance
    "subset of sample versions that are compatible with MetacellVersionNumber syntax"

    self
        validateSemanticVersionStrings:
            #('1.0.0-alpha' '1.0.0-alpha.1' '1.0.0-beta.2' '1.0.0-beta.11' '1.0.0-rc.1' '1.0.0')
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion01

	self assert: ((self versionClass fromString: '1.1.1') versionString = '1.1.1')
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion02

	| v1 v2 |
	v1 := self versionClass fromString: '1.1.1'.
	v2 := self versionClass fromString: '1.0.0'.
	self assert: (v1 = v1).	
	self assert: (v2 = v2).
	self assert: (v1 > v2)
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion04

	| v1 v2 |
	v1 := self versionClass fromString: '1.0.1'.
	v2 := self versionClass fromString: '1.0.0'.
	self assert: (v1 > v2)
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion05
    | v1 v2 |
    v1 := self versionClass fromString: '3.0.0'.
    v2 := self versionClass fromString: '2.0.0'.
    self assert: v1 > v2
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion09
    | v1 v2 |
    v1 := self versionClass fromString: '1.0.0'.
    v2 := self versionClass fromString: '0.7.0'.
    self assert: v1 >= v2.
    self assert: v2 <= v1
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion10
    | x y |
    self
        assert:
            (x := (({(self versionClass fromString: '1.0.0').
            (self versionClass fromString: '0.7.0').
            (self versionClass fromString: '0.8.0').
            (self versionClass fromString: '0.9.0').
            (self versionClass fromString: '1.0.1')} sort: [ :a :b | a <= b ]) collect: [ :each | each versionString ])
                asArray) = (y := #('0.7.0' '0.8.0' '0.9.0' '1.0.0' '1.0.1'))
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion12
    self deny: (self versionClass fromString: '1.0.0') <= (self versionClass fromString: '0.7.0')
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion14

	self assert: ((self versionClass fromString: '2.9.0-alpha02') < (self versionClass fromString: '2.9.0-alpha03')).
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion15
    self assert: (self versionClass fromString: '1.0.0-beta.0') < (self versionClass fromString: '1.0.0-beta.1')
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion16
    self assert: (self versionClass fromString: '1.0.0-beta.0') < (self versionClass fromString: '1.0.0')
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion17
    self assert: (self versionClass fromString: '1.0.0') > (self versionClass fromString: '1.0.0-0').
    self assert: (self versionClass fromString: '1.0.0') > (self versionClass fromString: '1.0.0-beta.0').
    self assert: (self versionClass fromString: '1.0.0') > (self versionClass fromString: '1.0.0-beta')
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion18
    | x y |
    self deny: (x := self versionClass fromString: '1.0.0') < (y := self versionClass fromString: '1.0.0-0').
    self assert: (x := self versionClass fromString: '1.0.0') > (y := self versionClass fromString: '1.0.0-0').
    self assert: (x := self versionClass fromString: '1.0.0') = (y := self versionClass fromString: '1.0.0+0').
 
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
testVersion19
    self assert: (self versionClass fromString: '1.0.0-beta.0') < (self versionClass fromString: '1.0.0')
%

category: 'tests'
method: RwSemanticVersionNumberTestCase
validateSemanticVersionStrings: versionStrings
    | versions version |
    versions := versionStrings collect: [ :each | each asRwSemanticVersionNumber ].
    version := versions at: 1.
    2 to: versions size do: [ :index | 
        | nextVersion |
        nextVersion := versions at: index.
        self assert: version < nextVersion.
        version := nextVersion ]
%

category: 'private'
method: RwSemanticVersionNumberTestCase
versionClass
    ^ RwSemanticVersionNumber
%

! Class implementation for 'RwSentButNotImplementedTest'

!		Instance methods for 'RwSentButNotImplementedTest'

category: 'test'
method: RwSentButNotImplementedTest
testSentButNotImplemented
	| sentNotImplemented |
	sentNotImplemented := self _sentButNotImplemented.
	sentNotImplemented
		keysAndValuesDo: [ :meth :selectors | 
			Transcript
				cr;
				show: 'Sent but not implemented from ' , meth printString.
			selectors
				do: [ :sel | 
					Transcript
						cr;
						tab;
						show: sel printString ] ].
	self assert: sentNotImplemented isEmpty description: sentNotImplemented size asString, ' sent but not implemented selectors'
%

category: 'private'
method: RwSentButNotImplementedTest
_sentButNotImplemented
	"return a map so that references to unimplemented selectors can be found"

	| sent implemented map notImplemented notImplementedMap |
	sent := IdentitySet new.
	implemented := IdentitySet new.
	map := IdentityDictionary new.
	ClassOrganizer new classes
		do: [ :class | 
			| metaClass |
			class selectors
				do: [ :sel | 
					| meth |
					implemented add: sel.
					meth := class compiledMethodAt: sel.
					map at: meth put: meth _selectorPool.
					sent addAll: meth _selectorPool ].
			metaClass := class class.
			metaClass selectors
				do: [ :sel | 
					| meth |
					implemented add: sel.
					meth := metaClass compiledMethodAt: sel.
					map at: meth put: meth _selectorPool.
					sent addAll: meth _selectorPool ] ].
	notImplemented := sent - implemented.
	notImplemented removeAllPresent: self _specialCases.
	notImplementedMap := SymbolKeyValueDictionary new.
	notImplemented
		do: [ :sel | 
			map
				keysAndValuesDo: [ :meth :selectors | 
					(selectors includes: sel)
						ifTrue: [ 
							| methName |
							methName := (meth homeMethod inClass printString , '>>'
								, meth homeMethod selector asString) asSymbol.
							(notImplementedMap
								at: methName
								ifAbsent: [ notImplementedMap at: methName put: IdentitySet new ])
								add: sel ] ] ].
	^ notImplementedMap
%

category: 'private'
method: RwSentButNotImplementedTest
_specialCases
	| nonImplemented |
	nonImplemented := Set new.
	(self class allSelectors
		select: [ :ea | ea beginsWith: 'nonImplementedSelectors' ])
		do: [ :selector | nonImplemented addAll: (self perform: selector) ].
	^ nonImplemented
%

! Class extensions for 'RwBrowserToolTest'

!		Instance methods for 'RwBrowserToolTest'

category: '*rowan-tests-components'
method: RwBrowserToolTest
_loadDiskProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName comment: comment format: format root: rootPath

	| projectDefinition projectTools |
	projectTools := Rowan projectTools.

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

	projectDefinition := (RwComponentProjectDefinition 
		projectName: projectName 
			projectHome: rootPath "?" 
			useGit: true 
			comment: comment)
		defaultSymbolDictName: defaultSymbolDictName;
		configsPath: 'configs';
		packagesPath: 'src';
		projectsPath: 'projects';
		specsPath: 'specs';
		packageNames: packageNames;
		yourself.

	(rootPath asFileReference / projectName) ensureDeleteAll.

	self
		handleConfirmationDuring: [ projectDefinition create ].

	projectTools load loadProjectDefinition: projectDefinition.
	^ projectDefinition
%

category: '*rowan-tests-35x'
method: RwBrowserToolTest
_standardProjectDefinition: projectName packageNames: packageNames defaultSymbolDictName: defaultSymbolDictName defaultUseSessionMethodsForExtensions: defaultUseSessionMethodsForExtensions comment: comment

	^ (RwComponentProjectDefinition newForGitBasedProjectNamed: projectName)
		defaultSymbolDictName: defaultSymbolDictName;
		defaultUseSessionMethodsForExtensions: defaultUseSessionMethodsForExtensions;
		packageNames: packageNames;
		comment: comment;
		yourself.
%

! Class extensions for 'RwGsImage'

!		Class methods for 'RwGsImage'

category: '*rowan-tests-gemstone'
classmethod: RwGsImage
testImageClass

	"answer an alternate image class (presumably a subclass of the receiver) that can be used as the image class for the duration of tests"

	^ RwGsTestImage
%

! Class extensions for 'RwHybridBrowserToolTest'

!		Instance methods for 'RwHybridBrowserToolTest'

category: '*rowan-tests-gemstone'
method: RwHybridBrowserToolTest
testHybridClassCreationWithClassCreationTemplate_292

	"https://github.com/dalehenrich/Rowan/issues/292"

	|  class projectName packageNames packageName1 template expectedTemplate oldClass |
	projectName := 'Hybrid Project A'.
	packageName1 := 'HybridA-Core'.
	packageNames := {packageName1}.

	self
		_loadProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project'.
"1 create class - indexable"
	class := Object
		rwIndexableSubclass: 'TestVariableClass'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	template := Rowan projectTools browser
		classCreationTemplateForClass: class
		hybridBrowser: true.
	expectedTemplate := 'Object rwIndexableSubclass: ''TestVariableClass''
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: ', packageName1 printString, '
	options: #()
'.
	self assert: template = expectedTemplate.

"2 create subclass - indexable"
	oldClass := class.
	class := oldClass
		rwIndexableSubclass: 'TestVariableSubclass'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	template := Rowan projectTools browser
		classCreationTemplateForClass: class
		hybridBrowser: true.
	expectedTemplate := 'TestVariableClass rwSubclass: ''TestVariableSubclass''
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: ', packageName1 printString, '
	options: #()
'.
	self assert: template = expectedTemplate.

"1 create class - byteSubclass"
	class := Object
		rwByteSubclass: 'TestByteClass'
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	template := Rowan projectTools browser
		classCreationTemplateForClass: class
		hybridBrowser: true.
	expectedTemplate := 'Object rwByteSubclass: ''TestByteClass''
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: ', packageName1 printString, '
	options: #()
'.
	self assert: template = expectedTemplate.

"2 create subclass - byteSubclass"
	oldClass := class.
	class := oldClass
		rwSubclass: 'TestByteSubclass'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	template := Rowan projectTools browser
		classCreationTemplateForClass: class
		hybridBrowser: true.
	expectedTemplate := 'TestByteClass rwSubclass: ''TestByteSubclass''
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: ', packageName1 printString, '
	options: #()
'.
	self assert: template = expectedTemplate.

"1 create class - disallowGciStore"
	class := Error
		rwSubclass: 'TestErrorClass'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	template := Rowan projectTools browser
		classCreationTemplateForClass: class
		hybridBrowser: true.
	expectedTemplate := 'Error rwSubclass: ''TestErrorClass''
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: ', packageName1 printString, '
	options: #()
'.
	self assert: template = expectedTemplate.

"1 create class - traverseByCallback"
	class := RcIdentityBag
		rwSubclass: 'TestRcIdentityBagClass'
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().

	template := Rowan projectTools browser
		classCreationTemplateForClass: class
		hybridBrowser: true.
	expectedTemplate := 'RcIdentityBag rwSubclass: ''TestRcIdentityBagClass''
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	category: ', packageName1 printString, '
	options: #()
'.
	self assert: template = expectedTemplate.
%

category: '*rowan-tests-components'
method: RwHybridBrowserToolTest
testHybridComplicatedProjectLoad

	"Write project to disk, make a few modifications and then reload the project from disk"

	| normalClass1 normalClass2 projectName packageNames packageName1 packageName2 normalInstance1 
		normalInstance2 projectTools className1 className2 theLoadedProject theLoadedPackage 
		theLoadedClassOrClassExtension writtenStateValidationBlock classNames oldNormalClass2 
		projectDefinition useExport |

	useExport := false.

	projectName := 'HybridPatchProjectA'.
	packageName1 := 'Hybrid-Patch-Core'.
	packageName2 := 'Hybrid-Patch-Extensions'.
	packageNames := {packageName1.
	packageName2}.
	projectDefinition := self
		_loadDiskProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project package patch test'
		format: 'tonel'
		root: self _testRowanProjectsSandbox pathString, '/rowanHybridPatchProject/'.
	className1 := 'SimpleHybridNormalReload1'.
	className2 := 'SimpleHybridNormalReload2'.
	classNames := {className1.
	className2}.

	normalClass1 := Object
		rwSubclass: className1
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass1 rowanPackageName = packageName1.

	normalClass1 
		rwCompileMethod:  'foo ^''foo''' 
		category: 'accessing'.
	normalClass1 class
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

	self assert: (normalClass1 perform: #bar) = 'bar'.
	normalInstance1 := normalClass1 new.
	self assert: (normalInstance1 perform: #foo) = 'foo'.

	normalClass2 := Object
		rwSubclass: className2
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass2 rowanPackageName = packageName1.

	normalInstance2 := normalClass2 new.
	self should: [ normalInstance2 perform: #biz ] raise: MessageNotUnderstood.
	self should: [ normalInstance2 perform: #biff ] raise: MessageNotUnderstood.

	projectTools := Rowan projectTools.
	projectDefinition exportSpecification.	"when should the spec be exported? ... not on every write since we do expect the spec to manually modified over time"
	useExport
		ifTrue: [ projectDefinition export ]
		ifFalse: [ projectTools write writeProjectNamed: projectName ].
	projectTools commit
		commitProjectNamed: projectName
		message:
			'Added SimpleHybridNormalReload1 and SimpleHybridNormalReload2 classes and extension methods'.

	writtenStateValidationBlock := [ 
	theLoadedProject := Rowan image loadedProjectNamed: projectName.	"Traverse the loaded package structure and verify that it matches the original expected structure"

	theLoadedProject
		loadedPackagesDo: [ :loadedProject :loadedPackage | 
			self assert: theLoadedProject == loadedProject.
			theLoadedPackage := loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			self assert: (packageNames includes: loadedPackage name) ]
		loadedClassedDo: [ :loadedProject :loadedPackage :loadedClass | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			theLoadedClassOrClassExtension := loadedClass.

			loadedPackage name = packageName1
				ifTrue: [ 
					loadedClass name = className1
						ifTrue: [ self assert: (loadedClass propertyAt: 'instvars') isEmpty ]
						ifFalse: [ 
							loadedClass name = className2
								ifTrue: [ self assert: (loadedClass propertyAt: 'instvars') isEmpty ]
								ifFalse: [ 
									self
										assert: false
										description:
											'Unexpected loaded class ' , loadedClass name printString , ' in '
												, packageName2 ] ] ]
				ifFalse: [ self assert: false description: 'No class expected in ' , packageName2 ] ]
		loadedClassExtensionsDo: [ :loadedProject :loadedPackage :loadedClassExtension | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			theLoadedClassOrClassExtension := loadedClassExtension.

			loadedPackage name = packageName1
				ifTrue: [ 
					self
						assert: false
						description: 'no classes expected in ' , packageName1 printString ].
			loadedPackage name = packageName2
				ifTrue: [ self assert: (classNames includes: loadedClassExtension name) ] ]
		loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			self assert: theLoadedClassOrClassExtension == loadedClassOrClassExtension.

			loadedPackage name = packageName1
				ifTrue: [ self assert: (#(#'foo') includes: loadedMethod selector) ].
			loadedPackage name = packageName2
				ifTrue: [ 
					self assert: false description: 'no instance methods expected in '.
					packageName2 ] ]
		loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
			loadedPackage name = packageName1
				ifTrue: [ 
					self
						assert: false
						description: 'no instance methods expected in ' , packageName1 ].
			loadedPackage name = packageName2
				ifTrue: [ self assert: (#(#'bar') includes: loadedMethod selector) ] ] ].

	writtenStateValidationBlock value.

	normalClass1 := Object
		rwSubclass: className1
		instVarNames: #('ivar1')
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().	"add new instance variable to class"

	normalInstance1 := normalClass1 new.

	normalClass1 rwCompileMethod: 'foo "comment" ^''foo''' category: 'accessing'.	"change method"
	normalClass1 rwCompileMethod: 'ivar1 ^ivar1' category: 'accessing'.	"add new instance method"
	normalClass1 class
		rwCompileMethod: 'baz ^''baz'''
		category: '*' , packageName2 asLowercase.	"add new class-side method"
	normalClass1 class rwRemoveSelector: #'bar'.	"remove existing method"

	self assert: (normalInstance1 perform: #foo) = 'foo'.
	self assert: (normalInstance1 perform: #ivar1) = nil.
	self assert: (normalClass1 perform: #baz) = 'baz'.
	self should: [ normalClass1 perform: #bar ] raise: MessageNotUnderstood.

	normalClass2 rwCompileMethod: 'biz ^''biz''' category: 'accessing'.	"add new instance method"
	normalClass2
		rwCompileMethod: 'biff ^''biff'''
		category: '*' , packageName2 asLowercase.	"add new class-side method"

	normalInstance2 := normalClass2 new.
	self assert: (normalInstance2 perform: #biz) = 'biz'.
	self assert: (normalInstance2 perform: #biff) = 'biff'.

	theLoadedProject := Rowan image loadedProjectNamed: projectName.	"Traverse the loaded package structure and verify that it matches the expected structure"

	theLoadedProject
		loadedPackagesDo: [ :loadedProject :loadedPackage | 
			self assert: theLoadedProject == loadedProject.
			theLoadedPackage := loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			self assert: (packageNames includes: loadedPackage name) ]
		loadedClassedDo: [ :loadedProject :loadedPackage :loadedClass | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			theLoadedClassOrClassExtension := loadedClass.

			loadedPackage name = packageName1
				ifTrue: [ 
					loadedClass name = className1
						ifTrue: [ self assert: (loadedClass propertyAt: 'instvars') = #('ivar1') ]
						ifFalse: [ 
							loadedClass name = className2
								ifTrue: [ self assert: (loadedClass propertyAt: 'instvars') isEmpty ]
								ifFalse: [ 
									self
										assert: false
										description:
											'Unexpected loaded class ' , loadedClass name printString , ' in '
												, packageName2 ] ] ]
				ifFalse: [ self assert: false description: 'No class expected in ' , packageName2 ] ]
		loadedClassExtensionsDo: [ :loadedProject :loadedPackage :loadedClassExtension | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			theLoadedClassOrClassExtension := loadedClassExtension.

			loadedPackage name = packageName1
				ifTrue: [ 
					self
						assert: false
						description: 'no classes expected in ' , packageName1 printString ].
			loadedPackage name = packageName2
				ifTrue: [ self assert: (classNames includes: loadedClassExtension name) ] ]
		loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			self assert: theLoadedClassOrClassExtension == loadedClassOrClassExtension.

			loadedPackage name = packageName1
				ifTrue: [ 
					loadedMethod loadedClass name = className1
						ifTrue: [ self assert: (#(#'foo' #'ivar1') includes: loadedMethod selector) ]
						ifFalse: [ 
							loadedMethod loadedClass name = className2
								ifTrue: [ self assert: (#(#'biz') includes: loadedMethod selector) ]
								ifFalse: [ 
									self
										assert: false
										description:
											'Unexpected loaded method ' , loadedMethod selector printString , ' in '
												, packageName1 ] ] ].
			loadedPackage name = packageName2
				ifTrue: [ 
					loadedMethod loadedClass name = className2
						ifTrue: [ self assert: (#(#'biff') includes: loadedMethod selector) ]
						ifFalse: [ 
							self
								assert: false
								description:
									'Unexpected loaded method ' , loadedMethod selector printString , ' in '
										, packageName2 ] ] ]
		loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
			loadedPackage name = packageName1
				ifTrue: [ 
					self
						assert: false
						description: 'no instance methods expected in ' , packageName1 ].
			loadedPackage name = packageName2
				ifTrue: [ self assert: (#(#'baz') includes: loadedMethod selector) ] ].

	projectTools load loadProjectNamed: projectName.	"restore original state of project"

	normalClass1 := Rowan globalNamed: className1.
	normalInstance1 := normalClass1 new.

	self assert: (normalClass1 perform: #bar) = 'bar'.
	self assert: (normalInstance1 perform: #foo) = 'foo'.
	self should: [ normalInstance1 perform: #ivar1 ] raise: MessageNotUnderstood.
	self should: [ normalClass1 perform: #baz = 'baz' ] raise: MessageNotUnderstood.

	oldNormalClass2 := normalClass2.
	normalClass2 := Rowan globalNamed: className2.
	self assert: oldNormalClass2 == normalClass2.
	normalInstance2 := normalClass2 new.
	self should: [ normalInstance2 perform: #biz ] raise: MessageNotUnderstood.
	self should: [ normalInstance2 perform: #biff ] raise: MessageNotUnderstood.

	writtenStateValidationBlock value	"verify that original state is restored"
%

category: '*rowan-tests-components'
method: RwHybridBrowserToolTest
testHybridProjectLoad

	"Write project to disk, make a few modifications and then reload the project from disk"

	| normalClass projectName packageNames packageName1 packageName2 fooMethod 
		barMethod normalInstance projectTools bazMethod ivar1Method className 
		theLoadedProject theLoadedPackage theLoadedClassOrClassExtension 
		writtenStateValidationBlock project |
	projectName := 'HybridPatchProjectA'.
	packageName1 := 'Hybrid-Patch-Core'.
	packageName2 := 'Hybrid-Patch-Extensions'.
	packageNames := { packageName1 . packageName2 }.

	projectTools := Rowan projectTools.

	self
		_loadDiskProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: self _symbolDictionaryName1
		comment: 'hybrid browser project package patch test'
		format: 'tonel'
		root: self _testRowanProjectsSandbox pathString, '/rowanHybridPatchProject/'.
	className := 'SimpleHybridNormalReload'.

	normalClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	self assert: normalClass rowanPackageName = packageName1.

	fooMethod := normalClass rwCompileMethod: 'foo ^''foo''' category: 'accessing'.
	barMethod := normalClass class
		rwCompileMethod: 'bar ^''bar'''
		category: '*' , packageName2 asLowercase.

	self assert: (normalClass perform: #bar) = 'bar'.
	normalInstance := normalClass new.
	self assert: (normalInstance perform: #foo) = 'foo'.

	project := RwProject newNamed: projectName.
	project exportSpecification.
	projectTools write writeProjectNamed: projectName.
	projectTools commit
		commitProjectNamed: projectName
		message: 'Added Simple class and extension methods'.

	writtenStateValidationBlock := [ 
	theLoadedProject := Rowan image loadedProjectNamed: projectName.	"Traverse the loaded package structure and verify that it matches the original expected structure"

	theLoadedProject
		loadedPackagesDo: [ :loadedProject :loadedPackage | 
			self assert: theLoadedProject == loadedProject.
			theLoadedPackage := loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			self assert: (packageNames includes: loadedPackage name) ]
		loadedClassedDo: [ :loadedProject :loadedPackage :loadedClass | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			theLoadedClassOrClassExtension := loadedClass.

			loadedPackage name = packageName1
				ifTrue: [ 
					self assert: loadedClass name = className.
					self assert: (loadedClass propertyAt: 'instvars') isEmpty ]
				ifFalse: [ self assert: false description: 'No class expected in ' , packageName2 ] ]
		loadedClassExtensionsDo: [ :loadedProject :loadedPackage :loadedClassExtension | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			theLoadedClassOrClassExtension := loadedClassExtension.

			loadedPackage name = packageName1
				ifTrue: [ 
					self
						assert: false
						description: 'no classes expected in ' , packageName1 printString ].
			loadedPackage name = packageName2
				ifTrue: [ self assert: loadedClassExtension name = className ] ]
		loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			self assert: theLoadedClassOrClassExtension == loadedClassOrClassExtension.

			loadedPackage name = packageName1
				ifTrue: [ self assert: (#(#'foo') includes: loadedMethod selector) ].
			loadedPackage name = packageName2
				ifTrue: [ 
					self assert: false description: 'no instance methods expected in '.
					packageName2 ] ]
		loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
			loadedPackage name = packageName1
				ifTrue: [ 
					self
						assert: false
						description: 'no instance methods expected in ' , packageName1 ].
			loadedPackage name = packageName2
				ifTrue: [ self assert: (#(#'bar') includes: loadedMethod selector) ] ] ].

	writtenStateValidationBlock value.

	normalClass := Object
		rwSubclass: className
		instVarNames: #('ivar1')
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().	"add new instance variable to class"

	normalInstance := normalClass new.

	fooMethod := normalClass
		rwCompileMethod: 'foo "comment" ^''foo'''
		category: 'accessing'.	"change method"
	ivar1Method := normalClass
		rwCompileMethod: 'ivar1 ^ivar1'
		category: 'accessing'.	"add new instance method"
	bazMethod := normalClass class
		rwCompileMethod: 'baz ^''baz'''
		category: '*' , packageName2 asLowercase.	"add new class-side method"
	normalClass class rwRemoveSelector: #'bar'.	"remove existing method"

	self assert: (normalInstance perform: #foo) = 'foo'.
	self assert: (normalInstance perform: #ivar1) = nil.
	self assert: (normalClass perform: #baz) = 'baz'.
	self should: [ normalClass perform: #bar ] raise: MessageNotUnderstood.

	theLoadedProject := Rowan image loadedProjectNamed: projectName.	"Traverse the loaded package structure and verify that it matches the expected structure"

	theLoadedProject
		loadedPackagesDo: [ :loadedProject :loadedPackage | 
			self assert: theLoadedProject == loadedProject.
			theLoadedPackage := loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			self assert: (packageNames includes: loadedPackage name) ]
		loadedClassedDo: [ :loadedProject :loadedPackage :loadedClass | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			theLoadedClassOrClassExtension := loadedClass.

			loadedPackage name = packageName1
				ifTrue: [ 
					self assert: loadedClass name = className.
					self assert: (loadedClass propertyAt: 'instvars') = #('ivar1') ]
				ifFalse: [ self assert: false description: 'No class expected in ' , packageName2 ] ]
		loadedClassExtensionsDo: [ :loadedProject :loadedPackage :loadedClassExtension | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			theLoadedClassOrClassExtension := loadedClassExtension.

			loadedPackage name = packageName1
				ifTrue: [ 
					self
						assert: false
						description: 'no classes expected in ' , packageName1 printString ].
			loadedPackage name = packageName2
				ifTrue: [ self assert: loadedClassExtension name = className ] ]
		loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
			self assert: theLoadedProject == loadedProject.
			self assert: theLoadedPackage == loadedPackage.
			self
				assert:
					(Rowan image loadedPackageNamed: loadedPackage name) == loadedPackage.
			self assert: theLoadedClassOrClassExtension == loadedClassOrClassExtension.

			loadedPackage name = packageName1
				ifTrue: [ self assert: (#(#'foo' #'ivar1') includes: loadedMethod selector) ].
			loadedPackage name = packageName2
				ifTrue: [ 
					self assert: false description: 'no instance methods expected in '.
					packageName2 ] ]
		loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
			loadedPackage name = packageName1
				ifTrue: [ 
					self
						assert: false
						description: 'no instance methods expected in ' , packageName1 ].
			loadedPackage name = packageName2
				ifTrue: [ self assert: (#(#'baz') includes: loadedMethod selector) ] ].

	projectTools load loadProjectNamed: projectName.	"restore original state of project"

	normalClass := Rowan globalNamed: className.
	normalInstance := normalClass new.

	self assert: (normalClass perform: #bar) = 'bar'.
	self assert: (normalInstance perform: #foo) = 'foo'.
	self should: [ normalInstance perform: #ivar1 ] raise: MessageNotUnderstood.
	self should: [ normalClass perform: #baz = 'baz' ] raise: MessageNotUnderstood.

	writtenStateValidationBlock value	"verify that original state is restored"
%

! Class extensions for 'RwProjectConfigurationsTest'

!		Instance methods for 'RwProjectConfigurationsTest'

category: '*rowan-tests-gemstone'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_gemstone_tests

	^ #('Rowan-Tests-GemStone') sort
%

category: '*rowan-tests-35x'
method: RwProjectConfigurationsTest
_expectedLoadPackageNames_gemstone_version

	^ #( 'Rowan-Tests-35x' )
%

! Class extensions for 'RwProjectFiletreeTonelReaderWriterTest'

!		Instance methods for 'RwProjectFiletreeTonelReaderWriterTest'

category: '*rowan-tests-components'
method: RwProjectFiletreeTonelReaderWriterTest
testReadExistingDiskProject

	| rowanProject projectHome specUrlString projectDefinition projectDefinitionSet |	
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
    projectHome := rowanProject repositoryRootPath , '/test/testRepositories/'.

"identify spec to be used for reading project"
	specUrlString :=  'file:' , projectHome, '/Issue122/', self _repositoryFormat, '/rowan/specs/Issue122.ston'.

"create project definition"
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.
"point to directory where the disk project is located"
	projectDefinition projectHome: projectHome.

"read project"
	projectDefinitionSet := Rowan projectTools read 
		readProjectSetForComponentProjectDefinition: projectDefinition.

"validation"
	self _validateIssue122ProjectDefinitionSet: projectDefinitionSet projectName: projectDefinition name
%

category: '*rowan-tests-components'
method: RwProjectFiletreeTonelReaderWriterTest
testReadExistingDiskProjectWithBothMethodProtocolValidationError
	"https://github.com/GemTalk/Rowan/issues/122"

	"method protocol starts with a * for non-extension method"

	| rowanProject projectHome specUrlString projectDefinition projectDefinitionSet patches |	
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := rowanProject repositoryRootPath , '/test/testRepositories/'.

"identify spec to be used for reading project"
	specUrlString :=  'file:' , projectHome, '/Issue122/', self _repositoryFormat, '/rowan/specs/Issue122_Both-ProtocolValidationError.ston'.

"create project definition"
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.
"point to directory where the disk project is located"
	projectDefinition projectHome: projectHome.

"read project -- catch and resume the notification ... repair the protocol"
	[ projectDefinitionSet := Rowan projectTools read readProjectSetForComponentProjectDefinition: projectDefinition ]
		on: RwInvalidCategoryProtocolConventionErrorNotification
		do: [:ex | 
			ex
				classCategoryNotificationDo: [ self assert: 'Unexpected notification ', ex class printString ]
				nonExtensionMethodNoficationDo: [ 
					"repair the protocol"
					ex methodDefinition protocol: 'repaired'.
					ex resume ] 
				extensionMethodPackageMismatchNoficationDo: [ 
					"repair the protocol - extension method protocol does start with a *, but does not match the package name"
					ex methodDefinition protocol: '*', ex packageName asLowercase.
					ex resume ]  
				extensionMethodNonExtensionProtocolNoficationDo: [ 
					"repair the protocol - extension method protocol doesn't start with a *"
					ex methodDefinition protocol: '*', ex packageName asLowercase.
					ex resume ] ].

"validation - read from disk, without repairing the issues (creating a patch reads without repairing validation errors"
	patches := Rowan projectTools diff patchesForProjectDefinition: projectDefinition.
	self assert: patches size = 1.
	patches do: [:assoc |
		| packageName patch operations |
		packageName := assoc key.
		patch := assoc value.
		self assert: packageName = 'Issue122-Extension1-ProtocolValidationError'.
		operations := patch operations.
		self assert: operations size = 2.
		operations do: [:modification |
			| definition |
			definition := modification modification.
			definition selector = 'method1'
				ifTrue: [ self assert: definition category = '*issue122-extension1-protocolvalidationerror' ]
				ifFalse: [
					definition selector = 'method20'
						ifTrue: [ self assert: definition category = '*issue122-extension1-protocolvalidationerror' ]
						ifFalse: [ self assert: false description: 'unknown definition ', definition printString ] ] ] ]
%

category: '*rowan-tests-components'
method: RwProjectFiletreeTonelReaderWriterTest
testReadExistingDiskProjectWithClassCategoryValidationError
	"https://github.com/GemTalk/Rowan/issues/122"

	"class category does not match package name -- Rowan Hybrid"

	| rowanProject projectHome specUrlString projectDefinition projectDefinitionSet |	
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := rowanProject repositoryRootPath , '/test/testRepositories/'.

"identify spec to be used for reading project"
	specUrlString :=  'file:' , projectHome, '/Issue122/', self _repositoryFormat, '/rowan/specs/Issue122_CategoryValidationError.ston'.

"create project definition"
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.
"point to directory where the disk project is located"
	projectDefinition projectHome: projectHome.

"read project -- hit category does not match error"
	self 
		should: [ Rowan projectTools read readProjectSetForComponentProjectDefinition: projectDefinition ]
		raise: Error.

"recreate project definition"
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.

"point to directory where the disk project is located"
	projectDefinition projectHome: projectHome.

"read project -- catch and resume the notification ... repair the category"
	[ projectDefinitionSet := Rowan projectTools read readProjectSetForComponentProjectDefinition: projectDefinition ]
		on: RwInvalidCategoryProtocolConventionErrorNotification
		do: [:ex | 
			ex
				classCategoryNotificationDo: [
					"repair the class category"
					ex classDefinition category: ex packageName.
					ex resume: true ]
				nonExtensionMethodNoficationDo: [ self assert: 'Unexpected notification ', ex class printString ] 
				extensionMethodPackageMismatchNoficationDo: [ self assert: 'Unexpected notification ', ex class printString ]  
				extensionMethodNonExtensionProtocolNoficationDo: [ self assert: 'Unexpected notification ', ex class printString ] ].

"validation"
	self _validateIssue122Repaired_CategoryValidationError_ProjectDefinitionSet: projectDefinitionSet projectName: projectDefinition name
%

category: '*rowan-tests-components'
method: RwProjectFiletreeTonelReaderWriterTest
testReadExistingDiskProjectWithEmptyClassExtension
	"https://github.com/GemTalk/Rowan/issues/361"


	| rowanProject projectHome projectName specUrlString projectDefinition projectDefinitionSet |	
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := rowanProject repositoryRootPath , '/test/testRepositories/'.

"identify spec to be used for reading project"
	projectName := 'Issue361'.
	specUrlString :=  'file:' , projectHome, '/', projectName, '/', self _repositoryFormat, '/rowan/specs/Issue122.ston'.

"create project definition"
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.
"point to directory where the disk project is located"
	projectDefinition projectHome: projectHome.

"read project -- hit protocol is invalid error"
	projectDefinitionSet := Rowan projectTools read readProjectSetForComponentProjectDefinition: projectDefinition.

"validate"
	self _validateIssue361ProjectDefinitionSet: projectDefinitionSet projectName: projectName
%

category: '*rowan-tests-components'
method: RwProjectFiletreeTonelReaderWriterTest
testReadExistingDiskProjectWithExtensionMethodProtocolValidationError
	"https://github.com/GemTalk/Rowan/issues/122"

	"
		extension method protocol doesn't start with a *
			OR
		extension method protocol does start with a *, but does not match the package name
	"

	| rowanProject projectHome specUrlString projectDefinition projectDefinitionSet |	
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := rowanProject repositoryRootPath , '/test/testRepositories/'.

"identify spec to be used for reading project"
	specUrlString :=  'file:' , projectHome, '/Issue122/', self _repositoryFormat, '/rowan/specs/Issue122_Extension-ProtocolValidationError.ston'.

"create project definition"
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.
"point to directory where the disk project is located"
	projectDefinition projectHome: projectHome.

"read project -- hit protocol is invalid error"
	self 
		should: [ Rowan projectTools read readProjectSetForComponentProjectDefinition: projectDefinition ]
		raise: Error.

"recreate project definition"
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.

"point to directory where the disk project is located"
	projectDefinition projectHome: projectHome.

"read project -- catch and resume the notification ... repair the protocol"
	[ projectDefinitionSet := Rowan projectTools read readProjectSetForComponentProjectDefinition: projectDefinition ]
		on: RwInvalidCategoryProtocolConventionErrorNotification
		do: [:ex | 
			ex
				classCategoryNotificationDo: [ self assert: 'Unexpected notification ', ex class printString ]
				nonExtensionMethodNoficationDo: [ self assert: 'Unexpected notification ', ex class printString ] 
				extensionMethodPackageMismatchNoficationDo: [ 
					"repair the protocol - extension method protocol does start with a *, but does not match the package name"
					ex methodDefinition protocol: '*', ex packageName asLowercase.
					ex resume ]  
				extensionMethodNonExtensionProtocolNoficationDo: [ 
					"repair the protocol - extension method protocol doesn't start with a *"
					ex methodDefinition protocol: '*', ex packageName asLowercase.
					ex resume ] ].

"validation"
	self _validateIssue122Repaired_ExtensionProtocolValidationError_ProjectDefinitionSet: projectDefinitionSet projectName: projectDefinition name
%

category: '*rowan-tests-components'
method: RwProjectFiletreeTonelReaderWriterTest
testReadExistingDiskProjectWithMethodProtocolValidationError
	"https://github.com/GemTalk/Rowan/issues/122"

	"method protocol starts with a * for non-extension method"

	| rowanProject projectHome specUrlString projectDefinition projectDefinitionSet |	
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := rowanProject repositoryRootPath , '/test/testRepositories/'.
"identify spec to be used for reading project"
	specUrlString :=  'file:' , projectHome, '/Issue122/', self _repositoryFormat, '/rowan/specs/Issue122_Core-ProtocolValidationError.ston'.

"create project definition"
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.
"point to directory where the disk project is located"
	projectDefinition projectHome: projectHome.

"read project -- hit protocol is invalid error"
	self 
		should: [ Rowan projectTools read readProjectSetForComponentProjectDefinition: projectDefinition ]
		raise: Error.

"recreate project definition"
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.

"point to directory where the disk project is located"
	projectDefinition projectHome: projectHome.

"read project -- catch and resume the notification ... repair the protocol"
	[ projectDefinitionSet := Rowan projectTools read readProjectSetForComponentProjectDefinition: projectDefinition ]
		on: RwInvalidCategoryProtocolConventionErrorNotification
		do: [:ex | 
			ex
				classCategoryNotificationDo: [ self assert: 'Unexpected notification ', ex class printString ]
				nonExtensionMethodNoficationDo: [ 
					"repair the protocol"
					ex methodDefinition protocol: 'repaired'.
					ex resume ] 
				extensionMethodPackageMismatchNoficationDo: [ self assert: 'Unexpected notification ', ex class printString ]  
				extensionMethodNonExtensionProtocolNoficationDo: [ self assert: 'Unexpected notification ', ex class printString ] ].

"validation"
	self _validateIssue122Repaired_CoreProtocolValidationError_ProjectDefinitionSet: projectDefinitionSet projectName: projectDefinition name
%

category: '*rowan-tests-components'
method: RwProjectFiletreeTonelReaderWriterTest
testWriterReader_Rowan_pharo

	"write Rowan project to alternate directory, using the pharo project attributes to read the project in the first place"

	"execute without errors"

	| platformConfigurationAttributes projectDefinition projectSetDefinition projectSetModification visitor
		projectHome rowanProject projectAlias writerVisitorClass |

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := self _testRowanProjectsSandbox.
	projectAlias := 'Rowan_', self _repositoryFormat.

	(projectHome / projectAlias / 'src') 
		ensureCreateDirectory;
		deleteAllChildren;
		yourself.

"Read project and packages from disk for Pharo"
	platformConfigurationAttributes := {
		'common'.
		'pharo'.	"want to read pharo packages"
	}.
	projectDefinition := RwComponentProjectDefinition 
		newForUrl: 'file:', rowanProject repositoryRootPath, '/platforms/pharo/rowan/specs/Rowan_component.ston'.
	projectDefinition projectHome: rowanProject repositoryRootPath asFileReference parent.
	projectDefinition read: platformConfigurationAttributes.

"Write project and packages to disk in filetree format, for bootstrapping Pharo"
	projectDefinition
		packagesPath: 'src';
		projectHome: projectHome;
		projectAlias: projectAlias;
		packageFormat: self _repositoryFormat;
		yourself.
	projectSetDefinition := RwProjectSetDefinition new
		addProject: projectDefinition;
		yourself.
	projectSetModification := projectSetDefinition compareAgainstBase: RwProjectSetDefinition new.
	writerVisitorClass := self _repositoryFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	visitor := writerVisitorClass new.
	visitor visit: projectSetModification.
%

! Class extensions for 'RwProjectReaderWriterTest'

!		Instance methods for 'RwProjectReaderWriterTest'

category: '*rowan-tests-components'
method: RwProjectReaderWriterTest
_projectDefinitionForStructureWriters_A: projectName format: repositoryFormat

	"multiple class extensions from multiple packages for multiple classes"

	| packageName1 packageName2 projectDefinition classDefinition packageDefinition className1 className2 className3
		classExtensionDefinition packageName3 rowanProject projectHome |

	self _markForProjectCleanup: projectName.
	packageName1 := 'Issue361-Core'.
	packageName2 := 'Issue361-Extension1'.
	packageName3 := 'Issue361-Extension2'.
	className1 := 'Issue361Class1'. 
	className2 := 'Issue361Class2'. 
	className3 := 'Issue361Class3'. 

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := self _testRowanProjectsSandbox pathString.


"create definitions"
	projectDefinition := (RwComponentProjectDefinition
		newForDiskBasedProjectNamed: projectName)
		packageFormat: repositoryFormat;
		projectHome: projectHome;
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: 'this is a test comment for ', className1
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition: 
			(RwMethodDefinition
					newForSelector: #'method6'
					protocol: 'instance accessing'
					source: 'method6 ^6');
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'class accessing'
					source: 'method2 ^2').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Array'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: 'this is a test comment for ', className2
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: className1
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: 'this is a test comment for ', className3
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method8:'
					protocol: 'accessing'
					source: 'method8: ignored ^ignored');
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method9'
					protocol: 'accessing'
					source: 'method9 ^9');
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4');
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method10'
					protocol: 'accessing'
					source: 'method10 ^10').
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: '*', packageName2 asLowercase
					source: 'method1 ^1').
	packageDefinition := projectDefinition packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	packageDefinition := projectDefinition packageNamed: packageName3.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method5'
					protocol: '*', packageName3 asLowercase
					source: 'method5 ^5');
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method6'
					protocol: '*', packageName3 asLowercase
					source: 'method6 ^6').
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	^ projectDefinition
%

! Class extensions for 'RwProjectTest'

!		Instance methods for 'RwProjectTest'

category: '*rowan-tests-35x'
method: RwProjectTest
test_issue428_loaded_no_disk

| projectName  packageName projectDefinition projectSetDefinition |

	projectName := 'Issue428'.
	packageName := 'Issue428-Extension'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

"create project"
	projectDefinition := (RwComponentProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

"test existsOnDisk"

	self deny: (RwProject newNamed: projectName) existsOnDisk.
%

category: '*rowan-tests-35x'
method: RwProjectTest
test_issue428_loaded_on_disk

	| projectName projectDefinition projectTools packageNames |
	projectName := 'Issue428'.
	packageNames := #('Issue428-Core' 'Issue428-Tests').
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	projectDefinition := (RwComponentProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackagesNamed: packageNames;
		packageFormat: 'tonel';
		projectHome: self _testRowanProjectsSandbox pathString, '/rowanSimpleProject/';
		yourself.

	self
		handleConfirmationDuring: [ projectDefinition create ].

"test existsOnDisk"

	self assert: (RwProject newNamed: projectName) existsOnDisk.
%

! Class extensions for 'RwProjectToolTest'

!		Instance methods for 'RwProjectToolTest'

category: '*rowan-tests-35x'
method: RwProjectToolTest
testDiskSimpleProject1

	"Create project and build disk-based artifacts first, then create create a class and write changes to disk."

	| projectName projectDefinition projectTools classDefinition packageDefinition packageNames loadedProject |
	projectName := 'Simple'.
	packageNames := #('Simple-Core' 'Simple-Tests').
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	((self _testRowanProjectsSandbox pathString, '/rowanSimpleProject/' )asFileReference)
		ensureCreateDirectory;
		deleteAllChildren.

	projectDefinition := RwComponentProjectDefinition
		projectName: projectName 
			projectHome: self _testRowanProjectsSandbox pathString, '/rowanSimpleProject/'
			useGit: true
			comment: 'This is a simple project to demonstrate the smalltalk API used for a project lifecycle'.
	 
	projectDefinition defaultSymbolDictName: self _symbolDictionaryName1.
	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName1.

	projectDefinition addPackagesNamed: packageNames.

	self
		handleConfirmationDuring: [ projectDefinition create ].

	projectDefinition commit: 'Initial commit'.

	self
		handleInformAsFailureDuring: [ projectTools load loadProjectDefinition: projectDefinition ].

	loadedProject := Rowan image
		loadedProjectNamed: projectName
		ifAbsent: [ self assert: false description: 'expected to find loaded project' ].
	packageNames
		do: [ :packageName | 
			"ensure that we have a loaded package for each of the packages"
			Rowan image
				loadedPackageNamed: packageName
				ifAbsent: [ self assert: false description: 'expected to find loaded package' ] ].

	classDefinition := RwClassDefinition
		newForClassNamed: 'Simple'
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: 'I am a Simple class'
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition packageNamed: 'Simple-Core'.
	packageDefinition addClassDefinition: classDefinition.

	self
		handleInformAsFailureDuring: [ projectTools load loadProjectDefinition: projectDefinition ].

	projectDefinition exportSpecification.
	projectTools write writeProjectDefinition: projectDefinition.
	projectDefinition commit: 'Added Simple class'
%

category: '*rowan-tests-35x'
method: RwProjectToolTest
testProjectClassExtensions

	"Build our project in memory without committing to disk until we've created a class with methods, then write to disk."

	| projectName projectDefinition projectTools classDefinition packageDefinition1 packageDefinition2 className testClass testInstance classExtensionDefinition packageNames project |
	projectName := 'Simple'.
	packageNames := #('Simple-Core' 'Simple-Extensions' 'Simple-Tests').
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	projectDefinition := (RwComponentProjectDefinition
		newForGitBasedProjectNamed: projectName)
		comment: 'This is a simple project created in memory first, then written to disk.';
		addPackagesNamed: packageNames;
		defaultSymbolDictName: self _symbolDictionaryName1;
		packageFormat: 'tonel';
		projectHome: self _testRowanProjectsSandbox pathString, '/rowanSimpleExtensionProject/';
		configsPath: 'configs';
		packagesPath: 'src';
		specsPath: 'specs';
		yourself.

	(self _testRowanProjectsSandbox / 'rowanSimpleExtensionProject') ensureDeleteAll.

	self
		handleConfirmationDuring: [ projectDefinition create ].

	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName1.

	className := 'Simple'.
	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #(#'civar1')
		classvars: #()
		category: nil
		comment: 'I am a Simple class with extensions'
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
				newForSelector: #'foo'
				protocol: 'accessing'
				source: 'foo ^ true').

	packageDefinition1 := projectDefinition packageNamed: 'Simple-Core'.
	packageDefinition1 addClassDefinition: classDefinition.

	projectTools load loadProjectDefinition: projectDefinition.

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	testInstance := testClass new.
	self assert: (testInstance perform: #foo).

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize civar1 := 1.');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'civar1'
						protocol: 'accessing'
						source: 'civar1 ^civar1');
		yourself.

	packageDefinition2 := projectDefinition packageNamed: 'Simple-Extensions'.
	packageDefinition2 addClassExtensionDefinition: classExtensionDefinition.

	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) == 1.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.


	projectDefinition 
		export;
		commit: 'Added Simple class and extension methods'.

	
	projectTools load loadProjectDefinition: projectDefinition.

	project := Rowan projectNamed: projectName.
	self assert: project _loadedProject notNil.
	self assert: project existsOnDisk.
	self assert: project canCommit.
	self assert: project currentBranchName = 'master'.
	self assert: (project extendedClasses asArray collect: [:beh | beh name asString ]) = { className }.
	self deny: project repositoryCommitId isEmpty.
	self assert: project repositoryRoot = (projectDefinition projectHome / projectName).
	self assert: (project repositoryRoot / 'specs' / projectName, 'ston') exists.
	self assert: (project repositoryRoot / 'configs' / 'Core', 'ston') exists.
	self assert: (project repositoryRoot / 'src' / 'Simple-Core') exists.
	self assert: (project repositoryRoot / 'src' / 'Simple-Extensions') exists.
	self assert: (project repositoryRoot / 'src' / 'Simple-Tests') exists.
	self assert: (project repositoryRoot / 'src' / 'Simple-Extensions' / 'Simple.extension.st') exists.
%

category: '*rowan-tests-35x'
method: RwProjectToolTest
testProjectClassExtensionsInSeparateSymbolDictionaryTheRightWay

	"Proper way to add extension methods to a class --- load spec expanded to allow user to specify per package symbol dictionaries ... symbolDictName redefined as defaultSymbolDictName."

	| projectName projectDefinition projectTools classDefinition packageDefinition1 
		packageDefinition2 packageDefinition3 className1 className2 testClass1 testClass2 
		testInstance1 testInstance2 classExtensionDefinition dictionariesAndSymbols x y 
		packageNames project |
	projectName := 'Simple'.
	packageNames := #('Simple-Core1' 'Simple-Core2' 'Simple-Extensions1').
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	projectDefinition := (RwComponentProjectDefinition
		newForGitBasedProjectNamed: projectName)
		comment:
				'This is a project created in memory first, then written to disk. There are three packages 21 of which creates classes in a different symbol dictionary.';
		addPackagesNamed: packageNames;
		defaultSymbolDictName: self _symbolDictionaryName2;
		packageFormat: 'tonel';
		projectHome: self _testRowanProjectsSandbox pathString, '/rowanClassExtensionsProject/';
		setSymbolDictName: self _symbolDictionaryName1 forPackageNamed: 'Simple-Core1';
		setSymbolDictName: self _symbolDictionaryName1
			forPackageNamed: 'Simple-Extensions1';
		yourself.

	(self _testRowanProjectsSandbox / 'rowanClassExtensionsProject') ensureDeleteAll.

	self
		handleConfirmationDuring: [ projectDefinition create ].

	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName1.
	Rowan image newOrExistingSymbolDictionaryNamed: self _symbolDictionaryName2.

	className1 := 'Simple1'.
	className2 := 'Simple2'.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #(#'civar1')
		classvars: #()
		category: nil
		comment: 'I am a Simple class with extensions'
		pools: #()
		type: 'normal'.

	packageDefinition1 := projectDefinition packageNamed: 'Simple-Core1'.
	packageDefinition1 addClassDefinition: classDefinition.

	projectTools load loadProjectDefinition: projectDefinition.

	testClass1 := Rowan globalNamed: className1.
	self assert: testClass1 notNil.
	testClass2 := Rowan globalNamed: className2.
	self assert: testClass2 isNil.
	testInstance1 := testClass1 new.
	self should: [ testInstance1 perform: #ivar1 ] raise: MessageNotUnderstood.

	dictionariesAndSymbols := Rowan image symbolList
		dictionariesAndSymbolsOf: testClass1.
	self assert: dictionariesAndSymbols size = 1.
	self
		assert:
			(x := (dictionariesAndSymbols at: 1) at: 1)
				== (y := Rowan globalNamed: self _symbolDictionaryName1).

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #(#'civar1')
		classvars: #()
		category: nil
		comment: 'I am a Simple class with extensions'
		pools: #()
		type: 'normal'.

	packageDefinition2 := projectDefinition packageNamed: 'Simple-Core2'.
	packageDefinition2 addClassDefinition: classDefinition.

	projectTools load loadProjectDefinition: projectDefinition.

	testClass2 := Rowan globalNamed: className2.
	self assert: testClass1 notNil.
	testInstance2 := testClass2 new.

	dictionariesAndSymbols := Rowan image symbolList
		dictionariesAndSymbolsOf: testClass2.
	self assert: dictionariesAndSymbols size = 1.
	self
		assert:
			(x := (dictionariesAndSymbols at: 1) at: 1)
				== (y := Rowan globalNamed: self _symbolDictionaryName2).

	classExtensionDefinition := RwClassExtensionDefinition
		newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize civar1 := 1.');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'civar1'
						protocol: 'accessing'
						source: 'civar1 ^civar1');
		yourself.

	packageDefinition3 := projectDefinition packageNamed: 'Simple-Extensions1'.
	packageDefinition3 addClassExtensionDefinition: classExtensionDefinition.

	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].

	self assert: (testClass1 perform: #civar1) = 1.

	projectDefinition
		export;
		commit: '3 packages with extension methods for first package in third package.'.

	projectTools load loadProjectDefinition: projectDefinition.

	project := Rowan projectNamed: projectName.
	self assert: project _loadedProject notNil.
	self assert: project existsOnDisk.
	self assert: project canCommit.
	self assert: project currentBranchName = 'master'.
	self assert: (x := (project extendedClasses asArray collect: [:beh | beh name asString ]) sort) = { className1 } sort.
	self deny: project repositoryCommitId isEmpty.
	self assert: project repositoryRoot = (projectDefinition projectHome / projectName).
	self assert: (project repositoryRoot / 'rowan' / 'specs' / projectName, 'ston') exists.
	self assert: (project repositoryRoot / 'rowan' / 'components' / 'Core', 'ston') exists.
	self assert: (project repositoryRoot / 'rowan' / 'src' / 'Simple-Core1') exists.
	self assert: (project repositoryRoot / 'rowan' / 'src' / 'Simple-Core2') exists.
	self assert: (project repositoryRoot / 'rowan' / 'src' / 'Simple-Extensions1') exists.
	self assert: (project repositoryRoot / 'rowan' / 'src' / 'Simple-Extensions1' / 'Simple1.extension.st') exists.
%

category: '*rowan-tests-35x'
method: RwProjectToolTest
testSimpleProject1

	"Create project and build disk-based artifacts first, then create create a class and write changes to disk."

	| projectName projectDefinition projectTools classDefinition packageDefinition 
		packageNames loadedProject |
	projectName := 'Simple'.
	packageNames := #('Simple-Core' 'Simple-Tests').
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	projectDefinition := (RwComponentProjectDefinition
		newForGitBasedProjectNamed: projectName)
		comment:
				'This is a simple project to demonstrate the smalltalk API used for a project lifecycle';
		addPackagesNamed: packageNames;
		defaultSymbolDictName: self _symbolDictionaryName1;
		packageFormat: 'tonel';
		projectHome: self _testRowanProjectsSandbox pathString, '/rowanSimpleProject/';
		yourself.

	(self _testRowanProjectsSandbox pathString, '/rowanSimpleProject/') asFileReference ensureDeleteAll.

	self
		handleConfirmationDuring: [ projectDefinition create ].

	projectDefinition
		export;
		commit: 'Initial commit'.

	self
		handleInformAsFailureDuring: [ projectTools load loadProjectDefinition: projectDefinition ].

	loadedProject := Rowan image
		loadedProjectNamed: projectName
		ifAbsent: [ self assert: false description: 'expected to find loaded project' ].
	packageNames
		do: [ :packageName | 
			"ensure that we have a loaded package for each of the packages"
			Rowan image
				loadedPackageNamed: packageName
				ifAbsent: [ self assert: false description: 'expected to find loaded package' ] ].

	classDefinition := RwClassDefinition
		newForClassNamed: 'Simple'
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: 'I am a Simple class'
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition packageNamed: 'Simple-Core'.
	packageDefinition addClassDefinition: classDefinition.

	self
		handleInformAsFailureDuring: [ projectTools load loadProjectDefinition: projectDefinition ].

	projectDefinition 
		export;
		commit: 'Added Simple class'
%

category: '*rowan-tests-35x'
method: RwProjectToolTest
testSimpleProject2

	"Build our project in memory without committing to disk until we've created a class, then write to disk."

	| projectName projectDefinition projectTools classDefinition packageDefinition 
		packageNames |
	projectName := 'Simple'.
	packageNames := #('Simple-Core' 'Simple-Tests').
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	projectDefinition := (RwComponentProjectDefinition
		newForGitBasedProjectNamed: projectName)
		comment:
				'This is a simple project created in memory first, then written to disk.';
		addPackagesNamed: packageNames;
		defaultSymbolDictName: self _symbolDictionaryName1;
		packageFormat: 'tonel';
		projectHome: self _testRowanProjectsSandbox pathString, '/rowanSimpleProject2/';
		configsPath: 'configs';
		packagesPath: 'src';
		specsPath: 'specs';
		yourself.

	(self _testRowanProjectsSandbox pathString, '/rowanSimpleProject2/' ) asFileReference ensureDeleteAll.

	classDefinition := RwClassDefinition
		newForClassNamed: 'Simple2'
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: nil
		comment: 'I am a Simple2 class'
		pools: #()
		type: 'normal'.

	packageDefinition := projectDefinition packageNamed: 'Simple-Core'.
	packageDefinition addClassDefinition: classDefinition.

	projectTools load loadProjectDefinition: projectDefinition.

	self
		handleConfirmationDuring: [ projectDefinition create ].

	projectDefinition 
		export;
		commit: 'Added Simple class'
%

category: '*rowan-tests-35x'
method: RwProjectToolTest
testSimpleProject3

	"Build our project in memory without committing to disk until we've created a class with methods, then write to disk."

	| projectName projectDefinition projectTools classDefinition packageDefinition className testClass testInstance packageNames |
	projectName := 'Simple'.
	packageNames := #('Simple-Core' 'Simple-Tests').
	projectTools := Rowan projectTools.

	{projectName}
		do: [ :name | 
			(Rowan image loadedProjectNamed: name ifAbsent: [  ])
				ifNotNil: [ :project | Rowan image _removeLoadedProject: project ] ].

	projectDefinition := (RwComponentProjectDefinition newForGitBasedProjectNamed: projectName)
		comment: 'This is a simple project created in memory first, then written to disk.';
		addPackagesNamed: packageNames;
		defaultSymbolDictName: self _symbolDictionaryName1;
		packageFormat: 'tonel';
		projectHome: self _testRowanProjectsSandbox pathString, '/rowanSimpleProject3/';
		configsPath: 'configs';
		packagesPath: 'src'; 
		specsPath: 'specs';
 		yourself.

	(self _testRowanProjectsSandbox pathString, '/rowanSimpleProject3/' )asFileReference ensureDeleteAll.

	className := 'Simple3'.
	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #('ivar1')
		classinstvars: #(#'civar1')
		classvars: #()
		category: nil
		comment: 'I am a Simple3 class'
		pools: #()
		type: 'normal'.

	classDefinition
		addInstanceMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'ivar1'
						protocol: 'accessing'
						source: 'ivar1 ^ivar1');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'initialize'
						protocol: 'initialization'
						source: 'initialize civar1 := 1.');
		addClassMethodDefinition:
				(RwMethodDefinition
						newForSelector: #'civar1'
						protocol: 'accessing'
						source: 'civar1 ^civar1');
		yourself.

	packageDefinition := projectDefinition packageNamed: 'Simple-Core'.
	packageDefinition addClassDefinition: classDefinition.

	[ projectTools load loadProjectDefinition: projectDefinition ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: true ].

	testClass := Rowan globalNamed: className.
	self assert: testClass notNil.
	self assert: (testClass perform: #civar1) == 1.
	testInstance := testClass new.
	self assert: (testInstance perform: #ivar1) isNil.

	self
		handleConfirmationDuring: [ projectDefinition create ].

	projectDefinition 
		export;
		commit: 'Added Simple3 class and methods'
%

! Class extensions for 'RwProjectTopazWriterTest'

!		Instance methods for 'RwProjectTopazWriterTest'

category: '*rowan-tests-gemstone-35x'
method: RwProjectTopazWriterTest
testGsTopazWriter_A_export

	"simple case with only two packages and a single set of extensions for a class"

	|  projectName packageName1 packageName2 projectDefinition classDefinition packageDefinition 
		className1 className2 className3 topazFileReference classExtensionDefinition 
		repositoryRootPath x stream y |

	projectName := 'Issue361'.
	packageName1 := 'Issue361-Core'.
	packageName2 := 'Issue361-Extension'.
	className1 := 'Issue361Class1'. 
	className2 := 'Issue361Class2'. 
	className3 := 'Issue361Class3'. 

"create definitions"
	projectDefinition := (RwComponentProjectDefinition newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Array'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: className1
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: '*', packageName2 asLowercase
					source: 'method1 ^1').
	packageDefinition := projectDefinition packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"export"
	repositoryRootPath := filesystem workingDirectory / projectName / 'topaz'.
	topazFileReference := repositoryRootPath asFileReference / projectName.
	self _markForCleanup: (filesystem workingDirectory / projectName).
	repositoryRootPath ensureCreateDirectory.
	projectDefinition exportTopazFormatTo: topazFileReference.

"validate"
	stream := ZnBufferedReadStream on: (topazFileReference, 'gs') readStream.
	x := stream contents.
	y := self _expectedGsTopazWriterFileContents_A.
	self assert: x = y
%

category: '*rowan-tests-gemstone-35x'
method: RwProjectTopazWriterTest
testGsTopazWriter_C_export

	"ramp up to multiple class extensions from multiple packages for multiple classes"

	"write each package into a separate topaz file"

	|  projectName packageName1 packageName2 projectDefinition classDefinition packageDefinition 
		className1 className2 className3 topazFileReference classExtensionDefinition repositoryRootPath 
		x stream y packageName3 |

	projectName := 'Issue361'.
	packageName1 := 'Issue361-Core'.
	packageName2 := 'Issue361-Extension1'.
	packageName3 := 'Issue361-Extension2'.
	className1 := 'Issue361Class1'. 
	className2 := 'Issue361Class2'. 
	className3 := 'Issue361Class3'. 

"create definitions"
	projectDefinition := (RwComponentProjectDefinition newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName1;
		setSymbolDictName: self _symbolDictionaryName forPackageNamed: packageName2;
		yourself.

	packageDefinition := projectDefinition packageNamed: packageName1.

	classDefinition := RwClassDefinition
		newForClassNamed: className1
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method2'
					protocol: 'accessing'
					source: 'method2 ^2').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className2
		super: 'Array'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method3'
					protocol: 'accessing'
					source: 'method3 ^3').
	packageDefinition addClassDefinition: classDefinition.

	classDefinition := RwClassDefinition
		newForClassNamed: className3
		super: className1
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addClassMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method4'
					protocol: 'accessing'
					source: 'method4 ^4').
	packageDefinition addClassDefinition: classDefinition.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: '*', packageName2 asLowercase
					source: 'method1 ^1').
	packageDefinition := projectDefinition packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	packageDefinition := projectDefinition packageNamed: packageName3.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className1.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method5'
					protocol: '*', packageName3 asLowercase
					source: 'method5 ^5').
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

"export"
	repositoryRootPath := filesystem workingDirectory / projectName / 'topaz'.
	topazFileReference := repositoryRootPath asFileReference / projectName.
	self _markForCleanup: (filesystem workingDirectory / projectName).
	repositoryRootPath ensureCreateDirectory.
	projectDefinition exportTopazFormatTo: topazFileReference usingPackageNamesMap: (Dictionary new
				at: packageName1 put: {packageName1};
				at: packageName2 put: {packageName2};
				at: packageName3 put: {packageName3};
				yourself).

"validate"

	{ packageName1. packageName2. packageName3 }
		do: [:packageName |
			stream := ZnBufferedReadStream on: (repositoryRootPath / packageName, 'gs') readStream.
			x := stream contents.
			y := self perform: #'_expectedGsTopazWriterFileContents_C_', (packageName copyWithout: $-).
			self assert: x = y ].
%

! Class extensions for 'RwRowanProjectIssuesTest'

!		Instance methods for 'RwRowanProjectIssuesTest'

category: '*rowan-services-tests'
method: RwRowanProjectIssuesTest
testIssue150_branches

	"https://github.com/dalehenrich/Rowan/issues/150"

	"The issue #150 tests are mainly aimed at verifying that the given commands do not fail - ensuring that git version supports the
		commands and arguments used by Jadeite. "

	| rowanProject projectName service testBranch testClass  queryService |

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectName := 'RowanSample3'.
	self 
		_cloneGitRepositoryFor: projectName 
		projectUrlString:  'file:' , rowanProject repositoryRootPath , '/samples/', projectName, '.ston'.

	queryService := 	RowanQueryService new
		projectBranches: projectName;
		yourself.

	service := RowanProjectService new
		name: projectName;
		yourself.

	testBranch := 'issue_150_v2'.
	service 
		checkout: testBranch;
		branch;
		repositorySha;
		log;
		pullFromGit;
		yourself.
	Rowan projectTools load loadProjectNamed: projectName.
	testClass := Rowan globalNamed: 'RowanSample3'.
	testClass 
		rwCompileMethod: 'foo
 "', DateAndTime now printString, '"
^1 '
		category: 'accessing'.
	service
		commitWithMessage: 'a commit';
		pushToGit;
		yourself
%

category: '*rowan-tests-gemstone'
method: RwRowanProjectIssuesTest
testIssue165

	"https://github.com/dalehenrich/Rowan/issues/165"

	| projectName packageName1 className symDictName theClass theSymbolDict myUserProfile mySymbolList theSymDictIndex | 
	projectName := 'Issue165_Project'.
	packageName1 := 'Issue165-Core'.
	className := 'Issue165Class'.
	symDictName := self _symbolDictionaryName2.

	self 
		_createLoadedProjectNamed: projectName 
		root: self _testRowanProjectsSandbox pathString, '/rowanIssuesProject/' 
		symbolDictionaryName: symDictName 
		validate: false.

	self _addPackageNamed: packageName1 toProjectNamed: projectName validate: false.

	theClass := Object
		rwSubclass: className
		instVarNames: #()
		classVars: #()
		classInstVars: #()
		poolDictionaries: #()
		category: packageName1
		options: #().
	theClass rwCompileMethod: 'foo ^1' category: 'accessing'.

	theSymbolDict := Rowan globalNamed: symDictName.
	self assert: theSymbolDict class == SymbolDictionary.			"symbol dictionary is accessible in my symbol list"

	self assert: (Rowan projectNames includes: projectName).		"project is visible"
	self assert: (Rowan packageNames includes: packageName1).	"package is visible"
	self assert: (Rowan globalNamed: className) notNil.				"class is visible"

	myUserProfile := System myUserProfile.
	mySymbolList := System myUserProfile symbolList.
	theSymDictIndex := mySymbolList indexOf: theSymbolDict.
	myUserProfile removeDictionaryAt: theSymDictIndex.				"remove symbol dictionary from my symbol list"

	self assert: (Rowan projectNames includes: projectName).		"project is visible"
	self deny: (Rowan packageNames includes: packageName1).	"package is NOT visible"
	self deny: (Rowan globalNamed: className) notNil.				"class is NOT visible"
%

category: '*rowan-tests-gemstone'
method: RwRowanProjectIssuesTest
testIssue185_254_move_extension_method_to_new_package_1

	"https://github.com/dalehenrich/Rowan/issues/185"
	"https://github.com/dalehenrich/Rowan/issues/254"

	"simplified version of RwRowanProjectIssuesTest>>testIssue41_interactiveMoveInitializeExtensionMethodToPackage"

	"use RwClassExtensionDefinition>>removeKey: to do final update (source changed)--- definition comparison bug (see testIssue206_move_extension_method_to_new_package_1)"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition 
		packageDefinition className projectSetDefinition class classExtensionDefinition packageName3 
		loadedPackage loadedClassExtensions x audit project|
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core1'.
	packageName2 := 'Issue185-Core2'.
	packageName3 := 'Issue185-Core3'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	"create extension method in different package"
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName2 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

	"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName2 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName2.

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: (loadedClassExtensions at: className ifAbsent: []) isNil.

	"move the method to new package"
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition classExtensions removeKey: className.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName3 asLowercase
					source: 'mover ^3').

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

	"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.

	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 3.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName3 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName3.

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self deny: ((x := loadedClassExtensions at: className ifAbsent: [RwGsLoadedSymbolDictClassExtension new initialize]) instanceMethodDefinitions includesKey: #mover).
%

category: '*rowan-tests-gemstone'
method: RwRowanProjectIssuesTest
testIssue185_254_move_extension_method_to_new_package_3

	"https://github.com/dalehenrich/Rowan/issues/185"

	"simplified version of RwRowanProjectIssuesTest>>testIssue41_interactiveMoveInitializeExtensionMethodToPackage"

	"use RwClassExtensionDefinition>>removeInstanceMethod: to do final update (testIssue185_move_extension_method_to_new_package_1 exposes a bug)"


	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		classExtensionDefinition packageName3 loadedPackage loadedClassExtensions x |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core1'.
	packageName2 := 'Issue185-Core2'.
	packageName3 := 'Issue185-Core3'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	"create extension method in different package"
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName2 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

	"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName2 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName2.

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: (loadedClassExtensions at: className ifAbsent: []) isNil.

	"move the method to new package"
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	(packageDefinition classExtensions at: className) removeInstanceMethod: #mover.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName3 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

	"validate"
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName3 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName3.

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self deny: ((x := loadedClassExtensions at: className ifAbsent: [RwGsLoadedSymbolDictClassExtension new initialize]) instanceMethodDefinitions includesKey: #mover).
%

category: '*rowan-tests-gemstone'
method: RwRowanProjectIssuesTest
testIssue185_254_move_extension_method_to_new_package_4

	"https://github.com/dalehenrich/Rowan/issues/185"

	"simplified version of RwRowanProjectIssuesTest>>testIssue41_interactiveMoveInitializeExtensionMethodToPackage"

	"use RwClassExtensionDefinition>>removeKey: to do final update (source not changed) --- definition comparison bug?"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		classExtensionDefinition packageName3 loadedPackage loadedClassExtensions x |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core1'.
	packageName2 := 'Issue185-Core2'.
	packageName3 := 'Issue185-Core3'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	"create extension method in different package"
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName2 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

	"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName2 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName2.

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: (loadedClassExtensions at: className ifAbsent: []) isNil.

	"move the method to new package"
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition classExtensions removeKey: className.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName3 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition_254: projectSetDefinition.

	"validate"
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName3 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName3.

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self deny: ((x := loadedClassExtensions at: className ifAbsent: [RwGsLoadedSymbolDictClassExtension new initialize]) instanceMethodDefinitions includesKey: #mover).
%

category: '*rowan-tests-gemstone'
method: RwRowanProjectIssuesTest
testIssue185_move_extension_method_to_new_package_1

	"https://github.com/dalehenrich/Rowan/issues/185"

	"simplified version of RwRowanProjectIssuesTest>>testIssue41_interactiveMoveInitializeExtensionMethodToPackage"

	"use RwClassExtensionDefinition>>removeKey: to do final update (source changed)--- definition comparison bug (see testIssue206_move_extension_method_to_new_package_1)"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		classExtensionDefinition packageName3 loadedPackage loadedClassExtensions x |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core1'.
	packageName2 := 'Issue185-Core2'.
	packageName3 := 'Issue185-Core3'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	"create extension method in different package"
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName2 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName2 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName2.

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: (loadedClassExtensions at: className ifAbsent: []) isNil.

	"move the method to new package"
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition classExtensions removeKey: className.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName3 asLowercase
					source: 'mover ^3').

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"validate"
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 3.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName3 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName3.

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self deny: ((x := loadedClassExtensions at: className ifAbsent: [RwGsLoadedSymbolDictClassExtension new initialize]) instanceMethodDefinitions includesKey: #mover).
%

category: '*rowan-tests-gemstone'
method: RwRowanProjectIssuesTest
testIssue185_move_extension_method_to_new_package_2

	"https://github.com/dalehenrich/Rowan/issues/185"

	"simplified version of RwRowanProjectIssuesTest>>testIssue41_interactiveMoveInitializeExtensionMethodToPackage"

	"use Behavior>>rwCompileMethod:category: to do final update (testIssue185_move_extension_method_to_new_package_1 exposes a bug)"

	| projectName  packageName1 packageName2 projectDefinition1 classDefinition packageDefinition className projectSetDefinition class
		classExtensionDefinition packageName3 loadedPackage loadedClassExtensions x |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core1'.
	packageName2 := 'Issue185-Core2'.
	packageName3 := 'Issue185-Core3'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	"create extension method in different package"
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName2 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName2 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName2.

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: (loadedClassExtensions at: className ifAbsent: []) isNil.

	"move the method to new package"
	class 
		rwCompileMethod: 'mover ^2'
		category:  '*' , packageName3 asLowercase.

	"validate"
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName3 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName3.

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self deny: ((x := loadedClassExtensions at: className ifAbsent: [RwGsLoadedSymbolDictClassExtension new initialize]) instanceMethodDefinitions includesKey: #mover).
%

category: '*rowan-tests-gemstone'
method: RwRowanProjectIssuesTest
testIssue185_move_extension_method_to_new_package_3

	"https://github.com/dalehenrich/Rowan/issues/185"

	"simplified version of RwRowanProjectIssuesTest>>testIssue41_interactiveMoveInitializeExtensionMethodToPackage"

	"use RwClassExtensionDefinition>>removeInstanceMethod: to do final update (testIssue185_move_extension_method_to_new_package_1 exposes a bug)"


	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		classExtensionDefinition packageName3 loadedPackage loadedClassExtensions x |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core1'.
	packageName2 := 'Issue185-Core2'.
	packageName3 := 'Issue185-Core3'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	"create extension method in different package"
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName2 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName2 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName2.

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: (loadedClassExtensions at: className ifAbsent: []) isNil.

	"move the method to new package"
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	(packageDefinition classExtensions at: className) removeInstanceMethod: #mover.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName3 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"validate"
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName3 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName3.

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self deny: ((x := loadedClassExtensions at: className ifAbsent: [RwGsLoadedSymbolDictClassExtension new initialize]) instanceMethodDefinitions includesKey: #mover).
%

category: '*rowan-tests-gemstone'
method: RwRowanProjectIssuesTest
testIssue185_move_extension_method_to_new_package_4

	"https://github.com/dalehenrich/Rowan/issues/185"

	"simplified version of RwRowanProjectIssuesTest>>testIssue41_interactiveMoveInitializeExtensionMethodToPackage"

	"use RwClassExtensionDefinition>>removeKey: to do final update (source not changed) --- definition comparison bug?"

	| projectName  packageName1 packageName2 projectDefinition1 projectDefinition2 classDefinition packageDefinition className projectSetDefinition class
		classExtensionDefinition packageName3 loadedPackage loadedClassExtensions x |
	projectName := 'Issue185'.
	packageName1 := 'Issue185-Core1'.
	packageName2 := 'Issue185-Core2'.
	packageName3 := 'Issue185-Core3'.
	className := 'Issue185Class'.

	{projectName}
		do: [ :pn | 
			(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
				ifNotNil: [ :loadedProject | Rowan image _removeLoadedProject: loadedProject ] ].

	projectDefinition1 := (RwProjectDefinition
		newForGitBasedProjectNamed: projectName)
		addPackageNamed: packageName1;
		addPackageNamed: packageName2;
		addPackageNamed: packageName3;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.

	classDefinition := RwClassDefinition
		newForClassNamed: className
		super: 'Object'
		instvars: #()
		classinstvars: #()
		classvars: #()
		category: packageName1
		comment: ''
		pools: #()
		type: 'normal'.
	classDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'method1'
					protocol: 'accessing'
					source: 'method1 ^1').

	packageDefinition := projectDefinition1 packageNamed: packageName1.
	packageDefinition addClassDefinition: classDefinition.

	"create extension method in different package"
	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName2 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition1 packageNamed: packageName2.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition1.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"validate"
	class := Rowan globalNamed: className.
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName2 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName2.

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: (loadedClassExtensions at: className ifAbsent: []) isNil.

	"move the method to new package"
	projectDefinition2 := (Rowan image loadedProjectNamed: projectName) asDefinition.

	packageDefinition := projectDefinition2 packageNamed: packageName2.
	packageDefinition classExtensions removeKey: className.

	classExtensionDefinition := RwClassExtensionDefinition newForClassNamed: className.
	classExtensionDefinition
		addInstanceMethodDefinition:
			(RwMethodDefinition
					newForSelector: #'mover'
					protocol: '*', packageName3 asLowercase
					source: 'mover ^2').

	packageDefinition := projectDefinition2 packageNamed: packageName3.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.

	"load"
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition2.
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"validate"
	self assert: class rowanPackageName = packageName1.
	self assert: (class new perform: #method1) = 1.
	self assert: (class new perform: #mover) = 2.

	self assert: (class categoryOfSelector: #mover) asString = ('*', packageName3 asLowercase).
	self assert: (class compiledMethodAt: #mover) rowanPackageName = packageName3.

	loadedPackage := Rowan image loadedPackageNamed: packageName3.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self assert: ((loadedClassExtensions at: className) instanceMethodDefinitions includesKey: #mover).

	loadedPackage := Rowan image loadedPackageNamed: packageName2.
	loadedClassExtensions := loadedPackage loadedClassExtensions.
	self deny: ((x := loadedClassExtensions at: className ifAbsent: [RwGsLoadedSymbolDictClassExtension new initialize]) instanceMethodDefinitions includesKey: #mover).
%

category: '*rowan-tests-components'
method: RwRowanProjectIssuesTest
_cloneGitRepositoryFor: projectName projectUrlString: projectUrlString

	| rowanProject projectTools gitRootPath |
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	(RwComponentProjectDefinition newForUrl: projectUrlString)
		projectHome: gitRootPath;
		clone;
		register.
%

category: '*rowan-tests-35x'
method: RwRowanProjectIssuesTest
_createLoadedProjectNamed: projectName packageNames: packageNames root: rootPath symbolDictionaryName: symbolDictionaryName validate: validate

	| projectDefinition project |

	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	projectDefinition := (self
		_standardProjectDefinition: projectName
		packageNames: packageNames
		defaultSymbolDictName: symbolDictionaryName
		comment: 'Basic project ', projectName printString)
			packageFormat: 'tonel';
			projectHome: rootPath; 
			configsPath: 'configs';
			packagesPath: 'src';
			projectsPath: 'src';
			specsPath: 'specs';
			yourself.

	self
		handleConfirmationDuring: [
			projectDefinition create ].

	Rowan projectTools load loadProjectDefinition: projectDefinition.

	project := RwProject newNamed: projectName.

	validate ifTrue: [ self assert: project isDirty ]. "a project is dirty if it has changes that are not written to disk"
%

! Class extensions for 'RwRowanSample2Test'

!		Instance methods for 'RwRowanSample2Test'

category: '*rowan-tests-35x'
method: RwRowanSample2Test
testIssue493

	"https://github.com/GemTalk/Rowan/issues/493"

	"started as Issue #515 test, but turned into issue #493 test, once #515 fixed"

	"load migration_1, set all of the instance variables (a-f, ivar0-ivar2), then load migration_2. after automtic migration the permanent instance variables (a-f) should retain the values, while the moved instance variables (ivar0-ivar2) should be niled out"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName instanceMap projectDef |
	projectName := 'RowanSample2'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

  	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample2SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: self _testRowanProjectsSandbox
		registerProject: false.

	projectDef defaultSymbolDictName: self _symbolDictionaryName.

	gitRootPath := projectDef repositoryRoot.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: self _migration_1_branchName.
	projectDef read; load.

	instanceMap := IdentityKeyValueDictionary new.
	self _migrationClassMap
		do: [ :ar | 
			| className ivs class instance |
			className := ar at: 1.
			class := Rowan globalNamed: className.
			instance := class new.
			ivs := ar at: 2.
			ivs do: [ :ivName | instance perform: ivName , ':' with: ivName ].
			instanceMap at: instance put: ar -> class ].

	gitTool gitcheckoutIn: gitRootPath with: self _migration_2_branchName.

	projectDef := (Rowan projectNamed: projectName) asDefinition.
	projectDef
		defaultSymbolDictName: self _symbolDictionaryName1;
		read;
		load.
%

category: '*rowan-tests-35x'
method: RwRowanSample2Test
testIssue515

	"https://github.com/GemTalk/Rowan/issues/515"

	"load migration_1, set all of the instance variables (a-f, ivar0-ivar2), then load migration_2. after automtic migration the permanent instance variables (a-f) should retain the values, while the moved instance variables (ivar0-ivar2) should be niled out"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName instanceMap projectDef |
	projectName := 'RowanSample2'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].

  	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample2SpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: self _testRowanProjectsSandbox
		registerProject: false.

	projectDef defaultSymbolDictName: self _symbolDictionaryName.

	gitRootPath := projectDef repositoryRoot.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: gitRootPath with: self _migration_1_branchName.
	projectDef read; load.

	instanceMap := IdentityKeyValueDictionary new.
	self _migrationClassMap
		do: [ :ar | 
			| className ivs class instance |
			className := ar at: 1.
			class := Rowan globalNamed: className.
			instance := class new.
			ivs := ar at: 2.
			ivs do: [ :ivName | instance perform: ivName , ':' with: ivName ].
			instanceMap at: instance put: ar -> class ].

	gitTool gitcheckoutIn: gitRootPath with: self _migration_2_branchName.

	projectDef := (Rowan projectNamed: projectName) asDefinition.
	projectDef
		defaultSymbolDictName: self _symbolDictionaryName;
		read;
		load.

"load RowanSample1 project into RowanSample2 dictionary"
	projectName := 'RowanSample1'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :project | Rowan image _removeLoadedProject: project ].
	specUrlString := self _rowanSample1LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	projectDef := self 
		_cloneProjectFromSpecUrl: specUrlString 
		projectsHome: gitRootPath
		registerProject: false.

	projectDef
		defaultSymbolDictName: 'RowanSample2';
		yourself.

"load project"
	projectDef load.
"watch out ... jadeite won't bhave well with class and symbol dictionary of same name ... but that's okay"
%

category: '*rowan-tests-35x'
method: RwRowanSample2Test
_migration_0_branchName
	^   'masterV2.0'
%

category: '*rowan-tests-35x'
method: RwRowanSample2Test
_migration_1_branchName
	^ 'migration_1_v2'
%

category: '*rowan-tests-35x'
method: RwRowanSample2Test
_migration_2_branchName
	^ 'migration_2_v2'
%

category: '*rowan-tests-35x'
method: RwRowanSample2Test
_rowanSample1LoadSpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath , '/samples/RowanSample1_v2.ston'
%

category: '*rowan-tests-35x'
method: RwRowanSample2Test
_rowanSample2SpecificationUrl
	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath
		, '/test/specs/RowanSample2_masterV2.ston'
%

category: '*rowan-tests-35x'
method: RwRowanSample2Test
_rowanSample2_bitbucketSpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath
		, '/test/specs/RowanSample2_bitbucket_v2.ston'
%

category: '*rowan-tests-35x'
method: RwRowanSample2Test
_rowanSample2_gitlabSpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath
		, '/test/specs/RowanSample2_gitlab_v2.ston'
%

category: '*rowan-tests-35x'
method: RwRowanSample2Test
_rowanSample2_gitoliteSpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath
		, '/test/specs/RowanSample2_gitolite_v2.ston'
%

! Class extensions for 'RwRowanSample4Test'

!		Instance methods for 'RwRowanSample4Test'

category: '*rowan-tests-35x'
method: RwRowanSample4Test
testIssue185_move_class_to_symbolDict_A_v20

	"https://github.com/dalehenrich/Rowan/issues/185"

	"issue_185_1 --> issue_185_3	:: move NewRowanSample4 class to RowanSample4SymbolDict symbol dictionary (no package rename)"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar |

	projectName := 'RowanSample4'.
	Rowan
		projectNamed: projectName 
		ifPresent: [:prj | Rowan image _removeLoadedProject: prj _loadedProject ].
	Rowan 
		projectNamed: projectName 
		ifPresent: [ :prj | self error: 'The project ', projectName printString, ' should not be loaded' ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_0'.				"starting point of test"

	project load.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames asArray) = #('tests').
	self assert: (x := project loadedConfigurationNames asArray) = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	project load.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_185_3'.				"Move NewRowanSample4 class to RowanSample4SymbolDict"

	project load.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4SymbolDict'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: '*rowan-tests-components'
method: RwRowanSample4Test
testIssue200

	"https://github.com/dalehenrich/Rowan/issues/200"

	"load RowanSampl4 project which depends upon RowanSample3"

	| specUrlString projectTools rowanProject gitRootPath project repoRootPath x
		projectName3 projectName4 |

	projectName3 := 'RowanSample3'.
	projectName4 := 'RowanSample4'.
	{ projectName3 . projectName4 } do: [:projectName |
		(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
			ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName3) ensureDeleteAll.
	(gitRootPath / projectName4) ensureDeleteAll.

	self deny: (gitRootPath / projectName3) exists.
	self deny: (gitRootPath / projectName4) exists.

	specUrlString := self _rowanSample4_200_LoadSpecificationUrl.

	(RwComponentProjectDefinition newForUrl: specUrlString)
		projectHome: gitRootPath;
		clone;
		register.

	project := Rowan projectNamed: projectName4.

	repoRootPath := project repositoryRootPath asFileReference.

	self assert: project currentBranchName = 'issue_200_0'.
	self deny: (Rowan globalNamed: 'RowanSample5') notNil.
	self deny: (Rowan globalNamed: 'RowanSample3') notNil.
	self deny: (Rowan globalNamed: 'RowanSample4') notNil.

"load"
	self
		handleInformDuring: [ project load ]
		interactionBlock: [ :inform | self assert: false description: 'unexpected inform' ].

"validate"
	self assert: (Rowan globalNamed: 'RowanSample5') notNil.
	self assert: (Rowan globalNamed: 'RowanSample3') notNil.
	self assert: (Rowan globalNamed: 'RowanSample4') notNil.

	project := Rowan projectNamed: projectName4.
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	project := Rowan projectNamed: projectName3.
	self assert: (x := project loadedConfigurationNames) asArray = #('Default').

	self assert: (gitRootPath / projectName4) exists.
	self assert: (gitRootPath / projectName3) exists.
%

category: '*rowan-tests-components'
method: RwRowanSample4Test
testIssue295_rename_package_move_newClassVersion_newProject_3

	"version of testIssue295_rename_package_move_newClassVersion_newProject_2 that should pass using RwProjectDefinition or RwProjectComponentDefinition"

	"attempting to reproduce the actual issue (_1 doesn't reproduce problem, but should remain static to ensure behavior does not change detrimentally"

	"https://github.com/dalehenrich/Rowan/issues/295"

	"Error creating a new class version while moving to a new package in a new project and a new symbol dictionary"

	"issue_295_1 --> issue_295_3	:: rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
													move new version of NewRowanSample4 to RowanSample4SymbolDict in new project"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName project x repoRootPath 
		baselinePackageNames newClass ar oldClass projectDefinition projectSetDefinition oldProjectDefinition |
	projectName := 'RowanSample4'.
	{ projectName . projectName, '_295'} do: [:pn |
		(Rowan image loadedProjectNamed: pn ifAbsent: [  ])
			ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ] ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath.

	project := Rowan projectNamed: projectName.
	repoRootPath := project repositoryRootPath asFileReference.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_0'.				"starting point of test"

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	baselinePackageNames := #( 'RowanSample4-Core' 'RowanSample4-Extensions' 'RowanSample4-Tests' 'RowanSample4-GemStone' 
											'RowanSample4-GemStone-Tests').
	self
		assert:
			(x := project packageNames asArray sort) =  baselinePackageNames sort.

	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_1'.				"New package added to the project"

	self assert: (Rowan globalNamed: 'NewRowanSample4') isNil.

	projectTools load
		loadProjectNamed: projectName
		instanceMigrator: RwGsInstanceMigrator noMigration.

	self
		assert:
			(x := project packageNames asArray sort) =  (baselinePackageNames, #('RowanSample4-NewPackage')) sort.

	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (ar first at: 1) name = #'RowanSample4DictionarySymbolDict'.

	gitTool gitcheckoutIn: repoRootPath with: 'issue_295_3'.				"Rename RowanSample4-NewPackage to RowanSample4-RenamedPackage; 
																								move new version of NewRowanSample4 to RowanSample4SymbolDict"
"trigger the bug on this load"
	specUrlString := self _rowanSample4LoadSpecificationUrl_295.

"need to add old project definition with all classes and extensions removed to the projectSet Definition to reproduce bug"
	projectSetDefinition := self _projectDefinitionFromSpecUrl: specUrlString projectRootPath: repoRootPath.
	projectDefinition := projectSetDefinition projectNamed: projectName, '_295'.

	self assert: (projectDefinition projectDefinitionSourceProperty = RwLoadedProject _projectDiskDefinitionSourceValue).

	oldProjectDefinition := (Rowan image loadedProjectNamed: 'RowanSample4') asDefinition.
	projectSetDefinition addProject: oldProjectDefinition.

	oldProjectDefinition packages values do: [:pkgDefinition |
	    pkgDefinition classDefinitions values do: [:classDefinition |
	        pkgDefinition removeClassDefinition: classDefinition ].
	    pkgDefinition classExtensions values do: [:classExtension |
        	pkgDefinition removeClassExtensionDefinition: classExtension ]].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.
	Rowan projectTools load markProjectSetNotDirty: projectSetDefinition.


	oldClass := newClass.
	newClass := Rowan globalNamed: 'NewRowanSample4'.

	self assert: oldClass ~~ newClass.
	self assert: (newClass new perform: #foo) = 'foo'.

	ar := Rowan image symbolList dictionariesAndSymbolsOf: newClass.
	self assert: (x := (ar first at: 1) name) = #'RowanSample4DictionarySymbolDict_295_3'.

	self deny: ((Rowan globalNamed: 'RowanSample4DictionarySymbolDict') includesKey: #'NewRowanSample4')
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
testLoadComponentProjectFromUrl

	| specUrlString projectTools projectName x project masterBranchSHA |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	projectTools load loadFromUrl: specUrlString.

	masterBranchSHA := 'ea371eb'.

	project := Rowan projectNamed: projectName.
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').
	self assert: (x := project loadedGroupNames) asArray = #('tests').
	self deny: (x := project loadedCommitId) = masterBranchSHA.
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
testLoadProjectNamed_221A_v20

	"https://github.com/dalehenrich/Rowan/issues/221"

	"default configuration loading behavior differs between v1.2 and v2.0 ... this is the v1.2 variant"

	| specUrlString projectTools rowanProject gitTool gitRootPath projectName repoRootPath x 
		project audit |

	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].

	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	projectTools := Rowan projectTools.

	gitRootPath := self _testRowanProjectsSandbox.

	(gitRootPath / projectName) ensureDeleteAll.

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: gitRootPath registerProject: true.

	repoRootPath := gitRootPath / projectName.

	gitTool := projectTools git.
	gitTool gitcheckoutIn: repoRootPath with: 'issue_302'.

"load core group"
	self 
		_loadProjectFromSpecUrl: (self _rowanSample4_coreSpecificationUrl: repoRootPath)
		repoRootPath: repoRootPath.

"validate"
	project := Rowan projectNamed: projectName.
	self assert: (audit := project audit) isEmpty.
	self assert: (Rowan globalNamed: 'RowanSample4') notNil.
	self assert: (Rowan globalNamed: 'RowanSample4Test') isNil.
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').
	self assert: (x := project loadedGroupNames) asArray = #('core').

"load tests group"
	projectTools load
		loadProjectNamed: 'RowanSample4' withGroupNames: #('tests').

"validate"
	self assert: (audit := project audit) isEmpty.
	self assert: (Rowan globalNamed: 'RowanSample4') notNil.
	self assert: (Rowan globalNamed: 'RowanSample4Test') notNil.
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').
	self assert: (x := project loadedGroupNames) asArray = #('tests').

"load core group -- unload the tests package"
	projectTools load
		loadProjectNamed: 'RowanSample4' withGroupNames: #('core').

"validate"
	self assert: (audit := project audit) isEmpty.
	self assert: (Rowan globalNamed: 'RowanSample4') notNil.
	self assert: (Rowan globalNamed: 'RowanSample4Test') isNil.
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').
	self assert: (x := project loadedGroupNames) asArray = #('core').

"load Core configuration -- tests loaded"
	projectTools load
		loadProjectNamed: 'RowanSample4' withConfigurations: #( 'Core' ) groupNames: #().

"validate"
	self assert: (audit := project audit) isEmpty.
	self assert: (Rowan globalNamed: 'RowanSample4') notNil.
	self assert: (Rowan globalNamed: 'RowanSample4Test') notNil.
	self assert: (x := project loadedConfigurationNames) asArray = #( 'Core' ).
	self assert: (x := project loadedGroupNames) asArray = #( 'core' ).

"(re)load project"
	projectTools load
		loadProjectNamed: 'RowanSample4'.

"validate"
	self assert: (audit := project audit) isEmpty.
	self assert: (Rowan globalNamed: 'RowanSample4') notNil.
	self assert: (Rowan globalNamed: 'RowanSample4Test') notNil.
	self assert: (x := project  loadedConfigurationNames) asArray = #( 'Core' ).
	self assert: (x := project loadedGroupNames) asArray = #( 'core' ).

"load Load configuraiont and core group -- unload the tests package"
	projectTools load
		loadProjectNamed: 'RowanSample4' withConfigurations: #('Load') groupNames: #('core').

"validate"
	self assert: (audit := project audit) isEmpty.
	self assert: (Rowan globalNamed: 'RowanSample4') notNil.
	self assert: (Rowan globalNamed: 'RowanSample4Test') isNil.
	self assert: (x := project loadedConfigurationNames) asArray = #('Load').
	self assert: (x := project  loadedGroupNames) asArray = #('core').
%

category: '*rowan-tests-components'
method: RwRowanSample4Test
test_projectUrl_issue_463
	| specUrlString rowanProject testProjectHome projectName project projectDef |
	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	testProjectHome := self _testRowanProjectsSandbox.
	(testProjectHome / projectName) exists
		ifTrue: [ (testProjectHome / projectName) deleteAll ].
	projectDef := (RwComponentProjectDefinition newForUrl: specUrlString)
		projectHome: testProjectHome;
		defaultSymbolDictName: self _symbolDictionaryName1;
		yourself.
	self
		handleInformDuring: [ projectDef clone ]
		interactionBlock: [ :inform | self assert: false description: 'unexpected inform' ].
	self
		assert: projectDef projectUrl = 'https://github.com/dalehenrich/RowanSample4'.
	projectDef load.
	project := RwProject newNamed: projectName.
	self assert: project projectUrl = projectDef projectUrl
%

category: '*rowan-tests-components'
method: RwRowanSample4Test
test_projectUrl_issue_527
	"https://github.com/GemTalk/Rowan/issues/527"

	| specUrlString rowanProject testProjectHome projectName project projectDef  gitTool |
	projectName := 'RowanSample4'.
	(Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
		ifNotNil: [ :prj | Rowan image _removeLoadedProject: prj ].
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	specUrlString := self _rowanSample4LoadSpecificationUrl.
	testProjectHome := self _testRowanProjectsSandbox.
	(testProjectHome / projectName) exists
		ifTrue: [ (testProjectHome / projectName) deleteAll ].
	projectDef := (RwComponentProjectDefinition newForUrl: specUrlString)
		projectHome: testProjectHome;
"		defaultSymbolDictName: self _symbolDictionaryName1;"
		yourself.
	self
		handleInformDuring: [ projectDef clone ]
		interactionBlock: [ :inform | self assert: false description: 'unexpected inform' ].

	gitTool := Rowan projectTools git.
	gitTool gitcheckoutIn: (testProjectHome / projectName) with: 'fb3fdc5'.

	self
		assert: projectDef projectUrl = 'https://github.com/dalehenrich/RowanSample4'.
self error: 'run tests interactivly, since loading project into UserGlobals (this is the bug) gums up the testing works'.
	projectDef load.
	project := RwProject newNamed: projectName.
	self assert: project projectUrl = projectDef projectUrl
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_cloneAndCreateProjectDefinitionFromSpecUrl: specUrlString projectRootPath: projectRootPath

	| projectDefinition projectSetDefinition |
	projectDefinition := (RwComponentProjectDefinition newForUrl: specUrlString)
		projectHome: projectRootPath parent;
		clone;
		yourself.
	projectSetDefinition := Rowan projectTools read readProjectSetForComponentProjectDefinition: projectDefinition.
	^ projectSetDefinition projectNamed: projectDefinition name
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_cloneProjectFromSpecUrl_300: specUrlString projectsHome: projectsHome registerProject: aBool

	self _cloneProjectFromSpecUrl: specUrlString projectsHome: projectsHome registerProject: aBool
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_createProjectDefinitionFromSpecUrl: specUrlString projectName: projectName

	| rowanProject projectHome projectDefinition loadSpecUrl |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	projectHome := self _testRowanProjectsSandbox.

	(projectHome / projectName) ensureDeleteAll.

	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.
	projectDefinition projectHome: projectHome.
	projectDefinition cloneRepository.

	loadSpecUrl := 'file:', (projectHome / projectName / projectDefinition specsPath / 'RowanSample4_load_v2.ston') pathString.
	projectDefinition := RwComponentProjectDefinition newForUrl: loadSpecUrl.
	projectDefinition projectHome: projectHome.
	projectDefinition register.
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_loadProjectFromSpecUrl: specUrlString repoRootPath: repoRootPath

	| projectDefinition projectSetDefinition |
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.
	projectDefinition repositoryRoot: repoRootPath.
	projectSetDefinition := projectDefinition read.
	^ projectSetDefinition load
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_projectDefinitionFromSpecUrl: specUrlString projectRootPath: projectRootPath

	| projectDefinition |
	projectDefinition := RwComponentProjectDefinition newForUrl: specUrlString.
	projectDefinition repositoryRoot: projectRootPath.
	projectDefinition cloneRepository.
	^ projectDefinition read
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_rowanSample4LoadSpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample4_load_v2.ston'
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_rowanSample4LoadSpecificationUrl_295

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample4_295_v2.ston'
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_rowanSample4SpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , (rowanProject repositoryRootPath asFileReference / 'test/specs/RowanSample4_v2.ston') pathString
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_rowanSample4_208_LoadSpecificationUrl

	| rowanProject |
	rowanProject := Rowan image _projectForNonTestProject: 'Rowan'.
	^ 'file:' , rowanProject repositoryRootPath , '/test/specs/RowanSample4_208_load_v2.ston'
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_rowanSample4_coreSpecificationUrl: repositoryRootPath

	^ 'file:' , repositoryRootPath pathString, '/rowan/specs/RowanSample4_core_v2.ston'
%

category: '*rowan-tests-35x'
method: RwRowanSample4Test
_rowanSample4_loadSpecificationUrl: repositoryRootPath

	^ 'file:' , repositoryRootPath pathString, '/rowan/specs/RowanSample4_load_v2.ston'
%

! Class extensions for 'RwRowanSampleAbstractTest'

!		Instance methods for 'RwRowanSampleAbstractTest'

category: '*rowan-tests-35x'
method: RwRowanSampleAbstractTest
_cloneProjectFromSpecUrl: specUrlString projectsHome: projectsHome
	^ self
		_cloneProjectFromSpecUrl: specUrlString
		projectsHome: projectsHome
		registerProject: true
%

category: '*rowan-tests-35x'
method: RwRowanSampleAbstractTest
_cloneProjectFromSpecUrl: specUrlString projectsHome: projectsHome registerProject: aBool

	| projectDefinition |
	projectDefinition := (RwComponentProjectDefinition newForUrl: specUrlString)
		projectHome: projectsHome;
		clone;
		yourself.
	aBool ifTrue: [ projectDefinition register ].
	^ projectDefinition
%

! Class Initialization

run
RwLoadingTest initialize.
true
%
