! Class Declarations

doit
(CypressMethodDefinition
	subclass: 'RwCypressMethodDefinition'
	instVarNames: #( isExtensionMethod )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Cypress-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(CypressMethodStructure
	subclass: 'RwCypressMethodStructure'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Cypress-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(CypressPackageStructure
	subclass: 'RwCypressPackageStructure'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Cypress-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Magnitude
	indexableSubclass: 'RwGemStoneVersionNumber'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '# GemStone version format

GemStone versions are simply an unbounded collection of $. separated positive integers.';
		immediateInvariant.
true.
%

doit
(Magnitude
	subclass: 'RwSemanticVersionNumber'
	instVarNames: #( normalVersion preReleaseVersion buildVersion )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: 'RwSemanticVersionNumber conforms to version 2.0.0 of  [Semantic Versioning 2.0.0](http://semver.org/)

**Semantic Versioning Specification** extracted from [Semantic versioning 2.0.0](https://raw.githubusercontent.com/semver/semver/347f73f880ebe1de61891832bf8702e864ca0998/semver.md):

Semantic Versioning 2.0.0
==============================

Summary
-------

Given a version number MAJOR.MINOR.PATCH, increment the:

1. MAJOR version when you make incompatible API changes,
1. MINOR version when you add functionality in a backwards-compatible
   manner, and
1. PATCH version when you make backwards-compatible bug fixes.

Additional labels for pre-release and build metadata are available as extensions
to the MAJOR.MINOR.PATCH format.

Introduction
------------

In the world of software management there exists a dreaded place called
"dependency hell." The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.

As a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
These rules are based on but not necessarily limited to pre-existing
widespread common practices in use in both closed and open-source software.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.

I call this system "Semantic Versioning." Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.


Semantic Versioning Specification (SemVer)
------------------------------------------

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [RFC 2119](http://tools.ietf.org/html/rfc2119).

1. Software using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.

1. A normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.

1. Once a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.

1. Major version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.

1. Version 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.

1. Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.

1. Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.

1. Major version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.

1. A pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphen
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.

1. Build metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.

1. Precedence refers to how versions are compared to each other when ordered.
Precedence MUST be calculated by separating the version into major, minor, patch
and pre-release identifiers in that order (Build metadata does not figure
into precedence). Precedence is determined by the first difference when
comparing each of these identifiers from left to right as follows: Major, minor,
and patch versions are always compared numerically. Example: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. When major, minor, and patch are equal, a pre-release version has
lower precedence than a normal version. Example: 1.0.0-alpha < 1.0.0. Precedence
for two pre-release versions with the same major, minor, and patch version MUST
be determined by comparing each dot separated identifier from left to right
until a difference is found as follows: identifiers consisting of only digits
are compared numerically and identifiers with letters or hyphens are compared
lexically in ASCII sort order. Numeric identifiers always have lower precedence
than non-numeric identifiers. A larger set of pre-release fields has a higher
precedence than a smaller set, if all of the preceding identifiers are equal.
Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.

BackusÂ–Naur Form Grammar for Valid SemVer Versions
--------------------------------------------------

    <valid semver> ::= <version core>
                     | <version core> "-" <pre-release>
                     | <version core> "+" <build>
                     | <version core> "-" <pre-release> "+" <build>

    <version core> ::= <major> "." <minor> "." <patch>

    <major> ::= <numeric identifier>

    <minor> ::= <numeric identifier>

    <patch> ::= <numeric identifier>

    <pre-release> ::= <dot-separated pre-release identifiers>

    <dot-separated pre-release identifiers> ::= <pre-release identifier>
                                              | <pre-release identifier> "." <dot-separated pre-release identifiers>

    <build> ::= <dot-separated build identifiers>

    <dot-separated build identifiers> ::= <build identifier>
                                        | <build identifier> "." <dot-separated build identifiers>

    <pre-release identifier> ::= <alphanumeric identifier>
                               | <numeric identifier>

    <build identifier> ::= <alphanumeric identifier>
                         | <digits>

    <alphanumeric identifier> ::= <non-digit>
                                | <non-digit> <identifier characters>
                                | <identifier characters> <non-digit>
                                | <identifier characters> <non-digit> <identifier characters>

    <numeric identifier> ::= "0"
                           | <positive digit>
                           | <positive digit> <digits>

    <identifier characters> ::= <identifier character>
                              | <identifier character> <identifier characters>

    <identifier character> ::= <digit>
                             | <non-digit>

    <non-digit> ::= <letter>
                  | "-"

    <digits> ::= <digit>
               | <digit> <digits>

    <digit> ::= "0"
              | <positive digit>

    <positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

    <letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
               | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
               | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
               | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
               | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
               | "y" | "z"


Why Use Semantic Versioning?
----------------------------

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that "close" isn''t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called "Firetruck." It requires a
Semantically Versioned package named "Ladder." At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there''s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.


FAQ
---

### How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

### How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you''re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.

### Doesn''t this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you''re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.

### If even the tiniest backwards incompatible changes to the public API require a major version bump, won''t I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you''ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

### Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that''s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

### What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you''ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it''s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

### What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it''s obviously a minor level increment.

### What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

### How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.

### Does SemVer have a size limit on the version string?

No, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.

### Is "v1.2.3" a semantic version?

No, "v1.2.3" is not a semantic version. However, prefixing a semantic version
with a "v" is a common way (in English) to indicate it is a version number.
Abbreviating "version" as "v" is often seen with version control. Example:
`git tag v1.2.3 -m "Release version 1.2.3"`, in which case "v1.2.3" is a tag
name and the semantic version is "1.2.3".


About
-----

The Semantic Versioning specification is authored by [Tom
Preston-Werner](http://tom.preston-werner.com), inventor of Gravatar and
cofounder of GitHub.

If you''d like to leave feedback, please [open an issue on
GitHub](https://github.com/mojombo/semver/issues).


License
-------

Creative Commons - CC BY 3.0
http://creativecommons.org/licenses/by/3.0/';
		immediateInvariant.
true.
%

doit
(Notification
	subclass: 'GsInteractionRequest'
	instVarNames: #( interaction )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Notification
	subclass: 'RwNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'General way for Cypress to toss things up the stack for consideration by a higher authority.';
		immediateInvariant.
true.
%

doit
(RwNotification
	subclass: 'RwAddUpdateRemoveMethodForUnpackagedClassNotification'
	instVarNames: #( errorMessage )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwNotification
	subclass: 'RwAdoptAuditErrorNotification'
	instVarNames: #( className isClassExtension packageName description )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAdoptAuditErrorNotification
	subclass: 'RwAdoptAuditClassErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAdoptAuditClassErrorNotification
	subclass: 'RwAdoptMissingClassErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAdoptAuditClassErrorNotification
	subclass: 'RwAuditClassErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAdoptAuditErrorNotification
	subclass: 'RwAdoptAuditMethodErrorNotification'
	instVarNames: #( selector isMetaclass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAdoptAuditMethodErrorNotification
	subclass: 'RwAdoptMissingMethodErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAdoptAuditMethodErrorNotification
	subclass: 'RwAuditMethodErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwNotification
	subclass: 'RwDeleteClassFromSystemNotification'
	instVarNames: #( candidateClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwNotification
	subclass: 'RwExecuteClassInitializeMethodsAfterLoadNotification'
	instVarNames: #( candidateClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwNotification
	subclass: 'RwExistingAssociationWithSameKeyNotification'
	instVarNames: #( errorMessage )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwNotification
	subclass: 'RwExistingVisitorAddingExistingClassNotification'
	instVarNames: #( classDefinition loadedProject )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwNotification
	subclass: 'RwInvalidCategoryProtocolConventionErrorNotification'
	instVarNames: #( packageName packageConvention )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwInvalidCategoryProtocolConventionErrorNotification
	subclass: 'RwInvalidClassCategoryConventionErrorNotification'
	instVarNames: #( classDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwInvalidCategoryProtocolConventionErrorNotification
	subclass: 'RwInvalidMethodProtocolConventionErrorNotification'
	instVarNames: #( methodDefinition className isMeta )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwInvalidMethodProtocolConventionErrorNotification
	subclass: 'RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwInvalidMethodProtocolConventionErrorNotification
	subclass: 'RwExtensionProtocolNonExtensionMethodErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwInvalidMethodProtocolConventionErrorNotification
	subclass: 'RwNonExtensionProtocolExtensionMethodErrorNotification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwNotification
	subclass: 'RwPerformingUnpackagedEditNotification'
	instVarNames: #( informMessage )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'GsInteraction'
	instVarNames: #( defaultActionBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(GsInteraction
	subclass: 'GsChoiceInteraction'
	instVarNames: #( prompt labels values lines )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(GsInteraction
	subclass: 'GsConfirmInteraction'
	instVarNames: #( prompt confirm cancel abort )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(GsConfirmInteraction
	subclass: 'GsNotifyInteraction'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(GsInteraction
	subclass: 'GsInformInteraction'
	instVarNames: #( message )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(GsInteraction
	subclass: 'GsInspectInteraction'
	instVarNames: #( theObject )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(GsInspectInteraction
	subclass: 'GsExploreInteraction'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(GsInteraction
	subclass: 'GsTextInteraction'
	instVarNames: #( prompt template requestPassword )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(GsTextInteraction
	subclass: 'GsMultiLineTextInteraction'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'GsInteractionHandler'
	instVarNames: #( choiceBlock confirmBlock informBlock textBlock multiLineTextBlock defaultBlock inspectBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'GemStone-Interactions-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'JadeServer'
	instVarNames: #( classList classOrganizers readStream writeStream selectedClass methodFilterType methodFilters selections methodCommandResult )
	classVars: #( ExternalInteger GciError GsObject OopType32 OopType64 )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #())
		category: 'Rowan-JadeServer';
		comment: '';
		immediateInvariant.
true.
%

doit
(JadeServer
	subclass: 'JadeServer64bit'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #())
		category: 'Rowan-JadeServer';
		comment: '';
		immediateInvariant.
true.
%

doit
(JadeServer64bit
	subclass: 'JadeServer64bit24'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #())
		category: 'Rowan-JadeServer';
		comment: '';
		immediateInvariant.
true.
%

doit
(JadeServer64bit24
	subclass: 'JadeServer64bit3x'
	instVarNames: #( environment )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #())
		category: 'Rowan-JadeServer';
		comment: '';
		immediateInvariant.
true.
%

doit
(JadeServer64bit3x
	subclass: 'JadeServer64bit32'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #())
		category: 'Rowan-JadeServer';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RBParser'
	instVarNames: #( scanner currentToken nextToken errorBlock source comments pragmas )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBParser takes a source code string and generates an AST for it. This is a hand-written, recursive descent parser and has been optimized for speed. The simplest way to call this is either ''RBParser parseExpression: aString'' if you want the AST for an expression, or ''RBParser parseMethod: aString'' if you want to parse an entire method.

Instance Variables:
	currentToken	<RBToken>	The current token being processed.
	emptyStatements	<Boolean>	True if empty statements are allowed. In IBM, they are, in VW they aren''t.
	errorBlock	<BlockClosure>	The block to evaluate on a syntax error.
	nextToken	<RBToken>	The next token that will be processed. This allows one-token lookahead.
	scanner	<RBScanner>	The scanner that generates a stream of tokens to parse.
	source	<String>	The source code to parse
	tags	<Collection of: Interval>	The source intervals of the tags appearing at the top of a method (e.g. Primitive calls)

Shared Variables:
	ParserType	<Symbol>	the type code we are parsing';
		immediateInvariant.
true.
%

doit
(RBParser
	subclass: 'RBPatternParser'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBPatternParser is a subclass of RBParser that allows the extended syntax that creates matching trees. These trees can be used by the ParseTreeMatcher to search and transform source code.
';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RBParseTreeRule'
	instVarNames: #( searchTree owner )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBParseTreeRule is the abstract superclass of all of the parse tree searching rules. A parse tree rule is the first class representation of a particular rule to search for. The owner of a rule is the algorithm that actually executes the search. This arrangement allows multiple searches to be conducted by a single Searcher.

Instance Variables:
	owner	<ParseTreeSearcher>	The searcher that is actually performing the search.
	searchTree	<RBProgramNode>	The parse tree to be searched.

';
		immediateInvariant.
true.
%

doit
(RBParseTreeRule
	subclass: 'RBReplaceRule'
	instVarNames: #( verificationBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBReplaceRule is the abstract superclass of all of the transforming rules. The rules change the source code by replacing the node that matches the rule. Subclasses implement different strategies for this replacement.

Subclasses must implement the following messages:
	matching
		foundMatchFor:

Instance Variables:
	verificationBlock	<BlockClosure>	Is evaluated with the matching node. This allows for further verification of a match beyond simple tree matching.

';
		immediateInvariant.
true.
%

doit
(RBReplaceRule
	subclass: 'RBBlockReplaceRule'
	instVarNames: #( replaceBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBBlockReplaceRule replaces the matching node by the result of evaluating replaceBlock. This allows arbitrary computation to come up with a replacement.

Instance Variables:
	replaceBlock	<BlockClosure>	The block that returns the node to replace to matching node with.
';
		immediateInvariant.
true.
%

doit
(RBReplaceRule
	subclass: 'RBStringReplaceRule'
	instVarNames: #( replaceTree )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBStringReplaceRule replaces a matched tree with another tree (which may include metavariable from the matching tree). This is a very succint syntax for specifying most rewrites.

Instance Variables:
	replaceTree	<RBProgramNode>	The tree to replace the matched tree with.

';
		immediateInvariant.
true.
%

doit
(RBParseTreeRule
	subclass: 'RBSearchRule'
	instVarNames: #( answerBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBSearchRule is a parse tree rule that simply searches for matches to the rule. Every time a match is found, answerBlock is evaluated with the node that matches and the cureent answer. This two-argument approach allows a collection to be formed from all of the matches (Think inject:into:).

Instance Variables:
	answerBlock	<BlockClosure>	Block to evaluate with the matching node and the current answer.

';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RBProgramNode'
	instVarNames: #( parent comments properties )
	classVars: #( FormatterClass )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBProgramNode is an abstract class that represents an abstract syntax tree node in a Smalltalk program.

Subclasses must implement the following messages:
	accessing
		start
		stop
	visitor
		acceptVisitor:

The #start and #stop methods are used to find the source that corresponds to this node. "source copyFrom: self start to: self stop" should return the source for this node.

The #acceptVisitor: method is used by RBProgramNodeVisitors (the visitor pattern). This will also require updating all the RBProgramNodeVisitors so that they know of the new node.

Subclasses might also want to redefine match:inContext: and copyInContext: to do parse tree searching and replacing.

Subclasses that contain other nodes should override equalTo:withMapping: to compare nodes while ignoring renaming temporary variables, and children that returns a collection of our children nodes.

Instance Variables:
	comments	<Collection of: Interval>	the intervals in the source that have comments for this node
	parent	<RBProgramNode>	the node we''re contained in

Shared Variables:
	FormatterClass	<Behavior>	the formatter class that is used when we are formatted';
		immediateInvariant.
true.
%

doit
(RBProgramNode
	subclass: 'RBMethodNode'
	instVarNames: #( selector selectorParts body source arguments pragmas replacements nodeReplacements )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBMethodNode is the AST that represents a Smalltalk method.

Instance Variables:
	arguments	<SequenceableCollection of: RBVariableNode>	the arguments to the method
	body	<BRSequenceNode>	the body/statements of the method
	nodeReplacements	<Dictionary>	a dictionary of oldNode -> newNode replacements
	replacements	<Collection of: RBStringReplacement>	the collection of string replacements for each node replacement in the parse tree
	selector	<Symbol | nil>	the method name (cached)
	selectorParts	<SequenceableCollection of: RBValueToken>	the tokens for the selector keywords
	source	<String>	the source we compiled
	tags	<Collection of: Interval>	the source location of any resource/primitive tags

';
		immediateInvariant.
true.
%

doit
(RBMethodNode
	subclass: 'RBPatternMethodNode'
	instVarNames: #( isList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBPatternMethodNode is a RBMethodNode that will match other method nodes without their selectors being equal. 

Instance Variables:
	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)

';
		immediateInvariant.
true.
%

doit
(RBProgramNode
	subclass: 'RBPragmaNode'
	instVarNames: #( selector selectorParts arguments isProtected left right )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBPragmaNode is an AST node that represents a method pragma.

Instance Variables:
	arguments <SequenceableCollection of: RBLiteralNode> our argument nodes
	left <Integer | nil> position of <
	right <Integer | nil> position of >
	selector <Symbol | nil>	the selector we''re sending (cached)
	selectorParts <SequenceableCollection of: RBValueToken> the tokens for each keyword';
		immediateInvariant.
true.
%

doit
(RBPragmaNode
	subclass: 'RBPatternPragmaNode'
	instVarNames: #( isList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RBProgramNode
	subclass: 'RBReturnNode'
	instVarNames: #( return value )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBReturnNode is an AST node that represents a return expression.

Instance Variables:
	return	<Integer>	the position of the ^ character
	value	<RBValueNode>	the value that is being returned

';
		immediateInvariant.
true.
%

doit
(RBProgramNode
	subclass: 'RBSequenceNode'
	instVarNames: #( leftBar rightBar statements periods temporaries )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBSequenceNode is an AST node that represents a sequence of statements. Both RBBlockNodes and RBMethodNodes contain these.

Instance Variables:
	leftBar	<Integer | nil>	the position of the left | in the temporaries definition
	periods	<SequenceableCollection of: Integer>	the positions of all the periods that separate the statements
	rightBar	<Integer | nil>	the position of the right | in the temporaries definition
	statements	<SequenceableCollection of: RBStatementNode>	the statement nodes
	temporaries	<SequenceableCollection of: RBVariableNode>	the temporaries defined

';
		immediateInvariant.
true.
%

doit
(RBProgramNode
	subclass: 'RBValueNode'
	instVarNames: #( parentheses )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBValueNode is an abstract class that represents a node that returns some value.

Subclasses must implement the following messages:
	accessing
		startWithoutParentheses
		stopWithoutParentheses
	testing
		needsParenthesis

Instance Variables:
	parentheses	<SequenceableCollection of: Inteval>	the positions of the parethesis around this node. We need a collection of intervals for stupid code such as "((3 + 4))" that has multiple parethesis around the same expression.

';
		immediateInvariant.
true.
%

doit
(RBValueNode
	subclass: 'RBArrayNode'
	instVarNames: #( left right statements periods )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'A RBArrayNode is an AST node for runtime arrays.

Instance Variables
	left:	 <Integer | nil> position of {
	periods: <SequenceableCollection of: Integer> the positions of all the periods that separate the statements
	right: <Integer | nil> position of }
	statements: <SequenceableCollection of: RBStatementNode> the statement nodes';
		immediateInvariant.
true.
%

doit
(RBValueNode
	subclass: 'RBAssignmentNode'
	instVarNames: #( variable assignment value )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBAssignmentNode is an AST node for assignment statements

Instance Variables:
	assignment	<Integer>	position of the :=
	value	<RBValueNode>	the value that we''re assigning
	variable	<RBVariableNode>	the variable being assigned

';
		immediateInvariant.
true.
%

doit
(RBValueNode
	subclass: 'RBBlockNode'
	instVarNames: #( left right colons arguments bar body )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBBlockNode is an AST node that represents a block "[...]".

Instance Variables:
	arguments	<SequenceableCollection of: RBVariableNode>	the arguments for the block
	bar	<Integer | nil>	position of the | after the arguments
	body	<RBSequenceNode>	the code inside the block
	colons	<SequenceableCollection of: Integer>	positions of each : before each argument
	left	<Integer>	position of [
	right	<Integer>	position of ]

';
		immediateInvariant.
true.
%

doit
(RBBlockNode
	subclass: 'RBPatternBlockNode'
	instVarNames: #( valueBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBPatternBlockNode is the node in matching parse trees (it never occurs in normal Smalltalk code) that executes a block to determine if a match occurs. valueBlock takes two arguments, the first is the actual node that we are trying to match against, and second node is the dictionary that contains all the metavariable bindings that the matcher has made thus far.

Instance Variables:
	valueBlock	<BlockClosure>	The block to execute when attempting to match this to a node.

';
		immediateInvariant.
true.
%

doit
(RBPatternBlockNode
	subclass: 'RBPatternWrapperBlockNode'
	instVarNames: #( wrappedNode )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBPatternWrapperBlockNode allows further matching using a block after a node has been matched by a pattern node.

Instance Variables:
	wrappedNode	<RBProgramNode>	The original pattern node to match';
		immediateInvariant.
true.
%

doit
(RBBlockNode
	subclass: 'RBQueryBlockNode'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RBValueNode
	subclass: 'RBCascadeNode'
	instVarNames: #( messages semicolons )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBCascadeNode is an AST node for cascaded messages (e.g., "self print1 ; print2").

Instance Variables:
	messages	<SequenceableCollection of: RBMessageNode>	the messages 
	semicolons	<SequenceableCollection of: Integer>	positions of the ; between messages

';
		immediateInvariant.
true.
%

doit
(RBValueNode
	subclass: 'RBLiteralNode'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBLiteralNode is an AST node that represents literals.';
		immediateInvariant.
true.
%

doit
(RBLiteralNode
	subclass: 'RBLiteralArrayNode'
	instVarNames: #( isByteArray stop contents start )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'A RBLiteralArrayNode is an AST node that represents literal arrays and literal byte arrays.

Instance Variables
	contents: <Array of: RBLiteralNode> literal nodes of the array
	isByteArray: <Boolean> if the receiver is a literal byte array
	start: <Integer | nil> source position of #( or #[
	stop: <Integer | nil> source position of ) or ]';
		immediateInvariant.
true.
%

doit
(RBLiteralNode
	subclass: 'RBLiteralValueNode'
	instVarNames: #( token )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBLiteralNode is an AST node that represents literal values (e.g., #foo, true, 1, etc.), but not literal arrays.

Instance Variables:
	token	<RBLiteralToken>	the token that contains the literal value as well as its source positions';
		immediateInvariant.
true.
%

doit
(RBValueNode
	subclass: 'RBMessageNode'
	instVarNames: #( receiver selector selectorParts arguments )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBMessageNode is an AST node that represents a message send.

Instance Variables:
	arguments	<SequenceableCollection of: RBValueNode>	our argument nodes
	receiver	<RBValueNode>	the receiver''s node
	selector	<Symbol | nil>	the selector we''re sending (cached)
	selectorParts	<SequenceableCollection of: RBValueToken>	the tokens for each keyword

';
		immediateInvariant.
true.
%

doit
(RBMessageNode
	subclass: 'RBPatternMessageNode'
	instVarNames: #( isList isCascadeList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBPatternMessageNode is a RBMessageNode that will match other message nodes without their selectors being equal. 

Instance Variables:
	isCascadeList	<Boolean>	are we matching a list of message nodes in a cascaded message
	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)';
		immediateInvariant.
true.
%

doit
(RBValueNode
	subclass: 'RBVariableNode'
	instVarNames: #( token )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBVariableNode is an AST node that represent a variable (global, inst var, temp, etc.).

Instance Variables:
	token	<RBValueToken>	the token that contains our name and position

';
		immediateInvariant.
true.
%

doit
(RBVariableNode
	subclass: 'RBPatternVariableNode'
	instVarNames: #( recurseInto isList isLiteral isStatement isAnything )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBPatternVariableNode is an AST node that is used to match several other types of nodes (literals, variables, value nodes, statement nodes, and sequences of statement nodes).

The different types of matches are determined by the name of the node. If the name contains a # character, then it will match a literal. If it contains, a . then it matches statements. If it contains no extra characters, then it matches only variables. These options are mutually exclusive.

The @ character can be combined with the name to match lists of items. If combined with the . character, then it will match a list of statement nodes (0 or more). If used without the . or # character, then it matches anything except for list of statements. Combining the @ with the # is not supported.

Adding another ` in the name will cause the search/replace to look for more matches inside the node that this node matched. This option should not be used for top level expressions since that would cause infinite recursion (e.g., searching only for "``@anything").

Instance Variables:
	isAnything	<Boolean>	can we match any type of node
	isList	<Boolean>	can we match a list of items (@)
	isLiteral	<Boolean>	only match a literal node (#)
	isStatement	<Boolean>	only match statements (.)
	recurseInto	<Boolean>	search for more matches in the node we match (`)

';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RBProgramNodeVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBProgramNodeVisitor is an abstract visitor for the RBProgramNodes.

';
		immediateInvariant.
true.
%

doit
(RBProgramNodeVisitor
	subclass: 'RBConfigurableFormatter'
	instVarNames: #( codeStream indent lookaheadCode originalSource lineStart inQueryBlock )
	classVars: #( CascadedMessageInsideParentheses FormatCommentWithStatements IndentsForKeywords IndentString InQueryBlock KeepBlockInMessage LineUpBlockBrackets MaxLineLength MethodSignatureOnMultipleLines MinimumNewLinesBetweenStatements MultiLineMessages NewLineAfterCascade NewLineBeforeFirstCascade NewLineBeforeFirstKeyword NewLinesAfterMethodComment NewLinesAfterMethodPattern NewLinesAfterTemporaries NumberOfArgumentsForMultiLine OneLineMessages PeriodsAtEndOfBlock PeriodsAtEndOfMethod RetainBlankLinesBetweenStatements StringFollowingReturn StringInsideBlocks StringInsideParentheses TraditionalBinaryPrecedence UseTraditionalBinaryPrecedenceForParentheses )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBConfigurableFormatter formats the Refactoring Browser''s parse trees. It has many more formatting options than the default formatter used by the RB. To change the RB to use this formatter, execute "RBProgramNode formatterClass: RBConfigurableFormatter". For some refactorings the RB must reformat the code after the change, so it is good to have a formatter configured to your tastes.

Instance Variables:
	codeStream	<PositionableStream>	the stream we are writing our output to
	indent	<Integer>	how many times are we indenting a new line -- indents are normally tabs but could be any whitespace string
	lineStart	<Integer>	the position of the character that started the current line. This is used for calculating the line length.
	lookaheadCode	<Dictionary key: RBProgramNode value: String>	sometimes we need to lookahead while formatting, this dictionary contains the nodes that have already been formatted by lookahead
	originalSource	<String>	the original source before we started formatting. This is used to extract the comments from the original source.

';
		immediateInvariant.
true.
%

doit
(RBProgramNodeVisitor
	subclass: 'RBFormatter'
	instVarNames: #( codeStream lineStart firstLineLength tabs inQueryBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBFormatter formats a parse tree. It is an example of a Visitor. This is rarely called directly. Sending ''formattedCode'' to a parse tree uses this algorithm to return a pretty-printed version.

Instance Variables:
	codeStream	<PositionableStream>	The buffer where the output is accumulated.
	firstLineLength	<Integer>	The length of the first line of a message send.
	lineStart	<Integer>	The position of the current line''s start.
	tabs	<Integer>	The number of tabs currently indented.

';
		immediateInvariant.
true.
%

doit
(RBProgramNodeVisitor
	subclass: 'RBParseTreeSearcher'
	instVarNames: #( searches answer argumentSearches context messages )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'ParseTreeSearcher walks over a normal source code parse tree using the visitor pattern, and then matches these nodes against the meta-nodes using the match:inContext: methods defined for the meta-nodes.

Instance Variables:
	answer	<Object>	the "answer" that is propagated between matches
	argumentSearches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	argument searches (search for the BRProgramNode and perform the BlockClosure when its found)
	context	<RBSmallDictionary>	a dictionary that contains what each meta-node matches against. This could be a normal Dictionary that is created for each search, but is created once and reused (efficiency).
	messages	<Collection>	the sent messages in our searches
	searches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	non-argument searches (search for the BRProgramNode and perform the BlockClosure when its found)';
		immediateInvariant.
true.
%

doit
(RBParseTreeSearcher
	subclass: 'RBParseTreeRewriter'
	instVarNames: #( tree )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then answer is set to true, and the modified tree can be retrieved by the #tree method.

Instance Variables:
	tree	<RBProgramNode>	the parse tree we''re transforming';
		immediateInvariant.
true.
%

doit
(RBProgramNodeVisitor
	subclass: 'RBReadBeforeWrittenTester'
	instVarNames: #( read checkNewTemps scopeStack )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBReadBeforeWrittenTester is a visitor that identifies variables that may have been read before they are initialized.

Instance Variables:
	checkNewTemps	<Boolean>	description of checkNewTemps
	read	<Collection>	description of read
	scopeStack	<OrderedCollection>	description of scopeStack

';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RBScanner'
	instVarNames: #( stream buffer tokenStart currentCharacter characterType classificationTable comments errorBlock )
	classVars: #( PatternVariableCharacter )
	classInstVars: #( classificationTable )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBScanner is a stream that returns a sequence of token from the string that it is created on. The tokens know where they came from in the source code and which comments were attached to them.

Instance Variables:
	buffer	<PositionableStream>	Accumulates the text for the current token.
	characterType	<ByteSymbol>	The type of the next character. (e.g. #alphabetic, etc.)
	classificationTable	<Array of: Symbol>	Mapping from Character values to their characterType.
	comments	<Collection of: Interval>	Source intervals of scanned comments that must be attached to the next token.
	currentCharacter	<Character>	The character currently being processed.
	errorBlock	<BlockClosure>	The block to execute on lexical errors.
	extendedLiterals	<Boolean>	True if IBM-type literals are allowed. In VW, this is false.
	nameSpaceCharacter	<Character>	The character used to separate namespaces.
	numberType	<ByteSymbol>	The method to perform: to scan a number. 
	separatorsInLiterals	<Boolean>	True if separators are allowed within literals.
	stream	<PositionableStream>	Contains the text to be scanned.
	tokenStart	<Integer>	The source position of the beginning of the current token

Class Instance Variables:
	classificationTable	<Array>		the default classification table for all characters

Shared Variables:
	PatternVariableCharacter	<Character>	the character that starts a pattern node';
		immediateInvariant.
true.
%

doit
(RBScanner
	subclass: 'RBPatternScanner'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBPatternScanner is a subclass of RBScanner that allows the extended syntax of pattern matching trees.
';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RBSmallDictionary'
	instVarNames: #( keys values tally )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBSmallDictionary is a special dictionary optimized for small collections. In addition to the normal dictionary protocol, it also supports an #empty message which "empties" the collection but may hang on to the original elements (so it could collect garbage). Without #empty we would either need to create a new dictionary or explicitly remove everything from the dictionary. Both of these take more time and #empty.

Instance Variables:
array <Array of: Object> array of keys (we don''t use Associations for our key value pairs)
tally <Integer> the size of the dictionary
values <Array of: Object> array of our values
';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RBStringReplacement'
	instVarNames: #( startPosition stopPosition string )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBStringReplacement represents replacing source in the original method with a different string. These are used when reformatting code after a parse tree change has been made. Depending on the change, it may be possible to minimally change the parse tree without needing to format it.

Instance Variables:
	startPosition	<Integer>	the start position in the original source
	stopPosition	<Integer>	the end position in the original source
	string	<String>	replaces everything from the startPosition to the endPosition with this string

';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RBToken'
	instVarNames: #( sourcePointer comments )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBToken is the abstract superclass of all of the RB tokens. These tokens (unlike the standard parser''s) remember where they came from in the original source code.

Subclasses must implement the following messages:
	accessing
		length

Instance Variables:
	sourcePointer	<Integer>	The position in the original source code where this token began.
';
		immediateInvariant.
true.
%

doit
(RBToken
	subclass: 'RBAssignmentToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBAssignmentToken is the first-class representation of the assignment token '':=''
';
		immediateInvariant.
true.
%

doit
(RBAssignmentToken
	subclass: 'RBShortAssignmentToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RBToken
	subclass: 'RBValueToken'
	instVarNames: #( value )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBValueToken is the abstract superclass of all tokens that have additional information attached. For example, the BinarySelector token holds onto the actual character (e.g. $+).

Instance Variables:
	value	<String>	The value of this token

';
		immediateInvariant.
true.
%

doit
(RBValueToken
	subclass: 'RBBinarySelectorToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBBinarySelectorToken is the first-class representation of a binary selector (e.g. +)
';
		immediateInvariant.
true.
%

doit
(RBValueToken
	subclass: 'RBIdentifierToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBIdentifierToken is the first class representation of an identifier token (e.g. Class)
';
		immediateInvariant.
true.
%

doit
(RBIdentifierToken
	subclass: 'RBPathToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RBValueToken
	subclass: 'RBKeywordToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBKeywordToken is the first-class representation of a keyword token (e.g. add:)';
		immediateInvariant.
true.
%

doit
(RBValueToken
	subclass: 'RBLiteralArrayToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RBValueToken
	subclass: 'RBLiteralToken'
	instVarNames: #( stopPosition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBLiteralToken is the first-class representation of a literal token (entire literals, even literal arrays, are a single token in the ST80 grammar.).

Instance Variables:
	stopPosition	<Integer>	The position within the source code where the token terminates.

';
		immediateInvariant.
true.
%

doit
(RBLiteralToken
	subclass: 'RBMultiKeywordLiteralToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RBLiteralToken
	subclass: 'RBNumberLiteralToken'
	instVarNames: #( source )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RBValueToken
	subclass: 'RBPatternBlockToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBPatternBlockToken is the first-class representation of the pattern block token.

';
		immediateInvariant.
true.
%

doit
(RBValueToken
	subclass: 'RBSpecialCharacterToken'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Core';
		comment: 'RBSpecialCharacterToken is the first class representation of special characters.

';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'Rowan'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #( configuration )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Kernel';
		comment: 'No class-specific documentation for Cypress, hierarchy is: 
Object
  Cypress
';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RowanCommandResult'
	instVarNames: #( executionTime )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: 'Simple object with the results of the Jadeite command.';
		immediateInvariant.
true.
%

doit
(RowanCommandResult
	subclass: 'RowanClassCategoryUpdate'
	instVarNames: #( categories selection )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanCommandResult
	subclass: 'RowanClassesUpdate'
	instVarNames: #( classNames selectionNames )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanClassesUpdate
	subclass: 'RowanClassHierarchyUpdate'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanClassesUpdate
	subclass: 'RowanMethodsUpdate'
	instVarNames: #( methods methodFilters selectors selectedClass selectedSelectors inheritedClasses inheritedClass type )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanClassesUpdate
	subclass: 'RowanSuperclassUpdate'
	instVarNames: #( tabName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanCommandResult
	subclass: 'RowanClassInfoUpdate'
	instVarNames: #( oop template category comment )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanCommandResult
	subclass: 'RowanDictionaryUpdate'
	instVarNames: #( dictionaries selections )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanCommandResult
	subclass: 'RowanGlobalsUpdate'
	instVarNames: #( globals )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanCommandResult
	subclass: 'RowanGsObject'
	instVarNames: #( gciSession name oopType )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanGsObject
	subclass: 'RowanGsMethod'
	instVarNames: #( behavior behaviorName breakPoints category isReadOnly originalSource source stepPoints unimplementedSelectors warnings )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanCommandResult
	subclass: 'RowanMethodUpdate'
	instVarNames: #( gsMethod firstSendOffsets method isOverride isTestClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanCommandResult
	subclass: 'RowanPackageUpdate'
	instVarNames: #( packages modifiedPackages selections )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanCommandResult
	subclass: 'RowanProjectsUpdate'
	instVarNames: #( projects modifiedProjects selection )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RowanInterface'
	instVarNames: #( name )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanInterface
	subclass: 'RwPackage'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanInterface
	subclass: 'RwProject'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RowanService'
	instVarNames: #( definition updates command commandArgs updateType organizer )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: 'Rowan Service is the abstract service class for classes that represent
first class entities in Rowan. They are transported to the client via 
ston. 

On the client, set the command & commandArgs inst vars, then tell
the browser to #issueCommand: with an array of services. A service
received without the the command inst var set will send #update to
the service. #issueCommand: should call JadeServer>>updateFromSton:
which will run the command and return a result. 

Any service that sends updates back to the client willl propogates to 
registered windows. Add a service for return to the client with:
RowanCommandResult addResult: <self>';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanAnsweringService'
	instVarNames: #( answer )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: 'A place to put miscellaneous commands that don''t fit 
well in other services. 

Also good asking the server questions as it gives back 
an answer whereas other services simply return updated
services.';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanBrowserService'
	instVarNames: #( projects removedMethods allClasses hierarchyServices testPackages testCount autoCommit )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: 'RowanBrowserService handles services that fall outside
the scope of other services.';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanClassService'
	instVarNames: #( name comment instVarNames classVarNames classInstVarNames superclassName subclassType poolDictionaryNames classType meta isExtension version versions oop template filters filterType methods selectedPackageServices packageName definedPackageName selectedMethods projectName hierarchyServices variables categories isTestCase expand visibleTests isNewClass updateAfterCommand isInSymbolList )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: 'Most class operations done here. 

selectedMethods - client side selection. Used after a method compile.';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanDebuggerService'
	instVarNames: #( initialProcessOop processes )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanFrameService'
	instVarNames: #( label method stepPoint vars oop )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanLoggingService'
	instVarNames: #( fileName id groupId date time comment services mode location isLogging )
	classVars: #( Current )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanMethodService'
	instVarNames: #( oop source selector methodDefinitions classService category packageName projectName className meta hasSupers hasSubs compilationWarnings isExtension inSelectedPackage references stepPoints selectedPackageServices superDisplayString accessedInstVars breakPoints testResult definedPackage isTestMethod testRunClassName failedCompile comparisonSource )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanPackageService'
	instVarNames: #( projectDefinition packageName name isDirty classes defaultTemplate projectName testClasses hierarchyServices selectedClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanProcessService'
	instVarNames: #( frames oop status )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanProjectService'
	instVarNames: #( name sha branch isSkew isDirty packages changes existsOnDisk isLoaded projectUrl rowanProjectsHome )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanQueryService'
	instVarNames: #( queryResults )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanTestService'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RowanService
	subclass: 'RowanVariableService'
	instVarNames: #( oop key value className )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RowanServicePreferences'
	instVarNames: #( defaultProjectName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Services-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwAbstractConfigurationPlatformAttributeMatcher'
	instVarNames: #( pattern patternMatchBlock )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractConfigurationPlatformAttributeMatcher
	subclass: 'RwGemStoneVersionConfigurationPlatformAttributeMatcher'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGemStoneVersionConfigurationPlatformAttributeMatcher
	subclass: 'RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher'
	instVarNames: #( pattern2 )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractConfigurationPlatformAttributeMatcher
	subclass: 'RwStringConfigurationPlatformAttributeMatcher'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwAbstractProjectConfiguration'
	instVarNames: #( name comment projectName version configurationNames )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractProjectConfiguration
	subclass: 'RwAbstractProjectLoadConfiguration'
	instVarNames: #( conditionalPackages conditionalPackageMatchers conditionalPackageMapSpecs conditionalPackageMapSpecMatchers )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractProjectLoadConfiguration
	subclass: 'RwNestedProjectLoadConfiguration'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractProjectLoadConfiguration
	subclass: 'RwProjectLoadConfiguration'
	instVarNames: #( definedGroupNames )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectLoadConfiguration
	subclass: 'RwComponentLoadConfiguration'
	instVarNames: #( projectNames )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractProjectConfiguration
	subclass: 'RwProjectCompoundConfiguration'
	instVarNames: #( packageNames )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwAbstractReaderWriterVisitor'
	instVarNames: #( currentProjectDefinition packageConvention currentPackageDefinition currentClassDefinition currentClassExtension )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractReaderWriterVisitor
	subclass: 'RwModificationWriterVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'Abstract class with support for walking a modification tree and writing out the source code in a variety of formats:
	topaz fileout
	Tonel
	Filetree';
		immediateInvariant.
true.
%

doit
(RwModificationWriterVisitor
	subclass: 'RwGsModificationTopazWriterVisitor'
	instVarNames: #( topazFilenameConfigsMap topazFilename topazFileHeader filenameExtension classSymbolDictionaryNames classDefinitions classExtensions bufferedStream topazFilenamePackageNamesMap classDefPackageNameMap classExtPackageNameMap classInitializationDefinitions buildPackageNamesMap repositoryRootPath )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: 'Example script that produces topaz bootstrap files for the Rowan projects:

	| repositoryRootPath projectSetDefinition projectSetModification visitor |
	repositoryRootPath := FileLocator dbfScratchDir / ''rowanBootstrap''.
	repositoryRootPath ensureCreateDirectory.

	projectSetDefinition := RwProjectSetDefinition new.
	Rowan image loadedProjects do: [:lp | projectSetDefinition addProject: lp asDefinition ].

	projectSetModification := projectSetDefinition compareAgainstBase: RwProjectSetDefinition new.
	visitor := RwGsModificationTopazWriterVisitor new
		repositoryRootPath: repositoryRootPath;
		yourself.
	false 
		ifTrue: [ visitor topazFilename: ''rowan_bootstrap'' ]
		ifFalse: [
			| fileNameConfigsMap |
			fileNameConfigsMap := Dictionary new
				at: ''rowan_bootstrap_app'' 
					put: (Dictionary new 
							at: ''Rowan'' put: {{''Kernel''}. {}};
							at: ''FileSystemGs'' put: nil;
							at: ''Cypress'' put: nil;
							at: ''STON'' put: nil;
							at: ''Tonel'' put: nil;
							yourself);
				at: ''rowan_bootstrap_globals'' 
					put: (Dictionary new 
							at: ''Rowan'' put: {{''Globals''}. {}};
							at: ''FileSystemGs'' put: {{''Default''}. {}};
							at: ''Cypress'' put: {{''Default''}. {}};
							at: ''STON'' put: {{''Bootstrap''}. {}};
							at: ''Tonel'' put: {{''Bootstrap''}. {}};
							yourself);
				at: ''rowan_bootstrap_user_globals'' 
					put: (Dictionary new 
							at: ''Rowan'' put: {{''UserGlobals''}. {}};
							at: ''FileSystemGs'' put: nil;
							at: ''Cypress'' put: nil;
							at: ''STON'' put: nil;
							at: ''Tonel'' put: nil;
							yourself);
				yourself.
			visitor topazFilenameConfigsMap: fileNameConfigsMap].
	visitor visit: projectSetModification.
	visitor export.';
		immediateInvariant.
true.
%

doit
(RwModificationWriterVisitor
	subclass: 'RwModificationCypressFamilyWriterVisitor'
	instVarNames: #( classDefFileNameMap classExtFileNameMap classDefBeforeFileNameMap classExtBeforeFileNameMap packageDefFileNameMap packageDefBeforeFileNameMap )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwModificationCypressFamilyWriterVisitor
	subclass: 'RwModificationFiletreeWriterVisitor'
	instVarNames: #( instanceFileNameMap classFileNameMap instanceBeforeFileNameMap classBeforeFileNameMap packageExtension separateMethodMetaAndSource noMethodMetaData useCypressPropertiesFile monticelloMetadata )
	classVars: #(  )
	classInstVars: #( specials )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwModificationCypressFamilyWriterVisitor
	subclass: 'RwModificationTonelWriterVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractReaderWriterVisitor
	subclass: 'RwRepositoryComponentProjectReaderVisitor'
	instVarNames: #( packageNames currentDirectory currentProjectReferenceDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRepositoryComponentProjectReaderVisitor
	subclass: 'RwRepositoryComponentProjectFiletreeReaderVisitor'
	instVarNames: #( packageExtension )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRepositoryComponentProjectReaderVisitor
	subclass: 'RwRepositoryComponentProjectTonelReaderVisitor'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwAbstractTool'
	instVarNames: #( specification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: 'Fundamental concepts:

	read			(disk -> def)
	write			(def -> disk)

	install			(def -> image)
	derive			(image -> def)

	load			(disk ->  image)
	commit			(image -> disk)

	project			manages collections of packages
	package			manages collections of definitions
	definitions	manages properties of classes and methods
	repository		manages disk representation of defintions';
		immediateInvariant.
true.
%

doit
(RwAbstractTool
	subclass: 'RwClassTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwClassTool
	subclass: 'RwClsAuditTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: 'This class audits individual classes';
		immediateInvariant.
true.
%

doit
(RwClsAuditTool
	subclass: 'RwClsExtensionAuditTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwClassTool
	subclass: 'RwClsDiffTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractTool
	subclass: 'RwGitTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractTool
	subclass: 'RwPackageTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwPackageTool
	subclass: 'RwPkgAdoptTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwPackageTool
	subclass: 'RwPkgCreateTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwPackageTool
	subclass: 'RwPkgDiffTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwPackageTool
	subclass: 'RwPkgDisownTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwPackageTool
	subclass: 'RwPkgLoadTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwPackageTool
	subclass: 'RwPkgRevertTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractTool
	subclass: 'RwPkgAuditTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractTool
	subclass: 'RwProjectTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjAdoptTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjAuditTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjBrowserTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjCheckoutTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjCloneTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjCommitTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjCreateTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjDeleteTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjDiffTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjDisownTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjEditTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjLoadTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjLogTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjPullTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjPushTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjQueryTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjReadTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjReconcileTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjRevertTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjTestTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectTool
	subclass: 'RwPrjWriteTool'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwAuditDetail'
	instVarNames: #( message owner )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwClassAdditionOrRemoval'
	instVarNames: #( projectDefinition packageDefinition classKey classesModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypClassAdditionOrRemoval, hierarchy is: 
Object
  CypClassAdditionOrRemoval( packageDefinition classKey classesModification)
';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwConfiguration'
	instVarNames: #( packageInfoSource )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'Configuration that guides Cypress operation.

Specific parameters:

packageInfoSource
--------------------------
A Symbol indicating where the authoritative repository of information about package membership of classes and methods is.
Acceptable values are platform-specific:

#Cypress -- the information is stored in Cypress-specific objects. Valid on all platforms, but recommended only when all code modifications are done through Cypress or tools that are Cypress-aware

#Category -- Valid for Pharo and GemStone. The category of a class is the name of its package, and a method''s membership in a protocol whose name starts with $* indicates extension methods.

#SymbolDictionary -- Valid for GemStone. The SymbolDictionary in which the class''s name is first found is the name of its package, and a method''s membership in a protocol whose name starts with $* indicates extension methods.

#Store -- Valid for VW. Cypress package membership is Store package membership.';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwDefinition'
	instVarNames: #( properties )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: 'Abstract.
Defines some "code" entity.
The definition object''s primary responsibility is to hold information.
It holds exactly the same information as the disk representation in some form of Cypress repository.
Other non-definition classes construct and use the information in definitions to read, write, and compare
code.

properties is a dictionary. Keys and values should be strings. These correspond to the properties in a Cypress repository, and are used in various ways, some of them dialect-specific.';
		immediateInvariant.
true.
%

doit
(RwDefinition
	subclass: 'RwAbstractClassDefinition'
	instVarNames: #( classMethodDefinitions instanceMethodDefinitions )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractClassDefinition
	subclass: 'RwClassDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: 'Defines a class.
Properties should include ''name'' and ''super''.
Other typical properties are ''instvars'' ''classinstvars'' ''classvars''.
Methods are their own definitions: classMethodDefinitions instanceMethodDefinitions
';
		immediateInvariant.
true.
%

doit
(RwAbstractClassDefinition
	subclass: 'RwClassExtensionDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: 'Extends an existing class with additional methods.
Properties must include ''name'', the name of the class to be extended, but should not include other things like ''super'' or ''instvars''.
';
		immediateInvariant.
true.
%

doit
(RwDefinition
	subclass: 'RwAbstractComponentDefinition'
	instVarNames: #( components packages )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractComponentDefinition
	subclass: 'RwAbstractSubComponentDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractSubComponentDefinition
	subclass: 'RwSubComponentDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractComponentDefinition
	subclass: 'RwComponentDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwDefinition
	subclass: 'RwAbstractRepositoryDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractRepositoryDefinition
	subclass: 'RwDiskRepositoryDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwDiskRepositoryDefinition
	subclass: 'RwGitRepositoryDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwAbstractRepositoryDefinition
	subclass: 'RwMemoryRepositoryDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwDefinition
	subclass: 'RwDefinitionSetDefinition'
	instVarNames: #( definitions )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: 'No class-specific documentation for CypPackageSetDefinition, hierarchy is: 
Object
  CypDefinition( properties)
    CypPackageSetDefinition( packages)
';
		immediateInvariant.
true.
%

doit
(RwDefinitionSetDefinition
	subclass: 'RwPackageSetDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: 'No class-specific documentation for CypPackageSetDefinition, hierarchy is: 
Object
  CypDefinition( properties)
    CypPackageSetDefinition( packages)
';
		immediateInvariant.
true.
%

doit
(RwDefinitionSetDefinition
	subclass: 'RwProjectSetDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: 'No class-specific documentation for CypPackageSetDefinition, hierarchy is: 
Object
  CypDefinition( properties)
    CypPackageSetDefinition( packages)
';
		immediateInvariant.
true.
%

doit
(RwDefinition
	subclass: 'RwMethodDefinition'
	instVarNames: #( source )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwDefinition
	subclass: 'RwPackageDefinition'
	instVarNames: #( classDefinitions classExtensions )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: 'Defines a package, which is a bunch of class definitions and class extensions.
Properties include ''name''.
Sub-definitions are classDefinitions and classExtensions
';
		immediateInvariant.
true.
%

doit
(RwDefinition
	subclass: 'RwProjectDefinition'
	instVarNames: #( packages )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectDefinition
	subclass: 'RwComponentProjectDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectDefinition
	subclass: 'RwUnmanagedProjectDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwDefinition
	subclass: 'RwProjectReferenceDefinition'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwElementsModification'
	instVarNames: #( elementsModified )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'Abstract. Represents a modification to the elements of some code entity. "Modification" means that the code entity exists both before and after, but has differences in some of its elements.

Instvars:

elementsAdded		Dictionary elementKey -> element
elementsRemoved	Dictonary elementKey -> element
elementsModified	Dictionary elementKey -> CypModification  (key may have changed -- if so the key here is the old key)';
		immediateInvariant.
true.
%

doit
(RwElementsModification
	subclass: 'RwClassesModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the classes or classExtensions of a package. The elements are classes. Key is class name.';
		immediateInvariant.
true.
%

doit
(RwElementsModification
	subclass: 'RwClassExtensionsModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypClassExtensionsModification, hierarchy is: 
Object
  CypElementsModification( elementsAdded elementsRemoved elementsModified)
    CypClassExtensionsModification
';
		immediateInvariant.
true.
%

doit
(RwElementsModification
	subclass: 'RwEntitySetModification'
	instVarNames: #( movedClasses movedMethods )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwEntitySetModification
	subclass: 'RwPackageSetModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between two PackageSets. The elements are packages. Key is package name.
movedClasses are classes that have moved from one package to another within the package set.
movedMethods are methods that have moved from a class definition to an extension of that class, or vice versa, or between two extensions of the same class.';
		immediateInvariant.
true.
%

doit
(RwEntitySetModification
	subclass: 'RwProjectSetModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between two PackageSets. The elements are packages. Key is package name.
movedClasses are classes that have moved from one package to another within the package set.
movedMethods are methods that have moved from a class definition to an extension of that class, or vice versa, or between two extensions of the same class.';
		immediateInvariant.
true.
%

doit
(RwElementsModification
	subclass: 'RwMethodsModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the instance or class methods defined by a class or class extension. The elements are method definitions. Key is selector (as string).';
		immediateInvariant.
true.
%

doit
(RwMethodsModification
	subclass: 'RwExtensionMethodsModification'
	instVarNames: #( extendedClassName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwElementsModification
	subclass: 'RwPackagesModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the classes or classExtensions of a package. The elements are classes. Key is class name.';
		immediateInvariant.
true.
%

doit
(RwElementsModification
	subclass: 'RwPropertiesModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the properties of a single entity. The elements are associations of propertyName -> propertyValue. Key is property name.';
		immediateInvariant.
true.
%

doit
(RwElementsModification
	subclass: 'RwSourceModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'DELETE ME';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwEntitySet'
	instVarNames: #( entities )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Definitions';
		comment: 'Holds some number of RwDefinitions or RwLoadedThingss to be operated on together. The entities put into the receiver should be at the same semantic level: all methods, class, packages , or projects.

When the receiver is sent #asDefinition, the receiver is converted to a RwDefinitionSetDefinition and all entities are converted to their definition counterparts.';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwFileUtilities'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypFileUtilities, hierarchy is: 
Object
  CypFileUtilities
';
		immediateInvariant.
true.
%

doit
(RwFileUtilities
	subclass: 'RwGsFileUtilities'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: 'No class-specific documentation for CypGemStoneFileUtilities, hierarchy is: 
Object
  CypFileUtilities
    CypGemStoneFileUtilities
';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwGsImage'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: 'Keeps track of what LoadedPackages are in the GemStone repository, and is the gateway for operations to query or change the image.';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwGsImagePatchVisitor_254'
	instVarNames: #( patchSet currentProject currentPackage currentClass currentMethod )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'Walks a diff tree and adds patches to a patchSet that will update the GemStone image (repository) to the code state represented by the ''after'' state of the diff, provided that the ''before'' state of the diff is the current state of the image.';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwGsInstanceMigrator'
	instVarNames: #( migrationEnabled maxThreads maxCpuPercentage )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsInstanceMigrator
	subclass: 'RwGsDeferredInstanceMigrator'
	instVarNames: #( classesToMigrate )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwGsPatch'
	instVarNames: #( packageDefinition projectDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'Abstract. A patch is a single operation to be performed on a GemStone image (repository).';
		immediateInvariant.
true.
%

doit
(RwGsPatch
	subclass: 'RwGsClassPatch'
	instVarNames: #( classDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassPatch( classDefinition packageDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsClassPatch
	subclass: 'RwGsClassAdditionSymbolDictPatch'
	instVarNames: #( newClass symbolAssociation )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassAdditionPatch( classDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsClassPatch
	subclass: 'RwGsClassConstraintsSymDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsClassPatch
	subclass: 'RwGsClassDeletionSymbolDictPatch'
	instVarNames: #( existingClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassDeletionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassDeletionPatch( classDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsClassPatch
	subclass: 'RwGsClassExtensionSymbolDictPatch'
	instVarNames: #( patchClass )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsClassPatch
	subclass: 'RwGsClassPropertiesSymDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassPropertiesPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassPatch( classDefinition packageDefinition)
      CypGsClassPropertiesPatch( propertiesModification)
';
		immediateInvariant.
true.
%

doit
(RwGsClassPatch
	subclass: 'RwGsClassSymbolDictionaryMoveSymDictPatch'
	instVarNames: #( classModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsClassPatch
	subclass: 'RwGsClassVariableChangeSymbolDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassVariableChangePatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassVariableChangePatch( oldClassDefinition newClassDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsClassPatch
	subclass: 'RwGsClassVersioningPatch'
	instVarNames: #( classModification oldClassVersion newClassVersion symbolAssociation )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassVersioningPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassVersioningPatch( oldClassDefinition newClassDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsClassPatch
	subclass: 'RwGsClassVersioningSymbolDictPatch'
	instVarNames: #( classModification oldClassVersion newClassVersion symbolAssociation )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassVersioningPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassVersioningPatch( oldClassDefinition newClassDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsPatch
	subclass: 'RwGsMethodPatch'
	instVarNames: #( isMeta methodDefinition classDefinition behavior selector compiledMethod )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsMethodPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsMethodPatch( isMeta methodDefinition classDefinition packageDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsMethodPatch
	subclass: 'RwGsMethodAdditionSymbolDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsMethodAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsMethodAdditionPatch( isMeta methodDefinition classDefinition packageDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsMethodPatch
	subclass: 'RwGsMethodDeletionSymbolDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsMethodDeletionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsMethodDeletionPatch( isMeta methodDefinition classDefinition packageDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsMethodDeletionSymbolDictPatch
	subclass: 'RwGsMethodDeletionExtensionSymbolDictPatch'
	instVarNames: #( extendedClassName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsMethodDeletionExtensionSymbolDictPatch
	subclass: 'RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsMethodPatch
	subclass: 'RwGsMethodExtensionSymbolDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsMethodAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsMethodAdditionPatch( isMeta methodDefinition classDefinition packageDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsMethodExtensionSymbolDictPatch
	subclass: 'RwGsMethodExtensionSessionMethodSymbolDictPatch'
	instVarNames: #( sessionDictsArray methDict catDict pArray )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsMethodPatch
	subclass: 'RwGsMethodPropertiesSymDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsMethodPropertiesPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsMethodPatch( isMeta methodDefinition classDefinition packageDefinition)
      CypGsMethodPropertiesPatch( propertiesModification)
';
		immediateInvariant.
true.
%

doit
(RwGsMethodPropertiesSymDictPatch
	subclass: 'RwGsMethodExtensionSessionMethodPropertiesSymDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsMethodPatch
	subclass: 'RwGsMethodSourceSymbolDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsMethodSourceSymbolDictPatch
	subclass: 'RwGsMethodExtensionSessionMethodSourceSymbolDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsPatch
	subclass: 'RwGsPackagePatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsPackagePatch, hierarchy is: 
Object
  CypGsPatch
    CypGsPackagePatch( packageDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsPackagePatch
	subclass: 'RwGsPackageAdditionSymbolDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsPackageAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsPackageAdditionPatch( packageDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsPackagePatch
	subclass: 'RwGsPackageDeletionSymbolDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsPackageAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsPackageAdditionPatch( packageDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsPackagePatch
	subclass: 'RwGsPackageMoveSymbolDictPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwGsPatch
	subclass: 'RwGsProjectPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsPackagePatch, hierarchy is: 
Object
  CypGsPatch
    CypGsPackagePatch( packageDefinition)
';
		immediateInvariant.
true.
%

doit
(RwGsProjectPatch
	subclass: 'RwGsProjectAdditionPatch'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsPackageAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsPackageAdditionPatch( packageDefinition)
';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwGsPatchSet_254'
	instVarNames: #( instanceMigrator addedProjects addedPackages deletedPackages movedPackages projectsWithPropertyChanges addedClasses deletedClasses movedClasses movedClassesMap extendedClasses classesWithPropertyChanges classesWithSymbolDictionaryChanges classesWithClassVariableChanges classesWithConstraintChanges classesWithNewVersions addedMethods deletedMethods deleteNewVersionMethods movedMethods extendedMethods methodsWithPropertyChanges methodsNeedingRecompile tempSymbols createdClasses errors currentProjectDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'A set of patches (changes) to be applied atomically (or as close to atomically as possible) to a GemStone repository.';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwGsSymbolDictionaryRegistry'
	instVarNames: #( symbolDictionary packageRegistry classRegistry classExtensionRegistry methodRegistry )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwGsSymbolDictionaryRegistry_Implementation'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #())
		category: 'Rowan-GemStone-Loader';
		comment: 'The Rowan-GemStone-Loader implementation does depend upon having a stable and consistent implementation of the RwGsSymbolDictionaryRegistry behavior for the duration of a load.

Right before a load, all of the classes that make up the Rowan-GemStone-Loader package are copied and isolated from the rest of the system, so that updates to the loader code itself will not change the behavior of the loader implementation while the load is in progress.

The class RwGsSymbolDictionaryRegistry is not part of the Rowan-GemStone-Loader package, because instance of the class are expected to have long lifetimes.

This class implements the behavior for RwGsSymbolDictionaryRegistry and since it is the Rowan-GemStone-Loader package, it can be copied and isolated during a load, without affecting the long lived instances of RwGsSymbolDictionaryRegistry.

The methods in the receiver (class-side only) have an extra `instance:` argument tacked on that refers to the instance of RwGsSymbolDictionaryRegistry that was the original target of the message. For example:

	RwGsSymbolDictionaryRegistry_implementation class>>addClassAssociation:forClass:toPackageNamed:instance:

The methods in RwGsSymbolDictionaryRegistry are implemented with a compiled in reference to the RwGsSymbolDictionaryRegistry_implementation class as follows:

	addClassAssociation: assoc forClass: class toPackageNamed: packageName

		^ RwGsSymbolDictionaryRegistry_implementation addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self

This form is adequate for message sends from classes outside of the Rowan-GemStone-Loader package.

Inside the Rowan-GemStone-Loader package, the messgaes sends must pass in a reference to the `RwGsSymbolDictionaryRegistry_implementation`. This reference will refer to the cloned copy of the class when the RowanLoader symbol dictionary is cloned. The methods have and extra `implementationClass:` that refers to the class and allows the caller to pass in a reference to the cloned class. For example:

	addClassAssociation: assoc forClass: class toPackageNamed: packageName implementationClass: implementationClass

		"Copy the name association to the correct 
			SymbolDictionary in the live SymbolList.
			Create a LoadedClass for the new class, add it to the defining LoadedPackage."

		^ implementationClass addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwLoadedThing'
	instVarNames: #( properties name handle )
	classVars: #( AbsentToken )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'properties: dictionary of properties
name: name of class or package, selector of method
handle: reference to the class or method object, or to the native package object for dialects that have that.';
		immediateInvariant.
true.
%

doit
(RwLoadedThing
	subclass: 'RwLoadedClass'
	instVarNames: #( loadedPackage loadedInstanceMethods loadedClassMethods )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'package: the CypLoadedPackage that defines me and all my methods that are not extension methods.
extensions: a collection of CypLoadedExtendedClasses for this class. From these we can tell which methods don''t belong to our default package.';
		immediateInvariant.
true.
%

doit
(RwLoadedClass
	subclass: 'RwGsLoadedSymbolDictClass'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwLoadedThing
	subclass: 'RwLoadedClassExtension'
	instVarNames: #( loadedPackage loadedInstanceMethods loadedClassMethods )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypLoadedClassExtension, hierarchy is: 
Object
  CypLoadedThing( properties name handle)
    CypLoadedClassExtension( loadedPackage loadedMethods)
';
		immediateInvariant.
true.
%

doit
(RwLoadedClassExtension
	subclass: 'RwGsLoadedSymbolDictClassExtension'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwLoadedThing
	subclass: 'RwLoadedComponent'
	instVarNames: #( loadedRepository loadedChildComponents loadedParentComponents )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwLoadedThing
	subclass: 'RwLoadedMethod'
	instVarNames: #( loadedClass classIsMeta )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypLoadedMethod, hierarchy is: 
Object
  CypLoadedThing( properties name handle)
    CypLoadedMethod
';
		immediateInvariant.
true.
%

doit
(RwLoadedMethod
	subclass: 'RwGsLoadedSymbolDictMethod'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: 'The MethodRegistry maps GsNMethods to LoadedMethods.';
		immediateInvariant.
true.
%

doit
(RwLoadedThing
	subclass: 'RwLoadedPackage'
	instVarNames: #( repository commitId loadedClasses loadedClassExtensions isDirty loadedProject )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'repository: The repository I was loaded from (if known, nil otherwise)
commitId: A repository-specific way of identifying source code commit, if it''s a type of repository that has that kind of information (nil otherwise)
loadedClasses: Dictionary -- keys are (non-meta) classes, values are the LoadedClasses that I define.
loadedClassExtensions: -- Dictionary -- keys are (non-meta) classes, values are the LoadedClassExtensions that I define.';
		immediateInvariant.
true.
%

doit
(RwLoadedPackage
	subclass: 'RwGsLoadedSymbolDictPackage'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwLoadedThing
	subclass: 'RwLoadedProject'
	instVarNames: #( loadedPackages isDirty )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwLoadedProject
	subclass: 'RwGsLoadedSymbolDictComponentProject'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwLoadedProject
	subclass: 'RwGsLoadedSymbolDictProject'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwLoadedThing
	subclass: 'RwLoadedRepository'
	instVarNames: #( loadedChildComponents )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwMethodAdditionOrRemoval'
	instVarNames: #( projectDefinition packageDefinition classDefinitionOrExtension methodKey isMeta methodsModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypMethodAdditionOrRemoval, hierarchy is: 
Object
  CypMethodAdditionOrRemoval( packageDefinition classDefinitionOrExtension methodKey isMeta methodsModification)
';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwModification'
	instVarNames: #( propertiesModification before after )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'Abstract. Represents a modification to some code entity. "Modification" means that the code entity exists both before and after, but has differences in some of its elements.

Instvars:

before		A definition of the state before the modification
after		A definition of state after the modification';
		immediateInvariant.
true.
%

doit
(RwModification
	subclass: 'RwClassModification'
	instVarNames: #( instanceMethodsModification classMethodsModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single class definition or class extension.

Instvars:

propertiesModification			PropertiesModification -- changes to class or class extension properties
instanceMethodsModification	MethodsModification -- changes to instance methods defined
classMethodsModification		MethodsModification -- changes to class methods defined';
		immediateInvariant.
true.
%

doit
(RwClassModification
	subclass: 'RwClassExtensionModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwClassModification
	subclass: 'RwClassModificationForcingNewClassVersion'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwModification
	subclass: 'RwMethodModification'
	instVarNames: #( sourceModification isMeta classDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single method

Instvars:

propertiesModification			PropertiesModification -- changes to method properties
oldSource						String -- source code before
newSource						String -- source code after';
		immediateInvariant.
true.
%

doit
(RwMethodModification
	subclass: 'RwExtensionMethodModification'
	instVarNames: #( extendedClassName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwMethodModification
	subclass: 'RwMethodModificationForNewClassVersion'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwMethodModificationForNewClassVersion
	subclass: 'RwExtensionMethodModificationForNewClassVersion'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwModification
	subclass: 'RwPackageModification'
	instVarNames: #( classesModification classExtensionsModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single package.

Instvars:

propertiesModification			PropertiesModification -- changes to package properties
classesModification				ClassesModification -- changes to classes defined
classExtensionsModification		ClassesModificaiton -- changes to classes extended';
		immediateInvariant.
true.
%

doit
(RwModification
	subclass: 'RwProjectModification'
	instVarNames: #( packagesModification )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single package.

Instvars:

propertiesModification			PropertiesModification -- changes to package properties
classesModification				ClassesModification -- changes to classes defined
classExtensionsModification		ClassesModificaiton -- changes to classes extended';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwMove'
	instVarNames: #( projectBefore projectAfter packageBefore packageAfter )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwMove
	subclass: 'RwClassExtensionMove'
	instVarNames: #( classExtensionBefore classExtensionAfter )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwMove
	subclass: 'RwClassMove'
	instVarNames: #( classBefore classAfter )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'Represents the move of a class definition from one package to another.';
		immediateInvariant.
true.
%

doit
(RwMove
	subclass: 'RwMethodMove'
	instVarNames: #( methodBefore methodAfter isMeta classOrExtensionBefore classOrExtensionAfter )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'Represents a move of a method from a class definition to a class extension, or from a class extension to a class definition, or between two extensions, of the same class. This should always also result in a change of package, since a class should not be defined and extended in the same package, nor extended twice in the same package.';
		immediateInvariant.
true.
%

doit
(RwMove
	subclass: 'RwPackageMove'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwPlatform'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Kernel';
		comment: 'Provides services specific to the Smalltalk dialect being run,
and locates other services that are dialect-specific.';
		immediateInvariant.
true.
%

doit
(RwPlatform
	subclass: 'RwGsPlatform'
	instVarNames: #( alternateImageClass enableInstanceMigration instanceMigrator )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-GemStone-Core';
		comment: 'This class is private to Cypress.
A GsPlatform is the gateway object for requesting platform-specific actions.';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwProjectLoadConfigurationVisitor'
	instVarNames: #( packageNames packageMapSpecs visitedConfigurationNames platformAttributes definedGroupNames groupNames configurationNames configurationBasePath )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectLoadConfigurationVisitor
	subclass: 'RwProjectLoadComponentVisitor'
	instVarNames: #( projectNames projectBasePath projectLoadSpecs visitedComponents projectComponentDefinition )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectLoadConfigurationVisitor
	subclass: 'RwProjectLoadConfigurationAnalysisVisitor'
	instVarNames: #( visitedConfigurationMap packageToConfigurationMap )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Configurations';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwPropertyModification'
	instVarNames: #( key oldValue newValue )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypPropertyModification, hierarchy is: 
Object
  CypDiff( changes)
    CypLeafModification( key before after)
      CypPropertyModification
';
		immediateInvariant.
true.
%

doit
(RwPropertyModification
	subclass: 'RwUnconditionalPropertyModification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypPropertyModification, hierarchy is: 
Object
  CypDiff( changes)
    CypLeafModification( key before after)
      CypPropertyModification
';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwSpecification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Specifications';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwSpecification
	subclass: 'RwImageSpecification'
	instVarNames: #( loadedCommitId loadedConfigurationNames loadedGroupNames repositoryUrl )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Specifications';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwImageSpecification
	subclass: 'RwSimpleProjectImageSpecification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Specifications';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwSpecification
	subclass: 'RwPlatformSpecification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Specifications';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwPlatformSpecification
	subclass: 'RwGemStoneSpecification'
	instVarNames: #( defaultMethodEnv defaultSymbolDictName defaultUseSessionMethodsForExtensions packageNameToPlatformPropertiesMap projectOwnerId )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-GemStone-Specifications';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwSpecification
	subclass: 'RwProjectSpecification'
	instVarNames: #( specName version projectUrl platformSpec configsPath specsPath repoSpec repoPath comment imageSpec defaultConfigurationNames defaultGroupNames )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Specifications';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectSpecification
	subclass: 'RwComponentSpecification'
	instVarNames: #( projectName projectsPath defaultComponentName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Components';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwProjectSpecification
	subclass: 'RwSimpleProjectSpecification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Specifications';
		comment: 'RwPackageLoadSpecification new
    specName: ''rowanLoadSpec'';
    packageNames:
        #(''Cypress-Core'' ''Rowan-Core'' ''Rowan-GemStone'' ''Rowan-Tests'' ''Rowan-Tode'');
    packageNamesToLoad:
        #(''Cypress-Core'' ''Rowan-Core'' ''Rowan-GemStone'' ''Rowan-Tests'');
    repositoryUrl:
        ''tonel:/export/foos1/users/dhenrich/dev/_home/shared/repos/rowan/CypressReferenceImplementation/tonel/'';
    exportToUrl:
        ''file:/export/foos1/users/dhenrich/dev/_home/shared/repos/rowan/CypressReferenceImplementation/''';
		immediateInvariant.
true.
%

doit
(RwSpecification
	subclass: 'RwReferenceSpecification'
	instVarNames: #( referenceUrl )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Specifications';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwSpecification
	subclass: 'RwRepositorySpecification'
	instVarNames: #( repositoryRootPath )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Specifications';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRepositorySpecification
	subclass: 'RwDiskRepositorySpecification'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Specifications';
		comment: '';
		immediateInvariant.
true.
%

doit
(RwRepositorySpecification
	subclass: 'RwGitRepositorySpecification'
	instVarNames: #( committish committishType remote remoteUrl )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Specifications';
		comment: '';
		immediateInvariant.
true.
%

doit
(Object
	subclass: 'RwUrl'
	instVarNames: #( fragment )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Url-Core';
		comment: 'A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.

The classes in this hierarchy:

RwUrl
 RwFileUrl
  RwCypressUrl
  RwFiletreeUrl
   RwTonelUrl
  RwGithubUrl
 RwGenericUrl
 RwHierarchicalUrl
  RwSmalltalkRepositoryUrl
   RwGitFileTreeUrl

are specificaly designed for parsing URLS for Rowan source code repositories:

 file:/opt/git/shared/repos/rowan/sample/repository
 http://gsdevkit.github.io/GsDevKit_home/rowan/Sample.ston
 https://raw.githubusercontent.com/dalehenrich/sample/master/specs/Sample.ston

 github://GsDevKit/GsDevKit:master/repository
 filetree:///opt/git/shared/repos/rowan/sample/repository
 tonel:/opt/git/shared/repos/rowan/sample/repository
 gitfiletree://gitlab.com/GsDevKit/GsDevKit:master/repository

 cypress:/opt/git/shared/repos/rowan/sample/repository/
 smalltalk://dkh:pass@gitlab.ferlicot.fr:3456/Projet/Bazard:dev/src
 smalltalk://git@git.gemtalksystems.com/btree340:dev/repository
 smalltalk://git@github.com/GsDevKit/GsDevKit:350/repository
 smalltalk://github.com/GsDevKit/GsDevKit:350/repository


The file:, http: and https: schemes should conform to the standard specs. ZnUrl is used for parsing http: and https: urls.

The github:, filetree:, gitfiletree: and tonel: schemes are supported for backward compatibility with schemes that have historically been used to identify Metacello repository urls.

The cypress: and smalltalk: schemes are new and intended to be used moving forward with Metacello and Rowan.

The cypress: url is used to indicate that path to a Cypress-style repository, i.e., a disk-based format for storing Smalltalk packages in filetree or tonel format. A cypress: url does not define the specific repository type (filetree or tonel). The type of the repository is encoded in a .filetree file located in the directory specified by pathString of the url.

The smalltalk: scheme is based on Thierry Goubier''s gitfiletree url[1]. The original github: scheme cannot be used for arbitrary git servers or git servers using non-standard ports or requiring usernames and passwords. Thierry''s scheme handles the full range of possibilites.

[1] https://github.com/dalehenrich/filetree/blob/734eed46ea57ebf5e24e5d935768bd49727fc22f/repository/MonticelloFileTree-Git.package/MCFileTreeGitRepository.class/class/basicFromUrl..st';
		immediateInvariant.
true.
%

doit
(RwUrl
	subclass: 'RwFileUrl'
	instVarNames: #( host path isAbsolute )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Url-Core';
		comment: 'This class models a file URL according to (somewhat) RFC1738, see http://www.w3.org/Addressing/rfc1738.txt

Here is the relevant part of the RFC:

3.10 FILES

   The file URL scheme is used to designate files accessible on a
   particular host computer. This scheme, unlike most other URL schemes,
   does not designate a resource that is universally accessible over the
   Internet.

   A file URL takes the form:

       file://<host>/<path>

   where <host> is the fully qualified domain name of the system on
   which the <path> is accessible, and <path> is a hierarchical
   directory path of the form <directory>/<directory>/.../<name>.

   For example, a VMS file

     DISK$USER:[MY.NOTES]NOTE123456.TXT

   might become

     <URL:file://vms.host.edu/disk$user/my/notes/note12345.txt>

   As a special case, <host> can be the string "localhost" or the empty
   string; this is interpreted as `the machine from which the URL is
   being interpreted''.

   The file URL scheme is unusual in that it does not specify an
   Internet protocol or access method for such files; as such, its
   utility in network protocols between hosts is limited.

From the above we can conclude that the RFC says that the <path> part never starts or ends with a slash and is always absolute. If the last name can be a directory instead of a file is not specified clearly.

The path is stored as a SequenceableCollection of path parts.

Notes regarding non RFC features in this class:

- If the last path part is the empty string, then the FileUrl is referring to a directory. This is also shown with a trailing slash when converted to a String.

- The FileUrl has an attribute isAbsolute which signals if the path should be considered absolute or relative to the current directory. This distinction is not visible in the String representation of FileUrl, since the RFC does not have that.

- Fragment is supported (kept for historical reasons)

';
		immediateInvariant.
true.
%

doit
(RwFileUrl
	subclass: 'RwCypressUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Url-Core';
		comment: 'This class implements the cypress: scheme:

 cypress:/opt/git/shared/repos/rowan/sample/repository/

The cypress: url specifies the file system path to the directory where a disk-based Smalltalk package repository resides. The name comes from the original name used to specifay a cross-platform package disk layout[1].

This url does not encode the specific disk format used by the repository (like the filetree: and tonel: schemes). The disk format is specified in a .cypress file in the directory using STON ike the following:

  { #format : ''filetree'' }
  { #format : ''tonel'' }
  { #format : ''cypress'' }

When the cypress: url is resolved, the appropriate platform-specific repository reader will be used to read the packages from disk.

[1] https://raw.githubusercontent.com/CampSmalltalk/Cypress/master/img/CypressStructure-STIC2012.png';
		immediateInvariant.
true.
%

doit
(RwCypressUrl
	subclass: 'RwTonelUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Url-Core';
		comment: 'This class implements the tonel: scheme:

  tonel:/opt/git/shared/repos/rowan/sample/repository

The scheme is supported for backward compatibility with the tonel disk format[1]. Not sure whether it''s use has made it into the wild, but it _is_ currently being used in the Rowan implementation.

[1] https://github.com/pharo-vcs/tonel';
		immediateInvariant.
true.
%

doit
(RwFileUrl
	subclass: 'RwFiletreeUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Url-Core';
		comment: 'This class implements the filetree: scheme[1]:

 filetree:///opt/git/shared/repos/rowan/sample/repository

This scheme is supported for backward compatibility. Moving forward the cypress: scheme should be used (see RwCypressUrl).

[1] https://github.com/Metacello/metacello/blob/master/docs/MetacelloScriptingAPI.md#filetree';
		immediateInvariant.
true.
%

doit
(RwFileUrl
	subclass: 'RwGithubUrl'
	instVarNames: #( project committish dir )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Url-Core';
		comment: 'This class implements the github: scheme[1]:

  github://GsDevKit/GsDevKit:master/repository

This scheme is supported for backward compatibility. Moving forward the metacello: scheme should be used (see RwMetacelloRepositoryUrl).

[1] https://github.com/Metacello/metacello/blob/master/docs/MetacelloScriptingAPI.md#github';
		immediateInvariant.
true.
%

doit
(RwUrl
	subclass: 'RwGenericUrl'
	instVarNames: #( schemeName locator )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Url-Core';
		comment: 'a URL type that can''t be broken down in any systematic way.  For example, mailto: and telnet: URLs.  The part after the scheme name is stored available via the #locator message.';
		immediateInvariant.
true.
%

doit
(RwUrl
	subclass: 'RwHierarchicalUrl'
	instVarNames: #( schemeName authority path query port username password )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Url-Core';
		comment: 'A URL which has a hierarchical encoding.  For instance, http and ftp URLs are hierarchical.';
		immediateInvariant.
true.
%

doit
(RwHierarchicalUrl
	subclass: 'RwSmalltalkRepositoryUrl'
	instVarNames: #( project committish dir )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Url-Core';
		comment: 'This class implements the smalltalk: scheme:

 smalltalk://dkh:pass@gitlab.ferlicot.fr:3456/Projet/Bazard:dev/src
 smalltalk://git@git.gemtalksystems.com/btree340:dev/repository
 smalltalk://git@github.com/GsDevKit/GsDevKit:350/repository
 smalltalk://github.com/GsDevKit/GsDevKit:350/repository

The smalltalk: scheme is based on Thierry Goubier''s gitfiletree url[1]:

  smalltalk:// <[user[:password]@]host[:port]> / user/ projectName [ : versionIdentifier ] [ / repositoryPath ]

[1] https://github.com/dalehenrich/filetree/blob/734eed46ea57ebf5e24e5d935768bd49727fc22f/repository/MonticelloFileTree-Git.package/MCFileTreeGitRepository.class/class/basicFromUrl..st';
		immediateInvariant.
true.
%

doit
(RwSmalltalkRepositoryUrl
	subclass: 'RwGitFileTreeUrl'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'Rowan-Url-Core';
		comment: 'This class implements the gitfiletree: scheme:

 gitfiletree://gitlab.com/GsDevKit/GsDevKit:master/repository

The gitfiletree scheme [1] encodes the following information:

  gitfiletree:// [ user [ : password ] @ ] host [ : port ] / user / project [ : branch ] [ / repositoryPath ]

From the method comment[1]:

  Parameters are:
		dir : the directory inside the repository where the target MC packages are.
		branch : the git branch to fetch.
		protocol: the user name part to add to the ssh Url, default to git, but can also be https (which implies read only access).
		readOnly : is the repository read only? If present, reduce the history to a minimum (and change the GUI).
	Alternative url syntax:
		gitfiletree://github.com/dalehenrich/filetree:pharo5.0_dev/repository
	with:
		host : github.com
		project : dalehenrich/filetree
		branch : pharo5.0_dev
		dir : repository

[1] https://github.com/dalehenrich/filetree/blob/734eed46ea57ebf5e24e5d935768bd49727fc22f/repository/MonticelloFileTree-Git.package/MCFileTreeGitRepository.class/class/basicFromUrl..st';
		immediateInvariant.
true.
%

doit
(StringKeyValueDictionary
	subclass: 'RwAuditReport'
	instVarNames: #( owner )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(StringKeyValueDictionary
	subclass: 'RwPackageAuditReport'
	instVarNames: #( packageName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(StringKeyValueDictionary
	subclass: 'RwProjectAuditReport'
	instVarNames: #( projectName )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #())
		category: 'Rowan-Tools-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RBFormatterTests'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Tests-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RBGemStoneNumberParserTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Kernel-Tests-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RBParserTest'
	instVarNames: #(  )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Tests-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RBProgramNodeTest'
	instVarNames: #( node previous )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Tests-Core';
		comment: '';
		immediateInvariant.
true.
%

doit
(TestCase
	subclass: 'RBSmallDictionaryTest'
	instVarNames: #( dict )
	classVars: #(  )
	classInstVars: #(  )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #())
		category: 'AST-Tests-Core';
		comment: '';
		immediateInvariant.
true.
%

! Class implementation for 'RwCypressMethodDefinition'

!		Instance methods for 'RwCypressMethodDefinition'

category: 'accessing'
method: RwCypressMethodDefinition
isExtensionMethod

	^ isExtensionMethod ifNil: [ isExtensionMethod := false ]
%

category: 'accessing'
method: RwCypressMethodDefinition
isExtensionMethod: anObject

   isExtensionMethod := anObject
%

! Class implementation for 'RwCypressMethodStructure'

!		Instance methods for 'RwCypressMethodStructure'

category: 'converting'
method: RwCypressMethodStructure
asCypressMethodDefinition

	"Try to coerce Unicode source to simple Strings when possible."

	^ RwCypressMethodDefinition
		className: self classStructure className
		classIsMeta: self isMetaclass
		selector: self selector
		category: self category
		source: self source asString
%

category: 'initialization'
method: RwCypressMethodStructure
fromRwClassMethodDefinition: methodDefinition
  self isMetaclass: true.
  self fromRwMethodDefinition: methodDefinition
%

category: 'initialization'
method: RwCypressMethodStructure
fromRwInstanceMethodDefinition: methodDefinition
  self isMetaclass: false.
  self fromRwMethodDefinition: methodDefinition
%

category: 'initialization'
method: RwCypressMethodStructure
fromRwMethodDefinition: methodDefinition
  self selector: methodDefinition selector asString.
  self category: (methodDefinition properties at: 'protocol').
  self source: methodDefinition source
%

! Class implementation for 'RwCypressPackageStructure'

!		Instance methods for 'RwCypressPackageStructure'

category: 'initialization'
method: RwCypressPackageStructure
fromPackage: aRwPackageDefinition

	| classStructure |
	aRwPackageDefinition classDefinitions
		do: [ :classDefinition | 
			classStructure := (CypressClassStructure fromClassDefinition: classDefinition)
				packageStructure: self.
			classDefinition instanceMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwInstanceMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure instanceMethods
						at: methodDefinition selector
						put: methodStructure ].
			classDefinition classMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwClassMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure classMethods
						at: methodDefinition selector
						put: methodStructure ].
			self classes add: classStructure ].
	aRwPackageDefinition classExtensions
		do: [ :extensionDefinition | 
			classStructure := (CypressClassStructure named: extensionDefinition name)
				isClassExtension: true;
				packageStructure: self.
			extensionDefinition instanceMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwInstanceMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure instanceMethods
						at: methodDefinition selector
						put: methodStructure ].
			extensionDefinition classMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwClassMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure classMethods
						at: methodDefinition selector
						put: methodStructure ].
			self extensions add: classStructure ].
	name := aRwPackageDefinition key , self packageExtension.
	properties := Dictionary new
%

category: 'initialization'
method: RwCypressPackageStructure
fromSnapshot: snapshot
  | classMap classDefinitions |
  classDefinitions := OrderedCollection new.
  classMap := Dictionary new.
  snapshot
    do: [ :definition | 
      definition
        classDefinition: [ :classDefinition | classDefinitions add: classDefinition ]
        methodDefinition: [ :methodDefinition | 
          (classMap at: methodDefinition className ifAbsentPut: [ Set new ])
            add: methodDefinition ] ].
  self name: self name from: classDefinitions classMap: classMap
%

category: 'snapshotting'
method: RwCypressPackageStructure
rwSnapshot

	| rwPackageDefinition |
	rwPackageDefinition := RwPackageDefinition new
		properties:
			(Dictionary new
				at: 'name' put: self packageName;
				yourself).
	self classes
		do: [ :classStructure | 
			| rwClassDef |
			rwClassDef := RwClassDefinition fromCypressClassStructure: classStructure.
			rwPackageDefinition addClassDefinition: rwClassDef ].
	self extensions
		do: [ :classStructure | 
			| rwClassExtensionDef |
			rwClassExtensionDef := RwClassExtensionDefinition
				newForClassNamed: classStructure className.
			(classStructure instanceMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					rwClassExtensionDef
						addInstanceMethodDefinition:
							(RwMethodDefinition fromCypressMethod: methodStructure) ].
			(classStructure classMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					rwClassExtensionDef
						addClassMethodDefinition:
							(RwMethodDefinition fromCypressMethod: methodStructure) ].
			rwPackageDefinition addClassExtensionDefinition: rwClassExtensionDef ].
	^ rwPackageDefinition
%

category: 'snapshotting'
method: RwCypressPackageStructure
snapshot

	| definitions |
	definitions := OrderedCollection new.
	self classes
		do: [ :classStructure | 
			definitions add: classStructure asCypressClassDefinition.
			(classStructure instanceMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | definitions add: methodStructure asCypressMethodDefinition ].
			(classStructure classMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | definitions add: methodStructure asCypressMethodDefinition ] ].
	self extensions
		do: [ :classStructure | 
			(classStructure instanceMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					| mdef |
					mdef := methodStructure asCypressMethodDefinition.
					mdef isExtensionMethod: true.
					definitions add: mdef ].
			(classStructure classMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					| mdef |
					mdef := methodStructure asCypressMethodDefinition.
					mdef isExtensionMethod: true.
					definitions add: mdef ] ].
	^ CypressSnapshot definitions: definitions
%

! Class implementation for 'RwGemStoneVersionNumber'

!		Class methods for 'RwGemStoneVersionNumber'

category: 'instance creation'
classmethod: RwGemStoneVersionNumber
fromString: aString

	| new components |
	components := OrderedCollection new.
	(aString substrings: '.') do: [:subString | 
		components add: subString asInteger].
	new := self new: components size.
	1 to: components size do: [:i | new at: i put: (components at: i) ].
	^new
%

!		Instance methods for 'RwGemStoneVersionNumber'

category: 'comparing'
method: RwGemStoneVersionNumber
< aRwGemStoneVersionNumber

	| condensed aCondensed |
	aRwGemStoneVersionNumber species = self species
		ifFalse: [ ^ false ].
	condensed := self collapseZeros.
	aCondensed := aRwGemStoneVersionNumber collapseZeros.
	(condensed ~~ self or: [ aCondensed ~~ aRwGemStoneVersionNumber ])
		ifTrue: [ ^ condensed compareLessThan: aCondensed ].
	^ self compareLessThan: aRwGemStoneVersionNumber
%

category: 'comparing'
method: RwGemStoneVersionNumber
= aRwGemStoneVersionNumber

	| condensed aCondensed |
	aRwGemStoneVersionNumber species = self species
		ifFalse: [ ^ false ].
	condensed := self collapseZeros.
	aCondensed := aRwGemStoneVersionNumber collapseZeros.
	(condensed ~~ self or: [ aCondensed ~~ aRwGemStoneVersionNumber ])
		ifTrue: [ ^ condensed compareEqualTo: aCondensed ].
	^ self compareEqualTo: aRwGemStoneVersionNumber
%

category: 'accessing'
method: RwGemStoneVersionNumber
approximateBase

	| base condensed |
	condensed := self collapseZeros.
	base := condensed copyFrom: 1 to: condensed size - 1.
	base at: base size put: (base at: base size) + 1.
	^base
%

category: 'converting'
method: RwGemStoneVersionNumber
asRwGemStoneVersionNumber

	^self
%

category: 'printing'
method: RwGemStoneVersionNumber
asString
	"Answer a string that represents the receiver."

	^ self printString
%

category: 'private'
method: RwGemStoneVersionNumber
collapseZeros
	"the rule must be that zeros can be collapsed as long as the series of zeros ends in a 0"

	| collection newSize new j lastElementIsStringOrZero canCollapse |
	(self size = 0 or: [ self at: 1 ]) == 0
		ifTrue: [ ^ self ].
	collection := OrderedCollection new.
	lastElementIsStringOrZero := true.
	canCollapse := true.
	self size to: 1 by: -1 do: [ :i | 
		| element |
		element := self at: i.
		(canCollapse and: [ element == 0 ])
			ifTrue: [ 
				lastElementIsStringOrZero
					ifFalse: [ 
						canCollapse := false.
						collection addFirst: element.]]
			ifFalse: [ 
				collection addFirst: element.
				canCollapse := lastElementIsStringOrZero := element isString ] ].
	collection size = self size
		ifTrue: [ ^ self ].
	newSize := collection size.
	new := self species new: newSize.
	j := 0.
	collection
		do: [ :element | 
			new at: j + 1 put: element.
			j := j + 1 ].
	^ new
%

category: 'private'
method: RwGemStoneVersionNumber
compareEqualTo: aRwGemStoneVersionNumber

	| mySize |
	aRwGemStoneVersionNumber species = self species ifFalse: [ ^false ].
	mySize := self size.
	mySize = aRwGemStoneVersionNumber size 
		ifFalse: [ ^false ].
	1 to: mySize do: [:i |
		(self at: i) = (aRwGemStoneVersionNumber at: i) ifFalse: [ ^false ]].
	^true
%

category: 'private'
method: RwGemStoneVersionNumber
compareLessThan: aRwGemStoneVersionNumber

	| mySize aSize commonSize count more |
	mySize := self size.
	aSize := aRwGemStoneVersionNumber size.
	commonSize :=  mySize min: aSize.
	count := 0.
	more := true.
	[ more and: [ count < commonSize ]] whileTrue: [
		(self at: count + 1) = (aRwGemStoneVersionNumber at: count + 1)
			ifTrue: [ count := count + 1 ]
			ifFalse: [ more := false ]].
	count < commonSize
		ifTrue: [ 
			^(self at: count + 1) < (aRwGemStoneVersionNumber at: count + 1) ].
	mySize < aSize
		ifTrue: [ 
			mySize = 0 ifTrue: [ ^true ].
			"if the versions at commonSize are equal and the next version slot in aRwGemStoneVersionNumber 
			 is a string, then it's considered that I'm > aRwGemStoneVersionNumber
			 (i.e., '2.9.9' is greater than '2.9.9-alpha.2')"
			(self at: commonSize) = (aRwGemStoneVersionNumber at: commonSize)
				ifFalse: [ ^true ]. 
			^(aRwGemStoneVersionNumber at: commonSize+1) isString not]
		ifFalse: [ 
			mySize = aSize ifTrue: [ ^false ].
			aSize <= 0 ifTrue: [ ^false ].
			"if the versions at commonSize are equal and the next version slot is a string, 
			 then it's considered that I'm < aRwGemStoneVersionNumber
			 (i.e., '2.9.9-alpha.2' is less than '2.9.9')"
			(self at: commonSize) = (aRwGemStoneVersionNumber at: commonSize)
				ifFalse: [ ^false ].
			 ^(self at: commonSize+1) isString]
%

category: 'copying'
method: RwGemStoneVersionNumber
copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize new j |
	newSize := stop - start + 1.
	new := self species new: newSize.
	j := 0.
	start to: stop do: [:i |
		new at: j + 1 put: (self at: i).
		j := j + 1 ].
	^new
%

category: 'enumerating'
method: RwGemStoneVersionNumber
do: aBlock 
	"Refer to the comment in Collection|do:."
	1 to: self size do:
		[:index | aBlock value: (self at: index)]
%

category: 'enumerating'
method: RwGemStoneVersionNumber
do: elementBlock separatedBy: separatorBlock
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	| beforeFirst | 
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		elementBlock value: each]
%

category: 'comparing'
method: RwGemStoneVersionNumber
hash

"Returns a numeric hash key for the receiver."

| mySize interval hashValue |

(mySize := self size) == 0
  ifTrue: [ ^15243 ].

"Choose an interval so that we sample at most 5 elements of the receiver"
interval := ((mySize - 1) // 4) max: 1.

hashValue := 4459.
1 to: mySize by: interval do: [ :i | | anElement |
  anElement := self at: i.
  (anElement isKindOf: SequenceableCollection)
    ifTrue: [
      hashValue := (hashValue bitShift: -1) bitXor: anElement size.
      ]
    ifFalse: [
      hashValue := (hashValue bitShift: -1) bitXor: anElement hash.
      ].
  ].

^ hashValue abs
%

category: 'printing'
method: RwGemStoneVersionNumber
printOn: aStream

	| beforeFirst | 
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [
				each isString
					ifTrue: [ aStream nextPut: $- ]
					ifFalse: [ aStream nextPut: $. ] ].
		aStream nextPutAll: each asString ]
%

category: 'matching'
method: RwGemStoneVersionNumber
rwPlatformAttributeMatchForGemStoneVersion: anRwGemStoneVersionConfigurationPlatformAttributeMatcher

	^ anRwGemStoneVersionConfigurationPlatformAttributeMatcher matchVersion: self
%

category: 'matching'
method: RwGemStoneVersionNumber
rwPlatformAttributeMatchForString: anRwStringConfigurationPlatformAttributeMatcher

	^ anRwStringConfigurationPlatformAttributeMatcher matchString: self printString
%

category: 'accessing'
method: RwGemStoneVersionNumber
versionString

	| strm |
	strm := WriteStream on: String new.
	self printOn: strm.
	^strm contents
%

category: 'comparing'
method: RwGemStoneVersionNumber
~> aRwGemStoneVersionNumber

	aRwGemStoneVersionNumber size == 1 ifTrue: [ ^false ].
	^self >= aRwGemStoneVersionNumber and: [ self < aRwGemStoneVersionNumber approximateBase ]
%

! Class implementation for 'RwSemanticVersionNumber'

!		Class methods for 'RwSemanticVersionNumber'

category: 'private'
classmethod: RwSemanticVersionNumber
extractNumericComponent: subString
    "$. separated components are integers"

    | number stream |
	stream := subString readStream.
	number := [ Integer fromStream: stream ] on: Error do: [:ex | ^ subString ].
	^ stream atEnd
		ifTrue: [ 
			(subString size > 1 and: [ (subString at: 1) = $0 ])
				ifTrue: [ self error: 'invalid version number: numberic components may not have a leading 0' ]
				ifFalse: [ number ] ]
		ifFalse: [ subString ]
%

category: 'instance creation'
classmethod: RwSemanticVersionNumber
fromString: aString
  | preRelease build versionString identifierCount normalEnd preReleaseEnd normalComponents preReleaseComponents buildComponents |
  normalComponents := OrderedCollection new.
  preReleaseComponents := OrderedCollection new.
  buildComponents := OrderedCollection new.
  preRelease := aString indexOf: $- startingAt: 1.
  build := aString indexOf: $+ startingAt: 1.
  (build > 0 and: [ preRelease > build ])
    ifTrue: [ preRelease := 0 ].
  normalEnd := preRelease = 0
    ifTrue: [ 
      build = 0
        ifTrue: [ aString size ]
        ifFalse: [ build - 1 ] ]
    ifFalse: [ preRelease - 1 ].
  versionString := aString copyFrom: 1 to: normalEnd.
  identifierCount := 0.
  (versionString subStrings: '.')
    do: [ :subString | 
      | integer |
      subString isEmpty
        ifTrue: [ self error: 'invalid version number: normal version component MUST NOT be empty' ].
	  integer := self integerFromString: subString.
	  integer < 0
		ifTrue: [ 
		  self
			error:
			  'invalid version number: normal version component MUST be integer '
				, subString printString ] .
      normalComponents add: integer.
      identifierCount := identifierCount + 1 ].
  identifierCount ~= 3
    ifTrue: [ self error: 'invalid version number: normal version MUST have only 3 components' ].
  preReleaseEnd := build = 0
    ifTrue: [ aString size ]
    ifFalse: [ build - 1 ].
  preRelease > 0
    ifTrue: [ 
      versionString := aString copyFrom: preRelease + 1 to: preReleaseEnd.
      (versionString subStrings: '.')
        do: [ :subString | 
	      subString isEmpty
              ifTrue: [ self error: 'invalid version number: preRelease version component MUST NOT be empty' ].
          (self isSemanticIdentifier: subString)
            ifFalse: [ 
              self
                error:
                  'invalid version number: preRelease version component must be one of [0-9A-Za-z-], MUST NOT be empty, and first component MUST NOT be 0' ].
          preReleaseComponents
            add:
              (self extractNumericComponent: subString) ] ].
  build > 0
    ifTrue: [ 
      versionString := aString copyFrom: build + 1 to: aString size.
      (versionString subStrings: '.')
        do: [ :subString | 
	      subString isEmpty
              ifTrue: [ self error: 'invalid version number: preRelease version component MUST NOT be empty' ].
          (self isSemanticIdentifier: subString)
            ifFalse: [ 
              self
                error:
                  'invalid version number: build version component must be one of [0-9A-Za-z-] and MUST NOT be empty' ].
          buildComponents add: subString ] ].

  ^ self new
    normalVersion: normalComponents;
    preReleaseVersion: preReleaseComponents;
    buildVersion: buildComponents;
    yourself
%

category: 'private'
classmethod: RwSemanticVersionNumber
integerFromString: aString
  aString
    detect: [ :char | char isDigit not ]
    ifNone: [ 
      | integer |
      integer := aString asInteger.
      ((aString at: 1) = $0 and: [ aString size > 1 ])
        ifTrue: [ 
          self
            error:
              'invalid version number: normal version component must not have leading 0s'
                , aString asString ].
      ^ integer ].
  self
    error:
      'invalid version number: normal version component must be integer '
        , aString asString
%

category: 'private'
classmethod: RwSemanticVersionNumber
isSemanticIdentifier: aString
    "whether the receiver is composed entirely of alphanumerics"

   aString do: [ :c | 
     c isAlphaNumeric
       ifFalse: [ c = $- ifFalse: [ ^ false ] ] ].
    ^ true
%

category: 'private'
classmethod: RwSemanticVersionNumber
validateVersionNumber: svn against: aString
  svn printString = aString
    ifFalse: [ 
      self
        error:
          'The printString of a semantic version number should be equal to the source version string' ]
%

!		Instance methods for 'RwSemanticVersionNumber'

category: 'comparing'
method: RwSemanticVersionNumber
< aRwSemanticVersionNumber
    aRwSemanticVersionNumber species = self species
        ifFalse: [ ^ false ].
    ^ self compareLessThan: aRwSemanticVersionNumber
%

category: 'comparing'
method: RwSemanticVersionNumber
= aMetacelloVersionNumber
    aMetacelloVersionNumber species = self species
        ifFalse: [ ^ false ].
    ^ self compareEqualTo: aMetacelloVersionNumber
%

category: 'accessing'
method: RwSemanticVersionNumber
approximateBase

	| base |
	base := self copyFrom: 1 to: self size - 1.
	base at: base size put: (base at: base size) + 1.
	^base
%

category: 'converting'
method: RwSemanticVersionNumber
asRwSemanticVersionNumber
    ^ self
%

category: 'printing'
method: RwSemanticVersionNumber
asString
	"Answer a string that represents the receiver."

	^ self printString
%

category: 'accessing'
method: RwSemanticVersionNumber
buildVersion
    buildVersion ifNil: [ buildVersion := #() ].
    ^ buildVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
buildVersion: anObject
	buildVersion := anObject
%

category: 'private'
method: RwSemanticVersionNumber
compareEqualTo: aRwSemanticVersionNumber
    aRwSemanticVersionNumber species = self species
        ifFalse: [ ^ false ].
    (self compareEqualTo: self normalVersion other: aRwSemanticVersionNumber normalVersion)
        ifFalse: [ ^ false ].
    (self compareEqualTo: self preReleaseVersion other: aRwSemanticVersionNumber preReleaseVersion)
        ifFalse: [ ^ false ].
    ^ true
%

category: 'private'
method: RwSemanticVersionNumber
compareEqualTo: myComponents other: otherComponents
    | mySize |
    mySize := myComponents size.
    mySize = otherComponents size
        ifFalse: [ ^ false ].
    1 to: mySize do: [ :i | 
        (myComponents at: i) = (otherComponents at: i)
            ifFalse: [ ^ false ] ].
    ^ true
%

category: 'private'
method: RwSemanticVersionNumber
compareLessThan: aRwSemanticVersionNumber
    | myComponents otherComponents defaultResult |
    aRwSemanticVersionNumber species = self species
        ifFalse: [ ^ false ].
    myComponents := self normalVersion.
    otherComponents := aRwSemanticVersionNumber normalVersion.
    defaultResult := true.
    (self compareEqualTo: myComponents other: otherComponents)
        ifTrue: [ defaultResult := false ]
        ifFalse: [ 
            (self compareLessThan: myComponents other: otherComponents version: #'normal')
                ifFalse: [ ^ false ] ].
    myComponents := self preReleaseVersion.
    otherComponents := aRwSemanticVersionNumber preReleaseVersion.
    (self compareEqualTo: myComponents other: otherComponents)
        ifTrue: [ 
            myComponents size > 0
                ifTrue: [ defaultResult := false ] ]
        ifFalse: [ ^ self compareLessThan: myComponents other: otherComponents version: #'preRelease' ].
    ^ defaultResult
%

category: 'private'
method: RwSemanticVersionNumber
compareLessThan: myComponents other: otherComponents version: version
    | mySize aSize commonSize count more |
    mySize := myComponents size.
    aSize := otherComponents size.
    commonSize := mySize min: aSize.
    count := 0.
    more := true.
    [ more and: [ count < commonSize ] ]
        whileTrue: [ 
            (myComponents at: count + 1) = (otherComponents at: count + 1)
                ifTrue: [ count := count + 1 ]
                ifFalse: [ more := false ] ].
    count < commonSize
        ifTrue: [ ^ (myComponents at: count + 1) rwSemanticVersionComponentLessThan: (otherComponents at: count + 1) ].
    mySize < aSize
        ifTrue: [ 
            mySize = 0
                ifTrue: [ 
                    #'preRelease' == version
                        ifTrue: [ ^ false ].
                    ^ true ].
            (myComponents at: commonSize) = (otherComponents at: commonSize)
                ifFalse: [ ^ true ].
            ^ true ]
        ifFalse: [ 
            mySize = aSize
                ifTrue: [ ^ false ].
            aSize = 0
                ifTrue: [ 
                    #'build' == version
                        ifTrue: [ ^ false ].
                    ^ true ].
            (myComponents at: commonSize) = (otherComponents at: commonSize)
                ifFalse: [ ^ false ].
            ^ true ]
%

category: 'copying'
method: RwSemanticVersionNumber
copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize new j |
	newSize := stop - start + 1.
	new := self species new: newSize.
	j := 0.
	start to: stop do: [:i |
		new at: j + 1 put: (self at: i).
		j := j + 1 ].
	^new
%

category: 'operations'
method: RwSemanticVersionNumber
decrementMajorVersion
  self decrementNormalVersionAt: 1
%

category: 'operations'
method: RwSemanticVersionNumber
decrementMinorVersion
  self decrementNormalVersionAt: 2
%

category: 'operations'
method: RwSemanticVersionNumber
decrementMinorVersionNumber
  self decrementNormalVersionAt: 3
%

category: 'private'
method: RwSemanticVersionNumber
decrementNormalVersionAt: index
  | int col |
  col := self normalVersion.
  int := col at: index.
  int > 0
    ifTrue: [ col at: index put: int - 1 ]
%

category: 'operations'
method: RwSemanticVersionNumber
decrementPatchVersion
  self decrementNormalVersionAt: 3
%

category: 'enumerating'
method: RwSemanticVersionNumber
do: aBlock 
	"Refer to the comment in Collection|do:."
	1 to: self size do:
		[:index | aBlock value: (self at: index)]
%

category: 'enumerating'
method: RwSemanticVersionNumber
do: elementBlock separatedBy: separatorBlock
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	| beforeFirst | 
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		elementBlock value: each]
%

category: 'comparing'
method: RwSemanticVersionNumber
hash
    ^ self versionComponents hash
%

category: 'operations'
method: RwSemanticVersionNumber
incrementMajorVersion
  self incrementNormalVersionAt: 1
%

category: 'operations'
method: RwSemanticVersionNumber
incrementMinorVersion
  self incrementNormalVersionAt: 2
%

category: 'operations'
method: RwSemanticVersionNumber
incrementMinorVersionNumber
  self incrementNormalVersionAt: 3
%

category: 'private'
method: RwSemanticVersionNumber
incrementNormalVersionAt: index
  | int col |
  col := self normalVersion.
  int := col at: index.
  col at: index put: int + 1
%

category: 'operations'
method: RwSemanticVersionNumber
incrementPatchVersion
  self incrementNormalVersionAt: 3
%

category: 'accessing'
method: RwSemanticVersionNumber
normalVersion
    normalVersion ifNil: [ normalVersion := #() ].
    ^ normalVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
normalVersion: anObject
	normalVersion := anObject
%

category: 'copying'
method: RwSemanticVersionNumber
postCopy
  normalVersion := normalVersion copy.
  preReleaseVersion := preReleaseVersion copy.
  buildVersion := buildVersion copy
%

category: 'accessing'
method: RwSemanticVersionNumber
preReleaseVersion
    preReleaseVersion ifNil: [ preReleaseVersion := #() ].
    ^ preReleaseVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
preReleaseVersion: anObject
	preReleaseVersion := anObject
%

category: 'printing'
method: RwSemanticVersionNumber
print: components prefix: prefixChar on: aStream
    | beforeFirst |
    beforeFirst := true.
    components
        do: [ :component | 
            beforeFirst
                ifTrue: [ 
                    beforeFirst := false.
                    prefixChar ifNotNil: [ aStream nextPut: prefixChar ] ]
                ifFalse: [ aStream nextPut: $. ].
            aStream nextPutAll: component asString ]
%

category: 'printing'
method: RwSemanticVersionNumber
printOn: aStream
    self print: self normalVersion prefix: nil on: aStream.
    self print: self preReleaseVersion prefix: $- on: aStream.
    self print: self buildVersion prefix: $+ on: aStream
%

category: 'private'
method: RwSemanticVersionNumber
versionComponents
    ^ self normalVersion , self preReleaseVersion , self buildVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
versionString

	| strm |
	strm := WriteStream on: String new.
	self printOn: strm.
	^strm contents
%

category: 'comparing'
method: RwSemanticVersionNumber
~> aMetacelloVersionNumber

	"if this selector is to survive it will need work ... see RwGemStoneVersionNumber ... I think that collapseZeroes will be needed (in some form) to 
		make this boy give expected results"

	aMetacelloVersionNumber size == 1 ifTrue: [ ^false ].
	^self >= aMetacelloVersionNumber and: [ self < aMetacelloVersionNumber approximateBase ]
%

! Class implementation for 'GsInteractionRequest'

!		Class methods for 'GsInteractionRequest'

category: 'interacting'
classmethod: GsInteractionRequest
signal: aGsInteraction
  ^ (self new interaction: aGsInteraction) signal
%

!		Instance methods for 'GsInteractionRequest'

category: 'signaling'
method: GsInteractionRequest
defaultAction
  ^ self interaction defaultActionFor: self
%

category: 'Compatibility'
method: GsInteractionRequest
gsArguments
  "This method included here for G/S 2.x only ... not needed nor used in 3.x"

  ^ {(self interaction)}
%

category: 'Instance initialization'
method: GsInteractionRequest
initialize
  super initialize.
  gsNumber := 121001
%

category: 'accessing'
method: GsInteractionRequest
interaction

   "Return the value of the instance variable 'interaction'."
   ^interaction
%

category: 'accessing'
method: GsInteractionRequest
interaction: anObject

   "Modify the value of the instance variable 'interaction'."
   interaction := anObject
%

category: 'signaling'
method: GsInteractionRequest
response: anObject
  self resume: anObject
%

! Class implementation for 'RwAdoptAuditErrorNotification'

!		Class methods for 'RwAdoptAuditErrorNotification'

category: 'instance creation'
classmethod: RwAdoptAuditErrorNotification
classNamed: className isClassExtension: classExtension  intoPackageNamed: packageName

	^ self new
		className: className;
		isClassExtension: classExtension;
		packageName: packageName;
		yourself
%

!		Instance methods for 'RwAdoptAuditErrorNotification'

category: 'accessing'
method: RwAdoptAuditErrorNotification
className

	^ className
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
className: aString

	className := aString
%

category: 'Handling'
method: RwAdoptAuditErrorNotification
defaultAction
 
	^ Error signal: self _errorMessage
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
description

	^ description ifNil: [ '' ]
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
description: aString

	description := aString
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
isClassExtension

	^ isClassExtension
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
isClassExtension: aBoolean

	isClassExtension := aBoolean
%

category: 'Handling'
method: RwAdoptAuditErrorNotification
methodErrorDo: methodBlock classErrorDo: classBlock
	"helper method for use in exception handling block ... avoid isKindOf:"

	self subclassResponsibility: #methodErrorDo:classErrorDo:
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
packageName

	^ packageName
%

category: 'accessing'
method: RwAdoptAuditErrorNotification
packageName: aString

	packageName := aString
%

category: 'private'
method: RwAdoptAuditErrorNotification
_errorMessage

	self subclassResponsibility: #_errorMessage
%

! Class implementation for 'RwAdoptAuditClassErrorNotification'

!		Instance methods for 'RwAdoptAuditClassErrorNotification'

category: 'Handling'
method: RwAdoptAuditClassErrorNotification
methodErrorDo: methodBlock classErrorDo: classBlock
	"helper method for use in exception handling block ... avoid isKindOf:"

	classBlock value
%

! Class implementation for 'RwAdoptMissingClassErrorNotification'

!		Instance methods for 'RwAdoptMissingClassErrorNotification'

category: 'private'
method: RwAdoptMissingClassErrorNotification
_errorMessage

	| extensionMessage |
	extensionMessage := self isClassExtension
		ifTrue: [ ' extension ' ]
		ifFalse: [ ' ' ].
	^ 'Unable to adopt the class ', self className printString, ' into the', extensionMessage, 'package ', self packageName printString, ' as it is not present in the current user''s symbol list.'
%

! Class implementation for 'RwAuditClassErrorNotification'

!		Instance methods for 'RwAuditClassErrorNotification'

category: 'Handling'
method: RwAuditClassErrorNotification
defaultAction
	"record audit error"
	^ true
%

! Class implementation for 'RwAdoptAuditMethodErrorNotification'

!		Class methods for 'RwAdoptAuditMethodErrorNotification'

category: 'instance creation'
classmethod: RwAdoptAuditMethodErrorNotification
method: methodSelector isMeta: isMeta inClassNamed: className isClassExtension: classExtension  intoPackageNamed: packageName


	^ (self classNamed: className isClassExtension: classExtension  intoPackageNamed: packageName)
		selector: methodSelector;
		isMetaclass: isMeta;
		yourself
%

!		Instance methods for 'RwAdoptAuditMethodErrorNotification'

category: 'accessing'
method: RwAdoptAuditMethodErrorNotification
isMetaclass

	^ isMetaclass
%

category: 'accessing'
method: RwAdoptAuditMethodErrorNotification
isMetaclass: aBoolean

	isMetaclass := aBoolean
%

category: 'Handling'
method: RwAdoptAuditMethodErrorNotification
methodErrorDo: methodBlock classErrorDo: classBlock
	"helper method for use in exception handling block ... avoid isKindOf:"

	methodBlock value
%

category: 'accessing'
method: RwAdoptAuditMethodErrorNotification
methodPrintString

	^ self 
		className, 
		(self isMetaclass ifTrue: [ ' class >> ' ] ifFalse: [ ' >> ' ]),
		self selector
%

category: 'accessing'
method: RwAdoptAuditMethodErrorNotification
selector

	^ selector
%

category: 'accessing'
method: RwAdoptAuditMethodErrorNotification
selector: aString

	selector := aString
%

! Class implementation for 'RwAdoptMissingMethodErrorNotification'

!		Instance methods for 'RwAdoptMissingMethodErrorNotification'

category: 'private'
method: RwAdoptMissingMethodErrorNotification
_errorMessage

	| extensionMessage metaClassMessage |
	metaClassMessage := self isMetaclass
		ifTrue: [ ' class << #' ]
		ifFalse: [ '  << #' ].
	extensionMessage := self isClassExtension
		ifTrue: [ ' extension ' ]
		ifFalse: [ ' ' ].
	^ 'Unable to adopt the method ', self className, metaClassMessage, self selector asString, ' into the package ', self packageName printString, '. The method is not present in the class''s method dictionary.'
%

! Class implementation for 'RwAuditMethodErrorNotification'

!		Instance methods for 'RwAuditMethodErrorNotification'

category: 'Handling'
method: RwAuditMethodErrorNotification
defaultAction
	"record audit error"
	^ true
%

! Class implementation for 'RwDeleteClassFromSystemNotification'

!		Instance methods for 'RwDeleteClassFromSystemNotification'

category: 'accessing'
method: RwDeleteClassFromSystemNotification
candidateClass
	"class to be deleted from system, if receiver is #resumed: with true"

	^ candidateClass
%

category: 'accessing'
method: RwDeleteClassFromSystemNotification
candidateClass: aClassToBeDeleted

	candidateClass := aClassToBeDeleted
%

category: 'handling'
method: RwDeleteClassFromSystemNotification
defaultAction

	^ true
%

! Class implementation for 'RwExecuteClassInitializeMethodsAfterLoadNotification'

!		Instance methods for 'RwExecuteClassInitializeMethodsAfterLoadNotification'

category: 'accessing'
method: RwExecuteClassInitializeMethodsAfterLoadNotification
candidateClass
	"class to which #initialize if receiver is #resumed: with true"

	^ candidateClass
%

category: 'accessing'
method: RwExecuteClassInitializeMethodsAfterLoadNotification
candidateClass: aClassToInitialize

	candidateClass := aClassToInitialize
%

category: 'handling'
method: RwExecuteClassInitializeMethodsAfterLoadNotification
defaultAction

	^ true
%

! Class implementation for 'RwExistingAssociationWithSameKeyNotification'

!		Instance methods for 'RwExistingAssociationWithSameKeyNotification'

category: 'handling'
method: RwExistingAssociationWithSameKeyNotification
defaultAction

	self error: self errorMessage
%

category: 'accessing'
method: RwExistingAssociationWithSameKeyNotification
errorMessage

   ^errorMessage
%

category: 'accessing'
method: RwExistingAssociationWithSameKeyNotification
errorMessage: anObject

   errorMessage := anObject
%

! Class implementation for 'RwExistingVisitorAddingExistingClassNotification'

!		Instance methods for 'RwExistingVisitorAddingExistingClassNotification'

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
classDefinition

	^ classDefinition
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
classDefinition: aClassDefinition

	classDefinition := aClassDefinition
%

category: 'handling'
method: RwExistingVisitorAddingExistingClassNotification
defaultAction

	loadedProject ifNil: [ ^ self error: 'Visitor adding a class ', classDefinition name printString, ' that already exists' ].
	self error: 
		'Visitor adding a class ', 
		classDefinition name printString, 
		' that already exists in the project ', 
		loadedProject name printString, 
		', but the project was not included in the load'
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
loadedProject

	^ loadedProject
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
loadedProject: aLoadedProject

	loadedProject := aLoadedProject
%

! Class implementation for 'RwInvalidCategoryProtocolConventionErrorNotification'

!		Instance methods for 'RwInvalidCategoryProtocolConventionErrorNotification'

category: 'Handling'
method: RwInvalidCategoryProtocolConventionErrorNotification
classCategoryNotificationDo: classCategoryBlock nonExtensionMethodNoficationDo: nonExtensionMethodBlock extensionMethodPackageMismatchNoficationDo: extensionMethodPackageMismatchBlock  extensionMethodNonExtensionProtocolNoficationDo: extensionMethodNonExtensionProtocolBlock
	"helper method for use in exception handling block ... avoid isKindOf:"

	
	self subclassResponsibility: #classCategoryNotificationDo:nonExtensionMethodNoficationDo:extensionMethodPackageMismatchNoficationDo:extensionMethodNonExtensionProtocolNoficationDo:
%

category: 'Handling'
method: RwInvalidCategoryProtocolConventionErrorNotification
defaultAction
 
	^ Error signal: self _errorMessage
%

category: 'accessing'
method: RwInvalidCategoryProtocolConventionErrorNotification
packageConvention

	^ packageConvention
%

category: 'accessing'
method: RwInvalidCategoryProtocolConventionErrorNotification
packageConvention: aString

	packageConvention := aString
%

category: 'accessing'
method: RwInvalidCategoryProtocolConventionErrorNotification
packageName

	^ packageName
%

category: 'accessing'
method: RwInvalidCategoryProtocolConventionErrorNotification
packageName: aString

	packageName := aString
%

category: 'private'
method: RwInvalidCategoryProtocolConventionErrorNotification
_errorMessage

	^ self subclassResponsibility: #_errorMessage
%

! Class implementation for 'RwInvalidClassCategoryConventionErrorNotification'

!		Class methods for 'RwInvalidClassCategoryConventionErrorNotification'

category: 'instance creation'
classmethod: RwInvalidClassCategoryConventionErrorNotification
signalWithClassDefinition: aClassDefinition packageName: packageName packageConvention: aString

	^ self new
			classDefinition: aClassDefinition;
			packageName:  packageName;
			packageConvention: aString;
			signal
%

!		Instance methods for 'RwInvalidClassCategoryConventionErrorNotification'

category: 'Handling'
method: RwInvalidClassCategoryConventionErrorNotification
classCategoryNotificationDo: classCategoryBlock nonExtensionMethodNoficationDo: nonExtensionMethodBlock extensionMethodPackageMismatchNoficationDo: extensionMethodPackageMismatchBlock  extensionMethodNonExtensionProtocolNoficationDo: extensionMethodNonExtensionProtocolBlock
	"class category does not match the package name"

	classCategoryBlock value
%

category: 'accessing'
method: RwInvalidClassCategoryConventionErrorNotification
classDefinition

	^ classDefinition
%

category: 'accessing'
method: RwInvalidClassCategoryConventionErrorNotification
classDefinition: aClassDefinition

	classDefinition := aClassDefinition
%

category: 'private'
method: RwInvalidClassCategoryConventionErrorNotification
_errorMessage

	^ 'The class category ', 
		self classDefinition category printString, 
		' for the class ', 
		self classDefinition name printString, 
		' violates the package convention ', 
		self packageConvention printString
%

! Class implementation for 'RwInvalidMethodProtocolConventionErrorNotification'

!		Class methods for 'RwInvalidMethodProtocolConventionErrorNotification'

category: 'instance creation'
classmethod: RwInvalidMethodProtocolConventionErrorNotification
signalWithMethodDefinition: aMethodDefinition className: className isMeta: isMeta packageName:  packageName packageConvention: aString

	^ self new
			methodDefinition: aMethodDefinition;
			className: className;
			isMeta: isMeta;
			packageName:  packageName;
			packageConvention: aString;
			signal
%

!		Instance methods for 'RwInvalidMethodProtocolConventionErrorNotification'

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
className

	^ className
%

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
className: aString

	className := aString
%

category: 'Handling'
method: RwInvalidMethodProtocolConventionErrorNotification
defaultAction
 
	^ Error signal: self _errorMessage
%

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
isMeta

	^ isMeta
%

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
isMeta: aBool

	isMeta := aBool
%

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
methodDefinition

	^ methodDefinition
%

category: 'accessing'
method: RwInvalidMethodProtocolConventionErrorNotification
methodDefinition: aMethodDef

	methodDefinition := aMethodDef
%

category: 'private'
method: RwInvalidMethodProtocolConventionErrorNotification
_errorMessage

	^ 'The method protocol ', 
		self methodDefinition protocol printString, 
		' for the method ', 
		self _methodPrintString printString, 
		' in the package ', 
		self packageName printString,
		' violates the package convention ', 
		self packageConvention printString, 
		'. '
%

category: 'private'
method: RwInvalidMethodProtocolConventionErrorNotification
_methodPrintString

	^ self className, (self isMeta ifTrue: [ ' class>>' ] ifFalse: [ '>>' ]), self methodDefinition selector
%

! Class implementation for 'RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification'

!		Instance methods for 'RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification'

category: 'Handling'
method: RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification
classCategoryNotificationDo: classCategoryBlock nonExtensionMethodNoficationDo: nonExtensionMethodBlock extensionMethodPackageMismatchNoficationDo: extensionMethodPackageMismatchBlock  extensionMethodNonExtensionProtocolNoficationDo: extensionMethodNonExtensionProtocolBlock
	"extension method protocol does start with a *, but does not match the package name"

	extensionMethodPackageMismatchBlock value
%

category: 'private'
method: RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification
_errorMessage

	^ super _errorMessage, 'The extension protocol does not match the package of the extension method.'
%

! Class implementation for 'RwExtensionProtocolNonExtensionMethodErrorNotification'

!		Instance methods for 'RwExtensionProtocolNonExtensionMethodErrorNotification'

category: 'Handling'
method: RwExtensionProtocolNonExtensionMethodErrorNotification
classCategoryNotificationDo: classCategoryBlock nonExtensionMethodNoficationDo: nonExtensionMethodBlock extensionMethodPackageMismatchNoficationDo: extensionMethodPackageMismatchBlock  extensionMethodNonExtensionProtocolNoficationDo: extensionMethodNonExtensionProtocolBlock
	"method protocol starts with a * for non-extension method"

	nonExtensionMethodBlock value
%

category: 'private'
method: RwExtensionProtocolNonExtensionMethodErrorNotification
_errorMessage

	^ super _errorMessage, 'The protocol should not start with a *, as the method is NOT an extension method.'
%

! Class implementation for 'RwNonExtensionProtocolExtensionMethodErrorNotification'

!		Instance methods for 'RwNonExtensionProtocolExtensionMethodErrorNotification'

category: 'Handling'
method: RwNonExtensionProtocolExtensionMethodErrorNotification
classCategoryNotificationDo: classCategoryBlock nonExtensionMethodNoficationDo: nonExtensionMethodBlock extensionMethodPackageMismatchNoficationDo: extensionMethodPackageMismatchBlock  extensionMethodNonExtensionProtocolNoficationDo: extensionMethodNonExtensionProtocolBlock
	"extension method protocol doesn't start with a *"

	extensionMethodNonExtensionProtocolBlock value
%

category: 'private'
method: RwNonExtensionProtocolExtensionMethodErrorNotification
_errorMessage

	^ super _errorMessage, 'The protocol should start with a *, as the method IS an extension method.'
%

! Class implementation for 'RwPerformingUnpackagedEditNotification'

!		Instance methods for 'RwPerformingUnpackagedEditNotification'

category: 'handling'
method: RwPerformingUnpackagedEditNotification
defaultAction

	^ self error: self errorMessage
%

category: 'accessing'
method: RwPerformingUnpackagedEditNotification
errorMessage

   ^self informMessage
%

category: 'accessing'
method: RwPerformingUnpackagedEditNotification
informMessage

   ^informMessage
%

category: 'accessing'
method: RwPerformingUnpackagedEditNotification
informMessage: anObject

   informMessage := anObject
%

category: 'signalling'
method: RwPerformingUnpackagedEditNotification
signal: aMessage

	self informMessage: aMessage.
	^ self signal
%

! Class implementation for 'GsInteraction'

!		Instance methods for 'GsInteraction'

category: 'accessing'
method: GsInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      nil ] ].
  ^ defaultActionBlock
%

category: 'accessing'
method: GsInteraction
defaultActionBlock: anObject

   "Modify the value of the instance variable 'defaultActionBlock'."
   defaultActionBlock := anObject
%

category: 'interacting'
method: GsInteraction
defaultActionFor: anInteractionRequest
  ^ self defaultActionBlock value: anInteractionRequest
%

category: 'interacting'
method: GsInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithInspect:
     interactWithMultiLineText:
     interactWithText:
  "

  self subclassResponsibility
%

category: 'printing'
method: GsInteraction
printLabel
  ^ ''
%

category: 'printing'
method: GsInteraction
printOn: aStream
  aStream nextPutAll: self class name asString , '(' , self printLabel , ')'
%

category: 'interacting'
method: GsInteraction
signal
  ^ GsInteractionRequest signal: self
%

! Class implementation for 'GsChoiceInteraction'

!		Class methods for 'GsChoiceInteraction'

category: 'instance creation'
classmethod: GsChoiceInteraction
labels: anArray
	^ self
		prompt: nil
		labels: anArray
		values: anArray
		lines: #()
%

category: 'instance creation'
classmethod: GsChoiceInteraction
labels: labelArray lines: lineArray
	^ self
		prompt: nil
		labels: labelArray
		values: labelArray
		lines: lineArray
%

category: 'instance creation'
classmethod: GsChoiceInteraction
prompt: aString labels: labelArray values: valueArray
	^ self
		prompt: aString
		labels: labelArray
		 values: valueArray
		lines: #()
%

category: 'instance creation'
classmethod: GsChoiceInteraction
prompt: aString labels: labelArray values: valueArray lines: lineArray
  ^ self new
    prompt: aString;
    labels: labelArray;
    values: valueArray;
    lines: lineArray;
    yourself
%

!		Instance methods for 'GsChoiceInteraction'

category: 'interacting'
method: GsChoiceInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithChoice: self
%

category: 'accessing'
method: GsChoiceInteraction
labels

   "Return the value of the instance variable 'labels'."
   ^labels
%

category: 'accessing'
method: GsChoiceInteraction
labels: anObject

   "Modify the value of the instance variable 'labels'."
   labels := anObject
%

category: 'accessing'
method: GsChoiceInteraction
lines

   "Return the value of the instance variable 'lines'."
   ^lines
%

category: 'accessing'
method: GsChoiceInteraction
lines: anObject

   "Modify the value of the instance variable 'lines'."
   lines := anObject
%

category: 'printing'
method: GsChoiceInteraction
printLabel
  ^ self prompt
%

category: 'accessing'
method: GsChoiceInteraction
prompt

   "Return the value of the instance variable 'prompt'."
   ^prompt
%

category: 'accessing'
method: GsChoiceInteraction
prompt: aString
  prompt := aString copyWrappedTo: 80
%

category: 'choice'
method: GsChoiceInteraction
select: anIndex
  ^ self values at: anIndex
%

category: 'choice'
method: GsChoiceInteraction
select: anIndex for: anInteractionRequest
  anInteractionRequest response: (self values at: anIndex)
%

category: 'accessing'
method: GsChoiceInteraction
values

   "Return the value of the instance variable 'values'."
   ^values
%

category: 'accessing'
method: GsChoiceInteraction
values: anObject

   "Modify the value of the instance variable 'values'."
   values := anObject
%

! Class implementation for 'GsConfirmInteraction'

!		Class methods for 'GsConfirmInteraction'

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt
  ^ self prompt: prompt confirm: 'Ok'
%

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt confirm: confirm
  ^ self prompt: prompt confirm: confirm cancel: 'Cancel'
%

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt confirm: confirm cancel: cancel
  ^ self new
    prompt: prompt;
    confirm: confirm;
    cancel: cancel
%

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt confirm: confirm cancel: cancel abort: abort
  "on confirm return true, on cancel return false on abort return nil"

  ^ self new
    prompt: prompt;
    confirm: confirm;
    cancel: cancel;
    abort: abort
%

!		Instance methods for 'GsConfirmInteraction'

category: 'accessing'
method: GsConfirmInteraction
abort
  ^ abort
%

category: 'accessing'
method: GsConfirmInteraction
abort: anObject
  abort := anObject
%

category: 'confirm'
method: GsConfirmInteraction
abortFor: anInteractionRequest
  anInteractionRequest response: self abortResponse
%

category: 'confirm'
method: GsConfirmInteraction
abortResponse
  ^ nil
%

category: 'accessing'
method: GsConfirmInteraction
cancel
  ^ cancel
%

category: 'accessing'
method: GsConfirmInteraction
cancel: anObject
	cancel := anObject
%

category: 'confirm'
method: GsConfirmInteraction
cancelFor: anInteractionRequest
  anInteractionRequest response: self cancelResponse
%

category: 'confirm'
method: GsConfirmInteraction
cancelResponse
  ^ false
%

category: 'accessing'
method: GsConfirmInteraction
confirm
	^ confirm
%

category: 'accessing'
method: GsConfirmInteraction
confirm: anObject
	confirm := anObject
%

category: 'accessing'
method: GsConfirmInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      self cancelResponse ] ].
  ^ defaultActionBlock
%

category: 'interacting'
method: GsConfirmInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithConfirm: self
%

category: 'confirm'
method: GsConfirmInteraction
ok
  ^ true
%

category: 'confirm'
method: GsConfirmInteraction
okFor: anInteractionRequest
  anInteractionRequest response: self okResponse
%

category: 'confirm'
method: GsConfirmInteraction
okResponse
  ^ true
%

category: 'printing'
method: GsConfirmInteraction
printLabel
  ^ self prompt
%

category: 'accessing'
method: GsConfirmInteraction
prompt
	^ prompt
%

category: 'accessing'
method: GsConfirmInteraction
prompt: aString
  prompt := aString copyWrappedTo: 80
%

! Class implementation for 'GsNotifyInteraction'

!		Instance methods for 'GsNotifyInteraction'

category: 'accessing'
method: GsNotifyInteraction
defaultActionBlock
  "notify answers ok by default, while confirm answers fals by default"

  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      self okResponse ] ].
  ^ defaultActionBlock
%

! Class implementation for 'GsInformInteraction'

!		Class methods for 'GsInformInteraction'

category: 'instance creation'
classmethod: GsInformInteraction
message: aString
  ^ self new
    message: aString;
    yourself
%

!		Instance methods for 'GsInformInteraction'

category: 'interacting'
method: GsInformInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithInform: self
%

category: 'accessing'
method: GsInformInteraction
message

   "Return the value of the instance variable 'message'."
   ^message
%

category: 'accessing'
method: GsInformInteraction
message: aString
  message := aString copyWrappedTo: 80
%

category: 'printing'
method: GsInformInteraction
printLabel
  ^ self message
%

! Class implementation for 'GsInspectInteraction'

!		Class methods for 'GsInspectInteraction'

category: 'instance creation'
classmethod: GsInspectInteraction
theObject: anObject
  ^ self new
    theObject: anObject;
    yourself
%

!		Instance methods for 'GsInspectInteraction'

category: 'accessing'
method: GsInspectInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      self theObject ] ].
  ^ defaultActionBlock
%

category: 'interacting'
method: GsInspectInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithInspect:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithInspect: self
%

category: 'printing'
method: GsInspectInteraction
printLabel
  ^ self theObject printString
%

category: 'accessing'
method: GsInspectInteraction
theObject

   "Return the value of the instance variable 'theObject'."
   ^theObject
%

category: 'accessing'
method: GsInspectInteraction
theObject: anObject

   "Modify the value of the instance variable 'theObject'."
   theObject := anObject
%

! Class implementation for 'GsExploreInteraction'

!		Instance methods for 'GsExploreInteraction'

category: 'interacting'
method: GsExploreInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithInspect:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithExplore: self
%

! Class implementation for 'GsTextInteraction'

!		Class methods for 'GsTextInteraction'

category: 'instance creation'
classmethod: GsTextInteraction
prompt: aString
  ^ self prompt: aString template: ''
%

category: 'instance creation'
classmethod: GsTextInteraction
prompt: promptString template: templateString
  ^ self new
    prompt: promptString;
    template: templateString;
    yourself
%

category: 'instance creation'
classmethod: GsTextInteraction
requestPassword: aString
  ^ self new
    requestPassword: aString;
    yourself
%

!		Instance methods for 'GsTextInteraction'

category: 'accessing'
method: GsTextInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      '' ] ].
  ^ defaultActionBlock
%

category: 'interacting'
method: GsTextInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithText: self
%

category: 'printing'
method: GsTextInteraction
printLabel
  ^ self prompt
%

category: 'accessing'
method: GsTextInteraction
prompt

   "Return the value of the instance variable 'prompt'."
   ^prompt
%

category: 'accessing'
method: GsTextInteraction
prompt: aString
  prompt := aString copyWrappedTo: 80
%

category: 'accessing'
method: GsTextInteraction
requestPassword

   requestPassword ifNil: [ requestPassword := false ].
   ^requestPassword
%

category: 'accessing'
method: GsTextInteraction
requestPassword: aString

   prompt := aString.
   requestPassword := true
%

category: 'accessing'
method: GsTextInteraction
template
  template ifNil: [ template := '' ].
  ^ template
%

category: 'accessing'
method: GsTextInteraction
template: anObject

   "Modify the value of the instance variable 'template'."
   template := anObject
%

! Class implementation for 'GsMultiLineTextInteraction'

!		Instance methods for 'GsMultiLineTextInteraction'

category: 'interacting'
method: GsMultiLineTextInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithMultiLineText: self
%

! Class implementation for 'GsInteractionHandler'

!		Instance methods for 'GsInteractionHandler'

category: 'accessing'
method: GsInteractionHandler
choiceBlock
  choiceBlock ifNil: [ ^ self defaultBlock ].
  ^ choiceBlock
%

category: 'accessing'
method: GsInteractionHandler
choiceBlock: anObject

   "Modify the value of the instance variable 'choiceBlock'."
   choiceBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
confirmBlock
  confirmBlock ifNil: [ ^ self defaultBlock ].
  ^ confirmBlock
%

category: 'accessing'
method: GsInteractionHandler
confirmBlock: anObject

   "Modify the value of the instance variable 'confirmBlock'."
   confirmBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
defaultBlock
  defaultBlock
    ifNil: [ 
      defaultBlock := [ :interaction | 
      self
        error:
          'No handler defined for ' , interaction class name asString , ' interaction.' ] ].
  ^ defaultBlock
%

category: 'accessing'
method: GsInteractionHandler
defaultBlock: anObject

   "Modify the value of the instance variable 'defaultBlock'."
   defaultBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
informBlock
  informBlock ifNil: [ ^ self defaultBlock ].
  ^ informBlock
%

category: 'accessing'
method: GsInteractionHandler
informBlock: anObject

   "Modify the value of the instance variable 'informBlock'."
   informBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
inspectBlock
  inspectBlock ifNil: [ ^ self defaultBlock ].
  ^ inspectBlock
%

category: 'accessing'
method: GsInteractionHandler
inspectBlock: anObject

   "Modify the value of the instance variable 'inspectBlock'."
   inspectBlock := anObject
%

category: 'interactions'
method: GsInteractionHandler
interactWithChoice: interaction
  ^ self choiceBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithConfirm: interaction
  ^ self confirmBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithExplore: interaction
  ^ self interactWithInspect: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithInform: interaction
  ^ self informBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithInspect: interaction
  ^ self inspectBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithMultiLineText: interaction
  ^ self multiLineTextBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithText: interaction
  ^ self textBlock value: interaction
%

category: 'accessing'
method: GsInteractionHandler
multiLineTextBlock
  multiLineTextBlock ifNil: [ ^ self defaultBlock ].
  ^ multiLineTextBlock
%

category: 'accessing'
method: GsInteractionHandler
multiLineTextBlock: anObject

   "Modify the value of the instance variable 'multiLineTextBlock'."
   multiLineTextBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
textBlock
  textBlock ifNil: [ ^ self defaultBlock ].
  ^ textBlock
%

category: 'accessing'
method: GsInteractionHandler
textBlock: anObject

   "Modify the value of the instance variable 'textBlock'."
   textBlock := anObject
%

! Class implementation for 'JadeServer'

!		Class methods for 'JadeServer'

category: 'jadeite server'
classmethod: JadeServer
theJadeiteServer

	^SessionTemps current at: #jadeiteServer ifAbsentPut: [
		(Rowan jadeServerClassNamed: #JadeServer64bit32) new initialize; yourself]
%

!		Instance methods for 'JadeServer'

category: 'category'
method: JadeServer
abort

	classOrganizers := Array new: 4.
	System abortTransaction.
%

category: 'category'
method: JadeServer
addAccessorsFor: aString inBehavior: aBehavior

	aBehavior compileAccessingMethodsFor: (Array with: aString asSymbol).

%

category: 'category'
method: JadeServer
addCategory: aString to: aClass 

	aClass addCategory: aString.

%

category: 'category'
method: JadeServer
addGroup: aString toUser: aUserProfile

	aUserProfile addGroup: aString.

%

category: 'category'
method: JadeServer
addMethodCategoryNamesToMethodFilters

	classList do: [:each | methodFilters addAll: each categoryNames].

%

category: 'category'
method: JadeServer
addMissingAccessorsFor: aClass

	aClass compileMissingAccessingMethods.

%

category: 'category'
method: JadeServer
addPrivilege: aString toUser: aUserProfile

	aUserProfile addPrivilege: aString.

%

category: 'category'
method: JadeServer
addProcess: aProcess to: aStream withStatus: aString scheduler: aScheduler

	| x |
	aStream lf
"1"	nextPutAll: aString; tab;
"2"	nextPutAll: aProcess asOop printString; tab;
"3"	nextPutAll: aProcess priority printString; tab;
"4"	nextPutAll: (aProcess createdByApplication ifTrue: ['Y'] ifFalse: ['']); tab; 
"5"	nextPutAll: ((x := aProcess stackId) == -1 	ifTrue: [''] ifFalse: [x printString]); tab;
"6"	nextPutAll: ((x := aProcess waitingOn) 	isNil ifTrue: [''] ifFalse: [x asOop printString]); tab;
"7"	nextPutAll: ((x := aProcess _signalTime) 	isNil ifTrue: [''] ifFalse: [(x - aScheduler _now) printString]); tab;
"8"	nextPutAll: (aProcess isPartialContinuation	ifTrue: ['partial'] ifFalse: [aProcess isContinuation ifTrue: ['full'] ifFalse: ['']]); tab;
"9"	"type: forked or main"
"10"	"live or terminated"
	yourself.

%

category: 'category'
method: JadeServer
addSessionWithId: anInteger toStream: aStream

	| array gsSession timeGmt x |
	array := System descriptionOfSession: anInteger.
	array size: 20.
	gsSession := GsSession sessionWithSerialNumber: (array at: 9).
	timeGmt := System timeGmt.
	aStream
		nextPutAll: '<session oop=';
		nextPutAll: (self oopOf: gsSession) printString printString;
		nextPutAll: ' name=';
		nextPutAll: (array at: 1) userId printString;
		nextPutAll: ' process=';
		nextPutAll: (array at: 2) printString printString;
		nextPutAll: ' host=';
		nextPutAll: (array at: 3) printString;
		nextPutAll: ' primitive=';
		nextPutAll: (array at: 4) printString printString;
		nextPutAll: ' viewAge=';
		nextPutAll: (timeGmt - (array at: 5)) printString printString;
		nextPutAll: ' state=';
		nextPutAll: (array at: 6) printString printString;
		nextPutAll: ' transaction=';
		nextPutAll: (array at: 7) printString printString;
		nextPutAll: ' hasOldestCR=';
		nextPutAll: (array at: 8) printString printString;
		nextPutAll: ' serial=';
		nextPutAll: (array at: 9) printString printString;
		nextPutAll: ' id=';
		nextPutAll: (array at: 10) printString printString;
		nextPutAll: ' ip=';
		nextPutAll: (array at: 11) printString;
		nextPutAll: ' priority=';
		nextPutAll: ((x := array at: 12) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' hostId=';
		nextPutAll: ((x := array at: 13)  isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' quietTime=';
		nextPutAll: ((x := array at: 14) isNil ifTrue: [''] ifFalse: [(timeGmt - x)  printString]) printString;
		nextPutAll: ' lifeTime=';
		nextPutAll: ((x := array at: 15) isNil ifTrue: [''] ifFalse: [(timeGmt - x)  printString]) printString;
		nextPutAll: ' backlog=';
		nextPutAll: ((x := array at: 16) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' description=';
		nextPutAll: ((x := array at: 17) isNil ifTrue: [''] ifFalse: [x]) printString;
		nextPutAll: ' objects=';
		nextPutAll: ((x := array at: 18) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' pages=';
		nextPutAll: ((x := array at: 19) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' voteState=';
		nextPutAll: ((x := array at: 20) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' />';
		yourself.

%

category: 'category'
method: JadeServer
addUser: aUserProfile toStream: aStream

	(self oopOf: aUserProfile) printOn: aStream.
	aStream tab; nextPutAll: aUserProfile userId.
	aStream tab; nextPutAll: (aUserProfile lastLoginTime asStringUsingFormat: #(1 2 3 $  2 1 $: true true true false)).
	aStream tab. aUserProfile loginsAllowedBeforeExpiration printOn: aStream.
	aStream tab. aUserProfile isDisabled printOn: aStream.
	aStream tab. aUserProfile activeUserIdLimit printOn: aStream.
	aStream tab.	"; nextPutAll: aUserProfile nativeLanguage asString."
	aStream tab. aUserProfile reasonForDisabledAccount printOn: aStream.
	aStream tab; nextPutAll: (aUserProfile lastPasswordChange asStringUsingFormat: #(1 2 3 $  2 1 $: true true true false)).
	aStream tab. aUserProfile passwordNeverExpires printOn: aStream.
	aStream lf.

%

category: 'category'
method: JadeServer
allGroups

	| allGroups myGroups stream |
	allGroups := AllGroups keys asSortedCollection.
	myGroups := (AllUsers userWithId: 'GcUser') groups.
	stream := WriteStream on: String new.
	allGroups do: [:each | 
		stream nextPutAll: each; tab.
		(myGroups includes: each) printOn: stream.
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
allSessions

	| list stream |
	stream := WriteStream on: String new.
	stream nextPutAll: '<?xml version=''1.0'' ?><sessions>'.
	list := System currentSessionNames subStrings: Character lf.
	list := list reject: [:each | each isEmpty].
	list := list collect: [:each | (each subStrings at: 3) asNumber].
	list do: [:each | 
		self
			addSessionWithId: each
			toStream: stream.
	].
	^stream 
		nextPutAll: '</sessions>';
		contents.

%

category: 'category'
method: JadeServer
allUsersPasswordLimits

	| stream |
	stream := WriteStream on: String new.
	AllUsers disallowUsedPasswords printOn: stream. stream tab.
	AllUsers minPasswordSize printOn: stream. stream tab.
	AllUsers maxPasswordSize printOn: stream. stream tab.
	AllUsers maxRepeatingChars printOn: stream. stream tab.
	AllUsers maxConsecutiveChars printOn: stream. stream tab.
	AllUsers maxCharsOfSameType printOn: stream. stream tab.
	AllUsers staleAccountAgeLimit printOn: stream. stream tab.
	AllUsers passwordAgeLimit printOn: stream. stream lf.
	AllUsers disallowedPasswords do: [:each | 
		stream nextPutAll: each; tab.
	].
	stream lf. AllUsers passwordAgeWarning printOn: stream. stream lf.
	^stream contents.

%

category: 'category'
method: JadeServer
asAsciiString: aString

	^String withAll: (aString asArray collect: [:char | 
		((32 <= char asciiValue and: [char asciiValue <= 127]) or: [char isSeparator])
			ifTrue: [char]
			ifFalse: [$?].
	]).

%

category: 'category'
method: JadeServer
assignClass: aClass toCategory: aString

	aClass thisClass category: aString.

%

category: 'category'
method: JadeServer
asString: anObject

	(anObject isKindOf: String) ifTrue: [^anObject].
	Exception
		category: nil
		number: nil
		do: [:ex :cat :num :args | 
			^'<<printString error: ' , ex printString , '>>'.
		].
	^anObject printString.

%

category: 'category'
method: JadeServer
authorInitials: aString

	| packagePolicy |
	(packagePolicy := self gsPackagePolicy) isNil ifTrue: [^self].
	packagePolicy authorInitials: aString.

%

category: 'jadeite'
method: JadeServer
autoCommitIfRequired
	| commitResult |
	RowanService autoCommit == true ifTrue:[
		commitResult := System commitTransaction.
		RowanBrowserService new autoCommit: 
			(commitResult 
				ifTrue:[true]
				ifFalse:[#failed])].
%

category: 'category'
method: JadeServer
beginTransaction

	classOrganizers := Array new: 4.
	System beginTransaction.

%

category: 'category'
method: JadeServer
behaviorFor: selector in: aClass

	| behavior |
	behavior := aClass.
	[
		behavior notNil.
	] whileTrue: [
		(behavior includesSelector: selector) ifTrue: [^behavior].
		behavior := behavior superclass.
	].
	self error: 'Method not found in class or in any superclass'.

%

category: 'category'
method: JadeServer
categoryListFor: aSymbolDictionary

	| categories stream |
	categories := Set new.
	aSymbolDictionary do: [:each | 
		each isBehavior ifTrue: [
			categories add: each category.
		].
	].
	categories copy do: [:each | 
		1 to: each size do: [:i | 
			(each at: i) = $- ifTrue: [
				| string |
				string := each copyFrom: 1 to: i - 1.
				(categories includes: string) ifFalse: [
					categories add: string.
					self _addToPureExportSet: string.
				].
			].
		].
	].
	stream := WriteStream on: String new.
	categories asSortedCollection do: [:each | 
		(self oopOf: each) printOn: stream.
		stream tab; nextPutAll: each; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
categoryOfMethod: aMethod

	| selector |
	(selector := aMethod selector) isNil ifTrue: [^''].
	^self _behavior: aMethod inClass categoryOfSelector: selector.

%

category: 'category'
method: JadeServer
class: aClass includesSelector: aSelector

	^aClass includesSelector: aSelector asSymbol.

%

category: 'category'
method: JadeServer
classesForUser: aUserProfile

	| stream |
	stream := WriteStream on: String new.
	aUserProfile symbolList do: [:eachDict |
		eachDict keysAndValuesDo: [:key :value |
			value isBehavior ifTrue: [
				stream nextPutAll: key; space; nextPutAll: value category asString; tab.
			].
		].
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
classListFor: aDictionary category: aString

	| visibleClasses allClasses stream queue |
	visibleClasses := aDictionary asArray select: [:each | 
		each isBehavior and: [aString isNil or: [
			| category |
			(category := each category) notNil and: [
			category = aString or: [
			category matchPattern: (Array with: aString with: $*)]]]]].
	allClasses := visibleClasses asIdentitySet.
	queue := visibleClasses asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| parent |
		parent := queue removeFirst superclass.
		(parent notNil and: [(allClasses includes: parent) not]) ifTrue: [
			queue add: parent.
			allClasses add: parent.
		].
	].
	stream := WriteStream on: String new.
	allClasses do: [:each |
		self
			_addClass: each 
			toStream: stream 
			isVisible: (visibleClasses includes: each)
			fromDictionary: aDictionary.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
classOrganizer

	^ClassOrganizer new

%

category: 'category'
method: JadeServer
clearBreakAtStepPoint: anInteger inMethod: aGsMethod

	aGsMethod clearBreakAtStepPoint: anInteger.

%

category: 'category'
method: JadeServer
commentFor: aClass

	| description |
	(Class canUnderstand: #'classComment') ifTrue: [
		^aClass classComment.
	].
	(description := aClass description) isNil ifTrue: [^nil].
	(description class name = #'GsClassDocumentation') ifTrue: [^description detailsAboutClass].
	^description printString.

%

category: 'category'
method: JadeServer
commit

	classOrganizers := Array new: 4.
	^System commitTransaction.

%

category: 'category'
method: JadeServer
compile: aString frame: anInteger process: aGsProcess
	"Compile method from within debugger"

	| oldMethod aBehavior selector category result |
	oldMethod := aGsProcess localMethodAt: anInteger.
	result := self recompile: oldMethod withSource: aString.
	(result isKindOf: Boolean) ifTrue: [^result].
	aBehavior := oldMethod inClass.
	selector := oldMethod selector.
	selector isNil ifTrue: [^result].
	category := self _behavior: aBehavior categoryOfSelector: selector.
	result := ((System myUserProfile resolveSymbol: #UserGlobals) value at: #rowanCompile
				ifAbsent: [false])
					ifTrue: [ 
						[ aBehavior rwCompileMethod: aString category: category ]
							on: RwExecuteClassInitializeMethodsAfterLoadNotification
							do: [:ex | ex resume: false ] ]
					ifFalse: 
						[self
							compileMethod: aString
							behavior: aBehavior
							user: nil
							inCategory: category].
	^result
%

category: 'category'
method: JadeServer
compiledMethodAt: aSymbol inClass: aClass

	^aClass compiledMethodAt: aSymbol.

%

category: 'category'
method: JadeServer
compileMethod: methodString behavior: aBehavior symbolList: aSymbolList inCategory: categorySymbol
	"Returns aGsNMethod (if successful) -> anArrayOfErrorsOrWarnings"

	| result |
	"Method is in GsFoundation, but not in GsBase"
	result := (aBehavior class canUnderstand: #'compileMethod:category:using:environmentId:') ifTrue: [
		[
			aBehavior		"returns self or signals a CompileError"
				compileMethod: methodString
				category: categorySymbol
				using: aSymbolList
				environmentId: 0.
			nil.
		] on: (self objectInBaseNamed: #'UndefinedSymbolNotification') do: [:ex | 
			ex resume: false.
		].
	] ifFalse: [(aBehavior class canUnderstand: #'compileMethod:category:using:') ifTrue: [
		[
			aBehavior		"returns self or signals a CompileError"
				compileMethod: methodString
				category: categorySymbol
				using: aSymbolList.
			nil.
		] on: (self objectInBaseNamed: #'UndefinedSymbolNotification') do: [:ex | 
			ex resume: false.
		].
	] ifFalse: [
		aBehavior		"returns nil or an Array of error descriptions"
			compileMethod: methodString
			dictionaries: aSymbolList
			category: categorySymbol.
	]].
	result notNil ifTrue: [
		^nil -> result.
	].
	(aBehavior class canUnderstand: #_primitiveCompileMethod:symbolList:category:oldLitVars:intoMethodDict:intoCategories:intoPragmas:) ifTrue: [
		result := aBehavior 
			_primitiveCompileMethod: methodString
			symbolList: aSymbolList
			category: categorySymbol
			oldLitVars: nil
			intoMethodDict: GsMethodDictionary new 
			intoCategories: GsMethodDictionary new
			intoPragmas: nil.
	] ifFalse: [
		(aBehavior class canUnderstand: #_primitiveCompileMethod:symbolList:category:obsoleteClassNames:oldLitVars:) ifTrue: [
			result := aBehavior 
				_primitiveCompileMethod: methodString
				symbolList: aSymbolList
				category: categorySymbol
				obsoleteClassNames: nil
				oldLitVars: nil.
		] ifFalse: [
			result := aBehavior 
				_primitiveCompileMethod: methodString
				symbolList: aSymbolList
				category: categorySymbol
				oldLitVars: nil
				intoMethodDict: GsMethodDictionary new 
				intoCategories: GsMethodDictionary new.
		].
	].
	(result isKindOf: Array) ifTrue: [
		"in 2.3.x: (Array with: compiledMethod with: errors with: warnings)"
		(result at: 2) notNil ifTrue: [^nil -> (result at: 2)].
		^(result at: 1) -> (result at: 3)
	].
	^result -> nil.

%

category: 'category'
method: JadeServer
compileMethod: methodString behavior: aBehavior user: aUserProfileOrNil inCategory: categoryString
	"answers a String:
		OOP of new method <TAB> selector of new method (or empty if compile failed)
		ERROR: [details] (repeat line for each error)
		[warnings] (if no errors)"

	| userProfile result gsMethod stream errDict errorList warnings |

	userProfile := aUserProfileOrNil isNil
		ifTrue: [System myUserProfile]
		ifFalse: [aUserProfileOrNil].
	result := self 		"key: GsNMethod value: ((Array withAll: errors) or aStringOfWarnings)"
		compileMethod: methodString 
		behavior: aBehavior 
		symbolList: userProfile symbolList 
		inCategory: categoryString asSymbol.
	(gsMethod := result key) isNil ifTrue: [
		errorList := result value.
		warnings := ''.
	] ifFalse: [
		errorList := #().
		warnings := result value.
	].
	stream := WriteStream on: String new.
	gsMethod notNil ifTrue: [
		stream 
			nextPutAll: gsMethod asOop printString;
			tab;
			nextPutAll: gsMethod selector;
			yourself.
	].
	errDict := GemStoneError at: System myUserProfile nativeLanguage.
	errorList do: [:each |
		stream lf; 
			nextPutAll: 'ERROR:'; tab;
			nextPutAll: (each at: 1) printString; tab;
			nextPutAll: (each at: 2) printString; tab;
			yourself.
		(each size >= 3 and: [(each at: 3) notNil]) ifTrue: [
			stream nextPutAll: (each at: 3); tab.
		] ifFalse: [
			(each at: 1) > errDict size ifTrue: [
				stream nextPutAll: '(unknown error number)'; tab.
			] ifFalse: [
				stream nextPutAll: (errDict at: (each at: 1)) asString; tab.
			].
		].
	].
	warnings isNil ifTrue: [warnings := ''].
	stream lf; nextPutAll: warnings.
	^stream contents.

%

category: 'category'
method: JadeServer
contents
	"WriteStream method to identify things that have not yet been flushed to the output. We have flushed everything!"

	^''.

%

category: 'category'
method: JadeServer
cr

	self nextPut: Character cr.

%

category: 'category'
method: JadeServer
currentUserMayEditMethod: aMethod

	^true
%

category: 'category'
method: JadeServer
debugString: aString fromContext: anObject environment: anInteger
	anInteger == 0 ifFalse: [self error: 'Only environment 0 is supported in this version!'].
	^(RowanDebuggerService new debugStringFrom: aString)
		evaluateInContext: anObject 
		symbolList: GsSession currentSession symbolList.
%

category: 'category'
method: JadeServer
debugTestNamed: testName of: testCaseClassName
	"Open a Debugger for the TestCase class named <testCaseClassName> in the test named <testName>"

	^(self objectNamed: testCaseClassName) debug: testName asSymbol
%

category: 'category'
method: JadeServer
defectiveTestsIn: aClass

	| testClass results stream |
	testClass := aClass thisClass.
	results := testClass suite run.
	stream := WriteStream on: String new.
	stream nextPutAll: results printString; lf.
	results defects asSet do: [:each | 
		| selector class |
		selector := each selector asSymbol.
		class := each class whichClassIncludesSelector: selector.
		stream nextPutAll: class name , ' debug: ' , each selector printString; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
definitionOfClass: aClass
	^aClass definition.
%

category: 'category'
method: JadeServer
definitionOfClass: aClass forUser: aUserProfile

			| stream |
			stream := WriteStream on: String new.
"1"		aClass superclass printOn: stream.
			stream 
"2"			lf; nextPutAll: (self subclassSelectorForClass: aClass);
"3"			lf; nextPutAll: aClass name;
"4"			lf; nextPutAll: (self dictionaryForClass: aClass forUser: aUserProfile);
				yourself.
"5"		stream lf. aClass instancesInvariant printOn: stream.
"6"		stream lf. aClass isModifiable printOn: stream.
"7"		stream lf. ((aClass class canUnderstand: #'instancesDbTransient') and: [aClass instancesDbTransient]) printOn: stream.
"8"		stream lf. ((aClass class canUnderstand: #'instancesNonPersistent') and: [aClass instancesNonPersistent]) printOn: stream.
			stream lf.
		aClass instVarNames do: [:each |
				stream 
"9.*.1"		nextPutAll: each; 
					space;
"9.*.2"		nextPutAll: (aClass constraintOfInstVar: each) name;
					tab.
			].
			stream lf.
			aClass class instVarNames do: [:each | 
"10.*"		stream nextPutAll: each; tab.
			].
			stream lf.
			aClass classVarNames asSortedCollection do: [:each | 
"11.*"		stream nextPutAll: each; tab.
			].
			stream lf.
			aClass sharedPools asSortedCollection do: [:each | 
"12.*"		stream nextPutAll: (self nameForSharedPool: each forUser: aUserProfile); tab.
			].
			^stream 
"13"		lf; nextPutAll: aClass userId;
"14"		lf; nextPutAll: (aClass timeStamp asStringUsingFormat: #(3 2 1 $- 1 1 $: true true false));
				lf; 
				contents.

%

category: 'category'
method: JadeServer
delay

	(Delay forMilliseconds: 10) wait.

%

category: 'category'
method: JadeServer
describeMethod: aMethod
	"Provide info needed to create a GsMethod in Jade client"

	writeStream := WriteStream on: String new.
	self _describeMethod: (self homeMethodFor: aMethod).
	^writeStream contents

%

category: 'category'
method: JadeServer
descriptionOfConfigOption: aString

	| dict key string |
	dict := self systemConfigAsDictionary.
	(string := dict at: aString ifAbsent: [nil]) notNil ifTrue: [^string].	string := aString asUppercase.
	dict keys do: [:each1 | 
		key := (each1 reject: [:each2 | each2 = $_]) asUppercase.
		key = string ifTrue: [^dict at: each1].
	].
	^''
%

category: 'category'
method: JadeServer
descriptionOfErrorNumber: anInteger

	| array stream |
	array := GemStoneError at: #'English'.
	anInteger <= 0 ifTrue: [^'Invalid number!'].
	array size < anInteger ifTrue: [^'Invalid number!'].
	stream := WriteStream on: String new.
	array := array at: anInteger.
	array isNil ifTrue: [^'No entry in GemStoneError for #' , anInteger printString , '!'].
	(array isKindOf: String) ifTrue: [array := Array with: array].
	array do: [:each | 
		(each isKindOf: Integer) ifTrue: [
			stream space; nextPut: $%.
			each printOn: stream.
		] ifFalse: [
			stream nextPutAll: each.
		].
	].
	^stream contents.

%

category: 'category'
method: JadeServer
dictionaryAndSymbolOf: aClass

	^self symbolList dictionaryAndSymbolOf: aClass.

%

category: 'category'
method: JadeServer
dictionaryAndSymbolOf: aClass forUser: aUserProfile

	^aUserProfile symbolList dictionaryAndSymbolOf: aClass.

%

category: 'category'
method: JadeServer
dictionaryForClass: aClass forUser: aUserProfile

	| anArray |
	anArray := self dictionaryAndSymbolOf: aClass forUser: aUserProfile.
	anArray isNil ifTrue: [^''].
	anArray := self dictionaryAndSymbolOf: (anArray at: 1) forUser: aUserProfile.
	anArray isNil ifTrue: [^''].
	^(anArray at: 2)

%

category: 'category'
method: JadeServer
dictionaryListFor: aUserProfile

	| symbolList list stream |
	symbolList := aUserProfile symbolList.
	list := symbolList namesReport subStrings: Character lf.
	list := list reject: [:each | each isEmpty].
	list := list collect: [:each | each subStrings].
	stream := WriteStream on: String new.
	list do: [:each | 
		(self oopOf: (symbolList at: (each at: 1) asNumber)) printOn: stream.
		stream tab; nextPutAll: (each at: 2); lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
does: newClass replace: oldClass

	^newClass name = oldClass name.

%

category: 'category'
method: JadeServer
environment
	"Ignored prior to 3.x"

	^0
%

category: 'category'
method: JadeServer
environment: anInteger
	"Ignored prior to 3.x"
%

category: 'category'
method: JadeServer
environmentForMethod: aGsNMethod

	^0
%

category: 'category'
method: JadeServer
environmentSuperClassFor: aBehavior

	^aBehavior superclass
%

category: 'category'
method: JadeServer
errorListFor: aCollection

	| stream |
	aCollection class name == #'ErrorDescription' ifTrue: [^''].
	stream := WriteStream on: String new.
	aCollection do: [:each | 
		stream
			nextPutAll: (each at: 1) printString; tab;
			nextPutAll: (each at: 2) printString; tab;
			nextPutAll: ((2 < each size and: [(each at: 3) notNil]) ifTrue: [(each at: 3)] ifFalse: [(GemStoneError at: #English) at: (each at: 1)]); tab;
			lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
executeString: aString fromContext: anObject environment: anInteger

	anInteger == 0 ifFalse: [self error: 'Only environment 0 is supported in this version!'].
	^aString
		evaluateInContext: anObject 
		symbolList: GsSession currentSession symbolList. 
%

category: 'category'
method: JadeServer
fileInClass: aString

	| list className index dictionaryName dictionary oldClass oldString |
	list := aString subStrings.
	className := list at: 3.
	className first = $' ifFalse: [self error: 'Class name ' , className printString , ' expected to begin and end with a quote!'].
	className last = $' ifFalse: [self error: 'Class name ' , className printString , ' expected to begin and end with a quote!'].
	className := className copyFrom: 2 to: className size - 1.
	index := list indexOf: 'inDictionary:'.
	dictionaryName := list at: index + 1.
	dictionary := self objectNamed: dictionaryName.
	oldClass := dictionary at: className ifAbsent: [nil].
	oldClass notNil ifTrue: [
		oldString := (oldClass _modifiableDefinitionInDictionary: dictionary named: dictionaryName) , '.'.
	].
	oldString = aString ifFalse: [aString evaluate].

%

category: 'category'
method: JadeServer
fileOutForClass: aClass

	^aClass thisClass fileOutClass.
 
%

category: 'category'
method: JadeServer
gemLogPath

	^''

%

category: 'category'
method: JadeServer
getMethodsNamesOf: classNamed
	"NO SENDERS"
	"Answer a collection with selectors of GemStone/s class name <className>"

	^(self objectNamed: classNamed) selectors asSortedCollection

%

category: 'category'
method: JadeServer
getPackagesNamesOfAll: classesNameCollection
	"NO SENDERS"
	"Answer aDictionary where each key is a class name and the value is the package that own the class"
	| classesPackages |

	classesPackages := Dictionary new.

	classesNameCollection do: [:eachClassName | | packageName |
		packageName := self getPackageNameOf: eachClassName.
		classesPackages at: eachClassName put: packageName].

	^classesPackages
%

category: 'category'
method: JadeServer
getPackagesNamesWithTestClasses
	"Answer a collection with all package names that contain at least one Test class (subclass of TestCase)"

	| comma packageOrganizer packageOrganizerClass packagesNames stream testCaseClass |
	testCaseClass := self objectInBaseNamed: #'TestCase'.
	testCaseClass isNil ifTrue: [^''].
	packageOrganizerClass := self objectInBaseNamed: #'PackageOrganizer'.
	packageOrganizerClass isNil ifTrue: [^'<All>'].
	packageOrganizer := packageOrganizerClass default.
	packagesNames := Set new.
	testCaseClass allSubclasses do: [:each | 
		| package |
		package := packageOrganizer packageOfClass: each ifNone: [nil].
		package notNil ifTrue: [packagesNames add: package packageName].
	].
	comma := ''.
	stream := WriteStream on: String new.
	packagesNames asSortedCollection do: [:each | stream nextPutAll: comma; nextPutAll: each. comma := ','].
	^stream contents
%

category: 'category'
method: JadeServer
getSubclassesNamesOf: classNamed 
	"NO SENDERS"
	"Answer a collection with all subclasses of GemStone/S class named <classNamed>"

	^((self objectNamed: classNamed) allSubclasses collect: [:each | each name]) asSortedCollection
%

category: 'category'
method: JadeServer
getTestCaseClassesNamesOf: packageName
	"Answer a collection with all test classes of the GemStone/S package named <packageNamed>"

	| classes comma stream |
	packageName isEmpty ifTrue: [^''].
	classes := (self objectInBaseNamed: #'TestCase') allSubclasses.
	packageName = '<All>' ifFalse: [
		| packageInfo packageOrganizer |
		packageOrganizer := (self objectInBaseNamed: #'PackageOrganizer') default.
		packageInfo := packageOrganizer packageNamed: packageName ifAbsent: [^''].
		packageInfo classes isEmpty ifTrue: [^''].
		classes := packageInfo classes select: [:each | classes includes: each].
	].
	stream := WriteStream on: String new.
	comma := ''.
	classes do: [:each | stream nextPutAll: comma; nextPutAll: each name. comma := ','].
	^stream contents
%

category: 'category'
method: JadeServer
getTestMethodsNamesOf: classNamed 
	"Answer a collection with all test selectors of the GemStone/S class named <classNamed>"

	| class comma stream testSelectors gsClass |
	stream := WriteStream on: String new.
	gsClass := self objectNamed: classNamed.
	gsClass isNil ifTrue: [^''].
	(class := self objectNamed: #'TestCase') isNil ifTrue: [^''].
	(gsClass isSubclassOf: class) ifFalse: [^''].
	testSelectors :=  gsClass testSelectors asSortedCollection.
	testSelectors isEmpty ifTrue: [^''].
	comma := ''.
	 testSelectors do: [:each | stream nextPutAll: comma; nextPutAll: each. comma := ','].
	^stream contents
%

category: 'category'
method: JadeServer
globalsFor: aSymbolDictionary

	| stream |
	stream := WriteStream on: String new.
	aSymbolDictionary keysAndValuesDo: [:eachKey :eachValue | 
		eachValue isBehavior ifFalse: [
			| data |
			data := (self _oopAndStringFor: eachValue) value.
			data size > 200 ifTrue: [data := data copyFrom: 1 to: 200].
			data := String withAll: (data asArray collect: [:each | (each >= Character space and: [each <= $~]) ifTrue: [each] ifFalse: [$?]]).
			stream
	"1"		nextPutAll: (self oopOf: eachValue) printString; tab;
	"2"		nextPutAll: eachKey; tab;
	"3"		nextPutAll: eachValue class name; tab;
	"4"		nextPutAll: data; tab;
				lf;
				yourself.
		].
	].
	^stream contents.

%

category: 'category'
method: JadeServer
groupListFor: aUserProfile

	| allGroups myGroups stream |
	allGroups := AllGroups keys asSortedCollection.
	myGroups := aUserProfile groups.
	stream := WriteStream on: String new.
	allGroups do: [:each | 
		stream nextPutAll: each; tab.
		(myGroups includes: each) printOn: stream.
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
gsPackagePolicy

	| class |
	class := self gsPackagePolicyClass.
	class isNil ifTrue: [^nil].
	^class current.

%

category: 'category'
method: JadeServer
gsPackagePolicyClass

	^self objectInBaseNamed: #'GsPackagePolicy'.

%

category: 'category'
method: JadeServer
historyOf: aClass

	| history |
	(history := aClass classHistory) isNil ifTrue: [
		history := Array with: aClass.
	].
	^history.

%

category: 'category'
method: JadeServer
homeMethodFor: aGsMethod

	^aGsMethod
%

category: 'category'
method: JadeServer
implementorsOf: anObject

	| symbol |
	symbol := (anObject isKindOf: String)
		ifTrue: [anObject asSymbol]
		ifFalse: [anObject selector].
	^self streamOfMethods: (self classOrganizer implementorsOf: symbol).

%

category: 'category'
method: JadeServer
implementorsOf: aGsMethod startingAt: aClass

	| selector myClass list |
	selector := aGsMethod selector.
	myClass := aClass.
	list := OrderedCollection new.
	[
		(myClass includesSelector: selector) ifTrue: [list add: myClass].
		(myClass := myClass superclass) notNil.
	] whileTrue: [].
	^self stringForClassList: list.

%

category: 'category'
method: JadeServer
initialize
	"#installTranscript is run from the Jadeite
	client post login method only. This avoids
	setting up ClientForwarder sends in a topaz
	session"

	classOrganizers := Array new: 4.
	self 
		registerOBNotifications;
		yourself.
%

category: 'category'
method: JadeServer
inspect: anObject

	| stream string |
	(stream := WriteStream on: String new)
		nextPutAll: anObject class name; tab;
		yourself.
	(self oopOf: anObject) printOn: stream.
	stream lf.
	(anObject isKindOf: Dictionary superclass) ifTrue: [^self inspectDictionary: anObject on: stream].
	self inspectNamedInstanceVariablesOf: anObject on: stream.
	anObject class format > 0 ifTrue: [
		1 to: (anObject _basicSize min: 200) do: [:i | 
			i printOn: stream.
			stream tab.
			self print: (self oopOf: (anObject _at: i)) on: stream.
			stream lf.
		].
	].
	(string := anObject printString) size > 5000 ifTrue: [string := (string copyFrom: 1 to: 5000) , '...'].
	string class == String ifFalse: [
		string := String withAll: (string collect: [:each | (32 <= each asciiValue and: [each asciiValue <= 255]) ifTrue: [each] ifFalse: [$?]]).
	].
	^stream 
		nextPutAll: string; 
		contents.
%

category: 'category'
method: JadeServer
inspectDictionary: aDictionary on: aStream

	| keys keyDict |
	keys := self keysForDictionary: aDictionary.
	keyDict := Dictionary new.
	keys do: [:each | 
		| key |
		key := each printString , '~' , (self oopOf: each) printString.
		key := key collect: [:char | char asciiValue < 32 ifTrue: [$?] ifFalse: [char]].
		keyDict
			at: key
			put: each.
	].
	keys size printOn: aStream.
	aStream lf.
	keyDict keys asSortedCollection do: [:each | 
		| index keyString key value valueString |
		index := each findLast: [:char | char = $~].
		keyString := each copyFrom: 1 to: index - 1.
		key := keyDict at: each.
		value := aDictionary at: key. 
		valueString := (self printStringOf: value to: 10).
		aStream nextPutAll: keyString , '->' , valueString; tab.
		self print: (self oopOf: value) on: aStream.
		aStream lf.
	].
	^aStream 
		lf; 
		contents.

%

category: 'category'
method: JadeServer
inspectNamedInstanceVariablesOf: anObject on: aStream

	| list size |
	list := anObject class allInstVarNames.
	size := list size.
	anObject class format > 0 ifTrue: [
		size := size + (anObject _basicSize min: 200).
	].
	size printOn: aStream.
	aStream lf.
	1 to: list size do: [:i | 
		aStream nextPutAll: (list at: i); tab.
		self print: (self oopOf: (anObject instVarAt: i)) on: aStream.
		aStream lf.
	].

%

category: 'category'
method: JadeServer
installTranscript

	| transcript |
	transcript := self objectInBaseNamed: #'Transcript'.

	"If no Transcript object, then install me!"
	(transcript == nil or: [transcript class name == self class name]) ifTrue: [
		UserGlobals at: #'Transcript' put: self.
		System commitTransaction.
		^self.
	].
	
	"Transcript object from Seaside"
	transcript class name = 'TranscriptProxy class' ifTrue: [
		| clientForwarder |
		clientForwarder := ClientForwarder new.
		clientForwarder	clientObject: 2.
		transcript registerTranscriptClientForwarder: clientForwarder.
		^self.
	].

%

category: 'category'
method: JadeServer
is32Bit

	^false.

%

category: 'category'
method: JadeServer
isClientForwarder: anObject

	^anObject _class name == #'ClientForwarder'.

%

category: 'category'
method: JadeServer
isPackagePolicyEnabled

	^self gsPackagePolicy notNil
%

category: 'category'
method: JadeServer
isResumableCategory: category number: number context: context

	| exceptionA receiver |
	category == GemStoneError ifTrue: [
		^number // 1000 = 2 or: [number // 1000 = 6].
	].
	(exceptionA := Globals at: #ExceptionA ifAbsent: [nil]) isNil ifTrue: [
		^true.
	].
	receiver := (context _frameContentsAt: 1) at: 8.
	(receiver isKindOf: exceptionA) ifTrue: [
		^receiver isResumable.
	].
	^true.

%

category: 'category'
method: JadeServer
keysForDictionary: aDictionary 

	^aDictionary keys.

%

category: 'category'
method: JadeServer
makeListener

	^nil.

%

category: 'category'
method: JadeServer
mcAddHttpRepository: aString

	| list repositoryClass repository group |
	list := aString subStrings: (Character codePoint: 255).
	(repositoryClass := self mcHttpRepositoryClass) isNil ifTrue: [self error: 'MCHttpRepository not found!'].
	repository := repositoryClass
		location: (list at: 1)
		user: (list at: 2)
		password: (list at: 3).
	(group := self mcRepositoryGroup) isNil ifTrue: [self error: 'MCRepositoryGroup not found!'].
	group addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcAddPackage: aString

	self mcWorkingCopyClass forPackage: (self mcPackageClass named: aString).

%

category: 'category'
method: JadeServer
mcAddRepository: aRepository toPackage: aMCWorkingCopy

	aMCWorkingCopy repositoryGroup addRepository: aRepository.

%

category: 'category'
method: JadeServer
mcAllFileNamesIn: anMCRepository

	| stream |
	stream := WriteStream on: String new.
	anMCRepository allFileNames do: [:each | 
		stream nextPutAll: each; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcAllVersionInfoNamesIn: anMCRepository

	| stream |
	stream := WriteStream on: String new.
	anMCRepository allVersionInfos do: [:each | 
		stream nextPutAll: each name; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcAllVersionNamesInDict: anMCRepository

	| stream list |
	stream := WriteStream on: String new.
	list := anMCRepository dictionary values.
	list := list asSortedCollection: [:a :b | 
		a package name < b package name or: [
		a package name = b package name and: [
		a info date > b info date or: [
		a info date = b info date and: [
		a info time > b info time
	]]]]].
	stream := WriteStream on: String new.
	list do: [:each | 
		stream nextPutAll: each info name; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcClassesInCategory: aString package: aMCWorkingCopy

	| visibleClasses allClasses stream queue |
	visibleClasses := aString isNil ifTrue: [
		aMCWorkingCopy packageInfo classes.
	] ifFalse: [
		aMCWorkingCopy packageInfo classes select: [:each | 
			each _classCategory notNil and: [
			each _classCategory = aString or: [
			aString notNil and: [each _classCategory matchPattern: (Array with: aString with: $*)]]]]
	].
	allClasses := visibleClasses asIdentitySet.
	queue := visibleClasses asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| parent |
		parent := queue removeFirst superclass.
		(parent notNil and: [(allClasses includes: parent) not]) ifTrue: [
			queue add: parent.
			allClasses add: parent.
		].
	].
	stream := WriteStream on: String new.
	allClasses do: [:each |
		self
			_addClass: each 
			toStream: stream 
			isVisible: (visibleClasses includes: each)
			fromDictionary: nil.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcCreationTemplateFor: anMCRepository

	^anMCRepository asCreationTemplate.

%

category: 'category'
method: JadeServer
mcHttpRepository

	^self objectInBaseNamed: #'MCHttpRepository'.

%

category: 'category'
method: JadeServer
mcHttpRepository: aRepository user: userString password: passwordString

	aRepository
		user: userString;
		password: passwordString;
		yourself.

%

category: 'category'
method: JadeServer
mcHttpRepositoryClass

	^self objectInBaseNamed: #'MCHttpRepository'.

%

category: 'category'
method: JadeServer
mcInitials: aString
	"Do initial setup and return useful information"

	| mcPlatformSupport packagePolicyEnabledFlag string x |
	string := 'Jade-' , GsSession currentSession serialNumber printString , '-' , System myUserProfile userId.
	[
		self mcInitialsA: string.
	] whileFalse: [	"Keep shortening it till it fits!"
		string := string copyFrom: 1 to: string size - 1.
	].
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	mcPlatformSupport notNil ifTrue: [mcPlatformSupport setAuthorInitials: aString].
	packagePolicyEnabledFlag := (x := self objectInBaseNamed: #'GsPackagePolicy') isNil ifTrue: ['0'] ifFalse: [x current enabled ifTrue: ['1'] ifFalse: ['0']].
	^System session printString , Character space asString , 
		(GsSession serialOfSession: System session) printString , Character space asString , 
		packagePolicyEnabledFlag

%

category: 'category'
method: JadeServer
mcInitialsA: aString
	"Subclasses provide error handling, typically means string is too long"

	System _cacheName: aString.

%

category: 'category'
method: JadeServer
mcLoadedVersionNames

	| mcWorkingCopyClass stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	stream := WriteStream on: String new.
	mcWorkingCopyClass allManagers do: [:each | 
		| packageOrVersion |
		packageOrVersion := each ancestors
			detect: [:ignored | true]
			ifNone: [each package].
		packageOrVersion := packageOrVersion notNil
			ifTrue: [packageOrVersion name]
			ifFalse: [''].
		stream
			nextPutAll: packageOrVersion; tab;
			nextPut: (each modified ifTrue: [$Y] ifFalse: [$N]); tab;
			nextPutAll: each package name;
			lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcNewDirectoryRepository: aString

	| mcRepositoryClass fileDirectoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCDirectoryRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	(fileDirectoryClass := self objectInBaseNamed: #'FileDirectory') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcNewFileTreeRepository: aString

	| mcRepositoryClass fileDirectoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCFileTreeRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	(fileDirectoryClass := self objectInBaseNamed: #'ServerFileDirectory') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcNewGitHubRepository: aString

	| mcRepositoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCGitHubRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcRepositoryClass location: aString.
	self mcRepositoryGroup addRepository: repository.
	^mcRepositoryClass
%

category: 'category'
method: JadeServer
mcNewServerDirectoryRepository: aString

	| mcDirectoryRepositoryClass fileDirectoryClass repository |
	(mcDirectoryRepositoryClass := self objectInBaseNamed: #'MCServerDirectoryRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	(fileDirectoryClass := self objectInBaseNamed: #'ServerFileDirectory') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcDirectoryRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcPackageClass

	^self objectInBaseNamed: #'MCPackage'.

%

category: 'category'
method: JadeServer
mcPatchFrom: aString1 to: aString2 inDictionaryRepository: aDictionaryRepository

	| index name leftSnapshot rightSnapshot patch |
	index := aString2 findLast: [:each | each = $-].
	name := aString2 copyFrom: 1 to: index - 1.
	(name includes: $.) ifTrue: [name := (name subStrings: $.) first].
	leftSnapshot := aString1 isNil ifTrue: [
		(self mcWorkingCopyClass allManagers detect: [:each | each package name = name]) package snapshot.
	] ifFalse: [
		(aDictionaryRepository versionFromVersionNamed: aString1) snapshot.
	].
	rightSnapshot := (aDictionaryRepository versionFromVersionNamed: aString2) snapshot.
	patch := rightSnapshot patchRelativeToBase: leftSnapshot.
	^self 
		_mcDescriptionOfPatch: patch
		baseName: aString1
		alternateName: aString2.

%

category: 'category'
method: JadeServer
mcPatchFrom: aString1 to: aString2 inFileBasedRepository: aFileRepository

	| index name leftSnapshot rightSnapshot patch |
	index := aString2 findLast: [:each | each = $-].
	name := aString2 copyFrom: 1 to: index - 1.
	(name includes: $.) ifTrue: [name := (name subStrings: $.) first].
	leftSnapshot := aString1 isNil ifTrue: [
		(self mcWorkingCopyClass allManagers detect: [:each | each package name = name]) package snapshot.
	] ifFalse: [
		(aFileRepository versionFromFileNamed: aString1) snapshot.
	].
	rightSnapshot := (aFileRepository versionFromFileNamed: aString2) snapshot.
	patch := rightSnapshot patchRelativeToBase: leftSnapshot.
	^self 
		_mcDescriptionOfPatch: patch
		baseName: aString1
		alternateName: aString2.

%

category: 'category'
method: JadeServer
mcputDefinition: aDefinition on: aStream

	| mcOrganizationDefinitionClass mcClassDefinitionClass mcMethodDefinitionClass |
	(mcOrganizationDefinitionClass := self objectInBaseNamed: 'MCOrganizationDefinition') isNil ifTrue: [^nil].
	(mcClassDefinitionClass := self objectInBaseNamed: 'MCClassDefinitionClass') isNil ifTrue: [^nil].
	(mcMethodDefinitionClass := self objectInBaseNamed: 'MCMethodDefinition') isNil ifTrue: [^nil].

	self _addToPureExportSet: aDefinition.
		aStream nextPutAll: (self oopOf: aDefinition) printString; tab;
			nextPutAll: aDefinition class name; tab.
			
		aDefinition class == mcOrganizationDefinitionClass ifTrue: [
			aDefinition categories do: [:eachCategory | 
				aStream nextPutAll: eachCategory; space]
		] ifFalse: [	aDefinition class == mcClassDefinitionClass ifTrue: [
			aStream
				nextPutAll: aDefinition className; tab;
				nextPutAll: aDefinition superclassName; tab;
				nextPutAll: aDefinition category; tab;
				nextPutAll: aDefinition type; tab;
				yourself.
		] ifFalse: [aDefinition class == mcMethodDefinitionClass ifTrue: [
			aStream
				nextPutAll: aDefinition classIsMeta printString; tab;
				nextPutAll: aDefinition category; tab;
				nextPutAll: aDefinition selector; tab;
				nextPutAll: aDefinition className; tab;
				nextPutAll: aDefinition timeStamp printString; tab]]].
	
	^aStream.
	
%

category: 'category'
method: JadeServer
mcRemovePackage: anMCWorkingCopy

	anMCWorkingCopy unregister.

%

category: 'category'
method: JadeServer
mcRemoveRepository: aRepository

	| repositoryClass group |
	(repositoryClass := self mcHttpRepositoryClass) isNil ifTrue: [self error: 'MCHttpRepository not found!'].
	(group := self mcRepositoryGroup) isNil ifTrue: [self error: 'MCRepositoryGroup not found!'].
	group removeRepository: aRepository.

%

category: 'category'
method: JadeServer
mcRemoveRepository: aRepository toPackage: aMCWorkingCopy

	aMCWorkingCopy repositoryGroup removeRepository: aRepository.

%

category: 'category'
method: JadeServer
mcRepositoryFrom: aRepository

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aRepository) printOn: stream.
	stream 
		tab;
		nextPutAll: aRepository description;
		tab;
		nextPutAll: aRepository class name;
		tab.
	^stream contents.

%

category: 'category'
method: JadeServer
mcRepositoryGroup

	| groupClass |
	(groupClass := self objectInBaseNamed: 'MCRepositoryGroup') isNil ifTrue: [^nil].
	^groupClass default.

%

category: 'category'
method: JadeServer
mcRepositoryList

	| group stream |
	(group := self mcRepositoryGroup) isNil ifTrue: [^nil].
	stream := WriteStream on: String new.
	group repositories do: [:each | 
		stream nextPutAll: (self mcRepositoryFrom: each).
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcStore: aMCWorkingCopy name: nameString message: messageString repository: aRepository 

	| version |
	version := (aMCWorkingCopy needsSaving not and: [aMCWorkingCopy currentVersionInfo name = nameString]) ifTrue: [
		(self objectInBaseNamed: #'MCVersion')
			package: aMCWorkingCopy package
			info: aMCWorkingCopy currentVersionInfo.
	] ifFalse: [
		aMCWorkingCopy
			newVersionWithName: nameString
			message: messageString.
	].
	aRepository storeVersion: version.
	(self objectInBaseNamed: #'MCCacheRepository') default storeVersion: version.

%

category: 'category'
method: JadeServer
mcTopazFrom: aString inDictionaryRepository: aDictionaryRepository

	| snapshot stream |
	snapshot := (aDictionaryRepository versionFromVersionNamed: aString) snapshot.
	stream := (WriteStream on: String new)
		nextPutAll: '! ' , aString , ' in ' , aDictionaryRepository printString; lf;
		yourself.
	self
		_mcTopazFrom: snapshot
		on: stream.
	^stream contents.


%

category: 'category'
method: JadeServer
mcTopazFrom: aString inFileRepository: aFileRepository

	| snapshot stream |
	snapshot := (aFileRepository versionFromFileNamed: aString) snapshot.
	stream := (WriteStream on: String new)
		nextPutAll: '! ' , aString , ' in ' , aFileRepository printString; lf;
		yourself.
	self
		_mcTopazFrom: snapshot
		on: stream.
	^stream contents.


%

category: 'category'
method: JadeServer
mcUniqueVersionNameFor: anMCWorkingCopy

	^anMCWorkingCopy uniqueVersionName.

%

category: 'category'
method: JadeServer
mcUserAndPasswordInHTTP: anMCHttpRepository

	^anMCHttpRepository user , Character tab asString , anMCHttpRepository password.

%

category: 'category'
method: JadeServer
mcVersionInfoFrom: aVersionInfo

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aVersionInfo) printOn: stream.
	stream 
		lf; nextPutAll: aVersionInfo name; 
		lf; nextPutAll: aVersionInfo date yyyymmdd;
		lf.
	aVersionInfo time printOn: stream.
	stream 
		lf; nextPutAll: aVersionInfo author; 
		lf; nextPutAll: aVersionInfo id asString;
		lf.
	aVersionInfo ancestors do: [:each | 
		stream nextPutAll: each name; tab.
	].
	stream lf.
	aVersionInfo stepChildren do: [:each | 
		stream nextPutAll: each name; tab.
	].
	stream lf.
	stream nextPutAll: aVersionInfo message.
	^stream contents.

%

category: 'category'
method: JadeServer
mcVersionInfoFromDictionaryPackageNamed: aString in: anMCDictionaryRepository

	| versionInfo |
	(versionInfo := anMCDictionaryRepository versionInfoFromVersionNamed: aString) isNil ifTrue: [^''].
	^self mcVersionInfoFrom: versionInfo.

%

category: 'category'
method: JadeServer
mcVersionInfoFromFileNamed: aString in: anMCFileBasedRepository

	| versionInfo |
	(versionInfo := anMCFileBasedRepository versionInfoFromFileNamed: aString) isNil ifTrue: [^''].
	^self mcVersionInfoFrom: versionInfo.

%

category: 'category'
method: JadeServer
mcVersionLoad: aString fromDictionary: anMCDictionaryRepository autoMigrate: aBoolean

	| version package workingCopy mcPlatformSupport autoMigrate |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCDictionaryRepository versionFromVersionNamed: aString.
	version load.
	package := version package.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	workingCopy repositoryGroup addRepository: anMCDictionaryRepository.
	mcPlatformSupport autoMigrate: autoMigrate.

%

category: 'category'
method: JadeServer
mcVersionLoad: aString fromFile: anMCFileBasedRepository autoMigrate: aBoolean

	| version package workingCopy mcPlatformSupport autoMigrate |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCFileBasedRepository loadVersionFromFileNamed: aString.
	version load.
	package := version package.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	workingCopy repositoryGroup addRepository: anMCFileBasedRepository.
	mcPlatformSupport autoMigrate: autoMigrate.

%

category: 'category'
method: JadeServer
mcVersionMerge: aString from: anMCFileBasedRepository autoMigrate: aBoolean

	| version mcPlatformSupport autoMigrate workingCopy |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCFileBasedRepository loadVersionFromFileNamed: aString.
	workingCopy := self mcWorkingCopyClass forPackage: version package.
	[
		[
			workingCopy merge: version.
		] on: (self objectInBaseNamed: #'MCNoChangesException') do: [:ex | 
			ex return.
		].
	] on: (self objectInBaseNamed: #'MCMergeResolutionRequest') do: [:ex | 
self halt.
		ex merger conflicts do: [:each | each chooseRemote].
		ex merger load.
		workingCopy 
			merged: version;
			modified: true;
			yourself.
		"ex resume: true."
		ex return.
	].


%

category: 'category'
method: JadeServer
mcVersionNameAndMessageFrom: aMCWorkingCopy

	(aMCWorkingCopy needsSaving or: [aMCWorkingCopy ancestors isEmpty]) ifTrue: [
		^'<new>	<new>'.
	].
	^aMCWorkingCopy currentVersionInfo name , Character tab asString , aMCWorkingCopy currentVersionInfo message.

%

category: 'category'
method: JadeServer
mcwcbWorkingCopies

	| mcWorkingCopyClass list stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	list := mcWorkingCopyClass allManagers.
	list := list asSortedCollection: [:a :b | a package name <= b package name].
	stream := WriteStream on: String new.
	list do: [:each |
		self saveWorkingCopy: each to: stream.
		stream lf].
	^stream contents
%

category: 'category'
method: JadeServer
mcWorkingCopyClass

	^self objectInBaseNamed: #'MCWorkingCopy'.

%

category: 'category'
method: JadeServer
mcWorkingCopyNamed: aString

	| mcWorkingCopyClass workingCopy stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	workingCopy := mcWorkingCopyClass allManagers 
		detect: [:each | each package name = aString]
		ifNone: [^nil].
	stream := WriteStream on: String new.
	self 
		saveWorkingCopy: workingCopy 
		to: stream.
	^stream contents.

%

category: 'category'
method: JadeServer
methodsContaining: aString

	^self streamOfMethods: (self classOrganizer substringSearch: aString) first.

%

category: 'category'
method: JadeServer
methodsFor: childClass upTo: parentClass filter: aString isVariables: aBoolean 

	| filterList answerList aClass stream selectors |
	filterList := (aString subStrings: Character tab) reject: [:each | each isEmpty].
	aBoolean ifTrue: [filterList := (filterList collect: [:each | each asSymbol]) asIdentitySet].
	aClass := childClass.
	answerList := IdentitySet new.
	selectors := IdentitySet new.
	[
		| methods |
		methods := self 
			_methodsFor: aClass
			filter: filterList
			isVariables: aBoolean.
		methods do: [:each | 
			(selectors includes: each selector) ifFalse: [
				answerList add: each.
				selectors add: each selector.
			].
		].
		aClass = parentClass.
	] whileFalse: [
		aClass := aClass superclass.
	].
	stream := WriteStream on: String new.
	answerList do: [:each | self _addMethod: each toStream: stream].
	^stream contents
%

category: 'category'
method: JadeServer
methodSignatureForSelector: aSymbol

	^aSymbol.

%

category: 'category'
method: JadeServer
millisecondsElapsedTime: aBlock

	^Time millisecondsElapsedTime: aBlock.

%

category: 'category'
method: JadeServer
moveClassesInDictionary: sourceDictionary category: aString to: destinationDictionary

	sourceDictionary copy keysAndValuesDo: [:eachKey :eachValue | 
		(eachValue isBehavior and: [eachValue category = aString]) ifTrue: [
			sourceDictionary removeKey: eachKey.
			destinationDictionary
				at: eachKey
				put: eachValue.
		].
	].

%

category: 'category'
method: JadeServer
moveDictionary: source toBefore: target forUser: aUserProfile

	| list |
	list := aUserProfile symbolList.
	list remove: source.
	target notNil ifTrue: [
		list
			add: source 
			before: target.
	] ifFalse: [
		list addLast: source.
	].


%

category: 'category'
method: JadeServer
moveMethod: aGsMethod toCategory: aString
	aGsMethod inClass
		rwMoveMethod: aGsMethod selector
		toCategory: aString.

%

category: 'category'
method: JadeServer
mySessionInfo

	| dict stream |
	stream := WriteStream on: String new.
	stream nextPutAll: self gemLogPath; cr.
	dict := System gemVersionReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	dict := System gemConfigurationReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	^stream contents
%

category: 'category'
method: JadeServer
nameForSharedPool: anObject forUser: aUserProfile

	| anArray dict sharedPoolClass |
	anArray := self dictionaryAndSymbolOf: anObject forUser: aUserProfile.
	anArray notNil ifTrue: [^anArray at: 2].
	(dict := aUserProfile objectNamed: anObject name) isNil ifTrue: [^'???'].
	(sharedPoolClass := self objectNamed: 'SharedPool') isNil ifTrue: [^'???'].
	((dict isKindOf: Class) and: [dict isSubclassOf: sharedPoolClass]) ifTrue: [^anObject name , ' _classVars'].
	^'???'.

%

category: 'category'
method: JadeServer
nameOfFirstDictionaryReferencing: aGlobal

	| list |
	list := self symbolList dictionaryAndSymbolOf: aGlobal.
	list isNil ifTrue: [^''].
	^list first name
%

category: 'category'
method: JadeServer
newUser: aString

	| userProfile stream |
	userProfile := UserProfile 
		newWithUserId: aString
		password: 'swordfish'
		privileges: #()
		inGroups: #().
	stream := WriteStream on: String new.
	self
		addUser: userProfile 
		toStream: stream.
	^stream contents.

%

category: 'category'
method: JadeServer
nextLine

	^readStream upTo: Character lf.

%

category: 'category'
method: JadeServer
nextLineAsList

	^(self nextLine subStrings: Character tab) reject: [:each | each isEmpty].

%

category: 'category'
method: JadeServer
nextPut: aCharacter

	self nextPutAll: aCharacter asString.

%

category: 'category'
method: JadeServer
nextPutAll: anObject

	| string args |
	string := self asString: anObject.
	args := Array
		with: self
		with: 1
		with: #'nextPutAll:'
		with: (Array with: string).
	System
		signal: 2336
		args: args
		signalDictionary: GemStoneError.

%

category: 'category'
method: JadeServer
obConfirmationRequest: anOBConfirmationRequest

	^String new 
		addAll: anOBConfirmationRequest cancelChoice;
		add: Character lf;
		addAll: anOBConfirmationRequest okChoice;
		add: Character lf;
		addAll: anOBConfirmationRequest prompt;
		yourself.

%

category: 'category'
method: JadeServer
obInformRequest: anOBInformRequest

	^anOBInformRequest message
%

category: 'category'
method: JadeServer
objectForOop: anInteger

	self subclassResponsibility.
%

category: 'category'
method: JadeServer
objectInBaseNamed: aString

	^[(SymbolList withAll: self class sharedPools) objectNamed: aString asSymbol] on: Error do: [:ex | ex return: nil].

%

category: 'category'
method: JadeServer
objectNamed: aString

	^System myUserProfile objectNamed: aString asSymbol.

%

category: 'category'
method: JadeServer
objectSecurityPolicyFor: anObject

	^anObject segment.

%

category: 'category'
method: JadeServer
obTextRequest: anOBTextRequest

	| prompt template |
	prompt := anOBTextRequest prompt.
	template := anOBTextRequest template.
	^String new 
		addAll: prompt size printString;
		add: Character lf;
		addAll: prompt;
		addAll: template;
		yourself.

%

category: 'category'
method: JadeServer
oopOf: anObject

	^anObject asOop.

%

category: 'category'
method: JadeServer
packagePolicy: aPackagePolicy includesSelector: aSymbol forClass: aClass

	^aPackagePolicy notNil and: [aPackagePolicy includesSelector: aSymbol for: aClass].

%

category: 'category'
method: JadeServer
postSaveClass: aGsClass activities: aString 

	| gsClass copyMethods migrateInstances recompileSubclasses removeFromClassHistory symbolList list index key oldClass newClass oldNewList stream |
	gsClass := (self historyOf: aGsClass) last.
	list := aString subStrings: Character tab.
	list := list collect: [:each | each = 'true'].
	symbolList := self symbolList.
	copyMethods := list at: 1.
	recompileSubclasses := list at: 2.
	migrateInstances := list at: 3.
	removeFromClassHistory := list at: 4.
	oldNewList := OrderedCollection new.
	stream := WriteStream on: String new.
	oldClass := (self historyOf: gsClass) asArray reverse at: 2.
	oldNewList add: oldClass -> gsClass.
	recompileSubclasses ifTrue: [
		(self classOrganizer allSubclassesOf: oldClass) do: [:each | 
			gsClass := GsSession currentSession execute: each definition.
			oldNewList add: each -> gsClass.
		].
	].
	copyMethods ifTrue: [
		oldNewList do: [:eachAssoc | 
			oldClass := eachAssoc key.
			newClass := eachAssoc value.
			index := symbolList findFirst: [:eachDict | eachDict includes: newClass].
			index = 0 ifTrue: [self error: 'Where did the class go?'].
			key := (symbolList at: index) keyAtValue: newClass.
			list := newClass copyMethodsFrom: oldClass dictionaries: symbolList.
			list do: [:eachMethod | 
				stream
					nextPutAll: 'method'; tab;
					nextPutAll: index printString; tab;
					nextPutAll: key; tab;
					nextPutAll: eachMethod selector; lf;
					yourself]]].
	migrateInstances ifTrue: [
		System commitTransaction ifFalse: [self error: 'commit failed!'].
		oldNewList do: [:eachAssoc | 
			oldClass := eachAssoc key.
			newClass := eachAssoc value.
			list := oldClass migrateInstancesTo: newClass.
			list do: [:each | 
				each notEmpty ifTrue: [
					stream
						nextPutAll: 'migrate'; tab;
						nextPutAll: newClass name; tab;
						nextPutAll: each size printString; lf;
						yourself.
				].
			].
		].
	].
	removeFromClassHistory ifTrue: [
		oldNewList do: [:eachAssoc | 
			newClass := eachAssoc value.
			((self historyOf: newClass) asArray copyFrom: 1 to: (self historyOf: newClass) size - 1) do: [:each | 
				(self historyOf: newClass) removeVersion: each.
			].
		].
	].
	^stream contents.

%

category: 'category'
method: JadeServer
print: anObject on: aStream
	"convert multi-byte strings to single-byte"

	| string |
	string := self printStringOf: anObject.
	string class == String ifFalse: [
		string := String withAll: (string collect: [:each | (32 <= each asciiValue and: [each asciiValue <= 255]) ifTrue: [each] ifFalse: [$?]]).
	].
	aStream nextPutAll: string.

%

category: 'category'
method: JadeServer
printStringOf: anObject

	^anObject printString.
%

category: 'category'
method: JadeServer
printStringOf: anObject to: anInteger

	| string |
	(string := self printStringOf: anObject) size > anInteger ifTrue: [string := (string copyFrom: 1 to: anInteger) , '...'].
	string := String withAll: (string collect: [:each | (32 <= each asciiValue and: [each asciiValue <= 255]) ifTrue: [each] ifFalse: [$?]]).
	^string.
%

category: 'category'
method: JadeServer
privilegeListFor: aUserProfile

	| allPrivileges myPrivileges stream |
	allPrivileges := (aUserProfile class instVarAt: 6) at: #'PrivilegeNames'.
	myPrivileges := aUserProfile privileges.
	stream := WriteStream on: String new.
	allPrivileges do: [:each | 
		stream nextPutAll: each; tab.
		(myPrivileges includes: each) printOn: stream.
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
processes

	| scheduler stream |
	scheduler := ProcessorScheduler scheduler.
	stream := (WriteStream on: String new)
		nextPutAll: 'highestPriority'; 			space; nextPutAll: scheduler highestPriority 			printString; tab;
		nextPutAll: 'highIOPriority'; 			space; nextPutAll: scheduler highIOPriority 			printString; tab;
		nextPutAll: 'lowestPriority'; 			space; nextPutAll: scheduler lowestPriority 				printString; tab;
		nextPutAll: 'lowIOPriority'; 				space; nextPutAll: scheduler lowIOPriority 				printString; tab;
		nextPutAll: 'systemBackgroundPriority'; 	space; nextPutAll: scheduler systemBackgroundPriority 	printString; tab;
		nextPutAll: 'timingPriority'; 			space; nextPutAll: scheduler timingPriority 			printString; tab;
		nextPutAll: 'userBackgroundPriority'; 		space; nextPutAll: scheduler userBackgroundPriority 		printString; tab;
		nextPutAll: 'userInterruptPriority'; 		space; nextPutAll: scheduler userInterruptPriority 		printString; tab;
		nextPutAll: 'userSchedulingPriority'; 		space; nextPutAll: scheduler userSchedulingPriority 		printString; tab;
		yourself.
	scheduler readyProcesses 		do: [:each | self addProcess: each to: stream withStatus: 'ready'		scheduler: scheduler].
	scheduler suspendedProcesses 	do: [:each | self addProcess: each to: stream withStatus: 'suspended'	scheduler: scheduler].
	self waitingProcesses			do: [:each | self addProcess: each to: stream withStatus: 'waiting'	scheduler: scheduler].
	^stream contents.


%

category: 'category'
method: JadeServer
referencesToObject: anObject

	^self streamOfMethods: (self classOrganizer referencesToObject: anObject).

%

category: 'category'
method: JadeServer
registerOBNotifications

	| platform clientForwarder |
	(platform := self objectInBaseNamed: #'OBGemStonePlatform') isNil ifTrue: [^self].
	clientForwarder := ClientForwarder new.
	clientForwarder	clientObject: 1.
	self
		registerOBNotificationsForPlatform: platform 
		clientForwarder: clientForwarder.

%

category: 'category'
method: JadeServer
registerOBNotificationsForPlatform: platform clientForwarder: clientForwarder

	platform 
		registerBrowseClientForwarder: clientForwarder;
		registerChoiceClientForwarder: clientForwarder;
		registerCloseClientForwarder: clientForwarder;
		registerConfirmationClientForwarder: clientForwarder;
		registerInformClientForwarder: clientForwarder;
		registerMultiLineTextClientForwarder: clientForwarder;
		registerTextClientForwarder: clientForwarder;
		yourself.

%

category: 'category'
method: JadeServer
removeCategory: aString fromBehavior: aBehavior

	aBehavior rwRemoveCategory: aString.

%

category: 'category'
method: JadeServer
removeClass: aClass from: aDictionary

	| key |
	key := aDictionary
		keyAtValue: aClass
		ifAbsent: [^false].
	aDictionary removeKey: key.
	^true.

%

category: 'category'
method: JadeServer
removeDictionary: aDictionary fromUser: aUserProfile

	| symbolList index |
	symbolList := aUserProfile symbolList.
	index := symbolList indexOf: aDictionary.
	aUserProfile removeDictionaryAt: index.

%

category: 'category'
method: JadeServer
removeGroup: aString fromUser: aUserProfile

	aUserProfile removeGroup: aString.

%

category: 'category'
method: JadeServer
removeKey: aString fromSymbolDictionary: aSymbolDictionary

	aSymbolDictionary removeKey: aString asSymbol.


%

category: 'category'
method: JadeServer
removeMethod: aGsMethod

	aGsMethod inClass removeSelector: aGsMethod selector.

%

category: 'category'
method: JadeServer
removePriorVersionsOf: aClass

	[
		1 < (self historyOf: aClass) size.
	] whileTrue: [
		(self historyOf: aClass) removeVersion: (self historyOf: aClass) first.
	].

%

category: 'category'
method: JadeServer
removePrivilege: aString fromUser: aUserProfile

	aUserProfile deletePrivilege: aString.

%

category: 'category'
method: JadeServer
renameCategory: oldString to: newString inBehavior: aBehavior

	aBehavior
		renameCategory: oldString asSymbol
		to: newString.

%

category: 'category'
method: JadeServer
reset
	"WriteStream protocol"
%

category: 'category'
method: JadeServer
runAsTest: aGsMethod

	aGsMethod inClass debug: aGsMethod selector.
	^true.

%

category: 'category'
method: JadeServer
runTestNamed: testName in: gsClass
	"The receiver run the test named <testName> of GemStone/S class named <gsClass>"
	| testResult |

	testResult := (self objectNamed: gsClass) run: testName asSymbol.

	^testResult errorCount printString, ',' ,testResult failureCount printString, ',', testResult passedCount printString
%

category: 'category'
method: JadeServer
runTestsNamed: testCollection in: gsClass
	"NO SENDERS"
	"The receiver run the all test of the collection <testCollection> of GemStone/S class named <gsClass>"
	| testResult |

	testResult := ((self objectNamed: gsClass) buildSuiteFromMethods: testCollection) run.

"	stream := WriteStream on: String new.
	testResult failures do: [:each | stream nextPutAll: ',', 'F_', each selector].
	testResult errors do: [:each | stream nextPutAll: ',', 'E_', each selector].
	testResult passed do: [:each | stream nextPutAll: ',', 'P_', each selector].

	^stream contents"

	^testResult printString
%

category: 'category'
method: JadeServer
saveWorkingCopy: wc to: stream

	self _addToPureExportSet: wc.
	stream
		nextPutAll: (self oopOf: wc) printString; tab;
		nextPutAll: wc package name; tab;
		nextPutAll: wc modified printString; tab;
		nextPutAll: wc ancestors size printString; tab;
		yourself.
	wc ancestors do: [:ancestor |
		self _addToPureExportSet: ancestor.
		(self oopOf: ancestor) printOn: stream.
		stream tab.
	].
	stream nextPutAll: wc repositoryGroup repositories size printString; tab.
	wc repositoryGroup repositories do: [:repository |
		self _addToPureExportSet: repository.
		(self oopOf: repository) printOn: stream.
		stream tab.
	].

%

category: 'category'
method: JadeServer
sbAddDictionary: anOrderedCollection

	| currentName newName symbolList index |
	symbolList := self symbolList.
	newName := anOrderedCollection removeFirst.
	anOrderedCollection notEmpty ifTrue: [
		currentName := anOrderedCollection removeFirst asSymbol.
		index := symbolList findFirst: [:each | each name = currentName].
	] ifFalse: [
		index := symbolList size + 1.
	].
	symbolList
		createDictionaryNamed: newName
		at: index.
	selections at: #'dictionary' put: newName.
	self systemBrowserUpdate.
%

category: 'category'
method: JadeServer
sbAddMethodCategory: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) addCategory: anOrderedCollection first.
	selections at: #'methodCategory' put: anOrderedCollection first.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbAddMissingAccessors: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) compileMissingAccessingMethods.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbAddNameOf: aClass

	writeStream nextPutAll: aClass name.
	1 < (self historyOf: aClass) size ifTrue: [
		writeStream nextPutAll: ' ('.
		((self historyOf: aClass) indexOf: aClass) printOn: writeStream.
		writeStream nextPut: $/.
		(self historyOf: aClass) size printOn: writeStream.
		writeStream nextPut: $).
	].
	writeStream tab.

%

category: 'category'
method: JadeServer
sbAddPackage: anOrderedCollection
	| string service |
	string := anOrderedCollection removeFirst.
	selections at: #package put: string.
	service := Rowan packageServiceClass forPackageNamed: string.
	service createPackage.
	self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbAddRepository: list

	| description repository packages |
	description := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = description].
	packages := self mcWorkingCopyClass allManagers select: [:each | list includes: each package name].
	packages do: [:each | each repositoryGroup addRepository: repository].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbBreak: anOrderedCollection

	| myClass gsMethod stepPoint |
	myClass := self sbClassFrom: anOrderedCollection.
	gsMethod := self compiledMethodAt: anOrderedCollection removeFirst asSymbol inClass: myClass.
	stepPoint := anOrderedCollection removeFirst asNumber.
	anOrderedCollection removeFirst = 'set' ifTrue: [
		gsMethod setBreakAtStepPoint: stepPoint.
	] ifFalse: [
		gsMethod clearBreakAtStepPoint: stepPoint.
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbBrowseClassReferences: anOrderedCollection

	| class |
	class := (self sbClassFrom: anOrderedCollection) thisClass.
	writeStream 
		nextPutAll: 'browseClassReferences'; lf;
		nextPutAll: (self referencesToObject: class); 
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseGlobalReferences: anOrderedCollection

	| global |
	global := self objectForOop: anOrderedCollection removeFirst asNumber.
	writeStream 
		nextPutAll: 'browseGlobalReferences'; lf;
		nextPutAll: (self referencesToObject: global); 
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseImplementors: anOrderedCollection

	writeStream 
		nextPutAll: 'browseImplementors'; lf;
		nextPutAll: (self implementorsOf: anOrderedCollection removeFirst);
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseMethodHistory: anOrderedCollection

	| behavior selector historyClass historyList |
	historyClass := self objectInBaseNamed: #'MethodVersionHistory'.
	historyClass isNil ifTrue: [^self].
	behavior := self sbClassFrom: anOrderedCollection.
	selector := anOrderedCollection removeFirst asSymbol.
	historyList := historyClass uniqueInstance 
		versionsOfMethod: selector 
		in: behavior.
	writeStream nextPutAll: 'browseMethodHistory'; nextPut: Character lf.
	historyList do: [:each | " behavior selector changeStamp category source"
		writeStream
			nextPutAll: each category; tab;
			nextPutAll: each changeStamp; tab;
			nextPutAll: each source;
			nextPut: Character lf;
			nextPut: $%;
			nextPut: Character lf;
			yourself.
	].

%

category: 'category'
method: JadeServer
sbBrowseMethodsContaining: anOrderedCollection

	writeStream 
		nextPutAll: 'browseMethodsContaining'; lf;
		nextPutAll: (self methodsContaining: anOrderedCollection removeFirst);
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseMethodsWithPragma: anOrderedCollection

	writeStream 
		nextPutAll: 'browseMethodsWithPragma'; lf;
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseSenders: anOrderedCollection

	writeStream 
		nextPutAll: 'browseSenders'; lf;
		nextPutAll: (self sendersOf: anOrderedCollection removeFirst);
		yourself.

%

category: 'category'
method: JadeServer
sbChangeClassName: aList

	| oldName class newName changedIn |
	oldName := aList removeFirst asSymbol.
	class := self objectForOop: aList removeFirst asNumber.
	class name == oldName ifFalse: [self error: 'Current name is ' , class name printString].
	newName := aList removeFirst asSymbol.
	class changeNameTo: newName.
	changedIn := OrderedCollection new.
	self symbolList do: [:each | 
		(each includes: class) ifTrue: [
			(each at: oldName ifAbsent: [nil]) == class ifFalse: [self error: 'Class not at name!'].
			(each includesKey: newName) ifTrue: [self error: 'Key already in use!'].
			each
				removeKey: oldName;
				at: newName put: class;
				yourself.
			changedIn add: each.
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbChangesInPackage: anOrderedCollection
	"where anOrderedCollection is {packageName, projectName}"

	| patch string packageName url |
	packageName := anOrderedCollection removeFirst.
	url := anOrderedCollection removeFirst.
	patch := Rowan packageTools diff patchForPackageName: packageName.
	string := self
				_mcDescriptionOfPatch: patch
				baseName: 'closest ancestor'
				alternateName: nil.
	writeStream
		nextPutAll: 'changesInPackage';
		lf;
		nextPutAll: string;
		yourself

%

category: 'category'
method: JadeServer
sbCheckUniqueClassName: aList

	| oldName class newName |
	oldName := aList removeFirst asSymbol.
	class := self objectForOop: aList removeFirst asNumber.
	class name == oldName ifFalse: [
		writeStream nextPutAll: 'Current name is ' , class name printString. 
		^self.
	].
	newName := aList removeFirst asSymbol.
	self symbolList do: [:each | 
		((each includes: class) and: [each includesKey: newName]) ifTrue: [
			writeStream nextPutAll: 'Dictionary '.
			each name printOn: writeStream.
			writeStream nextPutAll: ' already has a global with name '.
			newName printOn: writeStream.
			^self.
		].
	].
	
%

category: 'category'
method: JadeServer
sbClass: aList

	| string newClass mcWorkingCopyClass packages dictName |
	string := aList first.
	newClass := string evaluate.
	self classOrganizer update.
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [
		packages := Array with: nil.
	] ifFalse: [
		packages := mcWorkingCopyClass allManagers collect: [:each | each package name].
		packages := packages select: [:each | (newClass category copyFrom: 1 to: (newClass category size min: each size)) = each].
		packages isEmpty ifTrue: [
			packages := Array with: nil.
		].
	].
	dictName := (newClass class canUnderstand: #'symbolDictionaryName')
		ifTrue: [newClass symbolDictionaryName]
		ifFalse: [
			| array |
			array := self dictionaryAndSymbolOf: newClass.
			array isNil
				ifTrue: ['UserGlobals']
				ifFalse: [array first name]].
	selections 
		at: #'package' 		put: packages first;
		at: #'dictionary' 		put: dictName asString;
		at: #'category' 		put: newClass category;
		at: #'className'	put: newClass name;
		at: #'class'				put: newClass;
		yourself.
	selectedClass := newClass.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbClassCategory: aList

	| category classes |
	category := aList removeFirst.
	category := category copyFrom: 1 to: category size - 1.
	classes := aList removeFirst subStrings reject: [:each | each isEmpty].
	classes := classes collect: [:each | self objectNamed: each asSymbol].
	classes := classes collect: [:each | each thisClass].
	classes do: [:each | each category: category].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbClassComment: anOrderedCollection

	| class doc txt |
	class := (self sbClassFrom: anOrderedCollection) thisClass.
	doc := (self objectInBaseNamed: #'GsClassDocumentation') newForClass: self.
	txt := (self objectInBaseNamed: #'GsDocText') new details: self sbNextParagraph trimSeparators.
	doc documentClassWith: txt.
	class rwComment: doc.
	self systemBrowserUpdate.
%

category: 'category'
method: JadeServer
sbClassesToDictionary: anOrderedCollection

	| action targetName target sourceNames sources classNames |
	action := anOrderedCollection removeFirst.
	targetName := anOrderedCollection removeFirst asSymbol.
	target := self symbolList detect: [:each | each name = targetName].
	sourceNames := self nextLineAsList collect: [:each | each asSymbol].
	sources := sourceNames collect: [:eachName | self symbolList detect: [:eachDictionary | eachDictionary name = eachName]].
	classNames := self nextLineAsList collect: [:each | each asSymbol].
	classNames do: [:eachName | 
		| source class |
		source := sources detect: [:eachDict | 
			class := eachDict detect: [:eachGlobal | eachGlobal isBehavior and: [eachGlobal name = eachName]] ifNone: [nil].
			class notNil.
		].
		target at: class name put: class.
		action = 'move' ifTrue: [source removeKey: class name].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbClassFrom: anOrderedCollection

	| selectedClassName selectedClassOop set myClass |
	selectedClassName := (anOrderedCollection removeFirst subStrings: Character space) first.
	selectedClassOop := anOrderedCollection removeFirst asNumber.
	set := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal |
			eachGlobal isBehavior ifTrue: [
				set addAll: (self historyOf: eachGlobal).
			].
		].
	].
	myClass := set detect: [:each | (self oopOf: each) = selectedClassOop].
	myClass name asString = selectedClassName ifFalse: [self error: 'Class not found!'].
	anOrderedCollection removeFirst = 'classTab' ifTrue: [myClass := myClass class].
	^myClass.

%

category: 'category'
method: JadeServer
sbClassTemplate
	| def service classInfoUpdate |
	service := Rowan classServiceClass forClassNamed: 'Object'.
	def := service classCreationTemplate.
	classInfoUpdate := RowanClassInfoUpdate new.
	classInfoUpdate 
		oop: 0;
		template: def.
	classInfoUpdate writeInfoOn: writeStream

%

category: 'category'
method: JadeServer
sbComparePackages: anOrderedCollection

	| current ancestor repository patch string |
	current := self mcWorkingCopyClass forPackage: (self mcPackageClass named: anOrderedCollection removeFirst).
	ancestor := anOrderedCollection removeFirst.
	repository := anOrderedCollection removeFirst.
	repository := current repositoryGroup repositories detect: [:each | each description = repository].
	ancestor := repository class name = #'MCDictionaryRepository'
		ifTrue: [repository versionFromVersionNamed: ancestor]
		ifFalse: [repository versionFromFileNamed: ancestor , '.mcz'].
	patch := current package snapshot patchRelativeToBase: ancestor snapshot.
	string := self 
		_mcDescriptionOfPatch: patch
		baseName: ancestor info name
		alternateName: nil.
	writeStream 
		nextPutAll: 'comparePackages'; lf;
		nextPutAll: string;
		yourself.

%

category: 'category'
method: JadeServer
sbCopyMethodsFor: newClass

	| history oldClass symbolList |
	newClass isMeta ifFalse: [self sbCopyMethodsFor: newClass class].
	history := self historyOf: newClass thisClass.
	oldClass := history at: history size - 1.
	newClass isMeta ifTrue: [oldClass := oldClass class].
	symbolList := self symbolList.
	oldClass selectors do: [:each | 
		| source category errors |
		source := (self compiledMethodAt: each inClass: oldClass) sourceString.
		category := self _behavior: oldClass categoryOfSelector: each.
		errors := newClass 
			compileMethod: source
			dictionaries: symbolList
			category: category.
		errors notNil ifTrue: [
			writeStream
				nextPutAll: 'compileError'; lf;
				nextPutAll: newClass name; tab;
				nextPutAll: category; lf;
				nextPutAll: source; lf;
				nextPut: $%; lf;
				yourself.
			newClass removeSelector: each ifAbsent: [].
		].
	].

%

category: 'category'
method: JadeServer
sbFileOutClass: anOrderedCollection

	writeStream nextPutAll: (self sbClassFrom: anOrderedCollection) thisClass fileOutClass.

%

category: 'category'
method: JadeServer
sbFileOutDictionary: anOrderedCollection

	| dictionary |
	dictionary := self objectNamed: anOrderedCollection first.
	writeStream nextPutAll: '! ------- Create dictionary if it is not present
run
| aSymbol names userProfile |
aSymbol := ' , dictionary name printString , '.
userProfile := System myUserProfile.
names := userProfile symbolList names.
(names includes: aSymbol) ifFalse: [
	| symbolDictionary |
	symbolDictionary := SymbolDictionary new name: aSymbol; yourself.
	userProfile insertDictionary: symbolDictionary at: names size + 1.
].
' , '%
'.
	self classOrganizer
		fileOutClassesAndMethodsInDictionary: dictionary
		on: writeStream.

%

category: 'category'
method: JadeServer
sbFileOutMethod: anOrderedCollection

	| aClass |
	aClass := (self sbClassFrom: anOrderedCollection) thisClass.
	writeStream nextPutAll: aClass fileOutMethod: anOrderedCollection removeFirst.

%

category: 'category'
method: JadeServer
sbFindClass

	| classToPackageMap |
	classToPackageMap := self sbFindClassPackageMap.
	self symbolList do: [:eachDict | 
		| name |
		name := eachDict name.
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				| category |
				category := eachGlobal category.
				category isNil ifTrue: [category := ''].
"1"			self sbAddNameOf: eachGlobal.
				writeStream
"2"				nextPutAll: name; tab;
"3"				nextPutAll: category; tab;		"Class category"
"4"				nextPutAll: (classToPackageMap at: eachGlobal ifAbsent: ['']); tab;		"Package name if available"
					lf.
			].
		].
	].

%

category: 'category'
method: JadeServer
sbFindClassPackageMap

	| systemOrganizerClass mcWorkingCopyClass dictionary packageInfoList |
	dictionary := Dictionary new.
	(systemOrganizerClass := self objectInBaseNamed: #'SystemOrganizer') isNil ifTrue: [^dictionary].
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^dictionary].
	packageInfoList := mcWorkingCopyClass allManagers collect: [:each | each packageInfo].
	systemOrganizerClass new categoryDict keysAndValuesDo: [:catName :classes |
		| symbol packageInfo |
		symbol := catName asSymbol.
		packageInfo := packageInfoList detect: [:each | each includesSystemCategory: symbol] ifNone: [nil].
		packageInfo notNil ifTrue: [
			| name |
			name := packageInfo name.
			classes do: [:each | dictionary at: each put: name].
		].
	].
	^dictionary.

%

category: 'category'
method: JadeServer
sbFindSelectors: anOrderedCollection

	| allSymbols pattern |
	pattern := (anOrderedCollection collect: [:each | each = '*' ifTrue: [$*] ifFalse: [each]]) asArray.
	allSymbols := ((AllUsers userWithId: #SymbolUser ifAbsent: [AllUsers userWithId: #DataCurator]) resolveSymbol: #AllSymbols) value.
	allSymbols := allSymbols select: [:each |each asUppercase matchPattern: pattern].
	allSymbols := allSymbols select: [:each | (self classOrganizer implementorsOf: each) notEmpty].
	allSymbols := allSymbols asSortedCollection.
	allSymbols do: [:each | writeStream nextPutAll: each; nextPut: Character lf; yourself].

%

category: 'category'
method: JadeServer
sbInstVarsOldParent: oldParent newParent: newParent oldChild: oldChild

	| added removed newList used missing |
	added := newParent allInstVarNames asIdentitySet - oldParent allInstVarNames asIdentitySet.
	removed := oldParent allInstVarNames asIdentitySet - newParent allInstVarNames asIdentitySet.
	newList := oldChild instVarNames.
	used := IdentitySet new.
	(oldChild class canUnderstand: #'_methodDict') ifTrue: [
		oldChild _methodDict do: [:each | used addAll: each instVarsAccessed].
	].
	(oldChild class canUnderstand: #'persistentMethodDictsDo:') ifTrue: [
		oldChild persistentMethodDictsDo: [:eachDict | 
			eachDict do: [:eachMethod | 
				used addAll: eachMethod instVarsAccessed.
			].
		].
	].
	used := used * removed.	"Only interested in things that have been removed."
	missing := (used - newList asIdentitySet) asSortedCollection asArray.
	newList := newList , missing.
	newList := newList reject: [:each | added includes: each].
	^newList.

%

category: 'category'
method: JadeServer
sbListMethodPragmas
	"none before 3x"

%

category: 'category'
method: JadeServer
sbLoadLatestVersionOfConfiguration: anOrderedCollection

	anOrderedCollection do: [:each | 
		(self objectNamed: each) project latestVersion load.
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbMethodCategory: anOrderedCollection
	| behavior category |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection removeFirst.
	anOrderedCollection do: [:each | behavior rwMoveMethod: each asSymbol toCategory: category].
	self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbMethodClass: anOrderedCollection
	"Drag/drop method onto class"

	| sourceBehavior action targetName set target |
	sourceBehavior := self sbClassFrom: anOrderedCollection.
	action := anOrderedCollection removeFirst.
	targetName := anOrderedCollection removeFirst asSymbol.
	set := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			(eachGlobal isBehavior and: [eachGlobal name = targetName]) ifTrue: [set add: eachGlobal].
		].
	].
	1 < set size ifTrue: [self error: 'Target name is ambiguous!'].
	1 = set size ifFalse: [self error: 'Target not found!'].
	target := set asArray first.
	sourceBehavior isMeta ifTrue: [target := target class].
	anOrderedCollection do: [:each | 
		| gsMethod result |
		gsMethod := self compiledMethodAt: each asSymbol inClass: sourceBehavior.
		result := self		"key: GsNMethod value: (Array withAll: errors and warnings)"
				compileMethod: gsMethod sourceString
				behavior: target
				symbolList: self symbolList 
				inCategory: (self _behavior: sourceBehavior categoryOfSelector: gsMethod selector).
		(result key notNil and: [action = 'move']) ifTrue: [
			sourceBehavior removeSelector: gsMethod selector.
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbMigrateAll: aClass

	| mcPlatformSupport classes instances |
	((mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport') notNil and: [mcPlatformSupport autoMigrate]) ifTrue: [^self].
	System commitTransaction ifFalse: [self error: 'commit failed!'].
	classes := (ClassOrganizer new allSubclassesOf: aClass) 
		inject: (IdentitySet withAll: (self historyOf: aClass))
		into: [:set :each | set addAll: (self historyOf: each); yourself].
	classes := classes asArray.
	instances := (self objectInBaseNamed: #'SystemRepository') listInstances: classes.
	1 to: classes size do: [:i | 
		| class |
		class := classes at: i.
		class 
			migrateInstances: (instances at: i) 
			to: (self historyOf: class) last.
		System commitTransaction ifFalse: [self error: 'commit failed!'].
	].

%

category: 'category'
method: JadeServer
sbNextParagraph

	| stream |
	stream := WriteStream on: String new.
	[
		readStream peek = $%.
	] whileFalse: [
		stream nextPutAll: self nextLine; lf.
	].
	self nextLine.
	^stream contents.

%

category: 'category'
method: JadeServer
sbObjectLog: anOrderedCollection

	| command priorities class log debuggerLogEntryClass | 
	(class := self objectInBaseNamed: #'ObjectLogEntry') isNil ifTrue: [^self].
	debuggerLogEntryClass := self objectInBaseNamed: #'DebuggerLogEntry'.
	(command := anOrderedCollection removeFirst) = 'delete' ifTrue: [
		anOrderedCollection do: [:each | 			| oop entry |
			oop := each asNumber.			entry := class objectLog detect: [:each2 | (self oopOf: each2) = oop] ifNone: [nil].			entry notNil ifTrue: [class objectLog remove: entry].
		].
		^self systemBrowserCommand.
	].
	writeStream nextPutAll: 'objectLog'; lf.
	priorities := anOrderedCollection removeFirst asArray collect: [:each | each asString asNumber].
	log := class objectLog select: [:each | priorities includes: each priority].
	log reverseDo: [:each | 
		| labelString objectString |
		objectString := String withAll: (each objectString asArray collect: [:char | 
			char asciiValue < 32 ifTrue: [Character space] ifFalse: [
			127 < char asciiValue ifTrue: [$?] ifFalse: [char]]]).
		500 < objectString size ifTrue: [objectString := (objectString copyFrom: 1 to: 500) , '...'].
		each label = each object printString ifTrue: [
			labelString := ''.
		] ifFalse: [
			labelString := String withAll: (each labelString asArray collect: [:char | 
				char asciiValue < 32 ifTrue: [Character space] ifFalse: [
				127 < char asciiValue ifTrue: [$?] ifFalse: [char]]]).
			500 < labelString size ifTrue: [labelString := (labelString copyFrom: 1 to: 500) , '...'].
		].
"1"	(self oopOf: each) printOn: writeStream.
"2"	writeStream tab; nextPutAll: each class name; tab.
"3"	each pid printOn: writeStream. 
		writeStream tab.
"4"	each stamp rounded printOn: writeStream.
"5"	writeStream tab; nextPutAll: labelString; tab.
"6"	each priority printOn: writeStream.
		writeStream tab.
"7"	each tag printOn: writeStream.
"8"	writeStream tab; nextPutAll: objectString; tab.
		(debuggerLogEntryClass notNil and: [each isKindOf: debuggerLogEntryClass]) ifTrue: [
"9"		(self oopOf: each continuation) printOn: writeStream.
		] ifFalse: [
			writeStream nextPutAll: '0'.
		].
		writeStream lf.
	].

%

category: 'category'
method: JadeServer
sbPostSaveClass: anOrderedCollection
	"this has been Rowanized"

	self systemBrowserUpdate 
%

category: 'category'
method: JadeServer
sbReadMethodFilter

	| pieces |
	pieces := self nextLine subStrings: Character tab.
	methodFilterType := pieces at: 1.
	methodCommandResult type: methodFilterType.
	methodCommandResult writeTypeTo: writeStream

%

category: 'category'
method: JadeServer
sbRecompileSubclassesOf: newClass andCopyMethods: aBoolean

	| history oldClass symbolList list |
	history := self historyOf: newClass thisClass.
	oldClass := history at: history size - 1.
	symbolList := self symbolList.
	list := self classOrganizer subclassesOf: oldClass.
	list do: [:oldSubclass |
		| instVars classInstVars definition string newSubclass i j |
		instVars := self sbInstVarsOldParent: oldClass newParent: newClass oldChild: oldSubclass.
		classInstVars := self sbInstVarsOldParent: oldClass class newParent: newClass class oldChild: oldSubclass class.

		definition := oldSubclass definition.
		0 < (i := definition findString: 'instVarNames:' startingAt: 1) ifTrue: [
			j := definition indexOf: Character lf startingAt: i.
			string := String withAll: 'instVarNames: #('.
			instVars do: [:each | string addAll: each; add: Character space].
			string add: $).
			definition := (definition copyFrom: 1 to: i - 1) , string , (definition copyFrom: j to: definition size).
		].
		0 < (i := definition findString: 'classInstVars:' startingAt: 1) ifTrue: [
			j := definition indexOf: Character lf startingAt: i.
			string := String withAll: 'classInstVars: #('.
			classInstVars do: [:each | string addAll: each; add: Character space].
			string add: $).
			definition := (definition copyFrom: 1 to: i - 1) , string , (definition copyFrom: j to: definition size).
		].
		newSubclass := definition evaluate.
		aBoolean ifTrue: [self sbCopyMethodsFor: newSubclass].
		self classOrganizer update.
	].

%

category: 'category'
method: JadeServer
sbRemoveClasses
	| containers classNames |
	self nextLine = 'packageList'. "ignore this" 
	containers := self nextLineAsList.
	classNames := (self nextLineAsList reject: [:each | each isEmpty])
				collect: [:each | (each subStrings: Character space) first asSymbol].
	containers do: 
			[:packageName |
			classNames
				do: [:className | (Rowan packageServiceClass forPackageNamed: packageName) removeClassNamed: className]].
	^self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbRemoveDictionaries: anOrderedCollection

	anOrderedCollection do: [:each | 
		self symbolList removeDictionaryNamed: each asSymbol.
	].
	self systemBrowserUpdate.
%

category: 'category'
method: JadeServer
sbRemoveGlobals

	| symbolList dictionaries globals |
	symbolList := self symbolList.
	dictionaries := self nextLineAsList collect: [:each | each asSymbol].
	dictionaries := dictionaries collect: [:eachName | symbolList detect: [:eachDict | eachDict name = eachName]].
	globals := self nextLineAsList collect: [:each | each asSymbol].
	dictionaries do: [:eachDict | 
		globals do: [:eachKey | 
			eachDict removeKey: eachKey ifAbsent: [].
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRemoveHistory: aClass

	(ClassOrganizer new allSubclassesOf: aClass) asArray , (Array with: aClass) do: [:eachNewClass | 
		(self historyOf: eachNewClass) asArray do: [:eachClass | 
			eachClass ~~ eachNewClass ifTrue: [
				(self historyOf: eachNewClass) removeVersion: eachClass.
			].
		].
	].

%

category: 'category'
method: JadeServer
sbRemoveKey: aSymbol fromDictionary: aDictionary

	aDictionary removeKey: aSymbol.

%

category: 'category'
method: JadeServer
sbRemoveMethodCategories: anOrderedCollection

	| behavior |
	behavior := self sbClassFrom: anOrderedCollection.
	anOrderedCollection do: [:each | behavior rwRemoveCategory: each].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRemoveMethods: anOrderedCollection
	| behavior classEntity  notRemoved|
	behavior := self sbClassFrom: anOrderedCollection.
	classEntity := ((System myUserProfile resolveSymbol: #UserGlobals) value at: #rowanCompile
				ifAbsent: [false])
					ifTrue: [Rowan classServiceClass forClassNamed: behavior name meta: behavior isMeta]
					ifFalse: [behavior].
	notRemoved := Array new. 
	anOrderedCollection do: [:each | classEntity removeSelector: each asSymbol ifAbsent: [notRemoved add: each]].
	self systemBrowserUpdate.
	notRemoved isEmpty ifFalse:[self error: 'The following selectors were not removed. Possibly in a superclass? ', notRemoved printString].
%

category: 'category'
method: JadeServer
sbRemovePriorVersions

	| isPackages containers classNames |
	isPackages := self nextLine = 'packageList'.
	containers := self nextLineAsList.
	classNames := (self nextLineAsList reject: [:each | each isEmpty]) collect: [:each | (each subStrings: Character space) first asSymbol].
	self symbolList do: [:eachDictionary | 
		| dictionaryName |
		dictionaryName := eachDictionary name asString.
		classNames do: [:eachName |
			| class flag |
			(class := eachDictionary at: eachName ifAbsent: [nil]) notNil ifTrue: [
				isPackages ifTrue: [
					flag := false.
					containers do: [:each | flag := flag or: [(class category copyFrom: 1 to: (class category size min: each size)) = each]].
				] ifFalse: [
					flag := containers includes: dictionaryName.
				].
				flag ifTrue: [
					| classHistory |
					classHistory := self historyOf: class.
					classHistory size - 1 timesRepeat: [
						classHistory removeVersion: classHistory first.
					].
				].
			].
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRemoveRepository: list

	| description repository packages |
	description := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = description].
	packages := self mcWorkingCopyClass allManagers select: [:each | list includes: each package name].
	packages do: [:each | each repositoryGroup removeRepository: repository].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRevertClass

	| isPackages container className |
	isPackages := self nextLine = 'packageList'.
	container := self nextLine trimSeparators.
	className := self nextLine trimSeparators.
	self symbolList do: [:eachDictionary | 
		| dictionaryName class flag |
		dictionaryName := eachDictionary name asString.
		(class := eachDictionary at: className ifAbsent: [nil]) notNil ifTrue: [
			isPackages ifTrue: [
				flag := (class category copyFrom: 1 to: (class category size min: container size)) = container.
			] ifFalse: [
				flag := container = dictionaryName.
			].
			flag ifTrue: [
				| history |
				history := class classHistory.
				(class == history last and: [1 < history size]) ifFalse: [self error: 'Unexpected class history!'].
				history removeVersion: class.
				class := history last.
				eachDictionary at: class name put: class.
			].
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRunClassTests: aString

	| behavior |
	behavior := self sbClassFrom: (aString subStrings: Character tab).
	^self defectiveTestsIn: behavior.

%

category: 'category'
method: JadeServer
sbRunMethodTests: aString

	| list class |
	list := aString subStrings: Character tab.
	class := (self sbClassFrom: list) thisClass.
	list do: [:each | class debug: each asSymbol].
	^true.

%

category: 'category'
method: JadeServer
sbSaveMethod: anOrderedCollection
	"Save in method editor"

	| behavior category string association gsMethod |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection notEmpty ifTrue: [anOrderedCollection removeFirst] ifFalse: ['other'].
	string := self sbNextParagraph.
	association := self		"key: GsNMethod value: (Array withAll: errors and warnings)"
		compileMethod: string 
		behavior: behavior 
		symbolList: self symbolList 
		inCategory: category asSymbol.
	(gsMethod := association key) isNil ifTrue: [
		System
			signal: 1001 
			args: (Array with: association value)
			signalDictionary: GemStoneError.
	].
	selections 
		at: #'methodCategory' 	put: (self _behavior: gsMethod inClass categoryOfSelector: gsMethod selector) asString;
		at: #'method'					put: gsMethod selector asString;
		at: #'methodWarnings'	put: association value;
		yourself.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbSavePackage: list

	| packageName package repositoryDescription repository versionName httpUser httpPassword comment |
	packageName := list removeFirst.
	package := self mcWorkingCopyClass allManagers detect: [:each | each package name = packageName].
	repositoryDescription := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = repositoryDescription].
	versionName := list removeFirst.
	list notEmpty ifTrue: [httpUser := list removeFirst].
	list notEmpty ifTrue: [httpPassword := list removeFirst].
	comment := self sbNextParagraph.
	[
		comment notEmpty and: [comment last asciiValue <= 32].
	] whileTrue: [
		comment := comment copyFrom: 1 to: comment size - 1.
	].
	(repository class name = #'MCHttpRepository') ifTrue: [
		repository
			user: httpUser;
			password: httpPassword;
			yourself.
	].
	self 
		mcStore: package 
		name: versionName 
		message: comment 
		repository: repository.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbSetHomeDictionary: list

	| name dictionary packagePolicy |
	name := list removeFirst asSymbol.
	dictionary := self symbolList detect: [:each | each name = name].
	(packagePolicy := self gsPackagePolicy) notNil ifTrue: [
		packagePolicy homeSymbolDict: dictionary.
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbUniqueVersionName: aList

	| packageName package |
	packageName := aList removeFirst.
	package := self mcWorkingCopyClass allManagers detect: [:each | each package name = packageName].
	writeStream
		nextPutAll: 'uniqueVersionName'; lf;
		nextPutAll: package uniqueVersionName;
		yourself.


%

category: 'category'
method: JadeServer
sbUnloadPackage: anOrderedCollection
	| service |
	service := Rowan packageServiceClass forPackageNamed: anOrderedCollection removeFirst.
	service deletePackage.
	self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbUpdateClassCategories

	| categories selection override categoryUpdate |
	categoryUpdate := RowanClassCategoryUpdate new. 
	categories := Set new.
	classList do: [:each | categories add: each category].
	categoryUpdate categories addAll: categories asSortedCollection.
	categoryUpdate writeCategoriesTo: writeStream.
	selection := self nextLine.
	categoryUpdate selection: selection. 
	(override := selections at: #'category' ifAbsent: [nil]) notNil ifTrue: [selection := override , '-'].
	selection := 1 < selection size 
		ifTrue: [selection copyFrom: 1 to: selection size - 1]
		ifFalse: [''].
	selection notEmpty ifTrue: [
		categories := categories select: [:each | (each copyFrom: 1 to: (each size min: selection size)) = selection].
		categories isEmpty ifTrue: [selection := ''].
		categories notEmpty ifTrue: [
			classList := classList select: [:each | categories includes: each category].
		].
	].
	categoryUpdate writeSelectionTo: writeStream.


%

category: 'category'
method: JadeServer
sbUpdateClasses

	| tabName |
	tabName := self nextLine.
	writeStream nextPutAll: tabName; lf.
	tabName = 'classList' ifTrue: [^self sbUpdateClassList].
	tabName = 'classHierarchy' ifTrue: [^self sbUpdateClassHierarchy].
	self error: 'Unexpected token!'.

%

category: 'category'
method: JadeServer
sbUpdateClassHierarchy

	| currentSelection currentClass  override classHierarchyUpdate |
	
	classHierarchyUpdate := RowanClassHierarchyUpdate new. 
	classList do: [:each | 
		classHierarchyUpdate addHierarchyFor: each
	].
	classHierarchyUpdate writeHierarchyTo: writeStream. 
	"now figure out which class to select"
	currentSelection := self nextLineAsList.
	(override := selections at: #'className' ifAbsent: [nil]) notNil ifTrue: [currentSelection := Array with: override].
	currentSelection isEmpty ifTrue: [
		selectedClass := nil.
	] ifFalse: [
		(currentClass := selections at: #'class' ifAbsent: [nil]) isNil ifTrue: [
			| className |
			className := (currentSelection last subStrings: Character space) first asSymbol.
			selectedClass := classHierarchyUpdate allClasses detect: [:each | each name = className] ifNone:[].
		] ifFalse: [
			selectedClass := nil.
			[
				selectedClass isNil and: [currentClass notNil].
			] whileTrue: [
				selectedClass := classHierarchyUpdate allClasses detect: [:each | each = currentClass] ifNone:[].
				currentClass := currentClass superclass.
			].
		].
	].
	classHierarchyUpdate addSelectionHierarchyFor: selectedClass.
	classHierarchyUpdate writeSelectionHierarchyTo: writeStream.
	classHierarchyUpdate writeTestCaseInfoTo: writeStream.



%

category: 'category'
method: JadeServer
sbUpdateClassInfo
	| classInfoUpdate |
	selectedClass isNil ifTrue: [
		^self sbClassTemplate. 
].
	classInfoUpdate := RowanClassInfoUpdate new. 
	classInfoUpdate oop: (self oopOf: selectedClass).
	classInfoUpdate template: (Rowan classServiceClass forClassNamed: selectedClass name)
							classCreationTemplate.
	classInfoUpdate category: ((classInfoUpdate template includesString: 'category: ''')
					ifFalse: [' category: ' , selectedClass category printString]).
	classInfoUpdate comment: selectedClass rwComment. 
	classInfoUpdate writeInfoOn: writeStream.
%

category: 'category'
method: JadeServer
sbUpdateClassList

	| mySelections override classesUpdate |
	classesUpdate := RowanClassesUpdate new. 
	(classList asSortedCollection: [:a :b | a name <= b name]) do: [:eachClass | 
		classesUpdate classNames add: eachClass name. 
	].
	classesUpdate writeClassesTo: writeStream. 
	mySelections := self nextLineAsList collect: [:each | (each subStrings: Character space) first asSymbol].
	(override := selections at: #'className' ifAbsent: [nil]) notNil ifTrue: [mySelections := Array with: override].
	mySelections := classList select: [:eachClass | mySelections includes: eachClass name].
	mySelections do: [:eachClass | 
		classesUpdate selections add: eachClass asString].
	classesUpdate writeSelectionsTo: writeStream. 
	classesUpdate writeTestCaseInfoTo: writeStream. 
	selectedClass := mySelections size = 1
		ifTrue: [mySelections first]
		ifFalse: [nil].

%

category: 'category'
method: JadeServer
sbUpdateDictionaries

	| override packagePolicy home symbolList oldSelections newSelections fullList globals dictionaryUpdate globalsUpdate |
	dictionaryUpdate := RowanDictionaryUpdate new. 
	oldSelections := self nextLineAsList.
	(override := selections at: #'dictionary' ifAbsent: [nil]) notNil ifTrue: [oldSelections := Array with: override].
	symbolList := self symbolList.
	(packagePolicy := self gsPackagePolicy) notNil  ifTrue: [
		home := packagePolicy homeSymbolDict.
	].
	fullList := symbolList collect: [:each | 
		| hvName | 
		hvName := (each == home ifTrue: ['H'] ifFalse: ['V']) , each name.
		dictionaryUpdate dictionaries add: hvName.
		hvName.
		].
	dictionaryUpdate writeDictionariesTo: writeStream.
	fullList := fullList collect: [:each | each copyFrom: 2 to: each size].
	newSelections := oldSelections select: [:each | fullList includes: each].
	globals := Dictionary new.
	newSelections do: [:eachName | 
		| symbolDictionary globalKeyPrefix |
		globalKeyPrefix := 1 < newSelections size ifTrue: [eachName , '.'] ifFalse: [''].
		dictionaryUpdate selections add: eachName asString.
		symbolDictionary := symbolList at: (fullList indexOf: eachName).
		symbolDictionary keys asSortedCollection do: [:eachKey |
			| eachGlobal |
			eachGlobal := symbolDictionary at: eachKey.
			(eachGlobal isBehavior and: [eachGlobal name == eachKey])
				ifTrue: [classList add: eachGlobal]
				ifFalse: [globals at: globalKeyPrefix , eachKey put: (symbolDictionary associationAt: eachKey)].
		].
	].
	dictionaryUpdate writeSelectionsTo: writeStream. 
	globalsUpdate := RowanGlobalsUpdate new. 
	globals keys asSortedCollection do: [:eachKey | 
		| eachAssociation eachValue string globalsArray |
		eachAssociation := globals at: eachKey.
		eachValue := eachAssociation value.
		string := self asString: eachValue.
		100 < string size ifTrue: [string := string copyFrom: 1 to: 100].
		string := string collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$.] ifFalse: [char]].
		string := String withAll: string asArray.
		globalsArray := Array new. 
		globalsArray add: eachKey;
						add: eachValue _class name;
						add: string;
						add: (self oopOf: eachValue) printString;
						add: (self oopOf: eachAssociation) printString.
		globalsUpdate globals add: globalsArray. 
	].
	globalsUpdate writeGlobalsTo: writeStream. 
	


%

category: 'category'
method: JadeServer
sbUpdateMethod

	| classes method names selection aSymbol |

	aSymbol := methodCommandResult selectedSelectors first. 

	"Inherited implimentors"
	classes := self sbUpdateMethodInheritedImplementationsOf: aSymbol.
	names := classes collect: [:each | each name asString].
	methodCommandResult inheritedClasses: names. 
	methodCommandResult writeInheritedClassesTo: writeStream.  "Line 1"

	"Which inherited implementation is selected?"
	selection := self nextLine.
	(names includes: selection) ifFalse: [selection := names last].
	methodCommandResult inheritedClass: selection.
	methodCommandResult writeInheritedClassTo: writeStream.	"Line 2"

	method := self compiledMethodAt: aSymbol inClass: (classes detect: [:each | each name asString = selection]).
	self _describeMethod: method.

%

category: 'category'
method: JadeServer
sbUpdateMethodBreakPointsFor: aMethod
	"Answers an Array of step points"

	^aMethod _stepPointsFromBreakIpOffsets: aMethod _breakpointIpOffsets.		"at least as far back as 32-bit 6.3.0 and 64-bit 2.3.0, but not in 64-bit 3.0"

%

category: 'category'
method: JadeServer
sbUpdateMethodCategories

	methodCommandResult classNamesFrom: classList. 
	methodCommandResult updateMethodCategories; 
		writeMethodCategoriesTo: writeStream. 
	methodCommandResult updateMethodFilterSelections: self nextLineAsList 
			hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodCommandResult selectionNames.
	methodCommandResult writeSelectionsTo: writeStream.
%

category: 'category'
method: JadeServer
sbUpdateMethodFilter
	
	selectedClass isNil ifTrue: [^self].
	methodFilterType = 'categoryList' ifTrue: [^self sbUpdateMethodCategories].
	methodFilterType = 'variableList' ifTrue: [^self sbUpdateMethodVariables].
	methodFilterType = 'pragmaList' ifTrue: [^self sbUpdateMethodPragmas].
	self error: 'Unexpected token!'.

%

category: 'category'
method: JadeServer
sbUpdateMethodFilterSelections

	| mySelections override |
	mySelections := self nextLineAsList.
	(override := selections at: #'methodCategory' ifAbsent: [nil]) notNil ifTrue: [mySelections := Array with: override].
	mySelections := methodFilters select: [:each | mySelections includes: each asString].
	mySelections notEmpty ifTrue: [methodFilters := mySelections].
	self writeList: mySelections.

%

category: 'category'
method: JadeServer
sbUpdateMethodInheritedImplementationsOf: aSymbol

	| classes currentClass |
	classes := OrderedCollection new.
	currentClass := classList last.
	[
		currentClass notNil.
	] whileTrue: [
		(self class: currentClass includesSelector: aSymbol) ifTrue: [classes add: currentClass].
		currentClass := currentClass superclass.
	].
	^classes reverse.

%

category: 'category'
method: JadeServer
sbUpdateMethodPragmas

	self sbUpdateMethodFilterSelections.

%

category: 'category'
method: JadeServer
sbUpdateMethods

	| selectors |
	selectedClass isNil ifTrue: [^self].
	methodFilterType = 'categoryList' ifTrue: [selectors := self sbUpdateMethodsByCategories] ifFalse: [
	methodFilterType = 'variableList' ifTrue: [selectors := self sbUpdateMethodsByVariables] ifFalse: [
	methodFilterType = 'pragmaList' ifTrue: [selectors := self sbUpdateMethodsByPragmas] ifFalse: [
		self error: 'Unrecognized methodFilterType: ' , methodFilterType printString]]].
	methodCommandResult selectors: selectors asSortedCollection asArray.
	methodCommandResult updateMethodsInfo.
	methodCommandResult writeMethodsTo: writeStream. 
	self sbUpdateMethodSelections

%

category: 'category'
method: JadeServer
sbUpdateMethodsByCategories

	| selectors |
	selectors := IdentitySet new.
	classList do: [:eachClass |
		eachClass selectors do: [:eachSelector |
			( methodFilters includes: (self _behavior: eachClass categoryOfSelector: eachSelector)) ifTrue: [selectors add: eachSelector].
		].
	].
	^selectors.

%

category: 'category'
method: JadeServer
sbUpdateMethodsByPragmas
	"none before 3.x"

	^#()
%

category: 'category'
method: JadeServer
sbUpdateMethodsByVariables

	| selectors filters |
	selectors := IdentitySet new.
	filters := IdentitySet withAll: (methodFilters select: [:each | each isSymbol]).
	selectedClass selectors do: [:eachSelector | 
		| gsMethod |
		gsMethod := self compiledMethodAt: eachSelector inClass: selectedClass.
		(gsMethod instVarsAccessed * filters) notEmpty ifTrue: [selectors add: eachSelector].
	].
	^selectors.

%

category: 'category'
method: JadeServer
sbUpdateMethodSelections

	| priorSelections override newSelections aList |
	aList := methodCommandResult selectors asArray. 
	priorSelections := self nextLineAsList.
	(override := selections at: #'method' ifAbsent: [nil]) notNil ifTrue: [priorSelections := Array with: override].
	newSelections := aList select: [:each | priorSelections includes: each asString].
	methodCommandResult selectedSelectors: newSelections. 
	methodCommandResult writeSelectedSelectorsTo: writeStream.
	newSelections size = 1 ifTrue: [self sbUpdateMethod].


%

category: 'category'
method: JadeServer
sbUpdateMethodStepPointsFor: aMethod
	"Answers an Array of Associations (offset -> selector) indexed by step point"

	| offsets selectors |
	offsets := (self homeMethodFor: aMethod)  _sourceOffsets.
	selectors := Array new.
	1 to: offsets size do: [:i | 		"exists as far back as 32-bit 6.3.0"
		| offset ip association |
		offset := offsets at: i.
		ip := (aMethod _ipForStepPoint: i) + 2.		"dropped in 64-bit 3.0"
		association := offset -> ''.
		ip <= aMethod size ifTrue: [
			| literal |
			((literal := aMethod at: ip) isKindOf: Symbol) ifTrue: [
				association value: literal.
			].
		].
		selectors add: association.
	].
	^selectors.

%

category: 'category'
method: JadeServer
sbUpdateMethodVariables

	methodCommandResult classNamesFrom: classList. 
	methodCommandResult updateMethodVariables. 
	methodCommandResult writeMethodFiltersTo: writeStream. 
	methodCommandResult updateMethodFilterSelections: self nextLineAsList 
		hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodCommandResult selectionNames.
	methodCommandResult writeSelectionsTo: writeStream. 


%

category: 'category'
method: JadeServer
sbUpdatePackage: aString
	| package workingCopy list index |
	self mcPackageClass isNil
		ifTrue: 
			[writeStream
				nextPut: $%;
				lf.
			writeStream
				nextPut: $%;
				lf.
			^self ].
	package := self mcPackageClass named: aString.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	list := workingCopy ancestors collect: [:each | 0 -> each].
	index := 1.
	[list size < 4 and: [index <= list size]] whileTrue: 
			[| assoc |
			assoc := list at: index.
			assoc value ancestors do: [:parent | list add: assoc key + 1 -> parent].
			index := index + 1].
	list do: 
			[:each |
			| date time |
			date := each value date isNil
						ifTrue: ['']
						ifFalse: [each value date asStringUsingFormat: #(3 2 1 $- 1 1)].
			time := each value time isNil
						ifTrue: ['']
						ifFalse: [each value time asStringUsingFormat: #($: true false)].
			writeStream
				nextPutAll: each key printString;
				tab;
				nextPutAll: each value name;
				tab;
				nextPutAll: date;
				nextPut: $T;
				nextPutAll: time;
				tab;
				nextPutAll: (each value message
							collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$.] ifFalse: [char]]);
				lf].
	writeStream
		nextPut: $%;
		lf.
	workingCopy repositoryGroup repositories do: 
			[:each |
			writeStream
				nextPutAll: each class name;
				tab;
				nextPutAll: each description;
				tab;
				yourself.
			each class name = #MCHttpRepository
				ifTrue: 
					[writeStream
						nextPutAll: each user;
						tab;
						nextPutAll: each password;
						yourself]
				ifFalse: 
					[writeStream
						tab;
						tab].
			writeStream lf].
	writeStream
		nextPut: $%;
		lf
%

category: 'category'
method: JadeServer
sbUpdatePackages
	| override modifiedList oldSelections newSelections fullList packagesUpdate |
	
	packagesUpdate := RowanPackageUpdate new. 
	oldSelections := self nextLineAsList.
	(override := selections at: #package ifAbsent: [nil]) notNil
		ifTrue: [oldSelections := Array with: override].
	fullList := Rowan serviceClass new rowanLoadedPackageNames subStrings: Character lf.
	fullList := fullList reject: [:each | each isEmpty].
	fullList := fullList asSortedCollection asArray.
	fullList := fullList collect: [:each | each subStrings: Character tab].
	fullList := fullList reject: [:each | each isEmpty].
	modifiedList := (fullList select: [:each | (each at: 2) = 'Y']) collect: [:each | each at: 3].
	fullList := fullList collect: [:each | each at: 3].
	packagesUpdate modifiedPackages addAll: modifiedList. 
	packagesUpdate packages addAll: (fullList collect: [:packageName | RowanPackageService forPackageNamed: packageName]) . 
	packagesUpdate writePackagesTo: writeStream. 
	packagesUpdate writeModifiedPackagesTo: writeStream. 
	newSelections := oldSelections select: [:each | fullList includes: each].
	(newSelections isEmpty and: [oldSelections size = 1])
		ifTrue: 
			[newSelections := fullList
						select: [:each | (oldSelections first copyFrom: 1 to: (oldSelections first size min: each size)) = each]].
	newSelections do: 
			[:each |
			| service |
			packagesUpdate selections add: each asString. 
			service := Rowan packageServiceClass forPackageNamed: each.
			classList addAll: service loadedClassHandles].
	packagesUpdate writeSelectionsTo: writeStream.
	newSelections size = 1 ifTrue: [self sbUpdatePackage: newSelections first]

%

category: 'category'
method: JadeServer
sbUpdatePackagesOrDictionaries

	| selectedTab |
	selectedTab := self nextLine.
	"Removed for Rowan which may not have Monticello loaded, but have a package tab"
	"(self mcWorkingCopyClass isNil or: [self gsPackagePolicy isNil]) ifTrue: [selectedTab := 'dictionaryList']." 
	writeStream nextPutAll: selectedTab; lf.
	classList := OrderedCollection new.
	selectedTab = 'dictionaryList' ifTrue: [^self sbUpdateDictionaries].
	selectedTab = 'packageList' ifTrue: [^self sbUpdatePackages].
	selectedTab = 'projectList' ifTrue:[
		self sbUpdatePackages. 
		^self updateProjects].
	self error: 'unexpected token'.

%

category: 'category'
method: JadeServer
sbUpdateSuperclass

	| class tabName selected index superclassUpdate |

	superclassUpdate := RowanSuperclassUpdate new.
	tabName := self nextLine. 
	(#('default' 'instanceTab' 'classTab') includes: tabName) ifFalse: [self error: 'Unexpected token!'].
	tabName = 'default' ifTrue: [
		tabName := (selectedClass notNil and: [selectedClass selectors isEmpty and: [selectedClass class selectors notEmpty]]) 
			ifTrue: ['classTab']
			ifFalse: ['instanceTab'].
	]. 
	superclassUpdate tabName: tabName. 
	superclassUpdate writeTabNameTo: writeStream.
	selectedClass notNil ifTrue: [
		selectedClass := tabName = 'instanceTab'
			ifTrue: [selectedClass]
			ifFalse: [selectedClass class].
	].
	class := selectedClass.
	classList := OrderedCollection new.
	[
		class notNil.
	] whileTrue: [
		classList add: class.
		superclassUpdate classNames add: class name asString. 
		class := self environmentSuperClassFor: class.
	].
	superclassUpdate writeClassesTo: writeStream.
	classList := classList reverse.
	selected := self nextLine.
	index := classList findFirst: [:each | each name asString = selected].
	index = 0 ifTrue: [index := classList size].
	0 < index ifTrue: [classList := classList copyFrom: index to: classList size].
	classList notEmpty ifTrue: [
		selectedClass := classList first.
		superclassUpdate selections add: selectedClass asString.
	].
	superclassUpdate writeSelectionsTo: writeStream.
%

category: 'category'
method: JadeServer
selectedClassOverridesSelector: aSymbol

	^selectedClass superclass notNil and: [selectedClass superclass canUnderstand: aSymbol].

%

category: 'category'
method: JadeServer
selectorsMatching: aString

	| user stream list |
	list := (aString subStrings: $*) asOrderedCollection collect: [:each | each asUppercase].
	list size - 1 to: 1 do: [:i | list add: $* afterIndex: i].
	aString last = $* ifTrue: [list addLast: $*].
	stream := WriteStream on: String new.
	user := AllUsers 
		userWithId: #SymbolUser 
		ifAbsent: [AllUsers userWithId: #DataCurator].
	list := list asArray.
	list := (user resolveSymbol: #AllSymbols) value select: [:each |each asUppercase matchPattern: list].
	list := list select: [:each | (self classOrganizer implementorsOf: each) notEmpty].
	list := list asSortedCollection.
	list do: [:each | stream nextPutAll: each; nextPut: Character lf; yourself].
	^stream contents.

%

category: 'category'
method: JadeServer
sendersOf: anObject

	| symbol |
	symbol := (anObject isKindOf: String)
		ifTrue: [anObject asSymbol]
		ifFalse: [anObject selector].
	^self streamOfMethods: (self classOrganizer sendersOf: symbol) first.

%

category: 'category'
method: JadeServer
sendSigAbortToSession: anInteger

	System sendSigAbortToSession: anInteger negated.

%

category: 'category'
method: JadeServer
sendSigUsr1ToSession: anInteger

	| description command result |
	description := System descriptionOfSession: anInteger.
	command := 'kill -usr1 ' , (description at: 2) printString.
	result := System performOnServer: command.
	result trimSeparators notEmpty ifTrue: [self error: result trimSeparators].

%

category: 'category'
method: JadeServer
setBreakAtStepPoint: anInteger inMethod: aGsMethod

	aGsMethod setBreakAtStepPoint: anInteger.

%

category: 'category'
method: JadeServer
show: anObject

	self nextPutAll: anObject printString.

%

category: 'category'
method: JadeServer
sleepAndCommit

	[
		System commitTransaction.
	] whileTrue: [
		(Delay forSeconds: 30) wait.
	].

%

category: 'category'
method: JadeServer
sourceFor: anObject in: aClass

	| behavior selector packageName category mcTimestamp dict source |
	selector := (anObject isKindOf: String) 
		ifTrue: [anObject asSymbol]
		ifFalse: [anObject selector].
	behavior := self
		behaviorFor: selector 
		in: aClass.
	category := self _behavior: behavior categoryOfSelector: selector.
	packageName := category first = $*
		ifTrue: [self _packageNameFor: category]
		ifFalse: [behavior thisClass _classCategory].
	packageName isNil ifTrue: [packageName := ''].
	mcTimestamp := ''.
	dict := behavior extraDict.
	dict notNil ifTrue: [
		dict := dict at: #'GSMethodStampDict' ifAbsent: [nil].
		dict notNil ifTrue: [
			mcTimestamp := dict
				at: selector
				ifAbsent: [''].
		].
	].
	source := behavior sourceCodeAt: selector.
	^(WriteStream on: String new)
		nextPutAll: packageName; tab;
		nextPutAll: category; tab;
		nextPutAll: mcTimestamp; lf;
		nextPutAll: source;
		contents.

%

category: 'category'
method: JadeServer
sourceForProcess: gsProcess frame: level

	self subclassResponsibility
%

category: 'category'
method: JadeServer
stackForProcess: aGsProcess

	| array stream |
	Exception
		category: nil
		number: nil
		do: [:ex :cat :num :args | nil].
	array := aGsProcess _reportOfSize: 5000.
	stream := WriteStream on: String new.
	array do: [:each | 
		stream nextPutAll: each; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
step: aGsProcess inFrame: anInteger

	aGsProcess _stepOverInFrame: anInteger.

%

category: 'category'
method: JadeServer
stepPointsFor: aGsMethod in: aClass

	| behavior method source breakStepPoints stepPoint stream |
	behavior := self
		behaviorFor: aGsMethod selector
		in: aClass.
	source := behavior sourceCodeAt: aGsMethod selector.
	method := self compiledMethodAt: aGsMethod selector inClass: behavior.
	stream := WriteStream on: String new.
	breakStepPoints := (aGsMethod class canUnderstand: #'_breakpointIpOffsets')
		ifTrue: [aGsMethod _stepPointsFromBreakIpOffsets: aGsMethod _breakpointIpOffsets]
		ifFalse: [#()].
	stepPoint := 0.
	method _sourceOffsets do: [:each | 
		stepPoint := stepPoint + 1.
		(breakStepPoints includes: stepPoint) ifTrue: [stream nextPut: $B].
		each printOn: stream.
		stream nextPut: Character space.
	].
	stream lf; 
		nextPutAll: (self stringOfLineNumbersWithBreaksIn: method); lf;
		nextPutAll: source;
		yourself.
	^stream contents.

%

category: 'category'
method: JadeServer
stoneInfo

	| dict stream |
	stream := (WriteStream on: String new)
		nextPutAll: self streamType; tab;
		nextPutAll: self stringType; tab;
		cr;
		yourself.
	dict := System stoneVersionReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	dict := System stoneConfigurationReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	^stream contents
%

category: 'category'
method: JadeServer
stopSession: anInteger

	System stopSession: anInteger.

%

category: 'category'
method: JadeServer
streamOfMethods: aList

	| stream |
	stream := WriteStream on: String new.
	aList do: [:each | 
		self
			_addMethod: each 
			toStream: stream.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
streamType

	^'Legacy'
%

category: 'category'
method: JadeServer
stringForClassList: aList

	| stream |
	stream := WriteStream on: String new.
	aList do: [:each | 
		self 
			_addClass: each 
			toStream: stream.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
stringOfLineNumbersWithBreaksIn: aGsMethod

	| stepPoints offsets lines stream |
	stepPoints := (aGsMethod class canUnderstand: #'_breakpointIpOffsets')
		ifTrue: [aGsMethod _stepPointsFromBreakIpOffsets: aGsMethod _breakpointIpOffsets]
		ifFalse: [#()].
	offsets := stepPoints collect: [:each | aGsMethod _sourceOffsetsAt: each].
	lines := offsets collect: [:each | 
		((aGsMethod sourceString copyFrom: 1 to: each) select: [:char | char = Character lf]) size + 1.
	].
	stream := WriteStream on: String new.
	lines do: [:each | each printOn: stream. stream space].
	^stream contents.

%

category: 'category'
method: JadeServer
stringType

	^'String'
%

category: 'category'
method: JadeServer
subclassSelectorForClass: aClass

	(aClass isBytes and: [aClass superclass notNil and: [aClass superclass isBytes not]]) ifTrue: [
		^'byteSubclass:'.
	].
	(aClass isIndexable and: [aClass superclass notNil and: [aClass superclass isIndexable not]]) ifTrue: [
		^'indexableSubclass:'.
	].
	((aClass class canUnderstand: #'isTransientDB') and: [aClass isTransientDB]) ifTrue: [
		^'transientSubclass:'.
	].
	^'subclass:'.

%

category: 'category'
method: JadeServer
superclassesOf: aClass isMeta: aBoolean

	| myClass list |
	myClass := aBoolean ifTrue: [aClass class] ifFalse: [aClass].
	list := myClass _allSuperList , (Array with: myClass).
	^self stringForClassList: list.

%

category: 'category'
method: JadeServer
symbolList

	^System myUserProfile symbolList.

%

category: 'category'
method: JadeServer
systemBrowser: aString
	^self copy systemBrowserA: aString.

%

category: 'category'
method: JadeServer
systemBrowserA: aString

	| time |
	time := self millisecondsElapsedTime: [
		selections := Dictionary new.
		readStream := ReadStream on: aString.
		writeStream := WriteStream on: String new.
		writeStream lf.
		self environment: (readStream upTo: Character space) asNumber.
		self systemBrowserCommand.
	].
	^time printString , writeStream contents.

%

category: 'category'
method: JadeServer
systemBrowserCommand

	| list command |
	list := self nextLineAsList asOrderedCollection.
	command := list removeFirst.
	command = 'addDictionary'				ifTrue: [^self sbAddDictionary: list].
	command = 'addMethodCategory' 		ifTrue: [^self sbAddMethodCategory: list].
	command = 'addMissingAccessors'		ifTrue: [^self sbAddMissingAccessors: list].
	command = 'addPackage' 				ifTrue: [^self sbAddPackage: list].
	command = 'addRepository'			ifTrue: [^self sbAddRepository: list].

	command = 'break' 					ifTrue: [^self sbBreak: list].
	command = 'browseClassReferences'		ifTrue: [^self sbBrowseClassReferences: list].
	command = 'browseGlobalReferences'		ifTrue: [^self sbBrowseGlobalReferences: list].
	command = 'browseImplementors'		ifTrue: [^self sbBrowseImplementors: list].
	command = 'browseMethodHistory'		ifTrue: [^self sbBrowseMethodHistory: list].
	command = 'browseMethodsContaining'	ifTrue: [^self sbBrowseMethodsContaining: list].
	command = 'browseMethodsWithPragma'	ifTrue: [^self sbBrowseMethodsWithPragma: list].
	command = 'browseSenders'			ifTrue: [^self sbBrowseSenders: list].

	command = 'changeClassName'			ifTrue: [^self sbChangeClassName: list].
	command = 'changesInPackage'			ifTrue: [^self sbChangesInPackage: list].
	command = 'checkUniqueClassName'		ifTrue: [^self sbCheckUniqueClassName: list].
	command = 'class' 					ifTrue: [^self sbClass: list].
	command = 'classCategory'				ifTrue: [^self sbClassCategory: list].
	command = 'classComment'			ifTrue: [^self sbClassComment: list].
	command = 'classesToDictionary'		ifTrue: [^self sbClassesToDictionary: list].
	command = 'comparePackages'			ifTrue: [^self sbComparePackages: list].

	command = 'fileOutClass'				ifTrue: [^self sbFileOutClass: list].
	command = 'fileOutDictionary'			ifTrue: [^self sbFileOutDictionary: list].
	command = 'fileOutMethod'			ifTrue: [^self sbFileOutMethod: list].
	command = 'findClass' 				ifTrue: [^self sbFindClass].
	command = 'findSelectors'				ifTrue: [^self sbFindSelectors: list].


	command = 'listMethodPragmas'			ifTrue: [^self sbListMethodPragmas: list].
	command = 'loadLatestVersion'			ifTrue: [^self sbLoadLatestVersionOfConfiguration: list].

	command = 'method' 					ifTrue: [^self sbSaveMethod: list].
	command = 'methodCategory'			ifTrue: [^self sbMethodCategory: list].
	command = 'methodClass'				ifTrue: [^self sbMethodClass: list].

	command = 'objectLog'				ifTrue: [^self sbObjectLog: list].

	command = 'postSaveClass'			ifTrue: [^self sbPostSaveClass: list].

	command = 'removeClasses'			ifTrue: [^self sbRemoveClasses].
	command = 'removeDictionaries'			ifTrue: [^self sbRemoveDictionaries: list].
	command = 'removeGlobals'			ifTrue: [^self sbRemoveGlobals].
	command = 'removeMethodCategories' 	ifTrue: [^self sbRemoveMethodCategories: list].
	command = 'removeMethods'			ifTrue: [^self sbRemoveMethods: list].
	command = 'removePriorVersions'		ifTrue: [^self sbRemovePriorVersions].
	command = 'removeRepository'			ifTrue: [^self sbRemoveRepository: list].
	command = 'revertClass'				ifTrue: [^self sbRevertClass].

	command = 'savePackage'				ifTrue: [^self sbSavePackage: list].
	command = 'setHomeDictionary'			ifTrue: [^self sbSetHomeDictionary: list].

	command = 'uniqueVersionName'		ifTrue: [^self sbUniqueVersionName: list].
	command = 'unloadPackage'			ifTrue: [^self sbUnloadPackage: list].
	command = 'update' 					ifTrue: [^self systemBrowserUpdate].

	self error: 'Unknown command: ' , command printString.

%

category: 'category'
method: JadeServer
systemBrowserSTON: aString
	^self copy systemBrowserSTONA: aString.

%

category: 'category'
method: JadeServer
systemBrowserSTONA: aString

	| time |
	time := self millisecondsElapsedTime: [
		selections := Dictionary new.
		readStream := ReadStream on: aString.
		writeStream := WriteStream on: String new.
		writeStream lf.
		self environment: (readStream upTo: Character space) asNumber.
		self systemBrowserCommand.
	].
	^STON toString: RowanCommandResult results

%

category: 'jadeite'
method: JadeServer
systemBrowserUpdate

	RowanCommandResult initializeResults. 
	writeStream nextPutAll: 'update'; lf.
	self 
		sbUpdatePackagesOrDictionaries;
		sbUpdateClassCategories;
		sbUpdateClasses;
		sbUpdateClassInfo; 
		sbUpdateSuperclass. 
		methodCommandResult := RowanMethodsUpdate new. 
		self sbReadMethodFilter.
		selectedClass isNil ifFalse:[
			methodCommandResult selectedClass: selectedClass name.
			self
				sbUpdateMethodFilter;
				sbUpdateMethods]
%

category: 'category'
method: JadeServer
systemConfigAsDictionary

	| char dict i line list stream |
	list := Array new.
	stream := GsFile openReadOnServer: '$GEMSTONE/data/system.conf'.
	[
		[
			line := stream nextLine reject: [:each | each == Character cr or: [each == Character lf]].
			(2 < line size and: [(line copyFrom: 1 to: 2) = '#=']) ifTrue: [
				list add: (WriteStream on: String new).
			] ifFalse: [
				list last nextPutAll: line; cr.
			].
			stream atEnd not.
		] whileTrue: [].
	] ensure: [
		stream close.
	].
	list := list copyFrom: 3 to: list size.
	list := list collect: [:each | each contents].
	dict := Dictionary new.
	list do: [:each | 
		line := (ReadStream on: each) nextLine.
		line = '# End of Default GemStone Configuration Options' ifTrue: [^dict].
		(line copyFrom: 1 to: 2) = '# ' ifFalse: [line error: 'Unrecognized config file format!'].
		i := 3.
		[
			i <= line size and: [(char := line at: i) == $_ or: [char isAlphaNumeric]].
		] whileTrue: [
			i := i + 1.
		].
		dict at: (line copyFrom: 3 to: i - 1) put: each.
	].
	self error: 'End of file not recognized!'.
%

category: 'category'
method: JadeServer
terminate: aGsProcess

	aGsProcess isNil ifTrue: [^self].
	aGsProcess terminate.
	(Delay forMilliseconds: 10) wait.	"allow forked processes to finish"

%

category: 'jadeite'
method: JadeServer
updateFromSton: stonString
	| services organizer resultString |
	RowanCommandResult initializeResults.
	services := STON fromString: stonString.
	organizer := ClassOrganizer new.
	services do: 
			[:service |
			service organizer: organizer. 
			service updateType: nil.  "Update type is only for returned commands"
			service command ifNil:[service command: #update]. 
			service servicePerform: service command withArguments: service commandArgs].
	self autoCommitIfRequired.
	RowanLoggingService current logSentServices. 
	resultString := STON toString: RowanCommandResult results.
	^resultString
%

category: 'category'
method: JadeServer
updateProjects
	
	| update |
	update := RowanProjectsUpdate new. 
	RowanProjectService new projects do:[:service | 
		service isDirty ifTrue:[
			update modifiedProjects add: service name]. 
			update projects add: service].
%

category: 'category'
method: JadeServer
userList

	| list me stream |
	list := (AllUsers asSortedCollection: [:a :b | a userId <= b userId]) asOrderedCollection.
	me := System myUserProfile.
	list
		remove: me;
		addFirst: me;
		yourself.
	stream := WriteStream on: String new.
	list do: [:each | 
		self
			addUser: each 
			toStream: stream.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
waitingProcesses

	^ProcessorScheduler scheduler waitingProcesses

%

category: 'category'
method: JadeServer
writeList: aList

	aList do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.

%

category: 'category'
method: JadeServer
_addClass: each toStream: stream 

	self
		_addClass: each 
		toStream: stream 
		isVisible: true
		fromDictionary: nil.

%

category: 'category'
method: JadeServer
_addClass: aClass toStream: aStream isVisible: aBoolean fromDictionary: aDictionary
	"1. OOP; 2. key; 3. category; 4. dictionary name; 5. superclass OOP; 6. children; 7. Visible/Inherited; 8. Class History; 9. isTestCase"

	| testCaseClass history |
"1"	(self oopOf: aClass) printOn: aStream.
"2"	aStream tab; nextPutAll: (aDictionary  isNil ifTrue: [aClass name] ifFalse: [aDictionary keyAtValue: aClass ifAbsent: [aClass name]]); tab.
"3"	aClass category notNil ifTrue: [aStream nextPutAll: aClass category].
"4"	aStream tab; nextPutAll: (aDictionary isNil ifTrue: ['?'] ifFalse: [aDictionary name]).
"5"	aStream tab. (self oopOf: aClass superclass) printOn: aStream.
	aStream 
"6"		tab; "let client build children list"
"7"		tab; nextPut: (aBoolean ifTrue: [$V] ifFalse: [$I]);
		tab.
	(history := self historyOf: aClass) isNil ifTrue: [history := Array with: aClass].
"8"	(history indexOf: aClass) printOn: aStream.
	aStream nextPut: $/.
	history size printOn: aStream.
	aStream tab.
	testCaseClass := Globals
		at: #'TestCase'
		ifAbsent: [nil].
"9"	(testCaseClass notNil and: [aClass isSubclassOf: testCaseClass]) printOn: aStream.
	aStream lf.

%

category: 'category'
method: JadeServer
_addMethod: aGsMethod toStream: aStream
	"See GsMethod2>>initialize:"

	| inClass testCaseClass |
	inClass := aGsMethod inClass.
"1"	(self oopOf: aGsMethod) printOn: aStream.
	aStream 
"2"		tab; nextPutAll: aGsMethod selector; 
"3"		tab; nextPutAll: (self _behavior: inClass categoryOfSelector: aGsMethod selector);
		tab.

	"Class"
"4"	(self oopOf: inClass) printOn: aStream.
"5"	aStream tab; nextPutAll: inClass name; tab.
"6"	inClass category notNil ifTrue: [aStream nextPutAll: inClass category].
"7"	aStream tab; nextPutAll: (self nameOfFirstDictionaryReferencing: inClass thisClass); tab.

	"SUnit Test Method"
	testCaseClass := Globals
		at: #'TestCase'
		ifAbsent: [nil].
"8"	((testCaseClass notNil and: [inClass isSubclassOf: testCaseClass]) and: [inClass testSelectors includes: aGsMethod selector]) printOn: aStream.
	aStream lf.

%

category: 'category'
method: JadeServer
_addToPureExportSet: anObject

	System 
		_add: anObject 
		toGciSet: 39.  "PureExportSet"

%

category: 'category'
method: JadeServer
_allSelectors

	| allSelectors |
	allSelectors := IdentitySet new.
	self classOrganizer classes do: [:each | 
		allSelectors addAll: each selectors; addAll: each class selectors.
	].
	^allSelectors
%

category: 'category'
method: JadeServer
_behavior: aBehavior categoryOfSelector: aSymbol

	^aBehavior categoryOfSelector: aSymbol
%

category: 'category'
method: JadeServer
_describeMCAddition: anMCAddition on: aStream

	aStream 
		nextPut: $A; tab;
		nextPutAll: (self oopOf: anMCAddition) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCAddition definition 
		on: aStream.

%

category: 'category'
method: JadeServer
_describeMCClassDefinition: anMCClassDefinition on: aStream

	| string |
	string := anMCClassDefinition definitionString collect: [:char |
		char = Character lf
			ifTrue: [Character cr]
			ifFalse: [char].
	].
	aStream
		nextPut: $C; tab;
		nextPutAll: string; lf;
		yourself.

%

category: 'category'
method: JadeServer
_describeMCDefinition: anMCDefinition on: aStream

	anMCDefinition isMethodDefinition ifTrue: [
		self 
			_describeMCMethodDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	anMCDefinition isOrganizationDefinition ifTrue: [
		self 
			_describeMCOrganizationDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	anMCDefinition isClassDefinition ifTrue: [
		self 
			_describeMCClassDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	self halt.

%

category: 'category'
method: JadeServer
_describeMCMethodDefinition: anMCMethodDefinition on: aStream
	| unicodeFreeSource |
	unicodeFreeSource := RowanMethodService removeUnicodeFromSource: anMCMethodDefinition source.
	aStream
		nextPut: $M; tab;
		nextPutAll: anMCMethodDefinition timeStamp; tab;
		nextPutAll: anMCMethodDefinition className; tab;
		nextPutAll: anMCMethodDefinition classIsMeta printString; tab;
		nextPutAll: anMCMethodDefinition category; tab;
		nextPutAll: anMCMethodDefinition selector; tab;
		nextPutAll: unicodeFreeSource size printString; tab;
		nextPutAll: unicodeFreeSource; lf.
%

category: 'category'
method: JadeServer
_describeMCModification: anMCModification on: aStream

	aStream nextPut: $M; tab;
		nextPutAll: (self oopOf: anMCModification) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCModification obsoletion 
		on: aStream.
	self 
		_describeMCDefinition: anMCModification modification 
		on: aStream.

%

category: 'category'
method: JadeServer
_describeMCOrganizationDefinition: anMCOrganizationDefinition on: aStream

	aStream
		nextPut: $O; tab;
		yourself.
	anMCOrganizationDefinition categories do: [:each | 
		aStream nextPutAll: each; tab.
	].
	aStream lf.

%

category: 'category'
method: JadeServer
_describeMCRemoval: anMCRemoval on: aStream

	aStream nextPut: $R; tab;
		nextPutAll: (self oopOf: anMCRemoval) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCRemoval definition 
		on: aStream.

%

category: 'category'
method: JadeServer
_describeMethod: aMethod
	"Provide info needed to create a GsMethod in Jade client"
	"Nice to add packageName and mcTimestamp"

	| allSelectors class list oldGsMethod string methodUpdate |

	methodUpdate := methodCommandResult isNil ifTrue:[RowanMethodUpdate new]
		ifFalse:[methodCommandResult methods detect:[:update | update selector = aMethod selector]].
	self environment: (self environmentForMethod: aMethod).
		
	methodUpdate 	"Line 1 for GsMethod (line 3 for JadeSystemBrowserPresenter)"
"1"		classOop: (class := aMethod inClass) asOop;
"2"		className: class printString;
"3"		methodOop: aMethod asOop;
"4"		selector: aMethod selector;
"5"		category: (self categoryOfMethod: aMethod);
"6"		isReadOnly: (self currentUserMayEditMethod: aMethod);
			source: (RowanMethodService removeUnicodeFromSource: aMethod sourceString).

	"unimplemented selectors"			"https://github.com/jgfoster/Jade/issues/117"
	((aMethod class includesSelector: #'_selectorPool') and: [aMethod class includesSelector: #'_sourceOffsetOfFirstSendOf:']) ifTrue: [
		allSelectors := self _allSelectors.
		(aMethod _selectorPool reject: [:each | allSelectors includes: each]) do: [:each | 
			methodUpdate firstSendOffsets at: (aMethod _sourceOffsetOfFirstSendOf: each) put: each.
		].
	].

	"Array of Associations (offset -> selector) indexed by step points"
	list := self sbUpdateMethodStepPointsFor: aMethod.
	list do:[:each | methodUpdate stepPoints at: each key printString put: each value].

	"breaks"
	methodUpdate breakPoints: (self sbUpdateMethodBreakPointsFor: aMethod).

	"original method"
	oldGsMethod := (aMethod inClass class canUnderstand: #'persistentMethodDictForEnv:')
		ifTrue: [(aMethod inClass persistentMethodDictForEnv: 0) at: aMethod selector ifAbsent: [aMethod]]
		ifFalse: [(aMethod inClass class canUnderstand: #'_rawMethodDict')
			ifTrue: [aMethod inClass _rawMethodDict at: aMethod selector ifAbsent: [aMethod]]
			ifFalse: [aMethod]].
	aMethod ~~ oldGsMethod ifTrue: [
		methodUpdate originalMethodSource: oldGsMethod sourceString.
	].

	"method compile warnings"
	string := selections isNil 
		ifTrue: ['']
		ifFalse: [selections at: #'methodWarnings' ifAbsent: ['']].
	string isNil ifTrue: [string := ''].
	methodUpdate compilationWarnings: string.
	methodUpdate writeMethodTo: writeStream.
%

category: 'category'
method: JadeServer
_mcDescriptionOfPatch: aPatch baseName: aString1 alternateName: aString2

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aPatch) printOn: stream.
	stream 
		tab; nextPutAll: (aString1 isNil ifTrue: ['loaded'] ifFalse: [aString1]);
		nextPutAll: ' vs. ';
		nextPutAll: (aString2 isNil ifTrue: ['loaded'] ifFalse: [aString2]);
		lf.
	aPatch operations do: [:each | 
		each isAddition 		ifTrue: [self _describeMCAddition: 		each on: stream].
		each isModification 	ifTrue: [self _describeMCModification: 	each on: stream].
		each isRemoval 		ifTrue: [self _describeMCRemoval: 		each on: stream].
	].
	^stream contents.


%

category: 'category'
method: JadeServer
_mcTopazFrom: aSnapshot on: aStream

	| classes dict parents methods queue |
	classes := aSnapshot definitions select: [:each | each isClassDefinition].
	dict := Dictionary new.
	classes do: [:each | 
		| parent myself |
		parent := dict 
			at: each superclassName 
			ifAbsentPut: [nil -> Set new].
		myself := dict
			at: each className
			ifAbsentPut: [nil -> Set new].
		myself key: each.
		parent value add: myself.
	].
	dict := dict reject: [:each | each key isNil].
	parents := dict keys.
	dict copy do: [:each | 
		(parents includes: each key superclassName) ifTrue: [
			dict removeKey: each key className.
		].
	].
	queue := (dict asSortedCollection: [:a :b | a key <= b key]) asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| assoc children def |
		assoc := queue removeFirst.
		children := (assoc value asSortedCollection: [:a :b | a key <= b key]) asOrderedCollection.
		queue := children , queue.
		def := assoc key.
		aStream 
			nextPutAll: '! - ' , def className; lf;
			nextPutAll: '! - ' , def commentStamp; lf;
			nextPutAll: 'run'; lf;
			nextPutAll: '(' , def superclassName; lf;
			tab; nextPutAll: 'subclass: ' , def className printString; lf;
			tab; nextPutAll: 'instVarNames: #(' , def instanceVariablesString , ')'; lf;
			tab; nextPutAll: 'classVars: #(' , def classVariablesString , ')'; lf;
			tab; nextPutAll: 'classInstVars: #(' , def classInstanceVariablesString , ')'; lf;
			tab; nextPutAll: 'poolDictionaries: #(' , def sharedPoolsString , ')'; lf;
			tab; nextPutAll: 'inDictionary: UserGlobals'; lf;
			tab; nextPutAll: 'instancesInvariant: false'; lf;
			tab; nextPutAll: 'isModifiable: false)'; lf;
			tab; nextPutAll: 'category: ' , def category printString , '.'; lf;
			nextPutAll: 'true.'; lf;
			nextPut: $%; lf;
			yourself.
	].
	methods := aSnapshot definitions select: [:each | each isMethodDefinition].
	methods := methods asSortedCollection.
	classes asSortedCollection do: [:eachClass | 
		| localMethods |
		localMethods := methods select: [:eachMethod | eachClass className = eachMethod className].
		methods removeAll: localMethods.
		aStream
			lf; nextPutAll: '! - *** - ' , eachClass className; lf;
			nextPutAll: 'removeAllClassMethods ' , eachClass className; lf;
			nextPutAll: 'removeAllMethods ' , eachClass className; lf;
			yourself.
		localMethods do: [:eachMethod | 
			| source |
			source := eachMethod source copyReplaceAll: Character cr asString with: Character lf asString.
			aStream
				nextPutAll: 'category: ''' , eachMethod category , ''''; lf;
				nextPutAll: '! - ' , eachMethod timeStamp; lf;
				nextPutAll: (eachMethod classIsMeta ifTrue: ['classMethod: '] ifFalse: ['method: ']) , eachMethod className; lf;
				nextPutAll: source; lf;
				nextPut: $%; lf;
				yourself.
		].
	].
	aStream lf; nextPutAll: '! - *** - loose methods (where class is expected to be already defined)'; lf; lf.
	methods isEmpty ifTrue: [aStream nextPutAll: '! - (none)'; lf; lf].

	methods do: [:eachMethod | 
		| source |
		source := eachMethod source copyReplaceAll: Character cr asString with: Character lf asString.
		aStream
			nextPutAll: 'category: ''' , eachMethod category , ''''; lf;
			nextPutAll: '! - ' , eachMethod timeStamp; lf;
			nextPutAll: (eachMethod classIsMeta ifTrue: ['classMethod: '] ifFalse: ['method: ']) , eachMethod className; lf;
			nextPutAll: source; lf;
			nextPut: $%; lf;
			yourself.
	].

	aStream lf; nextPutAll: '! - *** - class initialization'; lf.
	methods isEmpty ifTrue: [aStream nextPutAll: '! - (none)'; lf; lf].
	classes do: [:each | 
		aStream nextPutAll: 'send ' , each className , ' initialize'; lf.
	].


%

category: 'category'
method: JadeServer
_methodsFor: aClass categories: aList

	| methods |
	methods := IdentitySet new.
	aList do: [:eachCategory | 
		(aClass _includesCategory: eachCategory) ifTrue: [
			(aClass selectorsIn: eachCategory) do: [:eachSelector |
				methods add: (self compiledMethodAt: eachSelector inClass: aClass).
			].
		].
	].
	^methods.


%

category: 'category'
method: JadeServer
_methodsFor: aClass filter: aList isVariables: aBoolean

	^aBoolean 
		ifTrue:	[self _methodsFor: aClass variables: 	aList]
		ifFalse:	[self _methodsFor: aClass categories: aList].

%

category: 'category'
method: JadeServer
_methodsFor: aClass variables: aList

	| methods |
	aList isEmpty ifTrue: [^aClass selectors collect: [:each | self compiledMethodAt: each inClass: aClass]].
	methods := IdentitySet new.
	aClass selectors do: [:each | 
		| method intersect |
		method := self compiledMethodAt: each inClass: aClass.
		intersect := method instVarsAccessed * aList.
		intersect notEmpty ifTrue: [methods add: method].
	].
	^methods.

%

category: 'category'
method: JadeServer
_oopAndStringFor: anObject

	^(self oopOf: anObject) -> anObject printString.

%

category: 'category'
method: JadeServer
_packageNameFor: aCategoryName

	| string mcWorkingCopyClass list |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^''].
	string := aCategoryName asUppercase copyFrom: 2 to: aCategoryName size.
	list := mcWorkingCopyClass allManagers collect: [:each | each packageName].
	list := list select: [:each | (string copyFrom: 1 to: (string size min: each size)) = each asUppercase].
	list isEmpty ifTrue: [^''].
	list size = 1 ifTrue: [^list first].
	^(list asSortedCollection: [:a :b | a size <= b size]) last.

%

category: 'category'
method: JadeServer
_sourceForProcess: gsProcess frame: level

	| frame homeMethod stepPoint keys values gsMethod receiver |
	writeStream := WriteStream on: String new.
	(frame := gsProcess _frameContentsAt: level) isNil ifTrue: [^'No frame found for level ' , level printString].
	gsMethod := frame at: 1.
	stepPoint := self 
		_stepPointFromProcess: gsProcess 
		frame: frame 
		method: gsMethod
		level: level.
	writeStream
		nextPutAll: '<?xml version=''1.0'' ?><frame oop=';
		nextPutAll: (self oopOf: frame) printString printString;
		nextPutAll: ' ipOffset=';
		nextPutAll: (frame at: 2) printString printString;
		nextPutAll: ' frameOffset=';
		nextPutAll: ((frame at: 3) isNil ifTrue: [''] ifFalse: [(frame at: 3) printString]) printString;
		nextPutAll: ' stepPoint=';
		nextPutAll: stepPoint printString printString;
		nextPutAll: '>'; lf;
		yourself.
	receiver := frame at: 10.
	values := OrderedCollection new.
	(self isClientForwarder: receiver) ifTrue: [
		keys := OrderedCollection with: 'clientObject'.
		values add: receiver clientObject.
		receiver := '[aClientForwarder(' , (self oopOf: receiver) printString , ')]'.
	] ifFalse: [
		((receiver isKindOf: BlockClosure) or: [receiver isKindOf: Class]) ifTrue: [
			keys := OrderedCollection new.
		] ifFalse: [
			keys := receiver class allInstVarNames asOrderedCollection collect: [:each | '-' , each].
			1 to: keys size do: [:i |
				values add: (receiver instVarAt: i).
			].
		].
	].
	keys addFirst: #'receiver'.
	values addFirst: receiver.
	keys addAll: (frame at: 9).
	keys := keys reject: [:each | each first == $.].
	values addAll: (frame size >= 11
		ifTrue: [frame copyFrom: 11 to: frame size]
		ifFalse: [#()]).
	1 to: (keys size min: values size) do: [:i | | oop assoc key value |
		key := keys at: i.
		value := values at: i.
		assoc := self _oopAndStringFor: value.
		oop := assoc key.
		value := assoc value.
		value size > 500 ifTrue: [value := (value copyFrom: 1 to: 500) , '...'].
		value := value collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$?] ifFalse: [char]].
		writeStream
			nextPutAll: '<var oop=';
			nextPutAll: oop asString printString;
			nextPutAll: ' name=';
			nextPutAll: key asString printString;
			nextPutAll: ' ><';
			nextPutAll: '![';
			nextPutAll: 'CDATA';
			nextPutAll: '[';
			nextPutAll: value;
			nextPutAll: ']';
			nextPutAll: ']';
			nextPutAll: '></var>'; lf;
			yourself.
	].
	homeMethod := self homeMethodFor: gsMethod.
	writeStream 
		nextPutAll: '<source';
		nextPutAll: ' ><';
		nextPutAll: '![';
		nextPutAll: 'CDATA';
		nextPutAll: '[';
		yourself.
	self _describeMethod: homeMethod.
	writeStream
		nextPutAll: ']';
		nextPutAll: ']';
		nextPutAll: '></source>';
		nextPutAll: '</frame>'; lf;
		yourself.
	^self asAsciiString: writeStream contents.

%

category: 'category'
method: JadeServer
_stepPointFromProcess: gsProcess frame: aFrame method: gsMethod level: anInteger

	self subclassResponsibility.
%

category: 'category'
method: JadeServer
_stepPointsForBreaksInMethod: gsMethod

	^gsMethod _stepPointsFromBreakIpOffsets: gsMethod _breakpointIpOffsets
%

category: 'category'
method: JadeServer
_trimStackOf: aGsProcess toLevel: anInteger

	aGsProcess _trimStackToLevel: anInteger.
	^aGsProcess.

%

! Class implementation for 'JadeServer64bit'

!		Instance methods for 'JadeServer64bit'

category: 'category'
method: JadeServer64bit
addSessionWithId: anInteger toStream: aStream

	[
		super
			addSessionWithId: anInteger
			toStream: aStream.
	] on: Error do: [:ex | 
		ex resume: '?????'.
	].

%

category: 'category'
method: JadeServer64bit
addUser: aUserProfile toStream: aStream

	[
		super
			addUser: aUserProfile 
			toStream: aStream.
	] on: Error do: [:ex | 
		aStream lf.
		ex return.
	].

%

category: 'category'
method: JadeServer64bit
asString: anObject

	^[
		super asString: anObject.
	] on: Error do: [:ex | 
		ex return: '???'.
	].

%

category: 'category'
method: JadeServer64bit
homeMethodFor: aGsMethod

	^[aGsMethod homeMethod] on: Error do: [:ex | ex return: aGsMethod]
%

category: 'category'
method: JadeServer64bit
installTranscript

	[
		super installTranscript.
	] on: Error do: [:ex | 
		ex return.
	].

%

category: 'category'
method: JadeServer64bit
mcInitialsA: aString

	^[
		super mcInitialsA: aString.
		true.
	] on: Error do: [:ex | 
		ex return: false.
	].

%

category: 'category'
method: JadeServer64bit
metacelloConfigurations

	| list |
	list := Array new.
	GsSession currentSession symbolList do: [:eachSymbolList | 
		eachSymbolList do: [:eachGlobal | 
			(eachGlobal isBehavior and: [
			(eachGlobal class includesSelector: #'isMetacelloConfig') and: [
			eachGlobal isMetacelloConfig]]) ifTrue: [list add: eachGlobal].
		].
	].
	^list

%

category: 'category'
method: JadeServer64bit
objectForOop: anInteger

	^Object _objectForOop: anInteger.

%

category: 'category'
method: JadeServer64bit
recompile: aMethod withSource: aString
	| result behavior |
	behavior := aMethod inClass.
	((System myUserProfile resolveSymbol: #UserGlobals) value at: #rowanCompile ifAbsent: [false])
		ifTrue: 
			[ [ behavior rwCompileMethod: aString
				category: (self _behavior: behavior categoryOfSelector: aMethod selector) ]
					on: RwExecuteClassInitializeMethodsAfterLoadNotification
					do: [:ex | ex resume: false ].
			Rowan serviceClass rowanFixMe.	"need to handle compile errors"
			^true]
		ifFalse: 
			[result := aMethod _recompileWithSource: aString.
			result isNil ifTrue: [^true].	"Bug 41195 returns nil if success so assume it is the same method"
			^result]
%

category: 'category'
method: JadeServer64bit
sbRemoveKey: aSymbol fromDictionary: aDictionary

	| aClass array |
	aClass := aDictionary at: aSymbol.
	array := self dictionaryAndSymbolOf: aClass.
	((array at: 1) == aDictionary and: [
		(array at: 2) == aSymbol and: [
		(Class canUnderstand: #'removeFromSystem') and: [	"mark package as modified"
		aClass removeFromSystem]]]) ifFalse: [
			aDictionary removeKey: aSymbol.
		].
%

category: 'category'
method: JadeServer64bit
sourceForProcess: gsProcess frame: level

	^[
		self
			_sourceForProcess: gsProcess 
			frame: level.
	] on: Error do: [:ex | 
			ex return: (self asAsciiString: ('?????' , ex description , Character cr asString , (GsProcess stackReportToLevel: 50))).
	].

%

category: 'category'
method: JadeServer64bit
streamType

	| isLegacy type |
	type := Globals at: #'PositionableStream_position' ifAbsent: [#'Legacy'].
	(Globals includesKey: #'PositionableStreamLegacy') ifFalse: [^type].
	isLegacy := PositionableStream isLegacyStreamImplementation.
	(type = #'Legacy') == isLegacy ifTrue: [^type].
	self error: 'Inconsistent PositionableStream configuration'.

%

category: 'category'
method: JadeServer64bit
stringType

	^(Globals at: #StringConfiguration ifAbsent: [String]) name

%

category: 'category'
method: JadeServer64bit
systemBrowser: aString

	[
		^super systemBrowser: aString.
	] on: Error do: [:ex |
		readStream := nil.
		ex pass.
	].

%

category: 'category'
method: JadeServer64bit
systemBrowserSTON: aString

	[
		^super systemBrowserSTON: aString.
	] on: Error do: [:ex |
		readStream := nil.
		ex pass.
	].

%

category: 'category'
method: JadeServer64bit
_oopAndStringFor: anObject

	^[
		super _oopAndStringFor: anObject.
	] on: Error do: [:ex | 
		ex return: 0 -> ('<ERROR IN #printString for ' , anObject class name , '>').
	].

%

category: 'category'
method: JadeServer64bit
_stepPointFromProcess: gsProcess frame: aFrame method: gsMethod level: anInteger

	^gsProcess _stepPointAt: anInteger

%

category: 'category'
method: JadeServer64bit
_trimStackOf: aGsProcess toLevel: anInteger

	^[
		super
			_trimStackOf: aGsProcess 
			toLevel: anInteger.
	] on: Error do: [:ex | 
		self 
			_trimStackOf: aGsProcess 
			toLevel: anInteger - 1.
		ex return.
	].

%

! Class implementation for 'JadeServer64bit24'

!		Instance methods for 'JadeServer64bit24'

category: 'category'
method: JadeServer64bit24
inspect: anObject

	^(self isClientForwarder: anObject)
		ifTrue: [self inspectClientForwarder: anObject]
		ifFalse: [super inspect: anObject].

%

category: 'category'
method: JadeServer64bit24
inspectClientForwarder: anObject

	| stream |
	(stream := WriteStream on: String new)
		nextPutAll: 'ClientForwarder'; tab;
		yourself.
	(self oopOf: anObject) printOn: stream.
	stream lf;
		nextPut: $1; lf;
		nextPutAll: 'clientObject'; tab;
		yourself.
	self print: (self oopOf: anObject clientObject) on: stream.
	stream lf; nextPutAll: (self printStringOf: anObject).
	^stream contents.

%

category: 'category'
method: JadeServer64bit24
isClientForwarder: anObject

	^(Reflection classOf: anObject) name == #'ClientForwarder' 

%

category: 'category'
method: JadeServer64bit24
oopOf: anObject

	^Reflection oopOf: anObject.

%

category: 'category'
method: JadeServer64bit24
printStringOf: anObject

	^(self isClientForwarder: anObject)
		ifFalse: [anObject printString]
		ifTrue: ['aClientForwarder(' , anObject clientObject printString , ')'].

%

category: 'category'
method: JadeServer64bit24
registerOBNotificationsForPlatform: platform clientForwarder: clientForwarder

	super
		registerOBNotificationsForPlatform: platform 
		clientForwarder: clientForwarder.
	platform 
		registerMultipleChoiceClientForwarder: clientForwarder;
		yourself.

%

! Class implementation for 'JadeServer64bit3x'

!		Instance methods for 'JadeServer64bit3x'

category: 'category'
method: JadeServer64bit3x
addMethodCategoryNamesToMethodFilters

	classList do: [:each | 
		each 
			env: environment 
			categorysDo:[ :categName :selectors | methodFilters add: categName ].
	].

%

category: 'category'
method: JadeServer64bit3x
addProcess: aProcess to: aStream withStatus: aString scheduler: aScheduler

	| instVarNumber modeInfo modeInfo_forked modeInfo_terminated |
	super addProcess: aProcess to: aStream withStatus: aString scheduler: aScheduler.
	(instVarNumber := GsProcess instVarNames indexOf: #'modeInfo') == 0 ifTrue: [^self].
	modeInfo := aProcess instVarAt: instVarNumber.
	(modeInfo_forked := GsProcess _classVars at: #'ModeInfo_forked' ifAbsent: [nil]) ifNil: [^self].
	(modeInfo_terminated := GsProcess _classVars at: #'ModeInfo_terminated' ifAbsent: [nil]) ifNil: [^self].
	aStream
"9"		nextPutAll: (0 < (modeInfo bitAnd: modeInfo_forked) ifTrue: ['forked'] ifFalse: ['main']); tab;
"10"		nextPutAll: (0 < (modeInfo bitAnd: modeInfo_terminated) ifTrue: ['terminated'] ifFalse: ['']); tab;
		yourself.

%

category: 'category'
method: JadeServer64bit3x
asString: anObject

	(anObject isKindOf: String) ifTrue: [^anObject].
	(anObject _class name == #'ClientForwarder') ifTrue: [^'aClientForwarder(' , (self asString: anObject clientObject) , ')'].
	^[
		anObject printString.
	] on: Error , Admonition do: [:ex | 
		ex return: '<<printString error: ' , ex description , '>>'.
	].

%

category: 'category'
method: JadeServer64bit3x
categoryOfMethod: aMethod

	| category selector |
	(selector := aMethod selector) isNil ifTrue: [^''].
	category := self _behavior: aMethod inClass categoryOfSelector: aMethod selector.
	category ifNil: [category := #'other'].
	^category.

%

category: 'category'
method: JadeServer64bit3x
class: aClass includesSelector: aSelector

	^aClass includesSelector: aSelector asSymbol environmentId: environment.

%

category: 'category'
method: JadeServer64bit3x
compiledMethodAt: aSymbol inClass: aClass

	| method | 
	method := aClass compiledMethodAt: aSymbol environmentId: environment.
	method ifNil: [self error: 'Lookup failed for selector ' , aSymbol , ' inClass ' , aClass name , ' in environment ' , environment printString].
	^method.
%

category: 'category'
method: JadeServer64bit3x
compileMethod: methodString behavior: aBehavior symbolList: aSymbolList inCategory: categorySymbol
	"returns (nil -> anArrayOfErrors) or (aGsNMethod -> compilerWarnings) or (aGsNMethod -> nil)"

	| method warnings | 

	[[((System myUserProfile resolveSymbol: #UserGlobals) value at: #rowanCompile ifAbsent:[false]) ifTrue:[
			[ method := aBehavior rwCompileMethod: methodString category: categorySymbol ]
					on: RwExecuteClassInitializeMethodsAfterLoadNotification
					do: [:ex | ex resume: false ] ]
		ifFalse:[
			method := aBehavior
			compileMethod: methodString
			dictionaries: aSymbolList
			category: categorySymbol
			environmentId: environment].
	] on: CompileError do: [:ex |
		^nil -> (ex gsArguments at: 1)
	]] on: CompileWarning do: [:ex |
		warnings := ex gsArguments at: 1.
		ex resume.
	].
	^[	
		(self compiledMethodAt: method key selector inClass: aBehavior) -> warnings.
	] on: Error do: [:ex | 
		ex return: method -> warnings.
	].
%

category: 'category'
method: JadeServer64bit3x
debugString: aString fromContext: anObject environment: anInteger

	[
		^super debugString: aString fromContext: anObject environment: anInteger.
	] on: CompileWarning do: [:ex | 
		ex resume.
	].

%

category: 'category'
method: JadeServer64bit3x
describeMethod: aMethod
	"Provide info needed to create a GsMethod in Jade client"

	(aMethod class name == #'GsNMethod') ifFalse: [self error: 'Expected a GsNMethod but got ' , aMethod class name].
	^super describeMethod: aMethod
%

category: 'category'
method: JadeServer64bit3x
environment

	^environment
%

category: 'category'
method: JadeServer64bit3x
environment: anInteger

	environment := anInteger.

%

category: 'category'
method: JadeServer64bit3x
environmentForMethod: aGsNMethod

	^aGsNMethod environmentId
%

category: 'category'
method: JadeServer64bit3x
executeString: aString fromContext: anObject environment: anInteger

	[
		^super executeString: aString fromContext: anObject environment: anInteger.
	] on: CompileWarning do: [:ex | 
		ex resume.
	].

%

category: 'category'
method: JadeServer64bit3x
homeMethodFor: aGsMethod

	| result |
	result := super homeMethodFor: aGsMethod.
	(result class name == #'GsNMethod') ifFalse: [self error: 'Expected a GsNMethod but got ' , result class name].
	^result
%

category: 'category'
method: JadeServer64bit3x
initialize

	super initialize.
	environment := 0.

%

category: 'category'
method: JadeServer64bit3x
inspect: anObject
	| dynamic dynamicSize indexedSize instVarNames namedSize stream string isRcBag |
	(self isClientForwarder: anObject) ifTrue: [^self inspectClientForwarder: anObject].
	(stream := WriteStream on: String new)
		nextPutAll: anObject class name; tab;
		yourself.
	(self oopOf: anObject) printOn: stream.
	stream lf.
	(anObject isKindOf: Dictionary superclass) ifTrue: [^self inspectDictionary: anObject on: stream].
	instVarNames := anObject class allInstVarNames.
	namedSize := instVarNames size.
	dynamic := anObject dynamicInstanceVariables.
	dynamicSize := dynamic size.
	isRcBag := anObject class name == #RcIdentityBag.
	indexedSize := (anObject class isNsc or: [anObject class isIndexable]) ifFalse: [
		0.
	] ifTrue: [
		isRcBag ifTrue: [ anObject size min: 200] ifFalse: [(anObject _primitiveSize - namedSize)  min: 200].
	].
	
	namedSize + dynamicSize + indexedSize printOn: stream.
	stream lf.
	1 to: instVarNames size do: [:i | 
		stream nextPutAll: (instVarNames at: i); tab.
		self print: (self oopOf: (anObject instVarAt: i)) on: stream.
		stream lf.
	].
	1 to: dynamicSize do: [:i | 
		stream nextPutAll: (dynamic at: i); tab.
		self print: (self oopOf: (anObject dynamicInstVarAt: (dynamic at: i))) on: stream.
		stream lf.
	].
	isRcBag
		ifTrue: [ |aBag |
			aBag := anObject _asIdentityBag.
			1 to: indexedSize do: [:i | 
				i printOn: stream.
				stream tab.
				self print: (self oopOf: (aBag _at: i )) on: stream.
				stream lf]]
		ifFalse: [
			1 to: indexedSize do: [:i | 
				i printOn: stream.
				stream tab.
				self print: (self oopOf: (anObject _primitiveAt: i + namedSize)) on: stream.
				stream lf] ].

	(string := anObject printString) size > 100000 ifTrue: [string := (string copyFrom: 1 to: 100000) , '...'].
	string class == String ifFalse: [
		string := String withAll: (string collect: [:each | (32 <= each codePoint and: [each codePoint <= 255]) ifTrue: [each] ifFalse: [$?]]).
	].
	^stream 
		nextPutAll: string; 
		contents.
%

category: 'category'
method: JadeServer64bit3x
inspectNamedInstanceVariablesOf: anObject on: aStream

	| list dynamic size |
	list := anObject class allInstVarNames.
	dynamic := anObject dynamicInstanceVariables.
	size := list size + dynamic size.
	anObject class format > 0 ifTrue: [
		size := size + (anObject _basicSize min: 200).
	].
	size printOn: aStream.
	aStream lf.
	1 to: list size do: [:i | 
		aStream nextPutAll: (list at: i); tab.
		self print: (self oopOf: (anObject instVarAt: i)) on: aStream.
		aStream lf.
	].
	1 to: dynamic size do: [:i | 
		aStream nextPutAll: (dynamic at: i); tab.
		self print: (self oopOf: (anObject dynamicInstVarAt: (dynamic at: i))) on: aStream.
		aStream lf.
	].

%

category: 'transcript'
method: JadeServer64bit3x
installTranscript

	Transcript class name == #'TranscriptStreamPortable' ifFalse: [^self].
	SessionTemps current at: #'TranscriptStream_SessionStream' put: self.
%

category: 'category'
method: JadeServer64bit3x
keysForDictionary: aDictionary 
	"RubyHash does not implement #'keys' or #'keysDo:'!"

	| keys |
	(aDictionary isKindOf: RubyHash) ifFalse: [^super keysForDictionary: aDictionary].
	keys := Set new.
	aDictionary keysAndValuesDo: [:eachKey :eachValue | keys add: eachKey].
	^keys.

%

category: 'category'
method: JadeServer64bit3x
methodSignatureForSelector: aSymbol
	"Ruby bridge methods can have some strange selectors!"

	| class comma i j method source |
	environment ~~ 1 ifTrue: [^aSymbol].
	class := selectedClass whichClassIncludesSelector: aSymbol environmentId: environment.
	method := class compiledMethodAt: aSymbol environmentId: environment.
	source := (method sourceString subStrings: Character lf) first trimBlanks.
	(4 < source size and: [(source copyFrom: 1 to: 4) = 'def ']) ifTrue: [
		source := source copyFrom: 5 to: source size.
		(source includes: $#) ifTrue: [source := (source copyFrom: 1 to: (source indexOf: $#) - 1) trimBlanks].
		^source.
	].
	(i := aSymbol indexOf: $#) == 0 ifTrue: [^aSymbol].
	source := aSymbol copyFrom: 1 to: i - 1.
	(aSymbol copyFrom: i to: aSymbol size) = '#0__' ifTrue: [^source].
	comma := ''.
	source add: $(.
	j := (aSymbol at: i + 1) asString asNumber.
	1 to: j do: [:k | 
		source 
			add: comma;
			add: 'arg'.
		1 < j ifTrue: [source add: k printString].
		comma := $,.
	].
	(aSymbol at: i + 2) == $* ifTrue: [
		source 
			add: comma;
			add: (0 == j ifTrue: ['args'] ifFalse: ['rest']).
		comma := $,.
	].
	aSymbol last == $& ifTrue: [
		source
			add: comma;
			add: '&block'.
	].
	source add: $).
	^source.

%

category: 'category'
method: JadeServer64bit3x
nameOfFirstDictionaryReferencing: aGlobal

	| list |
	list := self symbolList dictionariesAndSymbolsOf: aGlobal.
	list isEmpty ifTrue: [^''].
	^list first first name
%

category: 'category'
method: JadeServer64bit3x
nextPutAll: anObject

	| exception |
	exception := ClientForwarderSend new 
		receiver: self 
		clientObj: 2
		selector:#'nextPutAll:'
		args: (Array with: (self asString: anObject)).
	exception defaultAction.  "return error direct to GCI"
%

category: 'category'
method: JadeServer64bit3x
objectSecurityPolicyFor: anObject

	^anObject objectSecurityPolicy.

%

category: 'category'
method: JadeServer64bit3x
packagePolicy: aPackagePolicy includesSelector: aSymbol forClass: aClass

	| dict |
	^aPackagePolicy notNil and: [
		(dict := aClass transientMethodDictForEnv: environment) notNil and: [
			dict keys includes: aSymbol.		"includesKey: requires protected mode!"
		].
	].

%

category: 'category'
method: JadeServer64bit3x
sbBrowseMethodsWithPragma: anOrderedCollection

	| methods symbol |
	symbol := anOrderedCollection removeFirst asSymbol.
	methods := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				(Array with: eachGlobal class with: eachGlobal) do: [:eachBehavior | 
					(eachBehavior methodDictForEnv: environment) do: [:eachMethod | 
						(eachMethod pragmas anySatisfy: [:eachPragma | symbol == eachPragma keyword]) ifTrue: [methods add: eachMethod].
					].
				].
			].
		].
	].
	writeStream 
		nextPutAll: 'browseMethodsWithPragma'; lf;
		nextPutAll: (self streamOfMethods: methods);
		yourself.

%

category: 'category'
method: JadeServer64bit3x
sbClassComment: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) thisClass rwComment: self sbNextParagraph trimSeparators.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer64bit3x
sbFileOutMethod: anOrderedCollection

	| aClass |
	aClass := self sbClassFrom: anOrderedCollection.
	writeStream nextPutAll: (aClass fileOutMethod: anOrderedCollection removeFirst asSymbol environmentId: environment).


%

category: 'category'
method: JadeServer64bit3x
sbListMethodPragmas: aList

	| pragmas |
	pragmas := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				(Array with: eachGlobal with: eachGlobal class) do: [:eachBehavior | 
					(eachBehavior methodDictForEnv: environment) do: [:eachMethod | 
						pragmas addAll: (eachMethod pragmas collect: [:eachPragma | eachPragma keyword]).
					].
				].
			].
		].
	].
	pragmas asSortedCollection do: [:each | writeStream nextPutAll: each; tab].
	^pragmas
%

category: 'category'
method: JadeServer64bit3x
sbMethod: anOrderedCollection

	| behavior category string gsMethod |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection notEmpty ifTrue: [anOrderedCollection removeFirst] ifFalse: ['other'].
	string := self sbNextParagraph.
	gsMethod := behavior
		compileMethod: string 
		dictionaries: self symbolList 
		category: category asSymbol 
		environmentId: environment.
	selections 
		at: #'methodCategory' 	put: (self _behavior: gsMethod inClass categoryOfSelector: gsMethod selector) asString;
		at: #'method'			put: gsMethod selector asString;
		yourself.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodBreakPointsFor: aMethod
	"Answers an Array of step points"

	| list array |
	(array := aMethod _allBreakpoints) isNil ifTrue: [^#()].      "{ breakpointNumber1 . method . ipOffset1 . ... }"
	list := Array new.
	1 to: array size by: 3 do:[:k |
		list add: (aMethod
			_stepPointForMeth: (array at: k + 1)
			ip: (array at: k + 2)).
	].
	^list.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodPragmas

	selectedClass notNil ifTrue:[
		methodCommandResult selections add: selectedClass asString].
	methodCommandResult updateMethodPragmas.
	methodCommandResult writeMethodFiltersTo: writeStream. 
	methodCommandResult updateMethodFilterSelections: self nextLineAsList 
		hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodCommandResult selectionNames.
	methodCommandResult writeSelectionsTo: writeStream. 


%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodsByCategories

	| selectors |
	selectors := IdentitySet new.
	classList do: [:eachClass |
		(eachClass selectorsForEnvironment: environment) do: [:eachSelector |
			(methodFilters isEmpty or: [
				| category |
				category := eachClass categoryOfSelector: eachSelector environmentId: environment.
				(category isNil and: [ methodFilters includes: #'other']) or: [ methodFilters includes: category asSymbol]]) ifTrue: [
				| method |
				method := eachClass compiledMethodAt: eachSelector environmentId: environment.
				(method respondsTo: #isRubyBridgeMethod)
					ifTrue: [ 
						method isRubyBridgeMethod ifFalse: [
							selectors add: eachSelector ] ]
					ifFalse: [ selectors add: eachSelector ]
			].
		].
	].
	^selectors.
%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodsByPragmas

	| selectors |
	selectors := IdentitySet new.
	methodFilters isEmpty ifTrue: [^#()].
	(selectedClass selectorsForEnvironment: environment) do: [:eachSelector | 
		| gsMethod |
		gsMethod := selectedClass compiledMethodAt: eachSelector environmentId: environment.
		gsMethod pragmas do: [:eachPragma | 
			( methodFilters includes: eachPragma keyword) ifTrue: [selectors add: eachSelector].
		].
	].
	^selectors.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodsByVariables

	| selectors filters |
	selectors := IdentitySet new.
	filters := IdentitySet withAll: (methodFilters select: [:each | each isSymbol]).
	(selectedClass selectorsForEnvironment: environment) do: [:eachSelector | 
		| gsMethod |
		gsMethod := selectedClass compiledMethodAt: eachSelector environmentId: environment.
		(gsMethod instVarsAccessed * filters) notEmpty ifTrue: [selectors add: eachSelector].
	].
	^selectors.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodStepPointsFor: aMethod
	"Answers an Array of Associations (offset -> selector) indexed by step point"

	|  selectors list |
	(selectors := aMethod _allDebugInfo: 10) ifNil: [^#()].
	list := (self homeMethodFor: aMethod)  _sourceOffsets.
	list := list collect: [:each | 		"exists as far back as 32-bit 6.3.0"
		| index selector |
		selector := ''.
		index := selectors indexOf: each.
		0 < index ifTrue: [selector := selectors at: index + 1].
		each -> selector.
	].
	^list.


%

category: 'category'
method: JadeServer64bit3x
selectedClassOverridesSelector: aSymbol

	^selectedClass superclass notNil and: [(selectedClass superclass whichClassIncludesSelector: aSymbol environmentId: environment) ~~ nil].

%

category: 'transcript'
method: JadeServer64bit3x
uninstallTranscript

	Transcript class name == #'TranscriptStreamPortable' ifFalse: [^self].
	SessionTemps current at: #'TranscriptStream_SessionStream' put: nil.
%

category: 'category'
method: JadeServer64bit3x
_allSelectors

	| allSelectors |
	allSelectors := IdentitySet new.
	self classOrganizer classes do: [:each | 
		allSelectors addAll: (each selectorsForEnvironment: environment); addAll: (each class selectorsForEnvironment: environment).
	].
	^allSelectors
%

category: 'category'
method: JadeServer64bit3x
_behavior: aBehavior categoryOfSelector: aSymbol

	^aBehavior categoryOfSelector: aSymbol environmentId: environment
%

category: 'category'
method: JadeServer64bit3x
_describeMethod: aMethod

	(aMethod class name == #'GsNMethod') ifFalse: [self error: 'Expected a GsNMethod but got ' , aMethod class name].
	^super _describeMethod: aMethod
%

category: 'category'
method: JadeServer64bit3x
_methodsFor: aClass categories: aList

	| methods |
	methods := IdentitySet new.
	aList do: [:eachCategory | 
		(aClass includesCategory: eachCategory) ifTrue: [
			(aClass selectorsIn: eachCategory) do: [:eachSelector |
				methods add: (self compiledMethodAt: eachSelector inClass: aClass).
			].
		].
	].
	^methods.


%

category: 'category'
method: JadeServer64bit3x
_stepPointsForBreaksInMethod: gsMethod
	"Presumably there is a way to do this, just not the same as 32-bit and 64-bit 2.x"

	^#()
%

! Class implementation for 'JadeServer64bit32'

!		Instance methods for 'JadeServer64bit32'

category: 'category'
method: JadeServer64bit32
dictionaryAndSymbolOf: aClass

	| array |
	array := self symbolList dictionariesAndSymbolsOf: aClass.
	^array isEmpty
		ifTrue: [nil]
		ifFalse: [array first].

%

category: 'category'
method: JadeServer64bit32
dictionaryAndSymbolOf: aClass forUser: aUserProfile

	| array |
	array := aUserProfile symbolList dictionariesAndSymbolsOf: aClass.
	^array isEmpty
		ifTrue: [nil]
		ifFalse: [array first].

%

category: 'category'
method: JadeServer64bit32
gsPackagePolicy

	| class |
	class := self gsPackagePolicyClass.
	class isNil ifTrue: [^nil].
	class enabled ifFalse: [^nil].
	^class current

%

! Class implementation for 'RBParser'

!		Class methods for 'RBParser'

category: 'instance creation'
classmethod: RBParser
new

	^self basicNew initialize
%

category: 'accessing'
classmethod: RBParser
parseExpression: aString 
	^self parseExpression: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseExpression: aString onError: aBlock 
	| node parser |
	parser := self new.
	parser errorBlock: aBlock.
	parser initializeParserWith: aString.
	node := parser parseExpression: aString.
	^(node statements size == 1 and: [node temporaries isEmpty]) 
		ifTrue: [node statements first]
		ifFalse: [node]
%

category: 'accessing'
classmethod: RBParser
parseMethod: aString 
	^self parseMethod: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseMethod: aString onError: aBlock 
	| parser |
	parser := self new.
	parser errorBlock: aBlock.
	parser initializeParserWith: aString.
	^parser parseMethod: aString
%

category: 'parsing'
classmethod: RBParser
parseMethodPattern: aString 
	| parser |
	parser := self new.
	parser errorBlock: [:error :position | ^nil].
	parser initializeParserWith: aString.
	^parser parseMessagePattern selector
%

category: 'accessing'
classmethod: RBParser
parseRewriteExpression: aString 
	^self parseRewriteExpression: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseRewriteExpression: aString onError: aBlock 
	^RBPatternParser parseExpression: aString onError: aBlock
%

category: 'accessing'
classmethod: RBParser
parseRewriteMethod: aString 
	^self parseRewriteMethod: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseRewriteMethod: aString onError: aBlock 
	^RBPatternParser parseMethod: aString onError: aBlock
%

!		Instance methods for 'RBParser'

category: 'private'
method: RBParser
addCommentsTo: aNode
	aNode comments: aNode comments , comments.
	comments := OrderedCollection new
%

category: 'private-classes'
method: RBParser
arrayNodeClass
	^ RBArrayNode
%

category: 'private-classes'
method: RBParser
assignmentNodeClass
	^ RBAssignmentNode
%

category: 'testing'
method: RBParser
atEnd
	^currentToken class == RBToken
%

category: 'private-classes'
method: RBParser
blockNodeClass
	^ RBBlockNode
%

category: 'private-classes'
method: RBParser
cascadeNodeClass
	^ RBCascadeNode
%

category: 'error handling'
method: RBParser
errorBlock
	^errorBlock isNil ifTrue: [[:message :position | ]] ifFalse: [errorBlock]
%

category: 'accessing'
method: RBParser
errorBlock: aBlock 
	errorBlock := aBlock.
	scanner notNil ifTrue: [scanner errorBlock: aBlock]
%

category: 'error handling'
method: RBParser
errorPosition
	^currentToken start
%

category: 'initialize-release'
method: RBParser
initialize
	comments := OrderedCollection new
%

category: 'accessing'
method: RBParser
initializeParserWith: aString 
	source := aString.
	self scanner: (self scannerClass on: aString readStreamPortable
				errorBlock: self errorBlock)
%

category: 'private-classes'
method: RBParser
literalArrayNodeClass
	^ RBLiteralArrayNode
%

category: 'private-classes'
method: RBParser
literalNodeClass
	^ RBLiteralNode
%

category: 'private-classes'
method: RBParser
messageNodeClass
	^ RBMessageNode
%

category: 'private-classes'
method: RBParser
methodNodeClass
	^ RBMethodNode
%

category: 'private'
method: RBParser
nextToken
	^nextToken isNil ifTrue: [nextToken := scanner next] ifFalse: [nextToken]
%

category: 'private-parsing'
method: RBParser
parseArgs
	| args |
	args := OrderedCollection new.
	[currentToken isIdentifier] whileTrue: [args add: self parseVariableNode].
	^args
%

category: 'private-parsing'
method: RBParser
parseArray
  | position node |
  position := currentToken start.
  self step.
  (currentToken isSpecial and: [ currentToken value = $: ])
    ifTrue: [ ^self parseQueryBlock: position ].
  node := self arrayNodeClass new.
  node left: position.
  self parseStatementList: false into: node.
  (currentToken isSpecial and: [ currentToken value = $} ])
    ifFalse: [ self parserError: 'expected }' ].
  node right: currentToken start.
  self step.
  ^ node
%

category: 'private-parsing'
method: RBParser
parseAssignment
	"Need one token lookahead to see if we have a ':='. This method could 
	make it possible to assign the literals true, false and nil."

	| node position |
	(currentToken isIdentifier and: [self nextToken isAssignment]) 
		ifFalse: [^self parseCascadeMessage].
	node := self parseVariableNode.
	position := currentToken start.
	self step.
	^self assignmentNodeClass 
		variable: node
		value: self parseAssignment
		position: position
%

category: 'private-parsing'
method: RBParser
parseBinaryMessage
	| node |
	node := self parseUnaryMessage.
	
	[currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].
	currentToken isBinary] 
			whileTrue: [node := self parseBinaryMessageWith: node].
	^node
%

category: 'private-parsing'
method: RBParser
parseBinaryMessageWith: aNode 
	| binaryToken |
	binaryToken := currentToken.
	self step.
	^self messageNodeClass 
		receiver: aNode
		selectorParts: (Array with: binaryToken)
		arguments: (Array with: self parseUnaryMessage)
%

category: 'private-parsing'
method: RBParser
parseBinaryPattern
	| binaryToken node args |
	currentToken isBinary
		ifFalse: [self parserError: 'Message pattern expected'].
	binaryToken := currentToken.
	self step.
	args := Array with: self parseVariableNode.
	node := self methodNodeClass
		selectorParts: (Array with: binaryToken)
		arguments: args.
	node comments: node comments , args last comments.
	args last comments: nil.
	^node
%

category: 'private-parsing'
method: RBParser
parseBinaryPragma
	| binaryToken |
	currentToken isBinary 
		ifFalse: [ self parserError: 'Message pattern expected' ].
	binaryToken := currentToken.
	self step.
	^ self pragmaNodeClass
		selectorParts: (Array with: binaryToken)
		arguments: (Array with: self parsePragmaLiteral)
%

category: 'private-parsing'
method: RBParser
parseBlock
	| position node |
	position := currentToken start.
	self step.
	node := self blockNodeClass new. 
	self parseBlockArgsInto: node.
	node left: position.
	node body: (self parseStatements: false).
	(currentToken isSpecial and: [currentToken value = $]])
		ifFalse: [self parserError: ''']'' expected'].
	node right: currentToken start.
	self step.
	^node
%

category: 'private-parsing'
method: RBParser
parseBlockArgsInto: node 
	| verticalBar args colons |
	args := OrderedCollection new: 2.
	colons := OrderedCollection new: 2.
	verticalBar := false.
	[currentToken isSpecial and: [currentToken value = $:]] whileTrue: 
			[colons add: currentToken start.
			self step.	":"
			verticalBar := true.
			args add: self parseVariableNode].
	verticalBar 
		ifTrue: 
			[currentToken isBinary 
				ifTrue: 
					[node bar: currentToken start.
					currentToken value = #| 
						ifTrue: [self step]
						ifFalse: 
							[currentToken value = #'||' 
								ifTrue: 
									["Hack the current token to be the start 
									of temps bar"

									currentToken
										value: #|;
										start: currentToken start + 1]
								ifFalse: [self parserError: '''|'' expected']]]
				ifFalse: 
					[(currentToken isSpecial and: [currentToken value = $]]) 
						ifFalse: [self parserError: '''|'' expected']]].
	node
		arguments: args;
		colons: colons.
	^node
%

category: 'private-parsing'
method: RBParser
parseCascadeMessage
	| node receiver messages semicolons |
	node := self parseKeywordMessage.
	(currentToken isSpecial 
		and: [currentToken value = $; and: [node isMessage]]) ifFalse: [^node].
	receiver := node receiver.
	messages := OrderedCollection new: 3.
	semicolons := OrderedCollection new: 3.
	messages add: node.
	[currentToken isSpecial and: [currentToken value = $;]] whileTrue: 
			[semicolons add: currentToken start.
			self step.
			messages add: (currentToken isIdentifier 
						ifTrue: [self parseUnaryMessageWith: receiver]
						ifFalse: 
							[currentToken isKeyword 
								ifTrue: [self parseKeywordMessageWith: receiver]
								ifFalse: 
									[| temp |
									currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].
									currentToken isBinary ifFalse: [self parserError: 'Message expected'].
									temp := self parseBinaryMessageWith: receiver.
									temp == receiver ifTrue: [self parserError: 'Message expected'].
									temp]])].
	^self cascadeNodeClass messages: messages semicolons: semicolons
%

category: 'accessing'
method: RBParser
parseExpression: aString 
	| node |
	node := self parseStatements: false.
	(RBMethodNode selector: #noMethod body: node) source: aString.	"Make the sequence node have a method node as its parent"
	self atEnd ifFalse: [self parserError: 'Unknown input at end'].
	^node
%

category: 'private-parsing'
method: RBParser
parseKeywordMessage
	^self parseKeywordMessageWith: self parseBinaryMessage
%

category: 'private-parsing'
method: RBParser
parseKeywordMessageWith: node 
	| args isKeyword keywords |
	args := OrderedCollection new: 3.
	keywords := OrderedCollection new: 3.
	isKeyword := false.
	[currentToken isKeyword] whileTrue: 
			[keywords add: currentToken.
			self step.
			args add: self parseBinaryMessage.
			isKeyword := true].
	^isKeyword 
		ifTrue: 
			[self messageNodeClass 
				receiver: node
				selectorParts: keywords
				arguments: args]
		ifFalse: [node]
%

category: 'private-parsing'
method: RBParser
parseKeywordPattern
	| keywords args node |
	keywords := OrderedCollection new.
	args := OrderedCollection new.
	[currentToken isKeyword]
		whileTrue:
			[keywords add: currentToken.
			self step.
			args add: self parseVariableNode].
	node := self methodNodeClass
		selectorParts: keywords
		arguments: args.
	node comments: (node comments, args last comments).
	args last comments: nil.
	^node
%

category: 'private-parsing'
method: RBParser
parseKeywordPragma
	| keywords arguments |
	keywords := OrderedCollection new: 2.
	arguments := OrderedCollection new: 2.
	[ currentToken isKeyword ] whileTrue: [
		keywords addLast: currentToken.
		self step.
		arguments addLast: self parsePragmaLiteral ].
	^ self pragmaNodeClass selectorParts: keywords arguments: arguments
%

category: 'private-parsing'
method: RBParser
parseLiteralArray
	| stream start stop |
	start := currentToken start.
	stream := WriteStreamPortable on: Array new.
	self step.
	[self atEnd or: [currentToken isSpecial and: [currentToken value = $)]]] 
		whileFalse: [stream nextPut: self parseLiteralArrayObject].
	(currentToken isSpecial and: [currentToken value = $)]) 
		ifFalse: [self parserError: ''')'' expected'].
	stop := currentToken stop.
	self step.
	^self literalArrayNodeClass 
		startPosition: start
		contents: stream contents
		stopPosition: stop
		isByteArray: false
%

category: 'private-parsing'
method: RBParser
parseLiteralArrayObject
	currentToken isSpecial 
		ifTrue: 
			[currentToken value = $( ifTrue: [^self parseLiteralArray].
			"currentToken value == $[ ifTrue: [^self parseLiteralByteArray]"].
	currentToken isLiteralArrayToken 
		ifTrue: 
			[^currentToken isForByteArray 
				ifTrue: [self parseLiteralByteArray]
				ifFalse: [self parseLiteralArray]].
	currentToken isLiteralToken ifFalse: [self patchLiteralArrayToken].
	^self parsePrimitiveLiteral
%

category: 'private-parsing'
method: RBParser
parseLiteralByteArray
	| stream start stop |
	start := currentToken start.
	stream := WriteStreamPortable on: Array new.
	self step.
	[self atEnd or: [currentToken isSpecial and: [currentToken value = $]]]] 
		whileFalse: [stream nextPut: self parseLiteralByteArrayObject].
	(currentToken isSpecial and: [currentToken value = $]]) 
		ifFalse: [self parserError: ''']'' expected'].
	stop := currentToken stop.
	self step.
	^self literalArrayNodeClass 
		startPosition: start
		contents: stream contents
		stopPosition: stop
		isByteArray: true
%

category: 'private-parsing'
method: RBParser
parseLiteralByteArrayObject
	(currentToken isLiteralToken and: 
			[currentToken value _isInteger and: [currentToken value between: 0 and: 255]]) 
		ifFalse: [self parserError: 'Expecting 8-bit integer'].
	^self parsePrimitiveLiteral
%

category: 'private-parsing'
method: RBParser
parseMessagePattern
	currentToken isLiteralToken ifTrue: [self patchLiteralMessage].
	^currentToken isIdentifier 
		ifTrue: [self parseUnaryPattern]
		ifFalse: 
			[currentToken isKeyword 
				ifTrue: [self parseKeywordPattern]
				ifFalse: [self parseBinaryPattern]]
%

category: 'private-parsing'
method: RBParser
parseMethod
	| methodNode | 
	methodNode := self parseMessagePattern.
	self parsePragmas.
	self addCommentsTo: methodNode.
	methodNode body: (self parseStatements: true).
	pragmas isNil
		ifFalse: [ methodNode pragmas: pragmas ].
	^methodNode
%

category: 'accessing'
method: RBParser
parseMethod: aString 
	| node |
	node := self parseMethod.
	self atEnd ifFalse: [self parserError: 'Unknown input at end'].
	node source: aString.
	^node
%

category: 'private-parsing'
method: RBParser
parseNegatedNumber
	| token |
	(self nextToken isLiteral not or: [ self nextToken realValue isNumber not ])
		ifTrue: [ self parserError: 'only numbers may be negated' ].
	token := RBLiteralToken value: self nextToken realValue negated start: currentToken start stop: nextToken stop.
	self step; step.
	^ self literalNodeClass literalToken: token
%

category: 'private-parsing'
method: RBParser
parseParenthesizedExpression
	| leftParen node |
	leftParen := currentToken start.
	self step.
	node := self parseAssignment.
	^(currentToken isSpecial and: [currentToken value = $)])
		ifTrue: 
			[node addParenthesis: (leftParen to: currentToken start).
			self step.
			node]
		ifFalse: [self parserError: ''')'' expected']
%

category: 'private-parsing'
method: RBParser
parsePragma
  ^ currentToken isIdentifier
    ifTrue: [ 
      currentToken value = 'protected'
        ifTrue: [ self parseProtectedPragma ]
        ifFalse: [ self parseUnaryPragma ] ]
    ifFalse: [ 
      currentToken isKeyword
        ifTrue: [ self parseKeywordPragma ]
        ifFalse: [ self parseBinaryPragma ] ]
%

category: 'private-parsing'
method: RBParser
parsePragmaLiteral
	^ self parseLiteralArrayObject
%

category: 'private-parsing'
method: RBParser
parsePragmas
	| pragma start |
	[ currentToken isBinary and: [ currentToken value = #< ] ] whileTrue: [
		start := currentToken start.
		self step.
		pragma := self parsePragma.
		(currentToken isBinary and: [ currentToken value = #> ]) 
			ifFalse: [ self parserError: '''>'' expected' ].
		pragma left: start; right: currentToken start.
		pragmas isNil
			ifTrue: [ pragmas := OrderedCollection new ].
		pragmas addLast: pragma.
		self step ]
%

category: 'private-parsing'
method: RBParser
parsePrimitiveIdentifier
	| token node |
	token := currentToken.
	self step.
	node := self variableNodeClass identifierToken: token.
	self addCommentsTo: node.
	^node
%

category: 'private-parsing'
method: RBParser
parsePrimitiveLiteral
	| token |
	token := currentToken.
	self step.
	^self literalNodeClass literalToken: token
%

category: 'private-parsing'
method: RBParser
parsePrimitiveObject
	currentToken isIdentifier ifTrue: [^self parsePrimitiveIdentifier].
	(currentToken isLiteralToken and: [currentToken isMultiKeyword not]) 
		ifTrue: [^self parsePrimitiveLiteral].
	currentToken isLiteralArrayToken 
		ifTrue: 
			[^currentToken isForByteArray 
				ifTrue: [self parseLiteralByteArray]
				ifFalse: [self parseLiteralArray]].
	currentToken isSpecial 
		ifTrue: 
			[currentToken value = $[ ifTrue: [^self parseBlock].
			currentToken value = $( ifTrue: [^self parseParenthesizedExpression].
			currentToken value = ${ ifTrue: [^self parseArray]].
	(currentToken isBinary and: [ currentToken value = #- ]) 
		ifTrue: [ ^self parseNegatedNumber ].
	self parserError: 'Variable expected'
%

category: 'private-parsing'
method: RBParser
parseProtectedPragma
  "encoutered 'protected' as first token in pragma"

  self step.
  currentToken isKeyword
    ifFalse: [ ^ self pragmaNodeClass selectorParts: (Array with: 'protected') arguments: #() ].
  ^ self parseKeywordPragma
    isProtected: true;
    yourself
%

category: 'private-parsing'
method: RBParser
parseQueryBlock: startPosition
  | position node |
  position := startPosition.
  node := self queryBlockNodeClass new.
  self parseBlockArgsInto: node.
  node left: position.
  node body: (self parseStatements: false).
  (currentToken isSpecial and: [ currentToken value = $} ])
    ifFalse: [ self parserError: '''}'' expected' ].
  node right: currentToken start.
  self step.
  ^ node
%

category: 'error handling'
method: RBParser
parserError: aString 
	"Evaluate the block. If it returns raise an error"

	self errorBlock value: aString value: self errorPosition.
	self error: aString
%

category: 'private-parsing'
method: RBParser
parseStatementList: pragmaBoolean into: sequenceNode 
	| statements return periods returnPosition node |
	return := false.
	statements := OrderedCollection new.
	periods := OrderedCollection new.
	self addCommentsTo: sequenceNode.
	pragmaBoolean ifTrue: [self parsePragmas].
	[currentToken isSpecial and: [currentToken value = $.]] whileTrue: 
		[periods add: currentToken start.
		self step].
	[self atEnd 
		or: [currentToken isSpecial and: ['])}' includes: currentToken value]]] 
			whileFalse: 
				[return ifTrue: [self parserError: 'End of statement list encounted'].
				(currentToken isSpecial and: [currentToken value = $^]) 
					ifTrue: 
						[returnPosition := currentToken start.
						self step.
						node := self returnNodeClass return: returnPosition
									value: self parseAssignment.
						statements add: node.
						return := true]
					ifFalse: 
						[node := self parseAssignment.
						statements add: node].
				(currentToken isSpecial and: [currentToken value = $.]) 
					ifTrue: 
						[periods add: currentToken start.
						self step.
						self addCommentsTo: node]
					ifFalse: [return := true].
				[currentToken isSpecial and: [currentToken value = $.]] whileTrue: 
					[periods add: currentToken start.
					self step]].
	statements notEmpty ifTrue: [self addCommentsTo: statements last].
	sequenceNode
		statements: statements;
		periods: periods.
	^sequenceNode
%

category: 'private-parsing'
method: RBParser
parseStatements: pragmaBoolean 
	| args leftBar rightBar |
	args := #().
	leftBar := rightBar := nil.
	currentToken isBinary 
		ifTrue: 
			[currentToken value = #| 
				ifTrue: 
					[leftBar := currentToken start.
					self step.
					args := self parseArgs.
					(currentToken isBinary and: [currentToken value = #|]) 
						ifFalse: [self parserError: '''|'' expected'].
					rightBar := currentToken start.
					self step]
				ifFalse: 
					[currentToken value = #'||' 
						ifTrue: 
							[rightBar := (leftBar := currentToken start) + 1.
							self step]]].
	^self parseStatementList: pragmaBoolean
		into: (self sequenceNodeClass 
				leftBar: leftBar
				temporaries: args
				rightBar: rightBar)
%

category: 'private-parsing'
method: RBParser
parseUnaryMessage
	| node |
	node := self parsePrimitiveObject.
	self addCommentsTo: node.
	[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].
	currentToken isIdentifier] 
			whileTrue: [node := self parseUnaryMessageWith: node].
	self addCommentsTo: node.
	^node
%

category: 'private-parsing'
method: RBParser
parseUnaryMessageWith: aNode 
	| selector |
	selector := currentToken.
	self step.
	^self messageNodeClass 
		receiver: aNode
		selectorParts: (Array with: selector)
		arguments: #()
%

category: 'private-parsing'
method: RBParser
parseUnaryPattern
	| selector |
	selector := currentToken.
	self step.
	^self methodNodeClass selectorParts: (Array with: selector) arguments: #()
%

category: 'private-parsing'
method: RBParser
parseUnaryPragma
	| selector |
	selector := currentToken.
	self step.
	^ self pragmaNodeClass selectorParts: (Array with: selector) arguments: #()
%

category: 'private-parsing'
method: RBParser
parseVariableNode
	currentToken isIdentifier 
		ifFalse: [self parserError: 'Variable name expected'].
	^self parsePrimitiveIdentifier
%

category: 'private'
method: RBParser
patchLiteralArrayToken
	(currentToken isIdentifier and: 
			[self nextToken isAssignment 
				and: [currentToken stop + 1 = self nextToken start]]) 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: (currentToken value , ':') asSymbol
						start: currentToken start
						stop: self nextToken start.
			nextToken := RBLiteralToken 
						value: #=
						start: nextToken stop
						stop: nextToken stop.
			^self].
	currentToken isAssignment 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: #':'
						start: currentToken start
						stop: currentToken start.
			nextToken := RBLiteralToken 
						value: #=
						start: currentToken stop
						stop: currentToken stop.
			^self].
	currentToken isSpecial 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: (String with: currentToken value) asSymbol
						start: currentToken start
						stop: currentToken stop.
			^self].
	(currentToken isIdentifier and: [currentToken value includes: $.]) 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: currentToken value
						start: currentToken start
						stop: currentToken stop.
			^self].
	(currentToken isIdentifier 
		or: [currentToken isBinary or: [currentToken isKeyword]]) 
			ifFalse: [^self parserError: 'Invalid token'].
	currentToken := RBLiteralToken 
				value: currentToken value asSymbol
				start: currentToken start
				stop: currentToken stop
%

category: 'private'
method: RBParser
patchLiteralMessage
	currentToken value == true 
		ifTrue: 
			[^currentToken := RBIdentifierToken value: 'true' start: currentToken start].
	currentToken value == false 
		ifTrue: 
			[^currentToken := RBIdentifierToken value: 'false' start: currentToken start].
	currentToken value == nil 
		ifTrue: 
			[^currentToken := RBIdentifierToken value: 'nil' start: currentToken start]
%

category: 'private'
method: RBParser
patchNegativeLiteral
	"Handle the special negative number case for binary message sends."

	currentToken value isNumber 
		ifFalse: [^self].
	currentToken value <= 0 ifFalse: [^self].
	currentToken value = 0 
		ifTrue: 
			[(source notNil and: 
					[source notEmpty 
						and: [(source at: (currentToken start min: source size)) = $-]]) 
				ifFalse: [^self]].
	nextToken := currentToken.
	currentToken := RBBinarySelectorToken value: #- start: nextToken start.
	nextToken value: nextToken value negated.
	(nextToken isKindOf: RBNumberLiteralToken) 
		ifTrue: 
			[nextToken source: (nextToken source copyFrom: 2 to: nextToken source size)].
	nextToken start: nextToken start + 1
%

category: 'private-classes'
method: RBParser
pragmaNodeClass
	^ RBPragmaNode
%

category: 'private-classes'
method: RBParser
queryBlockNodeClass
  ^ RBQueryBlockNode
%

category: 'private-classes'
method: RBParser
returnNodeClass
	^ RBReturnNode
%

category: 'initialize-release'
method: RBParser
scanner: aScanner 
	scanner := aScanner.
	pragmas := nil.
	self initialize.
	self step
%

category: 'accessing'
method: RBParser
scannerClass
	^RBScanner
%

category: 'private-classes'
method: RBParser
sequenceNodeClass
	^ RBSequenceNode
%

category: 'private'
method: RBParser
step
	(currentToken notNil and: [currentToken comments notNil]) 
		ifTrue: [comments addAll: currentToken comments].
	nextToken notNil 
		ifTrue: 
			[currentToken := nextToken.
			nextToken := nil]
		ifFalse: [currentToken := scanner next]
%

category: 'private-classes'
method: RBParser
variableNodeClass
	^ RBVariableNode
%

! Class implementation for 'RBPatternParser'

!		Instance methods for 'RBPatternParser'

category: 'private-classes'
method: RBPatternParser
messageNodeClass
	^RBPatternMessageNode
%

category: 'private-classes'
method: RBPatternParser
methodNodeClass
	^RBPatternMethodNode
%

category: 'private-parsing'
method: RBPatternParser
parseLiteralByteArrayObject
	| node |
	(currentToken isIdentifier and: [currentToken isPatternVariable]) 
		ifTrue: 
			[node := self variableNodeClass identifierToken: currentToken.
			node isLiteralNode 
				ifTrue: 
					[self step.
					^node]].
	^super parseLiteralByteArrayObject
%

category: 'private-parsing'
method: RBPatternParser
parsePatternBlock: aClass 
	| position node |
	position := currentToken start.
	self step.
	node := self parseBlockArgsInto: aClass new.
	node left: position.
	node body: (self parseStatements: false).
	(currentToken isSpecial and: [currentToken value = $}]) 
		ifFalse: [self parserError: '''}'' expected'].
	node right: currentToken start.
	self step.
	^node
%

category: 'private-parsing'
method: RBPatternParser
parsePragmaLiteral
  | node |
  currentToken isPatternBlock
    ifTrue: [ ^ self parsePatternBlock: RBPatternBlockNode ].
  (currentToken isIdentifier and: [ currentToken isPatternVariable ])
    ifTrue: [ 
      node := self variableNodeClass identifierToken: currentToken.
      node isLiteralNode
        ifFalse: [ self error: 'Literal pattern expected' ].
      self step.
      currentToken isPatternBlock
        ifTrue: [ 
          node := (self parsePatternBlock: RBPatternWrapperBlockNode)
            wrappedNode: node;
            yourself ].
      ^ node ].
  ^ super parsePragmaLiteral
%

category: 'private-parsing'
method: RBPatternParser
parsePrimitiveLiteral
	| node |
	(currentToken isIdentifier and: [currentToken isPatternVariable]) 
		ifTrue: 
			[node := self variableNodeClass identifierToken: currentToken.
			node isLiteralNode 
				ifTrue: 
					[self step.
					^node].
			currentToken := RBLiteralToken 
						value: currentToken value asSymbol
						start: currentToken start
						stop: currentToken stop].
	^super parsePrimitiveLiteral
%

category: 'private-parsing'
method: RBPatternParser
parsePrimitiveObject
	currentToken isPatternBlock 
		ifTrue: [^self parsePatternBlock: RBPatternBlockNode].
	^super parsePrimitiveObject
%

category: 'private-parsing'
method: RBPatternParser
parseUnaryMessage
	| node |
	node := self parsePrimitiveObject.
	self addCommentsTo: node.
	
	[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].
	currentToken isPatternBlock 
		ifTrue: 
			[node := (self parsePatternBlock: RBPatternWrapperBlockNode)
						wrappedNode: node;
						yourself].
	currentToken isIdentifier] 
			whileTrue: [node := self parseUnaryMessageWith: node].
	self addCommentsTo: node.
	^node
%

category: 'private'
method: RBPatternParser
patchLiteralArrayToken
	(currentToken isIdentifier and: [currentToken isPatternVariable]) 
		ifTrue: [^self].
	super patchLiteralArrayToken
%

category: 'private-classes'
method: RBPatternParser
pragmaNodeClass
	^RBPatternPragmaNode
%

category: 'accessing'
method: RBPatternParser
scannerClass
	^RBPatternScanner
%

category: 'private-classes'
method: RBPatternParser
variableNodeClass
	^RBPatternVariableNode
%

! Class implementation for 'RBParseTreeRule'

!		Class methods for 'RBParseTreeRule'

category: 'instance creation'
classmethod: RBParseTreeRule
methodSearch: aString 
	^(self new)
		methodSearchString: aString;
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeRule
new

	^self basicNew initialize
%

category: 'instance creation'
classmethod: RBParseTreeRule
search: aString 
	^(self new)
		searchString: aString;
		yourself
%

!		Instance methods for 'RBParseTreeRule'

category: 'matching'
method: RBParseTreeRule
canMatch: aProgramNode 
	^true
%

category: 'private'
method: RBParseTreeRule
context
	^owner context
%

category: 'matching'
method: RBParseTreeRule
foundMatchFor: aProgramNode
	^aProgramNode
%

category: 'initialize-release'
method: RBParseTreeRule
initialize
%

category: 'initialize-release'
method: RBParseTreeRule
methodSearchString: aString 
	searchTree := RBParser parseRewriteMethod: aString
%

category: 'initialize-release'
method: RBParseTreeRule
owner: aParseTreeSearcher
	owner := aParseTreeSearcher
%

category: 'matching'
method: RBParseTreeRule
performOn: aProgramNode 
	self context empty.
	^((searchTree match: aProgramNode inContext: self context) 
		and: [self canMatch: aProgramNode]) 
			ifTrue: 
				[owner recusivelySearchInContext.
				self foundMatchFor: aProgramNode]
			ifFalse: [nil]
%

category: 'initialize-release'
method: RBParseTreeRule
searchString: aString 
	searchTree := RBParser parseRewriteExpression: aString
%

category: 'accessing'
method: RBParseTreeRule
sentMessages
	^searchTree sentMessages
%

! Class implementation for 'RBReplaceRule'

!		Instance methods for 'RBReplaceRule'

category: 'matching'
method: RBReplaceRule
canMatch: aProgramNode 
	^verificationBlock value: aProgramNode
%

category: 'matching'
method: RBReplaceRule
foundMatchFor: aProgramNode 
	self subclassResponsibility
%

category: 'initialize-release'
method: RBReplaceRule
initialize
	super initialize.
	verificationBlock := [:aNode | true]
%

category: 'matching'
method: RBReplaceRule
replace: aProgramNode with: newNode 
	aProgramNode replaceMethodSource: newNode
%

! Class implementation for 'RBBlockReplaceRule'

!		Class methods for 'RBBlockReplaceRule'

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchFor: searchString replaceWith: replaceBlock 
	^self new searchFor: searchString replaceWith: replaceBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchFor: searchString replaceWith: replaceBlock when: aBlock 
	^self new 
		searchFor: searchString
		replaceWith: replaceBlock
		when: aBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForMethod: searchString replaceWith: replaceBlock 
	^self new searchForMethod: searchString replaceWith: replaceBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForMethod: searchString replaceWith: replaceBlock when: aBlock 
	^self new 
		searchForMethod: searchString
		replaceWith: replaceBlock
		when: aBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceBlock 
	^self new searchForTree: aRBProgramNode replaceWith: replaceBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceBlock when: aBlock 
	^self new 
		searchForTree: aRBProgramNode
		replaceWith: replaceBlock
		when: aBlock
%

!		Instance methods for 'RBBlockReplaceRule'

category: 'matching'
method: RBBlockReplaceRule
foundMatchFor: aProgramNode 
	| newNode |
	newNode := replaceBlock value: aProgramNode.
	aProgramNode replaceMethodSource: newNode.
	^newNode
%

category: 'initialize-release'
method: RBBlockReplaceRule
initialize
	super initialize.
	replaceBlock := [:aNode | aNode]
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchFor: searchString replaceWith: aBlock 
	self searchString: searchString.
	replaceBlock := aBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchFor: searchString replaceWith: replBlock when: verifyBlock 
	self searchFor: searchString replaceWith: replBlock.
	verificationBlock := verifyBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForMethod: searchString replaceWith: aBlock 
	self methodSearchString: searchString.
	replaceBlock := aBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForMethod: searchString replaceWith: replBlock when: verifyBlock 
	self searchForMethod: searchString replaceWith: replBlock.
	verificationBlock := verifyBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForTree: aBRProgramNode replaceWith: aBlock 
	searchTree := aBRProgramNode.
	replaceBlock := aBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForTree: aBRProgramNode replaceWith: replBlock when: verifyBlock 
	self searchForTree: aBRProgramNode replaceWith: replBlock.
	verificationBlock := verifyBlock
%

! Class implementation for 'RBStringReplaceRule'

!		Class methods for 'RBStringReplaceRule'

category: 'instance creation'
classmethod: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString 
	^self new searchFor: searchString replaceWith: replaceString
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString when: aBlock 
	^self new 
		searchFor: searchString
		replaceWith: replaceString
		when: aBlock
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString 
	^(self new)
		searchForMethod: searchString replaceWith: replaceString;
		yourself
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString when: aBlock 
	^self new 
		searchForMethod: searchString
		replaceWith: replaceString
		when: aBlock
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceString 
	^self new searchForTree: aRBProgramNode replaceWith: replaceString
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceString when: aBlock 
	^self new 
		searchForTree: aRBProgramNode
		replaceWith: replaceString
		when: aBlock
%

!		Instance methods for 'RBStringReplaceRule'

category: 'matching'
method: RBStringReplaceRule
foundMatchFor: aProgramNode 
	| newNode |
	newNode := replaceTree copyInContext: self context.
	aProgramNode replaceMethodSource: newNode.
	newNode copyCommentsFrom: aProgramNode.
	^newNode
%

category: 'initialize-release'
method: RBStringReplaceRule
methodReplaceString: replaceString 
	replaceTree := RBParser parseRewriteMethod: replaceString
%

category: 'initialize-release'
method: RBStringReplaceRule
replaceString: replaceString 
	replaceTree := RBParser parseRewriteExpression: replaceString.
	searchTree isSequence = replaceTree isSequence 
		ifFalse: 
			[searchTree isSequence 
				ifTrue: [replaceTree := RBSequenceNode statements: (Array with: replaceTree)]
				ifFalse: [searchTree := RBSequenceNode statements: (Array with: searchTree)]]
%

category: 'initialize-release'
method: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString 
	self searchString: searchString.
	self replaceString: replaceString
%

category: 'initialize-release'
method: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString when: aBlock 
	self searchFor: searchString replaceWith: replaceString.
	verificationBlock := aBlock
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString 
	self methodSearchString: searchString.
	self methodReplaceString: replaceString
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString when: aBlock 
	self searchForMethod: searchString replaceWith: replaceString.
	verificationBlock := aBlock
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForTree: aBRProgramNode replaceWith: replaceNode 
	searchTree := aBRProgramNode.
	replaceTree := replaceNode
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForTree: aBRProgramNode replaceWith: replaceString when: aBlock 
	self searchForTree: aBRProgramNode replaceWith: replaceString.
	verificationBlock := aBlock
%

! Class implementation for 'RBSearchRule'

!		Class methods for 'RBSearchRule'

category: 'instance creation'
classmethod: RBSearchRule
searchFor: aString thenDo: aBlock 
	^self new searchFor: aString thenDo: aBlock
%

category: 'instance creation'
classmethod: RBSearchRule
searchForMethod: aString thenDo: aBlock 
	^self new searchForMethod: aString thenDo: aBlock
%

category: 'instance creation'
classmethod: RBSearchRule
searchForTree: aBRProgramNode thenDo: aBlock 
	^self new searchForTree: aBRProgramNode thenDo: aBlock
%

!		Instance methods for 'RBSearchRule'

category: 'testing'
method: RBSearchRule
canMatch: aProgramNode 
	owner answer: (answerBlock value: aProgramNode value: owner answer).
	^true
%

category: 'initialize-release'
method: RBSearchRule
searchFor: aString thenDo: aBlock 
	self searchString: aString.
	answerBlock := aBlock
%

category: 'initialize-release'
method: RBSearchRule
searchForMethod: aString thenDo: aBlock 
	self methodSearchString: aString.
	answerBlock := aBlock
%

category: 'initialize-release'
method: RBSearchRule
searchForTree: aBRProgramNode thenDo: aBlock 
	searchTree := aBRProgramNode.
	answerBlock := aBlock
%

! Class implementation for 'RBProgramNode'

!		Class methods for 'RBProgramNode'

category: 'accessing'
classmethod: RBProgramNode
formatterClass
  ^ FormatterClass isNil
    ifTrue: [ RBConfigurableFormatter ]
    ifFalse: [ ^ Rowan globalNamed: FormatterClass name ]
%

category: 'accessing'
classmethod: RBProgramNode
formatterClass: aClass 
	FormatterClass := aClass
%

category: 'instance creation'
classmethod: RBProgramNode
new

	^self basicNew initialize
%

category: 'accessing'
classmethod: RBProgramNode
optimizedSelectors
	^ #( and: caseOf: caseOf:otherwise: ifFalse: ifFalse:ifTrue: ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: ifTrue: ifTrue:ifFalse: or: to:by:do: to:do: whileFalse whileFalse: whileTrue whileTrue: )
%

!		Instance methods for 'RBProgramNode'

category: 'visitor'
method: RBProgramNode
acceptVisitor: aProgramNodeVisitor 
	self subclassResponsibility
%

category: 'replacing'
method: RBProgramNode
addReplacement: aStringReplacement
	parent isNil ifTrue: [^self].
	parent addReplacement: aStringReplacement
%

category: 'accessing'
method: RBProgramNode
allArgumentVariables
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allArgumentVariables;
				yourself]
%

category: 'iterating'
method: RBProgramNode
allChildren
	| children |
	children := OrderedCollection new.
	self nodesDo: [ :each | children addLast: each ].
	^ children
%

category: 'accessing'
method: RBProgramNode
allDefinedVariables
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allDefinedVariables;
				yourself]
%

category: 'accessing'
method: RBProgramNode
allTemporaryVariables
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allTemporaryVariables;
				yourself]
%

category: 'accessing'
method: RBProgramNode
asReturn
	"Change the current node to a return node."

	parent isNil 
		ifTrue: [self error: 'Cannot change to a return without a parent node.'].
	parent isSequence 
		ifFalse: [self error: 'Parent node must be a sequence node.'].
	(parent isLast: self) ifFalse: [self error: 'Return node must be last.'].
	^parent addReturn
%

category: 'testing'
method: RBProgramNode
assigns: aVariableName 
	^self children anySatisfy: [:each | each assigns: aVariableName]
%

category: 'querying'
method: RBProgramNode
bestNodeFor: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	selectedChildren := self children 
				select: [:each | each intersectsInterval: anInterval].
	^selectedChildren size == 1 
		ifTrue: [selectedChildren first bestNodeFor: anInterval]
		ifFalse: [self]
%

category: 'accessing'
method: RBProgramNode
blockVariables
	^parent isNil ifTrue: [#()] ifFalse: [parent blockVariables]
%

category: 'testing-matching'
method: RBProgramNode
canMatchMethod: aCompiledMethod 
	^self sentMessages allSatisfy: 
			[:each | 
			(self class optimizedSelectors includes: each) 
				or: [aCompiledMethod refersToLiteral: each]]
%

category: 'meta variable-accessing'
method: RBProgramNode
cascadeListCharacter
	^$;
%

category: 'accessing'
method: RBProgramNode
children
	^#()
%

category: 'replacing'
method: RBProgramNode
clearReplacements
	parent isNil ifTrue: [^self].
	parent clearReplacements
%

category: 'enumeration'
method: RBProgramNode
collect: aBlock 
	"Hacked to fit collection protocols"

	^aBlock value: self
%

category: 'accessing'
method: RBProgramNode
comments
	"Answer the comments of the receiving parse tree node as intervals of starting and ending indices."
	
	^ comments isNil ifTrue: [ #() ] ifFalse: [ comments ]
%

category: 'accessing'
method: RBProgramNode
comments: aCollection
	comments := aCollection
%

category: 'testing'
method: RBProgramNode
containedBy: anInterval 
	^anInterval first <= self start and: [anInterval last >= self stop]
%

category: 'testing'
method: RBProgramNode
containsReturn
	^self children anySatisfy: [:each | each containsReturn]
%

category: 'copying'
method: RBProgramNode
copyCommentsFrom: aNode 
	"Add all comments from aNode to us. If we already have the comment, then don't add it."

	| newComments |
	newComments := OrderedCollection new.
	aNode nodesDo: [:each | newComments addAll: each comments].
	self nodesDo: 
			[:each | 
			each comments do: [:comment | newComments remove: comment ifAbsent: []]].
	newComments isEmpty ifTrue: [^self].
	newComments := newComments asSortedCollection: [:a :b | a first < b first].
	self comments: newComments
%

category: 'matching'
method: RBProgramNode
copyInContext: aDictionary
	^ self copy
%

category: 'matching'
method: RBProgramNode
copyList: matchNodes inContext: aDictionary 
	| newNodes |
	newNodes := OrderedCollection new.
	matchNodes do: 
			[:each | 
			| object |
			object := each copyInContext: aDictionary.
			newNodes addAll: object].
	^newNodes
%

category: 'testing'
method: RBProgramNode
defines: aName
	^false
%

category: 'testing'
method: RBProgramNode
directlyUses: aNode
	^true
%

category: 'enumeration'
method: RBProgramNode
do: aBlock 
	"Hacked to fit collection protocols"

	aBlock value: self
%

category: 'comparing'
method: RBProgramNode
equalTo: aNode exceptForVariables: variableNameCollection 
	| dictionary |
	dictionary := Dictionary new.
	(self equalTo: aNode withMapping: dictionary) ifFalse: [^false].
	dictionary keysAndValuesDo: 
			[:key :value | 
			(key = value or: [variableNameCollection includes: key]) ifFalse: [^false]].
	^true
%

category: 'comparing'
method: RBProgramNode
equalTo: aNode withMapping: aDictionary 
	^self = aNode
%

category: 'testing'
method: RBProgramNode
evaluatedFirst: aNode 
	self children do: 
			[:each | 
			each == aNode ifTrue: [^true].
			each isImmediateNode ifFalse: [^false]].
	^false
%

category: 'accessing'
method: RBProgramNode
formattedCode
	^ self formatterClass new format: self
%

category: 'accessing'
method: RBProgramNode
formatterClass
	^ self class formatterClass
%

category: 'comparing'
method: RBProgramNode
hashForCollection: aCollection
	^ aCollection isEmpty ifTrue: [ 0 ] ifFalse: [ aCollection first hash ]
%

category: 'testing'
method: RBProgramNode
hasMultipleReturns
	| count |
	count := 0.
	self nodesDo: [:each | each isReturn ifTrue: [count := count + 1]].
	^count > 1
%

category: 'properties'
method: RBProgramNode
hasProperty: aKey
	"Test if the property aKey is present."
	
	^ properties notNil and: [ properties includesKey: aKey ]
%

category: 'initialize release'
method: RBProgramNode
initialize
%

category: 'testing'
method: RBProgramNode
intersectsInterval: anInterval 
	^(anInterval first between: self start and: self stop) 
		or: [self start between: anInterval first and: anInterval last]
%

category: 'testing'
method: RBProgramNode
isArray
	^ false
%

category: 'testing'
method: RBProgramNode
isAssignment
	^false
%

category: 'testing'
method: RBProgramNode
isBlock
	^false
%

category: 'testing'
method: RBProgramNode
isCascade
	^false
%

category: 'testing'
method: RBProgramNode
isDirectlyUsed
	"This node is directly used as an argument, receiver, or part of an assignment."

	^parent isNil ifTrue: [false] ifFalse: [parent directlyUses: self]
%

category: 'testing'
method: RBProgramNode
isEvaluatedFirst
	"Return true if we are the first thing evaluated in this statement."

	^parent isNil or: [parent isSequence or: [parent evaluatedFirst: self]]
%

category: 'deprecated'
method: RBProgramNode
isImmediate
	^self isImmediateNode
%

category: 'testing'
method: RBProgramNode
isImmediateNode
	^false
%

category: 'testing'
method: RBProgramNode
isLast: aNode 
	| children |
	children := self children.
	^children notEmpty and: [children last == aNode]
%

category: 'testing-matching'
method: RBProgramNode
isList
	^false
%

category: 'deprecated'
method: RBProgramNode
isLiteral
	^self isLiteralNode
%

category: 'testing'
method: RBProgramNode
isLiteralArray
	^false
%

category: 'testing'
method: RBProgramNode
isLiteralNode
	^false
%

category: 'testing'
method: RBProgramNode
isMessage
	^false
%

category: 'testing'
method: RBProgramNode
isMethod
	^false
%

category: 'testing-matching'
method: RBProgramNode
isPatternNode
	^false
%

category: 'testing'
method: RBProgramNode
isPragma
	^false
%

category: 'testing'
method: RBProgramNode
isReturn
	^false
%

category: 'testing'
method: RBProgramNode
isSequence
	^false
%

category: 'testing'
method: RBProgramNode
isUsed
	"Answer true if this node could be used as part of another expression. For example, you could use the 
	result of this node as a receiver of a message, an argument, the right part of an assignment, or the 
	return value of a block. This differs from isDirectlyUsed in that it is conservative since it also includes 
	return values of blocks."

	^parent isNil ifTrue: [false] ifFalse: [parent uses: self]
%

category: 'testing'
method: RBProgramNode
isValue
	^false
%

category: 'testing'
method: RBProgramNode
isVariable
	^false
%

category: 'testing'
method: RBProgramNode
lastIsReturn
	^self isReturn
%

category: 'meta variable-accessing'
method: RBProgramNode
listCharacter
	^$@
%

category: 'meta variable-accessing'
method: RBProgramNode
literalCharacter
	^$#
%

category: 'accessing'
method: RBProgramNode
mappingFor: aNode
	| method |
	method := self methodNode.
	method isNil ifTrue: [^aNode].
	^method mappingFor: aNode
%

category: 'matching'
method: RBProgramNode
match: aNode inContext: aDictionary 
	^ self = aNode
%

category: 'matching'
method: RBProgramNode
matchList: matchNodes against: programNodes inContext: aDictionary 
	^self
		matchList: matchNodes
		index: 1
		against: programNodes
		index: 1
		inContext: aDictionary
%

category: 'matching'
method: RBProgramNode
matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 
	| node currentIndex currentDictionary nodes |
	matchNodes size < matchIndex ifTrue: [^programNodes size < programIndex].
	node := matchNodes at: matchIndex.
	node isList 
		ifTrue: 
			[currentIndex := programIndex - 1.
			
			[currentDictionary := aDictionary copy.
			programNodes size < currentIndex or: 
					[nodes := programNodes copyFrom: programIndex to: currentIndex.
					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 
							[(self 
								matchList: matchNodes
								index: matchIndex + 1
								against: programNodes
								index: currentIndex + 1
								inContext: currentDictionary) 
									ifTrue: 
										[currentDictionary 
											keysAndValuesDo: [:key :value | aDictionary at: key put: value].
										^true].
							false]]] 
					whileFalse: [currentIndex := currentIndex + 1].
			^false].
	programNodes size < programIndex ifTrue: [^false].
	(node match: (programNodes at: programIndex) inContext: aDictionary) 
		ifFalse: [^false].
	^self 
		matchList: matchNodes
		index: matchIndex + 1
		against: programNodes
		index: programIndex + 1
		inContext: aDictionary
%

category: 'accessing'
method: RBProgramNode
methodComments
	^self comments
%

category: 'accessing'
method: RBProgramNode
methodNode
	^parent isNil ifTrue: [nil] ifFalse: [parent methodNode]
%

category: 'accessing'
method: RBProgramNode
newSource
	^self formattedCode
%

category: 'iterating'
method: RBProgramNode
nodesDo: aBlock 
	aBlock value: self.
	self children do: [ :each | each nodesDo: aBlock ]
%

category: 'accessing'
method: RBProgramNode
parent
	^parent
%

category: 'accessing'
method: RBProgramNode
parent: aRBProgramNode 
	parent := aRBProgramNode
%

category: 'accessing'
method: RBProgramNode
parents
	^ parent isNil
		ifTrue: [ OrderedCollection with: self ]
		ifFalse: [ 
			parent parents
				addLast: self;
				yourself ]
%

category: 'copying'
method: RBProgramNode
postCopy
	super postCopy.
	properties := properties copy
%

category: 'accessing'
method: RBProgramNode
precedence
	^6
%

category: 'printing'
method: RBProgramNode
printOn: aStream 
	aStream
		nextPutAll: self class name;
		nextPut: $(;
		nextPutAll: self formattedCode;
		nextPut: $)
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey
	"Answer the property value associated with aKey."
	
	^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey ifAbsent: aBlock
	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."
	
	^ properties isNil
		ifTrue: [ aBlock value ]
		ifFalse: [ properties at: aKey ifAbsent: aBlock ]
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey ifAbsentPut: aBlock
	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."
	
	^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey put: anObject
	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."

	^ (properties ifNil: [ properties := RBSmallDictionary new: 1 ])
		at: aKey put: anObject
%

category: 'testing-matching'
method: RBProgramNode
recurseInto
	^false
%

category: 'meta variable-accessing'
method: RBProgramNode
recurseIntoCharacter
	^$`
%

category: 'testing'
method: RBProgramNode
references: aVariableName 
	^self children anySatisfy: [:each | each references: aVariableName]
%

category: 'replacing'
method: RBProgramNode
removeDeadCode
	self children do: [:each | each removeDeadCode]
%

category: 'properties'
method: RBProgramNode
removeProperty: aKey
	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."
	
	^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ].
%

category: 'properties'
method: RBProgramNode
removeProperty: aKey ifAbsent: aBlock
	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."
	
	| answer |
	properties isNil ifTrue: [ ^ aBlock value ].
	answer := properties removeKey: aKey ifAbsent: aBlock.
	properties isEmpty ifTrue: [ properties := nil ].
	^ answer
%

category: 'replacing'
method: RBProgramNode
replaceMethodSource: aNode 
	"We are being replaced with aNode -- if possible try to perform an in place edit of the source."

	| method |
	method := self methodNode.
	method notNil ifTrue: [method map: self to: aNode].
	aNode parent: self parent.
	[self replaceSourceWith: aNode] on: Error
		do: 
			[:ex | 
			self clearReplacements.
			ex return]
%

category: 'replacing'
method: RBProgramNode
replaceNode: aNode withNode: anotherNode 
	self error: 'I don''t store other nodes'
%

category: 'private-replacing'
method: RBProgramNode
replaceSourceFrom: aNode
	self == aNode
		ifFalse: [ self clearReplacements ]
%

category: 'private-replacing'
method: RBProgramNode
replaceSourceWith: aNode 
	aNode replaceSourceFrom: self
%

category: 'replacing'
method: RBProgramNode
replaceWith: aNode 
	parent isNil ifTrue: [self error: 'This node doesn''t have a parent'].
	self replaceMethodSource: aNode.
	parent replaceNode: self withNode: aNode
%

category: 'querying'
method: RBProgramNode
selfMessages
	| searcher |
	searcher := RBParseTreeSearcher new.
	searcher matches: 'self `@msg: ``@args'
		do: 
			[:aNode :answer | 
			answer
				add: aNode selector;
				yourself].
	^searcher executeTree: self initialAnswer: Set new
%

category: 'accessing'
method: RBProgramNode
sentMessages
	^ self children
		inject: Set new
		into: [ :messages :each | 
			messages
				addAll: each sentMessages;
				yourself ]
%

category: 'enumeration'
method: RBProgramNode
size
	"Hacked to fit collection protocols"

	^1
%

category: 'accessing'
method: RBProgramNode
source
	^parent notNil ifTrue: [parent source] ifFalse: [nil]
%

category: 'accessing'
method: RBProgramNode
sourceInterval
	^self start to: self stop
%

category: 'accessing'
method: RBProgramNode
start
	self subclassResponsibility
%

category: 'meta variable-accessing'
method: RBProgramNode
statementCharacter
	^$.
%

category: 'accessing'
method: RBProgramNode
statementComments
	| statementComments |
	statementComments := OrderedCollection withAll: self comments.
	self children do: [:each | statementComments addAll: each statementComments].
	^statementComments asSortedCollection: [:a :b | a first < b first]
%

category: 'querying'
method: RBProgramNode
statementNode
	"Return your topmost node that is contained by a sequence node."

	(parent isNil or: [parent isSequence]) ifTrue: [^self].
	^parent statementNode
%

category: 'accessing'
method: RBProgramNode
stop
	self subclassResponsibility
%

category: 'querying'
method: RBProgramNode
superMessages
	| searcher |
	searcher := RBParseTreeSearcher new.
	searcher matches: 'super `@msg: ``@args'
		do: 
			[:aNode :answer | 
			answer
				add: aNode selector;
				yourself].
	^searcher executeTree: self initialAnswer: Set new
%

category: 'accessing'
method: RBProgramNode
temporaryVariables
	^parent isNil ifTrue: [#()] ifFalse: [parent temporaryVariables]
%

category: 'testing'
method: RBProgramNode
uses: aNode
	^true
%

category: 'querying'
method: RBProgramNode
whichNodeIsContainedBy: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	selectedChildren := self children 
				select: [:each | each intersectsInterval: anInterval].
	^selectedChildren size == 1 
		ifTrue: [selectedChildren first whichNodeIsContainedBy: anInterval]
		ifFalse: [nil]
%

category: 'querying'
method: RBProgramNode
whoDefines: aName 
	^(self defines: aName) 
		ifTrue: [self]
		ifFalse: [parent notNil ifTrue: [parent whoDefines: aName] ifFalse: [nil]]
%

! Class implementation for 'RBMethodNode'

!		Class methods for 'RBMethodNode'

category: 'instance creation'
classmethod: RBMethodNode
selector: aSymbol arguments: variableNodes body: aSequenceNode 
	^(self new)
		arguments: variableNodes;
		selector: aSymbol;
		body: aSequenceNode;
		yourself
%

category: 'instance creation'
classmethod: RBMethodNode
selector: aSymbol body: aSequenceNode 
	^self 
		selector: aSymbol
		arguments: #()
		body: aSequenceNode
%

category: 'instance creation'
classmethod: RBMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	^(self new)
		selectorParts: tokenCollection arguments: variableNodes;
		yourself
%

!		Instance methods for 'RBMethodNode'

category: 'comparing'
method: RBMethodNode
= anObject 
	self == anObject ifTrue: [ ^ true ].
	self class = anObject class ifFalse: [ ^ false ].
	(self selector = anObject selector
		and: [ self pragmas size = anObject pragmas size
		and: [ self body = anObject body ] ])
			ifFalse: [ ^ false ].
	self arguments with: anObject arguments do: [ :first :second |
		first = second 
			ifFalse: [ ^ false ] ].
	self pragmas with: anObject pragmas do: [ :first :second |
		first = second 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'visitor'
method: RBMethodNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptMethodNode: self
%

category: 'accessing'
method: RBMethodNode
addNode: aNode
	^ body addNode: aNode
%

category: 'replacing'
method: RBMethodNode
addReplacement: aStringReplacement 
	replacements isNil ifTrue: [^self].
	replacements add: aStringReplacement
%

category: 'accessing'
method: RBMethodNode
addReturn
	^ body addReturn
%

category: 'accessing'
method: RBMethodNode
addSelfReturn
	^ body addSelfReturn
%

category: 'accessing'
method: RBMethodNode
allArgumentVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allArgumentVariables;
		yourself
%

category: 'accessing'
method: RBMethodNode
allDefinedVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allDefinedVariables;
		yourself
%

category: 'accessing'
method: RBMethodNode
argumentNames
	^self arguments collect: [:each | each name]
%

category: 'accessing'
method: RBMethodNode
arguments
	^arguments
%

category: 'accessing'
method: RBMethodNode
arguments: variableNodes 
	arguments := variableNodes.
	arguments do: [:each | each parent: self]
%

category: 'accessing'
method: RBMethodNode
body
	^body
%

category: 'accessing'
method: RBMethodNode
body: stmtsNode 
	body := stmtsNode.
	body parent: self
%

category: 'private'
method: RBMethodNode
buildSelector
	| selectorStream |
	selectorStream := WriteStreamPortable on: String new.
	selectorParts do: [:each | selectorStream nextPutAll: each value].
	^selectorStream contents asSymbol
%

category: 'private-replacing'
method: RBMethodNode
changeSourceSelectors: oldSelectorParts arguments: oldArguments
	"If this is the same number of arguments, we try a one to one replacement of selector parts and arguments. If this is not the case try to rewrite the signature as a whole, what unfortunately drops the comments within the signature."
	
	[ (oldSelectorParts size = selectorParts size and: [ oldArguments size = arguments size ])
		ifTrue: [
			oldSelectorParts with: selectorParts do: [ :old :new | 
				self addReplacement: (RBStringReplacement 
					replaceFrom: old start
					to: old stop
					with: new value) ].
			oldArguments with: arguments do: [ :old :new | 
				self addReplacement: (RBStringReplacement 
					replaceFrom: old start
					to: old stop
					with: new name) ] ]
		ifFalse: [
			self addReplacement: (RBStringReplacement
				replaceFrom: oldSelectorParts first start
				to: (oldArguments notEmpty
					ifTrue: [ oldArguments last stop ]
					ifFalse: [ oldSelectorParts last stop ])
				with: (String streamContents: [ :stream |
					selectorParts keysAndValuesDo: [ :index :part |
						index = 1 ifFalse: [ stream space ].
						stream nextPutAll: part value.
						index <= arguments size
							ifTrue: [ stream space; nextPutAll: (arguments at: index) name ] ] ])) ] ]
		on: Error
		do: [ :ex | ex return ]
%

category: 'accessing'
method: RBMethodNode
children
	^ OrderedCollection new
		addAll: self arguments;
		addAll: self pragmas;
		add: self body;
		yourself
%

category: 'replacing'
method: RBMethodNode
clearReplacements
	replacements := nil
%

category: 'matching'
method: RBMethodNode
copyInContext: aDictionary
	^ self class new
		selectorParts: (self selectorParts collect: [ :each | each copy removePositions ]);
		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);
		pragmas: (self pragmas isEmpty
			ifTrue: [ aDictionary at: '-pragmas-' ifAbsent: [ #() ] ]
			ifFalse: [ self copyList: self pragmas inContext: aDictionary ]);
		body: (self body copyInContext: aDictionary);
		source: (aDictionary at: '-source-' ifAbsentPut: [ self source ]);
		yourself
%

category: 'testing'
method: RBMethodNode
defines: aName 
	^arguments anySatisfy: [:each | each name = aName]
%

category: 'comparing'
method: RBMethodNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [ ^ false ].
	(self selector = anObject selector
		and: [ self pragmas size = anObject pragmas size
		and: [ self body equalTo: anObject body withMapping: aDictionary ] ]) 
			ifFalse: [ ^ false ].
	self arguments with: anObject arguments do: [ :first :second |
		(first equalTo: second	withMapping: aDictionary)
			ifFalse: [ ^ false ].
		aDictionary removeKey: first name ].
	self pragmas with: anObject pragmas do: [ :first :second |
		(first equalTo: second	withMapping: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'comparing'
method: RBMethodNode
hash
	^ ((self selector hash bitXor: (self hashForCollection: self arguments)) bitXor: (self hashForCollection: self pragmas)) bitXor: self body hash
%

category: 'initialize-release'
method: RBMethodNode
initialize
	replacements := SortedCollection sortBlock: 
					[:a :b | 
					a startPosition < b startPosition 
						or: [a startPosition = b startPosition and: [a stopPosition < b stopPosition]]].
	nodeReplacements := IdentityDictionary new
%

category: 'testing'
method: RBMethodNode
isLast: aNode 
	^body isLast: aNode
%

category: 'testing'
method: RBMethodNode
isMethod
	^true
%

category: 'testing'
method: RBMethodNode
isPrimitive
	^ self pragmas anySatisfy: [ :each | each isPrimitive ]
%

category: 'testing'
method: RBMethodNode
lastIsReturn
	^body lastIsReturn
%

category: 'replacing'
method: RBMethodNode
map: oldNode to: newNode 
	nodeReplacements at: oldNode put: newNode
%

category: 'replacing'
method: RBMethodNode
mappingFor: oldNode 
	^nodeReplacements at: oldNode ifAbsent: [oldNode]
%

category: 'matching'
method: RBMethodNode
match: aNode inContext: aDictionary 
	self class = aNode class ifFalse: [ ^ false ].
	aDictionary at: '-source-' put: aNode source.
	self selector = aNode selector ifFalse: [ ^ false ].
	^ (self matchList: arguments against: aNode arguments inContext: aDictionary)
		and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)
		and: [ body match: aNode body inContext: aDictionary ] ]
%

category: 'matching'
method: RBMethodNode
matchPragmas: matchNodes against: pragmaNodes inContext: aDictionary
	matchNodes isEmpty ifTrue: [ 
		aDictionary at: '-pragmas-' put: pragmaNodes.
		^ true ].
	^ matchNodes allSatisfy: [ :matchNode |
		pragmaNodes anySatisfy: [ :pragmaNode |
			matchNode match: pragmaNode inContext: aDictionary ] ]
%

category: 'accessing'
method: RBMethodNode
methodComments
	| methodComments |
	methodComments := OrderedCollection withAll: self comments.
	arguments do: [:each | methodComments addAll: each comments].
	^methodComments asSortedCollection: [:a :b | a first < b first]
%

category: 'accessing'
method: RBMethodNode
methodNode
	^self
%

category: 'accessing'
method: RBMethodNode
newSource
	replacements isNil ifTrue: [^self formattedCode].
	^[self reformatSource] on: Error do: [:ex | ex return: self formattedCode]
%

category: 'accessing'
method: RBMethodNode
numArgs
	^self selector numArgs
%

category: 'copying'
method: RBMethodNode
postCopy
	super postCopy.
	self arguments: (self arguments collect: [ :each | each copy ]).
	self pragmas: (self pragmas collect: [ :each | each copy ]).
	self body: self body copy
%

category: 'accessing'
method: RBMethodNode
pragmas
	^ pragmas ifNil: [ #() ]
%

category: 'accessing'
method: RBMethodNode
pragmas: aCollection
	pragmas := aCollection.
	pragmas do: [ :each | each parent: self ]
%

category: 'accessing'
method: RBMethodNode
primitiveSources
	^ self pragmas collect: [ :each | self source copyFrom: each first to: each last ]
%

category: 'printing'
method: RBMethodNode
printOn: aStream 
	aStream nextPutAll: self formattedCode
%

category: 'testing'
method: RBMethodNode
references: aVariableName 
	^body references: aVariableName
%

category: 'private'
method: RBMethodNode
reformatSource
	| stream newSource newTree |
	stream := WriteStreamPortable on: String new.
	stream
		nextPutAll: (source
			copyFrom: (replacements
				inject: 1
				into: [ :sum :each | 
					stream
						nextPutAll: (source copyFrom: sum to: each startPosition - 1);
						nextPutAll: (each string).
					each stopPosition + 1 ])
			to: source size).
	newSource := stream contents.
	newTree := RBParser 
		parseMethod: newSource 
		onError: [ :msg :pos | ^ self formattedCode ].
	self = newTree
		ifFalse: [ ^ self formattedCode ].
	^ newSource
%

category: 'accessing'
method: RBMethodNode
renameSelector: newSelector andArguments: varNodeCollection 
	| oldSelectorParts oldArguments |
	oldSelectorParts := selectorParts.
	oldArguments := arguments.
	self
		arguments: varNodeCollection;
		selector: newSelector.
	self changeSourceSelectors: oldSelectorParts arguments: oldArguments
%

category: 'replacing'
method: RBMethodNode
replaceNode: aNode withNode: anotherNode 
	aNode == body ifTrue: [self body: anotherNode].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'accessing'
method: RBMethodNode
selector
	^selector isNil
		ifTrue: [selector := self buildSelector]
		ifFalse: [selector]
%

category: 'accessing'
method: RBMethodNode
selector: aSelector 
	| keywords numArgs |
	keywords := aSelector keywords.
	numArgs := aSelector numArgs.
	numArgs == arguments size 
		ifFalse: 
			[self 
				error: 'Attempting to assign selector with wrong number of arguments.'].
	selectorParts := numArgs == 0 
				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]
				ifFalse: 
					[keywords first last = $: 
						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]
						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].
	selector := aSelector asSymbol
%

category: 'private'
method: RBMethodNode
selectorParts
	^selectorParts
%

category: 'private'
method: RBMethodNode
selectorParts: tokenCollection 
	selectorParts := tokenCollection
%

category: 'initialize-release'
method: RBMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	selectorParts := tokenCollection.
	self arguments: variableNodes
%

category: 'accessing'
method: RBMethodNode
source
	^source
%

category: 'accessing'
method: RBMethodNode
source: anObject
	source := anObject
%

category: 'accessing'
method: RBMethodNode
start
	^1
%

category: 'accessing'
method: RBMethodNode
stop
	^source size
%

category: 'testing'
method: RBMethodNode
uses: aNode 
	^body == aNode and: [aNode lastIsReturn]
%

! Class implementation for 'RBPatternMethodNode'

!		Class methods for 'RBPatternMethodNode'

category: 'instance creation'
classmethod: RBPatternMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	^(tokenCollection anySatisfy: [:each | each isPatternVariable]) 
		ifTrue: [super selectorParts: tokenCollection arguments: variableNodes]
		ifFalse: 
			[RBMethodNode selectorParts: tokenCollection arguments: variableNodes]
%

!		Instance methods for 'RBPatternMethodNode'

category: 'matching'
method: RBPatternMethodNode
copyInContext: aDictionary 
	| selectors |
	selectors := self isSelectorList 
		ifTrue: [ (aDictionary at: selectorParts first value) keywords ]
		ifFalse: [ self selectorParts collect: [ :each | aDictionary at: each value ] ].
	^ RBMethodNode new
		selectorParts: (selectors collect: [ :each | 
			(each last = $: ifTrue: [ RBKeywordToken ] ifFalse: [ RBIdentifierToken ]) 
				value: each start: nil ]);
		arguments: (self copyList: self arguments inContext: aDictionary);
		pragmas: (self pragmas isEmpty
			ifTrue: [ aDictionary at: '-pragmas-' ifAbsent: [ #() ] ]
			ifFalse: [ self copyList: self pragmas inContext: aDictionary ]);
		body: (self body copyInContext: aDictionary);
		source: (aDictionary at: '-source-');
		yourself
%

category: 'testing-matching'
method: RBPatternMethodNode
isPatternNode
	^true
%

category: 'testing'
method: RBPatternMethodNode
isSelectorList
	^isList
%

category: 'matching'
method: RBPatternMethodNode
match: aNode inContext: aDictionary 
	aNode class = self matchingClass 
		ifFalse: [ ^ false ].
	aDictionary at: '-source-' put: aNode source.
	self isSelectorList ifTrue: [
		^ (aDictionary at: selectorParts first value ifAbsentPut: [ aNode selector ]) = aNode selector
			and: [ (aDictionary at: arguments first ifAbsentPut: [ aNode arguments ]) = aNode arguments
			and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)
			and: [ body match: aNode body inContext: aDictionary ] ] ] ].
	^(self matchArgumentsAgainst: aNode inContext: aDictionary) 
		and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)
		and: [ body match: aNode body inContext: aDictionary ] ]
%

category: 'matching'
method: RBPatternMethodNode
matchArgumentsAgainst: aNode inContext: aDictionary 
	self arguments size = aNode arguments size
		ifFalse: [ ^ false ].
	(self matchSelectorAgainst: aNode inContext: aDictionary) 
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'private'
method: RBPatternMethodNode
matchingClass
	^RBMethodNode
%

category: 'matching'
method: RBPatternMethodNode
matchSelectorAgainst: aNode inContext: aDictionary 
	self selectorParts with: aNode selectorParts do: [ :first :second |
		| keyword |
		keyword := aDictionary
			at: first value
			ifAbsentPut: [ 
				first isPatternVariable 
					ifTrue: [ second value ]
					ifFalse: [ first value ] ].
		keyword = second value 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'initialize-release'
method: RBPatternMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	super selectorParts: tokenCollection arguments: variableNodes.
	isList := (tokenCollection first value at: 2) == self listCharacter
%

! Class implementation for 'RBPragmaNode'

!		Class methods for 'RBPragmaNode'

category: 'instance creation'
classmethod: RBPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	^ self new selectorParts: keywordTokens arguments: valueNodes
%

!		Instance methods for 'RBPragmaNode'

category: 'comparing'
method: RBPragmaNode
= anObject
  self == anObject
    ifTrue: [ ^ true ].
  self class = anObject class
    ifFalse: [ ^ false ].
  self selector = anObject selector
    ifFalse: [ ^ false ].
  1 to: self arguments size do: [ :i | 
    (self arguments at: i) = (anObject arguments at: i)
      ifFalse: [ ^ false ] ].
  self isProtected == anObject isProtected
    ifFalse: [ ^ false ].
  ^ true
%

category: 'visitor'
method: RBPragmaNode
acceptVisitor: aProgramNodeVisitor 
	^ aProgramNodeVisitor acceptPragmaNode: self
%

category: 'accessing'
method: RBPragmaNode
arguments
	^ arguments ifNil: [ #() ]
%

category: 'accessing'
method: RBPragmaNode
arguments: aLiteralCollection 
	arguments := aLiteralCollection.
	arguments do: [ :each | each parent: self ]
%

category: 'private'
method: RBPragmaNode
buildSelector
	| selectorStream |
	selectorStream := WriteStreamPortable on: String new.
	selectorParts do: [ :each | selectorStream nextPutAll: each value ].
	^ selectorStream contents asSymbol
%

category: 'accessing'
method: RBPragmaNode
children
	^ self arguments
%

category: 'matching'
method: RBPragmaNode
copyInContext: aDictionary 
	^ self class new
		selectorParts: (self selectorParts collect: [ :each | each copy removePositions ]);
		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);
		yourself
%

category: 'comparing'
method: RBPragmaNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [ ^ false ].
	self selector = anObject selector ifFalse: [ ^ false ].
	self arguments with: anObject arguments do: [ :first :second |
		(first equalTo: second withMapping: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'comparing'
method: RBPragmaNode
hash
	^ self selector hash bitXor: (self hashForCollection: self arguments)
%

category: 'testing'
method: RBPragmaNode
isBinary
	^ (self isUnary or: [self isKeyword]) not
%

category: 'testing'
method: RBPragmaNode
isKeyword
	^ selectorParts first value last = $:
%

category: 'testing'
method: RBPragmaNode
isPragma
	^ true
%

category: 'testing'
method: RBPragmaNode
isPrimitive
	^ #(primitive: primitive:error: primitive:error:module: primitive:module: primitive:module:error:) includes: self selector
%

category: 'testing'
method: RBPragmaNode
isProtected
  isProtected ifNil: [ ^ false ].
  ^ isProtected
%

category: 'testing'
method: RBPragmaNode
isProtected: aBool
  isProtected := aBool
%

category: 'testing'
method: RBPragmaNode
isProtectedPrimitive
  ^ self isProtected and: [ self isPrimitive ]
%

category: 'testing'
method: RBPragmaNode
isUnary
	^ arguments isEmpty
%

category: 'accessing-token'
method: RBPragmaNode
left
	^ left
%

category: 'accessing-token'
method: RBPragmaNode
left: anInteger
	left := anInteger
%

category: 'matching'
method: RBPragmaNode
match: aNode inContext: aDictionary 
	aNode class = self class
		ifFalse: [ ^ false ].
	self selector = aNode selector
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary)
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'accessing'
method: RBPragmaNode
numArgs
	^ self selector numArgs
%

category: 'copying'
method: RBPragmaNode
postCopy
	super postCopy.
	self arguments: (self arguments collect: [ :each | each copy ])
%

category: 'replacing'
method: RBPragmaNode
replaceNode: aNode withNode: anotherNode 
	self arguments: (arguments collect: [ :each | 
		each == aNode 
			ifTrue: [ anotherNode ]
			ifFalse: [ each ] ])
%

category: 'accessing-token'
method: RBPragmaNode
right
	^ right
%

category: 'accessing-token'
method: RBPragmaNode
right: anInteger
	right := anInteger
%

category: 'accessing'
method: RBPragmaNode
selector
	^ selector ifNil: [ selector := self buildSelector ]
%

category: 'accessing'
method: RBPragmaNode
selector: aSelector 
	| keywords numArgs |
	keywords := aSelector keywords.
	numArgs := aSelector numArgs.
	numArgs == arguments size 
		ifFalse: 
			[self 
				error: 'Attempting to assign selector with wrong number of arguments.'].
	selectorParts := numArgs == 0 
				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]
				ifFalse: 
					[keywords first last = $: 
						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]
						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].
	selector := aSelector asSymbol
%

category: 'private'
method: RBPragmaNode
selectorParts
	^ selectorParts
%

category: 'private'
method: RBPragmaNode
selectorParts: tokenCollection 
	selectorParts := tokenCollection
%

category: 'initialization'
method: RBPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	self selectorParts: keywordTokens.
	self arguments: valueNodes
%

category: 'accessing'
method: RBPragmaNode
sentMessages
	^ super sentMessages
		add: self selector;
		yourself
%

category: 'accessing'
method: RBPragmaNode
start
	^ left
%

category: 'accessing'
method: RBPragmaNode
stop
	^ right
%

! Class implementation for 'RBPatternPragmaNode'

!		Class methods for 'RBPatternPragmaNode'

category: 'instance creation'
classmethod: RBPatternPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	^ (keywordTokens anySatisfy: [ :each | each isPatternVariable ]) 
		ifTrue: [ super selectorParts: keywordTokens arguments: valueNodes ]
		ifFalse: [ RBPragmaNode selectorParts: keywordTokens arguments: valueNodes ]
%

!		Instance methods for 'RBPatternPragmaNode'

category: 'matching'
method: RBPatternPragmaNode
copyInContext: aDictionary 
	| selectors |
	selectors := self isSelectorList 
		ifTrue: [ (aDictionary at: selectorParts first value) keywords ]
		ifFalse: [ self selectorParts collect: [ :each | aDictionary at: each value ] ].
	^ RBPragmaNode new
		selectorParts: (selectors collect: [ :each | 
			(each last = $: ifTrue: [ RBKeywordToken ] ifFalse: [ RBIdentifierToken ]) 
				value: each start: nil ]);
		arguments: (self copyList: self arguments inContext: aDictionary);
		yourself
%

category: 'testing-matching'
method: RBPatternPragmaNode
isPatternNode
	^ true
%

category: 'testing-matching'
method: RBPatternPragmaNode
isSelectorList
	^ isList
%

category: 'matching'
method: RBPatternPragmaNode
match: aNode inContext: aDictionary
	aNode class = self matchingClass
		ifFalse: [ ^ false ].
	self isSelectorList ifTrue: [
		^ (aDictionary at: selectorParts first value ifAbsentPut: [ aNode selector ]) = aNode selector
			and: [ (aDictionary at: arguments first ifAbsentPut: [ aNode arguments ]) = aNode arguments ] ].
	^ self matchArgumentsAgainst: aNode inContext: aDictionary
%

category: 'matching'
method: RBPatternPragmaNode
matchArgumentsAgainst: aNode inContext: aDictionary 
	self arguments size = aNode arguments size
		ifFalse: [ ^ false ].
	(self matchSelectorAgainst: aNode inContext: aDictionary) 
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'private'
method: RBPatternPragmaNode
matchingClass
	^ RBPragmaNode
%

category: 'matching'
method: RBPatternPragmaNode
matchSelectorAgainst: aNode inContext: aDictionary 
	self selectorParts with: aNode selectorParts do: [ :first :second |
		| keyword |
		keyword := aDictionary
			at: first value
			ifAbsentPut: [ 
				first isPatternVariable 
					ifTrue: [ second value ]
					ifFalse: [ first value ] ].
		keyword = second value 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'initialization'
method: RBPatternPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	super selectorParts: keywordTokens arguments: valueNodes.
	isList := (keywordTokens first value at: 2) == self listCharacter
%

category: 'accessing'
method: RBPatternPragmaNode
sentMessages
	^ super sentMessages
		remove: self selector ifAbsent: [ ];
		yourself
%

! Class implementation for 'RBReturnNode'

!		Class methods for 'RBReturnNode'

category: 'instance creation'
classmethod: RBReturnNode
return: returnInteger value: aValueNode 
	^self new return: returnInteger value: aValueNode
%

category: 'instance creation'
classmethod: RBReturnNode
value: aNode
	^self return: nil value: aNode
%

!		Instance methods for 'RBReturnNode'

category: 'comparing'
method: RBReturnNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	^self value = anObject value
%

category: 'visitor'
method: RBReturnNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptReturnNode: self
%

category: 'accessing'
method: RBReturnNode
children
	^Array with: value
%

category: 'testing'
method: RBReturnNode
containsReturn
	^true
%

category: 'matching'
method: RBReturnNode
copyInContext: aDictionary 
	^ self class new
		value: (self value copyInContext: aDictionary);
		yourself
%

category: 'comparing'
method: RBReturnNode
equalTo: anObject withMapping: aDictionary 
	^self class = anObject class 
		and: [self value equalTo: anObject value withMapping: aDictionary]
%

category: 'comparing'
method: RBReturnNode
hash
	^self value hash
%

category: 'testing'
method: RBReturnNode
isReturn
	^true
%

category: 'matching'
method: RBReturnNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^value match: aNode value inContext: aDictionary
%

category: 'copying'
method: RBReturnNode
postCopy
	super postCopy.
	self value: self value copy
%

category: 'replacing'
method: RBReturnNode
replaceNode: aNode withNode: anotherNode 
	value == aNode ifTrue: [self value: anotherNode]
%

category: 'accessing-token'
method: RBReturnNode
return
	^ return
%

category: 'accessing-token'
method: RBReturnNode
return: anInteger
	return := anInteger
%

category: 'initialize-release'
method: RBReturnNode
return: returnInteger value: aValueNode 
	return := returnInteger.
	self value: aValueNode
%

category: 'accessing'
method: RBReturnNode
start
	^return
%

category: 'accessing'
method: RBReturnNode
stop
	^value stop
%

category: 'accessing'
method: RBReturnNode
value
	^value
%

category: 'accessing'
method: RBReturnNode
value: valueNode 
	value := valueNode.
	value parent: self
%

! Class implementation for 'RBSequenceNode'

!		Class methods for 'RBSequenceNode'

category: 'instance creation'
classmethod: RBSequenceNode
leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 
	^(self new)
		leftBar: leftInteger
			temporaries: variableNodes
			rightBar: rightInteger;
		yourself
%

category: 'instance creation'
classmethod: RBSequenceNode
statements: statementNodes 
	^self temporaries: #() statements: statementNodes
%

category: 'instance creation'
classmethod: RBSequenceNode
temporaries: variableNodes statements: statementNodes 
	^(self new)
		temporaries: variableNodes;
		statements: statementNodes;
		yourself
%

!		Instance methods for 'RBSequenceNode'

category: 'comparing'
method: RBSequenceNode
= anObject 
	"Can't send = to the temporaries and statements collection since they might change from arrays to OCs"

	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	self temporaries size = anObject temporaries size ifFalse: [^false].
	1 to: self temporaries size
		do: 
			[:i | 
			(self temporaries at: i) = (anObject temporaries at: i) ifFalse: [^false]].
	self statements size = anObject statements size ifFalse: [^false].
	1 to: self statements size
		do: [:i | (self statements at: i) = (anObject statements at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBSequenceNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptSequenceNode: self
%

category: 'adding nodes'
method: RBSequenceNode
addNode: aNode
	aNode parent: self.
	(statements notEmpty and: [ statements last isReturn ])
		ifTrue: [ self error: 'Cannot add statement after return node' ].
	statements := statements asOrderedCollection
		add: aNode;
		yourself.
	^ aNode
%

category: 'adding nodes'
method: RBSequenceNode
addNode: aNode before: anotherNode
	| index |
	index := self indexOfNode: anotherNode.
	index = 0
		ifTrue: [ ^ self addNode: aNode ].
	statements := statements asOrderedCollection
		add: aNode beforeIndex: index;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBSequenceNode
addNodeFirst: aNode
	aNode parent: self.
	statements := statements asOrderedCollection
		addFirst: aNode;
		yourself.
	^ aNode
%

category: 'adding nodes'
method: RBSequenceNode
addNodes: aCollection
	aCollection do: [ :each | each parent: self ].
	(statements notEmpty and: [ statements last isReturn ])
		ifTrue: [ self error: 'Cannot add statement after return node' ].
	statements := statements asOrderedCollection
		addAll: aCollection;
		yourself.
	^ aCollection
%

category: 'adding nodes'
method: RBSequenceNode
addNodes: aCollection before: anotherNode
	aCollection do: [ :each | self addNode: each before: anotherNode ].
	^ aCollection
%

category: 'adding nodes'
method: RBSequenceNode
addNodesFirst: aCollection
	aCollection do: [ :each | each parent: self ].
	statements := statements asOrderedCollection
		addAllFirst: aCollection;
		yourself.
	^ aCollection
%

category: 'accessing'
method: RBSequenceNode
addReturn
	| node |
	statements isEmpty
		ifTrue: [ ^ nil ].
	statements last isReturn
		ifTrue: [ ^ statements last ].
	node := RBReturnNode value: statements last.
	statements at: statements size put: node.
	node parent: self.
	^ node
%

category: 'adding nodes'
method: RBSequenceNode
addSelfReturn
	| node |
	self lastIsReturn
		ifTrue: [ ^ self statements last ].
	node := RBReturnNode value: (RBVariableNode named: 'self').
	^ self addNode: node
%

category: 'adding nodes'
method: RBSequenceNode
addTemporariesNamed: aCollection
	^ aCollection collect: [ :each | self addTemporaryNamed: each ]
%

category: 'adding nodes'
method: RBSequenceNode
addTemporaryNamed: aString 
	| variableNode |
	variableNode := RBVariableNode named: aString.
	variableNode parent: self.
	temporaries := temporaries copyWith: variableNode.
	^ variableNode
%

category: 'accessing'
method: RBSequenceNode
allDefinedVariables
	^(self temporaryNames asOrderedCollection)
		addAll: super allDefinedVariables;
		yourself
%

category: 'accessing'
method: RBSequenceNode
allTemporaryVariables
	^(self temporaryNames asOrderedCollection)
		addAll: super allTemporaryVariables;
		yourself
%

category: 'querying'
method: RBSequenceNode
bestNodeFor: anInterval 
	| node |
	node := super bestNodeFor: anInterval.
	node == self 
		ifTrue: 
			[(temporaries isEmpty and: [statements size == 1]) 
				ifTrue: [^statements first]].
	^node
%

category: 'accessing'
method: RBSequenceNode
children
	^(OrderedCollection new)
		addAll: self temporaries;
		addAll: self statements;
		yourself
%

category: 'matching'
method: RBSequenceNode
copyInContext: aDictionary 
	^ self class new
		temporaries: (self copyList: self temporaries inContext: aDictionary);
		statements: (self copyList: self statements inContext: aDictionary);
		yourself
%

category: 'testing'
method: RBSequenceNode
defines: aName 
	^temporaries anySatisfy: [:each | each name = aName]
%

category: 'testing'
method: RBSequenceNode
directlyUses: aNode 
	^false
%

category: 'comparing'
method: RBSequenceNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self statements size = anObject statements size ifFalse: [^false].
	1 to: self statements size
		do: 
			[:i | 
			((self statements at: i) equalTo: (anObject statements at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	aDictionary values asSet size = aDictionary size ifFalse: [^false].	"Not a one-to-one mapping"
	self temporaries
		do: [:each | aDictionary removeKey: each name ifAbsent: []].
	^true
%

category: 'comparing'
method: RBSequenceNode
hash
	^ (self hashForCollection: self temporaries) bitXor: (self hashForCollection: self statements)
%

category: 'private'
method: RBSequenceNode
indexOfNode: aNode 
	"Try to find the node by first looking for ==, and then for ="

	^(1 to: statements size) detect: [:each | (statements at: each) == aNode]
		ifNone: [statements indexOf: aNode]
%

category: 'initialize-release'
method: RBSequenceNode
initialize
	super initialize.
	periods := statements := temporaries := #()
%

category: 'testing'
method: RBSequenceNode
isLast: aNode 
	| last |
	statements isEmpty ifTrue: [^false].
	last := statements last.
	^last == aNode or: 
			[last isMessage and: 
					[(#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: last selector) 
						and: [last arguments anySatisfy: [:each | each isLast: aNode]]]]
%

category: 'testing'
method: RBSequenceNode
isSequence
	^true
%

category: 'testing'
method: RBSequenceNode
lastIsReturn
	^statements notEmpty and: [statements last lastIsReturn]
%

category: 'accessing-token'
method: RBSequenceNode
leftBar
	^ leftBar
%

category: 'accessing-token'
method: RBSequenceNode
leftBar: anInteger
	leftBar := anInteger
%

category: 'initialize-release'
method: RBSequenceNode
leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 
	leftBar := leftInteger.
	self temporaries: variableNodes.
	rightBar := rightInteger
%

category: 'matching'
method: RBSequenceNode
match: aNode inContext: aDictionary 
	self class = aNode class ifFalse: [^false].
	^(self 
		matchList: temporaries
		against: aNode temporaries
		inContext: aDictionary) and: 
				[self 
					matchList: statements
					against: aNode statements
					inContext: aDictionary]
%

category: 'accessing'
method: RBSequenceNode
methodComments
	| methodComments |
	methodComments := OrderedCollection withAll: self comments.
	temporaries do: [:each | methodComments addAll: each comments].
	(parent notNil and: [parent isBlock]) 
		ifTrue: [parent arguments do: [:each | methodComments addAll: each comments]].
	^methodComments asSortedCollection: [:a :b | a first < b first]
%

category: 'accessing-token'
method: RBSequenceNode
periods
	^ periods
%

category: 'accessing-token'
method: RBSequenceNode
periods: anArray
	periods := anArray
%

category: 'copying'
method: RBSequenceNode
postCopy
	super postCopy.
	self temporaries: (self temporaries collect: [ :each | each copy ]).
	self statements: (self statements collect: [ :each | each copy ])
%

category: 'testing'
method: RBSequenceNode
references: aVariableName 
	^statements anySatisfy: [:each | each references: aVariableName]
%

category: 'replacing'
method: RBSequenceNode
removeDeadCode
	(self isUsed ifTrue: [statements size - 1] ifFalse: [statements size]) 
		to: 1
		by: -1
		do: 
			[:i | 
			(statements at: i) isImmediateNode 
				ifTrue: 
					[self clearReplacements.
					statements removeAtIndex: i]].
	super removeDeadCode
%

category: 'replacing'
method: RBSequenceNode
removeNode: aNode
	self replaceNode: aNode withNodes: #()
%

category: 'accessing'
method: RBSequenceNode
removeTemporaryNamed: aName 
	temporaries := temporaries reject: [:each | each name = aName]
%

category: 'replacing'
method: RBSequenceNode
replaceNode: aNode withNode: anotherNode 
	self statements: (statements 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).
	self temporaries: (temporaries 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'replacing'
method: RBSequenceNode
replaceNode: aNode withNodes: aCollection 
	| index newStatements |
	self clearReplacements.
	index := self indexOfNode: aNode.
	newStatements := OrderedCollection new: statements size + aCollection size.
	1 to: index - 1 do: [:i | newStatements add: (statements at: i)].
	newStatements addAll: aCollection.
	index + 1 to: statements size
		do: [:i | newStatements add: (statements at: i)].
	aCollection do: [:each | each parent: self].
	statements := newStatements
%

category: 'accessing-token'
method: RBSequenceNode
rightBar
	^ rightBar
%

category: 'accessing-token'
method: RBSequenceNode
rightBar: anInteger
	rightBar := anInteger
%

category: 'accessing'
method: RBSequenceNode
start
	^leftBar isNil 
		ifTrue: [statements isEmpty ifTrue: [1] ifFalse: [statements first start]]
		ifFalse: [leftBar]
%

category: 'accessing'
method: RBSequenceNode
statements
	^statements
%

category: 'accessing'
method: RBSequenceNode
statements: stmtCollection 
	statements := stmtCollection.
	statements do: [:each | each parent: self]
%

category: 'accessing'
method: RBSequenceNode
stop
	^(periods isEmpty ifTrue: [0] ifFalse: [periods last]) 
		max: (statements isEmpty ifTrue: [0] ifFalse: [statements last stop])
%

category: 'accessing'
method: RBSequenceNode
temporaries
	^temporaries
%

category: 'accessing'
method: RBSequenceNode
temporaries: tempCollection 
	temporaries := tempCollection.
	temporaries do: [:each | each parent: self]
%

category: 'accessing'
method: RBSequenceNode
temporaryNames
	^temporaries collect: [:each | each name]
%

category: 'accessing'
method: RBSequenceNode
temporaryVariables
	^(super temporaryVariables asOrderedCollection)
		addAll: self temporaryNames;
		yourself
%

category: 'testing'
method: RBSequenceNode
uses: aNode 
	statements isEmpty ifTrue: [^false].
	aNode == statements last ifFalse: [^false].
	^self isUsed
%

category: 'querying'
method: RBSequenceNode
whichNodeIsContainedBy: anInterval 
	| node |
	node := super whichNodeIsContainedBy: anInterval.
	node == self 
		ifTrue: 
			[(temporaries isEmpty and: [statements size == 1]) 
				ifTrue: [^statements first]].
	^node
%

! Class implementation for 'RBValueNode'

!		Instance methods for 'RBValueNode'

category: 'accessing'
method: RBValueNode
addParenthesis: anInterval 
	parentheses isNil ifTrue: [parentheses := OrderedCollection new: 1].
	parentheses add: anInterval
%

category: 'testing'
method: RBValueNode
containedBy: anInterval 
	^anInterval first <= self startWithoutParentheses 
		and: [anInterval last >= self stopWithoutParentheses]
%

category: 'testing'
method: RBValueNode
hasParentheses
	^self parentheses notEmpty
%

category: 'testing'
method: RBValueNode
isValue
	^true
%

category: 'testing'
method: RBValueNode
needsParenthesis
	^self subclassResponsibility
%

category: 'accessing'
method: RBValueNode
parentheses
	^parentheses isNil ifTrue: [#()] ifFalse: [parentheses]
%

category: 'accessing'
method: RBValueNode
start
	^parentheses isNil 
		ifTrue: [self startWithoutParentheses]
		ifFalse: [parentheses last first]
%

category: 'accessing'
method: RBValueNode
startWithoutParentheses
	^self subclassResponsibility
%

category: 'accessing'
method: RBValueNode
stop
	^parentheses isNil
		ifTrue: [self stopWithoutParentheses]
		ifFalse: [parentheses last last]
%

category: 'accessing'
method: RBValueNode
stopWithoutParentheses
	^self subclassResponsibility
%

! Class implementation for 'RBArrayNode'

!		Class methods for 'RBArrayNode'

category: 'instance creation'
classmethod: RBArrayNode
statements: statements
	^ self new statements: statements
%

!		Instance methods for 'RBArrayNode'

category: 'comparing'
method: RBArrayNode
= anObject 
	self == anObject ifTrue: [ ^ true ].
	self class = anObject class ifFalse: [ ^ false ].
	self statements size = anObject statements size ifFalse: [ ^ false ].
	1 to: self statements size do: [ :i | 
		(self statements at: i) = (anObject statements at: i) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'visitor'
method: RBArrayNode
acceptVisitor: aProgramNodeVisitor
	^ aProgramNodeVisitor acceptArrayNode: self
%

category: 'adding nodes'
method: RBArrayNode
addNode: aNode
	statements := statements asOrderedCollection
		add: aNode;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBArrayNode
addNode: aNode before: anotherNode 
	| index |
	aNode isReturn 
		ifTrue: [ self error: 'Cannot add return node' ].
	index := self indexOfNode: anotherNode.
	index = 0 ifTrue: [ ^ self addNode: aNode ].
	statements := statements asOrderedCollection
		add: aNode beforeIndex: index;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBArrayNode
addNodeFirst: aNode
	statements := statements asOrderedCollection
		addFirst: aNode;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBArrayNode
addNodes: aCollection
	statements := statements asOrderedCollection
		addAll: aCollection;
		yourself.
	aCollection do: [ :each | each parent: self ].
	^ aCollection
%

category: 'adding nodes'
method: RBArrayNode
addNodes: aCollection before: anotherNode 
	aCollection do: [ :each | self addNode: each before: anotherNode ].
	^ aCollection
%

category: 'adding nodes'
method: RBArrayNode
addNodesFirst: aCollection
	statements := statements asOrderedCollection
		addAllFirst: aCollection;
		yourself.
	aCollection do: [ :each | each parent: self ].
	^ aCollection
%

category: 'accessing'
method: RBArrayNode
children
	^ self statements
%

category: 'matching'
method: RBArrayNode
copyInContext: aDictionary 
	^ self class statements: (self copyList: self statements inContext: aDictionary)
%

category: 'comparing'
method: RBArrayNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class 
		ifFalse: [ ^ false ].
	self statements size = anObject statements size 
		ifFalse: [ ^ false ].
	self statements with: anObject statements do: [ :first :second |
		(first equalTo: second withMapping: aDictionary)
			ifFalse: [ ^ false ] ].
	aDictionary values asSet size = aDictionary size 
		ifFalse: [ ^ false ].
	^ true
%

category: 'comparing'
method: RBArrayNode
hash
	^ self hashForCollection: self statements
%

category: 'private'
method: RBArrayNode
indexOfNode: aNode 
	"Try to find the node by first looking for ==, and then for ="

	^ (1 to: statements size) 
		detect: [ :each | (statements at: each) == aNode ]
		ifNone: [ statements indexOf: aNode ]
%

category: 'initialize-release'
method: RBArrayNode
initialize
	super initialize.
	statements := periods := #()
%

category: 'testing'
method: RBArrayNode
isArray
	^ true
%

category: 'testing'
method: RBArrayNode
lastIsReturn
	statements isEmpty ifTrue:[ ^false ].
	^statements last lastIsReturn
%

category: 'accessing-token'
method: RBArrayNode
left
	^ left
%

category: 'accessing-token'
method: RBArrayNode
left: anInteger
	left := anInteger
%

category: 'matching'
method: RBArrayNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [ ^ false ].
	^ self matchList: statements against: aNode statements inContext: aDictionary
%

category: 'testing'
method: RBArrayNode
needsParenthesis
	^ false
%

category: 'accessing-token'
method: RBArrayNode
periods
	^ periods
%

category: 'accessing-token'
method: RBArrayNode
periods: anArray
	periods := anArray
%

category: 'copying'
method: RBArrayNode
postCopy
	super postCopy.
	self statements: (self statements collect: [ :each | each copy ])
%

category: 'accessing'
method: RBArrayNode
precedence
	^0
%

category: 'testing'
method: RBArrayNode
references: aVariableName 
	^ statements anySatisfy: [ :each | each references: aVariableName ]
%

category: 'replacing'
method: RBArrayNode
replaceNode: oldNode  withNode: newNode
	self statements: (statements collect: [ :statement |
		statement == oldNode 
			ifTrue: [ newNode ]
			ifFalse: [ statement ] ])
%

category: 'accessing-token'
method: RBArrayNode
right
	^ right
%

category: 'accessing-token'
method: RBArrayNode
right: anInteger
	right := anInteger
%

category: 'accessing'
method: RBArrayNode
startWithoutParentheses 
	^ left
%

category: 'accessing'
method: RBArrayNode
statementComments
	^self comments
%

category: 'accessing'
method: RBArrayNode
statements
	^statements
%

category: 'accessing'
method: RBArrayNode
statements: statements0 
	statements := statements0.
	statements do: [:statement | statement parent: self]
%

category: 'accessing'
method: RBArrayNode
stopWithoutParentheses 
	^ right
%

category: 'testing'
method: RBArrayNode
uses: aNode 
	^ (statements anySatisfy: [ :each | each == aNode ]) or: [ self isUsed ]
%

! Class implementation for 'RBAssignmentNode'

!		Class methods for 'RBAssignmentNode'

category: 'instance creation'
classmethod: RBAssignmentNode
variable: aVariableNode value: aValueNode 
	^self 
		variable: aVariableNode
		value: aValueNode
		position: nil
%

category: 'instance creation'
classmethod: RBAssignmentNode
variable: aVariableNode value: aValueNode position: anInteger 
	^(self new)
		variable: aVariableNode
			value: aValueNode
			position: anInteger;
		yourself
%

!		Instance methods for 'RBAssignmentNode'

category: 'comparing'
method: RBAssignmentNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	^self variable = anObject variable and: [self value = anObject value]
%

category: 'visitor'
method: RBAssignmentNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptAssignmentNode: self
%

category: 'accessing-token'
method: RBAssignmentNode
assignment
	^ assignment
%

category: 'accessing-token'
method: RBAssignmentNode
assignment: anInteger
	assignment := anInteger
%

category: 'accessing'
method: RBAssignmentNode
assignmentOperator
	^ (self assignmentPosition notNil and: [ self source notNil and: [ (self source at: self assignmentPosition ifAbsent: [ nil ]) = $_ ] ])
		ifTrue: [ '_' ]
		ifFalse: [ ':=' ]
%

category: 'accessing'
method: RBAssignmentNode
assignmentPosition
	^ assignment
%

category: 'testing'
method: RBAssignmentNode
assigns: aVariableName 
	^variable name = aVariableName or: [value assigns: aVariableName]
%

category: 'querying'
method: RBAssignmentNode
bestNodeFor: anInterval 
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	assignment isNil ifTrue: [^super bestNodeFor: anInterval].
	((anInterval first between: assignment and: assignment + 1) 
		or: [assignment between: anInterval first and: anInterval last]) 
			ifTrue: [^self].
	self children do: 
			[:each | 
			| node |
			node := each bestNodeFor: anInterval.
			node notNil ifTrue: [^node]]
%

category: 'accessing'
method: RBAssignmentNode
children
	^Array with: value with: variable
%

category: 'matching'
method: RBAssignmentNode
copyInContext: aDictionary 
	^ self class new
		variable: (self variable copyInContext: aDictionary);
		value: (self value copyInContext: aDictionary);
		yourself
%

category: 'testing'
method: RBAssignmentNode
directlyUses: aNode 
	^aNode = value ifTrue: [true] ifFalse: [self isDirectlyUsed]
%

category: 'comparing'
method: RBAssignmentNode
equalTo: anObject withMapping: aDictionary 
	^self class = anObject class and: 
			[(self variable equalTo: anObject variable withMapping: aDictionary) 
				and: [self value equalTo: anObject value withMapping: aDictionary]]
%

category: 'comparing'
method: RBAssignmentNode
hash
	^self variable hash bitXor: self value hash
%

category: 'testing'
method: RBAssignmentNode
isAssignment
	^true
%

category: 'matching'
method: RBAssignmentNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^(variable match: aNode variable inContext: aDictionary)
		and: [value match: aNode value inContext: aDictionary]
%

category: 'testing'
method: RBAssignmentNode
needsParenthesis
	^parent isNil 
		ifTrue: [false]
		ifFalse: [self precedence > parent precedence]
%

category: 'copying'
method: RBAssignmentNode
postCopy
	super postCopy.
	self variable: self variable copy.
	self value: self value copy
%

category: 'accessing'
method: RBAssignmentNode
precedence
	^5
%

category: 'replacing'
method: RBAssignmentNode
replaceNode: aNode withNode: anotherNode 
	value == aNode ifTrue: [self value: anotherNode].
	variable == aNode ifTrue: [self variable: anotherNode]
%

category: 'replacing'
method: RBAssignmentNode
replaceSourceWith: aNode 
	"Check if we need to convert the assignment. Also check if we are being replaced with a setter message send. If so, create the replacements to edit the original source."

	(aNode isAssignment and: [ aNode assignmentOperator ~= self assignmentOperator ]) ifTrue: [
		self addReplacement: (RBStringReplacement 
			replaceFrom: self assignmentPosition
			to: self assignmentPosition + self assignmentOperator size - 1
			with: aNode assignmentOperator).
		(aNode variable = variable and: [ aNode value = value ])
			ifTrue: [ ^ self ] ].
	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].
	aNode receiver isVariable ifFalse: [^super replaceSourceWith: aNode].
	aNode numArgs = 1 ifFalse: [^super replaceSourceWith: aNode].
	(self mappingFor: self value) = aNode arguments first 
		ifFalse: [^super replaceSourceWith: aNode].
	(self value hasParentheses not 
		and: [aNode arguments first precedence >= aNode precedence]) 
			ifTrue: 
				[self
					addReplacement: (RBStringReplacement 
								replaceFrom: self value start
								to: self value start - 1
								with: '(');
					addReplacement: (RBStringReplacement 
								replaceFrom: self value stop + 1
								to: self value stop
								with: ')')].
	self addReplacement: (RBStringReplacement 
				replaceFrom: self variable start
				to: self assignmentPosition + 1
				with: aNode receiver name , ' ' , aNode selector)
%

category: 'accessing'
method: RBAssignmentNode
startWithoutParentheses
	^variable start
%

category: 'accessing'
method: RBAssignmentNode
stopWithoutParentheses
	^value stop
%

category: 'testing'
method: RBAssignmentNode
uses: aNode 
	^aNode = value ifTrue: [true] ifFalse: [self isUsed]
%

category: 'accessing'
method: RBAssignmentNode
value
	^value
%

category: 'accessing'
method: RBAssignmentNode
value: aValueNode 
	value := aValueNode.
	value parent: self
%

category: 'accessing'
method: RBAssignmentNode
variable
	^variable
%

category: 'accessing'
method: RBAssignmentNode
variable: varNode 
	variable := varNode.
	variable parent: self
%

category: 'initialize-release'
method: RBAssignmentNode
variable: aVariableNode value: aValueNode position: anInteger 
	self variable: aVariableNode.
	self value: aValueNode.
	assignment := anInteger
%

! Class implementation for 'RBBlockNode'

!		Class methods for 'RBBlockNode'

category: 'instance creation'
classmethod: RBBlockNode
arguments: argNodes body: sequenceNode 
	^(self new)
		arguments: argNodes;
		body: sequenceNode;
		yourself
%

category: 'instance creation'
classmethod: RBBlockNode
body: sequenceNode 
	^self arguments: #() body: sequenceNode
%

!		Instance methods for 'RBBlockNode'

category: 'comparing'
method: RBBlockNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	self body = anObject body ifFalse: [^false].
	self arguments size = anObject arguments size ifFalse: [^false].
	1 to: self arguments size
		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBBlockNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptBlockNode: self
%

category: 'accessing'
method: RBBlockNode
allArgumentVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allArgumentVariables;
		yourself
%

category: 'accessing'
method: RBBlockNode
allDefinedVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allDefinedVariables;
		yourself
%

category: 'accessing'
method: RBBlockNode
argumentNames
	^self arguments collect: [:each | each name]
%

category: 'accessing'
method: RBBlockNode
arguments
	^arguments
%

category: 'accessing'
method: RBBlockNode
arguments: argCollection 
	arguments := argCollection.
	arguments do: [:each | each parent: self]
%

category: 'accessing-token'
method: RBBlockNode
bar
	^ bar
%

category: 'accessing-token'
method: RBBlockNode
bar: anInteger
	bar := anInteger
%

category: 'accessing'
method: RBBlockNode
blockVariables
	| vars |
	vars := super blockVariables asOrderedCollection.
	vars addAll: self argumentNames.
	^vars
%

category: 'accessing'
method: RBBlockNode
body
	^body
%

category: 'accessing'
method: RBBlockNode
body: stmtsNode 
	body := stmtsNode.
	body parent: self
%

category: 'accessing'
method: RBBlockNode
children
	^self arguments copyWith: self body
%

category: 'accessing-token'
method: RBBlockNode
colons
	^ colons
%

category: 'accessing-token'
method: RBBlockNode
colons: anArray 
	colons := anArray
%

category: 'matching'
method: RBBlockNode
copyInContext: aDictionary 
	^ self class new
		arguments: (self copyList: self arguments inContext: aDictionary);
		body: (self body copyInContext: aDictionary);
		yourself
%

category: 'testing'
method: RBBlockNode
defines: aName 
	^arguments anySatisfy: [:each | each name = aName]
%

category: 'testing'
method: RBBlockNode
directlyUses: aNode 
	^false
%

category: 'comparing'
method: RBBlockNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self arguments size = anObject arguments size ifFalse: [^false].
	1 to: self arguments size
		do: 
			[:i | 
			((self arguments at: i) equalTo: (anObject arguments at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	(self body equalTo: anObject body withMapping: aDictionary)
		ifFalse: [^false].
	self arguments do: [:each | aDictionary removeKey: each name].
	^true
%

category: 'comparing'
method: RBBlockNode
hash
	^ (self hashForCollection: self arguments) bitXor: self body hash
%

category: 'testing'
method: RBBlockNode
isBlock
	^true
%

category: 'testing'
method: RBBlockNode
isImmediateNode
	^true
%

category: 'testing'
method: RBBlockNode
isLast: aNode 
	^body isLast: aNode
%

category: 'accessing-token'
method: RBBlockNode
left
	^ left
%

category: 'accessing-token'
method: RBBlockNode
left: anInteger
	left := anInteger
%

category: 'matching'
method: RBBlockNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^(self 
		matchList: arguments
		against: aNode arguments
		inContext: aDictionary) 
			and: [body match: aNode body inContext: aDictionary]
%

category: 'testing'
method: RBBlockNode
needsParenthesis
	^false
%

category: 'copying'
method: RBBlockNode
postCopy
	super postCopy.
	self arguments: (self arguments collect: [ :each | each copy ]).
	self body: self body copy
%

category: 'accessing'
method: RBBlockNode
precedence
	^0
%

category: 'testing'
method: RBBlockNode
references: aVariableName 
	^body references: aVariableName
%

category: 'replacing'
method: RBBlockNode
replaceNode: aNode withNode: anotherNode 
	body == aNode ifTrue: [self body: anotherNode].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'accessing-token'
method: RBBlockNode
right
	^ right
%

category: 'accessing-token'
method: RBBlockNode
right: anInteger
	right := anInteger
%

category: 'accessing'
method: RBBlockNode
startWithoutParentheses
	^left
%

category: 'accessing'
method: RBBlockNode
statementComments
	^self comments
%

category: 'accessing'
method: RBBlockNode
stopWithoutParentheses
	^right
%

category: 'testing'
method: RBBlockNode
uses: aNode 
	aNode = body ifFalse: [^false].
	^parent isMessage 
		ifTrue: 
			[(#(#ifTrue:ifFalse: #ifTrue: #ifFalse: #ifFalse:ifTrue:) 
				includes: parent selector) not 
				or: [parent isUsed]]
		ifFalse: [self isUsed]
%

! Class implementation for 'RBPatternBlockNode'

!		Instance methods for 'RBPatternBlockNode'

category: 'visitor'
method: RBPatternBlockNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptPatternBlockNode: self
%

category: 'matching'
method: RBPatternBlockNode
addArgumentWithNameBasedOn: aString to: aRBBlockNode 
	| name index vars |
	name := aString.
	vars := aRBBlockNode allDefinedVariables.
	index := 0.
	[vars includes: name] whileTrue: 
			[index := index + 1.
			name := name , index printString].
	aRBBlockNode 
		arguments: (aRBBlockNode arguments copyWith: (RBVariableNode named: name))
%

category: 'matching'
method: RBPatternBlockNode
constructLookupNodeFor: aString in: aRBBlockNode 
	| argumentNode |
	argumentNode := RBLiteralNode literalToken: (RBLiteralToken 
						value: aString
						start: nil
						stop: nil).
	^RBMessageNode 
		receiver: (RBVariableNode named: 'self')
		selector: #lookupMatchFor:in:
		arguments: (Array with: argumentNode with: aRBBlockNode arguments last)
%

category: 'matching'
method: RBPatternBlockNode
copyInContext: aDictionary 
	^ self replacingBlock value: aDictionary
%

category: 'matching'
method: RBPatternBlockNode
createBlockFor: aRBBlockNode
  | source |
  self replacePatternNodesIn: aRBBlockNode.
  source := aRBBlockNode formattedCode.
  ^ (source
    _compileInContext: self
    symbolList: GsSession currentSession symbolList
    oldLitVars: nil
    environmentId: 0) _executeInContext: self
%

category: 'matching'
method: RBPatternBlockNode
createMatchingBlock
	| newBlock |
	self arguments size > 2 
		ifTrue: 
			[self 
				error: 'Search blocks can only contain arguments for the node and matching dictionary'].
	newBlock := RBBlockNode arguments: arguments body: body.
	newBlock arguments isEmpty 
		ifTrue: [self addArgumentWithNameBasedOn: 'aNode' to: newBlock].
	newBlock arguments size = 1 
		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].
	^self createBlockFor: newBlock
%

category: 'matching'
method: RBPatternBlockNode
createReplacingBlock
	| newBlock |
	self arguments size > 1 
		ifTrue: 
			[self 
				error: 'Replace blocks can only contain an argument for the matching dictionary'].
	newBlock := RBBlockNode arguments: arguments body: body.
	self arguments isEmpty 
		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].
	^self createBlockFor: newBlock
%

category: 'matching'
method: RBPatternBlockNode
lookupMatchFor: aString in: aDictionary 
	^aDictionary at: aString
		ifAbsent: 
			[| variableNode |
			variableNode := RBPatternVariableNode named: aString.
			aDictionary at: variableNode ifAbsent: [nil]]
%

category: 'matching'
method: RBPatternBlockNode
match: aNode inContext: aDictionary 
	^self matchingBlock value: aNode value: aDictionary
%

category: 'matching'
method: RBPatternBlockNode
matchingBlock
	^valueBlock isNil 
		ifTrue: [valueBlock := self createMatchingBlock]
		ifFalse: [valueBlock]
%

category: 'matching'
method: RBPatternBlockNode
replacePatternNodesIn: aRBBlockNode 
	aRBBlockNode body nodesDo: 
			[:each | 
			(each isVariable and: [each isPatternNode]) 
				ifTrue: 
					[each 
						replaceWith: (self constructLookupNodeFor: each name in: aRBBlockNode)]]
%

category: 'matching'
method: RBPatternBlockNode
replacingBlock
	^valueBlock isNil 
		ifTrue: [valueBlock := self createReplacingBlock]
		ifFalse: [valueBlock]
%

category: 'accessing'
method: RBPatternBlockNode
sentMessages
	^ OrderedCollection new
%

! Class implementation for 'RBPatternWrapperBlockNode'

!		Instance methods for 'RBPatternWrapperBlockNode'

category: 'visitor'
method: RBPatternWrapperBlockNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptPatternWrapperBlockNode: self
%

category: 'matching'
method: RBPatternWrapperBlockNode
copyInContext: aDictionary 
	"I don't know what this would mean, so ignore it."

	^ wrappedNode copyInContext: aDictionary
%

category: 'matching'
method: RBPatternWrapperBlockNode
match: aNode inContext: aDictionary 
	(wrappedNode match: aNode inContext: aDictionary) ifFalse: [^false].
	^super match: aNode inContext: aDictionary
%

category: 'accessing'
method: RBPatternWrapperBlockNode
precedence
	^1
%

category: 'accessing'
method: RBPatternWrapperBlockNode
wrappedNode
	^wrappedNode
%

category: 'accessing'
method: RBPatternWrapperBlockNode
wrappedNode: aRBProgramNode 
	wrappedNode := aRBProgramNode.
	aRBProgramNode parent: self
%

! Class implementation for 'RBQueryBlockNode'

!		Instance methods for 'RBQueryBlockNode'

category: 'visitor'
method: RBQueryBlockNode
acceptVisitor: aProgramNodeVisitor
  ^ aProgramNodeVisitor acceptQueryBlockNode: self
%

! Class implementation for 'RBCascadeNode'

!		Class methods for 'RBCascadeNode'

category: 'instance creation'
classmethod: RBCascadeNode
messages: messageNodes 
	^self new messages: messageNodes
%

category: 'instance creation'
classmethod: RBCascadeNode
messages: messageNodes semicolons: integerCollection 
	^self new messages: messageNodes semicolons: integerCollection
%

!		Instance methods for 'RBCascadeNode'

category: 'comparing'
method: RBCascadeNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	self messages size = anObject messages size ifFalse: [^false].
	1 to: self messages size
		do: [:i | (self messages at: i) = (anObject messages at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBCascadeNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptCascadeNode: self
%

category: 'querying'
method: RBCascadeNode
bestNodeFor: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	messages 
		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].
	selectedChildren := (messages 
				collect: [:each | each bestNodeFor: anInterval]) 
					reject: [:each | each isNil].
	^selectedChildren detect: [:each | true] ifNone: [nil]
%

category: 'accessing'
method: RBCascadeNode
children
	^self messages
%

category: 'matching'
method: RBCascadeNode
copyInContext: aDictionary 
	^ self class new
		messages: (self copyList: self messages inContext: aDictionary);
		yourself
%

category: 'testing'
method: RBCascadeNode
directlyUses: aNode 
	^messages last = aNode and: [self isDirectlyUsed]
%

category: 'comparing'
method: RBCascadeNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self messages size = anObject messages size ifFalse: [^false].
	1 to: self messages size
		do: 
			[:i | 
			((self messages at: i) equalTo: (anObject messages at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true
%

category: 'comparing'
method: RBCascadeNode
hash
	^ self hashForCollection: self messages
%

category: 'testing'
method: RBCascadeNode
isCascade
	^true
%

category: 'matching'
method: RBCascadeNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^self 
		matchList: messages
		against: aNode messages
		inContext: aDictionary
%

category: 'accessing'
method: RBCascadeNode
messages
	^messages
%

category: 'accessing'
method: RBCascadeNode
messages: messageNodeCollection 
	messages := messageNodeCollection.
	messages do: [:each | each parent: self]
%

category: 'initialize-release'
method: RBCascadeNode
messages: messageNodes semicolons: integerCollection 
	self messages: messageNodes.
	semicolons := integerCollection
%

category: 'testing'
method: RBCascadeNode
needsParenthesis
	^parent isNil 
		ifTrue: [false]
		ifFalse: [self precedence > parent precedence]
%

category: 'copying'
method: RBCascadeNode
postCopy
	super postCopy.
	self messages: (self messages collect: [ :each | each copy ])
%

category: 'accessing'
method: RBCascadeNode
precedence
	^4
%

category: 'accessing'
method: RBCascadeNode
receiver
	^self messages first receiver
%

category: 'replacing'
method: RBCascadeNode
replaceNode: aNode withNode: anotherNode 
	self messages: (messages 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'accessing-token'
method: RBCascadeNode
semicolons
	^ semicolons
%

category: 'accessing-token'
method: RBCascadeNode
semicolons: anArray
	semicolons := anArray
%

category: 'accessing'
method: RBCascadeNode
startWithoutParentheses
	^messages first start
%

category: 'accessing'
method: RBCascadeNode
statementComments
	| statementComments |
	statementComments := OrderedCollection withAll: self comments.
	statementComments addAll: messages first receiver statementComments.
	messages do: 
			[:each | 
			each arguments 
				do: [:arg | statementComments addAll: arg statementComments]].
	^statementComments asSortedCollection: [:a :b | a first < b first]
%

category: 'accessing'
method: RBCascadeNode
stopWithoutParentheses
	^messages last stop
%

category: 'testing'
method: RBCascadeNode
uses: aNode 
	^messages last = aNode and: [self isUsed]
%

category: 'querying'
method: RBCascadeNode
whichNodeIsContainedBy: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	messages 
		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].
	selectedChildren := (messages 
				collect: [:each | each whichNodeIsContainedBy: anInterval]) 
					reject: [:each | each isNil].
	^selectedChildren detect: [:each | true] ifNone: [nil]
%

! Class implementation for 'RBLiteralNode'

!		Class methods for 'RBLiteralNode'

category: 'instance creation'
classmethod: RBLiteralNode
literalToken: aLiteralToken 
	^(aLiteralToken realValue class == Array 
		or: [aLiteralToken realValue class == ByteArray]) 
			ifTrue: 
				[RBLiteralArrayNode 
					startPosition: aLiteralToken start
					contents: (aLiteralToken value asArray 
							collect: [:each | RBLiteralNode literalToken: each])
					stopPosition: aLiteralToken stop
					isByteArray: aLiteralToken value class ~~ Array]
			ifFalse: [RBLiteralValueNode literalToken: aLiteralToken]
%

category: 'instance creation'
classmethod: RBLiteralNode
value: aValue 
	^((aValue class == Array or: [aValue class == ByteArray]) 
		ifTrue: [RBLiteralArrayNode]
		ifFalse: [RBLiteralValueNode]) value: aValue
%

!		Instance methods for 'RBLiteralNode'

category: 'comparing'
method: RBLiteralNode
= anObject 
	self == anObject ifTrue: [^true].
	^self class = anObject class
%

category: 'comparing'
method: RBLiteralNode
hash
	^self value hash
%

category: 'testing'
method: RBLiteralNode
isImmediateNode
	^true
%

category: 'testing'
method: RBLiteralNode
isLiteralNode
	^true
%

category: 'testing'
method: RBLiteralNode
needsParenthesis
	^false
%

category: 'accessing'
method: RBLiteralNode
precedence
	^0
%

category: 'private-replacing'
method: RBLiteralNode
replaceSourceFrom: aNode 
	self addReplacement: (RBStringReplacement 
				replaceFrom: aNode start
				to: aNode stop
				with: self formattedCode)
%

category: 'private-replacing'
method: RBLiteralNode
replaceSourceWith: aNode 
	self addReplacement: (RBStringReplacement 
				replaceFrom: self start
				to: self stop
				with: aNode formattedCode)
%

category: 'accessing'
method: RBLiteralNode
value
	^self subclassResponsibility
%

! Class implementation for 'RBLiteralArrayNode'

!		Class methods for 'RBLiteralArrayNode'

category: 'instance creation'
classmethod: RBLiteralArrayNode
startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 
	^(self new)
		startPosition: startInteger
			contents: anArray
			stopPosition: stopInteger
			isByteArray: aBoolean;
		yourself
%

category: 'instance creation'
classmethod: RBLiteralArrayNode
value: aValue 
	^(self new)
		startPosition: nil
			contents: (aValue asArray collect: [:each | RBLiteralNode value: each])
			stopPosition: nil
			isByteArray: aValue class ~~ Array;
		yourself
%

!		Instance methods for 'RBLiteralArrayNode'

category: 'comparing'
method: RBLiteralArrayNode
= anObject 
	super = anObject ifFalse: [^false].
	self isForByteArray = anObject isForByteArray ifFalse: [^false].
	self contents size = anObject contents size ifFalse: [^false].
	1 to: self contents size
		do: [:i | (self contents at: i) = (anObject contents at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBLiteralArrayNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptLiteralArrayNode: self
%

category: 'accessing'
method: RBLiteralArrayNode
children
	^contents
%

category: 'accessing'
method: RBLiteralArrayNode
contents
	^contents
%

category: 'initialize-release'
method: RBLiteralArrayNode
contents: aRBLiteralNodeCollection 
	contents := aRBLiteralNodeCollection.
	contents do: [:each | each parent: self]
%

category: 'matching'
method: RBLiteralArrayNode
copyInContext: aDictionary 
	^ self class 
		startPosition: nil
		contents: (self copyList: self contents inContext: aDictionary)
		stopPosition: nil
		isByteArray: isByteArray
%

category: 'comparing'
method: RBLiteralArrayNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self isForByteArray = anObject isForByteArray ifFalse: [^false].
	self contents size = anObject contents size ifFalse: [^false].
	1 to: self contents size
		do: 
			[:i | 
			((self contents at: i) equalTo: (anObject contents at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true
%

category: 'testing'
method: RBLiteralArrayNode
isForByteArray
	^isByteArray
%

category: 'testing'
method: RBLiteralArrayNode
isLiteralArray
	^true
%

category: 'matching'
method: RBLiteralArrayNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	self isForByteArray = aNode isForByteArray ifFalse: [^false].
	^self 
		matchList: contents
		against: aNode contents
		inContext: aDictionary
%

category: 'copying'
method: RBLiteralArrayNode
postCopy
	super postCopy.
	self contents: (self contents collect: [ :each | each copy ])
%

category: 'replacing'
method: RBLiteralArrayNode
replaceNode: aNode withNode: anotherNode 
	self contents: (contents 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'private-replacing'
method: RBLiteralArrayNode
replaceSourceWith: aNode 
	(self class = aNode class and: 
			[self isForByteArray = aNode isForByteArray 
				and: [self contents size = aNode contents size]]) 
		ifFalse: [^super replaceSourceWith: aNode].
	1 to: self contents size
		do: 
			[:i | 
			(self contents at: i) = (aNode contents at: i) 
				ifFalse: [(self contents at: i) replaceSourceWith: (aNode contents at: i)]]
%

category: 'initialize-release'
method: RBLiteralArrayNode
startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 
	start := startInteger.
	self contents: anArray.
	stop := stopInteger.
	isByteArray := aBoolean
%

category: 'accessing'
method: RBLiteralArrayNode
startWithoutParentheses
	^start
%

category: 'accessing'
method: RBLiteralArrayNode
stopWithoutParentheses
	^stop
%

category: 'accessing'
method: RBLiteralArrayNode
value
	| array |
	array := (isByteArray ifTrue: [ByteArray] ifFalse: [Array]) 
				new: contents size.
	1 to: contents size
		do: [:each | array at: each put: (contents at: each) value].
	^array
%

! Class implementation for 'RBLiteralValueNode'

!		Class methods for 'RBLiteralValueNode'

category: 'instance creation'
classmethod: RBLiteralValueNode
literalToken: aLiteralToken 
	^(self new)
		literalToken: aLiteralToken;
		yourself
%

category: 'instance creation'
classmethod: RBLiteralValueNode
value: aValue 
	^self literalToken: (RBLiteralToken value: aValue)
%

!		Instance methods for 'RBLiteralValueNode'

category: 'comparing'
method: RBLiteralValueNode
= anObject 
	^ super = anObject 
		and: [ self value = anObject value 
		and: [ self value species = anObject value species ] ]
%

category: 'visitor'
method: RBLiteralValueNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptLiteralNode: self
%

category: 'matching'
method: RBLiteralValueNode
copyInContext: aDictionary
	^ self class literalToken: self token copy removePositions
%

category: 'initialize-release'
method: RBLiteralValueNode
literalToken: aLiteralToken 
	token := aLiteralToken
%

category: 'accessing'
method: RBLiteralValueNode
startWithoutParentheses
	^token start
%

category: 'accessing'
method: RBLiteralValueNode
stopWithoutParentheses
	^token stop
%

category: 'accessing'
method: RBLiteralValueNode
token
	^token
%

category: 'accessing'
method: RBLiteralValueNode
value
	^token realValue
%

! Class implementation for 'RBMessageNode'

!		Class methods for 'RBMessageNode'

category: 'instance creation'
classmethod: RBMessageNode
receiver: aValueNode selector: aSymbol 
	^self 
		receiver: aValueNode
		selector: aSymbol
		arguments: #()
%

category: 'instance creation'
classmethod: RBMessageNode
receiver: aValueNode selector: aSymbol arguments: valueNodes 
	^(self new)
		receiver: aValueNode;
		arguments: valueNodes;
		selector: aSymbol;
		yourself
%

category: 'instance creation'
classmethod: RBMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	^(self new)
		receiver: aValueNode
			selectorParts: keywordTokens
			arguments: valueNodes;
		yourself
%

!		Instance methods for 'RBMessageNode'

category: 'comparing'
method: RBMessageNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	(self receiver = anObject receiver 
		and: [self selector = anObject selector]) ifFalse: [^false].
	1 to: self arguments size
		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBMessageNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptMessageNode: self
%

category: 'accessing'
method: RBMessageNode
arguments
	^arguments isNil ifTrue: [#()] ifFalse: [arguments]
%

category: 'accessing'
method: RBMessageNode
arguments: argCollection 
	arguments := argCollection.
	arguments do: [:each | each parent: self]
%

category: 'querying'
method: RBMessageNode
bestNodeFor: anInterval 
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	selectorParts do: 
			[:each | 
			((anInterval first between: each start and: each stop) 
				or: [each start between: anInterval first and: anInterval last]) 
					ifTrue: [^self]].
	self children do: 
			[:each | 
			| node |
			node := each bestNodeFor: anInterval.
			node notNil ifTrue: [^node]]
%

category: 'private'
method: RBMessageNode
buildSelector
	| selectorStream |
	selectorStream := WriteStreamPortable on: String new.
	selectorParts do: [ :each | selectorStream nextPutAll: each value ].
	^ selectorStream contents asSymbol
%

category: 'accessing'
method: RBMessageNode
children
	^(OrderedCollection with: self receiver)
		addAll: self arguments;
		yourself
%

category: 'matching'
method: RBMessageNode
copyInContext: aDictionary 
	^ self class new
		receiver: (self receiver copyInContext: aDictionary);
		selectorParts: (self selectorParts collect: [ :each | each copy removePositions ]);
		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);
		yourself
%

category: 'comparing'
method: RBMessageNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	((self receiver equalTo: anObject receiver withMapping: aDictionary)
		and: [self selector = anObject selector]) ifFalse: [^false].
	1 to: self arguments size
		do: 
			[:i | 
			((self arguments at: i) equalTo: (anObject arguments at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true
%

category: 'comparing'
method: RBMessageNode
hash
	^ (self receiver hash bitXor: self selector hash) bitXor: (self hashForCollection: self arguments)
%

category: 'testing'
method: RBMessageNode
isBinary
	^(self isUnary or: [self isKeyword]) not
%

category: 'testing'
method: RBMessageNode
isCascaded
	^parent notNil and: [parent isCascade]
%

category: 'private-replacing'
method: RBMessageNode
isContainmentReplacement: aNode 
	^(self mappingFor: self receiver) = aNode 
		or: [self arguments anySatisfy: [:each | (self mappingFor: each) = aNode]]
%

category: 'testing'
method: RBMessageNode
isFirstCascaded
	^self isCascaded and: [parent messages first == self]
%

category: 'testing'
method: RBMessageNode
isKeyword
	^selectorParts first value last = $:
%

category: 'testing'
method: RBMessageNode
isMessage
	^true
%

category: 'testing'
method: RBMessageNode
isSelfSend
	^ self receiver isVariable and: [ self receiver name = 'self' ]
%

category: 'testing'
method: RBMessageNode
isSuperSend
	^ self receiver isVariable and: [ self receiver name = 'super' ]
%

category: 'testing'
method: RBMessageNode
isUnary
	^arguments isEmpty
%

category: 'testing'
method: RBMessageNode
lastIsReturn
	^ (#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifNil:ifNotNil: #ifNotNil:ifNil:) includes: self selector)
		and: [ arguments first isBlock and: [ arguments first body lastIsReturn 
		and: [ arguments last isBlock and: [ arguments last body lastIsReturn ] ] ] ]
%

category: 'matching'
method: RBMessageNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	self selector = aNode selector ifFalse: [^false].
	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].
	1 to: arguments size
		do: 
			[:i | 
			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary)
				ifFalse: [^false]].
	^true
%

category: 'testing'
method: RBMessageNode
needsParenthesis
	^parent isNil 
		ifTrue: [false]
		ifFalse: 
			[self precedence > parent precedence 
				or: [self precedence = parent precedence and: [self isUnary not]]]
%

category: 'accessing'
method: RBMessageNode
numArgs
	^self selector numArgs
%

category: 'copying'
method: RBMessageNode
postCopy
	super postCopy.
	self receiver: self receiver copy.
	self arguments: (self arguments collect: [ :each | each copy ])
%

category: 'accessing'
method: RBMessageNode
precedence
	^self isUnary 
		ifTrue: [1]
		ifFalse: [self isKeyword ifTrue: [3] ifFalse: [2]]
%

category: 'accessing'
method: RBMessageNode
receiver
	^receiver
%

category: 'accessing'
method: RBMessageNode
receiver: aValueNode 
	receiver := aValueNode.
	receiver parent: self
%

category: 'initialize-release'
method: RBMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	self receiver: aValueNode.
	selectorParts := keywordTokens.
	self arguments: valueNodes
%

category: 'accessing'
method: RBMessageNode
renameSelector: newSelector andArguments: varNodeCollection 
	self
		arguments: varNodeCollection;
		selector: newSelector
%

category: 'private-replacing'
method: RBMessageNode
replaceContainmentSourceWith: aNode 
	| originalNode needsParenthesis |
	needsParenthesis := aNode hasParentheses not and: [aNode needsParenthesis].
	originalNode := (self mappingFor: self receiver) = aNode 
				ifTrue: [self receiver]
				ifFalse: [self arguments detect: [:each | (self mappingFor: each) = aNode]].
	self
		addReplacement: (RBStringReplacement 
					replaceFrom: self start
					to: originalNode start - 1
					with: (needsParenthesis ifTrue: ['('] ifFalse: ['']));
		addReplacement: (RBStringReplacement 
					replaceFrom: originalNode stop + 1
					to: self stop
					with: (needsParenthesis ifTrue: [')'] ifFalse: ['']))
%

category: 'replacing'
method: RBMessageNode
replaceNode: aNode withNode: anotherNode 
	"If we're inside a cascade node and are changing the receiver, change all the receivers"

	receiver == aNode 
		ifTrue: 
			[self receiver: anotherNode.
			(parent notNil and: [parent isCascade]) 
				ifTrue: [parent messages do: [:each | each receiver: anotherNode]]].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'private-replacing'
method: RBMessageNode
replaceSourceWith: aNode 
	(self isContainmentReplacement: aNode) 
		ifTrue: [^self replaceContainmentSourceWith: aNode].
	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].
	^self replaceSourceWithMessageNode: aNode
%

category: 'private-replacing'
method: RBMessageNode
replaceSourceWithMessageNode: aNode 
	| isBinaryToKeyword |
	self numArgs = aNode numArgs ifFalse: [^super replaceSourceWith: aNode].
	self arguments with: aNode arguments
		do: [:old :new | (self mappingFor: old) = new ifFalse: [^super replaceSourceWith: aNode]].
	(self mappingFor: self receiver) = aNode receiver 
		ifFalse:
			[(self receiver isVariable and: [aNode receiver isVariable])
				ifFalse:
					[^super replaceSourceWith: aNode].
			self addReplacement:
				(RBStringReplacement
					replaceFrom: self receiver start
					to: self receiver stop
					with: aNode receiver name)].
	(isBinaryToKeyword := self isBinary and: [aNode isKeyword]) 
		ifTrue: 
			[(self hasParentheses not and: [self parent precedence <= aNode precedence]) 
				ifTrue: 
					[self
						addReplacement: (RBStringReplacement 
									replaceFrom: self start
									to: self start - 1
									with: '(');
						addReplacement: (RBStringReplacement 
									replaceFrom: self stop + 1
									to: self stop
									with: ')')]].
	self selectorParts with: aNode selectorParts
		do: 
			[:old :new | 
			old value ~= new value 
				ifTrue: 
					[self addReplacement: (RBStringReplacement 
								replaceFrom: old start
								to: old stop
								with: ((isBinaryToKeyword 
										and: [(self source at: old start - 1) isSqueakSeparator not]) 
											ifTrue: [' ' , new value]
											ifFalse: [new value]))]]
%

category: 'accessing'
method: RBMessageNode
selector
	^selector isNil
		ifTrue: [selector := self buildSelector]
		ifFalse: [selector]
%

category: 'accessing'
method: RBMessageNode
selector: aSelector 
	| keywords numArgs |
	keywords := aSelector keywords.
	numArgs := aSelector numArgs.
	numArgs == arguments size 
		ifFalse: 
			[self 
				error: 'Attempting to assign selector with wrong number of arguments.'].
	selectorParts := numArgs == 0 
				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]
				ifFalse: 
					[keywords first last = $: 
						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]
						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].
	selector := aSelector asSymbol
%

category: 'private'
method: RBMessageNode
selectorParts
	^ selectorParts
%

category: 'private'
method: RBMessageNode
selectorParts: tokenCollection 
	selectorParts := tokenCollection
%

category: 'accessing'
method: RBMessageNode
sentMessages
	^ super sentMessages
		add: self selector;
		yourself
%

category: 'accessing'
method: RBMessageNode
startWithoutParentheses
	^receiver start
%

category: 'accessing'
method: RBMessageNode
stopWithoutParentheses
	^arguments isEmpty 
		ifTrue: [selectorParts first stop]
		ifFalse: [arguments last stop]
%

! Class implementation for 'RBPatternMessageNode'

!		Class methods for 'RBPatternMessageNode'

category: 'instance creation'
classmethod: RBPatternMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	^(keywordTokens anySatisfy: [:each | each isPatternVariable]) 
		ifTrue: 
			[super 
				receiver: aValueNode
				selectorParts: keywordTokens
				arguments: valueNodes]
		ifFalse: 
			[RBMessageNode 
				receiver: aValueNode
				selectorParts: keywordTokens
				arguments: valueNodes]
%

!		Instance methods for 'RBPatternMessageNode'

category: 'matching'
method: RBPatternMessageNode
copyInContext: aDictionary 
	| selectors |
	self isList 
		ifTrue: [ ^ aDictionary at: self ].
	selectors := self isSelectorList 
		ifTrue: [ (aDictionary at: selectorParts first value) keywords ]
		ifFalse: [ self selectorParts collect: [ :each | aDictionary at: each value ] ].
	^ RBMessageNode new
		receiver: (self receiver copyInContext: aDictionary);
		selectorParts: (selectors collect: [ :each | 
			(each last = $: ifTrue: [ RBKeywordToken ] ifFalse: [ RBIdentifierToken ]) 
				value: each start: nil ]);
		arguments: (self copyList: self arguments inContext: aDictionary);
		yourself
%

category: 'testing-matching'
method: RBPatternMessageNode
isList
	^isCascadeList and: [parent notNil and: [parent isCascade]]
%

category: 'testing-matching'
method: RBPatternMessageNode
isPatternNode
	^true
%

category: 'testing-matching'
method: RBPatternMessageNode
isSelectorList
	^isList
%

category: 'matching'
method: RBPatternMessageNode
match: aNode inContext: aDictionary 
	aNode class == self matchingClass ifFalse: [^false].
	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].
	self isSelectorList 
		ifTrue: 
			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector]) 
				== aNode selector and: 
						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments]) 
							= aNode arguments]].
	^self matchArgumentsAgainst: aNode inContext: aDictionary
%

category: 'matching'
method: RBPatternMessageNode
matchArgumentsAgainst: aNode inContext: aDictionary 
	self arguments size = aNode arguments size
		ifFalse: [ ^ false ].
	(self matchSelectorAgainst: aNode inContext: aDictionary) 
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'private'
method: RBPatternMessageNode
matchingClass
	^RBMessageNode
%

category: 'matching'
method: RBPatternMessageNode
matchSelectorAgainst: aNode inContext: aDictionary 
	self selectorParts with: aNode selectorParts do: [ :first :second |
		| keyword |
		keyword := aDictionary
			at: first value
			ifAbsentPut: [ 
				first isPatternVariable 
					ifTrue: [ second value ]
					ifFalse: [ first value ] ].
		keyword = second value 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'initialize-release'
method: RBPatternMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	| message |
	super 
		receiver: aValueNode
		selectorParts: keywordTokens
		arguments: valueNodes.
	isCascadeList := isList := false.
	message := keywordTokens first value.
	2 to: message size
		do: 
			[:i | 
			| character |
			character := message at: i.
			character == self listCharacter 
				ifTrue: [isList := true]
				ifFalse: 
					[character == self cascadeListCharacter 
						ifTrue: [isCascadeList := true]
						ifFalse: [^self]]]
%

category: 'accessing'
method: RBPatternMessageNode
sentMessages
	^ super sentMessages
		remove: self selector ifAbsent: [ ];
		yourself
%

! Class implementation for 'RBVariableNode'

!		Class methods for 'RBVariableNode'

category: 'instance creation'
classmethod: RBVariableNode
identifierToken: anIdentifierToken 
	^(self new)
		identifierToken: anIdentifierToken;
		yourself
%

category: 'instance creation'
classmethod: RBVariableNode
named: aString 
	^self identifierToken: (RBIdentifierToken value: aString start: 0)
%

!		Instance methods for 'RBVariableNode'

category: 'comparing'
method: RBVariableNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	^self name = anObject name
%

category: 'visitor'
method: RBVariableNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptVariableNode: self
%

category: 'matching'
method: RBVariableNode
copyInContext: aDictionary 
	^ self class identifierToken: token copy removePositions
%

category: 'comparing'
method: RBVariableNode
equalTo: anObject withMapping: aDictionary 
	^self class = anObject class and: 
			[(aDictionary at: self name ifAbsentPut: [anObject name]) = anObject name]
%

category: 'comparing'
method: RBVariableNode
hash
	^self name hash
%

category: 'initialize-release'
method: RBVariableNode
identifierToken: anIdentifierToken 
	token := anIdentifierToken
%

category: 'testing'
method: RBVariableNode
isImmediateNode
	^true
%

category: 'testing'
method: RBVariableNode
isRead
	^ self isWrite not and: [ self isUsed ]
%

category: 'testing'
method: RBVariableNode
isVariable
	^true
%

category: 'testing'
method: RBVariableNode
isWrite
	^ self parent notNil and: [ self parent isAssignment and: [ self parent variable == self ] ]
%

category: 'accessing'
method: RBVariableNode
name
	^token value
%

category: 'testing'
method: RBVariableNode
needsParenthesis
	^false
%

category: 'accessing'
method: RBVariableNode
precedence
	^0
%

category: 'testing'
method: RBVariableNode
references: aVariableName 
	^self name = aVariableName
%

category: 'replacing'
method: RBVariableNode
replaceSourceFrom: aNode 
	self addReplacement: (RBStringReplacement 
				replaceFrom: aNode start
				to: aNode stop
				with: self name)
%

category: 'replacing'
method: RBVariableNode
replaceSourceWith: aNode
	self addReplacement: (RBStringReplacement 
				replaceFrom: self start
				to: self stop
				with: aNode formattedCode)
%

category: 'accessing'
method: RBVariableNode
startWithoutParentheses
	^token start
%

category: 'accessing'
method: RBVariableNode
stopWithoutParentheses
	^token stop
%

category: 'accessing'
method: RBVariableNode
token
	^ token
%

! Class implementation for 'RBPatternVariableNode'

!		Class methods for 'RBPatternVariableNode'

category: 'instance creation'
classmethod: RBPatternVariableNode
identifierToken: anIdentifierToken 
	^anIdentifierToken isPatternVariable 
		ifTrue: [super identifierToken: anIdentifierToken]
		ifFalse: [RBVariableNode identifierToken: anIdentifierToken]
%

!		Instance methods for 'RBPatternVariableNode'

category: 'matching'
method: RBPatternVariableNode
copyInContext: aDictionary 
	^ (aDictionary at: self) copy
%

category: 'initialize-release'
method: RBPatternVariableNode
identifierToken: anIdentifierToken 
	super identifierToken: anIdentifierToken.
	self initializePatternVariables
%

category: 'initialize-release'
method: RBPatternVariableNode
initializePatternVariables
	| name |
	name := self name.
	isAnything := isList := isLiteral := isStatement := recurseInto := false.
	2 to: name size
		do: 
			[:i | 
			| character |
			character := name at: i.
			character == self listCharacter 
				ifTrue: [isAnything := isList := true]
				ifFalse: 
					[character == self literalCharacter 
						ifTrue: [isLiteral := true]
						ifFalse: 
							[character == self statementCharacter 
								ifTrue: [isStatement := true]
								ifFalse: 
									[character == self recurseIntoCharacter 
										ifTrue: [recurseInto := true]
										ifFalse: [^self]]]]]
%

category: 'testing-matching'
method: RBPatternVariableNode
isAnything
	^isAnything
%

category: 'testing-matching'
method: RBPatternVariableNode
isList
	^isList
%

category: 'testing-matching'
method: RBPatternVariableNode
isLiteralNode
	^isLiteral
%

category: 'testing-matching'
method: RBPatternVariableNode
isPatternNode
	^true
%

category: 'testing-matching'
method: RBPatternVariableNode
isStatement
	^isStatement
%

category: 'matching'
method: RBPatternVariableNode
match: aNode inContext: aDictionary 
	self isAnything 
		ifTrue: [^(aDictionary at: self ifAbsentPut: [aNode]) = aNode].
	self isLiteralNode ifTrue: [^self matchLiteral: aNode inContext: aDictionary].
	self isStatement 
		ifTrue: [^self matchStatement: aNode inContext: aDictionary].
	aNode class == self matchingClass ifFalse: [^false].
	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode
%

category: 'private'
method: RBPatternVariableNode
matchingClass
	^RBVariableNode
%

category: 'matching'
method: RBPatternVariableNode
matchLiteral: aNode inContext: aDictionary 
	^aNode isLiteralNode
		and: [(aDictionary at: self ifAbsentPut: [aNode]) = aNode]
%

category: 'matching'
method: RBPatternVariableNode
matchStatement: aNode inContext: aDictionary 
	(aNode parent notNil and: [aNode parent isSequence]) ifFalse: [^false].
	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode
%

category: 'accessing'
method: RBPatternVariableNode
parent: aBRProgramNode 
	"Fix the case where '``@node' should match a single node, not a sequence node."

	super parent: aBRProgramNode.
	parent isSequence 
		ifTrue: 
			[(self isStatement or: [parent temporaries includes: self]) 
				ifFalse: [isList := false]]
%

category: 'testing-matching'
method: RBPatternVariableNode
recurseInto
	^recurseInto
%

! Class implementation for 'RBProgramNodeVisitor'

!		Class methods for 'RBProgramNodeVisitor'

category: 'instance creation'
classmethod: RBProgramNodeVisitor
new

	^self basicNew initialize
%

!		Instance methods for 'RBProgramNodeVisitor'

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptArrayNode: anArrayNode 
	anArrayNode children do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptAssignmentNode: anAssignmentNode 
	self visitNode: anAssignmentNode variable.
	self visitNode: anAssignmentNode value
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptBlockNode: aBlockNode 
	self visitArguments: aBlockNode arguments.
	self visitNode: aBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptCascadeNode: aCascadeNode 
	aCascadeNode messages do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptLiteralArrayNode: aRBLiteralArrayNode 
	aRBLiteralArrayNode contents do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptLiteralNode: aLiteralNode
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptMessageNode: aMessageNode 
	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 
		ifTrue: [self visitNode: aMessageNode receiver].
	aMessageNode arguments do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptMethodNode: aMethodNode 
	self visitArguments: aMethodNode arguments.
	aMethodNode pragmas
		do: [ :each | self visitNode: each ].
	self visitNode: aMethodNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptPatternBlockNode: aRBPatternBlockNode 
	self visitArguments: aRBPatternBlockNode arguments.
	self visitNode: aRBPatternBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	self visitArguments: aRBPatternWrapperBlockNode arguments.
	self visitNode: aRBPatternWrapperBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptPragmaNode: aPragmaNode
	aPragmaNode arguments do: [ :each | self visitNode: each ]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptQueryBlockNode: aBlockNode
  self visitArguments: aBlockNode arguments.
  self visitNode: aBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptReturnNode: aReturnNode 
	self visitNode: aReturnNode value
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptSequenceNode: aSequenceNode 
	self visitArguments: aSequenceNode temporaries.
	aSequenceNode statements do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptVariableNode: aVariableNode
%

category: 'initialize release'
method: RBProgramNodeVisitor
initialize
%

category: 'visiting'
method: RBProgramNodeVisitor
visitArgument: each 
	"Here to allow subclasses to detect arguments or temporaries."

	^self visitNode: each
%

category: 'visiting'
method: RBProgramNodeVisitor
visitArguments: aNodeCollection 
	^aNodeCollection do: [:each | self visitArgument: each]
%

category: 'visiting'
method: RBProgramNodeVisitor
visitNode: aNode 
	^aNode acceptVisitor: self
%

! Class implementation for 'RBConfigurableFormatter'

!		Class methods for 'RBConfigurableFormatter'

category: 'accessing'
classmethod: RBConfigurableFormatter
cascadedMessageInsideParentheses
	^ CascadedMessageInsideParentheses
%

category: 'accessing'
classmethod: RBConfigurableFormatter
cascadedMessageInsideParentheses: aBoolean
	CascadedMessageInsideParentheses := aBoolean
%

category: 'public'
classmethod: RBConfigurableFormatter
format: aParseTree 
	^self format: aParseTree withIndents: 0
%

category: 'public'
classmethod: RBConfigurableFormatter
format: aParseTree withIndents: anInteger 
	^ self new
		indent: anInteger;
		format: aParseTree
%

category: 'accessing'
classmethod: RBConfigurableFormatter
formatCommentWithStatements
	^ FormatCommentWithStatements
%

category: 'accessing'
classmethod: RBConfigurableFormatter
formatCommentWithStatements: aBoolean
	FormatCommentWithStatements := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentsForKeywords
	^ IndentsForKeywords
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentsForKeywords: anInteger
	IndentsForKeywords := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentString
	^ IndentString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentString: aString
	IndentString := aString
%

category: 'initialization'
classmethod: RBConfigurableFormatter
initialize
  InQueryBlock := false.
  CascadedMessageInsideParentheses := false.
  FormatCommentWithStatements := true.
  IndentString := '  '.
  IndentsForKeywords := 1.
  KeepBlockInMessage := true.
  LineUpBlockBrackets := false.
  MaxLineLength := 80.
  MethodSignatureOnMultipleLines := false.
  MinimumNewLinesBetweenStatements := 1.
  MultiLineMessages := #(#'ifTrue:ifFalse:' #'ifFalse:ifTrue:' #'ifTrue:' #'ifFalse:' #'on:do:' #'ensure:' #'ifCurtailed:').
  NewLineAfterCascade := true.
  NewLineBeforeFirstCascade := true.
  NewLineBeforeFirstKeyword := false.
  NewLinesAfterMethodComment := 2.
  NewLinesAfterMethodPattern := 1.
  NewLinesAfterTemporaries := 1.
  NumberOfArgumentsForMultiLine := 4.
  OneLineMessages := #(#'to:' #'to:do:' #'to:by:' #'to:by:do:').
  PeriodsAtEndOfBlock := false.
  PeriodsAtEndOfMethod := false.
  RetainBlankLinesBetweenStatements := false.
  StringFollowingReturn := ' '.
  StringInsideBlocks := ' '.
  StringInsideParentheses := ''.
  TraditionalBinaryPrecedence := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).
  UseTraditionalBinaryPrecedenceForParentheses := true
%

category: 'accessing'
classmethod: RBConfigurableFormatter
keepBlockInMessage
	^ KeepBlockInMessage
%

category: 'accessing'
classmethod: RBConfigurableFormatter
keepBlockInMessage: aBoolean
	KeepBlockInMessage := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
lineUpBlockBrackets
	^ LineUpBlockBrackets
%

category: 'accessing'
classmethod: RBConfigurableFormatter
lineUpBlockBrackets: aBoolean
	LineUpBlockBrackets := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
maxLineLength
	^ MaxLineLength
%

category: 'accessing'
classmethod: RBConfigurableFormatter
maxLineLength: anInteger
	MaxLineLength := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
methodSignatureOnMultipleLines
	^ MethodSignatureOnMultipleLines
%

category: 'accessing'
classmethod: RBConfigurableFormatter
methodSignatureOnMultipleLines: aBoolean
	MethodSignatureOnMultipleLines := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
minimumNewLinesBetweenStatements
	^ MinimumNewLinesBetweenStatements
%

category: 'accessing'
classmethod: RBConfigurableFormatter
minimumNewLinesBetweenStatements: anInteger
	MinimumNewLinesBetweenStatements := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineAfterCascade
	^ NewLineAfterCascade
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineAfterCascade: aBoolean
	NewLineAfterCascade := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstCascade
	^ NewLineBeforeFirstCascade
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstCascade: aBoolean
	NewLineBeforeFirstCascade := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstKeyword
	^ NewLineBeforeFirstKeyword
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstKeyword: aBoolean
	NewLineBeforeFirstKeyword := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodComment
	^ NewLinesAfterMethodComment
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodComment: anInteger
	NewLinesAfterMethodComment := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodPattern
	^ NewLinesAfterMethodPattern
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodPattern: anInteger
	NewLinesAfterMethodPattern := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterTemporaries
	^ NewLinesAfterTemporaries
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterTemporaries: anInteger
	NewLinesAfterTemporaries := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
numberOfArgumentsForMultiLine
	^ NumberOfArgumentsForMultiLine
%

category: 'accessing'
classmethod: RBConfigurableFormatter
numberOfArgumentsForMultiLine: anInteger
	NumberOfArgumentsForMultiLine := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAsTerminators
	^ PeriodsAtEndOfBlock and: [ PeriodsAtEndOfMethod ]
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAsTerminators: aBoolean
	PeriodsAtEndOfBlock := aBoolean.
	PeriodsAtEndOfMethod := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfBlock
	^ PeriodsAtEndOfBlock
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfBlock: aBoolean
	PeriodsAtEndOfBlock := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfMethod
	^ PeriodsAtEndOfMethod
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfMethod: aBoolean
	PeriodsAtEndOfMethod := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
retainBlankLinesBetweenStatements
	^ RetainBlankLinesBetweenStatements
%

category: 'accessing'
classmethod: RBConfigurableFormatter
retainBlankLinesBetweenStatements: aBoolean
	RetainBlankLinesBetweenStatements := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringFollowingReturn
	^ StringFollowingReturn
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringFollowingReturn: aString
	StringFollowingReturn := aString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideBlocks
	^ StringInsideBlocks
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideBlocks: aString
	StringInsideBlocks := aString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideParentheses
	^ StringInsideParentheses
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideParentheses: aString
	StringInsideParentheses := aString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
useTraditionalBinaryPrecedenceForParentheses
	^ UseTraditionalBinaryPrecedenceForParentheses
%

category: 'accessing'
classmethod: RBConfigurableFormatter
useTraditionalBinaryPrecedenceForParentheses: aBoolean
	UseTraditionalBinaryPrecedenceForParentheses := aBoolean
%

!		Instance methods for 'RBConfigurableFormatter'

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptArrayNode: anArrayNode
	self bracketWith: '{}' around: [ self formatArray: anArrayNode ]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptAssignmentNode: anAssignmentNode 
	self visitNode: anAssignmentNode variable.
	codeStream space; nextPutAll: anAssignmentNode assignmentOperator; space.
	self visitNode: anAssignmentNode value
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptBlockNode: aBlockNode
	self bracketWith: '[]' around: [self formatBlock: aBlockNode]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptCascadeNode: aCascadeNode 
	self visitNode: aCascadeNode receiver.
	self indentAround: 
			[NewLineBeforeFirstCascade ifTrue: [self newLine] ifFalse: [self space].
			aCascadeNode messages do: 
					[:each | 
					self indentAround: 
							[self 
								formatSelectorAndArguments: each
								firstSeparator: []
								restSeparator: ((self isMultiLineMessage: each) 
										ifTrue: [[self newLine]]
										ifFalse: [[self space]])]]
				separatedBy: 
					[codeStream nextPut: $;.
					NewLineAfterCascade ifTrue: [self newLine] ifFalse: [self space]]]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptLiteralArrayNode: aRBArrayLiteralNode 
	| brackets |
	codeStream nextPut: $#.
	brackets := aRBArrayLiteralNode isForByteArray 
				ifTrue: ['[]']
				ifFalse: ['()'].
	self bracketWith: brackets
		around: 
			[aRBArrayLiteralNode contents do: [:each | self visitNode: each]
				separatedBy: [self space]]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptLiteralNode: aLiteralNode 
	self writeString: aLiteralNode token rbStoreString
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptMessageNode: aMessageNode 
	self visitNode: aMessageNode receiver.
	self formatSelectorAndArguments: aMessageNode
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptMethodNode: aMethodNode 
	self formatMethodPatternFor: aMethodNode.
	self formatMethodBodyFor: aMethodNode
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptPatternBlockNode: aRBPatternBlockNode 
	codeStream nextPut: $`.
	self 
		bracketWith: '{}' 
		around: [self formatBlock: aRBPatternBlockNode]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	codeStream nextPut: $`.
	self 
		bracketWith: '{}' 
		around: [self formatBlock: aRBPatternWrapperBlockNode]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptPragmaNode: aPragmaNode
  codeStream nextPut: $<.
  aPragmaNode isProtected
    ifTrue: [ codeStream nextPutAll: 'protected ' ].
  self
    formatSelectorAndArguments: aPragmaNode
    firstSeparator: [ 
      aPragmaNode selector isInfix
        ifTrue: [ self space ] ]
    restSeparator: [ self space ].
  codeStream nextPut: $>
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptQueryBlockNode: aBlockNode
  self
    bracketWith: '{}'
    around: [ 
      [ 
      "query blocks are not nested"
      InQueryBlock := true.
      self formatBlock: aBlockNode ]
        ensure: [ InQueryBlock := false ] ]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptReturnNode: aReturnNode 
	codeStream
		nextPut: $^;
		nextPutAll: StringFollowingReturn.
	self visitNode: aReturnNode value
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptSequenceNode: aSequenceNode 
	self formatTemporariesFor: aSequenceNode.
	self formatSequenceCommentsFor: aSequenceNode.
	self formatSequenceNodeStatementsFor: aSequenceNode
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptVariableNode: aVariableNode 
	codeStream nextPutAll: aVariableNode name
%

category: 'private'
method: RBConfigurableFormatter
addNewLinesBeforeStatementStartingAt: anInteger 
	| newLines |
	newLines := MinimumNewLinesBetweenStatements 
				max: (RetainBlankLinesBetweenStatements 
						ifTrue: [self newLinesBeforeStartingAt: anInteger]
						ifFalse: [0]).
	newLines = 0 ifTrue: [self space] ifFalse: [self newLines: newLines]
%

category: 'private'
method: RBConfigurableFormatter
bracketWith: bracketString around: aBlock 
	bracketString isEmpty ifTrue: [^aBlock value].
	codeStream nextPut: bracketString first.
	^aBlock ensure: [codeStream nextPut: bracketString last]
%

category: 'private'
method: RBConfigurableFormatter
currentLineLength
	^codeStream position - lineStart
%

category: 'public interface'
method: RBConfigurableFormatter
format: aParseTree 
	originalSource := aParseTree source.
	self visitNode: aParseTree.
	^codeStream contents
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatArray: anArrayNode
	self formatSequenceCommentsFor: anArrayNode.
	self formatSequenceNodeStatementsFor: anArrayNode
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatBlock: aBlockNode
	(LineUpBlockBrackets and: [ self willBeMultiline: aBlockNode body ])
		ifTrue: [ self newLine ]
		ifFalse: [ codeStream nextPutAll: StringInsideBlocks ].
	self formatBlockArgumentsFor: aBlockNode.
	(self willBeMultiline: aBlockNode body)
		ifTrue: [ self newLine ].
	self visitNode: aBlockNode body.
	(LineUpBlockBrackets and: [ self willBeMultiline: aBlockNode body ])
		ifTrue: [ self newLine ]
		ifFalse: [ codeStream nextPutAll: StringInsideBlocks ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatBlockArgumentsFor: aBlockNode
	aBlockNode arguments isEmpty
		ifTrue: [ ^ self ].
	aBlockNode arguments
		do: [ :each | 
			codeStream nextPut: $:.
			self visitNode: each.
			FormatCommentWithStatements
				ifTrue: [ self formatCommentsFor: each ].
			self space ].
	codeStream nextPutAll: '| '
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatCommentsFor: aNode 
	originalSource isNil ifTrue: [^self].
	aNode comments do: 
			[:each | 
			codeStream
				space;
				nextPutAll: (originalSource copyFrom: each first to: each last)]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatMethodBodyFor: aMethodNode 
	self
		indentAround: 
			[self newLines: NewLinesAfterMethodPattern.
			self formatMethodCommentFor: aMethodNode.
			self formatPragmasFor: aMethodNode.
			self visitNode: aMethodNode body]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatMethodCommentFor: aMethodNode
	originalSource isNil ifTrue: [^self].
	(FormatCommentWithStatements
		ifTrue: [aMethodNode methodComments]
		ifFalse: [aMethodNode comments])
		do:
			[:each | 
			codeStream
				nextPutAll:
					(originalSource
						copyFrom: each first
						to: each last).
			self newLines: NewLinesAfterMethodComment]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatMethodPatternFor: aMethodNode 
	aMethodNode arguments isEmpty
		ifTrue: [codeStream nextPutAll: aMethodNode selector]
		ifFalse: 
			[self
				with: aMethodNode selectorParts
				and: aMethodNode arguments
				do: 
					[:key :arg | 
					codeStream nextPutAll: key value.
					self space.
					self visitNode: arg]
				separatedBy: 
					[MethodSignatureOnMultipleLines
						ifTrue: [self newLine]
						ifFalse: [self space]]]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatPragmasFor: aMethodNode
	aMethodNode pragmas do: [ :each | self visitNode: each; newLine ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSelectorAndArguments: aMessageNode
	| newLineBetweenArguments |
	newLineBetweenArguments := self isMultiLineMessage: aMessageNode.
	self
		indent:
			(newLineBetweenArguments
				ifTrue: [ IndentsForKeywords ]
				ifFalse: [ 0 ])
		around: [ 
			self
				formatSelectorAndArguments: aMessageNode
				firstSeparator:
					((newLineBetweenArguments or: [ NewLineBeforeFirstKeyword ])
						ifTrue: [ [ self newLine ] ]
						ifFalse: [ [ self space ] ])
				restSeparator:
					(newLineBetweenArguments
						ifTrue: [ [ self newLine ] ]
						ifFalse: [ [ self space ] ]) ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSelectorAndArguments: aMessageNode firstSeparator: firstBlock restSeparator: restBlock
	| separatorBlock |
	separatorBlock := firstBlock.
	aMessageNode isUnary
		ifTrue: [ 
			(self isLineTooLong: aMessageNode selector)
				ifTrue: [ self newLine ]
				ifFalse: [ separatorBlock value ].
			codeStream nextPutAll: aMessageNode selector ]
		ifFalse: [ 
			aMessageNode selectorParts
				with: aMessageNode arguments
				do: [ :selector :argument | 
					(self isLineTooLong: selector value)
						ifTrue: [ self newLine ]
						ifFalse: [ separatorBlock value ].
					separatorBlock := restBlock.
					self
						indentAround: [ 
							codeStream nextPutAll: selector value.
							(KeepBlockInMessage and: [ argument isBlock ])
								ifTrue: [ 
									self
										space;
										visitNode: argument ]
								ifFalse: [ 
									((self willBeMultiline: argument) or: [ self isLineTooLong: (self formattedSourceFor: argument) ])
										ifTrue: [ self newLine ]
										ifFalse: [ self space ].
									self visitNode: argument ] ] ] ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSequenceCommentsFor: aSequenceNode
	originalSource isNil ifTrue: [^self].
	aSequenceNode comments
		do:
			[:each | 
			codeStream
				nextPutAll:
					(originalSource
						copyFrom: each first
						to: each last).
			self newLine]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSequenceNodeStatementsFor: aSequenceNode 
	| statements |
	statements := aSequenceNode statements.
	statements isEmpty ifTrue: [^self].
	1 to: statements size
		do: 
			[:i | 
			self visitNode: (statements at: i).
			(i < statements size or: 
					[| parent |
					(parent := aSequenceNode parent) ifNil: [self class periodsAsTerminators]
						ifNotNil: 
							[ 
							parent isBlock 
								ifTrue: [self class periodsAtEndOfBlock]
								ifFalse: [self class periodsAtEndOfMethod]]]) 
				ifTrue: [codeStream nextPut: $.].
			self formatStatementCommentsFor: (statements at: i).
			i < statements size 
				ifTrue: 
					[self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start]]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatStatementCommentsFor: aStatementNode
	originalSource isNil ifTrue: [^self].
	FormatCommentWithStatements ifFalse: [^self].
	aStatementNode statementComments
		do:
			[:each | 
			codeStream
				tab;
				nextPutAll:
						(originalSource
								copyFrom: each first
								to: each last)]
%

category: 'private'
method: RBConfigurableFormatter
formattedSourceFor: aNode 
	^lookaheadCode at: aNode
		ifAbsentPut: [self class format: aNode withIndents: indent]
%

category: 'private'
method: RBConfigurableFormatter
formatTemporariesFor: aSequenceNode
	aSequenceNode temporaries isEmpty ifTrue: [^self].
	self
		bracketWith: '|'
		around:
			[self space.
			aSequenceNode temporaries
				do:
					[:each | 
					self visitNode: each.
					FormatCommentWithStatements ifTrue: [self formatCommentsFor: each].
					self space]].
	self newLines: NewLinesAfterTemporaries
%

category: 'initialize-release'
method: RBConfigurableFormatter
indent: anInteger
	indent := anInteger
%

category: 'private'
method: RBConfigurableFormatter
indent: anInteger around: aBlock 
	indent := indent + anInteger.
	^aBlock ensure: [indent := indent - anInteger]
%

category: 'private'
method: RBConfigurableFormatter
indentAround: aBlock 
	self indent: 1 around: aBlock
%

category: 'initialize-release'
method: RBConfigurableFormatter
initialize
	super initialize.
	lineStart := 0.
	indent := 0.
	lookaheadCode := IdentityDictionary new.
	codeStream := WriteStreamPortable on: String new
%

category: 'private'
method: RBConfigurableFormatter
isLineTooLong: aString 
	^ self currentLineLength + (aString indexOf: Character lf ifAbsent: [ aString size ]) >= MaxLineLength
%

category: 'private-formatting'
method: RBConfigurableFormatter
isMultiLineMessage: aMessageNode
	| messageStream |
	(MultiLineMessages includes: aMessageNode selector)
		ifTrue: [ ^ true ].
	(OneLineMessages includes: aMessageNode selector)
		ifTrue: [ ^ false ].
	(NumberOfArgumentsForMultiLine <= aMessageNode arguments size)
		ifTrue: [ ^ true ].
	(aMessageNode arguments 
		anySatisfy: [ :each | self indent: IndentsForKeywords + 1 around: [ self willBeMultiline: each ] ]) 
		ifTrue: [ ^ true ].
	aMessageNode isUnary
		ifTrue: [ ^ self isLineTooLong: aMessageNode selector ].
	messageStream := WriteStreamPortable on: String new.
	self  with: aMessageNode selectorParts and: aMessageNode arguments 
		do: [ :sel :arg | messageStream nextPutAll: sel value; space; nextPutAll: (self formattedSourceFor: arg) ]
		separatedBy: [ messageStream space ].
	^ self isLineTooLong: messageStream contents
%

category: 'private'
method: RBConfigurableFormatter
needsParenthesisFor: aNode
  | parent grandparent |
  aNode isValue
    ifFalse: [ ^ false ].
  parent := aNode parent ifNil: [ ^ false ].
  (CascadedMessageInsideParentheses
    and: [ aNode isMessage and: [ parent isMessage and: [ parent receiver == aNode ] ] ])
    ifTrue: [ 
      grandparent := parent parent.
      (grandparent notNil and: [ grandparent isCascade ])
        ifTrue: [ ^ true ] ].
  InQueryBlock
    ifTrue: [ 
      aNode isVariable
        ifTrue: [ 
          (aNode token isPath
            and: [ 
              parent isMessage
                and: [ parent receiver == aNode and: [ aNode parent selector == #'&' ] ] ])
            ifTrue: [ ^ true ] ] ].
  aNode precedence < parent precedence
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ parent isAssignment ])
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ aNode isCascade ])
    ifTrue: [ ^ true ].
  aNode precedence = 0
    ifTrue: [ ^ false ].
  aNode isMessage
    ifFalse: [ ^ true ].
  aNode precedence = parent precedence
    ifFalse: [ ^ true ].
  aNode isUnary
    ifTrue: [ ^ false ].
  aNode isKeyword
    ifTrue: [ ^ true ].
  parent receiver == aNode
    ifFalse: [ ^ true ].
  InQueryBlock
    ifTrue: [ ^ aNode receiver isMessage not and: [ aNode selector ~~ #'&' ] ].
  ^ UseTraditionalBinaryPrecedenceForParentheses
    and: [ self precedenceOf: parent selector greaterThan: aNode selector ]
%

category: 'private'
method: RBConfigurableFormatter
newLine
	self newLines: 1
%

category: 'private'
method: RBConfigurableFormatter
newLines: anInteger 
	anInteger + IndentString size = 0 ifTrue: [codeStream space].
	anInteger timesRepeat: [codeStream lf].
	lineStart := codeStream position.
	indent timesRepeat: [codeStream nextPutAll: IndentString]
%

category: 'private'
method: RBConfigurableFormatter
newLinesBeforeStartingAt: anIndex 
	| count cr lf index char |
	(anIndex isNil or: [anIndex > originalSource size]) ifTrue: [^0].
	cr := Character value: 13.
	lf := Character value: 10.
	count := 0.
	index := anIndex - 1.
	[index > 0 and: [(char := originalSource at: index) isSqueakSeparator]] 
		whileTrue: 
			[char == lf 
				ifTrue: 
					[count := count + 1.
					(originalSource at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].
			char == cr ifTrue: [count := count + 1].
			index := index - 1].
	^count
%

category: 'private'
method: RBConfigurableFormatter
precedenceOf: parentSelector greaterThan: childSelector 
	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 
	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"

	| childIndex parentIndex |
	childIndex := 0.
	parentIndex := 0.
	1 to: TraditionalBinaryPrecedence size
		do: 
			[:i | 
			((TraditionalBinaryPrecedence at: i) includes: parentSelector first) 
				ifTrue: [parentIndex := i].
			((TraditionalBinaryPrecedence at: i) includes: childSelector first) 
				ifTrue: [childIndex := i]].
	^childIndex < parentIndex
%

category: 'private'
method: RBConfigurableFormatter
space
	codeStream space
%

category: 'visiting'
method: RBConfigurableFormatter
visitNode: aNode
	| needsParenthesis |
	(lookaheadCode includesKey: aNode)
		ifTrue: [^self writeString: (lookaheadCode at: aNode)].
	needsParenthesis := self needsParenthesisFor: aNode.
	self
		bracketWith:
			(needsParenthesis
				ifTrue: ['()']
				ifFalse: [''])
		around:
			[needsParenthesis ifTrue: [codeStream nextPutAll: StringInsideParentheses].
			super visitNode: aNode.
			(FormatCommentWithStatements or: [aNode isMethod or: [aNode isSequence]])
				ifFalse: [self formatCommentsFor: aNode].
			needsParenthesis
				ifTrue: [codeStream nextPutAll: StringInsideParentheses]]
%

category: 'private'
method: RBConfigurableFormatter
willBeMultiline: aNode 
	^(self formattedSourceFor: aNode) includes: Character lf
%

category: 'utility'
method: RBConfigurableFormatter
with: firstCollection and: secondCollection do: aBlock separatedBy: separatorBlock 
	firstCollection isEmpty ifTrue: [^self].
	aBlock
		value: firstCollection first
		value: secondCollection first.
	2
		to: firstCollection size
		do: 
			[:i | 
			separatorBlock value.
			aBlock
				value: (firstCollection at: i)
				value: (secondCollection at: i)]
%

category: 'private'
method: RBConfigurableFormatter
writeString: aString 
	| index |
	index := aString lastIndexOf: Character lf ifAbsent: [0].
	codeStream nextPutAll: aString.
	index > 0 
		ifTrue: [lineStart := codeStream position - (aString size - index)]
%

! Class implementation for 'RBFormatter'

!		Instance methods for 'RBFormatter'

category: 'visitor-double dispatching'
method: RBFormatter
acceptArrayNode: anArrayNode
	codeStream nextPut: ${.
	anArrayNode statements isEmpty ifFalse: [
		anArrayNode statements size > 1
			ifTrue: [
				self indent: 1 while: [
					self indent.
					self formatStatementsFor: anArrayNode ].
				self indent ]
			ifFalse: [ self formatStatementsFor: anArrayNode ] ].
	codeStream nextPut: $}
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptAssignmentNode: anAssignmentNode 
	self indent: 2
		while: 
			[self visitNode: anAssignmentNode variable.
			codeStream space; nextPutAll: anAssignmentNode assignmentOperator; space.
			self visitNode: anAssignmentNode value]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptBlockNode: aBlockNode 
	self 
		acceptBlockNode: aBlockNode
		startBlockString: '['
		endBlockString: ']'
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString 
	| seqNode multiline formattedBody formatter |
	seqNode := aBlockNode body.
	formatter := (self copy)
				lineStart: 0;
				yourself.
	formattedBody := formatter format: seqNode.
	multiline := self lineLength + formattedBody size > self maxLineSize 
				or: [formatter isMultiLine].
	multiline ifTrue: [self indent].
	codeStream nextPutAll: startBlockString.
	aBlockNode arguments do: 
			[:each | 
			codeStream nextPut: $:.
			self visitNode: each.
			codeStream nextPut: $ ].
	aBlockNode arguments notEmpty 
		ifTrue: 
			[codeStream nextPutAll: '| '.
			multiline ifTrue: [self indent]].
	codeStream
		nextPutAll: formattedBody;
		nextPutAll: endBlockString
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptCascadeNode: aCascadeNode 
	| messages |
	messages := aCascadeNode messages.
	self visitNode: messages first receiver.
	self indentWhile: 
			[self 
				for: messages
				do: 
					[:each | 
					self
						indent;
						indentWhile: [self formatMessage: each cascade: true]]
				separatedBy: [codeStream nextPut: $;]]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptLiteralArrayNode: aRBArrayLiteralNode 
	codeStream nextPutAll: (aRBArrayLiteralNode isForByteArray 
				ifTrue: ['#[']
				ifFalse: ['#(']).
	self 
		for: aRBArrayLiteralNode contents
		do: [:each | self visitNode: each]
		separatedBy: [codeStream nextPut: $ ].
	codeStream 
		nextPut: (aRBArrayLiteralNode isForByteArray ifTrue: [$]] ifFalse: [$)])
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptLiteralNode: aLiteralNode 
	aLiteralNode token rbStoreOn: codeStream
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptMessageNode: aMessageNode 
	| newFormatter code |
	newFormatter := self copy.
	code := newFormatter format: aMessageNode receiver.
	codeStream nextPutAll: code.
	codeStream nextPut: $ .
	newFormatter isMultiLine
		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].
	self indent: (newFormatter isMultiLine ifTrue: [2] ifFalse: [1])
		while: [self formatMessage: aMessageNode cascade: false]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptMethodNode: aMethodNode 
	self formatMethodPatternFor: aMethodNode.
	self indentWhile: [
		self formatMethodCommentFor: aMethodNode indentBefore: true.
		self indent.
		self formatPragmasFor: aMethodNode.
		aMethodNode body statements notEmpty 
			ifTrue: [ self visitNode: aMethodNode body ] ]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptPatternBlockNode: aRBPatternBlockNode 
	self 
		acceptBlockNode: aRBPatternBlockNode
		startBlockString: '`{'
		endBlockString: '}'
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	self 
		acceptBlockNode: aRBPatternWrapperBlockNode
		startBlockString: '`{'
		endBlockString: '}'
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptPragmaNode: aPragmaNode
  codeStream nextPut: $<.
  aPragmaNode isProtected
    ifTrue: [ codeStream nextPutAll: 'protected ' ].
  aPragmaNode selector isInfix
    ifTrue: [ codeStream nextPut: $  ].
  self formatMessage: aPragmaNode cascade: false.
  codeStream nextPut: $>
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptQueryBlockNode: aBlockNode
  [ 
  inQueryBlock := true.
  self
    acceptQueryBlockNode: aBlockNode
    startBlockString: '{'
    endBlockString: '}' ]
    ensure: [ inQueryBlock := false ]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptQueryBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString
  | seqNode multiline formattedBody formatter |
  seqNode := aBlockNode body.
  formatter := self copy
    lineStart: 0;
    yourself.
  formattedBody := formatter format: seqNode.
  multiline := self lineLength + formattedBody size > self maxLineSize
    or: [ formatter isMultiLine ].
  multiline
    ifTrue: [ self indent ].
  codeStream nextPutAll: startBlockString.
  aBlockNode arguments
    do: [ :each | 
      codeStream nextPut: $:.
      self visitNode: each.
      codeStream nextPut: $  ].
  aBlockNode arguments notEmpty
    ifTrue: [ 
      codeStream nextPutAll: '| '.
      multiline
        ifTrue: [ self indent ] ].
  codeStream
    nextPutAll: formattedBody;
    nextPutAll: endBlockString
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptReturnNode: aReturnNode 
	codeStream nextPut: $^.
	self visitNode: aReturnNode value
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptSequenceNode: aSequenceNode 
	self formatMethodCommentFor: aSequenceNode indentBefore: false.
	self formatTemporariesFor: aSequenceNode.
	self formatStatementsFor: aSequenceNode
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptVariableNode: aVariableNode 
	codeStream nextPutAll: aVariableNode name
%

category: 'accessing'
method: RBFormatter
firstLineLength
	^firstLineLength isNil
		ifTrue: [codeStream position]
		ifFalse: [firstLineLength]
%

category: 'private'
method: RBFormatter
for: aValue do: doBlock separatedBy: separatorBlock 
	"This is implemented here since IBM Smalltalk doesn't implement a do:separatedBy: method"

	aValue isEmpty ifTrue: [^self].
	1 to: aValue size - 1
		do: 
			[:i | 
			doBlock value: (aValue at: i).
			separatorBlock value].
	doBlock value: aValue last
%

category: 'accessing'
method: RBFormatter
format: aNode 
	self visitNode: aNode.
	^codeStream contents
%

category: 'private-formatting'
method: RBFormatter
formatMessage: aMessageNode cascade: cascadeBoolean 
	| selectorParts arguments multiLine formattedArgs indentFirst firstArgLength length |
	selectorParts := aMessageNode selectorParts.
	arguments := aMessageNode arguments.
	formattedArgs := OrderedCollection new.
	multiLine := aMessageNode selector numArgs > self maximumArgumentsPerLine.
	length := aMessageNode selector size + arguments size + 1.
	firstArgLength := 0.
	self indentWhile: 
			[1 to: arguments size
				do: 
					[:i | 
					| formatter string |
					formatter := (self copy)
								lineStart: (selectorParts at: i) length negated;
								yourself.
					string := formatter format: (arguments at: i).
					formattedArgs add: string.
					i == 1 ifTrue: [firstArgLength := formatter firstLineLength].
					length := length + string size.
					multiLine := multiLine or: [formatter isMultiLine]]].
	multiLine := multiLine or: [length + self lineLength > self maxLineSize].
	indentFirst := cascadeBoolean not and: 
					[multiLine and: 
							[(self startMessageSendOnNewLine: aMessageNode) or: 
									[self lineLength + selectorParts first length + 2 + firstArgLength 
										> self maxLineSize]]].
	indentFirst ifTrue: [self indent].
	self 
		formatMessageSelector: selectorParts
		withArguments: formattedArgs
		multiline: multiLine
%

category: 'private-formatting'
method: RBFormatter
formatMessageSelector: selectorParts withArguments: formattedArgs multiline: multiLine 
	formattedArgs isEmpty 
		ifTrue: [codeStream nextPutAll: selectorParts first value]
		ifFalse: 
			[1 to: formattedArgs size
				do: 
					[:i | 
					(i ~= 1 and: [ multiLine not ])
						ifTrue: [codeStream nextPut: $ ].
					codeStream 
						nextPutAll: (selectorParts at: i) value;
						nextPut: $ ;
						nextPutAll: (formattedArgs at: i).
					(multiLine and: [i < formattedArgs size]) ifTrue: [self indent]]]
%

category: 'private-formatting'
method: RBFormatter
formatMethodCommentFor: aNode indentBefore: aBoolean 
	| source |
	source := aNode source.
	source isNil ifTrue: [^self].
	aNode methodComments do: 
			[:each | 
			aBoolean ifTrue: [self indent].
			codeStream
				nextPutAll: (aNode source copyFrom: each first to: each last);
				lf.
			aBoolean ifFalse: [self indent]]
%

category: 'private-formatting'
method: RBFormatter
formatMethodPatternFor: aMethodNode 
	| selectorParts arguments |
	selectorParts := aMethodNode selectorParts.
	arguments := aMethodNode arguments.
	arguments isEmpty 
		ifTrue: [codeStream nextPutAll: selectorParts first value]
		ifFalse: 
			[selectorParts with: arguments
				do: 
					[:selector :arg | 
					codeStream
						nextPutAll: selector value;
						nextPut: $ .
					self visitArgument: arg.
					codeStream nextPut: $ ]]
%

category: 'private-formatting'
method: RBFormatter
formatPragmasFor: aNode
	aNode pragmas do: [ :each | self visitNode: each; indent ]
%

category: 'private-formatting'
method: RBFormatter
formatStatementCommentFor: aNode 
	| source |
	source := aNode source.
	source isNil ifTrue: [^self].
	aNode statementComments do: 
			[:each | 
			| crs |
			crs := self newLinesFor: source startingAt: each first.
			(crs - 1 max: 0) timesRepeat: [codeStream lf].
			crs == 0 ifTrue: [codeStream tab] ifFalse: [self indent].
			codeStream nextPutAll: (source copyFrom: each first to: each last)]
%

category: 'private-formatting'
method: RBFormatter
formatStatementsFor: aSequenceNode 
	| statements |
	statements := aSequenceNode statements.
	statements isEmpty ifTrue: [^self].
	1 to: statements size - 1
		do: 
			[:i | 
			self visitNode: (statements at: i).
			codeStream nextPut: $..
			self formatStatementCommentFor: (statements at: i).
			self indent].
	self visitNode: statements last.
	self formatStatementCommentFor: statements last
%

category: 'private-formatting'
method: RBFormatter
formatTemporariesFor: aSequenceNode 
	| temps |
	temps := aSequenceNode temporaries.
	temps isEmpty ifTrue: [^self].
	codeStream nextPutAll: '| '.
	temps do: 
			[:each | 
			self visitArgument: each.
			codeStream nextPut: $ ].
	codeStream nextPut: $|.
	self indent
%

category: 'private'
method: RBFormatter
indent
	firstLineLength isNil ifTrue: [firstLineLength := codeStream position].
	codeStream lf.
	tabs timesRepeat: [codeStream tab].
	lineStart := codeStream position
%

category: 'private'
method: RBFormatter
indent: anInteger while: aBlock 
	tabs := tabs + anInteger.
	aBlock value.
	tabs := tabs - anInteger
%

category: 'private'
method: RBFormatter
indentWhile: aBlock 
	self indent: 1 while: aBlock
%

category: 'initialize-release'
method: RBFormatter
initialize
  super initialize.
  codeStream := WriteStreamPortable on: String new.
  tabs := 0.
  lineStart := 0.
  inQueryBlock := false
%

category: 'accessing'
method: RBFormatter
isMultiLine
	^firstLineLength notNil
%

category: 'accessing'
method: RBFormatter
lastLineLength
	^codeStream position - (lineStart max: 0)
%

category: 'private'
method: RBFormatter
lineLength
	^codeStream position - lineStart
%

category: 'private'
method: RBFormatter
lineStart: aPosition 
	lineStart := aPosition
%

category: 'private'
method: RBFormatter
maximumArgumentsPerLine
	^2
%

category: 'private'
method: RBFormatter
maxLineSize
	^75
%

category: 'private'
method: RBFormatter
needsParenthesisFor: aNode
  | parent grandparent |
  aNode isValue
    ifFalse: [ ^ false ].
  parent := aNode parent ifNil: [ ^ false ].
  (aNode isMessage and: [ parent isMessage and: [ parent receiver == aNode ] ])
    ifTrue: [ 
      grandparent := parent parent.
      (grandparent notNil and: [ grandparent isCascade ])
        ifTrue: [ ^ true ] ].
  inQueryBlock
    ifTrue: [ 
      aNode isLiteralNode
        ifTrue: [ 
          (parent isMessage
            and: [ parent receiver == aNode and: [ aNode parent selector == #'&' ] ])
            ifTrue: [ ^ true ] ].
      aNode isVariable
        ifTrue: [ 
          (aNode token isPath
            and: [ 
              parent isMessage
                and: [ parent receiver == aNode and: [ aNode parent selector == #'&' ] ] ])
            ifTrue: [ ^ true ] ] ].
  aNode precedence < parent precedence
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ parent isAssignment ])
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ aNode isCascade ])
    ifTrue: [ ^ true ].
  aNode precedence = 0
    ifTrue: [ ^ false ].
  aNode isMessage
    ifFalse: [ ^ true ].
  aNode precedence = parent precedence
    ifFalse: [ ^ true ].
  aNode isUnary
    ifTrue: [ ^ false ].
  aNode isKeyword
    ifTrue: [ ^ true ].
  parent receiver == aNode
    ifFalse: [ ^ true ].
  inQueryBlock
    ifTrue: [ ^ aNode receiver isMessage not and: [ aNode selector ~~ #'&' ] ].
  ^ self precedenceOf: parent selector greaterThan: aNode selector
%

category: 'private-formatting'
method: RBFormatter
newLinesFor: aString startingAt: anIndex 
	| count cr lf index char |
	cr := Character codePoint: 13.
	lf := Character codePoint: 10.
	count := 0.
	index := anIndex - 1.
	[index > 0 and: 
			[char := aString at: index.
			char isSeparator]] 
		whileTrue: 
			[char == lf 
				ifTrue: 
					[count := count + 1.
					(aString at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].
			char == cr ifTrue: [count := count + 1].
			index := index - 1].
	^count
%

category: 'copying'
method: RBFormatter
postCopy
	super postCopy.
	lineStart := self lineLength negated.
	codeStream := WriteStreamPortable on: String new.
	firstLineLength := nil
%

category: 'private'
method: RBFormatter
precedenceOf: parentSelector greaterThan: childSelector 
	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 
	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"

	| childIndex parentIndex operators |
	operators := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).
	childIndex := 0.
	parentIndex := 0.
	1 to: operators size
		do: 
			[:i | 
			((operators at: i) includes: parentSelector first) 
				ifTrue: [parentIndex := i].
			((operators at: i) includes: childSelector first) 
				ifTrue: [childIndex := i]].
	^childIndex < parentIndex
%

category: 'private'
method: RBFormatter
selectorsToLeaveOnLine
	^#(#to:do: #to:by: #to:by:do:)
%

category: 'private'
method: RBFormatter
selectorsToStartOnNewLine
	^#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse:)
%

category: 'testing'
method: RBFormatter
startMessageSendOnNewLine: aMessageNode 
	(self selectorsToStartOnNewLine includes: aMessageNode selector) 
		ifTrue: [^true].
	(self selectorsToLeaveOnLine includes: aMessageNode selector) 
		ifTrue: [^false].
	^aMessageNode selector numArgs > self maximumArgumentsPerLine
%

category: 'visiting'
method: RBFormatter
visitNode: aNode
  | parenthesis |
  parenthesis := self needsParenthesisFor: aNode.
  parenthesis
    ifTrue: [ codeStream nextPut: $( ].
  aNode acceptVisitor: self.
  parenthesis
    ifTrue: [ codeStream nextPut: $) ]
%

! Class implementation for 'RBParseTreeSearcher'

!		Class methods for 'RBParseTreeSearcher'

category: 'private'
classmethod: RBParseTreeSearcher
buildSelectorString: aSelector 
	| stream keywords |
	aSelector numArgs = 0 ifTrue: [^aSelector].
	stream := WriteStreamPortable on: String new.
	keywords := aSelector keywords.
	1 to: keywords size
		do: 
			[:i | 
			stream
				nextPutAll: (keywords at: i);
				nextPutAll: ' ``@arg';
				nextPutAll: i printString;
				nextPut: $ ].
	^stream contents
%

category: 'private'
classmethod: RBParseTreeSearcher
buildSelectorTree: aSelector 
	aSelector isEmpty ifTrue: [^nil].
	^RBParser parseRewriteExpression: '``@receiver ' 
				, (self buildSelectorString: aSelector)
		onError: [:err :pos | ^nil]
%

category: 'private'
classmethod: RBParseTreeSearcher
buildTree: aString method: aBoolean 
	^aBoolean 
		ifTrue: [RBParser parseRewriteMethod: aString]
		ifFalse: [RBParser parseRewriteExpression: aString]
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
getterMethod: aVarName 
	^(self new)
		matchesMethod: '`method ^' , aVarName do: [:aNode :ans | aNode selector];
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
justSendsSuper
	^ self new
		matchesAnyMethodOf: #(
			'`@method: `@args ^ super `@method: `@args' 
			'`@method: `@args super `@method: `@args')
		do: [ :node :answer | true ];
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
returnSetterMethod: aVarName 
	^(self new)
		matchesMethod: '`method: `Arg ^' , aVarName , ' := `Arg'
			do: [:aNode :ans | aNode selector];
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
setterMethod: aVarName 
	^(self new)
		matchesAnyMethodOf: (Array with: '`method: `Arg ' , aVarName , ' := `Arg'
					with: '`method: `Arg ^' , aVarName , ' := `Arg')
			do: [:aNode :ans | aNode selector];
		yourself
%

category: 'accessing'
classmethod: RBParseTreeSearcher
treeMatching: aString in: aParseTree 
	(self new)
		matches: aString do: [:aNode :answer | ^aNode];
		executeTree: aParseTree.
	^nil
%

category: 'accessing'
classmethod: RBParseTreeSearcher
treeMatchingStatements: aString in: aParseTree 
	| notifier tree |
	notifier := self new.
	tree := RBParser parseExpression: aString.
	tree isSequence 
		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].
	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).
	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').
	tree lastIsReturn 
		ifFalse: [tree addNode: (RBPatternVariableNode named: '`@.S2')].
	notifier matchesTree: tree
		do: [:aNode :answer | ^RBParser parseExpression: aString].
	notifier executeTree: aParseTree.
	^nil
%

!		Instance methods for 'RBParseTreeSearcher'

category: 'accessing'
method: RBParseTreeSearcher
addArgumentRule: aParseTreeRule 
	argumentSearches add: aParseTreeRule.
	aParseTreeRule owner: self
%

category: 'accessing'
method: RBParseTreeSearcher
addArgumentRules: ruleCollection 
	ruleCollection do: [:each | self addArgumentRule: each]
%

category: 'accessing'
method: RBParseTreeSearcher
addRule: aParseTreeRule 
	searches add: aParseTreeRule.
	aParseTreeRule owner: self
%

category: 'accessing'
method: RBParseTreeSearcher
addRules: ruleCollection 
	ruleCollection do: [:each | self addRule: each]
%

category: 'accessing'
method: RBParseTreeSearcher
answer
	^answer
%

category: 'initialize-release'
method: RBParseTreeSearcher
answer: anObject
	answer := anObject
%

category: 'testing'
method: RBParseTreeSearcher
canMatchMethod: aCompiledMethod
	| actualMessages |
	self messages isEmpty
		ifTrue: [ ^ true ].
	actualMessages := aCompiledMethod messages.
	^ self messages 
		anySatisfy: [ :each | actualMessages includes: each ]
%

category: 'accessing'
method: RBParseTreeSearcher
context
	^context
%

category: 'accessing'
method: RBParseTreeSearcher
executeMethod: aParseTree initialAnswer: anObject 
	answer := anObject.
	searches detect: [:each | (each performOn: aParseTree) notNil] ifNone: [].
	^answer
%

category: 'accessing'
method: RBParseTreeSearcher
executeTree: aParseTree 
	"Save our current context, in case someone is performing another search inside a match."

	| oldContext |
	oldContext := context.
	context := RBSmallDictionary new.
	self visitNode: aParseTree.
	context := oldContext.
	^answer
%

category: 'accessing'
method: RBParseTreeSearcher
executeTree: aParseTree initialAnswer: aValue 
	answer := aValue.
	^self executeTree: aParseTree
%

category: 'private'
method: RBParseTreeSearcher
foundMatch
%

category: 'testing'
method: RBParseTreeSearcher
hasRules
	^searches notEmpty
%

category: 'initialize-release'
method: RBParseTreeSearcher
initialize
	super initialize.
	context := RBSmallDictionary new.
	searches := OrderedCollection new.
	argumentSearches := OrderedCollection new: 0.
	answer := nil
%

category: 'private'
method: RBParseTreeSearcher
lookForMoreMatchesInContext: oldContext 
	oldContext keysAndValuesDo: 
			[:key :value | 
			(key isString not and: [key recurseInto]) 
				ifTrue: [value do: [:each | self visitNode: each]]]
%

category: 'searching'
method: RBParseTreeSearcher
matches: aString do: aBlock 
	self addRule: (RBSearchRule searchFor: aString thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyArgumentOf: stringCollection do: aBlock 
	stringCollection do: [:each | self matchesArgument: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyMethodOf: aStringCollection do: aBlock 
	aStringCollection do: [:each | self matchesMethod: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyOf: aStringCollection do: aBlock 
	aStringCollection do: [:each | self matches: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyTreeOf: treeCollection do: aBlock 
	treeCollection do: [:each | self matchesTree: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesArgument: aString do: aBlock 
	self addArgumentRule: (RBSearchRule searchFor: aString thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesArgumentTree: aBRProgramNode do: aBlock 
	self 
		addArgumentRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesMethod: aString do: aBlock 
	self addRule: (RBSearchRule searchForMethod: aString thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesTree: aBRProgramNode do: aBlock 
	self addRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)
%

category: 'accessing'
method: RBParseTreeSearcher
messages
	messages notNil ifTrue: [^messages].
	argumentSearches notEmpty ifTrue: [^messages := #()].
	messages := Set new.
	searches do: 
			[:each | 
			| searchMessages |
			searchMessages := each sentMessages.
			RBProgramNode optimizedSelectors 
				do: [:sel | searchMessages remove: sel ifAbsent: []].
			searchMessages isEmpty ifTrue: [^messages := #()].
			messages addAll: searchMessages].
	^messages := messages asArray
%

category: 'private'
method: RBParseTreeSearcher
performSearches: aSearchCollection on: aNode 
	| value |
	1 to: aSearchCollection size
		do: 
			[:i | 
			value := (aSearchCollection at: i) performOn: aNode.
			value notNil 
				ifTrue: 
					[self foundMatch.
					^value]].
	^nil
%

category: 'private'
method: RBParseTreeSearcher
recusivelySearchInContext
	"We need to save the matched context since the other searches might overwrite it."

	| oldContext |
	oldContext := context.
	context := RBSmallDictionary new.
	self lookForMoreMatchesInContext: oldContext.
	context := oldContext
%

category: 'visiting'
method: RBParseTreeSearcher
visitArgument: aNode 
	| value |
	value := self performSearches: argumentSearches on: aNode.
	^value isNil 
		ifTrue: 
			[aNode acceptVisitor: self.
			aNode]
		ifFalse: [value]
%

category: 'visiting'
method: RBParseTreeSearcher
visitNode: aNode 
	| value |
	value := self performSearches: searches on: aNode.
	^value isNil 
		ifTrue: 
			[aNode acceptVisitor: self.
			aNode]
		ifFalse: [value]
%

! Class implementation for 'RBParseTreeRewriter'

!		Class methods for 'RBParseTreeRewriter'

category: 'instance creation'
classmethod: RBParseTreeRewriter
removeTemporaryNamed: aName 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule replace: '| `@temps1 ' , aName , ' `@temps2 | ``@.Statements'
		with: '| `@temps1  `@temps2 | ``@.Statements'.
	^rewriteRule
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
rename: varName to: newVarName 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule
		replace: varName with: newVarName;
		replaceArgument: varName with: newVarName.
	^rewriteRule
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
rename: varName to: newVarName handler: aBlock 
	"Rename varName to newVarName, evaluating aBlock if there is a 
	temporary variable with the same name as newVarName. This 
	does not change temporary variables with varName."

	| rewriteRule |
	rewriteRule := self new.
	rewriteRule
		replace: varName with: newVarName;
		replaceArgument: newVarName
			withValueFrom: 
				[:aNode | 
				aBlock value.
				aNode].
	^rewriteRule
%

category: 'accessing'
classmethod: RBParseTreeRewriter
replace: code with: newCode in: aParseTree 
	^(self 
		replace: code
		with: newCode
		method: false)
		executeTree: aParseTree;
		tree
%

category: 'accessing'
classmethod: RBParseTreeRewriter
replace: code with: newCode in: aParseTree onInterval: anInterval 
	| rewriteRule |
	rewriteRule := self new.
	^rewriteRule
		replace: code
			with: newCode
			when: [:aNode | aNode intersectsInterval: anInterval];
		executeTree: aParseTree;
		tree
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
replace: code with: newCode method: aBoolean 
	| rewriteRule |
	rewriteRule := self new.
	aBoolean 
		ifTrue: [rewriteRule replaceMethod: code with: newCode]
		ifFalse: [rewriteRule replace: code with: newCode].
	^rewriteRule
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
replaceLiteral: literal with: newLiteral 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule replaceTree: (RBLiteralNode value: literal)
		withTree: (RBLiteralNode value: newLiteral).
	^rewriteRule
%

category: 'accessing'
classmethod: RBParseTreeRewriter
replaceStatements: code with: newCode in: aParseTree onInterval: anInterval 
	| tree replaceStmt |
	tree := self buildTree: code method: false.
	tree isSequence 
		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].
	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).
	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').
	tree lastIsReturn 
		ifTrue: [replaceStmt := '| `@temps | `@.S1. ^' , newCode]
		ifFalse: 
			[tree addNode: (RBPatternVariableNode named: '`@.S2').
			replaceStmt := '| `@temps | `@.S1. ' , newCode , '. `@.S2'].
	^self 
		replace: tree formattedCode
		with: replaceStmt
		in: aParseTree
		onInterval: anInterval
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
variable: aVarName getter: getMethod setter: setMethod 
	^self 
		variable: aVarName
		getter: getMethod
		setter: setMethod
		receiver: 'self'
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
variable: aVarName getter: getMethod setter: setMethod receiver: aString 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule
		replace: aVarName , ' := ``@object'
			with: aString , ' ' , setMethod , ' ``@object';
		replace: aVarName with: aString , ' ' , getMethod.
	^rewriteRule
%

!		Instance methods for 'RBParseTreeRewriter'

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptArrayNode: anArrayNode
	anArrayNode statements: (anArrayNode statements 
				collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptAssignmentNode: anAssignmentNode 
	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).
	anAssignmentNode value: (self visitNode: anAssignmentNode value)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptBlockNode: aBlockNode 
	aBlockNode arguments: (self visitArguments: aBlockNode arguments).
	aBlockNode body: (self visitNode: aBlockNode body)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptCascadeNode: aCascadeNode 
	| newMessages notFound |
	newMessages := OrderedCollection new: aCascadeNode messages size.
	notFound := OrderedCollection new: aCascadeNode messages size.
	aCascadeNode messages do: 
			[:each | 
			| newNode |
			newNode := self performSearches: searches on: each.
			newNode isNil 
				ifTrue: 
					[newNode := each.
					notFound add: newNode].
			newNode isMessage 
				ifTrue: [newMessages add: newNode]
				ifFalse: 
					[newNode isCascade 
						ifTrue: [newMessages addAll: newNode messages]
						ifFalse: 
							[Transcript
								show: 'Cannot replace message node inside of cascaded node with non-message node.';
								cr.
							newMessages add: each]]].
	notFound size = aCascadeNode messages size 
		ifTrue: 
			[| receiver |
			receiver := self visitNode: aCascadeNode messages first receiver.
			newMessages do: [:each | each receiver: receiver]].
	notFound 
		do: [:each | each arguments: (each arguments collect: [:arg | self visitNode: arg])].
	aCascadeNode messages: newMessages
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptLiteralArrayNode: aRBArrayLiteralNode 
	aRBArrayLiteralNode contents: (aRBArrayLiteralNode contents 
				collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptMessageNode: aMessageNode 
	aMessageNode receiver: (self visitNode: aMessageNode receiver).
	aMessageNode 
		arguments: (aMessageNode arguments collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptMethodNode: aMethodNode 
	aMethodNode arguments: (self visitArguments: aMethodNode arguments).
	aMethodNode pragmas: (aMethodNode pragmas 
		collect: [:each | self visitNode: each]).
	aMethodNode body: (self visitNode: aMethodNode body)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptPragmaNode: aPragmaNode 
	aPragmaNode arguments: (aPragmaNode arguments collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptReturnNode: aReturnNode 
	aReturnNode value: (self visitNode: aReturnNode value)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptSequenceNode: aSequenceNode 
	aSequenceNode 
		temporaries: (self visitArguments: aSequenceNode temporaries).
	aSequenceNode statements: (aSequenceNode statements 
				collect: [:each | self visitNode: each])
%

category: 'accessing'
method: RBParseTreeRewriter
executeTree: aParseTree 
	| oldContext |
	oldContext := context.
	context := RBSmallDictionary new.
	answer := false.
	tree := self visitNode: aParseTree.
	context := oldContext.
	^answer
%

category: 'private'
method: RBParseTreeRewriter
foundMatch
	answer := true
%

category: 'private'
method: RBParseTreeRewriter
lookForMoreMatchesInContext: oldContext 
	oldContext keysAndValuesDo: 
			[:key :value | 
			(key isString not and: [key recurseInto]) 
				ifTrue: 
					[oldContext at: key put: (value collect: [:each | self visitNode: each])]]
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString with: replaceString 
	self addRule: (RBStringReplaceRule searchFor: searchString
				replaceWith: replaceString)
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString with: replaceString when: aBlock 
	self addRule: (RBStringReplaceRule 
				searchFor: searchString
				replaceWith: replaceString
				when: aBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString withValueFrom: replaceBlock 
	self addRule: (RBBlockReplaceRule searchFor: searchString
				replaceWith: replaceBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString withValueFrom: replaceBlock when: conditionBlock 
	self addRule: (RBBlockReplaceRule 
				searchFor: searchString
				replaceWith: replaceBlock
				when: conditionBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString with: replaceString 
	self addArgumentRule: (RBStringReplaceRule searchFor: searchString
				replaceWith: replaceString)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString with: replaceString when: aBlock 
	self addArgumentRule: (RBStringReplaceRule 
				searchFor: searchString
				replaceWith: replaceString
				when: aBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString withValueFrom: replaceBlock 
	self addArgumentRule: (RBBlockReplaceRule searchFor: searchString
				replaceWith: replaceBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString withValueFrom: replaceBlock when: conditionBlock 
	self addArgumentRule: (RBBlockReplaceRule 
				searchFor: searchString
				replaceWith: replaceBlock
				when: conditionBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString with: replaceString 
	self addRule: (RBStringReplaceRule searchForMethod: searchString
				replaceWith: replaceString)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString with: replaceString when: aBlock 
	self addRule: (RBStringReplaceRule 
				searchForMethod: searchString
				replaceWith: replaceString
				when: aBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString withValueFrom: replaceBlock 
	self addRule: (RBBlockReplaceRule searchForMethod: searchString
				replaceWith: replaceBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString withValueFrom: replaceBlock when: conditionBlock 
	self addRule: (RBBlockReplaceRule 
				searchForMethod: searchString
				replaceWith: replaceBlock
				when: conditionBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceTree: searchTree withTree: replaceTree 
	self addRule: (RBStringReplaceRule searchForTree: searchTree
				replaceWith: replaceTree)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceTree: searchTree withTree: replaceTree when: aBlock 
	self addRule: (RBStringReplaceRule 
				searchForTree: searchTree
				replaceWith: replaceTree
				when: aBlock)
%

category: 'accessing'
method: RBParseTreeRewriter
tree
	^tree
%

category: 'visiting'
method: RBParseTreeRewriter
visitArguments: aNodeCollection 
	^aNodeCollection collect: [:each | self visitArgument: each]
%

! Class implementation for 'RBReadBeforeWrittenTester'

!		Class methods for 'RBReadBeforeWrittenTester'

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
isVariable: aString readBeforeWrittenIn: aBRProgramNode 
	^(self isVariable: aString writtenBeforeReadIn: aBRProgramNode) not
%

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
isVariable: aString writtenBeforeReadIn: aBRProgramNode 
	^(self readBeforeWritten: (Array with: aString) in: aBRProgramNode) 
		isEmpty
%

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
readBeforeWritten: varNames in: aParseTree 
	^(self new)
		checkNewTemps: false;
		initializeVars: varNames;
		executeTree: aParseTree;
		read
%

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
variablesReadBeforeWrittenIn: aParseTree 
	^(self new)
		executeTree: aParseTree;
		read
%

!		Instance methods for 'RBReadBeforeWrittenTester'

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptAssignmentNode: anAssignmentNode 
	self visitNode: anAssignmentNode value.
	self variableWritten: anAssignmentNode
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptBlockNode: aBlockNode 
	self processBlock: aBlockNode
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptMessageNode: aMessageNode 
	((#(#whileTrue: #whileFalse: #whileTrue #whileFalse) 
		includes: aMessageNode selector) and: [aMessageNode receiver isBlock]) 
		ifTrue: [self executeTree: aMessageNode receiver body]
		ifFalse: 
			[(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 
				ifTrue: [self visitNode: aMessageNode receiver]].
	((#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aMessageNode selector) 
		and: [aMessageNode arguments allSatisfy: [:each | each isBlock]]) 
			ifTrue: [^self processIfTrueIfFalse: aMessageNode].
	aMessageNode arguments do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptSequenceNode: aSequenceNode 
	self processStatementNode: aSequenceNode
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptVariableNode: aVariableNode 
	self variableRead: aVariableNode
%

category: 'initialize-release'
method: RBReadBeforeWrittenTester
checkNewTemps: aBoolean 
	checkNewTemps := aBoolean
%

category: 'private'
method: RBReadBeforeWrittenTester
copyDictionary: aDictionary 
	"We could send aDictionary the copy message, but that doesn't copy the associations."

	| newDictionary |
	newDictionary := Dictionary new: aDictionary size.
	aDictionary keysAndValuesDo: [ :key :value | newDictionary at: key put: value ].
	^ newDictionary
%

category: 'private'
method: RBReadBeforeWrittenTester
createScope
	scopeStack add: (self copyDictionary: scopeStack last)
%

category: 'private'
method: RBReadBeforeWrittenTester
currentScope
	^scopeStack last
%

category: 'accessing'
method: RBReadBeforeWrittenTester
executeTree: aParseTree 
	^self visitNode: aParseTree
%

category: 'initialize-release'
method: RBReadBeforeWrittenTester
initialize
	super initialize.
	scopeStack := OrderedCollection with: Dictionary new.
	read := Set new.
	checkNewTemps := true
%

category: 'initialize-release'
method: RBReadBeforeWrittenTester
initializeVars: varNames 
	varNames do: [:each | self currentScope at: each put: nil]
%

category: 'private'
method: RBReadBeforeWrittenTester
processBlock: aNode 
	| newScope |
	self createScope.
	self executeTree: aNode body.
	newScope := self removeScope.
	newScope keysAndValuesDo: 
			[:key :value | 
			(value == true and: [(self currentScope at: key) isNil]) 
				ifTrue: [self currentScope at: key put: value]]
%

category: 'private'
method: RBReadBeforeWrittenTester
processIfTrueIfFalse: aNode 
	| trueScope falseScope |
	self createScope.
	self executeTree: aNode arguments first body.
	trueScope := self removeScope.
	self createScope.
	self executeTree: aNode arguments last body.
	falseScope := self removeScope.
	self currentScope keysAndValuesDo: 
			[:key :value | 
			value isNil 
				ifTrue: 
					[(trueScope at: key) == (falseScope at: key) 
						ifTrue: [self currentScope at: key put: (trueScope at: key)]
						ifFalse: 
							[((trueScope at: key) == true or: [(falseScope at: key) == true]) 
								ifTrue: [self currentScope at: key put: true]]]]
%

category: 'private'
method: RBReadBeforeWrittenTester
processStatementNode: aNode 
	| temps |
	(checkNewTemps not or: [aNode temporaries isEmpty]) 
		ifTrue: 
			[aNode statements do: [:each | self executeTree: each].
			^self].
	self createScope.
	temps := aNode temporaries collect: [:each | each name].
	self initializeVars: temps.
	aNode statements do: [:each | self executeTree: each].
	self removeScope keysAndValuesDo: 
			[:key :value | 
			(temps includes: key) 
				ifTrue: [value == true ifTrue: [read add: key]]
				ifFalse: 
					[(self currentScope at: key) isNil 
						ifTrue: [self currentScope at: key put: value]]]
%

category: 'accessing'
method: RBReadBeforeWrittenTester
read
	self currentScope
		keysAndValuesDo: [:key :value | value == true ifTrue: [read add: key]].
	^read
%

category: 'private'
method: RBReadBeforeWrittenTester
removeScope
	^scopeStack removeLast
%

category: 'private'
method: RBReadBeforeWrittenTester
variableRead: aNode 
	(self currentScope includesKey: aNode name) 
		ifTrue: 
			[(self currentScope at: aNode name) isNil 
				ifTrue: [self currentScope at: aNode name put: true]]
%

category: 'private'
method: RBReadBeforeWrittenTester
variableWritten: aNode 
	(self currentScope includesKey: aNode variable name) 
		ifTrue: 
			[(self currentScope at: aNode variable name) isNil 
				ifTrue: [self currentScope at: aNode variable name put: false]]
%

! Class implementation for 'RBScanner'

!		Class methods for 'RBScanner'

category: 'accessing'
classmethod: RBScanner
classificationTable
	classificationTable isNil 
		ifTrue: [ self initializeClassificationTable ].
	^ classificationTable
%

category: 'class initialization'
classmethod: RBScanner
initialize
	self initializeClassificationTable
%

category: 'class initialization'
classmethod: RBScanner
initializeChars: characters to: aSymbol 
	characters do: [:c | classificationTable at: c asInteger put: aSymbol]
%

category: 'class initialization'
classmethod: RBScanner
initializeClassificationTable
  PatternVariableCharacter := $`.
  classificationTable := Array new: 255.
  self
    initializeChars: (((0 to: 255) collect: [ :v | Character codePoint: v ]) select: [ :each | each isLetter ])
    to: #'alphabetic'.
  self initializeUnderscore.
  self initializeChars: '01234567890' to: #'digit'.
  self initializeChars: '!%&*+,-/<=>?@\~|' to: #'binary'.
  classificationTable at: 177 put: #'binary'.	"plus-or-minus"
  classificationTable at: 183 put: #'binary'.	"centered dot"
  classificationTable at: 215 put: #'binary'.	"times"
  classificationTable at: 247 put: #'binary'.	"divide"
  self initializeChars: '().:;[]{}^' to: #'special'.
  self
    initializeChars:
      (((1 to: 255) collect: [ :v | Character codePoint: v ]) select: [ :each | each isSeparator ])
    to: #'separator'
%

category: 'class initialization'
classmethod: RBScanner
initializeUnderscore
  self classificationTable
    at: $_ asInteger
    put: #'alphabetic' 
"
      ((Scanner isLiteralSymbol: '_')
        ifTrue: [ #'alphabetic' ]
        ifFalse: [ #'special' ])
"
%

category: 'testing'
classmethod: RBScanner
isSelector: aSymbol 
	| scanner token |
	scanner := self basicNew.
	scanner on: aSymbol asString readStreamPortable.
	scanner step.
	token := scanner scanAnySymbol.
	token isLiteralToken ifFalse: [^false].
	token value isEmpty ifTrue: [^false].
	^scanner atEnd
%

category: 'testing'
classmethod: RBScanner
isVariable: aString 
	| scanner token |
	scanner := self on: aString readStreamPortable errorBlock: [:s :p | ^false].
	token := scanner next.
	token isIdentifier ifFalse: [^false].
	(token start = 1 and: [token stop = aString size]) ifFalse: [^false].
	^(aString includes: $.) not
%

category: 'instance creation'
classmethod: RBScanner
new
  ^ super new
%

category: 'instance creation'
classmethod: RBScanner
on: aStream 
	| str |
	str := self new on: aStream.
	str
		step;
		stripSeparators.
	^str
%

category: 'instance creation'
classmethod: RBScanner
on: aStream errorBlock: aBlock 
	| str |
	str := self new on: aStream.
	str
		errorBlock: aBlock;
		step;
		stripSeparators.
	^str
%

category: 'accessing'
classmethod: RBScanner
patternVariableCharacter
	^ PatternVariableCharacter
%

!		Instance methods for 'RBScanner'

category: 'testing'
method: RBScanner
atEnd
	^characterType = #eof
%

category: 'private'
method: RBScanner
classify: aCharacter 
	| index |
	aCharacter isNil ifTrue: [^nil].
	index := aCharacter asInteger.
	index == 0 ifTrue: [^#separator].
	index > 255 
		ifTrue: 
			[^aCharacter isLetter 
				ifTrue: [#alphabetic]
				ifFalse: [aCharacter isSqueakSeparator ifTrue: [#separator] ifFalse: [nil]]].
	^classificationTable at: index
%

category: 'accessing'
method: RBScanner
contents
	| contentsStream |
	contentsStream := WriteStreamPortable on: String new.
	[ self atEnd ]
		whileFalse: [ contentsStream nextPut: self next ].
	^ contentsStream contents
%

category: 'error handling'
method: RBScanner
errorBlock
	^errorBlock isNil ifTrue: [[:message :position | ]] ifFalse: [errorBlock]
%

category: 'accessing'
method: RBScanner
errorBlock: aBlock 
	errorBlock := aBlock
%

category: 'error handling'
method: RBScanner
errorPosition
	^stream position
%

category: 'accessing'
method: RBScanner
flush
%

category: 'accessing'
method: RBScanner
getComments
	| oldComments |
	comments isEmpty ifTrue: [^nil].
	oldComments := comments.
	comments := OrderedCollection new: 1.
	^oldComments
%

category: 'testing'
method: RBScanner
isReadable
	^true
%

category: 'testing'
method: RBScanner
isWritable
	^false
%

category: 'accessing'
method: RBScanner
next
	| token |
	buffer reset.
	tokenStart := stream position.
	token := characterType = #eof 
				ifTrue: 
					[RBToken start: tokenStart + 1	"The EOF token should occur after the end of input"]
				ifFalse: [self scanToken].
	self stripSeparators.
	token comments: self getComments.
	^token
%

category: 'accessing'
method: RBScanner
nextPut: anObject 
	"Provide an error notification that the receiver does not
	implement this message."

	self shouldNotImplement
%

category: 'initialize-release'
method: RBScanner
on: aStream 
	buffer := WriteStreamPortable on: String new.
	stream := aStream.
	classificationTable := self class classificationTable.
	comments := OrderedCollection new
%

category: 'private'
method: RBScanner
previousStepPosition
	^characterType = #eof 
		ifTrue: [stream position]
		ifFalse: [stream position - 1]
%

category: 'private-scanning'
method: RBScanner
scanAnySymbol
	characterType = #alphabetic ifTrue: [^self scanSymbol].
	characterType = #binary ifTrue: [^self scanBinary: RBLiteralToken].
	^RBToken new
%

category: 'private-scanning'
method: RBScanner
scanBinary: aClass 
	| val |
	buffer nextPut: currentCharacter.
	self step.
	[ characterType = #binary ] whileTrue: 
		[ buffer nextPut: currentCharacter.
		self step ].
	val := buffer contents.
	val := val asSymbol.
	^aClass value: val start: tokenStart
%

category: 'private-scanning'
method: RBScanner
scanIdentifierOrKeyword
  | name |
  self scanName.
  [ 
  currentCharacter = $.
    and: [ 'abcdefghijklmnopqrstuvwxyz*|#' includes: stream peek ] ]
    whileTrue: [ 
      buffer nextPut: currentCharacter.
      self step.
      self scanPathName.
      name := buffer contents.
      ^ RBPathToken value: name start: tokenStart ].
  (currentCharacter = $: and: [ stream peek ~= $= ])
    ifTrue: [ ^ self scanKeyword ].
  name := buffer contents.
  name = '_'
    ifTrue: [ ^ RBShortAssignmentToken start: tokenStart ].
  name = 'true'
    ifTrue: [ ^ RBLiteralToken value: true start: tokenStart stop: self previousStepPosition ].
  name = 'false'
    ifTrue: [ ^ RBLiteralToken value: false start: tokenStart stop: self previousStepPosition ].
  name = 'nil'
    ifTrue: [ ^ RBLiteralToken value: nil start: tokenStart stop: self previousStepPosition ].
  ^ RBIdentifierToken value: name start: tokenStart
%

category: 'private-scanning'
method: RBScanner
scanKeyword
	| outputPosition inputPosition name |
	[currentCharacter = $:] whileTrue: 
			[buffer nextPut: currentCharacter.
			outputPosition := buffer position.
			inputPosition := stream position.
			self step.	":"
			[characterType = #alphabetic] whileTrue: [self scanName]].
	buffer position: outputPosition.
	stream position: inputPosition.
	self step.
	name := buffer contents.
	^(name occurrencesOf: $:) == 1 
		ifTrue: [RBKeywordToken value: name start: tokenStart]
		ifFalse: 
			[RBMultiKeywordLiteralToken 
				value: name asSymbol
				start: tokenStart
				stop: tokenStart + name size - 1]
%

category: 'private-scanning'
method: RBScanner
scanLiteral
	self step.
	self stripSeparators.
	characterType = #alphabetic 
		ifTrue: [ ^ self scanSymbol ].
	characterType = #binary 
		ifTrue: [ ^ (self scanBinary: RBLiteralToken) stop: self previousStepPosition ].
	currentCharacter = $' 
		ifTrue: [ ^ self scanStringSymbol ].
	(currentCharacter = $( or: [ currentCharacter = $[ ]) 
		ifTrue: [ ^ self scanLiteralArrayToken].
	"Accept some strange literals like '#1', '# species' and '##species:'"
	characterType = #digit
		ifTrue: [ ^ self scanNumber ].
	currentCharacter = $#
		ifTrue: [ ^ self scanLiteral ].
	self scannerError: 'Expecting a literal type'
%

category: 'private-scanning'
method: RBScanner
scanLiteralArrayToken
	| token |
	token := RBLiteralArrayToken 
				value: (String with: $# with: currentCharacter)
				start: tokenStart.
	self step.
	^token
%

category: 'private-scanning'
method: RBScanner
scanLiteralCharacter
	| token |
	self step.	"$"
	token := RBLiteralToken 
				value: currentCharacter
				start: tokenStart
				stop: stream position.
	self step.	"char"
	^token
%

category: 'private-scanning'
method: RBScanner
scanLiteralString
	self step.
	
	[currentCharacter isNil 
		ifTrue: [self scannerError: 'Unmatched '' in string literal.'].
	currentCharacter = $' and: [self step ~= $']] 
			whileFalse: 
				[buffer nextPut: currentCharacter.
				self step].
	^RBLiteralToken 
		value: buffer contents
		start: tokenStart
		stop: self previousStepPosition
%

category: 'private-scanning'
method: RBScanner
scanName
	[characterType = #alphabetic or: [characterType = #digit]] whileTrue: 
			[buffer nextPut: currentCharacter.
			self step]
%

category: 'error handling'
method: RBScanner
scannerError: aString 
	"Evaluate the block. If it returns raise an error"

	self errorBlock value: aString value: self errorPosition.
	self error: aString
%

category: 'private-scanning'
method: RBScanner
scanNumber
	| start number stop string |
	start := stream position.
	stream position: start - 1.
	number := Number rwFromStream: stream.
	stop := stream position.
	stream position: start - 1.
	string := stream next: stop - start + 1.
	stream position: stop.
	self step.
	^RBNumberLiteralToken 
		value: number
		start: start
		stop: stop
		source: string
%

category: 'private-scanning'
method: RBScanner
scanPathName
  [ 
  (characterType = #'alphabetic' or: [ characterType = #'digit' ])
    or: [ 
      ((currentCharacter = $. or: [ currentCharacter = $| ])
        and: [ 'abcdefghijklmnopqrstuvwxyz' includes: stream peek ])
        or: [ 
          (currentCharacter = $. and: [ stream peek = $* ])
            or: [ currentCharacter = $* and: [ stream peek = $. ] ] ] ] ]
    whileTrue: [ 
      buffer nextPut: currentCharacter.
      self step ]
%

category: 'private-scanning'
method: RBScanner
scanPatternVariable
	buffer nextPut: currentCharacter.
	self step.
	currentCharacter = ${ 
		ifTrue: 
			[self step.
			^RBPatternBlockToken value: '`{' start: tokenStart].
	[characterType = #alphabetic] whileFalse: 
			[characterType = #eof 
				ifTrue: [self scannerError: 'Meta variable expected'].
			buffer nextPut: currentCharacter.
			self step].
	^self scanIdentifierOrKeyword
%

category: 'private-scanning'
method: RBScanner
scanSpecialCharacter
	| character |
	currentCharacter = $: 
		ifTrue: 
			[self step.
			^currentCharacter = $= 
				ifTrue: 
					[self step.
					RBAssignmentToken start: tokenStart]
				ifFalse: [RBSpecialCharacterToken value: $: start: tokenStart]].
	currentCharacter = $_ ifTrue:
		[ self step.  ^RBShortAssignmentToken start: tokenStart ].
	character := currentCharacter.
	self step.
	^RBSpecialCharacterToken value: character start: tokenStart
%

category: 'private-scanning'
method: RBScanner
scanStringSymbol
	| literalToken |
	literalToken := self scanLiteralString.
	literalToken value: literalToken value asSymbol.
	^literalToken
%

category: 'private-scanning'
method: RBScanner
scanSymbol
	[ characterType = #alphabetic or: [ currentCharacter = $: ] ] whileTrue: [
		self scanName.
		currentCharacter = $: ifTrue: [
			buffer nextPut: $:.
			self step ] ].
	^ RBLiteralToken 
		value: buffer contents asSymbol
		start: tokenStart
		stop: self previousStepPosition
%

category: 'accessing'
method: RBScanner
scanToken
	"fast-n-ugly. Don't write stuff like this. Has been found to cause cancer in laboratory rats. Basically a 
	case statement. Didn't use Dictionary because lookup is pretty slow."

	characterType = #alphabetic ifTrue: [^self scanIdentifierOrKeyword].
	(characterType = #digit 
		or: [currentCharacter = $- and: [(self classify: stream peek) = #digit]]) 
			ifTrue: [^self scanNumber].
	characterType = #binary ifTrue: [^self scanBinary: RBBinarySelectorToken].
	characterType = #special ifTrue: [^self scanSpecialCharacter].
	currentCharacter = $' ifTrue: [^self scanLiteralString].
	currentCharacter = $# ifTrue: [^self scanLiteral].
	currentCharacter = $$ ifTrue: [^self scanLiteralCharacter].
	^self scannerError: 'Unknown character'
%

category: 'private'
method: RBScanner
step
	stream atEnd 
		ifTrue: 
			[characterType := #eof.
			^currentCharacter := nil].
	currentCharacter := stream next.
	characterType := self classify: currentCharacter.
	^currentCharacter
%

category: 'private-scanning'
method: RBScanner
stripComment
	| start stop |
	start := stream position.
	[self step = $"] whileFalse: 
			[characterType = #eof
				ifTrue: [self scannerError: 'Unmatched " in comment.']].
	stop := stream position.
	self step.
	comments add: (start to: stop)
%

category: 'private-scanning'
method: RBScanner
stripSeparators
	
	[[characterType = #separator] whileTrue: [self step].
	currentCharacter = $"] 
			whileTrue: [self stripComment]
%

! Class implementation for 'RBPatternScanner'

!		Class methods for 'RBPatternScanner'

category: 'class initialization'
classmethod: RBPatternScanner
initialize
  "force initialization on load"

  "self initialize"

  super initialize
%

!		Instance methods for 'RBPatternScanner'

category: 'accessing'
method: RBPatternScanner
scanToken
	currentCharacter = PatternVariableCharacter 
		ifTrue: [^self scanPatternVariable].
	currentCharacter = $} ifTrue: [^self scanSpecialCharacter].
	^super scanToken
%

! Class implementation for 'RBSmallDictionary'

!		Class methods for 'RBSmallDictionary'

category: 'instance creation'
classmethod: RBSmallDictionary
new
	^ self new: 2
%

category: 'instance creation'
classmethod: RBSmallDictionary
new: anInteger 
	^ self basicNew initialize: anInteger
%

!		Instance methods for 'RBSmallDictionary'

category: 'accessing'
method: RBSmallDictionary
at: aKey
	"Answer the value associated with aKey. Raise an exception, if no such key is defined."

	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]
%

category: 'accessing'
method: RBSmallDictionary
at: aKey ifAbsent: aBlock
	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index ]
		ifTrue: [ aBlock value ]
%

category: 'accessing'
method: RBSmallDictionary
at: aKey ifAbsentPut: aBlock
	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index ]
		ifTrue: [ self privateAt: aKey put: aBlock value ]
%

category: 'accessing'
method: RBSmallDictionary
at: aKey put: aValue
	"Set the value of aKey to be aValue."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index put: aValue ]
		ifTrue: [ self privateAt: aKey put: aValue ]
%

category: 'accessing'
method: RBSmallDictionary
empty
	tally := 0
%

category: 'private'
method: RBSmallDictionary
errorKeyNotFound
	self error: 'Key not found'
%

category: 'private'
method: RBSmallDictionary
findIndexFor: aKey
	1 to: tally do: [ :index |
		(keys at: index) = aKey
			ifTrue: [ ^ index ] ].
	^ 0
%

category: 'private'
method: RBSmallDictionary
grow
	| newKeys newValues |
	newKeys := Array new: 2 * tally.
	newValues := Array new: 2 * tally.
	1 to: tally do: [ :index |
		newKeys at: index put: (keys at: index).
		newValues at: index put: (values at: index) ].
	keys := newKeys.
	values := newValues
%

category: 'testing'
method: RBSmallDictionary
includesKey: aKey
	"Answer whether the receiver has a key equal to aKey."

	^ (self findIndexFor: aKey) ~= 0
%

category: 'initialization'
method: RBSmallDictionary
initialize: anInteger
	tally := 0.
	keys := Array new: anInteger.
	values := Array new: anInteger
%

category: 'testing'
method: RBSmallDictionary
isEmpty
	^ tally = 0
%

category: 'accessing'
method: RBSmallDictionary
keys
	^ keys copyFrom: 1 to: tally
%

category: 'enumerating'
method: RBSmallDictionary
keysAndValuesDo: aBlock
	1 to: tally do: [ :index | aBlock value: (keys at: index) value: (values at: index) ]
%

category: 'enumerating'
method: RBSmallDictionary
keysDo: aBlock
	1 to: tally do: [ :each | aBlock value: (keys at: each) ]
%

category: 'copying'
method: RBSmallDictionary
postCopy
	super postCopy.
	keys := keys copy.
	values := values copy
%

category: 'private'
method: RBSmallDictionary
privateAt: aKey put: aValue
	tally = keys size ifTrue: [ self grow ].
	keys at: (tally := tally + 1) put: aKey.
	^ values at: tally put: aValue
%

category: 'removing'
method: RBSmallDictionary
removeKey: aKey
	"Remove aKey from the receiver, raise an exception if the element is missing."

	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]
%

category: 'removing'
method: RBSmallDictionary
removeKey: aKey ifAbsent: aBlock
	"Remove aKey from the receiver, evaluate aBlock if the element is missing."

	| index value |
	index := self findIndexFor: aKey.
	index = 0 ifTrue: [ ^ aBlock value ].
	value := values at: index.
	index to: tally - 1 do: [ :i |
		keys at: i put: (keys at: i + 1).
		values at: i put: (values at: i + 1) ].
	keys at: tally put: nil.
	values at: tally put: nil.
	tally := tally - 1.
	^ value
%

category: 'accessing'
method: RBSmallDictionary
size
	^ tally
%

category: 'accessing'
method: RBSmallDictionary
values
	^ values copyFrom: 1 to: tally
%

category: 'enumerating'
method: RBSmallDictionary
valuesDo: aBlock
	1 to: tally do: [ :index | aBlock value: (values at: index) ]
%

! Class implementation for 'RBStringReplacement'

!		Class methods for 'RBStringReplacement'

category: 'instance creation'
classmethod: RBStringReplacement
replaceFrom: startInteger to: stopInteger with: aString 
	^(self new)
		startPosition: startInteger;
		stopPosition: stopInteger;
		string: aString;
		yourself
%

!		Instance methods for 'RBStringReplacement'

category: 'accessing'
method: RBStringReplacement
startPosition
	^startPosition
%

category: 'initialize-release'
method: RBStringReplacement
startPosition: anInteger 
	startPosition := anInteger
%

category: 'accessing'
method: RBStringReplacement
stopPosition
	^stopPosition
%

category: 'initialize-release'
method: RBStringReplacement
stopPosition: anInteger 
	stopPosition := anInteger
%

category: 'accessing'
method: RBStringReplacement
string
	^string
%

category: 'initialize-release'
method: RBStringReplacement
string: aString 
	string := aString
%

! Class implementation for 'RBToken'

!		Class methods for 'RBToken'

category: 'instance creation'
classmethod: RBToken
start: anInterval 
	^self new start: anInterval
%

!		Instance methods for 'RBToken'

category: 'accessing'
method: RBToken
comments
	^comments
%

category: 'accessing'
method: RBToken
comments: anObject
	comments := anObject
%

category: 'testing'
method: RBToken
isAssignment
	^false
%

category: 'testing'
method: RBToken
isBinary
	^false
%

category: 'testing'
method: RBToken
isIdentifier
	^false
%

category: 'testing'
method: RBToken
isKeyword
	^false
%

category: 'testing'
method: RBToken
isLiteral
	^self isLiteralToken
%

category: 'testing'
method: RBToken
isLiteralArrayToken
	^false
%

category: 'testing'
method: RBToken
isLiteralToken
	^false
%

category: 'testing'
method: RBToken
isPath
  ^ false
%

category: 'testing'
method: RBToken
isPatternBlock
	^false
%

category: 'testing'
method: RBToken
isPatternVariable
	^false
%

category: 'testing'
method: RBToken
isSpecial
	^false
%

category: 'accessing'
method: RBToken
length
	^self subclassResponsibility
%

category: 'printing'
method: RBToken
printOn: aStream 
	aStream
		nextPut: $ ;
		nextPutAll: self class name
%

category: 'printing'
method: RBToken
rbStoreString

"Returns a string that, when evaluated, will recreate a copy of the
 receiver.  The default is to use storeOn: to create the description."

| stream str |
str := String new.
stream := WriteStreamPortable on: str.
self rbStoreOn: stream.
^str
%

category: 'accessing'
method: RBToken
removePositions
	sourcePointer := nil
%

category: 'accessing'
method: RBToken
start
	^ sourcePointer ifNil: [ 0 ]
%

category: 'initialize-release'
method: RBToken
start: anInteger 
	sourcePointer := anInteger
%

category: 'accessing'
method: RBToken
stop
	^ sourcePointer isNil 
		ifTrue: [ -1 ]
		ifFalse: [ self start + self length - 1 ]
%

! Class implementation for 'RBAssignmentToken'

!		Instance methods for 'RBAssignmentToken'

category: 'testing'
method: RBAssignmentToken
isAssignment
	^true
%

category: 'private'
method: RBAssignmentToken
length
	^2
%

! Class implementation for 'RBShortAssignmentToken'

!		Instance methods for 'RBShortAssignmentToken'

category: 'private'
method: RBShortAssignmentToken
length
	^ 1
%

! Class implementation for 'RBValueToken'

!		Class methods for 'RBValueToken'

category: 'instance creation'
classmethod: RBValueToken
value: aString start: anInteger 
	^self new value: aString start: anInteger
%

!		Instance methods for 'RBValueToken'

category: 'private'
method: RBValueToken
length
	^value size
%

category: 'printing'
method: RBValueToken
printOn: aStream
	super printOn: aStream.
	aStream nextPut: $(.
	value printOn: aStream.
	aStream nextPutAll: ')'
%

category: 'accessing'
method: RBValueToken
value
	^value
%

category: 'accessing'
method: RBValueToken
value: anObject
	value := anObject
%

category: 'initialize-release'
method: RBValueToken
value: aString start: anInteger 
	value := aString.
	sourcePointer := anInteger
%

! Class implementation for 'RBBinarySelectorToken'

!		Instance methods for 'RBBinarySelectorToken'

category: 'testing'
method: RBBinarySelectorToken
isBinary
	^true
%

! Class implementation for 'RBIdentifierToken'

!		Instance methods for 'RBIdentifierToken'

category: 'testing'
method: RBIdentifierToken
isIdentifier
	^true
%

category: 'testing'
method: RBIdentifierToken
isPatternVariable
	^value first = RBScanner patternVariableCharacter
%

! Class implementation for 'RBPathToken'

!		Instance methods for 'RBPathToken'

category: 'testing'
method: RBPathToken
isPath
  ^ true
%

! Class implementation for 'RBKeywordToken'

!		Instance methods for 'RBKeywordToken'

category: 'testing'
method: RBKeywordToken
isKeyword
	^true
%

category: 'testing'
method: RBKeywordToken
isPatternVariable
	^value first = RBScanner patternVariableCharacter
%

! Class implementation for 'RBLiteralArrayToken'

!		Instance methods for 'RBLiteralArrayToken'

category: 'testing'
method: RBLiteralArrayToken
isForByteArray
	^value last = $[
%

category: 'testing'
method: RBLiteralArrayToken
isLiteralArrayToken
	^true
%

! Class implementation for 'RBLiteralToken'

!		Class methods for 'RBLiteralToken'

category: 'instance creation'
classmethod: RBLiteralToken
value: anObject 
	| literal |
	literal := anObject class == Array 
				ifTrue: [anObject collect: [:each | self value: each]]
				ifFalse: [anObject].
	^self 
		value: literal
		start: nil
		stop: nil
%

category: 'instance creation'
classmethod: RBLiteralToken
value: aString start: anInteger stop: stopInteger 
	^(self new)
		value: aString
			start: anInteger
			stop: stopInteger;
		yourself
%

!		Instance methods for 'RBLiteralToken'

category: 'testing'
method: RBLiteralToken
isLiteralToken
	^true
%

category: 'testing'
method: RBLiteralToken
isMultiKeyword
	^false
%

category: 'private'
method: RBLiteralToken
length
	^stopPosition - self start + 1
%

category: 'printing'
method: RBLiteralToken
rbStoreOn: aStream
    value isSymbol
        ifTrue: [ 
            aStream nextPut: $#.
            value asString printOn: aStream.
            ^ self ].
    value class == Character
        ifTrue: [ 
            aStream
                nextPut: $$;
                nextPut: value.
            ^ self ].
    value rbStoreOn: aStream
%

category: 'accessing'
method: RBLiteralToken
realValue
	^value
%

category: 'accessing'
method: RBLiteralToken
stop: anObject 
	stopPosition := anObject
%

category: 'initialize-release'
method: RBLiteralToken
value: aString start: anInteger stop: stopInteger 
	value := aString.
	sourcePointer := anInteger.
	stopPosition := stopInteger
%

! Class implementation for 'RBMultiKeywordLiteralToken'

!		Instance methods for 'RBMultiKeywordLiteralToken'

category: 'testing'
method: RBMultiKeywordLiteralToken
isMultiKeyword
	^true
%

! Class implementation for 'RBNumberLiteralToken'

!		Class methods for 'RBNumberLiteralToken'

category: 'instance creation'
classmethod: RBNumberLiteralToken
value: aNumber start: anInteger stop: stopInteger source: sourceString 
	^(self 
		value: aNumber
		start: anInteger
		stop: stopInteger)
		source: sourceString;
		yourself
%

!		Instance methods for 'RBNumberLiteralToken'

category: 'printing'
method: RBNumberLiteralToken
rbStoreOn: aStream 
	aStream nextPutAll: source
%

category: 'accessing'
method: RBNumberLiteralToken
source
	^source
%

category: 'initialize-release'
method: RBNumberLiteralToken
source: aString 
	source := aString
%

! Class implementation for 'RBPatternBlockToken'

!		Instance methods for 'RBPatternBlockToken'

category: 'testing'
method: RBPatternBlockToken
isPatternBlock
	^true
%

! Class implementation for 'RBSpecialCharacterToken'

!		Instance methods for 'RBSpecialCharacterToken'

category: 'testing'
method: RBSpecialCharacterToken
isSpecial
	^true
%

category: 'private'
method: RBSpecialCharacterToken
length
	^1
%

! Class implementation for 'Rowan'

!		Class methods for 'Rowan'

category: 'public'
classmethod: Rowan
automaticClassInitializationBlackList

	"Answer list of project names for which automatic class initialiation should be disabled."

	^ self platform automaticClassInitializationBlackList
%

category: 'public client services'
classmethod: Rowan
classServiceClass

	^ self platform classServiceClass
%

category: 'public tools'
classmethod: Rowan
classTools

	^ self platform classTools
%

category: 'public'
classmethod: Rowan
clearAutomaticClassInitializationBlackList

	"Clear list of project names for which automatic class initialiation should be disabled."

	^ self platform clearAutomaticClassInitializationBlackList
%

category: 'public'
classmethod: Rowan
clearDefaultAutomaticClassInitializationBlackList

	"Clear default list of project names for which automatic class initialiation should be disabled.
		Individual users may override the black list."

	^ self platform clearAutomaticClassInitializationBlackList_default
%

category: 'public'
classmethod: Rowan
configuration

	^configuration
%

category: 'public'
classmethod: Rowan
defaultAutomaticClassInitializationBlackList

	"Answer default list of project names for which automatic class initialiation should be disabled.
		Individual users may override the black list."

	^ self platform automaticClassInitializationBlackList_default
%

category: 'private'
classmethod: Rowan
fileUtilities
	"Private to the Cypress system."

	^self platform fileUtilities
%

category: 'public tools'
classmethod: Rowan
gitTools

	^ self platform gitTools
%

category: 'public'
classmethod: Rowan
globalNamed: aName

	"Answer a global object with the given name.  If no object with the given name is found, returns nil."

	^ self platform globalNamed: aName
%

category: 'private'
classmethod: Rowan
image
	"Private to the Cypress system."

	^self platform image
%

category: 'public client services'
classmethod: Rowan
jadeServerClassNamed: className

	^ self platform jadeServerClassNamed: className
%

category: 'public client services'
classmethod: Rowan
methodServiceClass

	^ self platform methodServiceClass
%

category: 'public'
classmethod: Rowan
packageNames

	"Return list of package names"

	^ self image packageNames
%

category: 'public client services'
classmethod: Rowan
packageServiceClass

	^ self platform packageServiceClass
%

category: 'public tools'
classmethod: Rowan
packageTools

	^self platform packageTools
%

category: 'private'
classmethod: Rowan
platform

	^ RwPlatform current
%

category: 'public'
classmethod: Rowan
platformConfigurationAttributes

	"Return list of platform-specific configuration attributes"

	^ self platform platformConfigurationAttributes
%

category: 'public'
classmethod: Rowan
projectNamed: aName

	"Answer a project with the given name.  If no project with the given name is found, signals error."

	^ self 
		projectNamed: aName 
			ifPresent: [:loadedProject | loadedProject ]
			ifAbsent: [ self error: 'The project ', aName printString, ' was not found' ]
%

category: 'public'
classmethod: Rowan
projectNamed: aName ifAbsent: absentBlock

	"Lookup a project with the given name, if found return the project. if not found evaluate the <absentBlock>."

	^ self 
		projectNamed: aName 
			ifPresent: [:loadedProject | loadedProject ]
			ifAbsent: absentBlock
%

category: 'public'
classmethod: Rowan
projectNamed: aName ifPresent: presentBlock

	"Lookup a project with the given name, if found evaluate the <presentBlock>. if not found return nil."

	^ self 
		projectNamed: aName 
			ifPresent: presentBlock
			ifAbsent: []
%

category: 'public'
classmethod: Rowan
projectNamed: aName ifPresent: presentBlock ifAbsent: absentBlock

	"Lookup a project with the given name, if found evaluate the <presentBlock>, if not evaluate the <absentBlock.."

	^ self platform 
		projectNamed: aName 
			ifPresent: presentBlock 
			ifAbsent: absentBlock
%

category: 'public'
classmethod: Rowan
projectNames

	"Return list of project names"

	^ self image projectNames
%

category: 'public client services'
classmethod: Rowan
projectServiceClass

	^ self platform projectServiceClass
%

category: 'public tools'
classmethod: Rowan
projectTools

	^self platform projectTools
%

category: 'public client services'
classmethod: Rowan
serviceClass

	^ self platform serviceClass
%

category: 'public'
classmethod: Rowan
unpackagedName

	"Answer the name used for unpackaged projects and packages"

	^ '(NONE)'
%

! Class implementation for 'RowanCommandResult'

!		Class methods for 'RowanCommandResult'

category: 'accessing'
classmethod: RowanCommandResult
addResult: service
	service command: nil;
			commandArgs: nil. 
	self updateClientBoundServices: service.
%

category: 'accessing'
classmethod: RowanCommandResult
basicAddResult: service
	self results add: service
%

category: 'initailize'
classmethod: RowanCommandResult
initializeResults

	SessionTemps current at: #rowanCommandResults put: Array new.
%

category: 'instance creation'
classmethod: RowanCommandResult
new

	| inst |
	inst := super new initialize.
	self addResult: inst.
	^inst
%

category: 'accessing'
classmethod: RowanCommandResult
removeResult: aResult

	self results remove: aResult
%

category: 'accessing'
classmethod: RowanCommandResult
results

	"lazy initialize for a topaz session test" 
	^SessionTemps current at: #rowanCommandResults ifAbsentPut: [Array new]
%

category: 'private'
classmethod: RowanCommandResult
updateClientBoundServices: clientBoundService
	"We're about to add a service to the results collection. 
	That service will be sent to the client. Since services
	are not canonical, we need to do some housekeeping
	to ensure that we don't already have this service 
	somewhere in other client-bound services"
	(self results includes: clientBoundService) ifTrue:[
		self removeResult: clientBoundService].
	self basicAddResult: clientBoundService. 
	self results do:[:service |
		service updateInternalService: clientBoundService.
		clientBoundService updateInternalService: service].
%

!		Instance methods for 'RowanCommandResult'

category: 'accessing'
method: RowanCommandResult
command: anObject

	"results don't have commands"
%

category: 'accessing'
method: RowanCommandResult
commandArgs: anObject

	"results don't have commandArgs"
%

category: 'initialization'
method: RowanCommandResult
initialize
%

category: 'testing'
method: RowanCommandResult
isMethodService

	^false
%

category: 'private'
method: RowanCommandResult
rowanFixMe
%

category: 'accessing'
method: RowanCommandResult
updateInternalService: service
%

! Class implementation for 'RowanClassCategoryUpdate'

!		Instance methods for 'RowanClassCategoryUpdate'

category: 'accessing'
method: RowanClassCategoryUpdate
categories

	^categories
%

category: 'initialization'
method: RowanClassCategoryUpdate
initialize

	categories := Array new.
%

category: 'accessing'
method: RowanClassCategoryUpdate
selection

	^selection
%

category: 'accessing'
method: RowanClassCategoryUpdate
selection: anObject

	selection := anObject
%

category: 'jade'
method: RowanClassCategoryUpdate
writeCategoriesTo: writeStream

	categories do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanClassCategoryUpdate
writeSelectionTo: writeStream

	writeStream nextPutAll: selection.
	writeStream lf.
%

! Class implementation for 'RowanClassesUpdate'

!		Instance methods for 'RowanClassesUpdate'

category: 'accessing'
method: RowanClassesUpdate
classesFromNames
	| result |
	result := classNames collect:[:name | 
		| cls |
		cls := self objectInBaseNamed: (name subStrings first).
		name subStrings size = 2 "meta" ifTrue:[cls := cls class.].
		cls].
	^result
%

category: 'accessing'
method: RowanClassesUpdate
classNames

	^classNames
%

category: 'accessing'
method: RowanClassesUpdate
classNamesFrom: theClasses
	"store the class name for transport to the client"
	classNames := theClasses collect:[:class | class name]
%

category: 'private'
method: RowanClassesUpdate
historyOf: aClass

	| history |
	(history := aClass classHistory) isNil ifTrue: [
		history := Array with: aClass.
	].
	^history
%

category: 'initialization'
method: RowanClassesUpdate
initialize

	classNames := Array new.
	selectionNames := Array new.
%

category: 'private'
method: RowanClassesUpdate
objectInBaseNamed: aString

	^System myUserProfile symbolList objectNamed: aString asSymbol
%

category: 'accessing'
method: RowanClassesUpdate
selectionNames

	^selectionNames
%

category: 'accessing'
method: RowanClassesUpdate
selectionNamesAsSymbols

	^self selectionNames collect:[:string | string asSymbol]
%

category: 'accessing'
method: RowanClassesUpdate
selections

	^selectionNames
%

category: 'accessing'
method: RowanClassesUpdate
selections: aCollection

	selectionNames := aCollection.
%

category: 'jade'
method: RowanClassesUpdate
writeClass: aClass to: writeStream

	writeStream nextPutAll: aClass name.
		1 < (self historyOf: aClass) size ifTrue: [
			writeStream nextPutAll: ' ('.
			((self historyOf: aClass) indexOf: aClass) printOn: writeStream.
			writeStream nextPut: $/.
			(self historyOf: aClass) size printOn: writeStream.
			writeStream nextPut: $)].
	writeStream tab.
%

category: 'jade'
method: RowanClassesUpdate
writeClassesTo: writeStream

	self classesFromNames do:[:aClass | 
		self writeClass: aClass to: writeStream
	].
	writeStream lf.
%

category: 'jade'
method: RowanClassesUpdate
writeSelectionsTo: writeStream

	self selectionNames do:[:name | 
		self writeClass: (self objectInBaseNamed: (name subStrings first)) to: writeStream].
	writeStream lf.
%

category: 'jade'
method: RowanClassesUpdate
writeTestCaseInfoTo: writeStream

	| testCaseClass | 
	testCaseClass:= self objectInBaseNamed: #'TestCase'.
	testCaseClass isNil ifTrue: [
		false printOn: writeStream.
	] ifFalse: [
		(self selectionNames allSatisfy: [:each | (self objectInBaseNamed: each)  inheritsFrom: testCaseClass]) printOn: writeStream.
	].
	writeStream lf.
%

! Class implementation for 'RowanClassHierarchyUpdate'

!		Instance methods for 'RowanClassHierarchyUpdate'

category: 'accessing'
method: RowanClassHierarchyUpdate
addHierarchyFor: aClass
	classNames add: ((self hierarchyFor: aClass) collect:[:class | class name]).
%

category: 'accessing'
method: RowanClassHierarchyUpdate
addSelectionHierarchyFor: aClass
	self selections addAll: ((self hierarchyFor: aClass) collect:[:class | class asString])
%

category: 'accessing'
method: RowanClassHierarchyUpdate
allClasses

	| allClasses |
 
	allClasses := Set new. 
	classNames do:[:hierarchy | 
		allClasses addAll: (hierarchy collect: [:name | self objectInBaseNamed: name])]. 
	^allClasses asArray
%

category: 'accessing'
method: RowanClassHierarchyUpdate
hierarchyFor: aClass
	| currentClass hierarchy |
	currentClass := aClass.
	hierarchy := Array new. 
	[currentClass notNil] whileTrue: 
			[hierarchy add: currentClass.
			currentClass := currentClass superclass].
	^hierarchy
%

category: 'jade'
method: RowanClassHierarchyUpdate
writeHierarchyTo: writeStream
	
	classNames do:[:hierarchy |
		hierarchy do:[:name | 
			self writeClass: (self objectInBaseNamed: name) to: writeStream].
		writeStream lf].
	writeStream nextPut: $%; lf.
%

category: 'jade'
method: RowanClassHierarchyUpdate
writeSelectionHierarchyTo: writeStream
	
	super writeSelectionsTo: writeStream
%

category: 'jade'
method: RowanClassHierarchyUpdate
writeTestCaseInfoTo: writeStream
	"ignore test case info - method going away"
	writeStream nextPutAll: 'false';
		tab;
		lf
%

! Class implementation for 'RowanMethodsUpdate'

!		Instance methods for 'RowanMethodsUpdate'

category: 'testing'
method: RowanMethodsUpdate
filterSelections

	"intention revealing"

	^selectionNames
%

category: 'testing'
method: RowanMethodsUpdate
filterSelections: aCollection

	"intention revealing"

	selectionNames := aCollection
%

category: 'accessing'
method: RowanMethodsUpdate
inheritedClass: aString

	inheritedClass := aString
%

category: 'accessing'
method: RowanMethodsUpdate
inheritedClasses: aCollection

	inheritedClasses := aCollection
%

category: 'initialization'
method: RowanMethodsUpdate
initialize
	super initialize.
	methodFilters := IdentitySet new.
	methods := Array new.
%

category: 'accessing'
method: RowanMethodsUpdate
methodFilters

	^methodFilters
%

category: 'accessing'
method: RowanMethodsUpdate
methods

	^methods
%

category: 'accessing'
method: RowanMethodsUpdate
selectedClass

	^self objectInBaseNamed: (selectedClass subStrings first)
%

category: 'accessing'
method: RowanMethodsUpdate
selectedClass:  aString

	selectedClass := aString
%

category: 'testing'
method: RowanMethodsUpdate
selectedClassOverridesSelector: aSymbol

	^self selectedClass superclass notNil and: [self selectedClass superclass canUnderstand: aSymbol].
%

category: 'accessing'
method: RowanMethodsUpdate
selectedSelectors

	^selectedSelectors
%

category: 'accessing'
method: RowanMethodsUpdate
selectedSelectors: aCollection

	selectedSelectors := aCollection
%

category: 'accessing'
method: RowanMethodsUpdate
selectors

	^selectors
%

category: 'accessing'
method: RowanMethodsUpdate
selectors: aCollection

	selectors := aCollection
%

category: 'accessing'
method: RowanMethodsUpdate
type: anObject

	type := anObject
%

category: 'updating'
method: RowanMethodsUpdate
updateMethodCategories

	self classesFromNames do: [:each | 
		each 
			env: 0 
			categorysDo:[ :category :sels | methodFilters add: category ].
	].
	methodFilters isEmpty ifTrue: [methodFilters := #(#'other')].
%

category: 'updating'
method: RowanMethodsUpdate
updateMethodFilterSelections: oldSelections hasCategoryOverride: override
	self filterSelections: (oldSelections collect:[:sel | sel asSymbol]).
%

category: 'updating'
method: RowanMethodsUpdate
updateMethodPragmas

	| currentClass |
	currentClass := ((self objectInBaseNamed: #'Pragma') notNil and: [self selectionNames notEmpty]) ifTrue: [self objectInBaseNamed: self selectionNames first] ifFalse: [nil].
	methodFilters := IdentitySet new.
	currentClass notNil ifTrue: [
		(currentClass methodDictForEnv: 0) do: [:each | methodFilters addAll: each pragmas].
	].
	methodFilters := methodFilters collect: [:each | each keyword].
	methodFilters := (methodFilters asSortedCollection: [:a :b | a > b]) asArray.  "SortedCollections cannot be grown in Dolphin Smalltalk"
%

category: 'updating'
method: RowanMethodsUpdate
updateMethodsInfo

	selectors do:[:selector |
		| isTestClass update |

		isTestClass := false.
		self selectedClass _allSuperList do: [:each | 
			isTestClass := isTestClass or: [each name = #'TestCase'].
		].
		update := methods detect:[:methodUpdate | methodUpdate selector = selector] ifNone:[RowanMethodUpdate new].
		update selector: selector;
			isTestClass: isTestClass;
			isOverride: (self selectedClassOverridesSelector: selector).
		methods add: update. 
		].
%

category: 'updating'
method: RowanMethodsUpdate
updateMethodVariables

	| currentClass | 
	currentClass := classNames notEmpty ifTrue: [self classesFromNames last] ifFalse: [nil].
	methodFilters := OrderedCollection new.
	[
		currentClass notNil.
	] whileTrue: [
		methodFilters
			addAll: currentClass instVarNames reverse;
			add: ' ' , currentClass name;
			yourself.
		currentClass := currentClass superclass.
	].
%

category: 'jade'
method: RowanMethodsUpdate
writeInheritedClassesTo: writeStream

	inheritedClasses do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeInheritedClassTo: writeStream

	writeStream nextPutAll: inheritedClass; lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeMethodCategoriesTo: writeStream
	"Reverse order to be consistent with variables, where we add superclasses to the end"

	methodFilters := methodFilters asSortedCollection asArray reverse.
	self writeMethodFiltersTo: writeStream
%

category: 'jade'
method: RowanMethodsUpdate
writeMethodFiltersTo: writeStream

	methodFilters do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeMethodsTo: writeStream

	methods do: [:methodUpdate | 	
		writeStream 
"1"		nextPutAll: methodUpdate selector; tab;
"2"		nextPut: (methodUpdate isOverride ifTrue: [$T] ifFalse: [$F]); tab;
"3"		nextPut: (methodUpdate isTestClass ifTrue: [$T] ifFalse: [$F]); tab;
"4"		nextPut: $F; tab;
"5"		nextPutAll: methodUpdate selector; tab;	
		lf.
	].
	writeStream nextPut: $%; lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeSelectedSelectorsTo: writeStream

	selectedSelectors do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeSelectionsTo: writeStream

	self selectionNames do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeTypeTo: writeStream

	writeStream 
		nextPutAll: type; tab;
		nextPutAll: '0';  "environment default"
		lf.
%

! Class implementation for 'RowanSuperclassUpdate'

!		Instance methods for 'RowanSuperclassUpdate'

category: 'accessing'
method: RowanSuperclassUpdate
tabName

	^tabName
%

category: 'accessing'
method: RowanSuperclassUpdate
tabName: aString

	tabName := aString
%

category: 'jade'
method: RowanSuperclassUpdate
writeTabNameTo: writeStream

	writeStream nextPutAll: tabName; lf.
%

! Class implementation for 'RowanClassInfoUpdate'

!		Instance methods for 'RowanClassInfoUpdate'

category: 'accessing'
method: RowanClassInfoUpdate
category: aString

	category := aString
%

category: 'accessing'
method: RowanClassInfoUpdate
comment: aString

	comment := aString
%

category: 'accessing'
method: RowanClassInfoUpdate
oop: aNumber

	oop := aNumber
%

category: 'accessing'
method: RowanClassInfoUpdate
template 

	^template
%

category: 'accessing'
method: RowanClassInfoUpdate
template: anObject

	template := anObject
%

category: 'jade'
method: RowanClassInfoUpdate
writeInfoOn: writeStream

	writeStream
		nextPutAll: oop printString; 
		lf;
		nextPut: $(;
		lf;
		nextPutAll: template;
		nextPut: $);
		lf;
		nextPutAll: String new.
	category ifNotNil: [
		writeStream
			nextPutAll: category;
			lf].
	writeStream
		nextPut: $%;
		lf.
	comment ifNotNil: [
		writeStream
			nextPutAll: comment;
			lf].
	writeStream
		nextPut: $%;
		lf.
%

! Class implementation for 'RowanDictionaryUpdate'

!		Instance methods for 'RowanDictionaryUpdate'

category: 'accessing'
method: RowanDictionaryUpdate
dictionaries

	^dictionaries
%

category: 'initialization'
method: RowanDictionaryUpdate
initialize

	dictionaries := Array new. 
	selections := Array new.
%

category: 'accessing'
method: RowanDictionaryUpdate
selections

	^selections
%

category: 'jade'
method: RowanDictionaryUpdate
writeDictionariesTo: writeStream

	dictionaries do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanDictionaryUpdate
writeSelectionsTo: writeStream

	selections do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

! Class implementation for 'RowanGlobalsUpdate'

!		Instance methods for 'RowanGlobalsUpdate'

category: 'accessing'
method: RowanGlobalsUpdate
globals

	^globals
%

category: 'initialization'
method: RowanGlobalsUpdate
initialize

	globals := Array new.
%

category: 'jade'
method: RowanGlobalsUpdate
writeGlobalsTo: writeStream
	"globals is an array of 5 elements"
	
	globals do: [:array | 
		1 to: 4 do:[:idx |
			writeStream nextPutAll: (array at: idx); tab].
		writeStream nextPutAll: (array at: 5); lf].
	writeStream nextPut: $%; lf.
%

! Class implementation for 'RowanGsObject'

!		Instance methods for 'RowanGsObject'

category: 'other'
method: RowanGsObject
name

	^name
%

category: 'other'
method: RowanGsObject
name: anObject

	name := anObject
%

category: 'other'
method: RowanGsObject
oopType

	^oopType
%

category: 'other'
method: RowanGsObject
oopType: anObject

	oopType := anObject
%

! Class implementation for 'RowanGsMethod'

!		Instance methods for 'RowanGsMethod'

category: 'accessing'
method: RowanGsMethod
behavior

	^behavior
%

category: 'accessing'
method: RowanGsMethod
behavior: anObject

	behavior := anObject
%

category: 'accessing'
method: RowanGsMethod
behaviorName

	^behaviorName
%

category: 'accessing'
method: RowanGsMethod
behaviorName: anObject

	behaviorName := anObject
%

category: 'accessing'
method: RowanGsMethod
breakPoints

	^breakPoints
%

category: 'accessing'
method: RowanGsMethod
breakPoints: anObject

	breakPoints := anObject asArray
%

category: 'accessing'
method: RowanGsMethod
category

	^category
%

category: 'accessing'
method: RowanGsMethod
category: anObject

	category := anObject
%

category: 'initialization'
method: RowanGsMethod
initialize

	stepPoints := Dictionary new
%

category: 'accessing'
method: RowanGsMethod
isReadOnly

	^isReadOnly
%

category: 'accessing'
method: RowanGsMethod
isReadOnly: anObject

	isReadOnly := anObject
%

category: 'accessing'
method: RowanGsMethod
originalSource

	^originalSource
%

category: 'accessing'
method: RowanGsMethod
originalSource: anObject

	originalSource := anObject
%

category: 'accessing'
method: RowanGsMethod
source

	^source
%

category: 'accessing'
method: RowanGsMethod
source: anObject

	source := anObject
%

category: 'accessing'
method: RowanGsMethod
stepPoints

	^stepPoints
%

category: 'accessing'
method: RowanGsMethod
stepPoints: anObject

	stepPoints := anObject
%

category: 'accessing'
method: RowanGsMethod
unimplementedSelectors

	^unimplementedSelectors
%

category: 'accessing'
method: RowanGsMethod
unimplementedSelectors: anObject

	unimplementedSelectors := anObject
%

category: 'accessing'
method: RowanGsMethod
warnings

	^warnings
%

category: 'accessing'
method: RowanGsMethod
warnings: anObject

	warnings := anObject
%

! Class implementation for 'RowanMethodUpdate'

!		Instance methods for 'RowanMethodUpdate'

category: 'accessing'
method: RowanMethodUpdate
breakPoints

	^gsMethod breakPoints
%

category: 'accessing'
method: RowanMethodUpdate
breakPoints: anObject

	gsMethod breakPoints: anObject asArray
%

category: 'accessing'
method: RowanMethodUpdate
category

	^gsMethod category
%

category: 'accessing'
method: RowanMethodUpdate
category: anObject

	gsMethod category: anObject
%

category: 'accessing'
method: RowanMethodUpdate
className

	^gsMethod behaviorName
%

category: 'accessing'
method: RowanMethodUpdate
className: anObject

	gsMethod behaviorName: anObject
%

category: 'accessing'
method: RowanMethodUpdate
classOop

	^gsMethod behavior
%

category: 'accessing'
method: RowanMethodUpdate
classOop: anObject

	gsMethod behavior: anObject.
%

category: 'accessing'
method: RowanMethodUpdate
compilationWarnings

	^gsMethod warnings
%

category: 'accessing'
method: RowanMethodUpdate
compilationWarnings: aString

	gsMethod warnings: aString
%

category: 'accessing'
method: RowanMethodUpdate
firstSendOffsets

	^firstSendOffsets
%

category: 'initialization'
method: RowanMethodUpdate
initialize

	firstSendOffsets := Dictionary new.
	gsMethod := RowanGsMethod new.
%

category: 'accessing'
method: RowanMethodUpdate
isOverride

	^isOverride
%

category: 'accessing'
method: RowanMethodUpdate
isOverride: anObject

	isOverride := anObject
%

category: 'accessing'
method: RowanMethodUpdate
isReadOnly

	^gsMethod isReadOnly
%

category: 'accessing'
method: RowanMethodUpdate
isReadOnly: anObject

	gsMethod isReadOnly: anObject
%

category: 'accessing'
method: RowanMethodUpdate
isTestClass

	^isTestClass
%

category: 'accessing'
method: RowanMethodUpdate
isTestClass: anObject

	isTestClass := anObject
%

category: 'accessing'
method: RowanMethodUpdate
method: anObject
	
	method := anObject
%

category: 'accessing'
method: RowanMethodUpdate
methodOop

	^gsMethod oopType
%

category: 'accessing'
method: RowanMethodUpdate
methodOop: anObject

	gsMethod oopType: anObject
%

category: 'accessing'
method: RowanMethodUpdate
originalMethodSource

	 ^gsMethod originalSource
%

category: 'accessing'
method: RowanMethodUpdate
originalMethodSource: anObject

	gsMethod originalSource: anObject
%

category: 'accessing'
method: RowanMethodUpdate
selector

	^gsMethod name
%

category: 'accessing'
method: RowanMethodUpdate
selector: anObject

	gsMethod name: anObject
%

category: 'accessing'
method: RowanMethodUpdate
source

	^gsMethod source
%

category: 'accessing'
method: RowanMethodUpdate
source: anObject

	gsMethod source: anObject
%

category: 'accessing'
method: RowanMethodUpdate
stepPoints

	^gsMethod stepPoints
%

category: 'accessing'
method: RowanMethodUpdate
stepPoints: anObject

	gsMethod stepPoints: anObject
%

category: 'jade'
method: RowanMethodUpdate
writeMethodTo: writeStream
		
		writeStream 	"Line 1 for GsMethod (line 3 for JadeSystemBrowserPresenter)"
"1"		nextPutAll: self classOop printString; tab;
"2"		nextPutAll: self className; tab;
"3"		nextPutAll: self methodOop printString; tab;
"4"		nextPutAll: (self selector ifNil:[String new]); tab;
"5"		nextPutAll: self category; tab;
"6"		nextPutAll: self isReadOnly asString; tab;
		lf.

	"Method source"
	writeStream nextPutAll: self source.
	self source last = Character lf ifFalse: [writeStream lf].
	writeStream nextPut: $%; lf.	"Lines 2-N"

	"unimplemented selectors"			"https://github.com/jgfoster/Jade/issues/117"
	self firstSendOffsets keysAndValuesDo:[:offset :sel |
		writeStream 
			nextPutAll: offset printString;
			space;
			nextPutAll: sel;
			tab].
	writeStream lf.

	self stepPoints keysAndValuesDo:[:key :value |
		writeStream 
			nextPutAll: key
			space;
			nextPutAll: value; 
			tab].
	writeStream lf.
	
	self breakPoints do:[:bp | 
		writeStream nextPutAll: bp printString
		tab].
	writeStream lf.

	"original method"
	self originalMethodSource notNil ifTrue:[
		writeStream nextPutAll: self originalMethodSource.
		(self originalMethodSource notEmpty and: [self originalMethodSource last = Character lf]) ifFalse: [writeStream lf]].
	writeStream nextPut: $%; lf.

	"compilation warnings"
	writeStream nextPutAll: self compilationWarnings; nextPut: $%; lf.
%

! Class implementation for 'RowanPackageUpdate'

!		Instance methods for 'RowanPackageUpdate'

category: 'initialization'
method: RowanPackageUpdate
initialize

	packages := Array new. 
	modifiedPackages := Array new.
	selections := Array new.
%

category: 'accessing'
method: RowanPackageUpdate
modifiedPackages

	^modifiedPackages
%

category: 'accessing'
method: RowanPackageUpdate
packages

	^packages
%

category: 'accessing'
method: RowanPackageUpdate
selections

	^selections
%

category: 'jade'
method: RowanPackageUpdate
writeModifiedPackagesTo: writeStream

	modifiedPackages do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanPackageUpdate
writePackagesTo: writeStream

	packages do: [:each | writeStream nextPutAll: each name; tab].
	writeStream lf.
%

category: 'jade'
method: RowanPackageUpdate
writeSelectionsTo: writeStream

	selections do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

! Class implementation for 'RowanProjectsUpdate'

!		Instance methods for 'RowanProjectsUpdate'

category: 'initialize'
method: RowanProjectsUpdate
initialize

	projects := Array new. 
	modifiedProjects := Array new.
	selection := Array new.
%

category: 'accessing'
method: RowanProjectsUpdate
modifiedProjects

	^modifiedProjects
%

category: 'accessing'
method: RowanProjectsUpdate
projects

	^projects
%

category: 'accessing'
method: RowanProjectsUpdate
selection

	^selection
%

! Class implementation for 'RowanInterface'

!		Class methods for 'RowanInterface'

category: 'instance creation'
classmethod: RowanInterface
newNamed: aName

	^ self new
		initializeForName: aName;
		yourself
%

!		Instance methods for 'RowanInterface'

category: 'accessing'
method: RowanInterface
classes

	| classes |
	classes := IdentitySet new.
	classes
		addAll: self extendedClasses;
		addAll: self definedClasses.
	^ classes
%

category: 'accessing'
method: RowanInterface
definedClasses

	^ self subclassResponsibility: #'definedClasses'
%

category: 'accessing'
method: RowanInterface
extendedClasses

	^ self subclassResponsibility: #'extendedClasses'
%

category: 'initialization'
method: RowanInterface
initializeForName: aName

	name := aName
%

category: 'accessing'
method: RowanInterface
name

	^ name
%

category: 'accessing'
method: RowanInterface
project

	^ self RwProject newNamed: self _loadedProject name
%

category: 'private'
method: RowanInterface
_loadedProject

	^ self subclassResponsibility: #'_loadedProject'
%

category: 'private'
method: RowanInterface
_packageTools

	^ Rowan packageTools
%

category: 'private'
method: RowanInterface
_projectTools

	^ Rowan projectTools
%

! Class implementation for 'RwPackage'

!		Instance methods for 'RwPackage'

category: 'accessing'
method: RwPackage
definedClasses

	^ self _packageTools query classesForPackageNamed: self name
%

category: 'accessing'
method: RwPackage
extendedClasses

	^ self _packageTools query classExtensionsForPackageNamed: self name
%

category: 'testing'
method: RwPackage
isDirty

	^self _loadedPackage isDirty
%

category: 'private'
method: RwPackage
_loadedPackage

	^ Rowan image loadedPackageNamed: self name
%

category: 'private'
method: RwPackage
_loadedProject

	^ self _loadedPackage loadedProject
%

! Class implementation for 'RwProject'

!		Instance methods for 'RwProject'

category: 'properties'
method: RwProject
canCommit

	^ self _specification canCommit
%

category: 'properties'
method: RwProject
comment

	^ self _specification comment
%

category: 'accessing'
method: RwProject
currentBranchName

	| rootPath |
	self useGit
		ifFalse: [ ^ '' ].
	rootPath := self repositoryRootPath.
	rootPath ifNil: [ ^ '' ].
	^ Rowan gitTools gitBranchNameIn:rootPath
%

category: 'accessing'
method: RwProject
definedClasses

	^ self _projectTools query classForProjectNamed: self name
%

category: 'testing'
method: RwProject
existsOnDisk

	^ Rowan image 
		loadedProjectNamed: self name 
			ifPresent: [:loadedProject |
				self repositoryRoot
					ifNil: [ false ]
					ifNotNil: [:fileRef | fileRef exists ] ]
			ifAbsent: [ false ]
%

category: 'exporting'
method: RwProject
exportSpecification

	self _loadedProject asDefinition exportSpecification
%

category: 'accessing'
method: RwProject
extendedClasses

	^ self _projectTools query classExtensionsForProjectNamed: self name
%

category: 'testing'
method: RwProject
isDirty

	^self _loadedProject isDirty
%

category: 'properties'
method: RwProject
loadedCommitId

	^ self _loadedProject loadedCommitId
%

category: 'accessing'
method: RwProject
packageNames

	^ self _loadedProject packageNames
%

category: 'accessing'
method: RwProject
packages

	^ self packageNames collect: [ :packageName | RwPackage newNamed: packageName ]
%

category: 'accessing'
method: RwProject
project

	^ self
%

category: 'accessing'
method: RwProject
projectUrl

	"Return the projectUrl used to clone the project"

	^ self _loadedProject projectUrl
%

category: 'project creation'
method: RwProject
register
	"Create a loaded project based on the receiver's properties in the image."

	self _specification register
%

category: 'properties'
method: RwProject
remote

	^ self _specification remote
%

category: 'accessing'
method: RwProject
repositoryCommitId

	^ self _loadedProject repositoryCommitId
%

category: 'properties'
method: RwProject
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ self _loadedProject repositoryRoot
%

category: 'properties'
method: RwProject
repositoryRootPath

	^ self repositoryRoot pathString
%

category: 'testing'
method: RwProject
useGit

	^self _loadedProject useGit
%

category: 'private'
method: RwProject
_loadedProject

	^ Rowan image loadedProjectNamed: self name
%

category: 'private'
method: RwProject
_specification

	^ self _loadedProject specification
%

! Class implementation for 'RowanService'

!		Class methods for 'RowanService'

category: 'autocommit'
classmethod: RowanService
autoCommit

	^SessionTemps current at: #'Jadeite_AutoCommit' ifAbsentPut: [false]
%

category: 'autocommit'
classmethod: RowanService
flipAutoCommit
	| newValue |
	newValue := self autoCommit == #failed ifTrue:[false] ifFalse:[self autoCommit not].
	^self setAutoCommit: newValue
%

category: 'instance creation'
classmethod: RowanService
new

	^super new initialize
%

category: 'other'
classmethod: RowanService
rowanFixMe

	"send this message to see everywhere that GS_Jade should be fixed"
%

category: 'examples'
classmethod: RowanService
sampleService

	^self new sampleService
%

category: 'autocommit'
classmethod: RowanService
setAutoCommit: object

	^SessionTemps current at: #'Jadeite_AutoCommit' put: object
%

!		Instance methods for 'RowanService'

category: 'other'
method: RowanService
answer: anObject

	| answeringService |
	answeringService := RowanAnsweringService new. 
	answeringService answer: anObject. 
	RowanCommandResult addResult: answeringService.
%

category: 'rowan'
method: RowanService
browserTool

	^self projectTools browser
%

category: 'accessing'
method: RowanService
command

	^command
%

category: 'accessing'
method: RowanService
command: aSymbol

	command := aSymbol
%

category: 'accessing'
method: RowanService
commandArgs

	^commandArgs ifNil:[commandArgs := Array new]
%

category: 'accessing'
method: RowanService
commandArgs: anArray

	"for tests" 

	commandArgs := anArray
%

category: 'symbol dictionaries'
method: RowanService
createDefaultSymbolDictionary

	^self createSymbolDictionaryNamed: self defaultSymbolDictionaryName
%

category: 'samples'
method: RowanService
createSampleSymbolDictionary

	self removeSymbolDictionaryNamed: self sampleSymbolDictionaryName.
	self createSymbolDictionaryNamed: self sampleSymbolDictionaryName
%

category: 'symbol dictionaries'
method: RowanService
createSymbolDictionaryNamed: aName

	| dictionary size |
	dictionary := SymbolDictionary new.
	dictionary at: aName asSymbol put: dictionary.
	size := System myUserProfile symbolList size.
	System myUserProfile insertDictionary: dictionary at: size + 1.
	^ dictionary
%

category: 'symbol dictionaries'
method: RowanService
defaultSymbolDictionary

	^self symbolDictionaryNamed: self defaultSymbolDictionaryName
%

category: 'symbol dictionaries'
method: RowanService
defaultSymbolDictionaryName

	^'RowanProjects'
%

category: 'rowan'
method: RowanService
definitionClass

	^self subclassResponsibility
%

category: 'rowan'
method: RowanService
definitionClassName

	^self definitionClass name
%

category: 'replication'
method: RowanService
excludedInstVars

	^#( #organizer)
%

category: 'initialization'
method: RowanService
initialize
%

category: 'testing'
method: RowanService
isClassService

	^false
%

category: 'testing'
method: RowanService
isMethodService

	^false
%

category: 'testing'
method: RowanService
isPackageService

	^false
%

category: 'testing'
method: RowanService
isProjectService

	^false
%

category: 'accessing'
method: RowanService
jadeiteServer

	^(Rowan jadeServerClassNamed: #JadeServer) theJadeiteServer
%

category: 'accessing'
method: RowanService
organizer: anOrganizer

	organizer := anOrganizer.
%

category: 'rowan'
method: RowanService
projectTools

	^Rowan projectTools
%

category: 'samples'
method: RowanService
removeSampleSymbolDictionary

	self removeSymbolDictionaryNamed: self sampleSymbolDictionaryName.
%

category: 'symbol dictionaries'
method: RowanService
removeSymbolDictionaryNamed: aName

	| index |
	index := System myUserProfile symbolList names indexOf: aName asSymbol.
	index ~= 0 ifTrue:[
		System myUserProfile removeDictionaryAt: index]
%

category: 'other'
method: RowanService
rowanFixMe
		
	"marker for all things broken in Rowan"
%

category: 'rowan'
method: RowanService
rowanLoadedPackageNames

	| stream packages |
	self rowanFixMe.	"handle modified package display"
	stream := WriteStream on: String new.
	packages := Rowan packageNames.
	packages do: 
					[:package |
					stream
						nextPutAll: package;
						tab;
						nextPut: ((RwPackage newNamed: package) isDirty ifTrue:[$Y] ifFalse:[$N]);
						tab;
						nextPutAll: package;
						lf].
	^stream contents
%

category: 'accessing'
method: RowanService
rowanProjectName

	"all services should be able to return a project name
	even if they are not truly packaged" 

	^nil
%

category: 'samples'
method: RowanService
sampleSymbolDictionaryName

	^'SampleSymbolDictionaryName'
%

category: 'perform'
method: RowanService
servicePerform: symbol withArguments: collection
	^super perform: symbol withArguments: collection.
%

category: 'replication'
method: RowanService
stonOn: stonWriter
    | instanceVariableNames |
    instanceVariableNames := self class allInstVarNames reject: [:iv | self excludedInstVars includes: iv].
    stonWriter writeObject: self
        streamMap: 
            [:dictionary |
            instanceVariableNames do: 
                    [:each |
                    (self instVarAt: (self class allInstVarNames indexOf: each asSymbol))
                        ifNotNil: [:value | dictionary at: each asSymbol put: value]
                        ifNil: [self stonShouldWriteNilInstVars ifTrue: [dictionary at: each asSymbol put: nil]]]]
%

category: 'replication'
method: RowanService
stonStringFor: anObject

	"return a string representing a complete object structure
	suitable for replicating on the client."

	^STON toString: anObject
%

category: 'symbol dictionaries'
method: RowanService
symbolDictionaryNamed: aName

	| symbolList  index |
	symbolList := Rowan image symbolList.
	index :=symbolList names indexOf: aName asSymbol.
	^index ~= 0
		ifTrue:[
			symbolList at: index]
		ifFalse:[
			self createSymbolDictionaryNamed: aName].
%

category: 'initialization'
method: RowanService
update
%

category: 'update'
method: RowanService
updateInternalService: updatedService

	"no internally held services to update"
%

category: 'accessing'
method: RowanService
updateType: aSymbol

	updateType := aSymbol
%

category: 'fileout'
method: RowanService
writeFileOutHeaderOn: stream
	"This method will write a fileout header onto the given file.
	Adapted from GBS - GbxBrowser>>writeFileOutHeaderOn:"

	| rawVer beVer cr |
	stream nextPutAll: 'fileformat utf8';
			cr. 
	rawVer := System _version.
	beVer := ''.
	cr := String with: Character cr.
	"Comment each newline"
	(rawVer subStrings: (Array with: Character lf)) do: [:line | beVer := beVer , '! ' , line , cr].
	stream
		nextPutAll: '!';
		cr;
		nextPutAll: '! From ';
		nextPutAll: beVer;
		cr;
		nextPutAll: '! On ';
		nextPutAll: Date today printString;
		nextPutAll: ', ';
		nextPutAll: Time now printString;
		cr;
		nextPutAll: '!';
		cr;
		flush
%

! Class implementation for 'RowanAnsweringService'

!		Instance methods for 'RowanAnsweringService'

category: 'client commands'
method: RowanAnsweringService
allTestsIn: classServices
	answer := Array new. 
	classServices do:[:service | answer addAll: service allTests].
	RowanCommandResult addResult: self.
%

category: 'other'
method: RowanAnsweringService
answer

	^answer
%

category: 'Updating'
method: RowanAnsweringService
answer: anObject

	answer := anObject
%

category: 'client commands'
method: RowanAnsweringService
autoCommit

	answer := RowanService autoCommit. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
exec: aString

	"for command line service someday"
	answer := aString evaluate printString. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
exec: aString context: oop

	answer := [true -> (aString evaluateInContext: (Object _objectForOop: oop) symbolList: GsSession currentSession symbolList) asOop] 
		on: CompileError do: [:ex | 
			false -> ex errorDetails
	].
	answer key ifTrue:[(RowanService autoCommit == true) ifTrue:[System commitTransaction]].
	RowanCommandResult addResult: self.

	"return answer for testing" 
	^answer
%

category: 'client commands'
method: RowanAnsweringService
flipTranscript
	self isTranscriptInstalled ifTrue:[
		self jadeiteServer uninstallTranscript]
	ifFalse:[
		self jadeiteServer installTranscript]
%

category: 'client commands'
method: RowanAnsweringService
initializeAutoCommit

	RowanService setAutoCommit: false
%

category: 'testing'
method: RowanAnsweringService
isTranscriptInstalled

	^self transcriptObject == self jadeiteServer
%

category: 'client commands'
method: RowanAnsweringService
loadedPackageExists: packageName
	
	| actualName |
	actualName := Rowan image packageNames detect:[:loadedName | loadedName asLowercase = packageName asLowercase] ifNone:[]. 
	answer := (Rowan image loadedPackageNamed: actualName ifAbsent: []) notNil. 
	command := nil. 
	commandArgs := nil. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
printStringOf: oop toMaxSize: integer

	answer := (Object _objectForOop: oop) printString. 
	answer := answer size > integer ifTrue: [(answer copyFrom: 1 to: integer) , '...'] ifFalse:[answer].
	RowanCommandResult addResult: self.
	^answer
%

category: 'client commands'
method: RowanAnsweringService
runMethodTests: methodServices

	| behavior |
	methodServices do:[:methodService |
		(methodService selector asString matchPattern: #('test' $*)) ifTrue:[ 
			behavior := methodService theClass. 
			behavior debug: methodService selector]].
	answer := true. 
	RowanCommandResult initializeResults. "squash any client updates during server test run"
	RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
selectorsMatchingPattern: pattern

	answer := ((AllUsers userWithId: #SymbolUser) resolveSymbol: #AllSymbols) value.
	answer := answer select: [:each |each _matchPatternNoCase: pattern].
	answer := answer asSortedCollection asArray.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
setAutoCommit: object

	answer := RowanService setAutoCommit: object.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
subclassCreationTemplate: className
	 (RowanClassService new name: className) subclassCreationTemplate.  "gives an answer for us"
%

category: 'client commands'
method: RowanAnsweringService
transcriptInstalled

	answer := self isTranscriptInstalled.
	RowanCommandResult addResult: self.
%

category: 'private'
method: RowanAnsweringService
transcriptObject
	
	^(SessionTemps current  at: #'TranscriptStream_SessionStream')
%

category: 'client commands'
method: RowanAnsweringService
turnOffTranscriptWrites

	self isTranscriptInstalled ifTrue:[
		self flipTranscript]
%

! Class implementation for 'RowanBrowserService'

!		Instance methods for 'RowanBrowserService'

category: 'client commands'
method: RowanBrowserService
abortTransaction

	System abortTransaction.
	self updateProjects.
	self packagesWithTests.
	self updateType: #aborted:browser:.
%

category: 'client commands'
method: RowanBrowserService
allClasses

	allClasses := SortedCollection sortBlock: [:x :y | x name < y name].
	allClasses addAll: (organizer classes collect:[:class | 
			| service |
			service := RowanClassService new name: class name. 
			service packageName: class rowanPackageName.
			service projectName: class rowanProjectName.
			service]
			).
	allClasses := allClasses asArray. 
	updateType := #classes. "#classes not used at the moment so no updates will be done"
	RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
autoCommit: object

	RowanService setAutoCommit: object.
	autoCommit := RowanService autoCommit. 
	updateType := #autoCommitUpdate:.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanBrowserService
defaultClassHierarchy
	hierarchyServices := Dictionary new.   
	organizer hierarchy keysAndValuesDo: [:key :value |
		| classService |
		classService := key == #nil ifTrue:[#nil] ifFalse: [RowanClassService basicForClassNamed: key name].
		hierarchyServices at: classService put: (value collect:[:cls | RowanClassService basicForClassNamed: cls name]) asArray.
	].
	updateType := #classHierarchyUpdate:browser:. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanBrowserService
findRemovedServices: services

	services do:[:service | 
		service wasDeleted ifTrue:[
				service updateType: #removed:.
				RowanCommandResult addResult: service.
		]
	].
%

category: 'client commands'
method: RowanBrowserService
flipAutoCommit

	autoCommit := RowanService flipAutoCommit. 
	updateType := #autoCommitUpdate:.
	RowanCommandResult addResult: self.
%

category: 'window registry'
method: RowanBrowserService
openWindows

	"for testing"

	^SessionTemps current at: #rowanServicesWindowRegistry ifAbsent:[]
%

category: 'client commands'
method: RowanBrowserService
packagesWithTests
	testPackages := Set new. 
	testCount := 0. 
	TestCase allSubclasses do:[:testSubclass |
		testSubclass selectors do:[:selector |
			| packageName |
			(selector size >= 4 and:[
			(selector copyFrom: 1 to: 4) asString = 'test']) ifTrue:[
				packageName := (testSubclass compiledMethodAt: selector) rowanPackageName. 
				packageName = Rowan unpackagedName ifFalse:[
					testCount := testCount + 1. 
					testPackages add: (RowanPackageService forPackageNamed: packageName)]]]]. 
	updateType := #testPackages:. 
	testPackages := testPackages asArray. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanBrowserService
releaseWindowHandle: integer

	| registry |
	RowanLoggingService current logComment: 'Release window with handle: ', integer printString. 
	registry := SessionTemps current at: #rowanServicesWindowRegistry ifAbsent:[^self].
	registry removeKey: integer ifAbsent: []
%

category: 'client commands'
method: RowanBrowserService
reloadProjects: projectServices andUpdateServices: services
	| projectNames |
	projectServices do:[:projectService |
		projectService reloadProject].
	projectNames := projectServices collect: [:projectService | projectService name]. 
	services do:[:service | 
		(projectNames includes: service rowanProjectName) ifTrue:[service update]].
%

category: 'client commands'
method: RowanBrowserService
removeMethods: methodServices

	| notRemoved |
	notRemoved := Array new. 
	removedMethods := Array new. 
	methodServices do: [:methodService |
		| classService |
		classService := RowanClassService forClassNamed: methodService className. 
		classService meta: methodService meta. 
		classService removeSelector: methodService selector ifAbsent:[notRemoved add: methodService].
		classService updatePackageProject.
		(notRemoved includes: methodService) ifFalse:[
			methodService updateType: #removed:.
			RowanCommandResult addResult: methodService]. 
		removedMethods add: methodService].
	notRemoved isEmpty ifFalse:[
		self error: 'These selectors were not removed - ', (notRemoved collect:[:ea | ea selector]) printString].
	updateType := #methodsRemoved:. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanBrowserService
saveRootObject: oop windowHandle: integer

	" a window has been opened on the client. Save the 
	root object of the window so it won't be recycled"
	| dictionary |
	dictionary := SessionTemps current at: #rowanServicesWindowRegistry ifAbsentPut: [Dictionary new].
	dictionary at: integer put: (Object _objectForOop: oop).
%

category: 'perform'
method: RowanBrowserService
servicePerform: symbol withArguments: collection
	super perform: symbol withArguments: collection.
%

category: 'client commands'
method: RowanBrowserService
unloadProjectsNamed: array
	array do:[:projectName |
		| project |
		project := Rowan image loadedProjectNamed: projectName ifAbsent:[].
		project ifNotNil: [
			Rowan projectTools delete deleteProjectNamed: projectName]]. 
	self updateProjects
%

category: 'update'
method: RowanBrowserService
update

	self updateProjects
%

category: 'client commands'
method: RowanBrowserService
updateProjects
	| sortedProjects | 
	sortedProjects := SortedCollection sortBlock: [:a :b | a name < b name]. 
	sortedProjects addAll:  Rowan image loadedProjects.
	projects := sortedProjects collect:[:project | RowanProjectService newNamed: project name].
	updateType := #projectsUpdate:.
	RowanCommandResult addResult: self
%

! Class implementation for 'RowanClassService'

!		Class methods for 'RowanClassService'

category: 'instance creation'
classmethod: RowanClassService
basicForClassNamed: className 
	"Don't get method services. Efficient for classes with many methods"
	^self new basicForClassNamed: className
%

category: 'instance creation'
classmethod: RowanClassService
forClassNamed: className 

	^self new forClassNamed: className
%

category: 'instance creation'
classmethod: RowanClassService
forClassNamed: className meta: aBoolean

	| inst |
	inst := self forClassNamed: className subStrings first.
	inst meta: aBoolean.
	^inst
%

category: 'instance creation'
classmethod: RowanClassService
forClassNamed: className package: packageName

	| inst |
	inst := self forClassNamed: className.
	inst packageName: packageName.
	^inst
%

category: 'instance creation'
classmethod: RowanClassService
minimalForClassNamed: className 
	"Don't get method services. Efficient for classes with many methods"
	^self new minimalForClassNamed: className
%

!		Instance methods for 'RowanClassService'

category: 'comparing'
method: RowanClassService
= classService
	(classService class canUnderstand: #isClassService) ifFalse:[^false].
	^classService isClassService
			ifTrue: [  name asString = classService name asString and: [meta = classService meta]]
			ifFalse: [^false]
%

category: 'client commands'
method: RowanClassService
addCategory: string

	| theClass |

	theClass := self theClass.
	meta ifTrue:[theClass := theClass class]. 
	theClass addCategory: string.
%

category: 'Accessing'
method: RowanClassService
allTests
	| allSelectors theClass |
	self isTestCase ifFalse:[^Array new]. 
	theClass := self theClass thisClass.
	theClass isAbstract ifTrue:[^Array new].
	allSelectors := self theClass thisClass allTestSelectors.
	^allSelectors collect:[:selector | 
			RowanMethodService forSelector: selector 
										class: (theClass whichClassIncludesSelector: selector asString)
										meta: false
										organizer: organizer].
%

category: 'testing'
method: RowanClassService
arePackageAndProjectClean

	^self packageIsDirty not and:[self projectIsDirty not]
%

category: 'initialization'
method: RowanClassService
basicForClassNamed: className 

	| theClass |
	self name: className. 
	theClass := self theClass. 
	theClass isNil ifTrue:[oop := nil. ^self].
	self basicRefreshFrom: theClass.
%

category: 'initialization'
method: RowanClassService
basicRefreshFrom: theClass
	| classOrMeta theFilters |
	oop := theClass asOop.
	command := nil. 
	commandArgs := nil. 
	superclassName := theClass superClass ifNotNil:[:theSuper | theSuper name asString]. 
	comment := theClass rwComment. 
	organizer ifNil: [organizer := ClassOrganizer new]. "for Jade and tests"
	versions := theClass classHistory size.
	version := theClass classHistory indexOf: theClass.
	self setComment.
	template := self classCreationTemplate.
	theFilters := SortedCollection new.
	classOrMeta := meta == true ifTrue:[theClass class] ifFalse:[theClass].
	self initializeVariablesFor: classOrMeta. 
	self initializeCategoriesFor: classOrMeta.
	packageName := definedPackageName := classOrMeta rowanPackageName.
	projectName := classOrMeta rowanProjectName.
	instVarNames := classOrMeta instVarNames. 
	self setIsTestCase.
%

category: 'Accessing'
method: RowanClassService
behavior

	| behavior |
	behavior := self theClass. 
	meta == true ifTrue:[behavior := behavior class].
	^behavior
%

category: 'client commands'
method: RowanClassService
classComment: string
	| theClass |
	theClass := self theClass. 
	theClass rwComment: string.
%

category: 'rowan'
method: RowanClassService
classCreationTemplate
	
	^self browserTool classCreationTemplateForClass: self theClass hybridBrowser: true.
%

category: 'client commands'
method: RowanClassService
classHierarchy
	| behavior |
	behavior := self theClass. 
	organizer := ClassOrganizer newWithRoot: behavior. 
	hierarchyServices := Dictionary new.   
	organizer hierarchy keysAndValuesDo: [:key :value |
		| classService |
		classService := key == #nil ifTrue:[#nil] ifFalse: [(self classServiceFromOop: key asOop) meta: meta].
		hierarchyServices at: classService put: (self subclassServices: value). 
	].
	RowanCommandResult addResult: self.
%

category: 'Accessing'
method: RowanClassService
classHierarchyNames

	| names |
	names := Array new. 
	hierarchyServices keys do:[:classService | 
		classService == #nil ifFalse:[names add: classService name]].
	^names
%

category: 'Accessing'
method: RowanClassService
classInstVarNames
	^classInstVarNames
%

category: 'Updating'
method: RowanClassService
classInstVarNames: newValue
	classInstVarNames := newValue
%

category: 'Accessing'
method: RowanClassService
classOrMeta

	^meta 
			ifTrue:[self theClass class] 
			ifFalse: [self theClass].
%

category: 'instance creation'
method: RowanClassService
classServiceFromOop: anOop
	| theClass className classService |
	theClass := Object _objectForOop: anOop. 
	className := theClass name. 
	classService := RowanClassService new name: className.
	^className asString = name asString ifTrue:[
			className asString = 'Object' 
				ifTrue:[
					classService basicRefreshFrom: theClass]
				ifFalse:[
					classService refreshFrom: theClass]]
		ifFalse:[
			classService minimalRefreshFrom: theClass]
%

category: 'Accessing'
method: RowanClassService
classType
	^classType
%

category: 'Updating'
method: RowanClassService
classType: newValue
	classType := newValue
%

category: 'Accessing'
method: RowanClassService
classVarNames
	^classVarNames
%

category: 'Updating'
method: RowanClassService
classVarNames: newValue
	classVarNames := newValue
%

category: 'Accessing'
method: RowanClassService
comment
	^comment
%

category: 'Updating'
method: RowanClassService
comment: newValue
	comment := newValue
%

category: 'method compilation'
method: RowanClassService
compileMethod: methodString behavior: aBehavior symbolList: aSymbolList inCategory: categorySymbol
	"returns (nil -> anArrayOfErrors) or (aGsNMethod -> compilerWarnings) or (aGsNMethod -> nil)"

	| method warnings |
	
	[ [ [ method := aBehavior rwCompileMethod: methodString category: categorySymbol  ]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: false ] ] 
			on: CompileError
			do: [:ex | ^nil -> (ex gsArguments at: 1)]]
				on: CompileWarning
				do: 
					[:ex | 
					warnings := ex warningString.
					ex resume].
	^[(self compiledMethodAt: method key selector inClass: aBehavior) -> warnings] on: Error
		do: [:ex | ex return: method -> warnings]
%

category: 'Updating'
method: RowanClassService
definedPackageName: newValue

	definedPackageName := newValue
%

category: 'Updating'
method: RowanClassService
expand: boolean

	expand := boolean
%

category: 'other'
method: RowanClassService
fastRefresh
	"pushes less information to ston so it's faster"

	| theClass |
	theClass := self theClass. 
	self refreshFrom: theClass. 
	methods do:[:service1 |
			service1 source: nil; 
					stepPoints: Array new.
	visibleTests do:[:service2 |
			service2 source: nil; 
					stepPoints: Array new].
			].
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanClassService
fileoutCategories: array
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	array do:[:category |
		self behavior fileOutCategory: category on: ws]. 
	answeringService answer: ws contents. 
	RowanCommandResult addResult: answeringService.
%

category: 'client commands'
method: RowanClassService
fileoutClass
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	ws nextPutAll: self behavior fileOutClass. 
	answeringService answer: ws contents. 
	RowanCommandResult addResult: answeringService.
%

category: 'client commands'
method: RowanClassService
fileoutMethods: array
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	array do:[:methodService |
		self behavior fileOutMethod: methodService selector on: ws]. 
	answeringService answer: ws contents. 
	RowanCommandResult addResult: answeringService.
%

category: 'Accessing'
method: RowanClassService
filters
	^filters
%

category: 'Updating'
method: RowanClassService
filters: newValue
	filters := newValue
%

category: 'initialization'
method: RowanClassService
forClassNamed: className 

	| theClass |
	self name: className. 
	theClass := self theClass. 
	self refreshFrom: theClass.
%

category: 'comparing'
method: RowanClassService
hash
	^self name hash bitXor: meta hash
%

category: 'Accessing'
method: RowanClassService
hierarchyServices

	^hierarchyServices
%

category: 'initialization'
method: RowanClassService
initialize

	isExtension := false.
	selectedMethods := Array new.
	meta := false. "assume most of our work is on the instance side"
	selectedPackageServices := Array new.
	isNewClass := false.
	methods := Array new.
	isInSymbolList := true.
%

category: 'initialization'
method: RowanClassService
initializeCategoriesFor: classOrMeta

	| theFilters |
	theFilters := SortedCollection new.
	classOrMeta env: 0 categorysDo: [:category :selector | theFilters add: category asString].
	categories := theFilters asOrderedCollection.
%

category: 'initialization'
method: RowanClassService
initializeTestMethodsFor: aClass
	| testSelectors |
	(aClass inheritsFrom: TestCase) ifTrue:[
		aClass isAbstract ifTrue:[^self]. 
		testSelectors := aClass thisClass suite tests collect:[:method | method selector]. 
		methods do:[:methodService | 
			methodService isTestMethod: (testSelectors includes: methodService selector)]].
%

category: 'initialization'
method: RowanClassService
initializeVariablesFor: classOrMeta

	| theFilters |
	theFilters := SortedCollection new.
	theFilters addAll: (classOrMeta allInstVarNames collect:[:instVar | instVar asString]).
	variables := theFilters asOrderedCollection.
%

category: 'Accessing'
method: RowanClassService
instVarNames
	^instVarNames
%

category: 'Updating'
method: RowanClassService
instVarNames: newValue
	instVarNames := newValue
%

category: 'testing'
method: RowanClassService
isClassService

	^true
%

category: 'Updating'
method: RowanClassService
isExtension: boolean

	isExtension := boolean
%

category: 'Updating'
method: RowanClassService
isNewClass: boolean
	isNewClass := boolean
%

category: 'Updating'
method: RowanClassService
isTestCase

	^isTestCase
%

category: 'Updating'
method: RowanClassService
isTestCase: aBoolean

	isTestCase := aBoolean
%

category: 'Accessing'
method: RowanClassService
meta

	^meta
%

category: 'Updating'
method: RowanClassService
meta: anObject

	meta := anObject
%

category: 'Accessing'
method: RowanClassService
methods

	"for testing"
	^methods
%

category: 'private'
method: RowanClassService
methodServiceFrom: gsNMethod in: behavior compiltationResult: compilationResult
	| methodService |

	methodService := RowanMethodService forGsNMethod: gsNMethod organizer: organizer. 
	methodService compilationWarnings: compilationResult value.
	^methodService
%

category: 'private'
method: RowanClassService
methodServicesFor: classOrMeta organizer: theOrganizer

	methods addAll: (classOrMeta selectors collect:[:sel | 
			RowanMethodService 
				forSelector: sel class: classOrMeta thisClass meta: meta organizer: theOrganizer])
%

category: 'private'
method: RowanClassService
methodsIn: theClass categories: theCategories

	| selectors |
	selectors := Array new. 
	theCategories do:[:category |
		selectors addAll: (theClass selectorsIn: category)]. 
	^methods select:[:methodService | selectors includes: methodService selector]
%

category: 'testing'
method: RowanClassService
methodsNamed: selector
	"For testing. Multiple because class could have both instance and class methods"

	^methods select:[:methodService | methodService selector = selector]
%

category: 'initialization'
method: RowanClassService
minimalForClassNamed: className 

	| theClass |
	self name: className. 
	theClass := self theClass. 
	self minimalRefreshFrom: theClass.
%

category: 'initialization'
method: RowanClassService
minimalRefreshFrom: theClass
	| classOrMeta  |
	command := nil. 
	commandArgs := nil. 
	versions := theClass classHistory size.
	version := theClass classHistory indexOf: theClass.
	oop := theClass asOop.
	classOrMeta := meta == true ifTrue:[theClass class] ifFalse:[theClass].
	packageName := definedPackageName := classOrMeta rowanPackageName.
	projectName := classOrMeta rowanProjectName.
	instVarNames := classOrMeta instVarNames. 
	template := self classCreationTemplate.
	self initializeVariablesFor: classOrMeta. 
	self initializeCategoriesFor: classOrMeta.
	self setIsTestCase.
%

category: 'client commands'
method: RowanClassService
moveMethods: methodServices to: category
	| behavior |
	behavior := self classOrMeta.
	methodServices do: [:methodService | 
			behavior rwMoveMethod: methodService selector toCategory: category.
			methodService category: category].
	self update. 
	self selectedMethods: methodServices.
%

category: 'Accessing'
method: RowanClassService
name
	^name
%

category: 'Updating'
method: RowanClassService
name: newValue
	name := newValue asString
%

category: 'private'
method: RowanClassService
objectInBaseNamed: aString

	^System myUserProfile symbolList objectNamed: aString asSymbol
%

category: 'client commands'
method: RowanClassService
oneLevelClassHierarchy
	"good for expanding an existing hierarchy quickly"
	| behavior sortedSubclasses |
	behavior := self theClass. 
	hierarchyServices := Dictionary new. 
	hierarchyServices at: #expand put: Array new. 
	sortedSubclasses := behavior subclasses asSortedCollection:[:x :y | x name < y name].
	sortedSubclasses do: [:subclass |
		| classService |
		classService := (self classServiceFromOop: subclass asOop) meta: meta.
		(hierarchyServices at: #expand) add: classService. 
	].
%

category: 'Accessing'
method: RowanClassService
oop
	^oop
%

category: 'Updating'
method: RowanClassService
oop: newValue
	oop := newValue
%

category: 'testing'
method: RowanClassService
packageIsDirty

	| behavior |
	behavior := self theClass.
	behavior rowanPackageName =  Rowan unpackagedName ifTrue:[^true]. "avoid a refresh by assuming it's dirty" 
	^(RowanPackageService new name: behavior rowanPackageName) rowanDirty
%

category: 'Accessing'
method: RowanClassService
packageName
	
	^packageName
%

category: 'Updating'
method: RowanClassService
packageName: pkgName
	
	packageName := pkgName
%

category: 'Accessing'
method: RowanClassService
poolDictionaryNames
	^poolDictionaryNames
%

category: 'Updating'
method: RowanClassService
poolDictionaryNames: newValue
	poolDictionaryNames := newValue
%

category: 'printing'
method: RowanClassService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $:. 
	aStream nextPutAll: (name ifNil: [nil printString])
%

category: 'testing'
method: RowanClassService
projectIsDirty

	| behavior |
	behavior := self theClass.
	behavior rowanProjectName =  Rowan unpackagedName ifTrue:[^true]. "avoid a refresh by assuming it's dirty" 
	^(RowanProjectService new name: behavior rowanProjectName) rowanDirty
%

category: 'other'
method: RowanClassService
projectName

	^projectName
%

category: 'Updating'
method: RowanClassService
projectName: newValue
	projectName := newValue
%

category: 'initialization'
method: RowanClassService
refreshFrom: theClass
	| classOrMeta  |
	self basicRefreshFrom: theClass. 
	classOrMeta := meta == true ifTrue:[theClass class] ifFalse:[theClass].
	self refreshMethodsFor: classOrMeta
%

category: 'initialization'
method: RowanClassService
refreshMethodsFor: classOrMeta
	| gsNMethods |
	methods := SortedCollection sortBlock: [:x :y | x selector < y selector].
	self methodServicesFor: classOrMeta organizer: organizer.
	methods := methods asOrderedCollection.
	classOrMeta allInstVarNames do:[:instVar | 
			gsNMethods := organizer accessorsOf: instVar inClass: classOrMeta.
			gsNMethods do:[:gsNMethod |
				| service |
				service := methods detect:[:methodService | methodService selector = gsNMethod selector] ifNone:[].
				service ifNotNil:[
					service accessedInstVars add: instVar asString]
	]].
	self initializeTestMethodsFor: classOrMeta thisClass. 
	self setVisibleTests. "methods must be available"
%

category: 'client commands'
method: RowanClassService
removeCategories: theCategories
	| theClass  | 
	self refreshFrom: self theClass. 
	theClass := self theClass.
	meta ifTrue:[theClass := theClass class]. 
	theCategories do: [:category |
		theClass rwRemoveCategory: category.
		].
%

category: 'client commands'
method: RowanClassService
removeMethods: methodsToRemove

	| notRemoved |
	notRemoved := Array new. 
	methodsToRemove do: [:methodService |
		self removeSelector: methodService selector ifAbsent:[notRemoved add: methodService].
		(notRemoved includes: methodService) ifFalse:[
			methodService updateType: #removed:.
			RowanCommandResult addResult: methodService
		]].
	notRemoved isEmpty ifFalse:[
		self error: 'These selectors were not removed - ', (notRemoved collect:[:svc | svc selector]) printString].
%

category: 'rowan'
method: RowanClassService
removeSelector: selector

	self browserTool removeMethod: selector forClassNamed: name asString isMeta: meta
%

category: 'rowan'
method: RowanClassService
removeSelector: selector ifAbsent: absentBlock
	| theClass |
	theClass := self theClass. 
	meta ifTrue: [theClass := theClass class].
	(theClass compiledMethodAt: selector otherwise: nil) isNil ifTrue:[ ^absentBlock value ].
	self browserTool removeMethod: selector forClassNamed: name asString isMeta: meta
%

category: 'client commands'
method: RowanClassService
renameCategoryFrom: old to: new

	| affectedSelectors behavior |

	self update. 
	self addCategory: new. 
	behavior := self classOrMeta.
	affectedSelectors := behavior selectorsIn: old.
	methods := methods select:[:methodService | affectedSelectors includes: methodService selector].
	self moveMethods: methods to: new.
	self removeCategories: (Array with: old)
%

category: 'client commands'
method: RowanClassService
renameClass: oldClassName to: newClassName
	| references newMethods |
	newMethods := Array new. 
	Rowan projectTools browser renameClassNamed: oldClassName to: newClassName.
	name := newClassName. 
	organizer := ClassOrganizer new. 
	references := organizer update referencesTo: oldClassName asSymbol.
	1 to: references first size do:[:index |
		| method newSource compileResult failedCompile methodService oldSource |
		failedCompile := false. 
		method := references first at: index. 
		oldSource := method sourceString. 
		newSource := self replaceSubString: oldClassName in: oldSource with: newClassName.
		compileResult := [method inClass rwCompileMethod: newSource
									category: (method inClass categoryOfSelector: method selector) asSymbol] on: CompileError do:[:ex | failedCompile := true. method].
		methodService := RowanMethodService forGsNMethod: compileResult organizer: organizer.
		failedCompile ifTrue:[
				methodService comparisonSource: oldClassName]
			ifFalse:[
				methodService comparisonSource: oldSource].
		methodService failedCompile: failedCompile. 
		newMethods add: methodService.
		].
	RowanCommandResult addResult: (RowanAnsweringService new answer: newMethods).
%

category: 'private'
method: RowanClassService
replaceSubString: old in: string with: new
	| offset newSource |
	newSource := string. 
	offset := 1. 	
	[(offset := newSource findString: old startingAt: offset) = 0] whileFalse:[
		newSource := newSource copyReplaceFrom: offset to: offset + old size - 1 with: new. 
		offset := offset + new size. 
	].
	^newSource
%

category: 'rowan'
method: RowanClassService
rowanProjectName

	^projectName
%

category: 'client commands'
method: RowanClassService
runClassTests: classService

	"if it errors, the client will handle the error. 
	If it passes, we return true and the client
	will display decent results." 
	| behavior |
	behavior := classService theClass. 
	self refreshFrom: behavior.
	self tests do:[:methodService |
			behavior debug: methodService selector]. 
	RowanCommandResult addResult: (RowanAnsweringService new answer: true).
%

category: 'client commands'
method: RowanClassService
runMethodTests: methodServices

	| behavior |
	behavior := self theClass.  
	methodServices do:[:methodService |
		(methodService selector asString matchPattern: #('test' $*)) ifTrue:[ 
			behavior debug: methodService selector]].
	RowanCommandResult addResult: (RowanAnsweringService new answer: true).
%

category: 'client commands'
method: RowanClassService
saveMethodSource: source category: category

	| behavior compilationResult gsNMethod updatedCategory methodService |        
	meta ifNil:[
				behavior := (Object _objectForOop: oop). 
				meta := behavior isMeta]
			ifNotNil:[ 
				behavior := meta ifTrue:[self theClass class] ifFalse:[self theClass]]. 
	updatedCategory := category ifNil: ['other'].
	compilationResult := self		
		compileMethod: source 
		behavior: behavior 
		symbolList: System myUserProfile symbolList
		inCategory: updatedCategory asSymbol.
	(gsNMethod := compilationResult key) isNil ifTrue: [
		System
			signal: 1001  
			args: (Array with: compilationResult value) 
			signalDictionary: GemStoneError.
	]. 
	self update.  
	methodService := self methodServiceFrom: gsNMethod in: behavior compiltationResult: compilationResult.
	RowanCommandResult addResult: methodService.
	RowanQueryService new 
			organizer: ClassOrganizer new;
			hierarchyImplementorsOf: methodService selector inClass: methodService className. "this will update hierarchy method indicators for client"
	self selectedMethods: (Array with: methodService).
	self updateDirtyState.
%

category: 'other'
method: RowanClassService
selectedMethods
	"client side selection. Used after a method compile" 
	^selectedMethods
%

category: 'Updating'
method: RowanClassService
selectedMethods: theMethods
	selectedMethods := theMethods
%

category: 'Accessing'
method: RowanClassService
selectedPackageServices
	^selectedPackageServices
%

category: 'Updating'
method: RowanClassService
selectedPackageServices: newValue
	selectedPackageServices := newValue
%

category: 'Accessing'
method: RowanClassService
selectors

	^methods collect:[:methodService | methodService selector]
%

category: 'perform'
method: RowanClassService
servicePerform: symbol withArguments: collection
	| wasClean |
	wasClean := self arePackageAndProjectClean.
	super servicePerform: symbol withArguments: collection.
	updateAfterCommand == false ifFalse:[
		self update].
	wasClean ifTrue:[
		self updatePackageProject]
%

category: 'Accessing'
method: RowanClassService
setComment

	| theClass |
	theClass := self theClass.
	(theClass canUnderstand: #comment)
		ifTrue: [comment := theClass comment]
		ifFalse: 
			[(theClass canUnderstand: #description)
					ifTrue: 
						[| description |
						description := theClass description.
						description class name = #GsClassDocumentation
							ifTrue: [comment := description detailsAboutClass]]].
	comment isNil ifTrue: [comment := String new].
%

category: 'Updating'
method: RowanClassService
setIsTestCase

	isTestCase := self theClass isSubclassOf: TestCase
%

category: 'client commands'
method: RowanClassService
setIsTestCaseCommand

	self setIsTestCase.
%

category: 'client commands'
method: RowanClassService
setVisibleTests
	visibleTests := SortedCollection sortBlock: [:x :y | x selector < y selector]. 
	visibleTests addAll: self allTests.
	visibleTests := visibleTests asArray.
%

category: 'client commands'
method: RowanClassService
subclassCreationTemplate
	| answerService |
	answerService := RowanAnsweringService new. 
	answerService answer: (self browserTool classCreationTemplateForSubclassOf: name 
								className: 'NewSubclass' category: self theClass rowanPackageName).
	RowanCommandResult addResult: answerService.
%

category: 'private'
method: RowanClassService
subclassServices: subclasses

	| sortedSubclasses |

	sortedSubclasses := SortedCollection sortBlock: [:x :y | x name < y name]. 
	sortedSubclasses addAll: subclasses. 
	^(sortedSubclasses collect:[:cls | (self classServiceFromOop: cls asOop) meta: meta]) asArray.
%

category: 'Accessing'
method: RowanClassService
subclassType
	^subclassType
%

category: 'Updating'
method: RowanClassService
subclassType: newValue
	subclassType := newValue
%

category: 'Accessing'
method: RowanClassService
superclassName
	^superclassName
%

category: 'Updating'
method: RowanClassService
superclassName: newValue
	superclassName := newValue
%

category: 'Accessing'
method: RowanClassService
template
	^template
%

category: 'Updating'
method: RowanClassService
template: newValue
	template := newValue
%

category: 'private'
method: RowanClassService
tests

	^methods select:[:methodService | methodService selector asString matchPattern: #('test' $*)]
%

category: 'instance creation'
method: RowanClassService
theClass
	| theClass |
	theClass := oop ifNil:[Rowan globalNamed: name] ifNotNil: [Object _objectForOop: oop].
	theClass isMeta ifTrue:[oop := theClass thisClass asOop]. 
	(Rowan globalNamed: name) ifNil:[isInSymbolList := false]. 
	^theClass thisClass
%

category: 'updates'
method: RowanClassService
update

	self updateClass.
%

category: 'updates'
method: RowanClassService
updateClass

	"It's possible to have a nil class. For example, if we added & selected
	a class then aborted."

	| theClass |
	theClass := self theClass. 
	theClass isNil ifTrue:[oop := nil. ^self]. 
	theClass isBehavior ifFalse:[oop := theClass asOop. ^self].
	self refreshFrom: theClass.
	RowanCommandResult addResult: self
%

category: 'updates'
method: RowanClassService
updateDirtyState
	| projectService | 
	selectedPackageServices do:[:packageService | 
		packageService update. 
		RowanCommandResult addResult: packageService].
	projectService := RowanProjectService newNamed: self theClass rowanProjectName. 
	RowanCommandResult addResult: projectService.
%

category: 'updates'
method: RowanClassService
updatePackageProject
	| packageService projectService |

	packageService := RowanPackageService new name: packageName. 
	packageService update. 
	RowanCommandResult addResult: packageService.

	projectService := RowanProjectService new name: projectName. 
	projectService update.
	RowanCommandResult addResult: projectService.
%

category: 'Accessing'
method: RowanClassService
version
	^version
%

category: 'Updating'
method: RowanClassService
version: newValue
	version := newValue
%

category: 'Accessing'
method: RowanClassService
versions
	^versions
%

category: 'Updating'
method: RowanClassService
versions: newValue
	versions := newValue
%

category: 'testing'
method: RowanClassService
wasDeleted
	^(Rowan globalNamed: name) isNil
%

! Class implementation for 'RowanDebuggerService'

!		Instance methods for 'RowanDebuggerService'

category: 'debug string'
method: RowanDebuggerService
debugStringFrom: aString
	| debugStream newStream char | 
	debugStream := ReadStream on: aString trimLeadingBlanks.
	debugStream contents isEmpty ifTrue:[^'nil halt.'].
	newStream := WriteStream on: String new. 
	((char := debugStream next) = $|) ifTrue:[
		newStream nextPut: char. 
		newStream nextPutAll: (debugStream upTo: $|); 
			nextPut: $|;
			nextPut: Character space;
			nextPutAll: 'nil halt. '
	]
	ifFalse: [
		newStream 
			nextPutAll: 'nil halt. ';
			nextPut: char]. 		
	newStream nextPutAll: debugStream upToEnd. 
	^newStream contents
%

category: 'other'
method: RowanDebuggerService
update

	processes := OrderedCollection with: (RowanProcessService onActiveProcess: (Object _objectForOop: initialProcessOop)).
	ProcessorScheduler scheduler readyProcesses 			do: [:each | processes add: (RowanProcessService onReadyProcess: 		each)].
	ProcessorScheduler scheduler suspendedProcesses 	do: [:each | processes add: (RowanProcessService onSuspendedProcess: 	each)].
	ProcessorScheduler scheduler waitingProcesses 		do: [:each | processes add: (RowanProcessService onWaitingProcess: 		each)].
	RowanCommandResult addResult: self.
%

! Class implementation for 'RowanFrameService'

!		Class methods for 'RowanFrameService'

category: 'other'
classmethod: RowanFrameService
process: aGsProcess level: anInteger organizer: aClassOrganizer

	^self basicNew
		initializeProcess: aGsProcess level: anInteger organizer: aClassOrganizer;
		yourself
%

!		Instance methods for 'RowanFrameService'

category: 'other'
method: RowanFrameService
initializeProcess: aGsProcess level: anInteger organizer: aClassOrganizer
	"In 3.2.15 the server does some whacky things with IP, stepPoint, and nested methods.
	See http://kermit.gemtalksystems.com/bug?bug=45553 --JGF"

	| frameData gsNMethod |
	frameData := aGsProcess _frameContentsAt: anInteger.
	oop := (frameData at: 8) asOop.
	gsNMethod := frameData at: 1.
	label := aGsProcess _reportAt: anInteger.
	method := RowanMethodService forGsNMethod: gsNMethod organizer: aClassOrganizer.
	stepPoint := gsNMethod == gsNMethod homeMethod
		ifTrue: [aGsProcess _stepPointAt: anInteger]
		ifFalse: [gsNMethod homeMethod _stepPointForMeth: gsNMethod ip: (frameData at: 2)].
	vars := self varsFor: frameData.
%

category: 'other'
method: RowanFrameService
varsFor: anArray

	| keys list receiver values |
	receiver := anArray at: 10.
	values := OrderedCollection new.
	(Reflection classOf: receiver) name == #'ClientForwarder' ifTrue: [
		keys := OrderedCollection with: 'clientObject'.
		values add: receiver clientObject.
		receiver := '[aClientForwarder(' , (self oopOf: receiver) printString , ')]'.
	] ifFalse: [
		((receiver isKindOf: BlockClosure) or: [receiver isKindOf: Class]) ifTrue: [
			keys := OrderedCollection new.
		] ifFalse: [
			keys := receiver class allInstVarNames asOrderedCollection collect: [:each | '-' , each].
			1 to: keys size do: [:i |
				values add: (receiver instVarAt: i).
			].
		].
	].
	keys addFirst: #'receiver'.
	values addFirst: receiver.
	keys addAll: (anArray at: 9).
	keys := keys reject: [:each | each first == $.].
	values addAll: (anArray size >= 11
		ifTrue: [anArray copyFrom: 11 to: anArray size]
		ifFalse: [#()]).
	list := Array new.
	1 to: (keys size min: values size) do: [:i | | theOop key value valueClass | 
		key := keys at: i.
		value := values at: i.
		valueClass := value class.
		theOop := value asOop.
		value := [
			value printString.
		] on: Error do: [:ex | 
			ex return: '(' , value class name , ' printString error: ' , ex description , ')'. 
		].
		value size > 500 ifTrue: [value := (value copyFrom: 1 to: 500) , '...'].
		value := value collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$?] ifFalse: [char]].
		list add: (RowanVariableService oop: theOop key: key value: value className: valueClass name asString).
	].
	^list
%

! Class implementation for 'RowanLoggingService'

!		Class methods for 'RowanLoggingService'

category: 'accessing'
classmethod: RowanLoggingService
current

	^Current
%

category: 'accessing'
classmethod: RowanLoggingService
current: anObject

	^Current := anObject
%

!		Instance methods for 'RowanLoggingService'

category: 'accessing'
method: RowanLoggingService
fileName
	^fileName
%

category: 'accessing'
method: RowanLoggingService
fileName: object
	fileName := object
%

category: 'client commands'
method: RowanLoggingService
logComment: string

	| stonString ws |
	isLogging ifFalse:[^self].
	comment := string.
	id := id + 1. 
	date := Date today.
	time := Time now.
	location := #server.
	stonString := STON toString: self.
	ws := FileStream 
				write: fileName
				mode: #append.
	[ws nextPutAll: stonString] ensure: [ws close].
	comment := nil "service may be reused. Clear comment"
%

category: 'accessing'
method: RowanLoggingService
logFileContents

	| rs |
	rs := [FileStream read: fileName] on: Error do:[:ex | ^String new].
	[^rs contents] ensure: [rs close]
%

category: 'client commands'
method: RowanLoggingService
logReceivedServices

	mode := #received.
	self class current: self. 
	self logServices
%

category: 'client commands'
method: RowanLoggingService
logSentServices

	mode := #sent.
	services := RowanCommandResult results. 
	self logServices.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanLoggingService
logServices

	| stonString ws |
	isLogging ifFalse:[^self].
	id := id + 1. 
	date := Date today.
	time := Time now.
	location := #server.
	stonString := STON toString: self.
	ws := FileStream 
				write: fileName
				mode: #append.
	[ws nextPutAll: stonString] ensure: [ws close]
%

! Class implementation for 'RowanMethodService'

!		Class methods for 'RowanMethodService'

category: 'instance creation'
classmethod: RowanMethodService
forGsNMethod: aGsNMethod organizer: aClassOrganizer

	^self new
		initialize: aGsNMethod organizer: aClassOrganizer;
		yourself
%

category: 'instance creation'
classmethod: RowanMethodService
forSelector: sel class: theClass meta: boolean organizer: anOrganizer

	| service |
	service := self new. 
	service selector: sel;
		meta: boolean.
	service forClass: theClass organizer: anOrganizer.
	^service
%

category: 'utility'
classmethod: RowanMethodService
put: string onStreamWithoutUnicode: stream

	string do:[:char | 
			char asInteger > 255 ifTrue:[
				stream nextPutAll: '$\x', char asInteger asHexString]
			ifFalse:[
				stream nextPut: char
			]].
%

category: 'utility'
classmethod: RowanMethodService
removeUnicode: string

		| ws | 
		ws := WriteStream on: String new. 
		self put: string onStreamWithoutUnicode: ws. 
		^ws contents
%

category: 'utility'
classmethod: RowanMethodService
removeUnicodeFromSource: string

	"possibly a unicode string which is not yet 
	presentable in Jadeite."

	(string isKindOf: MultiByteString) ifTrue:[
		| ws | 
		ws := WriteStream on: String new. 
		ws nextPutAll: '''METHOD SOURCE CANNOT BE DISPLAYED
This method source contains unicode and is not displayable in Jadeite. 
An approximation of the source code is given printed below with $\x<char hex value>
replacing the actual unicode character.''';
			cr; 
			cr.
		self put: string onStreamWithoutUnicode: ws. 
		^ws contents]
	ifFalse:[
		^string].
%

category: 'instance creation'
classmethod: RowanMethodService
source: source selector: selector category: category className: className packageName: packageName meta: boolString

	| service |
	self rowanFixMe. "Need to include super and sub implementors"
	service := self new. 
	service 
		source: source;
		selector: selector;
		category: category asString;
		className: className;
		packageName: packageName;
		meta: boolString == true.
	^service
%

!		Instance methods for 'RowanMethodService'

category: 'comparing'
method: RowanMethodService
= methodService
	(methodService class canUnderstand: #isMethodService) ifFalse:[^false].
	methodService isMethodService ifFalse:[^false].
	^selector = methodService selector
		and: [className asString = methodService className asString and: [meta = methodService meta]]
%

category: 'Accessing'
method: RowanMethodService
accessedInstVars
	^accessedInstVars
%

category: 'Updating'
method: RowanMethodService
accessedInstVars: anArray
	accessedInstVars := anArray
%

category: 'rowan'
method: RowanMethodService
addOrUpdateMethod

		self browserTool  
                   addOrUpdateMethod: source
                   inProtocol: category
                   forClassNamed: self classService name
                   isMeta: meta
                   inPackageNamed: self classService packageName
%

category: 'client commands'
method: RowanMethodService
allReferences

	| methods |
	oop := self gsNMethod asOop. 
	methods := organizer sendersOf: selector.
	references := methods first collect:[:gsNMethod | 
			self class forGsNMethod: gsNMethod organizer: organizer].
	RowanCommandResult addResult: self
%

category: 'initialization'
method: RowanMethodService
breakPointsFor: aGsNMethod
	"Answers an Array stepPoints"

	| list |
	list := Array new.
	aGsNMethod _allBreakpoints ifNil: [^#()] ifNotNil: [:anArray | 
		1 to: anArray size by: 3 do: [:i | 
			list add: (aGsNMethod _stepPointForMeth: (anArray at: i + 1) ip: (anArray at: i + 2)).
		].
	].
	^list
%

category: 'Accessing'
method: RowanMethodService
category
	^category
%

category: 'Updating'
method: RowanMethodService
category: newValue
	category := newValue asString
%

category: 'Accessing'
method: RowanMethodService
classFromName
	
	"the dictionary browser may have versions numbers in the name"
	| nameSymbol |
	nameSymbol := (className copyUpTo: Character space) asSymbol.
	^(System myUserProfile resolveSymbol: nameSymbol) value
%

category: 'Accessing'
method: RowanMethodService
className
	^className
%

category: 'Updating'
method: RowanMethodService
className: newValue
	className := newValue asString
%

category: 'Accessing'
method: RowanMethodService
classOrMeta

	^meta 
			ifTrue:[self classFromName class] 
			ifFalse: [self classFromName].
%

category: 'Accessing'
method: RowanMethodService
classService

	^classService ifNil:[classService := RowanClassService forClassNamed: className package: packageName]
%

category: 'Updating'
method: RowanMethodService
classService: newValue
	classService := newValue
%

category: 'client commands'
method: RowanMethodService
clearBreakAt: stepPoint
	| method |
	method := self isUnboundMethod 
			ifTrue:[Object _objectForOop: oop] 
			ifFalse:[self gsNMethod].
	method clearBreakAtStepPoint: stepPoint.
	self update. 
	RowanCommandResult addResult: self.
%

category: 'Updating'
method: RowanMethodService
comparisonSource: string

	comparisonSource := string
%

category: 'Accessing'
method: RowanMethodService
compilationWarnings

	^compilationWarnings
%

category: 'Updating'
method: RowanMethodService
compilationWarnings: newValue
	compilationWarnings := newValue
%

category: 'rowan'
method: RowanMethodService
definitionClass

	^RwMethodDefinition
%

category: 'Updating'
method: RowanMethodService
failedCompile: boolean	
	
	failedCompile := boolean
%

category: 'client commands'
method: RowanMethodService
fileout
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	ws nextPutAll: (self behavior fileOutMethod: selector asString environmentId: 0).
	answeringService answer: ws contents.
	RowanCommandResult addResult: answeringService.
%

category: 'initialization'
method: RowanMethodService
forClass: theClass organizer: theOrganizer
	"assume meta and selector are set"

	| classOrMeta gsNMethod |
	organizer := theOrganizer. 
	classOrMeta := meta ifTrue:[theClass class] ifFalse:[theClass]. 
	gsNMethod := classOrMeta compiledMethodAt: selector.
	definedPackage := gsNMethod rowanPackageName. 
	oop := gsNMethod asOop. 
	stepPoints := self stepPointsFor: gsNMethod.
	breakPoints := self breakPointsFor: gsNMethod.
	self updateSource: gsNMethod sourceString.
	category := (classOrMeta categoryOfSelector: selector) asString.
	className := theClass name asString. 
	packageName := gsNMethod rowanPackageName. 
	projectName := gsNMethod rowanProjectName.
	self setSupersAndSubsFor: classOrMeta.
	isExtension := self rowanIsExtension.
%

category: 'Accessing'
method: RowanMethodService
gsNMethod

	^[self classOrMeta compiledMethodAt: selector ] on: Error do:[:ex | nil "removed method"]
%

category: 'comparing'
method: RowanMethodService
hash
	^(selector hash bitXor: className hash) bitXor: meta hash
%

category: 'Accessing'
method: RowanMethodService
hasSubs

	^hasSubs
%

category: 'Updating'
method: RowanMethodService
hasSubs: aBoolean

	hasSubs := aBoolean
%

category: 'Accessing'
method: RowanMethodService
hasSupers

	^hasSupers
%

category: 'Updating'
method: RowanMethodService
hasSupers: aBoolean

	hasSupers := aBoolean
%

category: 'initialization'
method: RowanMethodService
initialize

	super initialize. 
	hasSupers := false. 
	hasSubs := false.
	accessedInstVars := Array new.
	isTestMethod := false.
	failedCompile := false.
%

category: 'initialization'
method: RowanMethodService
initialize: aGsNMethod organizer: aClassOrganizer

	| inClass |
	oop := aGsNMethod asOop.
	definedPackage := aGsNMethod rowanPackageName. 
	selector := aGsNMethod selector.
	stepPoints := self stepPointsFor: aGsNMethod.
	breakPoints := self breakPointsFor: aGsNMethod.
	((inClass := aGsNMethod inClass) isNil or: [selector isNil]) ifTrue: [
		meta := false.
		self updateSource: aGsNMethod sourceString.
		hasSupers := false.
		hasSubs := false.
		organizer := aClassOrganizer. 
		inSelectedPackage := false.
		^self
	].
	meta := inClass isMeta.
	self 
		forClass: inClass thisClass 
		organizer: aClassOrganizer.
%

category: 'testing'
method: RowanMethodService
isMethodService

	^true
%

category: 'Accessing'
method: RowanMethodService
isTestMethod

	^isTestMethod
%

category: 'Updating'
method: RowanMethodService
isTestMethod: boolean

	isTestMethod := boolean
%

category: 'testing'
method: RowanMethodService
isUnboundMethod

	(className notNil and: [selector notNil]) ifTrue:[^false].
	^(Object _objectForOop: oop) isKindOf: GsNMethod
%

category: 'Accessing'
method: RowanMethodService
meta
	^meta
%

category: 'Updating'
method: RowanMethodService
meta: aBoolean
	"allow nil parameter for now" 
	meta := aBoolean == true
%

category: 'Accessing'
method: RowanMethodService
method

	^self classFromName compiledMethodAt: selector otherwise: nil
%

category: 'Accessing'
method: RowanMethodService
methodDefinitions
	^methodDefinitions
%

category: 'Updating'
method: RowanMethodService
methodDefinitions: newValue
	methodDefinitions := newValue
%

category: 'Accessing'
method: RowanMethodService
name

	^selector
%

category: 'Accessing'
method: RowanMethodService
packageName
	^packageName
%

category: 'Updating'
method: RowanMethodService
packageName: newValue
	packageName := newValue
%

category: 'printing'
method: RowanMethodService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $(;
				nextPutAll: (className ifNil:[nil printString]); 
				nextPutAll: '>>'; 
				nextPutAll: (selector ifNil:[nil printString]);
				nextPut: $)
%

category: 'rowan'
method: RowanMethodService
removeSelector: sel class: clsName
	
	self rowanFixMe. "combine remove methods variants"
	self browserTool removeMethod: sel asSymbol forClassNamed: (clsName subStrings first) isMeta: (clsName subStrings size = 2)
%

category: 'rowan'
method: RowanMethodService
rowanIsExtension

	^Rowan projectTools browser isExtensionMethod: selector asString forClassNamed: className asString isMeta: meta
%

category: 'rowan'
method: RowanMethodService
rowanProjectName

	^projectName
%

category: 'client commands'
method: RowanMethodService
runTest: testSelector inClassName: theClassName

	| sunitTestResult |
	sunitTestResult := (Rowan image objectNamed: theClassName) run: testSelector asSymbol.
	sunitTestResult errorCount > 0 ifTrue:[testResult := 'error']. 
	sunitTestResult failureCount > 0 ifTrue:[testResult := 'failure']. 
	sunitTestResult passedCount > 0 ifTrue:[testResult := 'passed']. 
	testRunClassName := theClassName. 
	RowanCommandResult addResult: self.
%

category: 'Accessing'
method: RowanMethodService
selectedPackageServices

	^selectedPackageServices
%

category: 'Updating'
method: RowanMethodService
selectedPackageServices: collection

	selectedPackageServices := collection
%

category: 'Accessing'
method: RowanMethodService
selector

	^selector
%

category: 'Updating'
method: RowanMethodService
selector: aSymbol

	selector := aSymbol
%

category: 'perform'
method: RowanMethodService
servicePerform: symbol withArguments: collection
	super servicePerform: symbol withArguments: collection.
	self update.
%

category: 'client commands'
method: RowanMethodService
setBreakAt: stepPoint
	| method |
	method := self isUnboundMethod 
			ifTrue:[Object _objectForOop: oop] 
			ifFalse:[self gsNMethod].
	method setBreakAtStepPoint: stepPoint.
	self update. 
	RowanCommandResult addResult: self.
%

category: 'initialization'
method: RowanMethodService
setSupersAndSubsFor: theClass

	| theSuper |
	theSuper := theClass superClass. 
	hasSupers := false. 
	[theSuper notNil and:[hasSupers not]] whileTrue:[
		hasSupers := theSuper selectors includes: selector.
		hasSupers ifTrue:[
			comparisonSource := theSuper sourceCodeAt: selector.
			superDisplayString := theSuper name, '>>', selector].
		theSuper := theSuper superClass].
	(organizer allSubclassesOf: theClass thisClass) do:[:cls |
		| aClass |
		aClass := theClass isMeta ifTrue:[cls class] ifFalse:[cls]. 
		(hasSubs := aClass includesSelector: selector) ifTrue:[
		^self]].
%

category: 'Accessing'
method: RowanMethodService
source

	^source
%

category: 'Updating'
method: RowanMethodService
source: string
	
	self updateSource: string
%

category: 'Accessing'
method: RowanMethodService
stepPoints

	"for testing"
	
	^stepPoints
%

category: 'Updating'
method: RowanMethodService
stepPoints: collection

	stepPoints := collection
%

category: 'initialization'
method: RowanMethodService
stepPointsFor: aGsNMethod
	"Answers an Array of Associations (offset -> selector) indexed by step point"

	|  selectors list |
	(selectors := aGsNMethod _allDebugInfo: 10) ifNil: [^#()].
	list := aGsNMethod homeMethod  _sourceOffsets.
	list := list collect: [:each |
		| index eachSelector |
		eachSelector := ''.
		index := selectors indexOf: each.
		0 < index ifTrue: [eachSelector := selectors at: index + 1].
		each -> eachSelector.
	].
	^list
%

category: 'Accessing'
method: RowanMethodService
testResult

	^testResult
%

category: 'updates'
method: RowanMethodService
update
	
	self isUnboundMethod ifFalse:[
		self wasRecycled ifTrue:[oop := self gsNMethod asOop].
		self wasDeleted ifTrue:[
			self updateType: #methodsRemoved:. 
			^RowanCommandResult addResult: self. ].  "removed method"
		oop ifNil: [oop := self gsNMethod asOop]].
	self 
		initialize: (Object _objectForOop: oop) 
		organizer: ClassOrganizer new.
	RowanCommandResult addResult: self.
%

category: 'private'
method: RowanMethodService
updateSource: string

	source := self class removeUnicodeFromSource: string
%

category: 'testing'
method: RowanMethodService
wasDeleted
	selector isNil ifTrue:[^false].
	^self gsNMethod isNil
%

category: 'testing'
method: RowanMethodService
wasRecycled
	(oop notNil and:[self gsNMethod asOop ~= oop]) ifTrue:[^true].
	^false
%

! Class implementation for 'RowanPackageService'

!		Class methods for 'RowanPackageService'

category: 'instance creation'
classmethod: RowanPackageService
forPackageNamed: aName

	| inst |
	inst := self new.  
	inst name: aName.
	aName isNil ifFalse:[
		inst isDirty. "lazy initialize"].
	inst setDefaultTemplate. 
	inst updateProjectName.
	^inst
%

!		Instance methods for 'RowanPackageService'

category: 'comparing'
method: RowanPackageService
= packageService
	(packageService isKindOf: RowanPackageService) ifFalse:[^false].
	^name = packageService name
%

category: 'testing'
method: RowanPackageService
arePackageAndProjectClean

	^self rowanDirty not and:[self projectIsDirty not]
%

category: 'rowan'
method: RowanPackageService
changes
   "diffForPackageName: not implemented yet"
 
   ^ (Rowan packageTools diff diffForPackageName: name) asString
%

category: 'client commands'
method: RowanPackageService
classHierarchy
	| superclassChains levels services hierarchies theClasses toExpand |
	self update. 
	theClasses := classes collect:[:classService | classService theClass].
	superclassChains := self superclassChainsFor: theClasses. 
	hierarchies := self extendHierarchies: superclassChains. 
	levels := self hierarchiesByLevel: hierarchies.
	services := Dictionary new. 
	toExpand := Set new. 
	self services: services from: levels expand: toExpand.
	hierarchyServices := services reject:[:array | array isEmpty].
	hierarchyServices copy keysAndValuesDo:[:key :value | 
		hierarchyServices at: key put: (value asSet asSortedCollection:[:x :y | x name < y name]) asArray].
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanPackageService
compileClass: definitionString

	|  anonymousMethod |
	anonymousMethod := definitionString _compileInContext: nil 
       symbolList: GsSession currentSession symbolList.
	UserGlobals at: #jadeiteCompileClassMethod put: anonymousMethod.
%

category: 'rowan'
method: RowanPackageService
createPackage
	| projectService default |
	default := RowanProjectService defaultProjectName.
	projectService := RowanProjectService new.
	projectService createProjectNamed: default.  
	(Rowan packageNames includes: name) ifFalse:[
		self browserTool addPackageNamed: name toProjectNamed: default].
%

category: 'rowan'
method: RowanPackageService
createPackageNamed: aString inProject: projName
	| projectService | 
	name := aString.
	projectService := RowanProjectService new.
	projectDefinition := projectService createProjectNamed: projName.  
	projectDefinition addPackageNamed: name.
	self projectTools load loadProjectDefinition: projectDefinition.
%

category: 'Updating'
method: RowanPackageService
defaultTemplate: newValue
	defaultTemplate := newValue
%

category: 'rowan'
method: RowanPackageService
definition

	^(Rowan image loadedPackageNamed: name) asDefinition
%

category: 'rowan'
method: RowanPackageService
deletePackage

	self browserTool removePackageNamed: name.
%

category: 'commands support'
method: RowanPackageService
extendHierarchies: hierarchies
	
	"extend the hierarchies by one level
	of subclasses"

	| extendedHierarchies |
	extendedHierarchies := Array new. 
	hierarchies do:[:hierarchy |
		| theClass |
		theClass := hierarchy last. 
		theClass subclasses isEmpty 
			ifTrue:[extendedHierarchies add: hierarchy]
			ifFalse:[
				theClass subclasses do:[:sub |
					extendedHierarchies add: (hierarchy copy add: sub; yourself)
				]]].
	^extendedHierarchies
%

category: 'rowan'
method: RowanPackageService
genericClassCreationTemplate

	^self browserTool classCreationTemplateForSubclassOf: 'Object' category: name packageName: nil
%

category: 'comparing'
method: RowanPackageService
hash
	^self name hash
%

category: 'commands support'
method: RowanPackageService
hierarchiesByLevel: hierarchies

	"Return dictionary of classes by level. 
	Example: 
		hierarchies - #(#(Object Collection Array) #(Object AbstractException Exception))
	Return: 
		#(#nil->#(Object) Object->#(Collection AbstractException) Collection->#(Array) AbstractException->#(Exception)
	"
	| levels |
	levels := hierarchies inject: Dictionary new into:[:dict :chain | 
		1 to: chain size do: [:index | 
			| cls theSuper classSet |
			cls := chain at: index.
			classSet := dict at: cls ifAbsentPut: [Array new].
			index = 1 
		ifTrue:[
			classSet := dict at: #'nil' ifAbsentPut: [Array new]. 
			((dict at: #'nil') includes: cls) ifFalse:[(dict at: #'nil') add: cls].
		]
		ifFalse:[
				theSuper := chain at: index - 1.
				((dict at: theSuper) includes: cls) ifFalse:[(dict at: theSuper) add: cls]
				]].
			dict].
	^levels
%

category: 'Accessing'
method: RowanPackageService
hierarchyServices

	^hierarchyServices
%

category: 'rowan'
method: RowanPackageService
isDirty

	^isDirty := self rowanDirty
%

category: 'Updating'
method: RowanPackageService
isDirty: boolean

	isDirty := boolean
%

category: 'Accessing'
method: RowanPackageService
jadeite_testClasses

	"for testing" 
	^testClasses
%

category: 'rowan'
method: RowanPackageService
loadedClasses

	| loadedPackage |
	loadedPackage := Rowan image loadedPackageNamed: name ifAbsent:[^KeyValueDictionary new].
	^loadedPackage loadedClasses
%

category: 'rowan'
method: RowanPackageService
loadedClassExtensions

	| loadedPackage |
	loadedPackage := Rowan image loadedPackageNamed: name ifAbsent:[^KeyValueDictionary new].
	^loadedPackage loadedClassExtensions
%

category: 'rowan'
method: RowanPackageService
loadedClassHandles
	| loadedClasses |
	loadedClasses := self loadedClasses collect:[:loadedClass | loadedClass handle].
	loadedClasses addAll: (self loadedClassExtensions collect:[:extension | extension handle]).
	^loadedClasses
%

category: 'rowan'
method: RowanPackageService
loadedClassNames

	^self loadedClasses collect:[:loadedClass | loadedClass name]
%

category: 'Accessing'
method: RowanPackageService
name
	^name
%

category: 'Updating'
method: RowanPackageService
name: newValue
	name := newValue
%

category: 'Accessing'
method: RowanPackageService
packageName
	^name
%

category: 'Updating'
method: RowanPackageService
packageName: newValue
	name := newValue
%

category: 'printing'
method: RowanPackageService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $:. 
	aStream nextPutAll: (name ifNil: [nil printString])
%

category: 'Accessing'
method: RowanPackageService
projectDefinition
	^projectDefinition
%

category: 'Updating'
method: RowanPackageService
projectDefinition: newValue
	projectDefinition := newValue
%

category: 'testing'
method: RowanPackageService
projectIsDirty

	^(RowanProjectService new name: projectName) rowanDirty
%

category: 'Accessing'
method: RowanPackageService
projectName
	^projectName
%

category: 'Updating'
method: RowanPackageService
projectName: newValue
	projectName := newValue
%

category: 'client commands'
method: RowanPackageService
recompileMethodsAfterClassCompilation

	"compileClass: must be run first"
	| theClass classService packageService |

	theClass := [(UserGlobals at: #jadeiteCompileClassMethod) _executeInContext: nil] 
		ensure: [UserGlobals at: #jadeiteCompileClassMethod put: nil].
	classService := RowanClassService new name: theClass name. 
	classService update. 
	classService isNewClass: true.
	classService packageName = name 
		ifTrue:[
			self selectedClass: classService
		]
		ifFalse:[
			packageService := RowanPackageService forPackageNamed: classService packageName. 
			packageService update. 
			packageService selectedClass: classService].
	RowanCommandResult addResult: classService.
%

category: 'client commands'
method: RowanPackageService
removeClass: classService
	self removeClassNamed: classService name. 
	self setDefaultTemplate.
	classService updateType: #removedClass:.
	RowanCommandResult addResult: classService
%

category: 'client commands'
method: RowanPackageService
removeClassNamed: className

	self browserTool removeClassNamed: className.
%

category: 'rowan'
method: RowanPackageService
rowanDirty

	^(RwPackage newNamed: name) isDirty
%

category: 'rowan'
method: RowanPackageService
rowanProjectName

	^projectName
%

category: 'other'
method: RowanPackageService
selectedClass
	
	^selectedClass
%

category: 'Accessing'
method: RowanPackageService
selectedClass: classService
	selectedClass := classService.
	classService selectedPackageServices: (Array with: self)
%

category: 'perform'
method: RowanPackageService
servicePerform: symbol withArguments: collection
	| wasClean |
	wasClean := self arePackageAndProjectClean.
	super servicePerform: symbol withArguments: collection.
	self update. 
	wasClean ifTrue:[
		self updateProject]
%

category: 'commands support'
method: RowanPackageService
services: services from: levels expand: toExpand

	(classes collect:[:svc | svc theClass]) do:[:aClass |
		toExpand addAll: aClass allSuperclasses].
	levels keysAndValuesDo: [:key :value |
		| newKey service  | 
		newKey := key = #'nil' ifTrue:[#'nil'] ifFalse:[
			service := (RowanClassService new classServiceFromOop: key asOop).
			(toExpand includes: service theClass) ifTrue:[service expand: true] ifFalse:[service expand: false].
			service].
		services at: newKey put: (value collect:[:cls | 
				service := (RowanClassService new classServiceFromOop: cls asOop).
				(toExpand includes: service theClass) ifTrue:[service expand: true] ifFalse:[service expand: false].
				service
				])]
%

category: 'client commands'
method: RowanPackageService
setDefaultTemplate

	defaultTemplate := self genericClassCreationTemplate.
%

category: 'commands support'
method: RowanPackageService
superclassChainsFor: behaviors

	^behaviors collect:[:behavior | | supers |
			supers := behavior allSuperclasses. 
			supers add: behavior. 
			supers].
%

category: 'client commands'
method: RowanPackageService
testClasses

	testClasses := Set new. 
	TestCase allSubclasses do:[:testSubclass |
		testSubclass isAbstract ifFalse:[
			testSubclass suite tests do:[:testClassInstance |
				| implementingClass |
				implementingClass := testClassInstance class whichClassIncludesSelector: testClassInstance selector. 
				(implementingClass compiledMethodAt: testClassInstance selector) rowanPackageName = name ifTrue:[
					| classService |
					classService := RowanClassService basicForClassNamed: testSubclass name.
					testClasses detect:[:testClassService | testClassService name = classService name] ifNone:[
					(self loadedClassExtensions keys asArray includes: classService name) ifFalse:[
							"don't include extension classes"
							testClasses add: classService]]]]]]. 
	updateType := #testClasses:. 
	testClasses := testClasses asArray. 
	RowanCommandResult addResult: self.
%

category: 'updates'
method: RowanPackageService
update
	Rowan image loadedPackageNamed: name ifAbsent: [^self]. 
	classes := (self loadedClassNames keys collect:[:string | RowanClassService minimalForClassNamed: string]) asArray.
	classes addAll: (self loadedClassExtensions keys collect:[:string | 
		| classService | 
		classService := (RowanClassService minimalForClassNamed: string) 
			isExtension: true.
		(Rowan image loadedClassForClass: classService theClass ifAbsent:[]) 
			ifNotNil:[:cls | classService definedPackageName: cls packageName].
		classService]).
	classes do: [:clsService | clsService packageName: self name]. 
	self isDirty. 
	projectName := (Rowan image loadedPackageNamed: name) projectName.
	RowanCommandResult addResult: self
%

category: 'updates'
method: RowanPackageService
updateInternalService: updatedService

	"when sending services back to the client,
	verify any services held by this object are 
	updated. Services know what internal services
	they contain." 

	1 to: classes size do:[:index |
		| classesService |
		classesService := classes at: index. 
		classesService = updatedService ifTrue:[
			classes at: index put: updatedService
		]].
%

category: 'updates'
method: RowanPackageService
updateProject
	| projectService |

	projectService := RowanProjectService new name: projectName. 
	projectService update.
	RowanCommandResult addResult: projectService.
%

category: 'updates'
method: RowanPackageService
updateProjectName

	projectName := (Rowan image loadedPackageNamed: name) projectName.
%

category: 'testing'
method: RowanPackageService
wasDeleted

	^(Rowan image loadedPackageNamed: name
			ifAbsent: []) isNil
%

! Class implementation for 'RowanProcessService'

!		Class methods for 'RowanProcessService'

category: 'other'
classmethod: RowanProcessService
new

	self error: 'Use on*Process: constructors'.
%

category: 'other'
classmethod: RowanProcessService
onActiveProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'active';
		yourself
%

category: 'other'
classmethod: RowanProcessService
onReadyProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'ready';
		yourself
%

category: 'other'
classmethod: RowanProcessService
onSuspendedProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'suspended';
		yourself
%

category: 'other'
classmethod: RowanProcessService
onWaitingProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'waiting';
		yourself
%

!		Instance methods for 'RowanProcessService'

category: 'initialize'
method: RowanProcessService
initialize: aGsProcess status: aString

	| theOrganizer |
	theOrganizer := ClassOrganizer new. 
	frames := Array new: aGsProcess stackDepth.
	1 to: aGsProcess stackDepth do: [:i | 
		frames at: i put: (RowanFrameService process: aGsProcess level: i organizer: theOrganizer).
	].
	oop := aGsProcess asOop.  
	status := aString.
%

! Class implementation for 'RowanProjectService'

!		Class methods for 'RowanProjectService'

category: 'accessing'
classmethod: RowanProjectService
defaultProjectName

	^RowanServicePreferences current defaultProjectName
%

category: 'accessing'
classmethod: RowanProjectService
defaultProjectName: aString

	RowanServicePreferences current defaultProjectName: aString
%

category: 'instance creation'
classmethod: RowanProjectService
newNamed: aString

	| inst |
	inst := self new.
	inst name: aString.
	inst refresh.
	^inst
%

!		Instance methods for 'RowanProjectService'

category: 'comparing'
method: RowanProjectService
= projectService
	^projectService isProjectService ifTrue: [name = projectService name] ifFalse: [^false]
%

category: 'client commands'
method: RowanProjectService
addPackageNamed: packageName

	Rowan image loadedPackageNamed: packageName ifAbsent: [
		self browserTool addPackageNamed: packageName toProjectNamed: name. 
		self update.
		^self answer: #added.].
	self answer: #duplicatePackage
%

category: 'initialization'
method: RowanProjectService
basicRefresh
	(isLoaded := self projectIsLoaded) ifFalse:[
		existsOnDisk := false. 
		updateType := #removedProject:. 
		^RowanCommandResult addResult: self]. 
	isDirty := self isDirty. 
	self setExistsOnDisk.
	isSkew := self isSkew.
	sha := self rowanSha.
	branch := self rowanBranch.
	projectUrl := self rowanProjectUrl. 
	rowanProjectsHome := System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME' .
	RowanCommandResult addResult: self
%

category: 'accessing'
method: RowanProjectService
branch

	name isNil ifTrue:[^String new].
	^(RwProject newNamed: name) currentBranchName
%

category: 'accessing'
method: RowanProjectService
branch: anObject

	branch := anObject
%

category: 'client commands'
method: RowanProjectService
changes

	| jadeServer |
	jadeServer := Rowan platform jadeServerClassNamed: #JadeServer. 
	changes := Array new. 
	(Rowan projectTools diff
		patchesForProjectNamed: 'Rowan') do: [:assoc | 
			"key is packageName, value is a CypressPatch"
			| patch |
			patch := assoc value.
			changes add:(jadeServer new
				_mcDescriptionOfPatch: patch
				baseName: 'closest ancestor'
				alternateName: nil) ].
	self refresh.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanProjectService
checkout: branchName

	| project branches |

	project := (RwProject newNamed: name). 
	branches := Rowan gitTools gitcheckoutIn: project repositoryRootPath asFileReference with: branchName.
	^branches
%

category: 'client commands'
method: RowanProjectService
commitWithMessage: message
	
	Rowan projectTools write writeProjectNamed: name.
	Rowan projectTools commit
		commitProjectNamed: name
		message: message.
%

category: 'examples'
method: RowanProjectService
createProjectNamed: projectName 

	^self createProjectNamed: projectName in: self sampleSymbolDictionaryName.
%

category: 'examples'
method: RowanProjectService
createProjectNamed: projectName in: symbolDictionaryName

	self rowanFixMe. "Dale doesn't like Rowan projectNames"
	(Rowan projectNames includes: projectName) ifFalse:[
		self browserTool createGitPackageProjectNamed: projectName updateDefinition: [:pd | 
				pd defaultSymbolDictName: symbolDictionaryName; comment:  'Sample Rowan Project'] ].
%

category: 'accessing'
method: RowanProjectService
defaultProjectName

	^self class defaultProjectName
%

category: 'accessing'
method: RowanProjectService
defaultProjectName: aString

	self class defaultProjectName: aString
%

category: 'accessing'
method: RowanProjectService
existsOnDisk

	^existsOnDisk
%

category: 'comparing'
method: RowanProjectService
hash
	^self name hash
%

category: 'initialization'
method: RowanProjectService
initialize

	super initialize. 
	packages := Array new
%

category: 'rowan'
method: RowanProjectService
isDirty

	name isNil ifTrue:[^false].
	^(RwProject newNamed: name) isDirty
%

category: 'accessing'
method: RowanProjectService
isDirty: aBoolean

	isDirty := aBoolean.
%

category: 'rowan'
method: RowanProjectService
isSkew
	| repositorySha |
	name isNil ifTrue:[^false].
	self existsOnDisk ifFalse:[^false]. 
	repositorySha := [self repositorySha] on: Error do:[:ex | repositorySha := 'not on disk'].
	^self sha ~= repositorySha
%

category: 'client commands'
method: RowanProjectService
loadProjectNamed: aName

	[Rowan projectTools load loadProjectNamed: aName] 
		on: Warning
		do: [ :ex | Transcript cr; show: ex description. ex resume ].
	RowanBrowserService new updateProjects.
%

category: 'rowan'
method: RowanProjectService
log

	^Rowan projectTools log
		commitLogProjectNamed: name
		limit: 25
%

category: 'accessing'
method: RowanProjectService
name

	^name
%

category: 'accessing'
method: RowanProjectService
name: anObject

	name := anObject
%

category: 'client commands'
method: RowanProjectService
newGitProject: url root: rootPath useSsh: useSsh
	"set useSsh to false to clone using https:"

	Rowan projectTools clone
		cloneSpecUrl: url
		gitRootPath: rootPath
		useSsh: useSsh.
	RowanBrowserService new updateProjects.
%

category: 'rowan'
method: RowanProjectService
packageNames
	"if no project is selected, return all package names"
	^name isNil ifTrue:[
		"list of visible packageNames for current user"
		Rowan image packageNames ]
	ifFalse:[
		"list of visible packageNames for current user and named project"
		Rowan image packageNamesForLoadedProjectNamed: name ]
%

category: 'rowan'
method: RowanProjectService
packageNameString
		"return a string showing the package names for a project"

	| ws packageNames |
	ws := WriteStream on: String new.
	ws
		nextPutAll: 'Packages for project: ' , name;
		cr.
	packageNames := Set new.
	packageNames addAll: (Rowan image loadedProjectNamed: name) packageNames.
	packageNames asSortedCollection do: 
			[:packageName |
			ws
				cr; 
				tab;
				nextPutAll: packageName
			].
	^ws contents
%

category: 'accessing'
method: RowanProjectService
packageServices

	^self packageNames collect:[:packageName | RowanPackageService forPackageNamed: packageName]
%

category: 'printing'
method: RowanProjectService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $:. 
	aStream nextPutAll: (name ifNil: [nil printString])
%

category: 'testing'
method: RowanProjectService
projectIsLoaded

	^(Rowan image
		loadedProjectNamed: name
		ifAbsent: []) notNil
%

category: 'rowan'
method: RowanProjectService
projects

		^Rowan projectNames collect: 
			[:string |
			| service |
			service := self class new name: string. 
			service 
				sha: service rowanSha;
				branch: service rowanBranch;
				isDirty: service rowanDirty]
%

category: 'accessing'
method: RowanProjectService
projectUrl

	^projectUrl
%

category: 'accessing'
method: RowanProjectService
projectUrl: anObject

	projectUrl := anObject
%

category: 'client commands'
method: RowanProjectService
pullFromGit

	| project |
	project := RwProject newNamed: name. 
	Rowan gitTools
		gitpullIn: project repositoryRootPath
		remote: project remote
		branch: project currentBranchName
%

category: 'client commands'
method: RowanProjectService
pushToGit

	| project |
	project := RwProject newNamed: name. 
	Rowan gitTools
		gitpushIn: project repositoryRootPath
		remote: project remote
		branch: project currentBranchName
%

category: 'initialization'
method: RowanProjectService
refresh
	self basicRefresh. 
	isLoaded ifTrue:[
		packages := self packageServices].
%

category: 'client commands'
method: RowanProjectService
reloadProject

	[Rowan projectTools load loadProjectNamed: name] 
		on: Warning
		do: [ :ex | Transcript cr; show: ex description. ex resume ]
%

category: 'rowan'
method: RowanProjectService
removeProjectNamed: projectName
   "remove project"
 
    (Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
      ifNotNil: [ :project | Rowan image _removeLoadedProject: project ]
%

category: 'rowan'
method: RowanProjectService
repositorySha

	^(RwProject newNamed: name) repositoryCommitId
%

category: 'rowan'
method: RowanProjectService
rowanBranch
	
	name isNil ifTrue:[^String new].
	^ [ (RwProject newNamed: name) currentBranchName ] on: Error do: [:ex | ^'ERROR getting repository branch' ]
%

category: 'rowan'
method: RowanProjectService
rowanDirty

	^(RwProject newNamed: name) isDirty
%

category: 'rowan'
method: RowanProjectService
rowanProjectName

	^name
%

category: 'rowan'
method: RowanProjectService
rowanProjectUrl

	^(RwProject newNamed: name) projectUrl
%

category: 'rowan'
method: RowanProjectService
rowanSha

	name isNil ifTrue:[^0].
	^(RwProject newNamed: name) loadedCommitId
%

category: 'rowan'
method: RowanProjectService
rowanSkew

	^self sha ~= self repositorySha
%

category: 'perform'
method: RowanProjectService
servicePerform: symbol withArguments: collection
	super servicePerform: symbol withArguments: collection.
	self update.
%

category: 'client commands'
method: RowanProjectService
setDefaultProject

	self class defaultProjectName: name
%

category: 'rowan'
method: RowanProjectService
setExistsOnDisk
	"might be a better test than #repositorySha for
	determining if a project exists on disk." 

	existsOnDisk := (RwProject newNamed: name) existsOnDisk.
%

category: 'accessing'
method: RowanProjectService
sha

	name isNil ifTrue:[^0].
	^(RwProject newNamed: name) loadedCommitId
%

category: 'accessing'
method: RowanProjectService
sha: anObject

	"because skew is intimately associated with sha
	set it here" 
	sha := anObject.
	isSkew := self rowanSkew
%

category: 'rowan'
method: RowanProjectService
unload

	| loadedProject |
	loadedProject := Rowan image loadedProjects select:[:proj | proj name = name].
%

category: 'update'
method: RowanProjectService
update
	self refresh.
%

category: 'update'
method: RowanProjectService
updateInternalService: updatedService

	"when sending services back to the client,
	verify any services held by this object are 
	updated. Services know what internal services
	they contain." 

	1 to: packages size do:[:index |
		| packageService |
		packageService := packages at: index. 
		packageService = updatedService ifTrue:[
			packages at: index put: updatedService
		]].
%

category: 'client commands'
method: RowanProjectService
write
	Rowan projectTools write writeProjectNamed: name
%

category: 'accessing'
method: RowanProjectService
_isSkew

	^isSkew
%

! Class implementation for 'RowanQueryService'

!		Instance methods for 'RowanQueryService'

category: 'queries'
method: RowanQueryService
browseClassReferences: className

	| methods |
	methods := organizer referencesTo: className asSymbol.
	queryResults := self methodServicesFrom: methods first.
	self returnQueryToClient.
%

category: 'private'
method: RowanQueryService
defaultProjectLogSize

	^100
%

category: 'queries'
method: RowanQueryService
hierarchyImplementorsOf: selector inClass: className

	| methods behavior classes |
	behavior := Rowan globalNamed: className.
	classes := behavior allSuperclasses. 
	classes add: behavior. 
	classes addAll: (organizer allSubclassesOf: behavior). 
	methods := organizer implementorsOf: selector in: classes.
	queryResults := self methodServicesFrom: methods.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
hierarchySendersOf: selector inClass: className

	| methods behavior classes |
	behavior := Rowan globalNamed: className.
	classes := behavior allSuperclasses. 
	classes add: behavior. 
	classes addAll: (organizer allSubclassesOf: behavior). 
	methods := organizer sendersOf: selector in: classes.
	queryResults := self methodServicesFrom: methods first.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
implementorsOf: selector

	| methods |
	methods := organizer implementorsOf: selector asSymbol.
	queryResults := self methodServicesFrom: methods.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
literalReferences: symbol

	| methods |
	methods := organizer referencesToLiteral: symbol.
	queryResults := self methodServicesFrom: methods first.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
methodsContaining: string

	| methods |
	methods := organizer substringSearch: string.
	queryResults := self methodServicesFrom: methods first.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
methodServicesFrom: methods

	| sorted | 
	sorted := SortedCollection sortBlock: [:x :y | x className = y className ifTrue:[x selector < y selector] ifFalse:[x className < y className]].
	sorted addAll: (methods collect:[:gsNMethod | 
			RowanMethodService forSelector: gsNMethod selector class: gsNMethod inClass thisClass meta: gsNMethod inClass isMeta organizer: organizer]).
	^sorted asArray
%

category: 'queries'
method: RowanQueryService
projectBranches: projectName

	| project  |
	project := (RwProject newNamed: projectName). 
	queryResults := Rowan gitTools gitbranchIn: project repositoryRootPath with: ''.
	RowanCommandResult addResult: self
%

category: 'queries'
method: RowanQueryService
projectLog: projectName

	queryResults := 
		(Rowan projectTools log
		commitLogProjectNamed: projectName
		limit: self defaultProjectLogSize).
	RowanCommandResult addResult: self.
%

category: 'queryResults'
method: RowanQueryService
queryResults

	"for tests. So far, not needed on server." 

	^queryResults
%

category: 'private'
method: RowanQueryService
returnQueryToClient

	queryResults do:[:service |
		RowanCommandResult addResult: service].
	RowanCommandResult addResult: self.
%

category: 'queries'
method: RowanQueryService
sendersOf: selector

	| methods |
	methods := organizer sendersOf: selector asSymbol.
	queryResults := self methodServicesFrom: methods first.
	self returnQueryToClient.
%

category: 'ston'
method: RowanQueryService
stonOn: stonWriter   
	| instanceVariableNames |
	instanceVariableNames := self class allInstVarNames reject: [:iv | self excludedInstVars includes: iv].
	stonWriter writeObject: self
		streamMap: 
			[:dictionary |
			instanceVariableNames do: 
					[:each |
					(self instVarAt: (self class allInstVarNames indexOf: each asSymbol))
						ifNotNil: [:value | dictionary at: each asSymbol put: value]
						ifNil: [self stonShouldWriteNilInstVars ifTrue: [dictionary at: each asSymbol put: nil]]]]
%

category: 'update'
method: RowanQueryService
updateInternalService: updatedService

	"when sending services back to the client,
	verify any services held by this object are 
	updated. Services know what internal services
	they contain." 
	1 to: queryResults size do:[:index |
		| service |
		service := queryResults at: index. 
		service = updatedService ifTrue:[ 
			queryResults at: index put: updatedService
		]].
%

! Class implementation for 'RowanTestService'

!		Instance methods for 'RowanTestService'

category: 'command'
method: RowanTestService
createNewTestProjectNamed: projectName

	| proj |
	proj := RwProjectDefinition newForGitBasedProjectNamed: projectName.
	proj repositoryRootPath: '$ROWAN_PROJECTS_HOME/', projectName.
	Rowan projectTools create createProjectFor: proj.
	Rowan projectTools load loadProjectDefinition: proj.
	^proj
%

! Class implementation for 'RowanVariableService'

!		Class methods for 'RowanVariableService'

category: 'other'
classmethod: RowanVariableService
oop: anInteger key: nameString value: valueString className: classNameString

	^self basicNew
		oop: anInteger key: nameString value: valueString className: classNameString;
		yourself
%

!		Instance methods for 'RowanVariableService'

category: 'other'
method: RowanVariableService
oop: anInteger key: nameString value: valueString className: classNameString

	oop := anInteger.
	key := nameString.
	value := valueString.
	className := classNameString.
%

! Class implementation for 'RowanServicePreferences'

!		Class methods for 'RowanServicePreferences'

category: 'accessing'
classmethod: RowanServicePreferences
current
	^(RwPlatform _userPlatformDictionary) 
		at: #RowanServicePrefs 
		ifAbsentPut: [ self new ]
%

!		Instance methods for 'RowanServicePreferences'

category: 'accessing'
method: RowanServicePreferences
defaultProjectName

	^defaultProjectName
%

category: 'accessing'
method: RowanServicePreferences
defaultProjectName: aString

	defaultProjectName := aString
%

! Class implementation for 'RwAbstractConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwAbstractConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwAbstractConfigurationPlatformAttributeMatcher
match: anObject

	self subclassResponsibility: #match:
%

category: 'matching'
method: RwAbstractConfigurationPlatformAttributeMatcher
matchString: aString

	self subclassResponsibility: #matchString:
%

category: 'matching'
method: RwAbstractConfigurationPlatformAttributeMatcher
matchVersion: anRwGemStoneVersionNumber

	self subclassResponsibility: #matchVersion:
%

category: 'accessing'
method: RwAbstractConfigurationPlatformAttributeMatcher
pattern: anObject
	pattern := anObject
%

category: 'accessing'
method: RwAbstractConfigurationPlatformAttributeMatcher
patternMatchBlock: aBlock
	patternMatchBlock := aBlock
%

! Class implementation for 'RwGemStoneVersionConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwGemStoneVersionConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwGemStoneVersionConfigurationPlatformAttributeMatcher
match: anObject

	^ anObject rwPlatformAttributeMatchForGemStoneVersion: self
%

category: 'matching'
method: RwGemStoneVersionConfigurationPlatformAttributeMatcher
matchString: aString

	^ false
%

category: 'matching'
method: RwGemStoneVersionConfigurationPlatformAttributeMatcher
matchVersion: aGemStoneVersion

	^ patternMatchBlock cull: pattern cull: aGemStoneVersion
%

! Class implementation for 'RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
matchVersion: aGemStoneVersion

	^ patternMatchBlock cull: pattern cull: aGemStoneVersion cull: pattern2
%

category: 'accessing'
method: RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
pattern2: anObject
	pattern2 := anObject
%

! Class implementation for 'RwStringConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwStringConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwStringConfigurationPlatformAttributeMatcher
match: anObject

	^ anObject rwPlatformAttributeMatchForString: self
%

category: 'matching'
method: RwStringConfigurationPlatformAttributeMatcher
matchString: aString

	^ patternMatchBlock cull: pattern cull: aString
%

category: 'matching'
method: RwStringConfigurationPlatformAttributeMatcher
matchVersion: aGemStoneVersion

	^ false
%

! Class implementation for 'RwAbstractProjectConfiguration'

!		Class methods for 'RwAbstractProjectConfiguration'

category: 'instance creation'
classmethod: RwAbstractProjectConfiguration
fromUrl: specNameOrUrl

	"self fromUrl: 'file:/home/dhenrich/rogue/_homes/rogue/_home/shared/repos/RowanSample1/configs/Default.ston'"

	| url |
	url := specNameOrUrl asRwUrl.
	url scheme isNil
		ifTrue: [ self error: 'scheme must be file: or https:' ].
	url scheme = 'file'
		ifTrue: [ 
			CypressFileUtilities current
				readStreamFor: url fileName
				in: url pathForDirectory
				do: [ :stream | ^ self _readStonFrom: stream ] ].
	url scheme asString = 'https'
		ifTrue: [ 
			| client response |
			GsSecureSocket disableCertificateVerificationOnClient.
			client := (Rowan globalNamed: 'ZnClient') new.
			response := client
				beOneShot;
				enforceHttpSuccess: true;
				get: url.
			^ self _readStonFrom: response decodeFromUTF8 ].
	self error: 'Unknown scheme: ' , url scheme printString
%

category: 'instance creation'
classmethod: RwAbstractProjectConfiguration
new

	^self basicNew initialize
%

category: 'instance creation'
classmethod: RwAbstractProjectConfiguration
newNamed: aName for: projectName

	^ self new
		name: aName;
		projectName: projectName;
		yourself
%

category: 'private'
classmethod: RwAbstractProjectConfiguration
_readStonFrom: stream

	| reader | 
	(reader := STONReader on: stream)
		allowComplexMapKeys: true.
	^reader next
		initializeForImport;
		yourself
%

!		Instance methods for 'RwAbstractProjectConfiguration'

category: 'visiting'
method: RwAbstractProjectConfiguration
acceptCompoundVisitor: aVisitor

	^ self subclassResponsibility: #acceptCompoundVisitor:
%

category: 'visiting'
method: RwAbstractProjectConfiguration
acceptNestedVisitor: aVisitor

	^ self acceptVisitor: aVisitor
%

category: 'visiting'
method: RwAbstractProjectConfiguration
acceptVisitor: aVisitor

	^ self subclassResponsibility: #acceptVisitor:
%

category: 'accessing'
method: RwAbstractProjectConfiguration
comment

   ^comment
%

category: 'initialization'
method: RwAbstractProjectConfiguration
comment: anObject

   comment := anObject
%

category: 'accessing'
method: RwAbstractProjectConfiguration
configurationNames

   ^ configurationNames ifNil: [ Array new ]
%

category: 'accessing'
method: RwAbstractProjectConfiguration
configurationNames: anObject

   configurationNames := anObject
%

category: 'private'
method: RwAbstractProjectConfiguration
currentVersion

	"
		0.1.0 - initial version for specs
	"

	"concrete subclasses, will override as needed"

	^ '0.1.0'
%

category: 'exporting'
method: RwAbstractProjectConfiguration
export

	|  exportUrl exportPath |
	exportPath := self _repositoryRootPath asFileReference / self _configsPath.
	exportPath ensureCreateDirectory.
	exportUrl := exportPath fileSystem isMemoryFileSystem
		ifTrue: [ 'memory:' , exportPath pathString ]
		ifFalse: [ 'file:' , exportPath pathString, '/' ].
	^ self exportToUrl: exportUrl
%

category: 'exporting'
method: RwAbstractProjectConfiguration
exportToUrl: fileUrl

	^ self copy
		initializeForExport
		_exportToUrl: fileUrl
%

category: 'initialization'
method: RwAbstractProjectConfiguration
initialize

	comment := ''.
	version := self currentVersion.
%

category: 'initialization'
method: RwAbstractProjectConfiguration
initializeForExport

	"if spec is to be exported, clear out any of the fields that represent state that should 
	not be shared"

	projectName := nil
%

category: 'initialization'
method: RwAbstractProjectConfiguration
initializeForImport

	"if spec has been imported, clear out any of the fields that represent state that should 
	not be shared"

	projectName := nil
%

category: 'testing'
method: RwAbstractProjectConfiguration
isIndependentlyLoadable
	
	^ true
%

category: 'accessing'
method: RwAbstractProjectConfiguration
name

   ^name
%

category: 'initialization'
method: RwAbstractProjectConfiguration
name: anObject

   name := anObject
%

category: 'accessing'
method: RwAbstractProjectConfiguration
projectName

   ^projectName
%

category: 'initialization'
method: RwAbstractProjectConfiguration
projectName: anObject

   projectName := anObject
%

category: 'load support'
method: RwAbstractProjectConfiguration
resolvePackageNames

	"return the list of package names that is the result of resolving all of the receiver's references"

	self subclassResponsibility: #'resolvePackageNames'
%

category: 'load support'
method: RwAbstractProjectConfiguration
resolvePackageNames: visitedConfigurationNames

	"return the list of package names that is the result of resolving all of the receiver's references.
		Do not visit configurations already listed in visitedConfigurationNames "

	self subclassResponsibility: #'resolvePackageNames:'
%

category: 'accessing'
method: RwAbstractProjectConfiguration
version
	"answer the version of the class --- used to mark the version of the class for objects written to disk"

	"see currentVersion method for list of versions"

	^ version
%

category: 'accessing'
method: RwAbstractProjectConfiguration
version: aString

	self error: 'Do not use version: ... the version should only be set when read from disk using STON'
%

category: 'private'
method: RwAbstractProjectConfiguration
_configsPath

	^ self _specification configsPath
%

category: 'exporting'
method: RwAbstractProjectConfiguration
_exportToUrl: fileUrl

	| url |
	url := fileUrl asRwUrl.
	url schemeName = 'file'
		ifTrue: [ 
			Rowan fileUtilities
				writeStreamFor: self name , '.ston'
				in: url pathForDirectory
				do: [ :stream | 
					| string |
					string := STON toStringPretty: self.
					stream nextPutAll: string.
					^ self ] ].
  url schemeName = 'memory'
    ifTrue: [ 
		(FileSystem currentMemoryFileSystem workingDirectory / url pathForDirectory / self name , 'ston')
			writeStreamDo: [ :stream | 
			  | string |
			  string := STON toStringPretty: self.
			  stream nextPutAll: string.
			  ^ self ] ].
	^ nil	"otherwise a noop"
%

category: 'private'
method: RwAbstractProjectConfiguration
_loadedProject

	^ Rowan image loadedProjectNamed: self projectName
%

category: 'private'
method: RwAbstractProjectConfiguration
_repositoryRootPath

	^ self _specification repositoryRootPath
%

category: 'private'
method: RwAbstractProjectConfiguration
_repositoryUrl

	^ self _specification repositoryUrl
%

category: 'private'
method: RwAbstractProjectConfiguration
_specification

	^ self _loadedProject specification
%

! Class implementation for 'RwAbstractProjectLoadConfiguration'

!		Instance methods for 'RwAbstractProjectLoadConfiguration'

category: 'visiting'
method: RwAbstractProjectLoadConfiguration
acceptCompoundVisitor: aVisitor

	self error: 'project load configurations may not be nested inside of compound configurations'
%

category: 'private'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecMatchers

	conditionalPackageMapSpecMatchers ifNotNil: [:val | ^ val ]. 
	conditionalPackageMapSpecMatchers := Dictionary new.
	self conditionalPackageMapSpecs keysAndValuesDo: [:platformPattern :packageMapSpecsMap |
		conditionalPackageMapSpecMatchers
			at: (self _platformPatternMatcherFor: platformPattern)
			put: packageMapSpecsMap ].
	^ conditionalPackageMapSpecMatchers
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecs

	^ conditionalPackageMapSpecs ifNil: [ conditionalPackageMapSpecs := Dictionary new ]
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecsAtGemStoneUserId: userId 

	^ ((self conditionalPackageMapSpecs at: 'gemstone' ifAbsent: [ ^ Dictionary new ])
		at: userId ifAbsent: [ ^ Dictionary new ])
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecsAtGemStoneUserId: userId andPackageName: packageName

	^ (((self conditionalPackageMapSpecs at: 'gemstone' ifAbsent: [ ^ Dictionary new ])
		at: userId ifAbsentPut: [ ^ Dictionary new ])
			at: #packageNameToPlatformPropertiesMap ifAbsent: [ ^ Dictionary new ])
				at: packageName ifAbsent: [ ^ Dictionary new ]
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecsAtGemStoneUserId: userId andPackageName: packageName setSymbolDictNameTo: symbolDictName

	((((self conditionalPackageMapSpecs at: 'gemstone' ifAbsentPut: [ Dictionary new ])
		at: userId ifAbsentPut: [ Dictionary new ])
			at: #packageNameToPlatformPropertiesMap ifAbsentPut: [ Dictionary new ])
				at: packageName ifAbsentPut: [ Dictionary new ])
					at: 'symbolDictName' put: symbolDictName asString
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecsAtGemStoneUserId: userId setDefaultSymbolDictNameTo: defaultSymbolDictName

	((self conditionalPackageMapSpecs at: 'gemstone' ifAbsentPut: [ Dictionary new ])
		at: userId ifAbsentPut: [ Dictionary new ])
			at: #defaultSymbolDictName put: defaultSymbolDictName asString
%

category: 'private'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMatchers

	conditionalPackageMatchers ifNotNil: [:val | ^ val ]. 
	conditionalPackageMatchers := Dictionary new.
	self conditionalPackages keysAndValuesDo: [:platformPatterns :groupMap |
		conditionalPackageMatchers
			at: (platformPatterns collect: [:pattern | self _platformPatternMatcherFor: pattern ])
			put: groupMap ].
	^ conditionalPackageMatchers
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackages

	^ conditionalPackages ifNil: [ conditionalPackages := Dictionary new ]
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackagesAtConditions: conditions andGroup: groupName

	| thePackageNameMap |
	thePackageNameMap := (self conditionalPackages at: conditions asArray sort ifAbsent: [ ^ Set new])
		at: groupName ifAbsent: [ ^ Set new ].
	^ (thePackageNameMap at: #packageNames ifAbsent: [ Set new ]) asSet
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackagesAtConditions: conditions andGroup: groupName addPackageNames: packageNames

	| thePackageNames thePackageNameMap |
	thePackageNameMap := (self conditionalPackages at: conditions asArray sort ifAbsentPut: [ Dictionary new])
		at: groupName ifAbsentPut: [ Dictionary new ].
	thePackageNames := (thePackageNameMap at: #packageNames ifAbsentPut: [ Set new ]) asSet.
	thePackageNames addAll: packageNames.
	thePackageNameMap at: #packageNames put: thePackageNames asArray sort
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
definedGroupNames
	"Empty list by default"

	^ #()
%

category: 'initialization'
method: RwAbstractProjectLoadConfiguration
initializeForExport

	"if spec is to be exported, clear out any of the fields that represent state that should 
	not be shared"

	super initializeForExport.
	conditionalPackageMatchers :=  conditionalPackageMapSpecMatchers := nil
%

category: 'private'
method: RwAbstractProjectLoadConfiguration
_platformPatternMatcherFor: pattern

	" Returns an instance of RwAbstractConfigurationPlatformAttributeMatcher:
		RwStringConfigurationPlatformAttributeMatcher,
		RwGemStoneVersionConfigurationPlatformAttributeMatcher,
		or RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
	"

	| versionPattern gsVersion1 gsVersion2 |
	(pattern beginsWith: 'gs')
		ifFalse: [ 
			"simple equality match"
			^ RwStringConfigurationPlatformAttributeMatcher new
					pattern: pattern;
					patternMatchBlock: [:a :b | a = b ];
					yourself ].
	"GemStone version pattern"
	versionPattern := (pattern copyFrom: 3 to: pattern size) substrings: '.'.
	(versionPattern last beginsWith: '[')
		ifTrue: [ 
			| vpSize rangePattern dashIndex |
			"range pattern"
			vpSize := versionPattern size.
			gsVersion1 := RwGemStoneVersionNumber new: vpSize .
			1 to: vpSize - 1
				do: [:index | gsVersion1 at: index put: (versionPattern at: index) asInteger ].
			gsVersion1 at: vpSize put: 0.
			rangePattern := (versionPattern at: vpSize) trimBoth.
			(((rangePattern at: 1) = $[) and: [ (rangePattern at: rangePattern size) = $] ])
				ifFalse: [ self error: 'Poorly formed GemStone version range pattern ', rangePattern printString, ' in ', pattern printString ].
			rangePattern := rangePattern copyFrom: 2 to: rangePattern size -1.
			dashIndex := rangePattern indexOf: $-.
			dashIndex <= 1
				ifTrue: [ self error: 'Invalid version range pattern missing range begin' , rangePattern printString, ' in ', pattern printString ].
			gsVersion1 at: vpSize put: (rangePattern copyFrom: 1 to: dashIndex -1) asInteger.
			dashIndex = rangePattern size
				ifTrue: [
					"open range"
					gsVersion2 := gsVersion1 copyFrom: 1 to: gsVersion1 size -1.
					gsVersion2 at: gsVersion2 size put: (gsVersion2 at: gsVersion2 size) + 1.
					^ RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher new
							pattern: gsVersion1;
							pattern2: gsVersion2;
							patternMatchBlock: [:a :b :c | (a <= b) & (b < c ) ];
							yourself ].
			"closed range"
			gsVersion2 := gsVersion1 copy.
			gsVersion2 at: vpSize put: (rangePattern copyFrom: dashIndex + 1 to: rangePattern size) asInteger.
			^ RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher new
					pattern: gsVersion1;
					pattern2: gsVersion2;
					patternMatchBlock: [:a :b :c | (a <= b) & (b <= c ) ];
					yourself ].
	versionPattern last = 'x' 
		ifFalse: [
			"specific version number match, use ="
			^ RwGemStoneVersionConfigurationPlatformAttributeMatcher new
					pattern: (pattern copyFrom: 3 to: pattern size) asRwGemStoneVersionNumber;
					patternMatchBlock: [:a :b | a = b ];
					yourself ].
	" 'gs', <gemstone-version-number> , '.x'"
	"match all values in x field"
	gsVersion1 := ((pattern copyFrom: 3 to: pattern size - 2), '.0') asRwGemStoneVersionNumber.
	gsVersion2 := gsVersion1 copyFrom: 1 to: gsVersion1 size - 1.
	gsVersion2 at: gsVersion2 size put: (gsVersion2 at: gsVersion2 size) + 1.
	^ RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher new
			pattern: gsVersion1;
			pattern2: gsVersion2;
			patternMatchBlock: [:a :b :c | (a <= b) & (b < c ) ];
			yourself
%

! Class implementation for 'RwNestedProjectLoadConfiguration'

!		Instance methods for 'RwNestedProjectLoadConfiguration'

category: 'visiting'
method: RwNestedProjectLoadConfiguration
acceptNestedVisitor: aVisitor

	^aVisitor visitNestedProjectLoadConfiguration: self
%

category: 'visiting'
method: RwNestedProjectLoadConfiguration
acceptVisitor: aVisitor

	^self error: 'nested configuration cannot be used as a top-level configuration. The receiver is nested inside of project load configurations'
%

category: 'testing'
method: RwNestedProjectLoadConfiguration
isIndependentlyLoadable
	"nested configuration is not independently loadable ... they can only be loaded when referenced from another config"

	^ false
%

! Class implementation for 'RwProjectLoadConfiguration'

!		Instance methods for 'RwProjectLoadConfiguration'

category: 'visiting'
method: RwProjectLoadConfiguration
acceptVisitor: aVisitor

	^aVisitor visitProjectLoadConfiguration: self
%

category: 'accessing'
method: RwProjectLoadConfiguration
addDefinedGroupName: groupName 

	"add a group that does not include any other groups"

	self addDefinedGroupName: groupName includeGroups: #()
%

category: 'accessing'
method: RwProjectLoadConfiguration
addDefinedGroupName: groupName includeGroups: includedGroups

	"add a group that does not include any other groups"

	self definedGroupNames at: groupName put: includedGroups asArray sort
%

category: 'accessing'
method: RwProjectLoadConfiguration
definedGroupNames

	^ definedGroupNames 
		ifNil: [ definedGroupNames :=  Dictionary new]
%

category: 'accessing'
method: RwProjectLoadConfiguration
definedGroupNames: aColl

	definedGroupNames := aColl
%

! Class implementation for 'RwComponentLoadConfiguration'

!		Instance methods for 'RwComponentLoadConfiguration'

category: 'visiting'
method: RwComponentLoadConfiguration
acceptVisitor: aVisitor

	^aVisitor visitComponentLoadConfiguration: self
%

category: 'initialization'
method: RwComponentLoadConfiguration
initializeForExport

	"for export, the keys in the dictionaris of the conditional packages structure need to be put into canonical order"

	| cp orderedConditionalPackages |
	super initializeForExport.
	cp := self conditionalPackages.
	orderedConditionalPackages := Rowan platform orderedDictionaryClass new.

	(cp keys asSortedCollection: [:a :b | (a at: 1) <= (b at: 1) ]) do: [:ar |
		| dict orderedPackageNames |
		dict := cp at: ar.
		orderedPackageNames := Rowan platform orderedDictionaryClass new.
		dict keys asArray sort do: [:group | orderedPackageNames at: group put: (dict at: group) ].
		orderedConditionalPackages at: ar put: orderedPackageNames ].
	
	conditionalPackages := orderedConditionalPackages
%

category: 'accessing'
method: RwComponentLoadConfiguration
projectNames

	^ projectNames ifNil: [ #() ]
%

category: 'accessing'
method: RwComponentLoadConfiguration
projectNames: anArray

	projectNames := anArray
%

! Class implementation for 'RwProjectCompoundConfiguration'

!		Instance methods for 'RwProjectCompoundConfiguration'

category: 'visiting'
method: RwProjectCompoundConfiguration
acceptCompoundVisitor: aVisitor

	^aVisitor visitProjectCompoundConfiguration: self
%

category: 'visiting'
method: RwProjectCompoundConfiguration
acceptVisitor: aVisitor

	^self acceptCompoundVisitor: aVisitor
%

category: 'initialization'
method: RwProjectCompoundConfiguration
initialize

	super initialize.
	packageNames := Set new.
%

category: 'accessing'
method: RwProjectCompoundConfiguration
packageNames

   ^packageNames
%

category: 'accessing'
method: RwProjectCompoundConfiguration
packageNames: anObject

   packageNames := anObject
%

category: 'load support'
method: RwProjectCompoundConfiguration
resolvePackageNames

	"return the list of package names that is the result of resolving all of the receiver's references"

	"resolve each of the configurations in configurationNames to a list of package names and combine
		with the receiver's package names"

	| visitedConfigurationNames |
	visitedConfigurationNames := Set new.
	^ self resolvePackageNames: visitedConfigurationNames
%

category: 'load support'
method: RwProjectCompoundConfiguration
resolvePackageNames: visitedConfigurationNames

	| thePackageNames |
	(visitedConfigurationNames includes: self name)
		ifTrue: [ ^ #() ].
	visitedConfigurationNames add: self name.
	thePackageNames := self packageNames copy.
	self _configurations
		do: [ :config | thePackageNames addAll: (config resolvePackageNames: visitedConfigurationNames) ].
	^ thePackageNames
%

category: 'private'
method: RwProjectCompoundConfiguration
_configurations

	| spec urlBase |
	self configurationNames isEmpty ifTrue: [ ^ #() ].
	spec := self _specification.
	urlBase := 'file:' , (spec repositoryRootPath asFileReference / spec configsPath) pathString, '/'.
	^ self configurationNames
		collect: [ :configName | 
			| url |
			url := urlBase , configName , '.ston'.
			(RwAbstractProjectConfiguration fromUrl: url)
				projectName: self projectName;
				yourself ]
%

! Class implementation for 'RwAbstractReaderWriterVisitor'

!		Class methods for 'RwAbstractReaderWriterVisitor'

category: 'private'
classmethod: RwAbstractReaderWriterVisitor
_readObjectFrom: aFileReference

	aFileReference readStreamDo: [:stream |
		| reader |
		reader := STON reader on:  (ZnBufferedReadStream on:  stream).
		reader classes at: #'Package' put: Dictionary.
		^ reader next ]
%

category: 'private'
classmethod: RwAbstractReaderWriterVisitor
_repositoryPropertyDictFor: packagesRoot

	| propertiesFile |
	propertiesFile := packagesRoot / 'properties', 'st'.
	propertiesFile exists
		ifFalse: [ ^ Dictionary new ].
	^ self _readObjectFrom: propertiesFile
%

!		Instance methods for 'RwAbstractReaderWriterVisitor'

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentClassDefinition

	^ currentClassDefinition
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentClassExtension

	^ currentClassExtension
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentPackageDefinition

	^ currentPackageDefinition
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentPackageDefinition: aRwPackageDefinition

	currentPackageDefinition := aRwPackageDefinition
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentProjectDefinition

	^ currentProjectDefinition
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
currentProjectDefinition: aRwComponentProjectDefinition

	currentProjectDefinition := aRwComponentProjectDefinition
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
defaultPackageFormat

	self subclassResponsibility: #defaultPackageFormat
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
packageConvention

	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	^ packageConvention ifNil: [ 
		| ppc dpc  |
		ppc := self currentProjectDefinition packageConvention.
		dpc := self _repositoryConventionFor: self packagesRoot.
		dpc ~= ppc
			ifTrue:  [ self error: 'Disk package convention ' , dpc printString, ' does not match expected package convention ', ppc printstring. ' for project ', self projectName printString ].
		packageConvention := ppc ]
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
packagesRoot

	^ self currentProjectDefinition packagesRoot
%

category: 'accessing'
method: RwAbstractReaderWriterVisitor
projectName

	^ self currentProjectDefinition projectName
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
validateClassCategory: aClassDefinition  forPackageNamed: packageName

	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	"signal an error if the protocol does not conform to the convention for the current project"

	self packageConvention = 'RowanHybrid'
		ifTrue: [ ^ self _validateRowanHybridClassCategoryConvention: aClassDefinition forPackageNamed: packageName ].
	self packageConvention = 'Monticello'
		ifTrue: [ ^ self _validateRowanMonticelloClassCategoryConvention: aClassDefinition forPackageNamed: packageName ].
	"Rowan - no convention ... any old protocol is fine"
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
validateMethodDefinitionProtocol: methodDef className: className isMeta: isMeta forPackageNamed:  packageName

	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	"signal an error if the protocol does not conform to the convention for the current project"

	self packageConvention = 'RowanHybrid'
		ifTrue: [ ^ self _validateRowanHybridProtocolConvention: methodDef className: className isMeta: isMeta forPackageNamed:  packageName ].
	self packageConvention = 'Monticello'
		ifTrue: [ ^ self _validateRowanMonticelloProtocolConvention:methodDef className: className isMeta: isMeta forPackageNamed:  packageName ].
	"Rowan - no convention ... any old protocol is fine"
%

category: 'private'
method: RwAbstractReaderWriterVisitor
_packageConvention: aString

	packageConvention := aString
%

category: 'private'
method: RwAbstractReaderWriterVisitor
_readObjectFrom: aFileReference

	^ self class _readObjectFrom: aFileReference
%

category: 'private'
method: RwAbstractReaderWriterVisitor
_repositoryConventionFor: packagesRoot

	^ (self _repositoryPropertyDictFor: packagesRoot) at: #convention ifAbsent: [ 'RowanHybrid'  ]
%

category: 'private'
method: RwAbstractReaderWriterVisitor
_repositoryFormatFor: packagesRoot

	^ (self _repositoryPropertyDictFor: packagesRoot) at: #format ifAbsent: [ self defaultPackageFormat ]
%

category: 'private'
method: RwAbstractReaderWriterVisitor
_repositoryPropertyDictFor: packagesRoot

	^ self class _repositoryPropertyDictFor: packagesRoot
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
_validateRowanHybridClassCategoryConvention: aClassDefinition forPackageNamed: packageName

	aClassDefinition category = packageName ifTrue: [ ^ self ].
	RwInvalidClassCategoryConventionErrorNotification 
		signalWithClassDefinition: aClassDefinition 
			packageName: packageName 
			packageConvention: 'RowanHybrid'
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
_validateRowanHybridProtocolConvention:  methodDef className: className isMeta: isMeta forPackageNamed:  packageName

	| canonProtocol expectedProtocol protocol |
	protocol := methodDef protocol.
	(protocol at: 1) = $*
		ifTrue: [
			currentClassDefinition
				ifNotNil: [
					"protocol should not start with $* for a non-extension method"
					RwExtensionProtocolNonExtensionMethodErrorNotification 
						signalWithMethodDefinition: methodDef
							className: className 
							isMeta: isMeta 
							packageName:  packageName
							packageConvention: 'RowanHybrid'.
					^ self ] ]
		ifFalse: [
			currentClassDefinition 
				ifNotNil:  [ 
					"protocol does not start with $* as expected"
					^ self ] ].			
	"validate conformance to convention for extension method"
	(protocol at: 1) = $*
		ifFalse: [
			"extension method protocol must start with a *"
			RwNonExtensionProtocolExtensionMethodErrorNotification
				signalWithMethodDefinition: methodDef
					className: className 
					isMeta: isMeta 
					packageName:  packageName
					packageConvention: 'RowanHybrid'.
			^ self  ].
	canonProtocol := protocol asLowercase.
	expectedProtocol := '*', packageName asLowercase.
	canonProtocol = expectedProtocol ifTrue: [ ^ self ].
	"protocol does not match package name"
	RwExtensionProtocolExtensionMethodPackageMismatchErrorNotification
		signalWithMethodDefinition: methodDef
			className: className 
			isMeta: isMeta 
			packageName:  packageName
			packageConvention: 'RowanHybrid'
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
_validateRowanMonticelloClassCategoryConvention: aClassDefinition forPackageNamed: packageName

	(aClassDefinition category beginsWith: packageName) ifTrue: [ ^ self ].
	RwInvalidClassCategoryConventionErrorNotification signalWithClassDefinition: aClassDefinition packageName: packageName packageConvention: 'Monticello'
%

category: 'validation'
method: RwAbstractReaderWriterVisitor
_validateRowanMonticelloProtocolConvention: protocol  forPackageNamed: packageName

	| canonProtocol expectedProtocol |
	(protocol at: 1) = $*
		ifTrue: [
			currentClassDefinition
				ifNotNil: [
					"protocol should not start with $* -- an obvious violation"
					self error: 'not yet implemented']]
		ifFalse: [
			currentClassDefinition 
				ifNotNil:  [ 
					"protocol does not start with $* as expected"
					^ self ] ].			
	"validate conformance to convention for extension method"
	canonProtocol := protocol asLowercase.
	expectedProtocol := '*', packageName asLowercase.
	"off the top of my head"
	(canonProtocol beginsWith: expectedProtocol) 
		ifTrue: [
			(canonProtocol indexOf: $- startingAt: expectedProtocol size) <= 1 ifTrue: [ ^self ] ].
	"protocol does not conform to Monticello convention"
	self error: 'not yet implemented'
%

! Class implementation for 'RwModificationWriterVisitor'

!		Class methods for 'RwModificationWriterVisitor'

category: 'accessing'
classmethod: RwModificationWriterVisitor
lineEnding
  "Answer the os-specific line endings"

  ^ String with: Character lf
%

!		Instance methods for 'RwModificationWriterVisitor'

category: 'actions'
method: RwModificationWriterVisitor
addedClass: aClassModification

	currentClassDefinition := aClassModification after.

	self processClass: aClassModification
%

category: 'actions'
method: RwModificationWriterVisitor
addedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification after.

	self processClassExtension: aClassExtensionModification
%

category: 'actions'
method: RwModificationWriterVisitor
addedPackage: aPackageModification

	currentPackageDefinition := aPackageModification after.
	self processPackage: aPackageModification
%

category: 'actions'
method: RwModificationWriterVisitor
addedProject: aProjectModification
	currentProjectDefinition := aProjectModification after.
	self processProject: aProjectModification
%

category: 'actions'
method: RwModificationWriterVisitor
changedClass: aClassModification

	currentClassDefinition := aClassModification after.

	self processClass: aClassModification
%

category: 'actions'
method: RwModificationWriterVisitor
changedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification after.

	self processClassExtension: aClassExtensionModification
%

category: 'actions'
method: RwModificationWriterVisitor
changedPackage: aPackageModification

	currentPackageDefinition := aPackageModification after.
	self processPackage: aPackageModification
%

category: 'actions'
method: RwModificationWriterVisitor
changedProject: aProjectModification

	currentProjectDefinition := aProjectModification after.
	self processProject: aProjectModification
%

category: 'actions'
method: RwModificationWriterVisitor
deletedClass: aClassModification

	self subclassResponsibility: #deletedClass:
%

category: 'actions'
method: RwModificationWriterVisitor
deletedClassExtension: aClassExtensionModification

	self subclassResponsibility: #deletedClassExtension:
%

category: 'actions'
method: RwModificationWriterVisitor
deletedPackage: aPackageModification

	self subclassResponsibility: #deletedPackage:
%

category: 'actions'
method: RwModificationWriterVisitor
deletedProject: aProjectModification

	"A deleted project means that the project was not inlcuded in the base project set definition ... we do not want to change anything on disk.
		So ignore the rest of the project"
%

category: 'exporting'
method: RwModificationWriterVisitor
export

	"noop ... directory-based formats written out as each element is visited"
%

category: 'class writing'
method: RwModificationWriterVisitor
processClass: aClassModification

	self subclassResponsibility: #processClass:
%

category: 'class writing'
method: RwModificationWriterVisitor
processClassExtension: aClassExtensionModification

	self subclassResponsibility: #processClassExtension:
%

category: 'package writing'
method: RwModificationWriterVisitor
processPackage: aPackageModification

	aPackageModification classesModification acceptVisitor: self.
	aPackageModification classExtensionsModification acceptVisitor: self
%

category: 'project writing'
method: RwModificationWriterVisitor
processProject: aProjectModification
 
	aProjectModification packagesModification acceptVisitor: self
%

category: 'public'
method: RwModificationWriterVisitor
visit: aPackageSetModification

	aPackageSetModification acceptVisitor: self.
	self export.
%

category: 'visiting'
method: RwModificationWriterVisitor
visitClassesModification: aClassesModification

	aClassesModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visiting'
method: RwModificationWriterVisitor
visitClassExtensionModification: aClassExtensionModification

	aClassExtensionModification isAddition
		ifTrue: [ ^ self addedClassExtension: aClassExtensionModification ] .
	aClassExtensionModification isDeletion
		ifTrue: [ ^ self deletedClassExtension: aClassExtensionModification ].
	^ self changedClassExtension: aClassExtensionModification
%

category: 'visiting'
method: RwModificationWriterVisitor
visitClassExtensionsModification: aClassExtensionsModification

	aClassExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwModificationWriterVisitor
visitClassModification: aClassModification

	aClassModification isAddition
		ifTrue: [ ^ self addedClass: aClassModification ] .
	aClassModification isDeletion
		ifTrue: [ ^ self deletedClass: aClassModification ].
(aClassModification instanceMethodsModification isEmpty and: [ aClassModification classMethodsModification isEmpty ])
	ifTrue: [
		"no instance or class modifications, check to see if the only Property modification is for 'gs_SymbolDictionary' "
		| propertiesModification elementsModified |
		propertiesModification := aClassModification propertiesModification.
		elementsModified := propertiesModification elementsModified.
		(elementsModified size = 1 and: [ (elementsModified at: 'gs_SymbolDictionary' ifAbsent: []) notNil])
			ifTrue: [
				"'gs_symbolDictionary' property is not written to disk, so we can skip this class"
				^ self ]].
	^ self changedClass: aClassModification
%

category: 'visiting'
method: RwModificationWriterVisitor
visitPackageModification: aPackageModification

	aPackageModification isAddition
		ifTrue: [ ^ self addedPackage: aPackageModification ] .
	aPackageModification isDeletion
		ifTrue: [ ^ self deletedPackage: aPackageModification ].
	^ self changedPackage: aPackageModification
%

category: 'visiting'
method: RwModificationWriterVisitor
visitPackagesModification: aPackagesModification

	aPackagesModification elementsModified do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwModificationWriterVisitor
visitProjecteSetModification: aProjectSetModification

	aProjectSetModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwModificationWriterVisitor
visitProjectModification: aProjectModification

	aProjectModification isAddition
		ifTrue: [ ^ self addedProject: aProjectModification ].
	aProjectModification isDeletion
		ifTrue: [ ^ self deletedProject: aProjectModification ].
	^ self changedProject: aProjectModification
%

category: 'private'
method: RwModificationWriterVisitor
_createFileNameMapForClassesOrPackages: aClassOrPackageDefinitionDictionary
 
  "answer a dictionary that maps each definition name to a filename that is guaranteed unique on case insensitive file systems"

  | map filenameMap |
  map := Dictionary new.
  aClassOrPackageDefinitionDictionary
    do: [ :cDef | 
      | nam col |
      "sort into bins by lowercase selector. "
      nam := cDef name asLowercase.
      col := map
        at: nam
        ifAbsentPut: [ OrderedCollection new ].
      col add: cDef ].
  filenameMap := Dictionary new.
  map values
	do: [ :col | 
	  | sortedCol |
	  col size = 1
		ifTrue: [ 
		  | def |
		  "no need to distinguish filename"
		  def := col at: 1.
		  filenameMap
			at: def name
			put: def name ]
		ifFalse: [ 
		  "tack on postfix to guarantee  file names are unique on case insensitive file systems"
		  sortedCol := col sorted: [ :a :b | a asString _unicodeLessThan: b asString ].
		  (1 to: sortedCol size) do: [ :index | 
			| def filename |
			def := sortedCol at: index.
			filename := def name.
			filename := filename , '..' , index printString.
			filenameMap at: def name put: filename ] ] ].
  ^ filenameMap
%

category: 'private'
method: RwModificationWriterVisitor
_newLine
	 ^ self class lineEnding
%

! Class implementation for 'RwGsModificationTopazWriterVisitor'

!		Instance methods for 'RwGsModificationTopazWriterVisitor'

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
bufferedStream

	^ bufferedStream ifNil: [ 
		| encodedStream |
		encodedStream := (self repositoryRootPath / self topazFilename, self filenameExtension) writeStreamEncoded: 'utf8'.
		bufferedStream := ZnBufferedWriteStream on: encodedStream ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
buildPackageNamesMap

	"If true, topazFilenamePackageNamesMap will be built from topazFilenameConfigsMap.
		If false, existing topazFilenamePackageNamesMap will be used"

	^ buildPackageNamesMap ifNil: [ buildPackageNamesMap := true ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
classDefinitions

	^ classDefinitions ifNil: [ classDefinitions := Dictionary new ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
classDefPackageNameMap

	^ classDefPackageNameMap ifNil: [ classDefPackageNameMap := Dictionary new ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
classExtensions

	^ classExtensions ifNil: [ classExtensions := Dictionary new ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
classExtPackageNameMap

	^ classExtPackageNameMap ifNil: [ classExtPackageNameMap := IdentityKeyValueDictionary new ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
classInitializationDefinitions

	^ classInitializationDefinitions
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
classSymbolDictionaryNames

	^ classSymbolDictionaryNames ifNil: [ classSymbolDictionaryNames := Dictionary new ]
%

category: 'actions'
method: RwGsModificationTopazWriterVisitor
deletededClass: aClassModification

	"a deleted class is ignored for topaz ... the deleted class is simply not written"
%

category: 'actions'
method: RwGsModificationTopazWriterVisitor
deletededClassExtension: aClassExtensionModification

	"a deleted class extension is ignored for topaz ... the deleted methods are simply not written"
%

category: 'actions'
method: RwGsModificationTopazWriterVisitor
deletededPackage: aPackageModification

	"a deleted package is ignored for topaz ... the deleted classes and methods are simply not written out"
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitor
export

	self topazFilenamePackageNamesMap keysAndValuesDo: [:filename :packageNames |
		| classDefinitionsInOrder classExtensionsInOrder classExtensionsList classDefinitionsList |

		self _setBufferedStreamFor: filename.
		self bufferedStream nextPutAll: self topazFileHeader.

		classInitializationDefinitions := Set new. "per file record"
		classDefinitionsList := Set new.

		self classDefPackageNameMap keysAndValuesDo: [:className :packageName |
			(packageNames includes: packageName)
				ifTrue: [ classDefinitionsList add: (self classDefinitions at: className) ] ].

		classDefinitionsInOrder := (CypressGsGeneralDependencySorter
			on: classDefinitionsList
			dependsOn: [:candidate | candidate superclassName]
			dependent: [:candidate | candidate name]) inOrder.
		self exportClassDefinitions: classDefinitionsInOrder;
			exportMethodDefinitions: classDefinitionsInOrder.

		"consolidate the classExtensions for a class from multiple packages into a single definition"
		classExtensionsList := Set new. 
		self classExtensions keysAndValuesDo: [:classExtName :extSet |
			| extsInConfig |
			extsInConfig := Set new.
			extSet do: [:ext |
				| packageName |
				packageName := self classExtPackageNameMap at: ext.
				(packageNames includes: packageName)
					ifTrue: [ extsInConfig add: ext ] ].

			extsInConfig size <= 1 
				ifTrue: [ classExtensionsList addAll: extsInConfig ]
				ifFalse: [
					| ar def |
					ar := extsInConfig asArray.
					def := (ar at: 1) copy.
					2 to: ar size do: [:index |
						| d |
						d := (ar at: index).
						d classMethodDefinitions values do: [:m | def addClassMethodDefinition: m ].
						d instanceMethodDefinitions values do: [:m | def addInstanceMethodDefinition: m ] ].
					classExtensionsList add: def ] ].

		classExtensionsInOrder := classExtensionsList sort: [:a :b | a name <= b name ].
		self
			exportExtensionMethodDefinitions: classExtensionsInOrder.

		self exportClassInitializations.

		self bufferedStream flush; close ].
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitor
exportClassDefinitions: classDefinitionsInOrder

	| stream |
	stream := self bufferedStream.
	classDefinitionsInOrder isEmpty not
		ifTrue: [ 
			stream
				nextPutAll: '! Class Declarations'; lf;
				lf ].
	classDefinitionsInOrder do: [:classDef | 
		self _fileOutClassDeclaration: classDef on: stream ].
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitor
exportClassInitializations

	| stream |
	self classInitializationDefinitions isEmpty ifTrue: [ ^ self ].

	stream := self bufferedStream.

	stream 
		nextPutAll: '! Class Initialization'; lf;
		lf;
		nextPutAll: 'run'; lf.

	(self classInitializationDefinitions sort: [:a :b | a name <= b name ]) do: [ :classDef |
		stream nextPutAll: classDef name, ' initialize.'; lf ].

	stream nextPutAll: '%'; lf;
		lf
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitor
exportExtensionMethodDefinitions: classDefinitionsInOrder

	self exportMethodDefinitions: classDefinitionsInOrder labeled: 'Class extensions'
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitor
exportMethodDefinitions: classDefinitionsInOrder

	self exportMethodDefinitions: classDefinitionsInOrder labeled: 'Class implementation'
%

category: 'exporting'
method: RwGsModificationTopazWriterVisitor
exportMethodDefinitions: classDefinitionsInOrder labeled: label

	| stream |
	stream := self bufferedStream.
	classDefinitionsInOrder do: [:classDef | 
		| className |
		className := classDef name.
		(classDef classMethodDefinitions isEmpty not or: [ classDef instanceMethodDefinitions isEmpty not])
			ifTrue: [ 
				stream nextPutAll: '! ', label, ' for ', className printString; lf;
				lf ].
		classDef classMethodDefinitions isEmpty not
			ifTrue: [ 
				stream nextPutAll: '!		Class methods for ', className printString; lf;
				lf ].
		(classDef classMethodDefinitions values sort: [:a :b | a selector <= b selector ])
			do: [:methodDef |
				methodDef selector == #initialize
					ifTrue: [ self classInitializationDefinitions add: classDef ].
				self _fileOutMethod: methodDef forClass: className isMeta: true on: stream ].
		classDef instanceMethodDefinitions isEmpty not
			ifTrue: [ 
				stream nextPutAll: '!		Instance methods for ', className printString; lf;
				lf ].
		(classDef instanceMethodDefinitions values sort: [:a :b | a selector <= b selector ])
			do: [:methodDef |
				self _fileOutMethod: methodDef forClass: className isMeta: false on: stream ] ].
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
filenameExtension

	^ filenameExtension ifNil: ['gs' ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
filenameExtension: aString

	filenameExtension := aString
%

category: 'class writing'
method: RwGsModificationTopazWriterVisitor
processClass: aClassModification

	| classDefinition symbolDictName |
	classDefinition := aClassModification after.
	(self classDefinitions at: classDefinition name ifAbsent: []) ifNotNil: [ self error: 'duplicate class defintion for ', classDefinition name printString, ' encountered.'].

	symbolDictName := self currentProjectDefinition symbolDictNameForPackageNamed: self currentPackageDefinition name.
	self classSymbolDictionaryNames at: classDefinition name put: symbolDictName.
	self classDefinitions at: classDefinition name put: classDefinition.

	self classDefPackageNameMap at: classDefinition name put: currentPackageDefinition name.

	"no need to visit any further as the class definition records the instance and class methods"
%

category: 'class writing'
method: RwGsModificationTopazWriterVisitor
processClassExtension: aClassExtensionModification

	| classExtension |
	classExtension := aClassExtensionModification after.
	(self classExtensions at: classExtension name ifAbsentPut: [ Set new ])
		add: classExtension.

	self classExtPackageNameMap at: classExtension put: currentPackageDefinition name.

	"no need to visit any further as the class etension records the instance and class methods"
%

category: 'project writing'
method: RwGsModificationTopazWriterVisitor
processProject: aProjectModification

	self buildPackageNamesMap 
		ifTrue: [
			| readTool |
			topazFilenamePackageNamesMap := self topazFilenamePackageNamesMap.
			readTool := Rowan projectTools read.
			self topazFilenameConfigsMap keysAndValuesDo: [:filename :configAndGroupNamesMap | 
				| configNames groupNames visitor packageNames configAndGroupNamesArray |
				configAndGroupNamesArray := configAndGroupNamesMap at: currentProjectDefinition name ifAbsent: [ {{}.{}} ].
				configAndGroupNamesArray
					ifNotNil: [
						configNames := configAndGroupNamesArray at: 1.
						groupNames := configAndGroupNamesArray at: 2.
						visitor := readTool 
							readConfigurationsForProjectDefinition: currentProjectDefinition 
							withConfigurations: configNames 
							groupNames: groupNames 
							forLoad: false.
						packageNames := visitor
							ifNil: [ 
								self topazFilenameConfigsMap size > 1
									ifTrue: [ self error: 'unable to read project configurations for project ', currentProjectDefinition name printString, '. Multiple output files likely to have the same contents.'].
								currentProjectDefinition packageNames ]
							ifNotNil: [  visitor packageNames ].
						(topazFilenamePackageNamesMap at: filename ifAbsentPut: [ Set new ]) addAll: packageNames ] ] ].
	aProjectModification packagesModification acceptVisitor: self
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
repositoryRootPath

	^ repositoryRootPath
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
repositoryRootPath: aStringOrFileReference 

	repositoryRootPath := aStringOrFileReference asFileReference.
	repositoryRootPath exists ifFalse: [ self error: 'The repository root path must exist: ', repositoryRootPath pathString printString ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
topazFileHeader

	^ topazFileHeader ifNil: [ '' ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
topazFileHeader: aString

	topazFileHeader := aString
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
topazFilename

	^ topazFilename
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
topazFilename: aString

	topazFilename := aString
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
topazFilename: aNameString filenameExtension: anExtensionString

	topazFilename := aNameString.
	filenameExtension := anExtensionString
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
topazFilenameConfigsMap

	^ topazFilenameConfigsMap
		ifNil: [ topazFilenameConfigsMap := Dictionary new at: self topazFilename put: Dictionary new; yourself ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
topazFilenameConfigsMap: aDictionary

	"keys are topaz file names, values are a dictionary:
		whose keys are project names and values are two slot array with config name list and group name list. 
			The config names and group names are resolved to a list of packages that will be written to the named file.

			If the config/group name list is empty, the default config and group names for the project will be used.
			If either (or both) of the slots contain empty array, then the corresponding project default will be used."

	"If topazFilenamePackageNamesMap is explicitly set, then the contents of topazFilenameConfigsMap will be ignored."

	buildPackageNamesMap := true.
	topazFilenameConfigsMap := aDictionary
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
topazFilenamePackageNamesMap

	^ topazFilenamePackageNamesMap ifNil: [ topazFilenamePackageNamesMap := Dictionary new ]
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
topazFilenamePackageNamesMap: aDictionary

	"keys are topaz file names, values are a collection of package names"

	"if topazFilenameConfigsMap is being used, then the topazFilenamePackageNamesMap is generated automatically,
		based on the project configurations."

	"If you explicitly set topazFilenamePackageNamesMap then contents of topazFilenameConfigsMap will be ignored."

	buildPackageNamesMap := false.
	topazFilenamePackageNamesMap := aDictionary
%

category: 'accessing'
method: RwGsModificationTopazWriterVisitor
topazFileReference

	^ self repositoryRootPath / self topazFilename, self filenameExtension
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitor
_fileOutClassDeclaration: classDefinition on: aStream
  aStream
    nextPutAll: 'doit';
    lf;
    nextPutAll: '(' , classDefinition superclassName;
    lf.
  self
    _writeClassTypeMessage: classDefinition
    on: aStream
    hasInstanceVariables: [ aStream
        nextPutAll:
            '	instVarNames: #( ' , (self _stringForVariables: classDefinition instVarNames) , ' )';
        lf ].
  aStream
    nextPutAll: '	classVars: #( ' ,  (self _stringForVariables: classDefinition classVarNames) , ' )';
    lf;
    nextPutAll:
        '	classInstVars: #( ' ,  (self _stringForVariables: classDefinition classInstVarNames) , ' )';
    lf;
    nextPutAll: '	poolDictionaries: #()';
    lf;
    nextPutAll: '	inDictionary: ', (self classSymbolDictionaryNames at: classDefinition name);
    lf;
    nextPutAll: '	options: #())';
    lf;
    nextPutAll: '		category: ' , classDefinition category printString , ';';
    lf;
    nextPutAll: '		comment: ' , classDefinition comment printString , ';';
    lf;
    nextPutAll: '		immediateInvariant.';
    lf;
    nextPutAll: 'true.';
    lf;
    nextPutAll: '%';
    lf;
    lf
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitor
_fileOutMethod: methodDefinition forClass: className isMeta: isMeta on: aStream

	aStream
		nextPutAll: 'category: ', methodDefinition protocol printString; lf;
		nextPutAll: (isMeta ifTrue: ['classmethod: '] ifFalse: ['method: ']), className; lf;
		nextPutAll: methodDefinition source.
	methodDefinition source last = Character lf
		ifFalse: [aStream lf].
	aStream nextPutAll: '%'; lf;
		lf
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitor
_setBufferedStreamFor: filename

	^ self _setBufferedStreamFor: filename extension: self filenameExtension
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitor
_setBufferedStreamFor: filename extension: extension

	| encodedStream |
	encodedStream := (self repositoryRootPath / filename, extension) writeStreamEncoded: 'utf8'.
	bufferedStream := ZnBufferedWriteStream on: encodedStream
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitor
_stringForVariables: variableList

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	variableList do: [:each | stream nextPutAll: each]
		separatedBy: [stream space].
	^stream contents
%

category: 'private exporting'
method: RwGsModificationTopazWriterVisitor
_writeClassTypeMessage: classDefinition on: aStream hasInstanceVariables: instanceVariableBlock
  | classType classTypeMessage hasInstanceVariables |
  hasInstanceVariables := true.
  classType := classDefinition subclassType.
  classType = 'variable'
    ifTrue: [ classTypeMessage := 'indexableSubclass: ' ]
    ifFalse: [ classType = 'byteSubclass'
        ifTrue: [ classTypeMessage := 'byteSubclass: '.
          hasInstanceVariables := false ]
        ifFalse: [ classType = ''
            ifTrue: [ classTypeMessage := 'subclass: ' ]
            ifFalse: [ self error: 'unknown subclass type: ' , classType ] ] ].
  aStream
    tab;
    nextPutAll: classTypeMessage , classDefinition name asString printString;
    lf.
  hasInstanceVariables
    ifTrue: [ instanceVariableBlock value ]
%

! Class implementation for 'RwModificationCypressFamilyWriterVisitor'

!		Class methods for 'RwModificationCypressFamilyWriterVisitor'

category: 'accessing'
classmethod: RwModificationCypressFamilyWriterVisitor
orderedDictionaryClass
  "Answer the platform-specific OrderedDictionary-compatible class"

  ^ GsTonelOrderedDictionary
%

!		Instance methods for 'RwModificationCypressFamilyWriterVisitor'

category: 'actions'
method: RwModificationCypressFamilyWriterVisitor
deletedPackage: aPackageModification

	currentPackageDefinition := aPackageModification before.

	self _packageSourceDir ensureDeleteAll.	"delete the whole package directory"
%

category: 'package writing'
method: RwModificationCypressFamilyWriterVisitor
packageExtension

	^ ''
%

category: 'package writing'
method: RwModificationCypressFamilyWriterVisitor
processPackage: aPackageModification

	classDefFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification after classDefinitions.
	classExtFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification after classExtensions.
	classDefBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification before classDefinitions.
	classExtBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aPackageModification before classExtensions.

	super processPackage: aPackageModification
%

category: 'class writing'
method: RwModificationCypressFamilyWriterVisitor
_commentOf: aClassDefinition
	^ (aClassDefinition comment 
		copyReplaceAll: '"' 
		with: '""')
		withLineEndings: self _newLine
%

category: 'package writing'
method: RwModificationCypressFamilyWriterVisitor
_packageSourceDir

	| filename |
	filename := packageDefFileNameMap 
		at:  self currentPackageDefinition name 
		ifAbsent: [
			"in the case of package removal, need to use the before package map"
			packageDefBeforeFileNameMap at: self currentPackageDefinition name ].
	^ self packageExtension isEmpty
		ifTrue: [ self _projectSourceDir /filename ]
		ifFalse: [ self _projectSourceDir /filename, self packageExtension ]
%

category: 'project writing'
method: RwModificationCypressFamilyWriterVisitor
_projectSourceDir

	^ self currentProjectDefinition packagesRoot
%

category: 'private'
method: RwModificationCypressFamilyWriterVisitor
_toJSON: anObject
	^ (STON toJsonStringPretty: anObject)
		withLineEndings: self _newLine
%

category: 'private'
method: RwModificationCypressFamilyWriterVisitor
_toSTON: anObject
	^ (String streamContents: [ :stream | 
		(TonelSTONWriter on: stream) nextPut: anObject ])
		withLineEndings: self _newLine
%

! Class implementation for 'RwModificationFiletreeWriterVisitor'

!		Class methods for 'RwModificationFiletreeWriterVisitor'

category: 'initialization'
classmethod: RwModificationFiletreeWriterVisitor
initialize
	"self initialize"
    specials := self initializeSpecials
%

category: 'initialization'
classmethod: RwModificationFiletreeWriterVisitor
initializeSpecials

    | map |
    map := Dictionary new.
    map
		at: $! put: 'bang';
        at: $+ put: 'plus';
        at: $- put: 'minus';
        at: $= put: 'equals';
        at: $< put: 'less';
        at: $> put: 'more';
        at: $% put: 'percent';
        at: $& put: 'and';
        at: $| put: 'pipe';
        at: $* put: 'star';
        at: $/ put: 'slash';
        at: $\ put: 'backslash';
        at: $~ put: 'tilde';
        at: $? put: 'wat';
        at: $, put: 'comma';
        at: $@ put: 'at'.
    map keys do: [ :key | map at: (map at: key) put: key ].
    ^ map
%

category: 'accessing'
classmethod: RwModificationFiletreeWriterVisitor
selectorSpecials

	^ specials ifNil: [ specials := self initializeSpecials ]
%

!		Instance methods for 'RwModificationFiletreeWriterVisitor'

category: 'actions'
method: RwModificationFiletreeWriterVisitor
addedMethod: aMethodModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodModification after.

	"create instance/class directory as needed ... write method source file"
	 (aMethodModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st')
		writeStreamDo: [:aStream |
		aStream 
			<< methodDefinition protocol
			<< self _newLine
			<< (methodDefinition source withLineEndings: self _newLine) ]
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
addedMethodExtension: aMethodExtensionModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodExtensionModification after.

	"create instance/class directory as needed ... write method source file"
	 (aMethodExtensionModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassExtensionDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceExtensionDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st')
		writeStreamDo: [:aStream |
		aStream 
			<< methodDefinition protocol
			<< self _newLine
			<< (methodDefinition source withLineEndings: self _newLine) ]
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
addedPackage: aPackageModification

	| packageProperties |
	currentPackageDefinition := aPackageModification after.

	"create package directory and properties.json file"
	self _packageSourceDir ensureCreateDirectory.
	(self _packageSourceDir /  'properties.json')
		writeStreamDo: [:aStream |
		aStream 
			<< '{'
			<< self  _newLine
			<< '	 }'].

	packageProperties := self _filetreePackagePropertyDictFor: aPackageModification.
	(packageProperties at:  'noMethodMetaData' ifAbsent: []) = self noMethodMetaData
		ifFalse: [
			"Rowan can read filetree repositories with methodMetaData, but does write method metadata"
			self error: 'method metadata not supported.' ].
	(packageProperties at:  'separateMethodMetaAndSource' ifAbsent: []) = self separateMethodMetaAndSource
		ifFalse: [
			"Rowan can read filetree repositories with separateMethodMetaAndSource, but does write separateMethodMetaAndSource"
			self error: 'separateMethodMetaAndSource not supported.' ].
	(packageProperties at:  'useCypressPropertiesFile' ifAbsent: []) = self useCypressPropertiesFile
		ifFalse: [
			"Rowan can read filetree repositories without CypressPropertiesFile, but does write without useCypressPropertiesFile"
			self error: 'only useCypressPropertiesFile not supported.' ].

	self processPackage: aPackageModification
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
changedMethod: aMethodModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodModification after.

	"create instance/class directory as needed ... write method source file"
	 (aMethodModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st')
		writeStreamDo: [:aStream |
		aStream 
			<< methodDefinition protocol
			<< self _newLine
			<< (methodDefinition source withLineEndings: self _newLine) ]
%

category: 'accessing'
method: RwModificationFiletreeWriterVisitor
defaultPackageFormat

	^ 'filetree'
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
deletedClass: aClassModification

	currentClassDefinition := aClassModification before.

	self _classSourceDir ensureDeleteAll
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
deletedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification before.

	self _classExtensionSourceDir ensureDeleteAll
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
deletedMethod: aMethodModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodModification before.

	"delete method source file"
	 (aMethodModification isMeta
		ifTrue: [
			methodFileName := classFileNameMap at: methodDefinition selector
				ifAbsent: [ classBeforeFileNameMap at: methodDefinition selector ].
			methodDir := self _methodClassDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceFileNameMap at: methodDefinition selector
				ifAbsent: [ instanceBeforeFileNameMap at: methodDefinition selector ].
			methodDir := self _methodInstanceDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st') ensureDelete
%

category: 'actions'
method: RwModificationFiletreeWriterVisitor
deletedMethodExtension: aMethodExtensionModification

	| methodDefinition methodDir methodFileName |

	methodDefinition := aMethodExtensionModification before.

	"create instance/class directory as needed ... write method source file"
	 (aMethodExtensionModification isMeta
		ifTrue: [
			methodFileName := classBeforeFileNameMap at: methodDefinition selector.
			methodDir := self _methodClassExtensionDir ensureCreateDirectory ]
		ifFalse: [ 
			methodFileName := instanceBeforeFileNameMap at: methodDefinition selector.
			methodDir := self _methodInstanceExtensionDir ensureCreateDirectory ]) .


	(methodDir / methodFileName, 'st') ensureDelete
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
monticelloMetadata
	"monticello metadata  --- for writing metadataless is the only supported format"

	^ monticelloMetadata ifNil: [ monticelloMetadata := false ]
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
noMethodMetaData

	^ noMethodMetaData ifNil: [ noMethodMetaData := true ]
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
packageExtension

	^ packageExtension ifNil: [ packageExtension := 'package' ]
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
processClass: aClassModification

	"create class directory and class defintion structure"

	self _classSourceDir ensureCreateDirectory.

	(self _classSourceDir /  'README.md')
		writeStreamDo: [:aStream |
		aStream 
			<< (self _commentOf: self currentClassDefinition) ].

	(self _classSourceDir /  'properties.json')
		writeStreamDo: [:aStream |
			aStream 
				<< (self _typeClassDefinitionOf: self currentClassDefinition)
				<< self _newLine ].

	instanceFileNameMap  := self _createFileNameMapForMethods: aClassModification after instanceMethodDefinitions.
	classFileNameMap := self _createFileNameMapForMethods: aClassModification after classMethodDefinitions.
	instanceBeforeFileNameMap  := self _createFileNameMapForMethods: aClassModification before instanceMethodDefinitions.
	classBeforeFileNameMap := self _createFileNameMapForMethods: aClassModification before classMethodDefinitions.

	currentClassDefinition instanceMethodDefinitions isEmpty
		ifTrue: [  self _methodInstanceDir ensureDeleteAll ]
		ifFalse: [ aClassModification instanceMethodsModification acceptVisitor: self ].
	currentClassDefinition classMethodDefinitions isEmpty
		ifTrue: [  self _methodClassDir ensureDeleteAll ]
		ifFalse: [ aClassModification classMethodsModification acceptVisitor: self ]
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
processClassExtension: aClassExtensionModification

	"create class extension directory and defintion structure"

	(currentClassExtension instanceMethodDefinitions isEmpty and: [ currentClassExtension classMethodDefinitions isEmpty ])
		ifTrue: [ self _classExtensionSourceDir ensureDeleteAll ]
		ifFalse: [ 
			self _classExtensionSourceDir ensureCreateDirectory.
			(self _classExtensionSourceDir /  'properties.json')
				writeStreamDo: [:aStream |
					aStream 
						<< (self _classExtensionOf: self currentClassExtension)
						<< self _newLine ].

			instanceFileNameMap  := self _createFileNameMapForMethods: aClassExtensionModification after instanceMethodDefinitions.
			classFileNameMap := self _createFileNameMapForMethods: aClassExtensionModification after classMethodDefinitions.
			instanceBeforeFileNameMap  := self _createFileNameMapForMethods: aClassExtensionModification before instanceMethodDefinitions.
			classBeforeFileNameMap := self _createFileNameMapForMethods: aClassExtensionModification before classMethodDefinitions.

			aClassExtensionModification instanceMethodsModification acceptVisitor: self.
			aClassExtensionModification classMethodsModification acceptVisitor: self ]
%

category: 'project writing'
method: RwModificationFiletreeWriterVisitor
processProject: aProjectModification

	| projectProperties |

	packageDefFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification after packages.
	packageDefBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification before packages.

	"confirm that the project source is written in Tonel format"
	(self _repositoryFormatFor:  aProjectModification after packagesRoot) = 'filetree' ifFalse: [ self error: 'expected tonel format repository' ].

	projectProperties := self _filetreeProjectPropertyDictFor: aProjectModification.
	packageExtension := projectProperties at: 'packageExtension' ifAbsent: [ self packageExtension ].
	(packageExtension beginsWith: '.')
		ifTrue: [
			"properties file includes leading $., so strip it"
			packageExtension := packageExtension copyFrom: 2 to: packageExtension size ].
	(projectProperties at: 'Metadata' ifAbsent: [ true ])
		ifTrue: [
			"Rowan can read filetree repositories with Monticello metadata, but cannot write Monticello metadata"
			self error: 'Monticello metadata not supported.' ].

	super processProject: aProjectModification.
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
separateMethodMetaAndSource

	^ separateMethodMetaAndSource ifNil: [ separateMethodMetaAndSource := false ]
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
useCypressPropertiesFile

	^ useCypressPropertiesFile ifNil: [ useCypressPropertiesFile := true ]
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitor
visitExtensionMethodModification: aMethodExtensionModification

	aMethodExtensionModification isAddition
		ifTrue: [ ^ self addedMethodExtension: aMethodExtensionModification ] .
	aMethodExtensionModification isDeletion
		ifTrue: [ ^ self deletedMethodExtension: aMethodExtensionModification ].
	^ self changedMethodExtension: aMethodExtensionModification
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitor
visitExtensionMethodsModification: aMethodExtensionsModification

	aMethodExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitor
visitMethodModification: aMethodModification

	aMethodModification isAddition
		ifTrue: [ ^ self addedMethod: aMethodModification ] .
	aMethodModification isDeletion
		ifTrue: [ ^ self deletedMethod: aMethodModification ].
	^ self changedMethod: aMethodModification
%

category: 'visiting'
method: RwModificationFiletreeWriterVisitor
visitMethodsModification: aMethodsModification

	aMethodsModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
_classExtensionOf: aClassExtension
	"order is alphabetical"

	| definition |
	definition := self class orderedDictionaryClass new.

	definition at: #name put: aClassExtension name.

	^ self _toJSON: definition
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
_classExtensionSourceDir

	| filename |
	filename := classExtFileNameMap 
		at:  self currentClassExtension name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classExtBeforeFileNameMap at: self currentClassExtension name ].
	^ self _packageSourceDir / filename, 'extension'
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
_classSourceDir

	| filename |
	filename := classDefFileNameMap 
		at:  self currentClassDefinition name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classDefBeforeFileNameMap at: self currentClassDefinition name ].
	^ self _packageSourceDir / filename, 'class'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_createFileNameMapForMethods: aMethodDefinitionDictionary
  "https://github.com/dalehenrich/filetree/issues/92"

  "answer a dictionary that maps each definition selector to a filename that is guaranteed unique on case insensitive file systems"

  | map filenameMap |
  map := Dictionary new.
  aMethodDefinitionDictionary
    do: [ :mDef | 
      | sel col |
      "sort into bins by lowercase selector. "
      sel := mDef selector asLowercase.
      col := map
        at: sel
        ifAbsentPut: [ OrderedCollection new ].
      col add: mDef ].
  filenameMap := Dictionary new.
  map values
	do: [ :col | 
	  | sortedCol |
	  col size = 1
		ifTrue: [ 
		  | def |
		  "no need to distinguish filename"
		  def := col at: 1.
		  filenameMap
			at: def selector
			put: (self _methodFileNameFor: def) ]
		ifFalse: [ 
		  "tack on postfix to guarantee  file names are unique on case insensitive file systems"
		  sortedCol := col sorted: [ :a :b | a asString _unicodeLessThan: b asString ].
		  (1 to: sortedCol size) do: [ :index | 
			| def filename |
			def := sortedCol at: index.
			filename := self _methodFileNameFor: def.
			filename := filename , '..' , index printString.
			filenameMap at: def selector put: filename ] ] ].
  ^ filenameMap
%

category: 'package writing'
method: RwModificationFiletreeWriterVisitor
_filetreePackagePropertyDictFor: aPackageModification

	| propertiesFile |
	propertiesFile := self _packageSourceDir /  '.filetree'.
	propertiesFile exists
		ifFalse: [
			"create default properties file"
			propertiesFile
				writeStreamDo: [:aStream |
				aStream 
					<< (self _toJSON:
 					(self class orderedDictionaryClass new
						add: 'noMethodMetaData' -> self noMethodMetaData;
						add: 'separateMethodMetaAndSource' -> self separateMethodMetaAndSource;
						add: 'useCypressPropertiesFile' -> self useCypressPropertiesFile;
						yourself))
					<< self  _newLine ] ].
	^ self _readObjectFrom: propertiesFile
%

category: 'project writing'
method: RwModificationFiletreeWriterVisitor
_filetreeProjectPropertyDictFor: aProjectModification

	| propertiesFile |
	propertiesFile := self _projectSourceDir /  '.filetree'.
	propertiesFile exists
		ifFalse: [
			"create default properties file"
			propertiesFile
				writeStreamDo: [:aStream |
				| dict |
				dict := (self class orderedDictionaryClass new)
					at: 'packageExtension' put: '.', self packageExtension;
					at: 'Metadata' put: self monticelloMetadata;
					yourself.
				aStream 
					<< (self _toJSON: dict )
					<< self  _newLine ] ].
	^ self _readObjectFrom: propertiesFile
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_methodClassDir

	^ self _classSourceDir / 'class'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_methodClassExtensionDir

	^ self _classExtensionSourceDir / 'class'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_methodFileNameFor: aMethodDefinition
	| selector |
	selector := aMethodDefinition selector.
	^ (selector includes: $:)
	ifTrue: [ 
	  selector
		collect: [ :each | 
		  each = $:
			ifTrue: [ $. ]
			ifFalse: [ each ] ] ]
	ifFalse: [ 
	  (self class selectorSpecials includes: selector first)
		ifFalse: [ selector ]
		ifTrue: [ 
		  | output specials |
		  specials := self class selectorSpecials.
		  output := WriteStream on: String new.
		  output nextPut: $^.
		  selector
			do: [ :each | 
			  output
				nextPutAll:
				  ((specials includes: each)
					ifTrue: [ specials at: each ]
					ifFalse: [ each asString ]) ]
			separatedBy: [ output nextPut: $. ].
		  output contents ] ]
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_methodInstanceDir

	^ self _classSourceDir / 'instance'
%

category: 'method writing'
method: RwModificationFiletreeWriterVisitor
_methodInstanceExtensionDir

	^ self _classExtensionSourceDir / 'instance'
%

category: 'class writing'
method: RwModificationFiletreeWriterVisitor
_typeClassDefinitionOf: aClassDefinition
	"order is alphabetical"

	| definition |
	definition := self class orderedDictionaryClass new.

	definition 		
		at: #category put: aClassDefinition category.

	(aClassDefinition classInstVarNames)
		ifNotEmpty: [ :vars | definition at: #classinstvars put: vars asArray ].

	(aClassDefinition classVarNames)
		ifNotEmpty: [ :vars | definition at: #classvars put: vars asArray ].

	(aClassDefinition gs_constraints)
		ifNotEmpty: [:gs_constraints | definition at: #'gs_constraints' put: gs_constraints asArray ].

	(aClassDefinition gs_options)
		ifNotEmpty: [:gs_options | definition at: #'gs_options' put: gs_options asArray ].

	(aClassDefinition instVarNames)
		ifNotEmpty: [ :vars | definition at: #instvars put: vars asArray ].

	definition at: #name put: aClassDefinition name.

	((aClassDefinition poolDictionaryNames) collect: [:each | each asString])
		ifNotEmpty: [ :vars | definition at: #pools put: vars asArray ].

	definition at: #super put: aClassDefinition superclassName.

	definition at: #type put: aClassDefinition classType.

	^ self _toJSON: definition
%

! Class implementation for 'RwModificationTonelWriterVisitor'

!		Class methods for 'RwModificationTonelWriterVisitor'

category: 'accessing'
classmethod: RwModificationTonelWriterVisitor
classLabel
	^ 'Class'
%

!		Instance methods for 'RwModificationTonelWriterVisitor'

category: 'actions'
method: RwModificationTonelWriterVisitor
addedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification after.

	self processClassExtension: aClassExtensionModification
%

category: 'actions'
method: RwModificationTonelWriterVisitor
addedPackage: aPackageModification

	currentPackageDefinition := aPackageModification after.

	"create package directory and package.st file"
	self _packageSourceDir ensureCreateDirectory.
	(self _packageSourceDir /  'package.st')
		writeStreamDo: [:aStream |
		aStream 
			<< 'Package ' 
			<< (self _toSTON: { #name ->  currentPackageDefinition name } asDictionary) 
			<< self  _newLine ].

	self processPackage: aPackageModification
%

category: 'accessing'
method: RwModificationTonelWriterVisitor
defaultPackageFormat

	^ 'tonel'
%

category: 'actions'
method: RwModificationTonelWriterVisitor
deletedClass: aClassModification

	currentClassDefinition := aClassModification before.

	self _classSourceFile ensureDelete
%

category: 'actions'
method: RwModificationTonelWriterVisitor
deletedClassExtension: aClassExtensionModification

	currentClassExtension := aClassExtensionModification before.

	self _classExtensionSourceFile ensureDelete
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
processClass: aClassModification

	"write out the class definition"

	self _classSourceFile
		writeStreamDo: [:aStream |
			self _writeClassDefinition: currentClassDefinition on: aStream.
			self _writeClassSideMethodDefinitions: currentClassDefinition on: aStream.
			self _writeInstanceSideMethodDefinitions: currentClassDefinition on: aStream ]
%

category: 'class extension writing'
method: RwModificationTonelWriterVisitor
processClassExtension: aClassExtensionModification

	"write out the class definition"

	(currentClassExtension instanceMethodDefinitions isEmpty and: [ currentClassExtension classMethodDefinitions isEmpty ])
		ifTrue: [ self _classExtensionSourceFile ensureDelete ]
		ifFalse: [ 
			self _classExtensionSourceFile
				writeStreamDo: [:aStream |
					self _writeClassExtension: currentClassExtension on: aStream.
					self _writeClassSideMethodDefinitions: currentClassExtension on: aStream.
					self _writeInstanceSideMethodDefinitions: currentClassExtension on: aStream ] ]
%

category: 'project writing'
method: RwModificationTonelWriterVisitor
processProject: aProjectModification
	"confirm that the project source is written in Tonel format"

	| format propertiesFile |
	packageDefFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification after packages.
	packageDefBeforeFileNameMap := self _createFileNameMapForClassesOrPackages:  aProjectModification before packages.

	(format := self _repositoryFormatFor:  aProjectModification after packagesRoot) = 'tonel' ifFalse: [ self error: 'expected tonel format repository, instead format is ', format printString ].

	propertiesFile := aProjectModification after packagesRoot /  'properties.st'.
	propertiesFile exists
		ifFalse: [
			propertiesFile writeStreamDo: [ :fileStream | 
				fileStream 
					nextPutAll: '{ #format : ' , format printString , '}';
					lf;
					nextPutAll: '{ #convention : ' , currentProjectDefinition packageConvention printString , '}';
					yourself ] ].

	super processProject: aProjectModification.
%

category: 'class extension writing'
method: RwModificationTonelWriterVisitor
_classExtensionSourceFile

	| filename |
	filename := classExtFileNameMap 
		at:  self currentClassExtension name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classExtBeforeFileNameMap at: self currentClassExtension name ].
	^ self _packageSourceDir / (filename, '.extension.st')
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_classSourceFile

	| filename |
	filename := classDefFileNameMap 
		at:  self currentClassDefinition name
		ifAbsent: [
			"in the case of class removal, need to use the before class def map"
			classDefBeforeFileNameMap at: self currentClassDefinition name ].
	^ self _packageSourceDir / (filename, '.class.st')
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_fileNameFor: aClassDefinition
	^ String streamContents: [ :stream | 
		stream 
			<< aClassDefinition name
			<< '.' << (self _typeOfClass: aClassDefinition) asLowercase
			<< '.st'  ]
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_hasCommentOf: aClassDefinition 

	| comment |
	comment := aClassDefinition comment.
	^ comment notNil and: [ comment ~= '' ]
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_methodDefinitionOf: aMethodDefinition
	^ self _toSTON: (self class orderedDictionaryClass new 
		at: #category put: aMethodDefinition protocol; 
		yourself)
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_selectorIsComplete: keywords in: aString
	| start |
	
	start := 1.
	keywords do: [ :each | | index | 
		index := aString 
			findString: each 
			startingAt: start 
			caseSensitive: true.
		index = 0 ifTrue: [ ^ false ].
		start := index + each size ].
	^ true
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_splitMethodSource: aMethodDefinition into: aBlock
	| keywords source declaration |
	
	keywords := aMethodDefinition selector asSymbol keywords.
	source := aMethodDefinition source readStream.
	"Skip spaces"
	(source peek isSeparator) ifTrue: [ self skipSeparators: source ].
	"Skip comments"
	(source peek = $") ifTrue: [ self skipComment: source ]. 
	"Parse declaration"
	declaration := String new writeStreamPortable.
	[ (self _selectorIsComplete: keywords in: declaration originalContents) not 
		or: [ ':+-/\*~<>=@,%|&?!' includes: declaration contents trimRight last ] ]
	whileTrue: [ 
		"get separators"
		[ source atEnd not and: [ source peek isSeparator ] ]
			whileTrue: [ declaration nextPut: source next ].
		"take next word"
		[ source atEnd not and: [ source peek isSeparator not ] ]
			whileTrue: [ declaration nextPut: source next ] ].
	aBlock 
		value: (declaration contents trimLeft withLineEndings: self _newLine)
		value: (source upToEnd withLineEndings: self _newLine)
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_typeClassDefinitionOf: aClassDefinition
	| definition |
	
	definition := self class orderedDictionaryClass new 
		at: #name put: aClassDefinition name; 
		at: #superclass put: aClassDefinition superclassName;
		yourself.

	aClassDefinition classType = 'normal' ifFalse: [ 
		definition at: #type put: aClassDefinition classType ].
	
	(aClassDefinition instVarNames)
		ifNotEmpty: [ :vars | definition at: #instVars put: vars asArray ].

	(aClassDefinition classVarNames)
		ifNotEmpty: [ :vars | definition at: #classVars put: vars asArray ].
		
	((aClassDefinition poolDictionaryNames) collect: [:each | each asString])
		ifNotEmpty: [ :vars | definition at: #pools put: vars asArray ].
		
	(aClassDefinition classInstVarNames)
		ifNotEmpty: [ :vars | definition at: #classInstVars put: vars asArray ].

	(aClassDefinition gs_constraints)
		ifNotEmpty: [:gs_constraints | definition at: #'gs_constraints' put: gs_constraints asArray ].

	(aClassDefinition gs_options)
		ifNotEmpty: [:gs_options | definition at: #'gs_options' put: gs_options asArray ].

	definition 		
		at: #category put: aClassDefinition category.
	
	^ self _toSTON: definition
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_typeOfClass: aClassDefinition
	^ self class classLabel
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_writeClassDefinition: aClassDefinition on: aStream
	| nl |
	nl := self _newLine.
	
	(self _hasCommentOf: aClassDefinition) 
		ifTrue: [ 
			aStream 
				<< '"' << nl
				<< (self _commentOf: aClassDefinition) << nl
				<< '"' << nl ].
	aStream
		<< (self _typeOfClass: aClassDefinition) 
		<< ' ' << (self _typeClassDefinitionOf: aClassDefinition ) << nl
%

category: 'class extension writing'
method: RwModificationTonelWriterVisitor
_writeClassExtension: aClassExtension on: aStream

	aStream << 'Extension '
				<< (self _toSTON: {(#'name' -> aClassExtension name)} asDictionary) << self _newLine.
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_writeClassSideMethodDefinitions: aClassDefinition on: aStream
	((aClassDefinition classMethodDefinitions values )
		sortWithBlock: [ :a :b | a selector _unicodeLessThan: b selector ])
		do: [ :each | 
			self _writeMethodDefinition: each classDefinition: aClassDefinition isMeta: true on: aStream ]
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_writeInstanceSideMethodDefinitions: aClassDefinition on: aStream
	((aClassDefinition instanceMethodDefinitions values )
		sortWithBlock: [ :a :b | a selector _unicodeLessThan: b selector ])
		do: [ :each | 
			self _writeMethodDefinition: each classDefinition: aClassDefinition isMeta: false on: aStream ]
%

category: 'class writing'
method: RwModificationTonelWriterVisitor
_writeMethodDefinition: aMethodDefinition  classDefinition: aClassDefinition isMeta: isMeta on: aStream
	| nl |
	
	nl := self _newLine.
	self 
		_splitMethodSource: aMethodDefinition 
		into: [ :methodDeclaration :methodBody | | fullClassName |
			fullClassName :=aClassDefinition name  , (isMeta ifTrue: [' class'] ifFalse: ['']).
			aStream 
				<< nl 
				<< (self _methodDefinitionOf: aMethodDefinition) << nl 
				<< fullClassName << ' >> ' << methodDeclaration 
				<< ' [' << methodBody << nl << ']' << nl ]
%

! Class implementation for 'RwRepositoryComponentProjectReaderVisitor'

!		Instance methods for 'RwRepositoryComponentProjectReaderVisitor'

category: 'accessing'
method: RwRepositoryComponentProjectReaderVisitor
currentDirectory

	^ currentDirectory
%

category: 'accessing'
method: RwRepositoryComponentProjectReaderVisitor
currentDirectory: aFileReference

	currentDirectory := aFileReference
%

category: 'accessing'
method: RwRepositoryComponentProjectReaderVisitor
currentProjectReferenceDefinition

	^ currentProjectReferenceDefinition
%

category: 'accessing'
method: RwRepositoryComponentProjectReaderVisitor
currentProjectReferenceDefinition: aRwProjectReferenceDefinition

	currentProjectReferenceDefinition := aRwProjectReferenceDefinition
%

category: 'tonel parser'
method: RwRepositoryComponentProjectReaderVisitor
newClassDefinitionFrom: anArray
  | metadata |
  metadata := anArray sixth.
	currentClassExtension := nil.
  currentClassDefinition := RwClassDefinition
		newForClassNamed: (metadata at: #'name') 
			super: (metadata at: #'superclass' ifAbsent: [metadata at: #'super']) 
			instvars: (metadata at: #'instvars' ifAbsent: [ #() ]) 
			classinstvars: (metadata at: #'classinstvars' ifAbsent: [ #() ]) 
			classvars: (metadata at: #'classvars' ifAbsent: [ #() ]) 
			category: (metadata at: #'category' ifAbsent: [ ])
			comment: (anArray second ifNil: [ '' ]) 
			pools: (metadata at: #'pools' ifAbsent: [ #() ]) 
			type: (metadata at: #'type' ifAbsent: [ #'normal' ]) asSymbol.
	^ currentClassDefinition
		gs_options: (metadata at: #'gs_options' ifAbsent: [ #() ]);
		gs_constraints: (metadata at: #'gs_constraints' ifAbsent: [ #() ]);
		yourself
%

category: 'tonel parser'
method: RwRepositoryComponentProjectReaderVisitor
newClassExtensionDefinitionFrom: anArray
	| className |
	className := (anArray sixth) at: #name.
	currentClassDefinition := nil.
	^currentClassExtension := currentPackageDefinition
		classExtensionDefinitionNamed: className 
		ifAbsent: [ currentPackageDefinition addClassExtensionNamed: className ].
%

category: 'package reading'
method: RwRepositoryComponentProjectReaderVisitor
packageExtension

	^ self subclassResponsibility: #packageExtension
%

category: 'accessing'
method: RwRepositoryComponentProjectReaderVisitor
packageNames

	^ packageNames
%

category: 'accessing'
method: RwRepositoryComponentProjectReaderVisitor
packageNames: anArray

	packageNames := anArray
%

category: 'class reading'
method: RwRepositoryComponentProjectReaderVisitor
readClassesFor: packageName packageRoot: packageRoot

	^ self subclassResponsibility: #readClassesFor:packageRoot:
%

category: 'package reading'
method: RwRepositoryComponentProjectReaderVisitor
readPackages: packagesRoot
	packagesRoot directories do: [:packageDir |
		| packageName |
		packageName := self _packageNameFromPackageDir: packageDir.
		(packageDir extension = self packageExtension and: [ self packageNames includes: packageName ])
			ifTrue: [ self readClassesFor: packageName packageRoot: packageDir ] ]
%

category: 'public'
method: RwRepositoryComponentProjectReaderVisitor
visit: anObject

	anObject acceptVisitor: self.
%

category: 'visiting'
method: RwRepositoryComponentProjectReaderVisitor
visitComponentProjectDefinition: aRwComponentProjectDefinition

	self currentProjectDefinition: aRwComponentProjectDefinition.
	aRwComponentProjectDefinition packages: Dictionary new.
	self visit: aRwComponentProjectDefinition projectRef
%

category: 'visiting'
method: RwRepositoryComponentProjectReaderVisitor
visitProjectReferenceDefinition: aRwProjectReferenceDefinition
	"read the packageNames from the repository"

	self currentProjectReferenceDefinition: aRwProjectReferenceDefinition.
	self readPackages: aRwProjectReferenceDefinition packagesRoot
%

category: 'package reading'
method: RwRepositoryComponentProjectReaderVisitor
_packageNameFromPackageDir: packageDir

	"this is not really correct, but it works as a fallback (filetree does not have independent package name)"

	^ packageDir basenameWithoutExtension
%

! Class implementation for 'RwRepositoryComponentProjectFiletreeReaderVisitor'

!		Class methods for 'RwRepositoryComponentProjectFiletreeReaderVisitor'

category: 'class directory reading'
classmethod: RwRepositoryComponentProjectFiletreeReaderVisitor
readClassDirectories: directoryArray

	^ self readClassDirectories: directoryArray  projectName: '___READ_CLASS_Project___' packageName: '___READ_CLASS_Package___'
%

category: 'class directory reading'
classmethod: RwRepositoryComponentProjectFiletreeReaderVisitor
readClassDirectories: directoryArray  projectName: projectName packageName: packageName

	| visitor projectReference projectDefinition packageDefinition  |
	projectReference := RwProjectReferenceDefinition projectName: projectName useGit: false.
	projectDefinition := (RwComponentProjectDefinition newForProjectReference: projectReference)
		packageConvention: 'Rowan';
		setSymbolDictName: 'Globals' forPackageNamed: packageName;
		yourself.
	1 to: directoryArray size do: [:index |
		| directory |
		directory := directoryArray at: index.
		projectDefinition setSymbolDictName: 'Globals' forPackageNamed: packageName, '_', index asString.
		packageDefinition := projectDefinition addPackageNamed:  packageName, '_', index asString.
		visitor := self new
			currentProjectDefinition: projectDefinition;
			currentPackageDefinition: packageDefinition;
			_packageConvention: 'Rowan';
			yourself.
		visitor readClassDirectory: directory inPackage: packageDefinition name ].
	^ projectDefinition
%

category: 'class directory reading'
classmethod: RwRepositoryComponentProjectFiletreeReaderVisitor
readClassDirectory: directory

	^ self readClassDirectories: {directory}
%

category: 'class directory reading'
classmethod: RwRepositoryComponentProjectFiletreeReaderVisitor
readClassDirectory: directory projectName: projectName packageName: packageName

	^ self readClassDirectories: {directory} projectName: projectName packageName: packageName
%

!		Instance methods for 'RwRepositoryComponentProjectFiletreeReaderVisitor'

category: 'accessing'
method: RwRepositoryComponentProjectFiletreeReaderVisitor
packageExtension

	^ packageExtension 
		ifNil: [ 
			| ext |
			ext := (self _filetreeRepositoryPropertyDictFor: currentProjectReferenceDefinition packagesRoot) at: 'packageExtension'.
			packageExtension := ext copyFrom: 2 to: ext size ]
%

category: 'class reading'
method: RwRepositoryComponentProjectFiletreeReaderVisitor
readClassDirectory: classDirectory inPackage: packageName

	| classDirectoryReference classProperties classComment normalizedMetadata classDef |
	classDirectoryReference := classDirectory asFileReference.
	classProperties :=  self _readObjectFrom: classDirectoryReference / 'properties' , 'json'.
	classComment := (classDirectoryReference / 'README' , 'md') contents.
	normalizedMetadata := Dictionary new.
	classProperties keysAndValuesDo: [:key :value |
		normalizedMetadata at: key asLowercase asSymbol put: value ].
	classDef :=	self newClassDefinitionFrom: {
		nil.
		classComment. 
		nil. 
		normalizedMetadata at: 'type' ifAbsent: ['normal']. 
		nil. 
		normalizedMetadata
	}.
	self validateClassCategory: classDef forPackageNamed: packageName.
	(currentProjectDefinition packageNamed: packageName)
		addClassDefinition: currentClassDefinition.

	self readMethodDirectories: classDirectoryReference forClassDefinition: classDef inPackage: packageName
%

category: 'class reading'
method: RwRepositoryComponentProjectFiletreeReaderVisitor
readClassesFor: packageName packageRoot: packageRoot

	currentPackageDefinition := currentProjectDefinition 
		packageNamed: packageName 
		ifAbsent: [ currentProjectDefinition addPackageNamed: packageName ].
	packageRoot directories do: [:directory |
		| directoryExtension |
		directoryExtension := directory extension.
		directoryExtension = 'class'
			ifTrue: [ self readClassDirectory: directory inPackage: packageName ]
			ifFalse: [
				directoryExtension = 'extension'
					ifTrue: [ self readClassExtensionDirectory: directory  inPackage: packageName ] ] ]
%

category: 'class reading'
method: RwRepositoryComponentProjectFiletreeReaderVisitor
readClassExtensionDirectory: classExtensionDirectory inPackage: packageName

	| classExtensionProperties className package |
	classExtensionProperties :=  self _readObjectFrom: classExtensionDirectory / 'properties' , 'json'.
	className := classExtensionProperties at: 'name'.
	package := currentProjectDefinition packageNamed: packageName.
	currentClassDefinition := nil.
	currentClassExtension := package 
		classExtensionDefinitionNamed: className 
		ifAbsent: [ package addClassExtensionNamed: className ].

	self readMethodDirectories: classExtensionDirectory forClassDefinition: currentClassExtension inPackage: packageName
%

category: 'method reading'
method: RwRepositoryComponentProjectFiletreeReaderVisitor
readMethodDirectories: classDirectory forClassDefinition: classDefinition inPackage: packageName

	(self readMethodDirectory: classDirectory / 'instance' forClassDefinition: classDefinition isClassMeta: false inPackage: packageName) do: [:methodDefinition |
		classDefinition addInstanceMethodDefinition: methodDefinition ].
	(self readMethodDirectory: classDirectory / 'class' forClassDefinition: classDefinition isClassMeta: true inPackage: packageName) do: [:methodDefinition |
		classDefinition addClassMethodDefinition: methodDefinition ]
%

category: 'method reading'
method: RwRepositoryComponentProjectFiletreeReaderVisitor
readMethodDirectory: methodDirectory forClassDefinition: classDefinition isClassMeta: isClassMeta inPackage: packageName

	| methodDefinitions methodDefinitionStream |
	methodDefinitions := {}.
	methodDirectory exists ifFalse: [ ^ methodDefinitions ].

	methodDefinitionStream := methodDefinitions writeStreamPortable.
	methodDirectory files do: [:file |
		file extension = 'st'
			ifTrue: [ 
				| protocol methodSource methodStream methodDef |
				methodStream := file contents  readStreamPortable.
				protocol := methodStream nextLine.
				methodSource := methodStream upToEnd.
				methodDef := RwMethodDefinition newForSource: methodSource protocol: protocol.
				self 
					validateMethodDefinitionProtocol: methodDef 
						className: classDefinition name
						isMeta: isClassMeta 
						forPackageNamed:  packageName.
				methodDefinitionStream nextPut: methodDef ] ].

	^ methodDefinitions
%

category: 'private'
method: RwRepositoryComponentProjectFiletreeReaderVisitor
_filetreeRepositoryPropertyDictFor: packagesRoot

	^ self _readObjectFrom: packagesRoot / '.filetree'
%

! Class implementation for 'RwRepositoryComponentProjectTonelReaderVisitor'

!		Class methods for 'RwRepositoryComponentProjectTonelReaderVisitor'

category: 'class file reading'
classmethod: RwRepositoryComponentProjectTonelReaderVisitor
readClassFile: file

	^ self readClassFiles: { file }
%

category: 'class file reading'
classmethod: RwRepositoryComponentProjectTonelReaderVisitor
readClassFile: file projectName: projectName packageName: packageName

	^ self readClassFiles: { file } projectName: projectName packageName: packageName
%

category: 'class file reading'
classmethod: RwRepositoryComponentProjectTonelReaderVisitor
readClassFiles: fileArray

	^ self readClassFiles: fileArray projectName: '___READ_CLASS_Project___' packageName: '___READ_CLASS_Package___'
%

category: 'class file reading'
classmethod: RwRepositoryComponentProjectTonelReaderVisitor
readClassFiles: fileArray projectName: projectName packageName: packageName

	| visitor projectReference projectDefinition packageDefinition |
	projectReference := RwProjectReferenceDefinition projectName: projectName useGit: false.
	projectDefinition := (RwComponentProjectDefinition newForProjectReference: projectReference)
		packageConvention: 'Rowan';
		yourself.
	1 to: fileArray size do: [:index |
		| file |
		file := fileArray at: index.
		projectDefinition setSymbolDictName: 'Globals' forPackageNamed: packageName, '_', index asString.
		packageDefinition := projectDefinition addPackageNamed:  packageName, '_', index asString.
		visitor := self new
			currentProjectDefinition: projectDefinition;
			currentPackageDefinition: packageDefinition;
			_packageConvention: 'Rowan';
			yourself.
		visitor readClassFile: file inPackage: packageDefinition name ].
	^ projectDefinition
%

!		Instance methods for 'RwRepositoryComponentProjectTonelReaderVisitor'

category: 'class reading'
method: RwRepositoryComponentProjectTonelReaderVisitor
classExtensionFileExtensions

	^ #( 'extension' 'st' )
%

category: 'class reading'
method: RwRepositoryComponentProjectTonelReaderVisitor
classFileExtensions

	^ #( 'class' 'st' )
%

category: 'tonel parser'
method: RwRepositoryComponentProjectTonelReaderVisitor
definitionForType: aString
  aString = TonelWriter classLabel
    ifTrue: [ ^ #class ].
  aString = TonelWriter extensionLabel
    ifTrue: [ ^ #classExtension ].
  TonelParseError signal: 'Unknown type declaration.'
%

category: 'tonel parser'
method: RwRepositoryComponentProjectTonelReaderVisitor
newMethodDefinitionForClassNamed: className classIsMeta: meta selector: selector category: protocol source: source

	| methodDef |
	methodDef := RwMethodDefinition
		newForSelector: selector 
			protocol: protocol 
			source: source.
	self 
		validateMethodDefinitionProtocol: methodDef 
			className: className
			isMeta: meta
			forPackageNamed: self currentPackageDefinition name.
	^ methodDef
%

category: 'tonel parser'
method: RwRepositoryComponentProjectTonelReaderVisitor
newTypeDefinitionFrom: anArray
  | typeClass |
  typeClass := self definitionForType: anArray fourth.
  typeClass == #class
    ifTrue: [ ^  self newClassDefinitionFrom: anArray ].
  typeClass == #classExtension
	ifTrue: [ ^ self newClassExtensionDefinitionFrom: anArray ].
  ^ self error: 'unexpected typeClass: ', typeClass printString
%

category: 'package reading'
method: RwRepositoryComponentProjectTonelReaderVisitor
packageExtension

	^ ''
%

category: 'class reading'
method: RwRepositoryComponentProjectTonelReaderVisitor
readClassesFor: packageName packageRoot: packageRoot

	| classFileExtensions classExtensionFileExtensions |
	currentPackageDefinition := currentProjectDefinition 
		packageNamed: packageName 
		ifAbsent: [ currentProjectDefinition addPackageNamed: packageName ].
	classExtensionFileExtensions := self classExtensionFileExtensions.
	classFileExtensions := self classFileExtensions.
	packageRoot files do: [:file |
		| fileExtensions |
		fileExtensions := file extensions asArray.
		fileExtensions = classFileExtensions
			ifTrue: [ self readClassFile: file inPackage: packageName ]
			ifFalse: [
				fileExtensions = classExtensionFileExtensions
					ifTrue: [ self readClassExtensionFile: file  inPackage: packageName ] ] ]
%

category: 'class reading'
method: RwRepositoryComponentProjectTonelReaderVisitor
readClassExtensionFile: file inPackage: packageName

	| fileReference |
	fileReference := file asFileReference.
	fileReference readStreamDo: [:fileStream |
		| definitions stream |
		stream := ZnBufferedReadStream on: fileStream. "wrap with buffered stream to bypass https://github.com/GemTalk/FileSystemGs/issues/9"
		stream sizeBuffer: fileReference size. "part of workaround for GemTalk/FileSystemGs#9"
		definitions := (TonelParser on: stream forReader: self) start.
		((definitions at: 2) at: 1) do: [:mDef |
			currentClassExtension addClassMethodDefinition: mDef ].
		((definitions at: 2) at: 2) do: [:mDef |
			currentClassExtension addInstanceMethodDefinition: mDef ] ].
%

category: 'class reading'
method: RwRepositoryComponentProjectTonelReaderVisitor
readClassFile: file inPackage: packageName

	| fileReference |
	fileReference := file asFileReference.
	fileReference readStreamDo: [:fileStream |
		| definitions stream |
		stream := ZnBufferedReadStream on: fileStream. "wrap with buffered stream to bypass https://github.com/GemTalk/FileSystemGs/issues/9"
		stream sizeBuffer: fileReference size. "part of workaround for GemTalk/FileSystemGs#9"
		definitions := (TonelParser on: stream forReader: self) start.
		self validateClassCategory: currentClassDefinition forPackageNamed: packageName.
		((definitions at: 2) at: 1) do: [:mDef |
			currentClassDefinition addClassMethodDefinition: mDef ].
		((definitions at: 2) at: 2) do: [:mDef |
			currentClassDefinition addInstanceMethodDefinition: mDef ].
		(currentProjectDefinition packageNamed: packageName)
			addClassDefinition: currentClassDefinition ].
%

category: 'package reading'
method: RwRepositoryComponentProjectTonelReaderVisitor
_packageNameFromPackageDir: packageDir

	"this is not really correct, but it works as a fallback (filetree does not have independent package name)"

	^ (self _readObjectFrom: (packageDir / 'package', 'st')) at: #name
%

! Class implementation for 'RwAbstractTool'

!		Class methods for 'RwAbstractTool'

category: 'commands'
classmethod: RwAbstractTool
git

	^ RwGitTool new
%

!		Instance methods for 'RwAbstractTool'

category: 'class lookup'
method: RwAbstractTool
definitionsForClassExtensionNamed: className ifFound: foundBlock ifAbsent: absentBlock

	"validate loaded class extension registry structure"

	^ Rowan image
		loadedClassExtensionsNamed: className
		ifFound: [ :loadedClassExtensionSet | 
			loadedClassExtensionSet
				do: [ :loadedClassExtension | 
					| loadedPackage projectDef packageDef classExtensionDef |
					loadedPackage := loadedClassExtension loadedPackage.
					projectDef := loadedPackage loadedProject asDefinition.
					packageDef := projectDef packageNamed: loadedPackage name.
					classExtensionDef := packageDef classExtensions
						at: loadedClassExtension name.
					foundBlock value: classExtensionDef value: packageDef value: projectDef ].
			^ self ]
		ifAbsent: absentBlock
%

category: 'class lookup'
method: RwAbstractTool
definitionsForClassNamed: className ifFound: foundBlock ifAbsent: absentBlock

	Rowan image
		loadedClassNamed: className
		ifFound: [ :loadedClass | 
			| loadedPackage projectDef packageDef classDef |
			loadedPackage := loadedClass loadedPackage.
			projectDef := loadedPackage loadedProject asDefinition.
			packageDef := projectDef packageNamed: loadedPackage name.
			classDef := packageDef classDefinitions at: loadedClass name.
			^ foundBlock value: classDef value: packageDef value: projectDef ]
		ifAbsent: absentBlock
%

category: 'class lookup'
method: RwAbstractTool
definitionsForMethod: selector inClassNamed: className isMeta: isMeta ifFound: foundBlock ifAbsent: absentBlock

	^ Rowan image
		loadedMethod: selector
		inClassNamed: className
		isMeta: isMeta
		ifFound: [ :loadedMethod | 
			| loadedPackage loadedClass projectDef packageDef classDef classExtensionDef |
			loadedPackage := loadedMethod loadedPackage.
			loadedClass := loadedMethod loadedClass.
			projectDef := loadedPackage loadedProject asDefinition.
			packageDef := projectDef packageNamed: loadedPackage name.
			loadedClass isLoadedClass
				ifTrue: [ classDef := packageDef classDefinitions at: loadedClass name ]
				ifFalse: [ classExtensionDef := packageDef classExtensions at: loadedClass name ].
			foundBlock
				value: loadedMethod asDefinition
				value: classDef
				value: classExtensionDef
				value: packageDef
				value: projectDef.
			^ self ]
		ifAbsent: absentBlock
%

category: 'git'
method: RwAbstractTool
doGitCommit: messageString

	| gitTool gitRootPath commitMessageFileName status |
	gitTool := Rowan gitTools.
	gitRootPath := specification repoSpec repositoryRootPath.
	commitMessageFileName := gitTool createTmpFileWith: messageString.
	gitTool gitaddIn: gitRootPath with: '-A .'.
	gitTool gitcommitIn: gitRootPath with: '--file=' , commitMessageFileName.
	status := gitTool gitlogIn: gitRootPath with: '-1'.
	Transcript
		cr;
		show: '==============';
		cr;
		show: status.
	^ status
%

category: 'git'
method: RwAbstractTool
doGitUpdateLoadedCommitId

	| repoRootPath |
	repoRootPath := specification repoSpec repositoryRootPath.
	repoRootPath
		ifNil: [ 
			"in memory repo without a rootPath is legal"
			^ nil ].
	^ self doGitUpdateLoadedCommitId: repoRootPath
%

category: 'git'
method: RwAbstractTool
doGitUpdateLoadedCommitId: gitRootPath

	| gitTool loadedCommitId |
	gitTool := Rowan gitTools.
	loadedCommitId := [ gitTool gitcommitShaIn: gitRootPath asFileReference pathString ]
		on: Error
		do: [ :ignored | 
			"most likely no commits yet"
			^ nil ].
	^ specification imageSpec loadedCommitId: loadedCommitId
%

category: 'private'
method: RwAbstractTool
fileUtilities
  ^ Rowan fileUtilities
%

category: 'smalltalk api'
method: RwAbstractTool
help

	^self manPage asText
%

category: 'bash utilities'
method: RwAbstractTool
readlink: filepath

	"resolve (possible) symbolic links in filepath and return an absolute path"
	"NOTE: may need alternate solution on OSX"

	| command |
	command := self _sh_realpath_source, '; realpath ' , filepath.
	^Rowan gitTools performOnServer: command logging: true
%

category: 'smalltalk api'
method: RwAbstractTool
specification: aRwSpecification
  ^ specification := aRwSpecification
%

category: 'smalltalk api'
method: RwAbstractTool
specUrl: aString
  ^ self specification: (RwSpecification fromUrl: aString)
%

category: 'private'
method: RwAbstractTool
_sh_realpath_source

	"https://github.com/mkropat/sh-realpath/blob/master/realpath.sh"

	"all on one line because that's what our perform on server call wants - I think:)"

	^'realpath() { canonicalize_path "$(resolve_symlinks "$1")"; }; resolve_symlinks() { local dir_context path ; path=$(readlink -- "$1"); if [ $? -eq 0 ]; then dir_context=$(dirname -- "$1"); resolve_symlinks "$(_prepend_path_if_relative "$dir_context" "$path")"; else printf ''%s\n'' "$1"; fi; }; _prepend_path_if_relative() { case "$2" in /* ) printf ''%s\n'' "$2" ;; * ) printf ''%s\n'' "$1/$2" ;; esac; }; canonicalize_path() { if [ -d "$1" ]; then _canonicalize_dir_path "$1"; else _canonicalize_file_path "$1"; fi; }; _canonicalize_dir_path() { (cd "$1" 2>/dev/null && pwd -P); }; _canonicalize_file_path() { local dir file; dir=$(dirname -- "$1"); file=$(basename -- "$1"); (cd "$dir" 2>/dev/null && printf ''%s/%s\n'' "$(pwd -P)" "$file"); }'
%

category: 'private'
method: RwAbstractTool
_symbolDictionaryForSpecification

	^ Rowan image
		newOrExistingSymbolDictionaryNamed:
			(specification platformSpec at: 'gemstone') defaultSymbolDictName
%

! Class implementation for 'RwClassTool'

!		Class methods for 'RwClassTool'

category: 'commands'
classmethod: RwClassTool
clas
  ^ RwClsDiffTool new
%

! Class implementation for 'RwClsAuditTool'

!		Instance methods for 'RwClsAuditTool'

category: 'audit'
method: RwClsAuditTool
auditLoadedClass: aLoadedClass
"look for methods compiled into class without Rowan API"
| res  |

	res := self _result.
	(Rowan globalNamed: aLoadedClass name)  
		ifNil: [res add: (RwAuditDetail for: aLoadedClass message:  'Missing gemstone class for loaded class ') "aLoadedClass name -> 'Missing gemstone class for loaded class '" ] "there is no matching Class for LoadedClass"
		ifNotNil: [:aBehavior | 
			"audit class properties"
			res addAll:  (self _auditLoadedClassProperties: aLoadedClass forBehavior: aBehavior).
			"audit categories"

			aBehavior categorysDo: [:category :selectors | 
				res addAll: (self  _auditCategory: category forBehavior: aBehavior loadedClass: aLoadedClass)
			].
			aBehavior class categorysDo: [:category :selectors | 
				res  addAll: (self  _auditCategory: category forBehavior: aBehavior class loadedClass: aLoadedClass)
			].
		"audit loaded class methods"
		aLoadedClass 
			loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClass :aLoadedMethod | (aBehavior compiledMethodAt: aLoadedMethod name otherwise: nil) 
					ifNil: [(self _auditLoadedInstanceMethod: aLoadedMethod forBehavior: aBehavior loadedClass: loadedClass) ifNotNil: [:a | self errorLog: res add: a]]]

			loadedClassMethodsDo: [:loadedProject :loadedPackage :loadedClass :aLoadedMethod |(aBehavior class compiledMethodAt: aLoadedMethod name otherwise: nil) 
					ifNil: [(self _auditLoadedClassMethod: aLoadedMethod forBehavior: aBehavior class loadedClass: loadedClass)  ifNotNil: [:a | self errorLog: res add: a]]
			]
	].
	^res
%

category: 'audit'
method: RwClsAuditTool
errorLog: aResult add: aMessage	
"add error to results. print to file"
	aResult add: aMessage.
	GsFile gciLogServer: aMessage value asString,'  ', aMessage key asString.
	Notification signal: aMessage value asString,'  ', aMessage key asString.
%

category: 'audit'
method: RwClsAuditTool
errorLog: aResult addAll: aCol	
"add all messages to result"
	aCol do: [:e | self errorLog: aResult add: e].
%

category: 'audit'
method: RwClsAuditTool
_auditCategory: category forBehavior: aBehavior loadedClass: aLoadedClass
	| aPackage |
		"must be an extension. Do basic checks"
	aPackage := (category copyFrom: 2 to: category size).

	^category first == $*	ifTrue: ["must be an extension category. See if package exists"
		(aPackage asLowercase isEquivalent: aBehavior rowanPackageName asLowercase) 
			ifTrue: [{RwAuditDetail for: aLoadedClass message: 'Extension category name <', category, '>  must not match class package name.' 
							"aLoadedClass name , ' #' , category asString -> 'Extension category name can not be same as class package' "}]
			ifFalse: [
				(Rowan image loadedClassExtensionsNamed: aBehavior thisClass name 
					ifFound: [:extensions | extensions detect: [:e | e loadedPackage name asLowercase isEquivalent: aPackage] ifNone: [nil]] 
					ifAbsent: [nil]) isNil 
						ifTrue: [ | res | 
									res := self _auditCategory: category selectors: (aBehavior selectorsIn: category)  forBehavior: aBehavior loadedClass: aLoadedClass		.
						] 
						ifFalse: [{}"no basic extension problems found, class extension will be audited separately"]
			]
	] ifFalse: [
		self _auditCategory: category selectors: (aBehavior selectorsIn: category)  forBehavior: aBehavior loadedClass: aLoadedClass		
	]
%

category: 'audit'
method: RwClsAuditTool
_auditCategory: category selectors: aSelectorSet forBehavior: aBehavior loadedClass: aLoadedClass
	|  res |
	
		res := res := self _result.

		aSelectorSet do: [:aSelector |
				( self  _auditSelector: aSelector forBehavior: aBehavior loadedClass: aLoadedClass)  
					ifNotNil: [:aRes | res add: aRes]
				
		].

		^res

%

category: 'audit'
method: RwClsAuditTool
_auditClassSelector: aSelector forBehavior: aBehavior loadedClass: aLoadedClass
"audit a selector. verify compiled method matches loaded method reference return nil if no problem found"

	^(aLoadedClass loadedMethodAt: aSelector isMeta:  true)
			ifNil: [
				| notification |
				notification := (RwAuditMethodErrorNotification
					method: aSelector 
					isMeta: true
					inClassNamed: aBehavior theNonMetaClass name
					isClassExtension: aLoadedClass isLoadedClassExtension
					intoPackageNamed: aLoadedClass packageName )
						description: 'Missing loaded instance method. ';
						yourself.
				(notification signal) 
					ifTrue: [ (aLoadedClass name ,  ' >> ', aSelector) -> 'Missing loaded class method. ' ]
					ifFalse: [ 
						"don't record audit error"
						nil ] ]
			ifNotNil: [:aLoadedMethod |
				(aBehavior compiledMethodAt: aSelector  otherwise: nil) == aLoadedMethod handle
						ifTrue: [
							| expected actual |
							((expected := aLoadedMethod propertyAt: 'protocol') equalsNoCase: (actual := aBehavior categoryOfSelector:  aSelector ) ) 
								ifTrue: [nil]
								ifFalse: [aLoadedClass name , '#', (aLoadedMethod propertyAt: 'protocol') -> ('Missing class method category for loaded class (expected: ', expected printString, ' actual: ', actual printString, ')') ]
						] 
						ifFalse: [(aLoadedClass name ,  ' >> ', aSelector) -> 'Compiled class method is not identical to loaded class method '] 
			]
%

category: 'audit'
method: RwClsAuditTool
_auditLoadedClassProperties: aLoadedClass forBehavior: aBehavior
"Check #( 'instvars', 'superclass', 'classinstvars',  'gs_SymbolDictionary', 'comment', 'classvars', 'pools', 'category')"

	| res  aDict |
	res :=  self _result.
	(aLoadedClass classSuperclass isEquivalent: aBehavior superclass name ) 
		ifFalse: [res  add: (RwAuditDetail for: aLoadedClass message: 'Superclass is different from loaded class')].
	(aLoadedClass classInstVarNames = (aBehavior instVarNames collect: [:e | e asString]) ) 
			ifFalse: [res  add: (RwAuditDetail for: aLoadedClass message: 'instVarNames changed in compiled class v loaded class')].
	(aLoadedClass classClassVarNames = ((aBehavior.classVars ifNil: [SymbolDictionary new]) 
			keys collect: [:e | e asString]) asSortedCollection asArray) ifFalse: [
				res  add: (RwAuditDetail for: aLoadedClass message: 'ClassVars changed in compiled class v loaded class')].
	(aLoadedClass classPoolDictionaries = ((aBehavior.poolDictionaries ifNil: [Array new]) collect: [:e | e asString]) ) 
			ifFalse: [ res  add: (RwAuditDetail for: aLoadedClass message: 'PoolDictionaries changed in compiled class v loaded class')].
	(aLoadedClass classComment isEquivalent: aBehavior rwComment ) 
			ifFalse: [res  add: (RwAuditDetail for: aLoadedClass message: 'Comment has changed in compiled class v loaded class')].
	(aLoadedClass classCategory = aBehavior category ) 
			ifFalse: [res  add: (RwAuditDetail for: aLoadedClass message: 'Class category has changed in compiled class v loaded class')].
	(aDict := System myUserProfile resolveSymbol: aLoadedClass classSymbolDictionaryName asSymbol ) 
			ifNil: [res  add: (RwAuditDetail for: aLoadedClass message: ('Unable to find SymbolDictionary ' , aLoadedClass classSymbolDictionaryName))] 
			ifNotNil: [:smbd | smbd value at: aLoadedClass name asSymbol 
					ifAbsent: [res  add: aLoadedClass name -> 'Compiled class not found in symbol dictionary of loaded class']] .

	^res
%

category: 'audit'
method: RwClsAuditTool
_auditLoadedMethod: aLoadedMethod forBehavior: aClassOrMeta loadedClass: aLoadedClassOrExtension
"verify that compiled method is present for each loaded class method. return nil if no error"
"we already check verifying selectors that compiled method matches loaded method"

		^( aClassOrMeta compiledMethodAt: aLoadedMethod name  otherwise: nil) 
				ifNil: [RwAuditDetail for: aLoadedClassOrExtension message: 'Missing compiled method>>', aLoadedMethod name 
							"(aLoadedClassOrExtension name ,  ' >> ', aLoadedMethod name) -> 'Missing compiled class method. ' "]
				ifNotNil: [:aMethod | aMethod == aLoadedMethod handle 
						ifTrue: [((aLoadedMethod methodCategory) equalsNoCase: (aClassOrMeta categoryOfSelector: aMethod selector) ) 
							ifTrue: [nil]
							ifFalse: [RwAuditDetail for: aClassOrMeta category: aLoadedMethod methodCategory 
										message: 'Missing method category for loaded class'
								"aLoadedClassOrExtension name , '#', (aLoadedMethod properties at: 'protocol') -> 'Missing class method category for loaded class'"]
						]
						ifFalse: [RwAuditDetail for: aLoadedClassOrExtension 
										message:  'Compiled method is not identical to loaded class method>>' , aLoadedMethod name]		
			]
%

category: 'audit'
method: RwClsAuditTool
_auditSelector: aSelector forBehavior: aBehavior loadedClass: aLoadedClass
"#rentamed from _auidtClassSelector since functionality is same for instanance and class
 verify compiled method matches loaded method reference return nil if no problem found"

	^(aLoadedClass loadedMethodAt: aSelector isMeta:  aBehavior isMeta)
			ifNil: [
				| notification |
				notification := (RwAuditMethodErrorNotification
					method: aSelector 
					isMeta: aBehavior isMeta
					inClassNamed: aBehavior theNonMetaClass name
					isClassExtension: aLoadedClass isLoadedClassExtension
					intoPackageNamed: aLoadedClass packageName )
						description: 'Missing loaded method. ';
						yourself.
				(notification signal) 
					ifTrue: [ RwAuditDetail for: aBehavior message: 'Missing loaded method>>' , aSelector asString ]
					ifFalse: [ 
						"don't record audit error"
						nil ]  ]
			ifNotNil: [:aLoadedMethod |
				(aBehavior compiledMethodAt: aSelector  otherwise: nil) == aLoadedMethod handle
					ifTrue: [
						| expected actual |
						((expected := aLoadedMethod methodCategory) equalsNoCase: (actual := aBehavior categoryOfSelector:  aSelector ) ) 
							ifTrue: [nil]
							ifFalse: [RwAuditDetail for: aBehavior message: (
										'Mismatched method category (expected: ', expected printString, 
										' actual: ', actual printString, ')')
						]
					] 
					ifFalse: [RwAuditDetail for: aLoadedClass message:  'Compiled method is not identical to loaded method '
				] 
			]
%

category: 'audit'
method: RwClsAuditTool
_result

	^Array new.
%

! Class implementation for 'RwClsExtensionAuditTool'

!		Instance methods for 'RwClsExtensionAuditTool'

category: 'other'
method: RwClsExtensionAuditTool
auditLoadedClassExtension: aLoadedClassExtension
"look for methods compiled into class without Rowan API"
| res   extensionCategoryName|

	res := self _result.
	extensionCategoryName :=  aLoadedClassExtension loadedPackage asExtensionName "'*' , aLoadedClassExtension loadedPackage name" .
	(Rowan globalNamed: aLoadedClassExtension name) 
		ifNil: [(RwAuditDetail for: aLoadedClassExtension message: ' Class does not exists for loaded class extension')] 
		ifNotNil: [:aBehavior ||categories | 
					
			categories := (aBehavior _baseCategorys: 0)
				ifNil: [ #() ]
				ifNotNil: [:catDict | catDict keys ].
			(categories	
				detect: [:each | each equalsNoCase: extensionCategoryName ] ifNone: [ ])
					ifNotNil: [:aCategory | res  addAll:  (self _auditCategory: aCategory forBehavior: aBehavior loadedClass: aLoadedClassExtension)]
					ifNil: [aLoadedClassExtension loadedInstanceMethods notEmpty ifTrue: [
						res add: (RwAuditDetail for: aLoadedClassExtension message: 'Missing instance method extension category named ', extensionCategoryName) ] ].

			categories := (aBehavior class _baseCategorys: 0)
				ifNil: [ #() ]
				ifNotNil: [:catDict | catDict keys ].
			(categories
				detect: [:each | each equalsNoCase: extensionCategoryName ] ifNone: [ ])
					ifNotNil: [:aCategory | res  addAll:  (self _auditCategory: aCategory forBehavior: aBehavior class loadedClass: aLoadedClassExtension)]
					ifNil: [aLoadedClassExtension loadedClassMethods notEmpty ifTrue: [
						res add: (RwAuditDetail for: aLoadedClassExtension message: 'Missing class method extension category named ' ,extensionCategoryName) ] ].

			aLoadedClassExtension 
				loadedInstanceMethodsDo: [:loadedProject :loadedPackage :loadedClass :aLoadedMethod | 
					(self _auditLoadedMethod: aLoadedMethod forBehavior: aBehavior loadedClass: loadedClass) ifNotNil: [:x | res add: x]
				] 
				loadedClassMethodsDo: [:loadedProject :loadedPackage :loadedClass :aLoadedMethod |
					(self _auditLoadedMethod: aLoadedMethod forBehavior: aBehavior class loadedClass: loadedClass) ifNotNil: [:x | res add: x]
				]
		].
		^res
%

category: 'other'
method: RwClsExtensionAuditTool
_auditCategory: anExtentionCategory forBehavior: aClassOrMeta loadedClass: aLoadedClassExtension
"if we have loaded methods but no compiled methods add error to result"
| res |
	res := super _auditCategory: anExtentionCategory selectors:  (aClassOrMeta selectorsIn: anExtentionCategory) forBehavior: aClassOrMeta loadedClass: aLoadedClassExtension.
	aClassOrMeta isMeta 
		ifTrue: [
			(aLoadedClassExtension loadedClassMethods notEmpty and: [(aClassOrMeta selectorsIn: anExtentionCategory) isEmpty])
				ifTrue: [res  add: (RwAuditDetail for: aLoadedClassExtension 
								message:  'Missing expected class methods in the category ', ' #' , anExtentionCategory asString )   ].
	] 	ifFalse: [
			(aLoadedClassExtension loadedInstanceMethods notEmpty and: [(aClassOrMeta selectorsIn: anExtentionCategory) isEmpty])
				ifTrue: [ res  add: (RwAuditDetail for: aLoadedClassExtension 
								message: 'Missing expected instances methods in the category' , ' #' , anExtentionCategory asString)   ].
	].
	^res
%

! Class implementation for 'RwGitTool'

!		Instance methods for 'RwGitTool'

category: 'smalltalk api'
method: RwGitTool
gitaddIn: gitRepoPath with: args

	^ self performGitCommand: 'add' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitbranchIn: gitRepoPath with: args

	^ self performGitCommand: 'branch' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitBranchNameIn: gitRepoPath

	"return current branch for git repository located at gitPath"

	| command result |
	command := 'set -e; cd ' , gitRepoPath , ';git branch | sed -n ''/\* /s///p'''.
	result := self performOnServer: command logging: false.
	^ result trimWhiteSpace
%

category: 'smalltalk api'
method: RwGitTool
gitcheckoutIn: gitRepoPath with: args

	^ self performGitCommand: 'checkout' in: gitRepoPath pathString with: args
%

category: 'smalltalk api'
method: RwGitTool
gitcloneIn: gitRootPath with: args

	^ self gitcloneIn: gitRootPath with: args logging: true
%

category: 'smalltalk api'
method: RwGitTool
gitcloneIn: gitRootPath with: gitArgs logging: logging

	| commandBase command gitCommand |
	gitCommand := 'clone'.
	commandBase := 'set -e; cd ' , gitRootPath , '; git ' , gitCommand , ' '.
	command := commandBase , gitArgs.
	^ self performOnServer: command logging: logging
%

category: 'smalltalk api'
method: RwGitTool
gitcommitIn: gitRepoPath with: args

	^ self performGitCommand: 'commit' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitcommitShaIn: gitRepoPath

	| result |
	gitRepoPath ifNil: [ ^ '' ].
	result := self gitlogIn: gitRepoPath with: ' -1 --pretty=format:%h '.
	(result beginsWith: 'fatal:')
		ifTrue: [ ^ nil ].
	^ result trimWhiteSpace
%

category: 'smalltalk api'
method: RwGitTool
gitinitIn: dirPath with: args

	| command |
	command := 'set -e; cd ' , dirPath , '; git init ' , args.
	^ self performOnServer: command logging: true
%

category: 'smalltalk api'
method: RwGitTool
gitlogFull: commitish limit: limit gitRepoDirectory: gitRepoPath

	| commitLog |
	commitLog := self
		gitlogIn: gitRepoPath
		with: ' -' , limit printString , ' ' , commitish.
	^ commitLog
%

category: 'smalltalk api'
method: RwGitTool
gitlogIn: gitRepoPath with: args

	^ self performGitCommand: 'log' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitlogtool: commitish limit: limit gitRepoDirectory: gitRepoPath

	^ self
		gitlogIn: gitRepoPath
		with:
			'--date=relative --format="%h %cd %s" -' , limit printString , ' ' , commitish
%

category: 'smalltalk api'
method: RwGitTool
gitPresentIn: gitRepoPath

	| gitHome command cdResponse |
	[ 
	gitHome := self gitrevparseShowTopLevelIn: gitRepoPath.
	command := 'set -e; cd ' , gitRepoPath , '; pwd'.
	cdResponse := self performOnServer: command logging: true ]
		on: Error
		do: [ :ex | ^ false ].
	^ (self readlink: gitHome) = (self readlink: cdResponse)
%

category: 'smalltalk api'
method: RwGitTool
gitpullIn: gitRepoPath

	^ self gitpullIn: gitRepoPath with: ''
%

category: 'smalltalk api'
method: RwGitTool
gitpullIn: gitRepoPath remote: remoteName branch: branchName

	^ self gitpullIn: gitRepoPath with: remoteName , ' ' , branchName
%

category: 'smalltalk api'
method: RwGitTool
gitpullIn: gitRepoPath with: args

	^ self performGitCommand: 'pull' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitpushIn: gitRepoPath remote: remoteName branch: branchName

	^ self gitpushIn: gitRepoPath with: remoteName , ' ' , branchName
%

category: 'smalltalk api'
method: RwGitTool
gitpushIn: gitRepoPath with: args

	^ self performGitCommand: 'push' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitrevparseShowTopLevelIn: dirPath

	| command |
	command := 'set -e; cd ' , dirPath , '; git rev-parse --show-toplevel'.
	^ self performOnServer: command logging: true
%

category: 'smalltalk api'
method: RwGitTool
gitstatusIn: gitRepoPath with: args

	^ self performGitCommand: 'status' in: gitRepoPath with: args
%

category: 'private'
method: RwGitTool
performGitCommand: gitCommand in: gitRepoPath with: gitArgs

	^ self
		performGitCommand: gitCommand
		in: gitRepoPath
		worktree: gitRepoPath
		with: gitArgs
		logging: true
%

category: 'private'
method: RwGitTool
performGitCommand: gitCommand in: gitRepoPath worktree: workTreePath with: gitArgs logging: logging

	"unconditional cd to work-tree because of git pull problem with git prior to 1.7.7.2"

	| commandBase command |
	commandBase := 'set -e; cd ' , workTreePath , '; git --git-dir ' , gitRepoPath
		, '/.git --work-tree ' , workTreePath , ' ' , gitCommand , ' '.
	command := commandBase , gitArgs.
	^ self performOnServer: command logging: logging
%

category: 'private'
method: RwGitTool
performOnServer: commandLine logging: logging
  | result |
  result := self
    performOnServer: commandLine
    status: [ :performOnServerStatusArray | 
      "Array of 5 elements: 
       raw status Integer, 
       child process status Integer (after WEXITSTATUS macro applied), 
       result String (or nil if operation failed) ,
       error string from script file write, fork, or result file read ,
       errno value, a SmallInteger from file write, fork, or file read"
      (performOnServerStatusArray at: 1) ~~ 0
        ifTrue: [ 
          | message |
          message := 'performOnServer: ' , commandLine printString , ' stdout: '
            , (performOnServerStatusArray at: 3) printString
            , ' failed with status: '
            , (performOnServerStatusArray at: 1) printString , ' errno: '
            , (performOnServerStatusArray at: 5) printString , ' errStr: '
            , (performOnServerStatusArray at: 4) asString.
          self error: message ].
      performOnServerStatusArray at: 3 ].
  logging
    ifTrue: [ 
      Transcript
        cr;
        show: commandLine printString;
        cr;
        show: result ].
  ^ result
%

! Class implementation for 'RwPackageTool'

!		Class methods for 'RwPackageTool'

category: 'commands'
classmethod: RwPackageTool
adopt
  ^ RwPkgAdoptTool new
%

category: 'commands'
classmethod: RwPackageTool
audit
  ^ RwPkgAuditTool new
%

category: 'commands'
classmethod: RwPackageTool
create
  ^ RwPkgCreateTool new
%

category: 'commands'
classmethod: RwPackageTool
diff
  ^ RwPkgDiffTool new
%

category: 'commands'
classmethod: RwPackageTool
disown
  ^ RwPkgDisownTool new
%

category: 'commands'
classmethod: RwPackageTool
load
  ^ RwPkgLoadTool new
%

! Class implementation for 'RwPkgAdoptTool'

!		Instance methods for 'RwPkgAdoptTool'

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassExtensionNamed: className  instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName

	"adopt extension methods for the class named <className> into the package named <packageName>"

	self 
		adoptClassNamed: className 
		classExtension: true 
		instanceSelectors: instanceSelectors 
		classSelectors: classSelectors 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassNamed: className classExtension: classExtension instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName

	"adopt the methods for class named <className> and it's methods into the package named <packageName>, 
		if it is not a <classExtension>, adopt the class into the package as well."

	"Ignore packaged instance and class methods"

	| loadedPackage loadedProject packageSymDictName theClass theSymbolDictionary
		registry theBehavior actualPackageSymDictName |
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	packageSymDictName := (loadedProject symbolDictNameForPackageNamed: packageName) asSymbol.

	theClass := Rowan globalNamed: className.
	theClass ifNil: [ 
		(RwAdoptMissingClassErrorNotification classNamed: className isClassExtension: classExtension  intoPackageNamed: packageName) signal.
		"if exception resumed then we'll skip the adopt operation for this class"
		^ self ].
	(Rowan image symbolList dictionariesAndSymbolsOf: theClass)
		do: [:ar |
			actualPackageSymDictName := (ar at: 1) name.
			actualPackageSymDictName == packageSymDictName
				ifTrue: [ theSymbolDictionary := (ar at: 1). ] ].
	theSymbolDictionary 
		ifNil: [ 
			self error: 'The symbol dictionary for class ', 
				className printString, 
				' (', actualPackageSymDictName, ') does not match the expected symbol dictionary for the package ', 
				packageName printString, 
				'. (', packageSymDictName, '). REQUIRED.'.]. 

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	classExtension
		ifFalse: [
			[ registry
				addClassAssociation: (theSymbolDictionary associationAt: theClass name) 
				forClass: theClass 
				toPackageNamed: packageName ]
					on: RwExistingAssociationWithSameKeyNotification
					do: [:ex | ex resume ] ].

	theBehavior := theClass.
	instanceSelectors do: [:methodSelector |
		| theCompiledMethod |
		theCompiledMethod := (theBehavior compiledMethodAt: methodSelector  otherwise: nil)
			ifNil: [ 
				(RwAdoptMissingMethodErrorNotification method: methodSelector isMeta: false inClassNamed: className isClassExtension: classExtension  intoPackageNamed: packageName) signal.
				"skip adoption of this method"
				nil ].
		theCompiledMethod
			ifNotNil: [ 
				registry
					adoptCompiledMethod: theCompiledMethod
					classExtension: classExtension
					for: theBehavior 
					protocol: (theBehavior categoryOfSelector: methodSelector) 
					toPackageNamed: packageName ] ] .

	theBehavior := theClass class.
	classSelectors do: [:methodSelector |
		| theCompiledMethod |
		theCompiledMethod := (theBehavior compiledMethodAt: methodSelector  otherwise: nil)
			ifNil: [ (RwAdoptMissingMethodErrorNotification method: methodSelector isMeta: true inClassNamed: className isClassExtension: classExtension  intoPackageNamed: packageName) signal.
				"skip adoption of this method"
				nil ].
		theCompiledMethod
			ifNotNil: [ 
				registry
					adoptCompiledMethod: theCompiledMethod 
					classExtension: classExtension
					for: theBehavior 
					protocol: (theBehavior categoryOfSelector: methodSelector) 
					toPackageNamed: packageName ] ].
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassNamed: className  instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName

	"adopt the class named <className> and it's methods into the package named <packageName>"

	"Ignore packaged instance and class methods"
	
	self 
		adoptClassNamed: className 
		classExtension: false 
		instanceSelectors: instanceSelectors 
		classSelectors: classSelectors 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassNamed: className  intoPackageNamed: packageName

	"adopt the class named <className> and it's methods into the package named <packageName>"

	"Ignore packaged instance and class methods"

	| theClass |

	theClass := Rowan globalNamed: className.
	self 
		adoptClassNamed: className 
		instanceSelectors: theClass selectors 
		classSelectors: theClass class selectors 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptMethod: methodSelector inClassNamed: className  isMeta: isMeta intoPackageNamed: packageName

	"adopt the method <methodSelector> in class named <className> and it's methods into the package named <packageName>"

	| theClass theBehavior protocolString  |
	theClass := Rowan globalNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].
	protocolString := (theBehavior categoryOfSelector: methodSelector asSymbol) asString. 
	self 
		adoptMethod: methodSelector 
		protocol: protocolString 
		inClassNamed: className  
		isMeta: isMeta 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptMethod: methodSelector protocol: protocolString inClassNamed: className  isMeta: isMeta intoPackageNamed: packageName

	"adopt the method <methodSelector> in class named <className> and it's methods into the package named <packageName>.
		move the method into protocol <protocolString> "

	| loadedPackage loadedProject packageSymDictName theClass theSymbolDictionary registry 
		theBehavior theCompiledMethod |
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	packageSymDictName := loadedProject symbolDictNameForPackageNamed: packageName.

	theClass := Rowan globalNamed: className.
	theSymbolDictionary := Rowan globalNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].

	theCompiledMethod := theBehavior compiledMethodAt: methodSelector.

	theCompiledMethod rowanProjectName = Rowan unpackagedName
		ifFalse: [ self error: 'The method ', className printString, '>>', methodSelector asString, ' is already packaged ... no need to adopt' ].

	theClass  rowanPackageName ~= packageName
		ifTrue: [ 
			registry
				addExtensionCompiledMethod: theCompiledMethod 
				for: theBehavior 
				protocol: protocolString 
				toPackageNamed: packageName ]
		ifFalse: [ 
			registry
				adoptCompiledMethod: theCompiledMethod 
				classExtension: false
				for: theBehavior 
				protocol: protocolString
				toPackageNamed: packageName ].
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolDictionary: symbolDictionary intoPackageNamed: packageName

	"create loaded classes in the loaded package <packageName> for the unpackaged classes in <symbolDictionary>"

	symbolDictionary keysAndValuesDo: [:className :object |
		object isBehavior
			ifTrue: [ 
				object rowanPackageName = Rowan unpackagedName
					ifTrue: [ self adoptClassNamed: className asString intoPackageNamed: packageName ] ] ]
.
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolDictionaryNamed: symDictName intoPackageNamed: packageName

	"create loaded classes in the loaded package <packageName> for the unpackaged classes in the symbol dictionary named <symDictName>"

	^ self adoptSymbolDictionary: (Rowan globalNamed: symDictName) intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolList: symbolList excluding: excludedSymbolDictionaries intoPackagesNamed: packageNameMap

	"create loaded classes for the unpackaged classes in each of the symbol dictionaries in symbolList, except for those listed in
		<excludedSymbolDictionaries>. The loaded classes should be created in the package associated with the name of the symbol 
		dictionary in <packageNameMap>"

	symbolList do: [:symbolDict |
		(excludedSymbolDictionaries includes: symbolDict)
			ifFalse: [ self adoptSymbolDictionary: symbolDict intoPackageNamed: (packageNameMap at: symbolDict name asString) ] ]
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolList: symbolList excludingSymbolDictsNamed: excludedSymbolDictionaryNames intoPackagesNamed: packageNameMap

	"create loaded classes for the unpackaged classes in each of the symbol dictionaries in symbolList, except for those named in
		<excludedSymbolDictionaryNames>. The loaded classes should be created in the package associated with the name of the symbol 
		dictionary in <packageNameMap>"

	symbolList do: [:symbolDict |
		| symDictName |
		symDictName := symbolDict name asString.
		(excludedSymbolDictionaryNames includes: symDictName)
			ifFalse: [ self adoptSymbolDictionary: symbolDict intoPackageNamed: (packageNameMap at: symDictName) ] ]
%

! Class implementation for 'RwPkgCreateTool'

!		Instance methods for 'RwPkgCreateTool'

category: 'smalltalk api'
method: RwPkgCreateTool
createLoadedPackageNamed: packageName inProjectNamed: projectName

	"create a loaded package named <packageName> in the loaded project named <projectName>"

	| registry theSymbolDictionary packageSymDictName loadedPackage loadedProject |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	packageSymDictName := loadedProject symbolDictNameForPackageNamed: packageName.
	theSymbolDictionary := Rowan image newOrExistingSymbolDictionaryNamed: packageSymDictName.
	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.
	loadedPackage := registry newLoadedPackageNamed: packageName.
	loadedProject addLoadedPackage: loadedPackage.
%

! Class implementation for 'RwPkgDiffTool'

!		Instance methods for 'RwPkgDiffTool'

category: 'smalltalk api'
method: RwPkgDiffTool
patchForPackageName: packageName

	| loadedPackage loadedProject repo diskSnapshot imageSnapshot |
self deprecated: 'patchForPackageName: deprecated in favor or RwPrjDiffTool>>patchesForProjectNamed:'.
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.
	super specification: loadedProject specification.
	repo := specification repositoryUrl asRwRepository.
	diskSnapshot := (repo readPackageStructureForPackageNamed: packageName)
		snapshot.
	imageSnapshot := (RwCypressPackageStructure
		fromPackage: loadedPackage asDefinition) snapshot.
	^ CypressPatch fromBase: diskSnapshot toTarget: imageSnapshot
%

! Class implementation for 'RwPkgDisownTool'

!		Instance methods for 'RwPkgDisownTool'

category: 'classes'
method: RwPkgDisownTool
disownClassExtensionMethodsInClassNamed: className forPackageNamed: packageName

	"Remove the extension methods in the named class for the named package"

	"The methods are not removed from the system"

	"use:
		Rowan packageTools adopt
			adoptClassExtensionNamed: className  instanceSelectors: <instanceSelectors> classSelectors: <classSelectors> intoPackageNamed: packageName
	to restore the classes and methods to the loaded things"

	| loadedPackage loadedProject loadedClassExtension packageSymDictName theClass theSymbolDictionary registry |
	theClass := Rowan globalNamed: className.

	loadedClassExtension := (Rowan image loadedClassExtensionsForClass: theClass) 
		detect: [:classExtension |  classExtension loadedPackage name = packageName ]
		ifNone: [ self error: 'No class extensions for the package ' , packageName printString, ' found in the class ' , className printString ].

	loadedPackage := loadedClassExtension loadedPackage.
	loadedProject := loadedPackage loadedProject.

	packageSymDictName := loadedProject symbolDictNameForPackageNamed: packageName.

	theSymbolDictionary := Rowan globalNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	registry disownClassExtensions: theClass forLoadedPackage: loadedPackage
%

category: 'classes'
method: RwPkgDisownTool
disownClassNamed: className

	"Remove the specified class and all of it's packaged instance and class methods from the loaded things. Methods that are not in the same package as
		the class are not disowned. "

	"The classes and methods are not removed from the system"

	"use:
		Rowan packageTools adopt
			adoptClassNamed: className classExtension: classExtension instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: <packageName>
	to restore the classes and methods to the loaded things"

	| packageName loadedPackage loadedProject packageSymDictName theClass theSymbolDictionary registry |
	theClass := Rowan globalNamed: className.

	theClass rowanProjectName = Rowan unpackagedName
		ifTrue: [ self error: 'The class ', className printString, ' is not packaged ... cannot disown an unpackaged class' ].

	packageName := theClass rowanPackageName.
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	packageSymDictName := loadedProject symbolDictNameForPackageNamed: packageName.

	theSymbolDictionary := Rowan globalNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	registry disownClass: theClass
%

category: 'methods'
method: RwPkgDisownTool
disownMethod: methodSelector inClassNamed: className isMeta: isMeta

	"remove the specified method from the loaded things. The method becomes unpackaged, but is not remove the system."

	"use:
		Rowan packageTools adopt
			adoptMethod: methodSelector inClassNamed: className  isMeta: isMeta intoPackageNamed: <packageName>
	to restore the specified method to the loaded things"

	| packageName loadedPackage loadedProject packageSymDictName theClass theSymbolDictionary registry 
		theBehavior theCompiledMethod |
	theClass := Rowan globalNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].
	theCompiledMethod := theBehavior compiledMethodAt: methodSelector.

	theCompiledMethod rowanProjectName = Rowan unpackagedName
		ifTrue: [ self error: 'The method ', className printString, '>>', methodSelector asString, ' is not packaged ... no need to disown' ].

	packageName := theCompiledMethod rowanPackageName.
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	packageSymDictName := loadedProject symbolDictNameForPackageNamed: packageName.

	theSymbolDictionary := Rowan globalNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	registry _doDeleteCompiledMethodFromLoadedThings: theCompiledMethod for: theBehavior
%

category: 'packages'
method: RwPkgDisownTool
disownPackageNamed: packageName

	"Remove the classes and methods managed by the package from the loaded things."

	"The classes and methods are not removed from the system"

	"Use the adopt tool to restore the classes and methods to the loaded things"

	| loadedPackage registry |

	loadedPackage := Rowan image loadedPackageNamed: packageName.
	registry :=Rowan image loadedRegistryForPackageNamed: packageName.

	loadedPackage loadedClasses values
		do: [:loadedClass | 
			| class |
			class := Rowan globalNamed: loadedClass key.
			loadedClass disownFromLoaded: registry.
			registry classRegistry removeKey: class classHistory ].

	loadedPackage loadedClassExtensions values 
		do: [:loadedClassExtension | 
			| class |
			class := Rowan globalNamed: loadedClassExtension key.
			loadedClassExtension disownFromLoaded: registry ].

	registry deletePackage: packageName
%

! Class implementation for 'RwPkgLoadTool'

!		Instance methods for 'RwPkgLoadTool'

category: 'smalltalk api'
method: RwPkgLoadTool
loadPackageSetDefinition: packageSetDefinitionToLoad

	^ self
		loadPackageSetDefinition: packageSetDefinitionToLoad
		instanceMigrator: Rowan platform instanceMigrator
%

category: 'smalltalk api'
method: RwPkgLoadTool
loadPackageSetDefinition: packageSetDefinitionToLoad instanceMigrator: instanceMigrator

	"NOTE: not sure that we want to support the loading of arbitrary package sets (mixed projects) ... used by relatively old tests at the moment ... should be legal if the we create some project sets where the package to be loaded replace the packages in definitions derived from loaded things ... do a single load with proper updating of loaded packages in specification ..."

	| loadedPackageSet diff loadedEntitySet |
	loadedEntitySet := packageSetDefinitionToLoad deriveLoadedThings.
	loadedPackageSet := loadedEntitySet asPackageDefinitionSet.
	diff := packageSetDefinitionToLoad compareAgainstBase: loadedPackageSet.
	diff isEmpty
		ifTrue: [ 
			| msg |
			msg := 'The packages are already up to date'.
			self inform: msg.
			^ msg ].
	Rowan image applyModification_254: diff instanceMigrator: instanceMigrator.
	^ diff
%

! Class implementation for 'RwPkgAuditTool'

!		Instance methods for 'RwPkgAuditTool'

category: 'other'
method: RwPkgAuditTool
auditForPackage: loadedPackage
"audit dirty packages"
	|  res|
	res := RwAuditReport for: loadedPackage.
	"self _log: '===Auditing package ', loadedPackage name."
	loadedPackage 
				loadedClassesDo: [:aLoadedClass |  (self auditLoadedClass: aLoadedClass) 
					ifNotEmpty: [:aColl | res at: aLoadedClass name put: aColl]]				
				loadedClassExtensionsDo: [:aLoadedClass | (self auditLoadedClassExtension: aLoadedClass) 
					ifNotEmpty: [:aColl | res at: aLoadedClass name put: aColl] ] .
	^res
%

category: 'other'
method: RwPkgAuditTool
auditForPackageNamed: packageName
	
	^self auditForPackage: (Rowan image loadedPackageNamed: packageName).
%

category: 'other'
method: RwPkgAuditTool
auditLoadedClass: aLoadedClass
"look for methods compiled into class without Rowan API"

	^RwClsAuditTool new auditLoadedClass: aLoadedClass.
%

category: 'other'
method: RwPkgAuditTool
auditLoadedClassExtension: aLoadedClass
"look for methods compiled into class without Rowan API"

	^RwClsExtensionAuditTool new auditLoadedClassExtension: aLoadedClass
%

category: 'other'
method: RwPkgAuditTool
_addAll: aColl to: aDict for: aName

	aDict at: aName ifAbsentPut: [aColl].
%

! Class implementation for 'RwProjectTool'

!		Class methods for 'RwProjectTool'

category: 'commands'
classmethod: RwProjectTool
adopt

	^ RwPrjAdoptTool new
%

category: 'commands'
classmethod: RwProjectTool
audit

	^RwPrjAuditTool new
%

category: 'commands'
classmethod: RwProjectTool
browser

	^ RwPrjBrowserTool new
%

category: 'commands'
classmethod: RwProjectTool
checkout

	^RwPrjCheckoutTool new
%

category: 'commands'
classmethod: RwProjectTool
clone

	^RwPrjCloneTool new
%

category: 'commands'
classmethod: RwProjectTool
commit

	^RwPrjCommitTool new
%

category: 'commands'
classmethod: RwProjectTool
create
  ^ RwPrjCreateTool new
%

category: 'commands'
classmethod: RwProjectTool
delete

	^ RwPrjDeleteTool new
%

category: 'commands'
classmethod: RwProjectTool
diff

	^ RwPrjDiffTool new
%

category: 'commands'
classmethod: RwProjectTool
disown

	^ RwPrjDisownTool new
%

category: 'commands'
classmethod: RwProjectTool
edit

	^ RwPrjEditTool new
%

category: 'commands'
classmethod: RwProjectTool
load

	^RwPrjLoadTool new
%

category: 'commands'
classmethod: RwProjectTool
log

	^RwPrjLogTool new
%

category: 'commands'
classmethod: RwProjectTool
pull

	^RwPrjPullTool new
%

category: 'commands'
classmethod: RwProjectTool
push

	^RwPrjPushTool new
%

category: 'commands'
classmethod: RwProjectTool
query

	^ RwPrjQueryTool new
%

category: 'commands'
classmethod: RwProjectTool
read
  ^ RwPrjReadTool new
%

category: 'commands'
classmethod: RwProjectTool
reconcile

	^ RwPrjReconcileTool new
%

category: 'commands'
classmethod: RwProjectTool
revert

	^RwPrjRevertTool new
%

category: 'commands'
classmethod: RwProjectTool
test

	^RwPrjTestTool new
%

category: 'commands'
classmethod: RwProjectTool
write

	^RwPrjWriteTool new
%

!		Instance methods for 'RwProjectTool'

category: 'smalltalk api'
method: RwProjectTool
repositoryUrl
  ^ self specification repositoryUrl
%

! Class implementation for 'RwPrjAdoptTool'

!		Instance methods for 'RwPrjAdoptTool'

category: 'smalltalk api'
method: RwPrjAdoptTool
adoptProjectDefinition: projectDefinition

	| pkgAdoptTool |
	pkgAdoptTool := Rowan packageTools adopt.
	projectDefinition packages valuesDo: [:packageDef |
		packageDef classDefinitions valuesDo: [:classDef |
			pkgAdoptTool
				adoptClassNamed: classDef name 
				instanceSelectors: classDef instanceMethodDefinitions keys 
				classSelectors: classDef classMethodDefinitions keys 
				intoPackageNamed: packageDef name].
		packageDef classExtensions valuesDo: [:classDef |
			pkgAdoptTool
				adoptClassExtensionNamed: classDef name 
				instanceSelectors: classDef instanceMethodDefinitions keys 
				classSelectors: classDef classMethodDefinitions keys 
				intoPackageNamed: packageDef name ] ]
%

category: 'smalltalk api'
method: RwPrjAdoptTool
adoptProjectSetDefinition: projectSetDefinitionToAdopt

	projectSetDefinitionToAdopt projects do: [:projectDef |
		self adoptProjectDefinition: projectDef ]
%

! Class implementation for 'RwPrjAuditTool'

!		Instance methods for 'RwPrjAuditTool'

category: 'other'
method: RwPrjAuditTool
auditAll
	
	^self auditAllForUser: System myUserProfile userId
%

category: 'other'
method: RwPrjAuditTool
auditAllForUser: aUserId
| res |
	res := StringKeyValueDictionary new.
			(Rowan image  _loadedProjectRegistryForUserId: aUserId) keysAndValuesDo: [:prjName :aLoadedProject |
				(self auditForProject: aLoadedProject) ifNotEmpty: [:aColl | res at: prjName put: aColl]
	].
	^res
%

category: 'other'
method: RwPrjAuditTool
auditForProject: aLoadedProject
"audit loaded project"

	| res |

	res := RwAuditReport for: aLoadedProject.
	"self _log: '==============Auditing project ', aLoadedProject name."
		aLoadedProject loadedPackages values do: [:e | (Rowan packageTools audit auditForPackage: e) 
				ifNotEmpty: [:aColl | res at: e name put: aColl]].	
	^res
%

category: 'other'
method: RwPrjAuditTool
auditForProjectNamed: aProjectName

	^self auditForProject: (Rowan image loadedProjectNamed: aProjectName)
%

category: 'other'
method: RwPrjAuditTool
auditForProjectsNamed: aCol
"audit all named projects"
	
	| res |
	res := Array new.
		aCol do: [:prjName | res addAll: (self auditForProjectNamed: prjName )	].
	^res
%

category: 'other'
method: RwPrjAuditTool
auditProjectsNamed: aCol
"audit all named projects"
	
	| res |
	res := Array new.
		aCol do: [:prjName | res addAll: (self auditForProjectNamed: prjName )	].
	^res
%

! Class implementation for 'RwPrjBrowserTool'

!		Instance methods for 'RwPrjBrowserTool'

category: 'class browsing'
method: RwPrjBrowserTool
addOrUpdateClassDefinition: className type: type superclass: superclassName instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: category packageName: packageName constraints: constraintsArray options: optionsArray

	| loadedPackage loadedProject loadedClass theOptions theConstraints |
	loadedPackage := self
		_loadedPackageNamed: packageName
		ifAbsent: [ self error: 'No package named ' , packageName printString , ' found' ].
	loadedProject := loadedPackage loadedProject.
	anArrayOfPoolDicts isEmpty
		ifFalse: [ self error: 'poolDictionaries not supported yet' ].
	loadedClass := self _loadedClassNamed: className ifAbsent: [  ].
	theOptions := optionsArray collect: [:each | each asString ].
	(constraintsArray isKindOf: Array)
		ifTrue: [
			theConstraints := {}.
			constraintsArray do: [:ar |
				(ar isKindOf: Array)
					ifTrue: [ theConstraints add: { (ar at: 1) asString . (ar at: 2) name asString } ]
					ifFalse: [ theConstraints add: ar name asString ] ] ]
		ifFalse: [
			theConstraints := constraintsArray
				ifNil: [ #() ]
				ifNotNil: [ constraintsArray ]].
	loadedClass
		ifNil: [ 
			| classDef |
			"create a new class"
			classDef := RwClassDefinition
				newForClassNamed: className
				super: superclassName
				instvars: anArrayOfStrings
				classinstvars: anArrayOfClassInstVars
				classvars: anArrayOfClassVars
				category: category
				comment: nil
				pools: #()
				type: type.
			classDef gs_options: theOptions.
			classDef gs_constraints: theConstraints.
			self createClass: classDef inPackageNamed: packageName ]
		ifNotNil: [ 
			self class edit
				definitionsForClassNamed: className
				ifFound: [ :classDef :packageDef :projectDef | 
					| classProjectDef projectSetDef |
					classProjectDef := projectDef.
					projectSetDef := RwProjectSetDefinition new.
					projectSetDef addProject: classProjectDef.
					classDef
						superclassName: superclassName;
						instVarNames: anArrayOfStrings;
						classVarNames: anArrayOfClassVars;
						classInstVarNames: anArrayOfClassInstVars;
						gs_options: theOptions;
						gs_constraints: theConstraints;
						category: category;
						yourself.
					loadedClass packageName = packageName
						ifFalse: [ 
							| thePackageDef |
							"move class to another package"
							packageDef removeClassDefinition: classDef.
							thePackageDef := classProjectDef
								packageNamed: packageName
								ifAbsent: [ 
									| packageProjectDef |
									"loadedPackage in a different project"
									packageProjectDef := loadedPackage loadedProject asDefinition.
									projectSetDef addProject: packageProjectDef.
									packageProjectDef packageNamed: packageName ].
							thePackageDef addClassDefinition: classDef ].
					self class load loadProjectSetDefinition: projectSetDef ]
				ifAbsent: [ 
					"shouldn't happen ... loadedClass known to exist"
					self error: 'unexpected missing class ' , className printString ] ].
	^ (self _loadedClassNamed: className ifAbsent: [  ]) handle currentVersion
%

category: 'class browsing'
method: RwPrjBrowserTool
addOrUpdateClassDefinition: className type: type superclass: superclassName instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: category packageName: packageName options: optionsArray

	^ self 
		addOrUpdateClassDefinition: className
		type: type 
		superclass: superclassName 
		instVarNames: anArrayOfStrings 
		classVars: anArrayOfClassVars 
		classInstVars: anArrayOfClassInstVars 
		poolDictionaries: anArrayOfPoolDicts 
		category: category 
		packageName: packageName 
		constraints: #() 
		options: optionsArray
%

category: 'method browsing'
method: RwPrjBrowserTool
addOrUpdateMethod: methodSource inProtocol: hybridPackageName forClassNamed: className isMeta: isMeta

	"If the method is already installed in a different package, remove the method from that package.
	 If package name matches the name of the package of the class definition, then add the method 
		to the class definition.
	 If there is no matching class extension or the package name does not match, add the method 
		to a class extension in the named package.
	 Return the resulting compiled method"

	"a hybrid package name has a leading '*' followed by the name of a package ... 
 		where the hybrid package name is not expected to preserve case"

	| loadedPackage |
	loadedPackage := (hybridPackageName at: 1) = $*
		ifTrue: [ 
			Rowan image
				loadedHybridPackageNamed: hybridPackageName
				ifAbsent: [ 
					self
						error:
							'A package for hybrid package name ' , hybridPackageName printString
								, ' was not found.' ] ]
		ifFalse: [ 
			| loadedClass |
			loadedClass := Rowan image 
				loadedClassNamed: className 
				ifAbsent: [
					RwPerformingUnpackagedEditNotification signal: 'Attempt to add or modify an unpackage method in the class ', className printString, '. The modification will not be tracked by Rowan'.
					"Notification resumed, so continue with add/modify"
					^ (Rowan image objectNamed: className)
						compileMethod: methodSource
						dictionaries: Rowan image symbolList
						category: hybridPackageName].
			loadedClass loadedPackage ].

	^ self
		addOrUpdateMethod: methodSource
		inProtocol: hybridPackageName
		forClassNamed: className
		isMeta: isMeta
		inPackageNamed: loadedPackage name
%

category: 'method browsing'
method: RwPrjBrowserTool
addOrUpdateMethod: methodSource inProtocol: protocol forClassNamed: className isMeta: isMeta inPackageNamed: packageName

	"If the method is already installed in a different package, remove the method from that package.
	 If package name matches the name of the package of the class definition, then add the method 
		to the class definition.
	 If there is no matching class extension or the package name does not match, add the method 
		to a class extension in the named package.
	 Return the resulting compiled method"

	| projectTools loadedPackage classExtensionDef methodDef updateBlock projectDefinition packageDefinition projectSetDefinition loadedMethodToBeRemoved |
	projectSetDefinition := RwProjectSetDefinition new.

	methodDef := RwMethodDefinition newForSource: methodSource protocol: protocol.
	loadedMethodToBeRemoved := self
		_loadedMethod: methodDef selector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ 
			"no pre-existing method for this selector installed"
			 ].

	projectTools := Rowan projectTools.
	updateBlock := [ :cDef :pDef | 
	loadedMethodToBeRemoved
		ifNil: [
			"no method needs to be remove, just add the method to the class or extension def"
			isMeta
				ifTrue: [ cDef addClassMethodDefinition: methodDef ]
				ifFalse: [ cDef addInstanceMethodDefinition: methodDef ] ]
		ifNotNil: [ :loadedMethod | 
			| loadedPackageForMethod |
			loadedPackageForMethod := loadedMethod loadedPackage.
			loadedPackageForMethod name = packageName
				ifTrue: [ 
					"loaded method being updated in same package, sjust update the method def"
					isMeta
						ifTrue: [ cDef updateClassMethodDefinition: methodDef ]
						ifFalse: [ cDef updateInstanceMethodDefinition: methodDef ] ]
				ifFalse: [ 
					| loadedClassOrExtension projectDef packageDef crDef |
					"loaded method in different package than new version of method"
					projectDef := loadedPackageForMethod loadedProject asDefinition.
					projectDef name = pDef name
						ifTrue: [ 
							"both packages are in same project"
							projectDef := pDef ]
						ifFalse: [ 
							"each package in a different project, will need to load loaded method project as well"
							projectSetDefinition addProject: projectDef ].
					packageDef := projectDef packageNamed: loadedPackageForMethod name.
					loadedClassOrExtension := loadedMethod loadedClass.
					crDef := loadedClassOrExtension isLoadedClass
						ifTrue: [ packageDef classDefinitions at: loadedClassOrExtension name ]
						ifFalse: [ packageDef classExtensions at: loadedClassOrExtension name ].
					"remove the method from one package and add it to the other"
					isMeta
						ifTrue: [ 
							crDef removeClassMethod: methodDef selector.
							cDef addClassMethodDefinition: methodDef  ]
						ifFalse: [ 
							crDef removeInstanceMethod: methodDef selector.
							cDef addInstanceMethodDefinition: methodDef  ] ] ].
	projectSetDefinition addProject: pDef.
	projectTools load loadProjectSetDefinition: projectSetDefinition.
	(self _loadedMethod: methodDef selector inClassNamed: className isMeta: isMeta)
		handle ].

	self
		definitionsForClassNamed: className
		ifFound: [ :classDef :packageDef :projectDef | 
			packageDef name = packageName
				ifTrue: [ ^ updateBlock value: classDef value: projectDef ]
				ifFalse: [ 
					"the named package is different from the class definition package"
					 ] ]
		ifAbsent: [ 
			"no loaded class definition, so we probably need to add a class extension"
			 ].
	loadedPackage := Rowan image
		loadedPackageNamed: packageName
		ifAbsent: [ self error: 'A package named ' , packageName printString , ' was not found.' ].
	projectDefinition := loadedPackage loadedProject asDefinition.
	packageDefinition := projectDefinition packageNamed: packageName.

	classExtensionDef := packageDefinition classExtensions
		at: className
		ifAbsent: [ 
			"no existing class extension definition ... create a new one"
			classExtensionDef := RwClassExtensionDefinition newForClassNamed: className.

			packageDefinition addClassExtensionDefinition: classExtensionDef.
			classExtensionDef ].

	^ updateBlock value: classExtensionDef value: projectDefinition
%

category: 'package browsing'
method: RwPrjBrowserTool
addPackageNamed: packageName toProjectNamed: projectName

	| projectDefinition |
	projectDefinition := self _projectNamed: projectName.
	projectDefinition addPackage: (RwPackageDefinition newNamed: packageName).
	Rowan projectTools load loadProjectDefinition: projectDefinition
%

category: 'package browsing'
method: RwPrjBrowserTool
addPackagesNamed: packageNames toProjectNamed: projectName

	| projectDefinition |
	projectDefinition := self _projectNamed: projectName.
	packageNames
		do: [ :packageName | projectDefinition addPackage: (RwPackageDefinition newNamed: packageName) ].
	Rowan projectTools load loadProjectDefinition: projectDefinition
%

category: 'project browsing'
method: RwPrjBrowserTool
addRowanSymbolDictionariesToPersistentSymbolList

	self addRowanSymbolDictionariesToPersistentSymbolListFor: System myUserProfile
%

category: 'project browsing'
method: RwPrjBrowserTool
addRowanSymbolDictionariesToPersistentSymbolListFor: userProfile

	| systemUser |
	systemUser := AllUsers userWithId: 'SystemUser'.
	self _rowanSymbolDictionaryNames do: [:symDictName |
		| aSymbolDictionary anIndex |
		aSymbolDictionary := systemUser objectNamed: symDictName.
		anIndex := userProfile symbolList size + 1.
		userProfile
			insertDictionary: aSymbolDictionary at: anIndex ]
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForClass: aClass

	^ self classCreationTemplateForClass: aClass hybridBrowser: false
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForClass: aClass hybridBrowser: hybridBrowser

	| result anArray lfsp newByteSubclass civs superClass className thePackageName nonRowanClass |
	result := String new.
	superClass := aClass superclass.
	className := aClass name asString.
	superClass
		ifNil: [ result addAll: 'nil' ]
		ifNotNil: [ result addAll: superClass name asString ].
	lfsp := Character lf asString tab.
	newByteSubclass := false.
	thePackageName := aClass rowanPackageName.
	nonRowanClass := thePackageName = Rowan unpackagedName.
	(aClass isBytes _and: [ superClass isBytes not ])
		ifTrue: [ 
			nonRowanClass
				ifTrue: [ result addAll: ' byteSubclass: ''' ]
				ifFalse: [ result addAll: ' rwByteSubclass: ''' ].
			result
				addAll: className;
				addLast: $'.
			newByteSubclass := true ]
		ifFalse: [ 
			(aClass isIndexable and: [superClass isIndexable not])
				ifTrue: [ 
					nonRowanClass
						ifTrue: [ result addAll: ' indexableSubclass: ''' ]
						ifFalse: [ result addAll: ' rwIndexableSubclass: ''' ].
					result
						addAll: className;
						addLast: $' ]
				ifFalse: [ 
					nonRowanClass
						ifTrue: [ result addAll: ' subclass: ''' ]
						ifFalse: [ result addAll: ' rwSubclass: ''' ].
					result
						addAll: className;
						addLast: $' ] ].
	newByteSubclass
		ifFalse: [ 
			result
				addAll: lfsp;
				addAll: 'instVarNames: #(';
				addAll: (aClass _instVarNamesWithSeparator: lfsp , '                 ');
				add: $) ].
	result
		addAll: lfsp;
		addLast: 'classVars: #('.
	aClass _sortedClassVarNames
		do: [ :aKey | 
			result addLast: $ .
			(aKey includesValue: $')
				ifTrue: [ result addAll: aKey _asSource ]
				ifFalse: [ result addAll: aKey ] ].
	result addLast: $).
	result
		addAll: lfsp;
		addLast: 'classInstVars: #('.
	civs := aClass class allInstVarNames.
	civs removeFrom: 1 to: aClass class superClass instSize.
	civs
		do: [ :civName | 
			result addLast: $ .
			(civName includesValue: $')
				ifTrue: [ result addAll: civName _asSource ]
				ifFalse: [ result addAll: civName ] ].
	result addLast: $).
	result
		addAll: lfsp;
		addAll: 'poolDictionaries: '.
	result addAll: '#()'.	"ignored for now"
	nonRowanClass
		ifTrue: [ 
			"if the class is unpackaged, then we need to provide for the specification of symbol dictionary into which the class will be installed"
			result
				addAll: lfsp;
				addAll: 'inDictionary: '.
			anArray := Rowan image symbolList dictionariesAndSymbolsOf: aClass.
			anArray isEmpty
				ifTrue: [ result addAll: '''''' ]
				ifFalse: [ result addAll: ((anArray at: 1) at: 1) name asString ] ]
		ifFalse: [ 
			result
				addAll: lfsp;
				addAll: 'category: '.
			result addAll: aClass category printString.
			(hybridBrowser and: [ thePackageName = aClass category ])
				ifFalse: [ 
					result
						addAll: lfsp;
						addAll: 'packageName: '.
					result addAll: thePackageName printString ] ].
	aClass _hasConstraints
		ifTrue: [ 
			result
				add: lfsp;
				add: aClass _rwDefinitionOfConstraints ].
	result
		add: lfsp;
		add: aClass _rwOptionsForDefinition.
	result add: Character lf.
	^ result
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName category: category

	^ self
		classCreationTemplateForSubclassOf: superclassName
		category: category
		packageName: nil
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName category: category packageName: packageName

	^ self
		classCreationTemplateForSubclassOf: superclassName
		className: 'NameOfSubclass'
		category: category
		packageName: packageName
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName className: className category: category

	^ self
		classCreationTemplateForSubclassOf: superclassName
		className: className
		category: category
		packageName: nil
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName className: className category: category packageName: packageName

	^ self
		classCreationTemplateForSubclassOf: superclassName
		className: className
		type: 'normal'
		category: category
		packageName: packageName
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName className: className type: classType category: category packageName: packageNameOrNil

	"classType may be 'normal', 'bytes', or 'variable'"

	| result lfsp superClass |
	result := String new.
	superClass := Rowan image objectNamed: superclassName.
	result addAll: superclassName.
	lfsp := Character lf asString tab.
	classType = 'normal'
		ifTrue: [ result addAll: ' rwSubclass: ' ].
	classType = 'variable'
		ifTrue: [ result addAll: ' rwIndexableSubclass: ' ].
	classType = 'bytes'
		ifTrue: [ result addAll: ' rwByteSubclass: ' ].
	result addAll: className printString.
	classType ~= 'bytes'
		ifTrue: [ 
			result
				addAll: lfsp;
				addAll: 'instVarNames: #()' ].
	result
		addAll: lfsp;
		addLast: 'classVars: #()';
		addAll: lfsp;
		addLast: 'classInstVars: #()';
		addAll: lfsp;
		addAll: 'poolDictionaries: #()'.
	result
		addAll: lfsp;
		addAll: 'category: ';
		addAll: category printString.
	packageNameOrNil
		ifNotNil: [ 
			result
				addAll: lfsp;
				addAll: 'packageName: '.
			result addAll: packageNameOrNil printString ].
	result
		add: lfsp;
		add: 'options: #()';
		add: Character lf.
	^ result
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName className: className type: classType instanceVariablesString: instanceVariablesString classVariablesString: classVariablesString classInstanceVariablesString: classInstanceVariablesString poolDictionariesString: poolDictionariesString 
comment: comment category: category

	"classType may be 'normal', 'bytes', or 'variable'"

	| result lfsp |
	result := String new.
	lfsp := Character lf asString tab.
	comment isEmpty 
		ifFalse: [ 
			result 
				addAll: '(';
				addAll: lfsp ].
	result
		addAll: superclassName.
	classType = 'normal'
		ifTrue: [ result addAll: ' rwSubclass: ' ].
	classType = 'variable'
		ifTrue: [ result addAll: ' rwIndexableSubclass: ' ].
	classType = 'bytes'
		ifTrue: [ result addAll: ' rwByteSubclass: ' ].
	result addAll: className.
	classType ~= 'bytes'
		ifTrue: [ 
			result
				addAll: lfsp;
				addAll: 'instVarNames: #(' , instanceVariablesString , ')' ].
	result
		addAll: lfsp;
		addLast: 'classVars: #(' , classVariablesString , ')';
		addAll: lfsp;
		addLast: 'classInstVars: #(' , classInstanceVariablesString , ')';
		addAll: lfsp;
		addAll: 'poolDictionaries: #(' , poolDictionariesString , ')'.
	result
		addAll: lfsp;
		addAll: 'category: ';
		addAll: category.
	result
		add: lfsp;
		add: 'options: #()';
		add: Character lf.
	comment isEmpty 
		ifFalse: [ 
			result 
				addAll: ') ';
				addAll: lfsp;
				addAll: 'comment: ';
				addAll: comment;
				addAll: lfsp ].
	^ result
%

category: 'definition updating'
method: RwPrjBrowserTool
classNamed: className updateDefinition: updateBlock

	^ self
		classNamed: className
		updateDefinition: updateBlock
		ifAbsent: [ 
			self
				error:
					'expected class definition for class ' , className printString , ' not found.' ]
%

category: 'definition updating'
method: RwPrjBrowserTool
classNamed: className updateDefinition: updateBlock ifAbsent: absentBlock

	| projectDefinition classDefinition |
	self class edit
		definitionsForClassNamed: className
		ifFound: [ :classDef :packageDef :projectDef | 
			projectDefinition := projectDef.
			classDefinition := classDef ]
		ifAbsent: [ ^ absentBlock value ].

	updateBlock value: classDefinition.
	self class load loadProjectDefinition: projectDefinition
%

category: 'class browsing'
method: RwPrjBrowserTool
copyClassNamed: className to: newName

	"anser the new copy of the class"

	| projectSetDefinition |
	projectSetDefinition := self _copyClassDefinitionNamed: className to: newName.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	^ Rowan globalNamed: newName
%

category: 'class browsing'
method: RwPrjBrowserTool
createClass: classDefinition inPackageNamed: packageName

	| loadedPackage projectDefinition projectTools |
	loadedPackage := Rowan image
		loadedPackageNamed: packageName
		ifAbsent: [ self error: 'The package named ' , packageName printString , ' was not found' ].
	projectDefinition := loadedPackage loadedProject asDefinition.

	projectTools := Rowan projectTools.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

	projectTools load loadProjectDefinition: projectDefinition
%

category: 'project browsing'
method: RwPrjBrowserTool
createGitPackageProjectNamed: projectName

	self createGitPackageProjectNamed: projectName updateDefinition: [  ]
%

category: 'definition updating'
method: RwPrjBrowserTool
createGitPackageProjectNamed: projectName updateDefinition: updateBlock

	| projectDefinition |
	projectDefinition := RwProjectDefinition
		newForGitBasedProjectNamed: projectName.
	updateBlock cull: projectDefinition.
	self class load loadProjectDefinition: projectDefinition
%

category: 'project browsing'
method: RwPrjBrowserTool
exposeRowanToolsSymbolDictionary

	| transient size dict |
	transient := Rowan image symbolList.
	size := transient size.
	dict := (AllUsers userWithId: 'SystemUser') objectNamed: 'RowanTools'.
	transient insertObject: dict at: size + 1.
%

category: 'method browsing'
method: RwPrjBrowserTool
isExtensionMethod: methodSelector forClassNamed: className isMeta: isMeta

	"Answer true if the specified method is a Rowan extension method"

	| loadedMethod loadedClassOrExtension loadedPackage |

	loadedMethod := self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ 
			"No loaded method found ... it is not an extension method"
			^ false ].
	loadedPackage := loadedMethod loadedPackage.

	loadedClassOrExtension := loadedPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- no class or extension for ' , className printString
						, ' in package ' , loadedPackage name printString , '.' ].

	^loadedClassOrExtension isLoadedClassExtension
%

category: 'method browsing'
method: RwPrjBrowserTool
moveMethod: methodSelector forClassNamed: className isMeta: isMeta toProtocol: hybridPackageName

	"hybridPackageName is expected to be an existing protocol in className"

	| loadedMethodToBeMoved srcLoadedMethodPackage srcLoadedClassPackage srcLoadedClassOrExtension projectDef packageDef 
		clsDef projectSetDefinition destinationLoadedPackage methodDef |

	loadedMethodToBeMoved := self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ ].

	destinationLoadedPackage := (hybridPackageName at: 1) = $*
		ifTrue: [ 
			Rowan image
				loadedHybridPackageNamed: hybridPackageName
				ifAbsent: [ 
					self
						error:
							'A package for hybrid package name ' , hybridPackageName printString
								, ' was not found.' ] ]
		ifFalse: [ 
			| lc |
			lc := self
				_loadedClassNamed: className
				ifAbsent: [].
			lc 
				ifNil: [
					loadedMethodToBeMoved
						ifNil: [ 
							"unpackaged method moved to unpackaged category"
							^ (Rowan image objectNamed: className) moveMethod: methodSelector toCategory: hybridPackageName ].
				RwPerformingUnpackagedEditNotification signal: 'Attempt to move a packaged method to an unpackaged class ', className printString, '. The unpackaged method will not be tracked by Rowan'.
				"Notification resumed, so continue with move"
				"Move packaged method to unpackaged category"
				"Disown the method, then move it to proper category" 
				Rowan packageTools disown disownMethod: methodSelector inClassNamed: className isMeta: isMeta.
				^ (Rowan image objectNamed: className) moveMethod: methodSelector toCategory: hybridPackageName ].
			"use the loaded package for the class that contains the method"
			srcLoadedClassPackage := lc loadedPackage ].

	loadedMethodToBeMoved
		ifNil: [
			| instanceSelectors classSelectors res |
			"Moving an unpackaged method to a package in an unpackage class"
			"Move the method to the proper category and then adopt the method"
			isMeta
				ifTrue: [
					instanceSelectors := {}.
					classSelectors := { methodSelector } ]
				ifFalse: [
					instanceSelectors := { methodSelector }.
					classSelectors := {} ].
			res := (Rowan image objectNamed: className) moveMethod: methodSelector toCategory: hybridPackageName.
			Rowan packageTools adopt
				adoptClassNamed: className 
				classExtension: true
				instanceSelectors: instanceSelectors 
				classSelectors: classSelectors 
				intoPackageNamed: destinationLoadedPackage name.
			^ res ].

	"Moving a packaged method to another package"
	srcLoadedMethodPackage := loadedMethodToBeMoved loadedPackage.
	srcLoadedClassOrExtension := srcLoadedMethodPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- no class or extension for ' , className printString
						, ' in package ' , srcLoadedMethodPackage name printString , '.' ].

	projectSetDefinition := RwProjectSetDefinition new.
	projectDef := srcLoadedMethodPackage loadedProject asDefinition.
	packageDef := projectDef packageNamed: srcLoadedMethodPackage name.
	clsDef := srcLoadedClassOrExtension isLoadedClass
		ifTrue: [ packageDef classDefinitions at: className ]
		ifFalse: [ packageDef classExtensions at: className ].

	projectSetDefinition addProject: projectDef.
	destinationLoadedPackage name = srcLoadedMethodPackage name
		ifTrue: [
			"method is not moving to a different package, only need to change the protocol for the method"

			methodDef := isMeta
				ifTrue: [ clsDef classMethodDefinitions at: methodSelector ]
				ifFalse: [ clsDef instanceMethodDefinitions at: methodSelector ].
			methodDef protocol: hybridPackageName ]
		ifFalse: [
			"method is moving to a different package"

			| destProjectDef destPackageDef destClsDef srcPackageDef  srcClsDef |
			destinationLoadedPackage loadedProject name = projectDef name 
				ifTrue: [ destProjectDef := projectDef ]
				ifFalse: [ 
					"method is moving to a different project"
					destProjectDef := destinationLoadedPackage loadedProject asDefinition.
					projectSetDefinition addProject: destProjectDef ].
			srcPackageDef := projectDef packageNamed: srcLoadedMethodPackage name.
			srcClsDef := srcLoadedClassOrExtension isLoadedClass
				ifTrue: [ srcPackageDef classDefinitions at: className ]
				ifFalse: [ srcPackageDef classExtensions at: className ].

			destPackageDef := destProjectDef packageNamed: destinationLoadedPackage name. 

			destClsDef := srcLoadedClassPackage == destinationLoadedPackage
				ifTrue: [
					"method is not an extension method ... add the method to the class definition"
					destPackageDef 
						classDefinitions 
							at: className 
							ifAbsent: [ 
								self error: 'internal error - class ', 
									className printString , 
									' not found in expected package ', 
									destinationLoadedPackage name printString ] ]
				ifFalse: [ 
					"method is to be added as an extension method" 
					destPackageDef classExtensions at: className ifAbsentPut: [ RwClassExtensionDefinition newForClassNamed: className ] ].
			isMeta
				ifTrue: [
					methodDef := srcClsDef classMethodDefinitions at: methodSelector.
					methodDef protocol: hybridPackageName.
					destClsDef addClassMethodDefinition: methodDef.
					srcClsDef removeClassMethod: methodSelector ]
				ifFalse: [ 
					methodDef := srcClsDef instanceMethodDefinitions at: methodSelector.
					methodDef protocol: hybridPackageName.
					destClsDef addInstanceMethodDefinition: methodDef.
					srcClsDef removeInstanceMethod: methodSelector ] ].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.
%

category: 'project browsing'
method: RwPrjBrowserTool
projectNamed: projectName

	^ self _projectNamed: projectName
%

category: 'definition updating'
method: RwPrjBrowserTool
projectNamed: projectName updateDefinition: updateBlock

	| projectDefinition |
	projectDefinition := self _projectNamed: projectName.
	updateBlock value: projectDefinition.
	self class load loadProjectDefinition: projectDefinition
%

category: 'definition updating'
method: RwPrjBrowserTool
projectsNamed: projectNames updateDefinition: updateBlock

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectNames
		do: [ :projectName | 
			| projectDefinition |
			projectDefinition := self _projectNamed: projectName.
			updateBlock value: projectDefinition.
			projectSetDefinition addProject: projectDefinition ].
	self class load loadProjectSetDefinition: projectSetDefinition
%

category: 'class browsing'
method: RwPrjBrowserTool
removeClassNamed: className

	| projectSetDefinition loadedClass loadedClassProjectDef  loadedClassProjectDefName loadedClassExtensions |
	projectSetDefinition := RwProjectSetDefinition new.

	loadedClass := self _loadedClassNamed: className ifAbsent: [ ].
	loadedClassExtensions := #(). "only apply if the class itself is not managed by Rowan"

	loadedClass 
		ifNil: [
			"Give developer a chance to handle and abort the removal of unpackaged class"
			RwPerformingUnpackagedEditNotification signal: 'Attempt to remove an unpackaged class ', className printString, '. The removal will not be tracked by Rowan'.
			"Notification resumed, so continue with removal ... actual removal is performed below"
				loadedClassExtensions := self _loadedClassExtensionsNamed: className ifAbsent: [ #() ] ]
		ifNotNil: [
			| loadedPackage projectDef packageDef classDef |
			loadedPackage := loadedClass loadedPackage.
			projectDef := loadedClass loadedProject asDefinition.
			packageDef := projectDef packageNamed: loadedPackage name.
			classDef := packageDef classDefinitions at: loadedClass name.
			packageDef removeClassDefinition: classDef.
			projectSetDefinition addProject: projectDef.
			loadedClassProjectDef := projectDef.
			loadedClassProjectDefName := projectDef name ].

	loadedClassExtensions
		do: [ :loadedClassExtension | 
			| loadedClassExtensionPackage ceProjectDef cePackageDef |
			loadedClassExtensionPackage := loadedClassExtension loadedPackage.
			ceProjectDef := loadedClassExtension loadedProject asDefinition.
			ceProjectDef name = loadedClassProjectDefName
				ifTrue: [
					"extensions defined in same project as the class itself, entry already exists in projectSetDefinition"
					ceProjectDef := loadedClassProjectDef ]
				ifFalse: [ projectSetDefinition addProject: ceProjectDef ].
			cePackageDef := ceProjectDef packageNamed: loadedClassExtensionPackage name.
			cePackageDef
				removeClassExtensionDefinition:
					(cePackageDef classExtensions at: loadedClassExtension name) ].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass 
		ifNil: [
			"need to do the actual removal of the unpackaged class after Rowan has done it's job"
			| theClass |
			theClass := Rowan image objectNamed: className.
			(GsCurrentSession currentSession symbolList dictionariesAndSymbolsOf: theClass)
				do: [:ar | | dict key |
					"brute force removal of the class from system dictionaries"
					dict := ar at: 1.	
					key := ar at: 2.
					dict removeKey: key ] ]
%

category: 'method browsing'
method: RwPrjBrowserTool
removeMethod: methodSelector forClassNamed: className isMeta: isMeta

	"Remove the given method selector from the class named className"

	| loadedMethodToBeRemoved loadedPackage loadedClassOrExtension projectDef packageDef crDef |
	loadedMethodToBeRemoved := self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [
			RwPerformingUnpackagedEditNotification signal: 'Attempt to remove an unpackaged method from the class ', className printString, '. The removal will not be tracked by Rowan'.
			"Notification resumed, so continue with removal"
			^ (Rowan globalNamed: className) removeSelector: methodSelector ].
	loadedPackage := loadedMethodToBeRemoved loadedPackage.
	loadedClassOrExtension := loadedPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- no class or extension for ' , className printString
						, ' in package ' , loadedPackage name printString , '.' ].
	projectDef := loadedPackage loadedProject asDefinition.
	packageDef := projectDef packageNamed: loadedPackage name.
	crDef := loadedClassOrExtension isLoadedClass
		ifTrue: [ packageDef classDefinitions at: loadedClassOrExtension name ]
		ifFalse: [ packageDef classExtensions at: loadedClassOrExtension name ].
	isMeta
		ifTrue: [ crDef removeClassMethod: methodSelector ]
		ifFalse: [ crDef removeInstanceMethod: methodSelector ].
	Rowan projectTools load loadProjectDefinition: projectDef
%

category: 'package browsing'
method: RwPrjBrowserTool
removePackageNamed: packageName

	| loadedPackage projectDef |
	loadedPackage := self _loadedPackageNamed: packageName.
	projectDef := loadedPackage loadedProject asDefinition.
	projectDef removePackageNamed: loadedPackage name.

	Rowan projectTools load loadProjectDefinition: projectDef
%

category: 'class browsing'
method: RwPrjBrowserTool
removeProtocol: hybridPackageName fromClassNamed: className isMeta: isMeta

	"hybridPackageName is expected to be an existing protocol in className, that may or may not be empty"

	| projectSetDefinition loadedClass theClass theBehavior loadedPackage |
	projectSetDefinition := RwProjectSetDefinition new.

	loadedClass := self _loadedClassNamed: className ifAbsent: [ ].

	loadedPackage := (hybridPackageName at: 1) = $*
		ifTrue: [ 
			Rowan image
				loadedHybridPackageNamed: hybridPackageName
				ifAbsent: [ 
					self
						error:
							'A package for hybrid package name ' , hybridPackageName printString
								, ' was not found.' ] ]
		ifFalse: [ loadedClass loadedPackage ].

	theClass := Rowan image objectNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].

	(((theBehavior selectorsIn: hybridPackageName)
		collect: [:methodSelector |
			self
				_loadedMethod: methodSelector
				inClassNamed: className
				isMeta: isMeta
				ifAbsent: [
					RwPerformingUnpackagedEditNotification signal: 'Attempt to remove an unpackaged method from the class ', className printString, '. The removal will not be tracked by Rowan'.
					"Notification resumed, so continue with removal"
					(Rowan image objectNamed: className) removeSelector: methodSelector.
					nil "no loaded method involved" ] ]) select: [:each | each notNil ])
			do: [:loadedMethodToBeRemoved |
				| loadedClassOrExtension projectDef crDef packageDef methodSelector | 

				methodSelector := loadedMethodToBeRemoved selector.
				loadedPackage == loadedMethodToBeRemoved loadedPackage
					ifFalse: [ self error: 'Internal error -- the loaded package of a method to be removed does not match the expected loaded package' ].
				loadedClassOrExtension := loadedPackage
					classOrExtensionForClassNamed: className
					ifAbsent: [ 
						self
							error:
								'Internal error -- no class or extension for ' , className printString
									, ' in package ' , loadedPackage name printString , '.' ].
				projectDef := projectSetDefinition
					projectNamed: loadedPackage loadedProject name
					ifAbsent: [ 
						projectDef := loadedPackage loadedProject asDefinition.
						projectSetDefinition addProject: projectDef.
						projectDef ].
				packageDef := projectDef packageNamed: loadedPackage name.
				crDef := loadedClassOrExtension isLoadedClass
					ifTrue: [ packageDef classDefinitions at: loadedClassOrExtension name ]
					ifFalse: [ packageDef classExtensions at: loadedClassOrExtension name ].
				isMeta
					ifTrue: [ crDef removeClassMethod: methodSelector ]
					ifFalse: [ crDef removeInstanceMethod: methodSelector ] ].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"Rowan does not automatically remove empty method categories ... just removes methods,
		we need to clean up after Rowan is done."
	theBehavior removeCategory: hybridPackageName asSymbol
%

category: 'class browsing'
method: RwPrjBrowserTool
renameClassNamed: className to: newName

	"During renameClassNamed:to: a class is created with the new name and all methods 
		are copied from the old class to the new class. If there are subclasses of the old class,
		the subclasses are moved under the new class, then the old class is removed. It is
		recommended that before renaming a class, you should find references to the class 
		and be prepared to edit the methods once the rename is complete.

	Worry about the fact that any references to the original class that may be in methods in 
		the class itself or in subclass methods will error out, if recompiled 
	"

	"anser the new copy of the class"

	| projectSetDefinition loadedClass loadedPackage loadedProject projectDef packageDef |
"1. find references to the original class [not yet implemented]"

"2. copy class to renamed class"
	projectSetDefinition := self _copyClassDefinitionNamed: className to: newName.

	loadedClass := self 
		_loadedClassNamed: className 
		ifAbsent: [  self error: 'No loaded class named: ', className printString , ' found.' ].

"3. remove original class definition"
	loadedPackage := loadedClass loadedPackage.
	loadedProject := loadedPackage loadedProject.
	projectDef := projectSetDefinition projectNamed: loadedProject name ifAbsent: [ self error: 'No loaded project named: ', loadedProject printString , ' found.'].
	packageDef := projectDef packageNamed: loadedPackage name.

	packageDef removeClassNamed: className.

"4. change superclass for all subclasses of original class to renamed class"
	(Rowan globalNamed: className) subclasses do: [:subclass |
		| subclassName classDef  |
		subclassName := subclass name asString.
		loadedClass := self 
			_loadedClassNamed: subclassName
			ifAbsent: [  self error: 'No loaded class named: ', subclassName printString , ' found.' ].

		loadedPackage := loadedClass loadedPackage.
		loadedProject := loadedPackage loadedProject.
		projectDef := projectSetDefinition 
			projectNamed: loadedProject name 
			ifAbsent: [ 
				| pDef |
				pDef := loadedPackage loadedProject asDefinition.
				projectSetDefinition addProject: pDef.
				pDef ].
		packageDef := projectDef packageNamed: loadedPackage name.
		classDef := packageDef classDefinitions at: subclassName.
		classDef superclassName: newName ].

"load projectSetDefinition & do rename"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	^ Rowan globalNamed: newName
%

category: 'class browsing'
method: RwPrjBrowserTool
updateClassComment: aString forClassNamed: className 

	"update the comment of the named class"

	| loadedClass projectDefinition packageDefinition classDefinition |
	loadedClass := Rowan image 
		loadedClassNamed: className 
		ifAbsent: [
			RwPerformingUnpackagedEditNotification signal: 'Attempt to add or modify a comment for the class ', className printString, '. The modification will not be tracked by Rowan'.
			"Notification resumed, so continue with add/modify"
			^ (Rowan globalNamed: className) comment: aString ].

	projectDefinition := loadedClass loadedProject asDefinition.
	packageDefinition := projectDefinition packageNamed: loadedClass loadedPackage name.
	classDefinition := packageDefinition classDefinitions at: loadedClass name.
	classDefinition comment: aString.

	self class load loadProjectDefinition: projectDefinition.
%

category: 'private'
method: RwPrjBrowserTool
_copyClassDefinitionNamed: className to: newName

	"answer a projectSetDefinition that includes the copied class definition"

	| loadedClass classDef loadedPackage projectDef packageDef  projectSetDefinition |
	(self _loadedClassNamed: newName ifAbsent:  [])
		ifNotNil: [ self error: 'There is already a class named ', newName printString, ' in the system.' ].
	loadedClass := self 
		_loadedClassNamed: className 
		ifAbsent: [  self error: 'No loaded class named: ', className printString , ' found.' ].
	projectSetDefinition := RwProjectSetDefinition new.
	loadedPackage := loadedClass loadedPackage.
	projectDef := loadedPackage loadedProject asDefinition.
	packageDef := projectDef packageNamed: loadedPackage name.
	classDef := loadedClass asDefinition.
	classDef name: newName.
	packageDef addClassDefinition: classDef.
	projectSetDefinition addProject: projectDef.

	(self _loadedClassExtensionsNamed: className ifAbsent: [ #() ])
		do: [:loadedClassExtension | 
			| classExtDef loadedProject |
			loadedPackage := loadedClassExtension loadedPackage.
			loadedProject := loadedPackage loadedProject.
			projectDef := projectSetDefinition
				projectNamed: loadedPackage loadedProject name
				ifAbsent: [ 
					projectDef := loadedProject asDefinition.
					projectSetDefinition addProject: projectDef.
					projectDef ].

			packageDef := projectDef packageNamed: loadedPackage name.
			classExtDef := loadedClassExtension asDefinition.
			classExtDef name: newName.
			packageDef addClassExtensionDefinition: classExtDef ].

	^ projectSetDefinition
%

category: 'private'
method: RwPrjBrowserTool
_loadedClassExtensionsNamed: className

	^ self
		_loadedClassExtensionsNamed: className
		ifAbsent: [ 
			self
				error:
					'No extensions for the class ' , className printString , ' were found' ]
%

category: 'private'
method: RwPrjBrowserTool
_loadedClassExtensionsNamed: className ifAbsent: absentBlock

	^ Rowan image
		loadedClassExtensionsNamed: className
		ifFound: [ :loadedClassExtensionSet | ^ loadedClassExtensionSet ]
		ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserTool
_loadedClassNamed: className

	^ self
		_loadedClassNamed: className
		ifAbsent: [ self error: 'The class ' , className printString , ' was not found' ]
%

category: 'private'
method: RwPrjBrowserTool
_loadedClassNamed: className ifAbsent: absentBlock

	^ Rowan image loadedClassNamed: className ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserTool
_loadedMethod: methodSelector inClassNamed: className isMeta: isMeta

	^ self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ 
			self
				error:
					'No loaded method for ' , methodSelector printString , ' was found for class '
						, className printString ]
%

category: 'private'
method: RwPrjBrowserTool
_loadedMethod: methodSelector inClassNamed: className isMeta: isMeta ifAbsent: absentBlock

	^ Rowan image
		loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifFound: [ :loadedMethod | ^ loadedMethod ]
		ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserTool
_loadedPackageNamed: packageName

	^ self
		_loadedPackageNamed: packageName
		ifAbsent: [ self error: 'No package named ' , packageName printString , ' found' ]
%

category: 'private'
method: RwPrjBrowserTool
_loadedPackageNamed: packageName ifAbsent: absentBlock

	^ Rowan image loadedPackageNamed: packageName ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserTool
_loadedProjectForClassNamed: className

	^ (self _loadedClassNamed: className) loadedProject
%

category: 'private'
method: RwPrjBrowserTool
_loadedProjectForMethod: methodSelector inClassNamed: className isMeta: isMeta

	^ (self _loadedMethod: methodSelector inClassNamed: className isMeta: isMeta)
		loadedProject
%

category: 'private'
method: RwPrjBrowserTool
_loadedProjectForPackageNamed: packageName

	^ (self _loadedPackageNamed: packageName) loadedProject
%

category: 'private'
method: RwPrjBrowserTool
_loadedProjectNamed: projectName

	^ Rowan image
		loadedProjectNamed: projectName
		ifAbsent: [ self error: 'No project named ' , projectName printString , ' found' ]
%

category: 'private'
method: RwPrjBrowserTool
_projectForClassNamed: className

	^ (self _loadedProjectForClassNamed: className) asDefinition
%

category: 'private'
method: RwPrjBrowserTool
_projectForMethod: methodSelector inClassNamed: className isMeta: isMeta

	^ (self
		_loadedProjectForMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta) asDefinition
%

category: 'private'
method: RwPrjBrowserTool
_projectForPackageNamed: packageName

	^ (self _loadedProjectForPackageNamed: packageName) asDefinition
%

category: 'private'
method: RwPrjBrowserTool
_projectNamed: projectName

	^ (self _loadedProjectNamed: projectName) asDefinition
%

category: 'private'
method: RwPrjBrowserTool
_rowanSymbolDictionaryNames

	^ #( #RowanKernel #RowanLoader #RowanTools )
%

! Class implementation for 'RwPrjCheckoutTool'

!		Instance methods for 'RwPrjCheckoutTool'

category: 'smalltalk api'
method: RwPrjCheckoutTool
checkoutProjectReference: aRwGitProjectReference

	| checkout |
	checkout := aRwGitProjectReference  committish.
	checkout
		ifNil: [ 
			| msg |
			msg := 'No committish defined for the project reference '
				, aRwGitProjectReference projectAlias printString.
			self inform: msg.
			^ msg ]
		ifNotNil: [ 
			| gitTool gitRepoPath |
			gitTool := Rowan gitTools.
			gitRepoPath := aRwGitProjectReference repositoryRoot.
			gitTool gitcheckoutIn: gitRepoPath with: checkout ].
	^ aRwGitProjectReference
%

category: 'smalltalk api'
method: RwPrjCheckoutTool
checkoutSpecification: aRwSpecification

	| checkout |
	self specification: aRwSpecification.
	checkout := specification repoSpec committish.
	checkout
		ifNil: [ 
			| msg |
			msg := 'No committish defined for the spec '
				, specification specName printString.
			self inform: msg.
			^ msg ]
		ifNotNil: [ 
			| gitTool gitRepoPath |
			gitTool := Rowan gitTools.
			gitRepoPath := specification repoSpec repositoryRootPath asFileReference.
			gitTool gitcheckoutIn: gitRepoPath with: checkout ].
	^ specification
%

category: 'smalltalk api'
method: RwPrjCheckoutTool
checkoutSpecUrl: aString 

	^self checkoutSpecification: (RwSpecification fromUrl: aString) 
%

! Class implementation for 'RwPrjCloneTool'

!		Instance methods for 'RwPrjCloneTool'

category: 'smalltalk api'
method: RwPrjCloneTool
cloneRepository: aRwGitRepositoryDefinition

	| gitTool response remoteUrl cloneOption checkout |

	self
		_validateForGitRepository: aRwGitRepositoryDefinition
		ifDone: [ :msg | 
			"done block is invoked when it is not necessary to perform further processing. Typically,
		the clone is already present."
			^ msg ].
	gitTool := Rowan gitTools.
	remoteUrl := aRwGitRepositoryDefinition remoteUrl , ' '.
	cloneOption := ' --no-checkout '.
	checkout := aRwGitRepositoryDefinition committish.
	checkout ifNil: [ cloneOption := '' ].
	response := gitTool gitcloneIn: aRwGitRepositoryDefinition repositoryRoot parent pathString with: cloneOption , remoteUrl, aRwGitRepositoryDefinition repositoryRoot pathString.
	checkout
		ifNotNil: [ Rowan projectTools checkout checkoutProjectReference: aRwGitRepositoryDefinition ].
%

category: 'smalltalk api'
method: RwPrjCloneTool
cloneSpecification: aRwSpecification gitRootPath: gitRootPath useSsh: useSsh

	^ self cloneSpecification: aRwSpecification gitRootPath: gitRootPath useSsh: useSsh registerProject: true
%

category: 'smalltalk api'
method: RwPrjCloneTool
cloneSpecification: aRwSpecification gitRootPath: gitRootPathOrString useSsh: useSsh registerProject: registerProject

	| gitTool response projectUrl gitRepoPath cloneUrl cloneOption checkout segments gitRootPath |
	registerProject
		ifTrue: [ 
			"Register project show that is shows up as a loaded project in project list ... ready to be explicitly loaded"
			self specification: aRwSpecification ]
		ifFalse: [ specification := aRwSpecification ].
	gitRootPath := gitRootPathOrString asFileReference.
	gitRepoPath := gitRootPath / aRwSpecification specName.
	self
		_validateForGitRootPathForSpecification: gitRootPath
		gitRepoDir: gitRepoPath
		useSsh: useSsh
		ifDone: [ :msg | 
			"done block is invoked when it is not necessary to perform further processing. Typically,
		the clone is already present."
			^ msg ].
	gitTool := Rowan gitTools.
	projectUrl := RwUrl fromString: specification projectUrl.
	cloneUrl := useSsh
		ifTrue: [ 'git@' , projectUrl authority , ':' ]
		ifFalse: [ 'https://' , projectUrl authority , '/' ].
	segments := projectUrl segments.
	cloneUrl := segments size = 1
		ifTrue: [ cloneUrl , (segments at: 1) , '.git' ]
		ifFalse: [ cloneUrl , (segments at: 1) , '/' , (projectUrl segments at: 2) , '.git' ].
	cloneOption := ' --no-checkout '.
	checkout := specification repoSpec committish.
	checkout ifNil: [ cloneOption := '' ].
	response := gitTool gitcloneIn: gitRootPath  pathString with: cloneOption , cloneUrl.
	specification
		repositoryUrl: 'cypress:' , gitRepoPath pathString  , '/' , specification repoPath , '/'.
	specification repositoryRootPath: gitRepoPath.
	checkout
		ifNotNil: [ Rowan projectTools checkout checkoutSpecification: specification ].
	^ specification
%

category: 'smalltalk api'
method: RwPrjCloneTool
cloneSpecUrl: aString gitRootPath: gitRootPath useSsh: useSsh

	^self 
		cloneSpecification: (RwSpecification fromUrl: aString) 
		gitRootPath: gitRootPath 
		useSsh: useSsh
%

category: 'smalltalk api'
method: RwPrjCloneTool
specification: aRwSpecification
  "let the validation run before sending #register"

  ^ (super specification: aRwSpecification) register
%

category: 'private'
method: RwPrjCloneTool
_validateForGitRepository: aRwGitRepositoryDefinition ifDone: doneBlock

	| gitTool response command cdResponse gitRepoPath |
	gitTool := Rowan gitTools.
	gitRepoPath := aRwGitRepositoryDefinition repositoryRoot.

	gitRepoPath exists
		ifTrue: [ 
			[ 
			"if gitRepoDir exists and it is a git repo, then make sure that the clone is for the target
		project ... if not error out of here."
			response := gitTool gitrevparseShowTopLevelIn: gitRepoPath pathString.
			command := 'set -e; cd ' , gitRepoPath pathString , '; pwd'.
			cdResponse := gitTool performOnServer: command logging: true.
			(self readlink: response) = (self readlink: cdResponse)
				ifTrue: [ 
					| msg |
					msg := 'A clone for '
						, aRwGitRepositoryDefinition name printString , ' already exists in '
						, gitRepoPath pathString printString , ', so the clone operation is being skipped'
						, '
The project project has been registered with Rowan at the existing location .'.
					self inform: msg.
					doneBlock value: msg ] ]
				on: Error
				do: [ :ignored | 
					self
						error:
							'Expected a git repository to present in the directory: '
								, gitRepoPath pathString printString ] ].
	gitRepoPath parent ensureCreateDirectory
%

category: 'private'
method: RwPrjCloneTool
_validateForGitRootPathForSpecification: gitRootPath gitRepoDir: gitRepoPath useSsh: useSsh ifDone: doneBlock

	| gitTool response command cdResponse |
	gitTool := Rowan gitTools.
	specification repositoryUrl
		ifNotNil: [ :repoUrlString | 
			| repoUrl |
			repoUrl := RwUrl fromString: repoUrlString.
			response := gitTool gitrevparseShowTopLevelIn: repoUrl pathString.
			command := 'set -e; cd ' , gitRepoPath , '; pwd'.
			cdResponse := gitTool performOnServer: command logging: true.
			(self readlink: response) = (self readlink: cdResponse)
				ifTrue: [ 
					| msg |
					msg := 'A clone for ' , specification specName printString
						, ' already exists in ' , gitRepoPath printString , '. Skipping clone.'.
					self inform: msg.
					doneBlock value: msg ].
			self
				error:
					'A clone for a different project (' , response printString
						, ') is already present in ' , gitRepoPath printString ].
	gitRepoPath exists
		ifTrue: [ 
			[ 
			"if gitRepoDir exists and it is a git repo, then make sure that the clone is for the target
		project ... if not error out of here."
			response := gitTool gitrevparseShowTopLevelIn: gitRepoPath pathString.
			command := 'set -e; cd ' , gitRepoPath pathString , '; pwd'.
			cdResponse := gitTool performOnServer: command logging: true.
			(self readlink: response) = (self readlink: cdResponse)
				ifTrue: [ 
					| msg |
					specification
						repositoryUrl:
							'cypress:' , gitRepoPath pathString , '/' , specification repoPath , '/'.
					specification repositoryRootPath: gitRepoPath pathString.
					msg := 'A clone for '
						, specification specName printString , ' already exists in '
						, gitRepoPath printString , ', so the clone operation is being skipped'
						, '
The project project has been registered with Rowan at the existing location .'.
					self inform: msg.
					doneBlock value: msg ] ]
				on: Error
				do: [ :ignored | 
					self
						error:
							'Expected a git repository to present in the directory: '
								, gitRepoPath pathString printString ] ].
	gitRootPath ensureCreateDirectory
%

! Class implementation for 'RwPrjCommitTool'

!		Instance methods for 'RwPrjCommitTool'

category: 'smalltalk api'
method: RwPrjCommitTool
commitProjectNamed: projectName message: messageString

	"commit repository ... packages must be written out independently with write tool"

	| loadedProject projectDefinition |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	projectDefinition := loadedProject asDefinition.
	projectDefinition commit: messageString
%

! Class implementation for 'RwPrjCreateTool'

!		Instance methods for 'RwPrjCreateTool'

category: 'component project defintion creation'
method: RwPrjCreateTool
createComponentProject: componentProjectDefinition

	"Create create new repository on `disk`, based on the given repository definition."

	self createProjectRepository: componentProjectDefinition projectRef.

	componentProjectDefinition exportSpecification.
	componentProjectDefinition exportProjects.
	componentProjectDefinition exportComponents.
	componentProjectDefinition exportPackages.

	componentProjectDefinition register.

	^ componentProjectDefinition
%

category: 'project repository creation'
method: RwPrjCreateTool
createProjectRepository: projectReferenceDefinition

	"Create create new repository on `disk`, based on the given repository definition."

	| repositoryDefinition |
	repositoryDefinition := projectReferenceDefinition repositoryDefinition.
	self _createProjectRepositoryDirectory: 
		repositoryDefinition repositoryRoot 
		useGit: projectReferenceDefinition useGit 
		abort: [
			"abort occurs because directory exists and user has not confirmed that the directory should be deleted"
			"cofirm that the repository appears to be complete relative to this project ... we will likely be writing new information to the repo"
			projectReferenceDefinition validateRepository.
			^ projectReferenceDefinition ].

	{projectReferenceDefinition configsRoot. projectReferenceDefinition packagesRoot. projectReferenceDefinition specsRoot. projectReferenceDefinition projectsRoot }
		do: [ :path | path ensureCreateDirectory ].

	projectReferenceDefinition exportSpecification.
	^ projectReferenceDefinition
%

! Class implementation for 'RwPrjDeleteTool'

!		Instance methods for 'RwPrjDeleteTool'

category: 'delete project definitions'
method: RwPrjDeleteTool
deleteProjectDefinition: projectDefinition

	"Remove the classes and methods managed by the project definition."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects the delete will fail ... deleteProjectDefinitionSet: to delete multiple projects"

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

	^ self deleteProjectSetDefinition: projectSetDefinition
%

category: 'delete projects by name'
method: RwPrjDeleteTool
deleteProjectNamed: projectName

	"Remove the classes and methods managed by the project from the loaded things."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects the delete will fail ... deleteProjectDefinitionSet: to delete multiple projects"

	| loadedProject |

	loadedProject := Rowan image loadedProjectNamed: projectName.

	^ self deleteProjectDefinition: loadedProject asDefinition
%

category: 'delete project definitions'
method: RwPrjDeleteTool
deleteProjectSetDefinition: projectSetDefinitionToDelete

	"Remove the classes and methods managed by the listed project definitions."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will fail ... 
		add projects containing  subclasses to the <projectSetDefinitionToDelete> ."

	| loadedProjectSet |
	loadedProjectSet := projectSetDefinitionToDelete deriveLoadedThings.

	projectSetDefinitionToDelete definitions
		do: [ :projectDef |
			projectDef packageNames do: [:packageName | 
				projectDef removePackageNamed: packageName ] ].
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinitionToDelete.

	loadedProjectSet do: [:loadedProject |
		Rowan image _removeLoadedProject: loadedProject ]
%

category: 'delete project definitions'
method: RwPrjDeleteTool
forceDeleteProjectDefinition: projectDefinition

	"Remove the classes and methods managed by the project definition."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will NOT fail."

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

	^ self forceDeleteProjectSetDefinition: projectSetDefinition
%

category: 'delete projects by name'
method: RwPrjDeleteTool
forceDeleteProjectNamed: projectName

	"Remove the classes and methods managed by the project from the loaded things."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will NOT fail."

	| loadedProject |

	loadedProject := Rowan image loadedProjectNamed: projectName.

	^ self forceDeleteProjectDefinition: loadedProject asDefinition
%

category: 'delete project definitions'
method: RwPrjDeleteTool
forceDeleteProjectSetDefinition: projectSetDefinitionToDelete

	"Remove the classes and methods managed by the listed project definitions."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will NOT fail."

	| loadedProjectSet classesToDelete methodsToDelete mySymbolList |
	loadedProjectSet := projectSetDefinitionToDelete deriveLoadedThings.

	classesToDelete := IdentitySet new.
	methodsToDelete := IdentityKeyValueDictionary new.

	loadedProjectSet do: [:theLoadedProject |
		theLoadedProject 
			loadedPackagesDo: [ :loadedProject :loadedPackage | "ignored" ] 
			loadedClassedDo: [ :loadedProject :loadedPackage :loadedClass | 
				"collect the classes defined in the project"
				classesToDelete add: loadedClass handle currentVersion ] 
			loadedClassExtensionsDo: [:loadedProject :loadedPackage :loadedClassExtension | "ignored" ] 
			loadedInstanceMethodsDo: [:loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod |
				loadedClassOrClassExtension isLoadedClassExtension
					ifTrue: [ 
						"collect extension instance methods"
						((methodsToDelete at: loadedClassOrClassExtension handle currentVersion ifAbsentPut: [Dictionary new]) 
							at: 'instance' ifAbsentPut: [ IdentitySet new ]) add: loadedMethod handle selector ] ] 
			loadedClassMethodsDo: [:loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
				loadedClassOrClassExtension isLoadedClassExtension
					ifTrue: [ 
						"collect extension class methods"
						((methodsToDelete at: loadedClassOrClassExtension handle currentVersion ifAbsentPut: [Dictionary new]) 
							at: 'class' ifAbsentPut: [ IdentitySet new ]) add: loadedMethod handle selector ] ] ].
	classesToDelete do: [:class | 
		"remove any classes that are going to be deleted from methodsToDelete"
		methodsToDelete removeKey: class ifAbsent: [ ] ].

	loadedProjectSet do: [:theLoadedProject |
		"remove the methods, classes, packages and projects from loaded things"
		Rowan projectTools disown disownProjectNamed: theLoadedProject name ].

	mySymbolList := System myUserProfile symbolList. "persistent symbol list"
	classesToDelete do: [:class |
		"remove classes from system"
		(mySymbolList dictionariesAndSymbolsOf: class) do: [:ar |
			GsFile gciLogServer: 'Forcibly delete class ', class name asString printString.
			(ar at: 1) removeKey: (ar at: 2) ] ].

	methodsToDelete keysAndValuesDo: [:class :selectorDict |
		| behavior |
		"remove extension methods from the classes remaining in system"
		GsFile gciLogServer: 'Forcibly remove extension methods from class ', class name asString printString.
		GsFile gciLogServer: '	instance'.
		(selectorDict at: 'instance' ifAbsent: [ #() ]) do: [:selector |
			GsFile gciLogServer: '		', selector asString printString.
			class removeSelector: selector ].
		behavior := class class.
		GsFile gciLogServer: '	class'.
		(selectorDict at: 'class' ifAbsent: [ #() ]) do: [:selector |
			GsFile gciLogServer: '		', selector asString printString.
			behavior removeSelector: selector ] ].
%

! Class implementation for 'RwPrjDiffTool'

!		Instance methods for 'RwPrjDiffTool'

category: 'smalltalk api'
method: RwPrjDiffTool
patchesForProjectDefinition: imageProjectDefinition

	| imagePackageDefinitions diskProjectSet diskProject diskPackageDefinitionMaps |
	imagePackageDefinitions := imageProjectDefinition packages values.
	[ diskProjectSet :=  imageProjectDefinition readProjectSet ]
		on: RwInvalidCategoryProtocolConventionErrorNotification
		do: [:ex | ex resume ].
	diskProject := diskProjectSet projectNamed: imageProjectDefinition name.
	diskPackageDefinitionMaps := diskProject packages.
	^ imagePackageDefinitions collect: [:packageDefinition |
		| imageSnapshot diskPackageDefinition diskSnapshot |
		imageSnapshot := (RwCypressPackageStructure fromPackage: packageDefinition ) snapshot.
		diskPackageDefinition := diskPackageDefinitionMaps at: packageDefinition name.
		diskSnapshot := (RwCypressPackageStructure fromPackage: diskPackageDefinition ) snapshot.
		packageDefinition name -> (CypressPatch fromBase: diskSnapshot toTarget: imageSnapshot) ]
%

category: 'smalltalk api'
method: RwPrjDiffTool
patchesForProjectNamed: projectName

	| imageProject |
	imageProject := Rowan image loadedProjectNamed: projectName.
	^ self patchesForProjectDefinition: imageProject asDefinition
%

! Class implementation for 'RwPrjDisownTool'

!		Instance methods for 'RwPrjDisownTool'

category: 'projects'
method: RwPrjDisownTool
disownProjectNamed: projectName

	"Remove the classes and methods managed by the project from the loaded things."

	"The classes and methods are not removed from the system"

	"Use the adopt tool to restore the classes and methods to the loaded things"

	| loadedProject disownTool |

	loadedProject := Rowan image loadedProjectNamed: projectName.

	disownTool := Rowan packageTools disown.
	loadedProject loadedPackages 
		do: [:loadedPackage |
			disownTool disownPackageNamed: loadedPackage name ].

	Rowan image _removeLoadedProject: loadedProject
%

! Class implementation for 'RwPrjEditTool'

!		Instance methods for 'RwPrjEditTool'

category: 'class editing'
method: RwPrjEditTool
addClass: classDefinition inPackageNamed: packageName inProject: projectDefinition

	"Add the given class definition to the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition addClassDefinition: classDefinition.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
addClass: classDefinition inPackageNamed: packageName inProjectNamed: projectName

	"Add the given class definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

category: 'class extension editting'
method: RwPrjEditTool
addClassExtension: classExtensionDefinition inPackageNamed: packageName inProject: projectDefinition

	"Add the given class extension definition to the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition addClassExtensionDefinition: classExtensionDefinition.
	^ projectDefinition
%

category: 'class extension editting'
method: RwPrjEditTool
addClassExtension: classExtensionDefinition inPackageNamed: packageName inProjectNamed: projectName

	"Add the given class extension definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		addClassExtension: classExtensionDefinition
		inPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

category: 'class editing'
method: RwPrjEditTool
removeClass: classDefinition fromPackageNamed: packageName inProject: projectDefinition

	"Remove the given class definition from the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition removeClassDefinition: classDefinition.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
removeClass: classDefinition fromPackageNamed: packageName inProjectNamed: projectName

	"Remove the given class definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		removeClass: classDefinition
		fromPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

category: 'class editing'
method: RwPrjEditTool
removeClassNamed: className fromPackageNamed: packageName inProject: projectDefinition

	"Remove the named class definition from the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition removeClassNamed: className.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
removeClassNamed: className fromPackageNamed: packageName inProjectNamed: projectName

	"Remove the named class definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		removeClassNamed: className
		fromPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

category: 'class editing'
method: RwPrjEditTool
updateOrAddClass: classDefinition inPackageNamed: packageName inProject: projectDefinition

	"Update or add the given class definition to the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition updateClassDefinition: classDefinition.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
updateOrAddClass: classDefinition inPackageNamed: packageName inProjectNamed: projectName

	"Update or add the given class definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		updateOrAddClass: classDefinition
		inPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

! Class implementation for 'RwPrjLoadTool'

!		Instance methods for 'RwPrjLoadTool'

category: 'load project definitions'
method: RwPrjLoadTool
loadComponentProjectDefinition: projectDefinition

	^ self loadProjectDefinition: projectDefinition platformConfigurationAttributes: Rowan platformConfigurationAttributes
%

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectDefinition: projectDefinition
	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	^ self loadProjectSetDefinition: projectSetDefinition
%

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectDefinition: projectDefinition platformConfigurationAttributes: platformConfigurationAttributes
	"read the configurations for <projectDefinition> to develop the list of dependent projects"

	| visitor projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.
	visitor := Rowan projectTools read
			readConfigurationsForProjectComponentDefinition: projectDefinition
			withConfigurations: projectDefinition loadedConfigurationNames
			groupNames: projectDefinition loadedGroupNames 
			platformConfigurationAttributes: platformConfigurationAttributes
			forLoad: true.
	visitor projectLoadSpecs do: [:loadSpec |
		| dependentProjectDefinition |
		dependentProjectDefinition := loadSpec asDefinition.
		dependentProjectDefinition clone.
		dependentProjectDefinition read do: [:readProjectDef |
			(projectSetDefinition projectNames includes: readProjectDef name)
				ifTrue: [ self error: 'duplicate dependent projects encountered ', readProjectDef name printString]
				ifFalse: [ projectSetDefinition addDefinition: readProjectDef ] ] ].
	^ self loadProjectSetDefinition: projectSetDefinition
%

category: 'load project by spec url'
method: RwPrjLoadTool
loadProjectFromSpecUrl: fileUrlOrString

	| projectDefinition projectSetDefinition res |
	projectDefinition := Rowan projectTools create createProjectDefinitionFromSpecUrl: fileUrlOrString.
	projectSetDefinition := Rowan projectTools read readProjectSetForProjectDefinition: projectDefinition.
	res := self loadProjectSetDefinition: projectSetDefinition.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by spec url'
method: RwPrjLoadTool
loadProjectFromSpecUrl: fileUrlOrString  projectRootPath: projectRootPath

	| projectDefinition projectSetDefinition res |

	projectDefinition := Rowan projectTools create createProjectDefinitionFromSpecUrl: fileUrlOrString projectRootPath: projectRootPath.
	projectSetDefinition := Rowan projectTools read readProjectSetForProjectDefinition: projectDefinition.
	res := self loadProjectSetDefinition: projectSetDefinition.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by spec url'
method: RwPrjLoadTool
loadProjectFromSpecUrl: fileUrlOrString withConfigurations: configNames groupNames: groupNames

	| projectDefinition projectSetDefinition res |
	projectDefinition := Rowan projectTools create createProjectDefinitionFromSpecUrl: fileUrlOrString.
	projectSetDefinition := Rowan projectTools read 
		readProjectSetForProjectDefinition: projectDefinition 
		withConfigurations: configNames
		groupNames: groupNames.
	res := self loadProjectSetDefinition: projectSetDefinition.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by spec url'
method: RwPrjLoadTool
loadProjectFromSpecUrl: fileUrlOrString  withConfigurations: configNames groupNames: groupNames projectRootPath: projectRootPath

	| projectDefinition projectSetDefinition res |

	projectDefinition := Rowan projectTools create createProjectDefinitionFromSpecUrl: fileUrlOrString projectRootPath: projectRootPath.
	projectSetDefinition := Rowan projectTools read 
		readProjectSetForProjectDefinition: projectDefinition 
		withConfigurations: configNames
		groupNames: groupNames.
	res := self loadProjectSetDefinition: projectSetDefinition.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	^ self loadProjectNamed: projectNamed instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed instanceMigrator: instanceMigrator

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed.
	res := self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed withConfigurations: configNames groupNames: groupNames

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	^ self loadProjectNamed: projectNamed withConfigurations: configNames groupNames: groupNames instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed withConfigurations: configNames groupNames: groupNames instanceMigrator: instanceMigrator

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed
		withConfigurations: configNames 
		groupNames: groupNames.
	res := self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed withGroupNames: groupNames

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	^ self loadProjectNamed: projectNamed withGroupNames: groupNames instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed withGroupNames: groupNames instanceMigrator: instanceMigrator

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed
		withGroupNames: groupNames.
	res := self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed_254: projectNamed instanceMigrator: instanceMigrator

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed.
	res := self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectSetDefinition: projectSetDefinitionToLoad

	^ self
		loadProjectSetDefinition: projectSetDefinitionToLoad
		instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectSetDefinition: projectSetDefinition instanceMigrator: instanceMigrator

	"NOTE: when loading a definition into a stone, the loaded things are not marked as non-dirty ... dirty state is relative to the disk image for a
		project and a definition can have come from anywhere"

	^ self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new
%

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectSetDefinition_254: projectSetDefinitionToLoad

	^ self
		loadProjectSetDefinition_254: projectSetDefinitionToLoad
		instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectSetDefinition_254: projectSetDefinition instanceMigrator: instanceMigrator

	"NOTE: when loading a definition into a stone, the loaded things are not marked as non-dirty ... dirty state is relative to the disk image for a
		project and a definition can have come from anywhere"

	^ self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new
%

category: 'utilities'
method: RwPrjLoadTool
markProjectSetNotDirty: projectSetDefinition

	"This method should only be used when the projectSetDefinitions have been read from disk - mark them not dirty. Not dirty means that the loaded things match the code on disk."

	projectSetDefinition deriveLoadedThings do: [:loadedProject |
		loadedProject markNotDirty.
		loadedProject loadedPackages valuesDo: [:loadedPackage | loadedPackage markNotDirty ] ].
%

category: 'private'
method: RwPrjLoadTool
_doProjectSetLoad_254: projectSetDefinition instanceMigrator: instanceMigrator originalProjectSet: originalProjectSet processedClassNames: processedClassNames
	| copiedProjectSetDef theClassName theClass projectDef theLoadedProject loadedClass packageDef |
	[ ^ self
		_loadProjectSetDefinition_254: projectSetDefinition
		instanceMigrator: instanceMigrator ]
			on: RwExistingVisitorAddingExistingClassNotification
			do: [:ex | 
				theClassName := ex classDefinition name.
				(processedClassNames includes: theClassName) ifTrue: [ ex resume ].
				theClass := Rowan globalNamed: theClassName.
				theClass isBehavior ifFalse: [ self halt. ex pass ].
				theLoadedProject := Rowan image loadedProjectNamed: theClass rowanProjectName.
				theLoadedProject 
					ifNil: [ 
						"the loaded project should not be nil - if it is, pass the notification"
						ex pass ].
				(originalProjectSet projectNamed: theLoadedProject name ifAbsent: []) 
					ifNotNil: [
						"If the loadedProject is in the originalProjectSet, then is likely to be a class move - resume and let the chips fall where they may"
						ex resume ].
				copiedProjectSetDef := projectSetDefinition copy.
				"a project in the original project set is taking ownership of an already  loaded class,
					remove the class from the original project's package and attempt a reload"
				projectDef := copiedProjectSetDef 
					projectNamed: theLoadedProject name
					ifAbsent: [ 
						projectDef := theLoadedProject asDefinition.
						copiedProjectSetDef addProject: projectDef.
						projectDef ].
				loadedClass := Rowan image loadedClassNamed: theClassName.
				packageDef := projectDef packageNamed: loadedClass loadedPackage name.
				packageDef removeClassNamed: theClassName.
				processedClassNames add: theClassName ].
	"trim the stack"
	^ self _doProjectSetLoad_254: copiedProjectSetDef instanceMigrator: instanceMigrator originalProjectSet: originalProjectSet processedClassNames: processedClassNames
%

category: 'private'
method: RwPrjLoadTool
_loadProjectSetDefinition_254: projectSetDefinitionToLoad instanceMigrator: instanceMigrator

	| loadedProjectSet loadedProjectDefinitionSet diff loadedProjectInfo| 
	loadedProjectSet := projectSetDefinitionToLoad deriveLoadedThings.
	loadedProjectDefinitionSet := loadedProjectSet asProjectDefinitionSet.
	loadedProjectInfo := projectSetDefinitionToLoad properties at: 'loadedProjectInfo' ifAbsent: [ Dictionary new ].
	loadedProjectInfo keysAndValuesDo: [:projectName :projectInfo |
			"install the packageMapSpecs for this load into the specification prior to the load"
			| projectDefinition |
			projectDefinition := projectSetDefinitionToLoad projectNamed: projectName ifAbsent: [].
			projectDefinition updateGsPlatformSpecLoadedProjectInfo: projectInfo ].
	projectSetDefinitionToLoad definitions keysAndValuesDo: [:projectName :projectDefinition |
			projectDefinition packages keysAndValuesDo: [:packageName :packageDefinition |
				"set the target symbol dictionary name for each incoming package definition"
				packageDefinition gs_symbolDictionary: (projectDefinition symbolDictNameForPackageNamed: packageName) ] ].
	diff := projectSetDefinitionToLoad compareAgainstBase_254: loadedProjectDefinitionSet.
	diff isEmpty
		ifFalse: [  Rowan image applyModification_254: diff instanceMigrator: instanceMigrator ].
	projectSetDefinitionToLoad definitions
		do: [ :projectDef |
			| theProjectDef |
			theProjectDef := (loadedProjectSet entities at: projectDef name ifAbsent: [])
				ifNil: [ projectDef ]
				ifNotNil: [:loadedProject | loadedProject ].
			projectDef projectDefinitionSourceProperty = RwLoadedProject _projectDiskDefinitionSourceValue
				ifTrue: [  theProjectDef updateLoadedCommitId ].
			(loadedProjectInfo at: projectDef name ifAbsent: [])
				ifNotNil: [:map |
					theProjectDef
						loadedConfigurationNames: (map at: 'loadedConfigurationNames');
						loadedGroupNames: (map at: 'loadedGroupNames') ] ].
	^ diff
%

! Class implementation for 'RwPrjLogTool'

!		Instance methods for 'RwPrjLogTool'

category: 'smalltalk api'
method: RwPrjLogTool
commitLogProjectNamed: projectName limit: logLimit

	^ (Rowan image loadedProjectNamed: projectName) commitLog: logLimit
%

category: 'git'
method: RwPrjLogTool
doGitCommitLog: logLimit

	| gitTool gitRootPath |
	gitTool := Rowan gitTools.
	gitRootPath := specification repoSpec repositoryRootPath.
	^ gitTool gitlogtool: 'HEAD' limit: logLimit gitRepoDirectory: gitRootPath
%

! Class implementation for 'RwPrjPullTool'

!		Instance methods for 'RwPrjPullTool'

category: 'git'
method: RwPrjPullTool
doGitPull: remote

	| gitTool gitRootPath |
	gitTool := Rowan gitTools.
	gitRootPath := specification repoSpec repositoryRootPath.
	^ remote isEmpty
		ifTrue: [ gitTool gitpullIn: gitRootPath with: '' ]
		ifFalse: [ 
			| currentBranchName |
			currentBranchName := gitTool gitBranchNameIn: gitRootPath.
			gitTool gitpullIn: gitRootPath with: remote , ' ' , currentBranchName ]
%

category: 'smalltalk api'
method: RwPrjPullTool
pullSpecification: aRwSpecification
  ^ self pullSpecification: aRwSpecification remote: nil
%

category: 'smalltalk api'
method: RwPrjPullTool
pullSpecification: aRwSpecification remote: remoteOrNil
  | remote |
  self specification: aRwSpecification.
  remoteOrNil
    ifNil: [ remote := specification repoSpec remote ]
    ifNotNil: [ remote := remoteOrNil ].
  ^ specification pullForTool: self remote: remote
%

category: 'smalltalk api'
method: RwPrjPullTool
pullSpecUrl: aSpecUrlString
  ^ self
    pullSpecification: (RwSpecification fromUrl: aSpecUrlString)
    remote: nil
%

category: 'smalltalk api'
method: RwPrjPullTool
pullSpecUrl: aSpecUrlString remote: remote
  ^ self
    pullSpecification: (RwSpecification fromUrl: aSpecUrlString)
    remote: remote
%

! Class implementation for 'RwPrjPushTool'

!		Instance methods for 'RwPrjPushTool'

category: 'git'
method: RwPrjPushTool
doGitPush: remote

	| gitTool gitRootPath |
	gitTool := Rowan gitTools.
	gitRootPath := specification repoSpec repositoryRootPath.
	^ remote isEmpty
		ifTrue: [ gitTool gitpushIn: gitRootPath with: '' ]
		ifFalse: [ 
			| currentBranchName |
			currentBranchName := gitTool gitBranchNameIn: gitRootPath.
			gitTool gitpushIn: gitRootPath with: remote , ' ' , currentBranchName ]
%

category: 'smalltalk api'
method: RwPrjPushTool
pushSpecification: aRwSpecification
  ^ self pushSpecification: aRwSpecification remote: nil
%

category: 'smalltalk api'
method: RwPrjPushTool
pushSpecification: aRwSpecification remote: remoteOrNil
  | remote |
  self specification: aRwSpecification.
  remoteOrNil
    ifNil: [ remote := specification repoSpec remote ]
    ifNotNil: [ remote := remoteOrNil ].
  ^ specification pushForTool: self remote: remote
%

category: 'smalltalk api'
method: RwPrjPushTool
pushSpecUrl: aSpecUrlString
  ^ self
    pushSpecification: (RwSpecification fromUrl: aSpecUrlString)
    remote: nil
%

category: 'smalltalk api'
method: RwPrjPushTool
pushSpecUrl: aSpecUrlString remote: remote
  ^ self
    pushSpecification: (RwSpecification fromUrl: aSpecUrlString)
    remote: remote
%

! Class implementation for 'RwPrjQueryTool'

!		Instance methods for 'RwPrjQueryTool'

category: 'smalltalk API'
method: RwPrjQueryTool
classesForProjectNamed: projectName

	| loadedProject classes |
	classes := IdentitySet new.
	loadedProject := Rowan image loadedProjectNamed: projectName.
	loadedProject loadedPackages
		do: [ :loadedPackage | 
			loadedPackage loadedClasses values
				do: [ :rowanLoadedClass | classes add: rowanLoadedClass handle ] ].
	^ classes
%

category: 'smalltalk API'
method: RwPrjQueryTool
classExtensionsForProjectNamed: projectName

	| loadedProject classExtensions |
	classExtensions := IdentitySet new.
	loadedProject := Rowan image loadedProjectNamed: projectName.
	loadedProject loadedPackages
		do: [ :loadedPackage | 
			loadedPackage loadedClassExtensions values
				do: [ :rowanLoadedClass | classExtensions add: rowanLoadedClass handle ] ].
	^ classExtensions
%

! Class implementation for 'RwPrjReadTool'

!		Instance methods for 'RwPrjReadTool'

category: 'read components'
method: RwPrjReadTool
readConfigurationsForProjectComponentDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames platformConfigurationAttributes: platformConfigurationAttributes

	^self 
		readConfigurationsForProjectComponentDefinition: projectDefinition 
			withConfigurations: configNames 
			groupNames: groupNames 
			platformConfigurationAttributes: platformConfigurationAttributes 
			forLoad: true
%

category: 'read components'
method: RwPrjReadTool
readConfigurationsForProjectComponentDefinition: projectComponentDefinition withConfigurations: configNames groupNames: groupNames platformConfigurationAttributes: platformConfigurationAttributes forLoad: forLoad

	| theConfigNames theGroupNames |
	projectComponentDefinition components: Dictionary new. "build new list of components based on (potentially) new list of configNames"
	projectComponentDefinition packages: Dictionary new.	"bulid new list of packages as well"
	theConfigNames := configNames isEmpty
		ifTrue: [ projectComponentDefinition defaultConfigurationNames ]
		ifFalse: [ configNames ].
	theGroupNames := groupNames isEmpty
		ifTrue: [  projectComponentDefinition defaultGroupNames ]
		ifFalse: [ groupNames ].
	^ self 
		_visitConfigurations: RwProjectLoadComponentVisitor 
		forProjectComponentDefinition: projectComponentDefinition 
		withConfigurations: theConfigNames 
		groupNames: theGroupNames
		platformConfigurationAttributes: platformConfigurationAttributes
		forLoad: forLoad
%

category: 'read configurations'
method: RwPrjReadTool
readConfigurationsForProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames

	^self readConfigurationsForProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames forLoad: true
%

category: 'read configurations'
method: RwPrjReadTool
readConfigurationsForProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames forLoad: forLoad

	| theConfigNames theGroupNames |
	theConfigNames := configNames isEmpty
		ifTrue: [ projectDefinition defaultConfigurationNames ]
		ifFalse: [ configNames ].
	theGroupNames := groupNames isEmpty
		ifTrue: [  projectDefinition defaultGroupNames ]
		ifFalse: [ groupNames ].
	^ self 
		_visitConfigurations: RwProjectLoadConfigurationVisitor 
		forProjectDefinition: projectDefinition 
		withConfigurations: theConfigNames 
		groupNames: theGroupNames
		platformConfigurationAttributes: Rowan platformConfigurationAttributes
		forLoad: forLoad
%

category: 'read project definitions'
method: RwPrjReadTool
readProjectDefinition: projectDefinition
	"read all of the packages in the existing Rowan project associated with the given project definition"

	|  repo packageNames |
	repo := projectDefinition repositoryUrl asRwRepository.
	packageNames := repo packageNames.
	^ self 
		_readProjectDefinition: projectDefinition 
		packageNames: packageNames
		fromRepo: repo
%

category: 'read project definitions'
method: RwPrjReadTool
readProjectSetForComponentProjectDefinition: projectComponentDefinition

	projectComponentDefinition loadedConfigurationNames
		ifNotNil: [:configNames |
			"project has been loaded previously, use the loaded config and group names"
			^ self 
					readProjectSetForComponentProjectDefinition: projectComponentDefinition
					withConfigurations: configNames
					groupNames: projectComponentDefinition loadedGroupNames ].
	"project has not been loaded previously use the default config and group names from the spec"
	^ self 
			readProjectSetForComponentProjectDefinition: projectComponentDefinition
			withConfigurations: projectComponentDefinition defaultConfigurationNames
			groupNames: projectComponentDefinition defaultGroupNames
%

category: 'read project definitions'
method: RwPrjReadTool
readProjectSetForComponentProjectDefinition: projectComponentDefinition withConfigurations: configNames groupNames: groupNames

	^ self 
		readProjectSetForComponentProjectDefinition: projectComponentDefinition 
			withConfigurations: configNames 
			groupNames: groupNames 
			platformConfigurationAttributes: Rowan platformConfigurationAttributes
%

category: 'read project definitions'
method: RwPrjReadTool
readProjectSetForComponentProjectDefinition: projectComponentDefinition withConfigurations: configNames groupNames: groupNames platformConfigurationAttributes: platformConfigurationAttributes

	| projectSetDefinition visitor projectVisitorQueue projectVisitedQueue |
	projectSetDefinition := RwProjectSetDefinition new.
	projectVisitedQueue := {}.
	projectVisitorQueue := {
		{ projectComponentDefinition . configNames . groupNames }
	}.
	[ projectVisitorQueue isEmpty ] whileFalse: [
		| nextDefArray pcd cn gn |
		nextDefArray := projectVisitorQueue removeFirst.
		pcd := nextDefArray at: 1. 
		cn := nextDefArray at: 2.
		gn := nextDefArray at: 3.
		visitor := self readConfigurationsForProjectComponentDefinition: pcd withConfigurations: cn groupNames: gn platformConfigurationAttributes: platformConfigurationAttributes.
		visitor visitedComponents keysAndValuesDo: [:cName :cmp | pcd components at: cName put: cmp ].
		projectVisitedQueue addLast: { visitor . nextDefArray  }.
		visitor projectLoadSpecs do: [:loadSpec |
			| lsd |
			lsd := loadSpec asDefinition.
			projectVisitorQueue addLast: {lsd . lsd loadedConfigurationNames . lsd loadedGroupNames } ] ].
	projectVisitedQueue do: [:visitedArray |
		| projectName ndf theVisitor theProjectComponentDefinition theProjectSetDefinition theConfigNames
			theGroupNames thePackageNames thePackageMapSpecs |
		theVisitor := visitedArray at: 1.
		ndf := visitedArray at: 2.
		theProjectComponentDefinition := ndf at: 1.
		projectName := theProjectComponentDefinition name.
		theConfigNames := ndf at: 2.
		theGroupNames := ndf at: 3.
		thePackageNames := theProjectComponentDefinition packageNames.
		theVisitor 
			ifNotNil: [ thePackageMapSpecs := theVisitor packageMapSpecs ]
			ifNil: [ thePackageMapSpecs := Dictionary new ].	
		theProjectSetDefinition := self 
			_readProjectSetForProjectComponentDefinition: theProjectComponentDefinition 
			packageNames: thePackageNames.
		projectSetDefinition addProject: (theProjectSetDefinition projectNamed: projectName).
		((projectSetDefinition properties at: 'loadedProjectInfo' ifAbsentPut: [Dictionary new])
			at: projectName ifAbsentPut: [ Dictionary new ])
				at: 'loadedConfigurationNames' put: theConfigNames;
				at: 'loadedGroupNames' put: theGroupNames;
				at: 'packageMapSpecs' put: thePackageMapSpecs ].
	^ projectSetDefinition
%

category: 'read project definitions'
method: RwPrjReadTool
readProjectSetForProjectDefinition: projectDefinition

	| repo spec packageNames |
	spec := projectDefinition specification.
	spec loadedConfigurationNames
		ifNotNil: [:configNames |
			"project has been loaded previously, use the loaded config and group names"
			^ self 
					readProjectSetForProjectDefinition: projectDefinition
					withConfigurations: configNames
					groupNames: spec loadedGroupNames ].
	spec defaultConfigurationNames
		ifNotNil: [:configNames |
			"project has not been loaded previously use the default config and group names from the spec"
			^ self 
					readProjectSetForProjectDefinition: projectDefinition
					withConfigurations: configNames
					groupNames: spec defaultGroupNames ].
	"no configuration associated with the project, load all of the packages in the repository"
	repo := projectDefinition repositoryUrl asRwRepository.
	packageNames := repo packageNames.
	^ self 
		_readProjectSetForProjectDefinition: projectDefinition 
		packageNames: packageNames
		fromRepo: repo
%

category: 'read project definitions'
method: RwPrjReadTool
readProjectSetForProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames

	| projectName repo spec packageNames projectSetDefinition packageMapSpecs visitor |
	projectName := projectDefinition name.
	spec := projectDefinition specification.
	repo := projectDefinition repositoryUrl asRwRepository.
	visitor := self readConfigurationsForProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames.
	visitor 
		ifNotNil: [ 
			packageNames := visitor packageNames.
			packageMapSpecs := visitor packageMapSpecs ]
		ifNil: [ 
			packageNames := projectDefinition packageNames.
			packageMapSpecs := Dictionary new ].	
	projectSetDefinition := self 
		_readProjectSetForProjectDefinition: projectDefinition 
		packageNames: packageNames 
		fromRepo: repo.
	((projectSetDefinition properties at: 'loadedProjectInfo' ifAbsentPut: [Dictionary new])
		at: projectName ifAbsentPut: [ Dictionary new ])
			at: 'loadedConfigurationNames' put: configNames;
			at: 'loadedGroupNames' put: groupNames;
			at: 'packageMapSpecs' put: packageMapSpecs.
	^ projectSetDefinition
%

category: 'read project by name'
method: RwPrjReadTool
readProjectSetForProjectNamed: projectName

	^ (Rowan image loadedProjectNamed: projectName) asDefinition readProjectSet
%

category: 'read project by name'
method: RwPrjReadTool
readProjectSetForProjectNamed: projectName withConfigurations: configNames groupNames: groupNames

	| projectDefinition |
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	^ projectDefinition
		readProjectSetReadTool: self
			withConfigurations: configNames 
			groupNames: groupNames
%

category: 'read project by name'
method: RwPrjReadTool
readProjectSetForProjectNamed: projectName withGroupNames: groupNames

	| projectDefinition theConfigNames |
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	theConfigNames := projectDefinition loadedConfigurationNames
		ifNotNil: [:configNames | configNames ]
		ifNil: [
			projectDefinition defaultConfigurationNames
				ifNotNil: [:configNames | configNames ]
				ifNil: [ #('Default') ] ].
	^ projectDefinition
		readProjectSetReadTool: self
			withConfigurations: theConfigNames 
			groupNames: groupNames
%

category: 'private'
method: RwPrjReadTool
_readProjectDefinition: projectDefinition packageNames: packageNames fromRepo: repo

	projectDefinition packageNames do: [:packageName | 
		(packageNames includes: packageName) 
			ifFalse: [ 
				"deleted package"
				projectDefinition removePackageNamed: packageName ] ].
	packageNames
		do: [ :packageName | 
			| structureName reader packageDefinition |
			structureName := packageName , repo packageExtension.
			reader := repo reader.
			reader
				packageStructure: (RwCypressPackageStructure named: structureName);
				packageDirectory:
						(reader fileUtils
								directoryFromPath: structureName
								relativeTo: repo directoryPath);
				readPackageStructure.
			packageDefinition := reader packageStructure rwSnapshot.
			projectDefinition addOrUpdatePackage: packageDefinition ].
	projectDefinition propertyAt: RwLoadedProject _projectDefinitionSourceKey put: RwLoadedProject _projectDiskDefinitionSourceValue.
	^ projectDefinition
%

category: 'private'
method: RwPrjReadTool
_readProjectSetForProjectComponentDefinition: projectComponentDefinition packageNames: packageNames

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectComponentDefinition readProjectSetForPackageNames: packageNames.
	projectSetDefinition addProject: projectComponentDefinition.
	projectComponentDefinition propertyAt: RwLoadedProject _projectDefinitionSourceKey put: RwLoadedProject _projectDiskDefinitionSourceValue.
	^ projectSetDefinition
%

category: 'private'
method: RwPrjReadTool
_readProjectSetForProjectDefinition: projectDefinition packageNames: packageNames fromRepo: repo

	self _readProjectDefinition: projectDefinition packageNames: packageNames fromRepo: repo.
	^ RwProjectSetDefinition new
		addProject: projectDefinition;
		yourself
%

category: 'private'
method: RwPrjReadTool
_visitConfigurations: visitorClass forProjectComponentDefinition: projectComponentDefinition withConfigurations: configNames groupNames: groupNames platformConfigurationAttributes: platformConfigurationAttributes forLoad: forLoad

	| projectName configDirectory projectsDirectory visitor |
	projectName := projectComponentDefinition name.
	configDirectory := projectComponentDefinition repositoryRoot / projectComponentDefinition configsPath.
	configDirectory exists
		ifFalse: [ ^ self error: 'No configuration directory (', configDirectory pathString printString, ') found for project ', projectName printString ].
	projectsDirectory := projectComponentDefinition repositoryRoot / projectComponentDefinition projectsPath.
	projectsDirectory exists
		ifFalse: [ ^ self error: 'No projects directory (', projectsDirectory pathString printString, ') found for project ', projectName printString ].
	visitor := visitorClass new
		platformAttributes: platformConfigurationAttributes;
		groupNames: groupNames;
		configurationBasePath: configDirectory pathString;
		projectBasePath: projectsDirectory pathString;
		projectComponentDefinition: projectComponentDefinition;
		yourself.
	configNames do: [:configName |
		| config url |
		url := 'file:' , ((configDirectory / configName) , 'ston') pathString.
		config := RwAbstractProjectConfiguration fromUrl: url.
		config projectName: projectName.
		forLoad
			ifTrue: [
				"expect all config names to represent loadable configurations - throw error if a nested configuration is encountered"
				visitor visit: config ]
			ifFalse: [ 
				"resolve config names without respect to whether or not the configuration is loadable"
				visitor visitNested: config ] ].
	^visitor
%

category: 'private'
method: RwPrjReadTool
_visitConfigurations: visitorClass forProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames platformConfigurationAttributes: platformConfigurationAttributes forLoad: forLoad

	| projectName configDirectory visitor |
	projectDefinition repositoryRootPath ifNil: [ ^ nil ].
	projectName := projectDefinition name.
	configDirectory := projectDefinition repositoryRootPath asFileReference / projectDefinition configsPath.
	configDirectory exists
		ifFalse: [ ^ nil ].
	visitor := visitorClass new
		platformAttributes: platformConfigurationAttributes;
		groupNames: groupNames;
		configurationBasePath: configDirectory pathString;
		yourself.
	configNames do: [:configName |
		| config url |
		url := 'file:' , ((configDirectory / configName) , 'ston') pathString.
		config := RwAbstractProjectConfiguration fromUrl: url.
		config projectName: projectName.
		forLoad
			ifTrue: [
				"expect all config names to represent loadable configurations - throw error if a nested configuration is encountered"
				visitor visit: config ]
			ifFalse: [ 
				"resolve config names without respect to whether or not the configuration is loadable"
				visitor visitNested: config ] ].
	^visitor
%

! Class implementation for 'RwPrjReconcileTool'

!		Instance methods for 'RwPrjReconcileTool'

category: 'smalltalk api'
method: RwPrjReconcileTool
reconcileGlobalClassExtensionsForProjectDefinitionSet: projectDefinitionSet defaultGroupName: defaultGroupName globalsGroupName: globalsGroupName globalsUserId: globalsUserId

	| configExportMap |
	configExportMap := Dictionary new.
	projectDefinitionSet projects do: [:projectDef |
		| config movedClassExtensions globalPackageNames originalPackageNames |
		movedClassExtensions := Set new.
		globalPackageNames := Set new.
		originalPackageNames := projectDef packageNames.
		projectDef packages values do: [:packageDef |
			packageDef classExtensions values do: [:classDef |
				(Globals 
					at: classDef name asSymbol 
					ifAbsent: [])
						ifNotNil: [ 
							"the class extension is for a class that is Globals, so it needs to be moved to a new Globals extension package"
							movedClassExtensions add: {classDef . packageDef . projectDef } ] ] ].
		movedClassExtensions do: [:ar |
			| theClassDef packageDef theProjectDef  newPackageName |
			theClassDef := ar at: 1.
			packageDef := ar at: 2.
			theProjectDef := ar at: 3.
			newPackageName :=  packageDef name , '-Globals'.
			self 
				_moveClassExtension: theClassDef 
				toNewPackageNamed: packageDef name , '-Globals'
				clonedFrom: packageDef 
				inProject: theProjectDef.
			globalPackageNames add: newPackageName ].
		config := RwProjectLoadConfiguration new
			name: 'Default';
			projectName: projectDef name;
			yourself.
		{ defaultGroupName . globalsGroupName }
			do: [:groupName | config addDefinedGroupName: groupName ].
		config 
			conditionalPackagesAtConditions: { Rowan platform basePlatformAttribute } 
				andGroup: defaultGroupName 
				addPackageNames: originalPackageNames;
			conditionalPackagesAtConditions: { Rowan platform basePlatformAttribute } 
				andGroup: globalsGroupName 
				addPackageNames: globalPackageNames.
		globalPackageNames do: [:packageName |
			config 
				conditionalPackageMapSpecsAtGemStoneUserId: globalsUserId 
				andPackageName: packageName 
				setSymbolDictNameTo: 'Globals' ].
		configExportMap at: config put: projectDef configurationExportUrl ].
	^ configExportMap
%

category: 'smalltalk api'
method: RwPrjReconcileTool
reconcileGlobalClassExtensionsForProjectFromSpecUrl: specUrl defaultGroupName: defaultGroupName globalsGroupName: globalsGroupName  globalsUserId: globalsUserId writeProject: writeProjectBool
	| projectDefinition projectDefinitionSet projectTools loadedProjectInfo configExportMap |
	projectTools := Rowan projectTools.
	projectDefinition := projectTools create createProjectDefinitionFromSpecUrl: specUrl.
	projectDefinitionSet := projectTools read readProjectSetForProjectDefinition: projectDefinition.

	loadedProjectInfo := projectDefinitionSet properties at: 'loadedProjectInfo' ifAbsent: [ Dictionary new ].
	loadedProjectInfo keysAndValuesDo: [:projectName :projectInfo |
			"install the packageMapSpecs for this load into the specification prior to the reconcile"
			(projectDefinitionSet projectNamed: projectName ifAbsent: [])
				updateGsPlatformSpecLoadedProjectInfo: projectInfo ].

	configExportMap := self 
		reconcileGlobalClassExtensionsForProjectDefinitionSet: projectDefinitionSet 
		defaultGroupName: defaultGroupName 
		globalsGroupName: globalsGroupName  
		globalsUserId: globalsUserId.
	writeProjectBool
		ifTrue: [
			configExportMap keysAndValuesDo: [:config :exportUrl |
				config exportToUrl: exportUrl ].
			projectTools write writeProjectDefinition: projectDefinition ].
	^ projectDefinition
%

category: 'smalltalk api'
method: RwPrjReconcileTool
reconcileProjectDefinitionSet: projectDefinitionSet
	| movedClassExtensions packageNameToSymbolDictNameMap configExportMap |

	configExportMap := Dictionary new.
	movedClassExtensions := Set new.
	packageNameToSymbolDictNameMap := Dictionary new.
	projectDefinitionSet projects do: [:projectDef |
		| config |
		projectDef packages values do: [:packageDef |
			packageDef classDefinitions values do: [:classDef |
				self 
					_checkExpectedSymbolDictForClassDefinition: classDef 
					packageDef: packageDef 
					projectDef: projectDef 
					classNotFound: [:theClassDef  | self error: 'The class ', theClassDef name printString, ' not found' ] 
					ifCorrect: [:theClassDef :actualSymDictName | 
						(packageNameToSymbolDictNameMap at: packageDef name ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol ] 
					ifIncorrect: [:theClassDef :expectedSymDictName :actualSymDictName | 
						"the class is defined in the actualSymDictName and that's where the package should be loaded"
						(packageNameToSymbolDictNameMap at: packageDef name ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol ] ].
			packageDef classExtensions values do: [:classDef |
				self 
					_checkExpectedSymbolDictForClassDefinition: classDef 
					packageDef: packageDef 
					projectDef: projectDef 
					classNotFound: [:theClassDef  | self error: 'The class to be extended ', theClassDef name printString, ' not found'  ] 
					ifCorrect: [:theClassDef :actualSymDictName | 
						(packageNameToSymbolDictNameMap at: packageDef name ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol ] 
					ifIncorrect: [:theClassDef :expectedSymDictName :actualSymDictName | 
						"the class extension is in the actualSymDictName and that's where the package should be loaded"
						movedClassExtensions add: {theClassDef . packageDef . actualSymDictName . projectDef } ] ] ].
		movedClassExtensions do: [:ar |
			| theClassDef packageDef actualSymDictName theProjectDef  newPackageDef|
			theClassDef := ar at: 1.
			packageDef := ar at: 2.
			actualSymDictName := ar at: 3.
			theProjectDef := ar at: 4.
			newPackageDef := self 
				_moveClassExtension: theClassDef 
				toNewPackageClonedFrom: packageDef 
				inSymbolDictionary: actualSymDictName 
				inProject: theProjectDef.
			(packageNameToSymbolDictNameMap at: newPackageDef name ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol  ].
		config := projectDef configurationTemplate.
		packageNameToSymbolDictNameMap keysAndValuesDo: [:packageName :symDictNames |
			symDictNames size > 1 ifTrue: [ self error: 'More than one symbol dictionary associated with package ', packageName printString ].
			config 
				conditionalPackageMapSpecsAtGemStoneUserId: Rowan image currentUserId 
				andPackageName: packageName 
				setSymbolDictNameTo: symDictNames any ].
		configExportMap at: config put: projectDef configurationExportUrl ].
	^ configExportMap
%

category: 'smalltalk api'
method: RwPrjReconcileTool
reconcileProjectFromSpecUrl: specUrl writeProject: writeProjectBool
	| projectDefinition projectDefinitionSet projectTools loadedProjectInfo configExportMap |
	projectTools := Rowan projectTools.
	projectDefinition := projectTools create createProjectDefinitionFromSpecUrl: specUrl.
	projectDefinitionSet := projectTools read readProjectSetForProjectDefinition: projectDefinition.

	loadedProjectInfo := projectDefinitionSet properties at: 'loadedProjectInfo' ifAbsent: [ Dictionary new ].
	loadedProjectInfo keysAndValuesDo: [:projectName :projectInfo |
			"install the packageMapSpecs for this load into the specification prior to the reconcile"
			(projectDefinitionSet projectNamed: projectName ifAbsent: [])
				updateGsPlatformSpecLoadedProjectInfo: projectInfo ].

	configExportMap := self reconcileProjectDefinitionSet: projectDefinitionSet.
	writeProjectBool
		ifTrue: [
			configExportMap keysAndValuesDo: [:config :exportUrl |
				config exportToUrl: exportUrl ].
			projectTools write writeProjectDefinition: projectDefinition ].
	^ projectDefinition
%

category: 'private'
method: RwPrjReconcileTool
_checkExpectedSymbolDictForClassDefinition: classDef packageDef: packageDef projectDef: projectDef classNotFound: classNotFoundBlock ifCorrect: correctBlock ifIncorrect: incorrectBlock
	| class ar symDict expectedSymDictName actualSymDictName |
	class := Rowan globalNamed: classDef name.
	class
		ifNil: [ classNotFoundBlock value: classDef ]
		ifNotNil: [
			ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
			ar size > 1 ifTrue: [self error: 'The class ', classDef name printString, ' is in multiple symbol dictionaries'].
			symDict := ar first at: 1.
			actualSymDictName := symDict name asString.
			expectedSymDictName := projectDef symbolDictNameForPackageNamed: packageDef name.
			expectedSymDictName = actualSymDictName
				ifTrue: [ correctBlock value: classDef value: actualSymDictName ]
				ifFalse: [ incorrectBlock value:  classDef value: expectedSymDictName value: actualSymDictName ] ]
%

category: 'private'
method: RwPrjReconcileTool
_moveClassExtension: theClassExtension toNewPackageClonedFrom: packageDef inSymbolDictionary: expectedSymDictName inProject: projectDef

	| newPackageName newPackageDef |
	newPackageName := packageDef name, '-ext-', expectedSymDictName.
	newPackageDef := projectDef 
		packageNamed: newPackageName 
		ifAbsent: [ 
			| pDef |
			pDef := RwPackageDefinition newNamed: newPackageName.
			projectDef addPackage: pDef.
			pDef ].
	packageDef removeClassExtensionDefinition: theClassExtension.
	newPackageDef addClassExtensionDefinition: theClassExtension.
	"update the method categories --- hybrid only ... but that is what we're doing"
	theClassExtension instanceMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	theClassExtension classMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	^ newPackageDef
%

category: 'private'
method: RwPrjReconcileTool
_moveClassExtension: theClassExtension toNewPackageNamed: newPackageName clonedFrom: packageDef inProject: projectDef

	| newPackageDef |
	newPackageDef := projectDef 
		packageNamed: newPackageName 
		ifAbsent: [ 
			| pDef |
			pDef := RwPackageDefinition newNamed: newPackageName.
			projectDef addPackage: pDef.
			pDef ].
	packageDef removeClassExtensionDefinition: theClassExtension.
	newPackageDef addClassExtensionDefinition: theClassExtension.
	"update the method categories --- hybrid only ... but that is what we're doing"
	theClassExtension instanceMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	theClassExtension classMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	^ newPackageDef
%

! Class implementation for 'RwPrjTestTool'

!		Instance methods for 'RwPrjTestTool'

category: 'smalltalk api'
method: RwPrjTestTool
testSuiteForProjectNamed: projectName

	| suite |
	suite := TestSuite named: projectName , ' tests'.
	self _addTestsForProjectNamed: projectName toTestSuite: suite.
	^ suite
%

category: 'smalltalk api'
method: RwPrjTestTool
testSuiteForProjectsNamed: projectNames

	| suite strm |
	strm := WriteStream on: String new.
	projectNames do: [:projectName | strm nextPutAll: projectName; space ].
	strm nextPutAll:  'tests'.
	suite := TestSuite named: strm contents.
	projectNames do: [:projectName | self _addTestsForProjectNamed: projectName toTestSuite: suite ].
	^ suite
%

category: 'private'
method: RwPrjTestTool
_addTestsForProjectNamed: projectName toTestSuite: suite

	| loadedProject |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	loadedProject loadedPackages
		do: [ :loadedPackage | 
			loadedPackage loadedClasses values
				do: [ :rowanLoadedClass | 
					| cl |
					cl := rowanLoadedClass handle.
					(cl inheritsFrom: TestCase)
						ifTrue: [ 
							cl isAbstract
								ifFalse: [ suite addTests: cl suite tests ] ] ] ].
	^ suite
%

! Class implementation for 'RwPrjWriteTool'

!		Instance methods for 'RwPrjWriteTool'

category: 'smalltalk api'
method: RwPrjWriteTool
writeComponentProjectDefinition: projectDefinition

	Rowan projectTools create createProjectRepository: projectDefinition projectRef.
	projectDefinition 
		exportProjects;
		exportComponents;
		exportPackages
%

category: 'smalltalk api'
method: RwPrjWriteTool
writeProjectDefinition: projectDefinition

	projectDefinition export
%

category: 'smalltalk api'
method: RwPrjWriteTool
writeProjectNamed: projectName

	| loadedProject projectDefinition |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	projectDefinition := loadedProject asDefinition.
	self writeProjectDefinition: projectDefinition.
	"loaded project and loaded packages written to disk - mark them not dirty"
	loadedProject markNotDirty.
	loadedProject loadedPackages valuesDo: [:loadedPackage | loadedPackage markNotDirty ].
%

category: 'private'
method: RwPrjWriteTool
_loadedPackagesForProject: projectDefinition

	"Answer a PackageSet containing packages for the given project definition."

	^ self
		_loadedPackagesNamed: projectDefinition packageNames
		forProject: projectDefinition
%

category: 'private'
method: RwPrjWriteTool
_loadedPackagesNamed: someNames forProject: projectDefinition

	"Answer a PackageSet containing packages with the given names in the image.
 	If any name is not a loaded package, that name is ignored."

	"very likely we should be dealing with a project name at this point ... unless there is a use 
		case for loading a collection of packages without directly using the project interface 
		--- loaded packages do know what project they belong to ... so there might be something 
		done behind the scenes"

	| loadedPackages |
	loadedPackages := someNames
		collect: [ :aName | 
			projectDefinition packageNamed: aName ifAbsent: [ self error: 'package not a member of projectDefinition' ].
			Rowan image loadedPackageNamed: aName ifAbsent: [ nil ] ].
	^ RwEntitySet
		withAll:
			(loadedPackages
				select: [ :loadedPackage | 
					loadedPackage notNil
						and: [ loadedPackage loadedProject name = projectDefinition name ] ])
%

! Class implementation for 'RwAuditDetail'

!		Class methods for 'RwAuditDetail'

category: 'other'
classmethod: RwAuditDetail
for: anObject message: aString	
"add error to results. print to file"
	
	^self new owner: anObject; 
			message: aString; 
			notify; 
			yourself
%

!		Instance methods for 'RwAuditDetail'

category: 'other'
method: RwAuditDetail
matches: aString
"see if my messages matches expected string"

	^self message matchPattern: {$* . aString . $*}
%

category: 'other'
method: RwAuditDetail
message

	^message
%

category: 'other'
method: RwAuditDetail
message: aString

	message := aString
%

category: 'other'
method: RwAuditDetail
notify

	GsFile gciLogServer: self message,'  ', self owner name asString.
	Notification signal: self message asString,'  ', self owner name asString.
%

category: 'other'
method: RwAuditDetail
owner
	^owner
%

category: 'other'
method: RwAuditDetail
owner: anObject

	owner := anObject
%

category: 'other'
method: RwAuditDetail
printOn: aStream

	aStream 
			nextPutAll: '---------------';
			nextPutAll: self owner name asString.
	self owner isMeta ifTrue: [aStream space; nextPutAll: 'class'].
	aStream
			nextPutAll: '>>';
			nextPutAll: self message
%

! Class implementation for 'RwClassAdditionOrRemoval'

!		Class methods for 'RwClassAdditionOrRemoval'

category: 'instance creation'
classmethod: RwClassAdditionOrRemoval
packageDefinition: aPackageDefinition classKey: aClassKey classesModification: aClassesModification

	^(self new)
		packageDefinition: aPackageDefinition;
		classKey: aClassKey;
		classesModification: aClassesModification;
		yourself
%

category: 'instance creation'
classmethod: RwClassAdditionOrRemoval
projectDefinition: aProjectDefinition packageDefinition: aPackageDefinition classKey: aClassKey classesModification: aClassesModification

	^(self new)
		projectDefinition: aProjectDefinition;
		packageDefinition: aPackageDefinition;
		classKey: aClassKey;
		classesModification: aClassesModification;
		yourself
%

!		Instance methods for 'RwClassAdditionOrRemoval'

category: 'Accessing'
method: RwClassAdditionOrRemoval
classesModification
	^classesModification
%

category: 'Updating'
method: RwClassAdditionOrRemoval
classesModification: newValue
	classesModification := newValue
%

category: 'Accessing'
method: RwClassAdditionOrRemoval
classKey
	^classKey
%

category: 'Updating'
method: RwClassAdditionOrRemoval
classKey: newValue
	classKey := newValue
%

category: 'Accessing'
method: RwClassAdditionOrRemoval
packageDefinition
	^packageDefinition
%

category: 'Updating'
method: RwClassAdditionOrRemoval
packageDefinition: newValue
	packageDefinition := newValue
%

category: 'Accessing'
method: RwClassAdditionOrRemoval
projectDefinition
	^projectDefinition
%

category: 'Updating'
method: RwClassAdditionOrRemoval
projectDefinition: newValue
	projectDefinition := newValue
%

! Class implementation for 'RwConfiguration'

!		Instance methods for 'RwConfiguration'

category: 'testing'
method: RwConfiguration
needsPackageProtocolNames

	"Answer true if image protocol names need to be *<packageName>*"

	^ packageInfoSource == #'Category'
%

category: 'accessing'
method: RwConfiguration
packageInfoSource
	^packageInfoSource
%

category: 'accessing'
method: RwConfiguration
packageInfoSource: newValue
	"Valid values for GemStone are #Cypress, #Category, #SymbolDictionary"

	packageInfoSource := newValue
%

! Class implementation for 'RwDefinition'

!		Class methods for 'RwDefinition'

category: 'instance creation'
classmethod: RwDefinition
new

	^(super new)
		initialize;
		yourself
%

!		Instance methods for 'RwDefinition'

category: 'private'
method: RwDefinition
addDefinition: aDefinition to: aDictionary

	| key |
	key := aDefinition key.
	(aDictionary includesKey: key)
		ifTrue: [self error: 'Duplicate definition.'].
	^ aDictionary at: key put: aDefinition
%

category: 'converting'
method: RwDefinition
asDefinition
  ^ self
%

category: 'comparing'
method: RwDefinition
compareAgainstBase: aDefinition
	"Diff myself for changes against the given base definition. 
	Answer a Modification, which might be empty if there are no changes."

	self subclassResponsibility
%

category: 'comparing'
method: RwDefinition
compareAgainstBaseForNewClassVersion: aBaseDefinition

	"Diff myself for changes against the given base definition. 
	Answer a Modification, which might be empty if there are no changes."

	"Filter the definition to include changes that are only applicable to new class versions"

	self subclassResponsibility
%

category: 'comparing'
method: RwDefinition
compareDictionary: myDictionary againstBaseDictionary: baseDictionary into: anElementsModification elementClass: elementClass

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys do: 
			[:key |
			| before after modification |
			before := baseDictionary at: key ifAbsent: [elementClass new].
			after := myDictionary at: key ifAbsent: [elementClass new].
			modification := after compareAgainstBase: before.
			modification isEmpty
				ifFalse: [anElementsModification addElementModification: modification]]
%

category: 'initialization'
method: RwDefinition
initialize

	properties := Dictionary new
%

category: 'testing'
method: RwDefinition
isEmpty
	"Answer true if this definition does not actually define anything.
	All definitions are expected to have at least a name property."

	^properties isEmpty
%

category: 'properties'
method: RwDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container."

	self subclassResponsibility
%

category: 'copying'
method: RwDefinition
postCopy

	| oldProperties |
	super postCopy.
	oldProperties := properties.
	properties := Dictionary new.
	oldProperties keysAndValuesDo: [:key :value| properties at: key put: value copy ]
%

category: 'printing'
method: RwDefinition
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' for ';
		nextPutAll: (self key ifNil: ['nil'])
%

category: 'accessing'
method: RwDefinition
properties

	^properties
%

category: 'accessing'
method: RwDefinition
properties: propertiesDictionary

	properties := propertiesDictionary
%

category: 'accessing'
method: RwDefinition
propertyAt: aKey

	^properties at: aKey
%

category: 'accessing'
method: RwDefinition
propertyAt: aKey ifAbsent: absentBlock

	^properties at: aKey ifAbsent: absentBlock
%

category: 'properties'
method: RwDefinition
propertyAt: aKey put: aValue

	^properties at: aKey put: aValue
%

category: 'private'
method: RwDefinition
removeDefinition: aDefinition from: aDictionary

	| key |
	key := aDefinition key.
	aDictionary
		removeKey: key
		ifAbsent: [ self error: 'no definition for ' , key printString , ' found' ]
%

category: 'private'
method: RwDefinition
removeKey: key from: aDictionary

	aDictionary
		removeKey: key
		ifAbsent: [ self error: 'no definition for ' , key printString , ' found' ]
%

category: 'private'
method: RwDefinition
updateDefinition: aDefinition in: aDictionary

	| key |
	key := aDefinition key.
	aDictionary at: key put: aDefinition
%

category: 'private'
method: RwDefinition
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue

	^ propertyValue = baseValue
%

! Class implementation for 'RwAbstractClassDefinition'

!		Class methods for 'RwAbstractClassDefinition'

category: 'instance creation'
classmethod: RwAbstractClassDefinition
withProperties: propertiesDictionary classMethodDefinitions: classMethodDefinitions instanceMethodDefinitions: instanceMethodDefinitions

	^(self basicNew)
		properties: propertiesDictionary;
		classMethodDefinitions: classMethodDefinitions;
		instanceMethodDefinitions: instanceMethodDefinitions;
		yourself
%

!		Instance methods for 'RwAbstractClassDefinition'

category: 'accessing'
method: RwAbstractClassDefinition
addClassMethod: methodSource protocol: protocol

	^self addClassMethodDefinition: (RwMethodDefinition newForSource: methodSource protocol: protocol)
%

category: 'accessing'
method: RwAbstractClassDefinition
addClassMethodDefinition: aMethodDefinition

	self addDefinition: aMethodDefinition to: classMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
addInstanceMethod: methodSource protocol: protocol

	^self addInstanceMethodDefinition: (RwMethodDefinition newForSource: methodSource protocol: protocol)
%

category: 'accessing'
method: RwAbstractClassDefinition
addInstanceMethodDefinition: aMethodDefinition

	self addDefinition: aMethodDefinition to: instanceMethodDefinitions
%

category: 'private'
method: RwAbstractClassDefinition
addMethodDefinition: aMethodDefinition to: aDictionary

	| selector |
	selector := aMethodDefinition propertyAt: 'selector'.
	(aDictionary includesKey: selector)
		ifTrue: [self error: 'Duplicate selector in behavior'].
	aDictionary at: selector put: aMethodDefinition
%

category: 'accessing'
method: RwAbstractClassDefinition
classMethodDefinitions

	^classMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
classMethodDefinitions: dictionaryOfDefinitions

	classMethodDefinitions := dictionaryOfDefinitions
%

category: 'comparing'
method: RwAbstractClassDefinition
compareAgainstBase: aDefinition

	| modification instanceMethodsModification classMethodsModification className |
	modification := self _modificationClass before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	className := self _classNameForCompare: aDefinition.
	instanceMethodsModification := self _methodsModificationClass
		extendedClassName: className.
	classMethodsModification := self _methodsModificationClass
		extendedClassName: className.
	self
		compareDictionary: instanceMethodDefinitions
		againstBaseDictionary: aDefinition instanceMethodDefinitions
		into: instanceMethodsModification
		elementClass: RwMethodDefinition
		isMeta: false.
	self
		compareDictionary: classMethodDefinitions
		againstBaseDictionary: aDefinition classMethodDefinitions
		into: classMethodsModification
		elementClass: RwMethodDefinition
		isMeta: true.
	modification
		instanceMethodsModification: instanceMethodsModification;
		classMethodsModification: classMethodsModification.
	^ modification
%

category: 'comparing'
method: RwAbstractClassDefinition
compareAgainstBaseForNewClassVersion: aDefinition

	"all unchanged and unremoved methods need to be applied to the patch"

	| modification instanceMethodsModification classMethodsModification |
	modification := self _modificationClass before: aDefinition after: self.
	instanceMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	classMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	self
		compareDictionary: instanceMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition instanceMethodDefinitions
		into: instanceMethodsModification
		elementClass: RwMethodDefinition
		isMeta: false.
	self
		compareDictionary: classMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition classMethodDefinitions
		into: classMethodsModification
		elementClass: RwMethodDefinition
		isMeta: true.
	modification
		instanceMethodsModification: instanceMethodsModification;
		classMethodsModification: classMethodsModification.
	^ modification
%

category: 'comparing'
method: RwAbstractClassDefinition
compareDictionary: myDictionary againstBaseDictionary: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys do: 
			[:key |
			| before after modification |
			before := baseDictionary at: key ifAbsent: [elementClass new].
			after := myDictionary at: key ifAbsent: [elementClass new].
			modification := after compareAgainstBase: before.
			modification 
				isMeta: isClassMeta;
				classDefinition: self.
			modification isEmpty
				ifFalse: [anElementsModification addElementModification: modification]]
%

category: 'comparing'
method: RwAbstractClassDefinition
compareDictionary: myDictionary againstBaseDictionaryForNewClassVersion: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys
		do: [ :key | 
			(baseDictionary
				at: key
				ifAbsent: [ 
					"additions do not apply for new class version - the original modification should not be changed"
					 ])
				ifNotNil: [ :before | 
					(myDictionary
						at: key
						ifAbsent: [ 
							"deletions do not apply for new class version - the original modification should not be changed"
							 ])
						ifNotNil: [ :after | 
							| modification |
							modification := after compareAgainstBaseForNewClassVersion: before.
							modification
								isMeta: isClassMeta;
								classDefinition: self.
							modification isEmpty
								ifFalse: [ anElementsModification addElementModification: modification ] ] ] ]
%

category: 'initialization'
method: RwAbstractClassDefinition
initialize

	super initialize.
	classMethodDefinitions := Dictionary new.
	instanceMethodDefinitions := Dictionary new
%

category: 'accessing'
method: RwAbstractClassDefinition
instanceMethodDefinitions

	^instanceMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
instanceMethodDefinitions: dictionaryOfDefinitions

	instanceMethodDefinitions := dictionaryOfDefinitions
%

category: 'testing'
method: RwAbstractClassDefinition
isClassExtension
	^ false
%

category: 'testing'
method: RwAbstractClassDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & classMethodDefinitions isEmpty
		& instanceMethodDefinitions isEmpty
%

category: 'private'
method: RwAbstractClassDefinition
key

	^properties at: 'name' ifAbsent: [nil]
%

category: 'accessing'
method: RwAbstractClassDefinition
name: aString

	properties at: 'name' put: aString
%

category: 'copying'
method: RwAbstractClassDefinition
postCopy

	| oldDefs |
	super postCopy.
	oldDefs := classMethodDefinitions.
	classMethodDefinitions := Dictionary new.
	oldDefs keysAndValuesDo: [:key :value | classMethodDefinitions at: key put: value copy ].
	oldDefs := instanceMethodDefinitions.
	instanceMethodDefinitions := Dictionary new.
	oldDefs keysAndValuesDo: [:key :value | instanceMethodDefinitions at: key put: value copy ].
%

category: 'accessing'
method: RwAbstractClassDefinition
removeClassMethod: selector

	| definition |
	definition := classMethodDefinitions
		at: selector
		ifAbsent: [ self error: 'No method definition for ' , selector printString , ' found.' ].
	self removeDefinition: definition from: classMethodDefinitions.
	^ definition
%

category: 'accessing'
method: RwAbstractClassDefinition
removeInstanceMethod: selector

	| definition |
	definition := instanceMethodDefinitions
		at: selector
		ifAbsent: [ self error: 'No method definition for ' , selector printString , ' found.' ].
	self removeDefinition: definition from: instanceMethodDefinitions.
	^ definition
%

category: 'accessing'
method: RwAbstractClassDefinition
updateClassMethodDefinition: aMethodDefinition

	self updateDefinition: aMethodDefinition in: classMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
updateInstanceMethodDefinition: aMethodDefinition

	self updateDefinition: aMethodDefinition in: instanceMethodDefinitions
%

category: 'private'
method: RwAbstractClassDefinition
_classNameForCompare: aDefinition

	^ self key ifNil: [ aDefinition key ]
%

category: 'private'
method: RwAbstractClassDefinition
_methodsModificationClass

	self subclassResponsibility: #'__methodsModificationClass'
%

category: 'private'
method: RwAbstractClassDefinition
_modificationClass

	self subclassResponsibility: #'_modificationClass'
%

! Class implementation for 'RwClassDefinition'

!		Class methods for 'RwClassDefinition'

category: 'instance creation'
classmethod: RwClassDefinition
newForClassNamed: className super: superClassName category: category

	^ self 
		newForClassNamed: className 
		super: superClassName 
		instvars: #() 
		classinstvars: #() 
		classvars: #() 
		category: category 
		comment: nil 
		pools: #() 
		type: 'normal'
%

category: 'instance creation'
classmethod: RwClassDefinition
newForClassNamed: className super: superClassName instvars: instvars classinstvars: classinstvars classvars: classvars category: category comment: comment pools: pools type: type

	| propertiesDictionary |
	propertiesDictionary := Dictionary new.
	category
		ifNotNil: [ 
			propertiesDictionary
				at: 'category' put: category;
				yourself ].
	propertiesDictionary
		at: 'classinstvars' put: classinstvars;
		at: 'classvars' put: classvars;
		at: 'instvars' put: instvars;
		at: 'name' put: className;
		at: 'pools' put: pools;
		at: 'superclass' put: superClassName;
		at: 'type' put: type asString.
	comment ifNotNil: [ propertiesDictionary at: 'comment' put: comment ].
	^ self
		withProperties: propertiesDictionary
		classMethodDefinitions: Dictionary new
		instanceMethodDefinitions: Dictionary new
%

!		Instance methods for 'RwClassDefinition'

category: 'accessing'
method: RwClassDefinition
classType
	"Legal types are normal, variable, and bytes."

	^self propertyAt: 'type' ifAbsent: ['normal']
%

category: 'accessing'
method: RwClassDefinition
classVarNames
  ^ properties at: 'classvars'
%

category: 'accessing'
method: RwClassDefinition
classVarNames: anArrayOfClassVarNames

	^ properties at: 'classvars' put: anArrayOfClassVarNames
%

category: 'accessing'
method: RwClassDefinition
comment: aString
  properties at: 'comment' put: aString
%

category: 'accessing'
method: RwClassDefinition
instVarNames

	^ properties at: 'instvars'
%

category: 'accessing'
method: RwClassDefinition
instVarNames: arrayOfInstanceVariableNames

	^ properties at: 'instvars' put: arrayOfInstanceVariableNames
%

category: 'accessing'
method: RwClassDefinition
superclassName

	^self propertyAt: 'superclass' ifAbsent: [self propertyAt: 'super']
%

category: 'accessing'
method: RwClassDefinition
superclassName: aString

	^ self propertyAt: 'superclass' put: aString
%

! Class implementation for 'RwClassExtensionDefinition'

!		Class methods for 'RwClassExtensionDefinition'

category: 'instance creation'
classmethod: RwClassExtensionDefinition
newForClassNamed: className

	| propertiesDictionary |
	propertiesDictionary := Dictionary new
		at: 'name' put: className;
		yourself.
	^ self
		withProperties: propertiesDictionary
		classMethodDefinitions: Dictionary new
		instanceMethodDefinitions: Dictionary new
%

!		Instance methods for 'RwClassExtensionDefinition'

category: 'comparing'
method: RwClassExtensionDefinition
compareDictionary: myDictionary againstBaseDictionary: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys
		do: [ :key | 
			| before after modification |
			before := baseDictionary at: key ifAbsent: [ elementClass new ].
			after := myDictionary at: key ifAbsent: [ elementClass new ].
			modification := after compareExtensionMethodsAgainstBase: before.
			modification
				isMeta: isClassMeta;
				classDefinition: self.
			modification isEmpty
				ifFalse: [ anElementsModification addElementModification: modification ] ]
%

category: 'testing'
method: RwClassExtensionDefinition
isClassExtension
	^ true
%

category: 'private'
method: RwClassExtensionDefinition
_classNameForCompare: aDefinition

	^ self key ifNil: 
		[ | cName |
		cName := aDefinition key.
		self name: cName.
		cName ]
%

! Class implementation for 'RwAbstractComponentDefinition'

!		Class methods for 'RwAbstractComponentDefinition'

category: 'instance creation'
classmethod: RwAbstractComponentDefinition
newNamed: componentName

	^ self new
			name: componentName;
			yourself
%

!		Instance methods for 'RwAbstractComponentDefinition'

category: 'accessing'
method: RwAbstractComponentDefinition
addComponent: aComponentDefinition

	| key |
	key := aComponentDefinition key.
	(components includesKey: key) ifTrue: [self error: 'Duplicate component'].
	^ components at: key put: aComponentDefinition
%

category: 'accessing'
method: RwAbstractComponentDefinition
addComponentNamed: componentName

	^ self addComponent: (RwComponentDefinition newNamed: componentName)
%

category: 'accessing'
method: RwAbstractComponentDefinition
addPackage: aPackageDefinition

	| key |
	key := aPackageDefinition key.
	(packages includesKey: key) ifTrue: [self error: 'Duplicate package'].
	^ packages at: key put: aPackageDefinition
%

category: 'accessing'
method: RwAbstractComponentDefinition
addPackageNamed: packageName

	^ self addPackage: (RwPackageDefinition newNamed: packageName)
%

category: 'accessing'
method: RwAbstractComponentDefinition
addSubComponentNamed: subComponentName

	^ self addComponent: (RwSubComponentDefinition newNamed: subComponentName)
%

category: 'initialization'
method: RwAbstractComponentDefinition
initialize

	super initialize.
	components := Dictionary new.
	packages := Dictionary new.
%

category: 'accessing'
method: RwAbstractComponentDefinition
key

	^properties at: 'name' ifAbsent: [nil]
%

category: 'accessing'
method: RwAbstractComponentDefinition
name

	^ self key
%

category: 'accessing'
method: RwAbstractComponentDefinition
name: aString 

	properties at: 'name' put: aString
%

! Class implementation for 'RwAbstractRepositoryDefinition'

!		Class methods for 'RwAbstractRepositoryDefinition'

category: 'instance creation'
classmethod: RwAbstractRepositoryDefinition
newForSpecification: aRwSpecification projectHome: projectHomeFileReferenceOrString

	^ self 
		newNamed: aRwSpecification specName 
		forSpecification: aRwSpecification 
		projectHome: projectHomeFileReferenceOrString
%

category: 'instance creation'
classmethod: RwAbstractRepositoryDefinition
newNamed: repositoryName forSpecification: aRwSpecification projectHome: projectHomeFileReferenceOrString

	| cls projectHomeFileReference |
	projectHomeFileReference := projectHomeFileReferenceOrString asFileReference.
	cls := (aRwSpecification useGit and: [ projectHomeFileReference fileSystem isDiskFileSystem ])
		ifTrue: [ RwGitRepositoryDefinition ]
		ifFalse: [  projectHomeFileReference fileSystem rowanRepositoryDefinitionClass ].
	^ (self _instanceClass: cls)
		newNamed: aRwSpecification specName 
			forSpecification: aRwSpecification 
			repositoryRoot: projectHomeFileReference / aRwSpecification specName
%

category: 'instance creation'
classmethod: RwAbstractRepositoryDefinition
newNamed: repositoryName forSpecification: aRwSpecification repositoryRoot: repoRoot

	^ self
		newNamed: repositoryName 
			repositoryRoot: repoRoot
			projectUrl: aRwSpecification projectUrl
			committish: aRwSpecification repoSpec committish 
			committishType: aRwSpecification repoSpec committishType
%

category: 'instance creation'
classmethod: RwAbstractRepositoryDefinition
newNamed: repositoryName repositoryRoot: repoRoot 

	^ self new
		name: repositoryName;
		repositoryRoot: repoRoot;
		yourself
%

category: 'instance creation'
classmethod: RwAbstractRepositoryDefinition
newNamed: repositoryName repositoryRoot: repoRoot projectUrl: anUrlString

	^ self new
		name: repositoryName;
		repositoryRoot: repoRoot;
		projectUrl: anUrlString;
		yourself
%

category: 'instance creation'
classmethod: RwAbstractRepositoryDefinition
newNamed: repositoryName repositoryRoot: repoRoot projectUrl: anUrlString committish: committish committishType: committishType

	^ self new
		name: repositoryName;
		repositoryRoot: repoRoot;
		projectUrl: anUrlString;
		committish: committish committishType: committishType;
		yourself
%

category: 'private'
classmethod: RwAbstractRepositoryDefinition
_instanceClass: defaultInstanceClass
	"default class only needed when receiver is the abstract class"

	self == RwAbstractRepositoryDefinition
		ifTrue: [ ^ defaultInstanceClass ].
	^ self
%

!		Instance methods for 'RwAbstractRepositoryDefinition'

category: 'actions'
method: RwAbstractRepositoryDefinition
attach

	self error: 'not yet implemented'
%

category: 'testing'
method: RwAbstractRepositoryDefinition
canCommit

	^ false
%

category: 'actions'
method: RwAbstractRepositoryDefinition
clone

	"attach to existing cloned disk structure or clone project from remote repository"

	"who wins? resolve or clone"

	self subclassResponsibility: #clone
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
commitId

	^ ''
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
commitLog: logLimit

	^ ''
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
committish

	^ self properties at: 'committish' ifAbsent: []
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
committish: aString committishType: committishTypeString

	self properties at: 'committish' put: aString.
	self properties at: 'committishType' put: committishTypeString.
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
committishType

	^ self properties at: 'committishType' ifAbsent: []
%

category: 'actions'
method: RwAbstractRepositoryDefinition
create

	self error: 'not yet implemented'
%

category: 'actions'
method: RwAbstractRepositoryDefinition
doCommit: message

	"noop by default"
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
gitRoot: ignored
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
key

	^properties at: 'name' ifAbsent: [nil]
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
name

	^ self key
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
name: aString 

	properties at: 'name' put: aString
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
projectUrl

	^ self properties at: 'projectUrl' ifAbsent: [ '' ]
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
projectUrl: anUrlString

	anUrlString ifNil: [ ^ self properties removeKey: 'projectUrl' ifAbsent: [ ] ].
	self properties at: 'projectUrl' put: anUrlString
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
repositoryCommitId

	^ ''
%

category: 'testing'
method: RwAbstractRepositoryDefinition
repositoryExists

	^ self repositoryRoot exists
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ self properties at: 'repositoryRoot'
%

category: 'accessing'
method: RwAbstractRepositoryDefinition
repositoryRoot: pathStringOrReference

	| fileRef |
	fileRef := pathStringOrReference asFileReference.
	self projectUrl: nil.
	self gitRoot: nil.
	self properties at: 'repositoryRoot' put: fileRef
%

category: 'actions'
method: RwAbstractRepositoryDefinition
resolve

	"attach to existing repository structure or create"

	"who wins? resolve or clone"

	self subclassResponsibility: #resolve
%

category: 'private'
method: RwAbstractRepositoryDefinition
_fileSystem

	self subclassResponsibility: #_fileSystem
%

! Class implementation for 'RwDiskRepositoryDefinition'

!		Instance methods for 'RwDiskRepositoryDefinition'

category: 'private'
method: RwDiskRepositoryDefinition
_fileSystem

	^ FileSystem disk
%

! Class implementation for 'RwGitRepositoryDefinition'

!		Class methods for 'RwGitRepositoryDefinition'

category: 'instance creation'
classmethod: RwGitRepositoryDefinition
newNamed: repositoryName forSpecification: aRwSpecification repositoryRoot: repoRoot

	^ (super newNamed: repositoryName forSpecification: aRwSpecification repositoryRoot: repoRoot)
		committish: aRwSpecification repoSpec committish committishType: aRwSpecification repoSpec committishType;
		remoteUrl: aRwSpecification remoteUrl;
		yourself
%

category: 'instance creation'
classmethod: RwGitRepositoryDefinition
newNamed: repositoryName repositoryRoot: repoRoot projectUrl: anUrlString remoteUrl: aRemoreUrlStrng committish: committish committishType:committishType

	^ self new
		name: repositoryName;
		repositoryRoot: repoRoot;
		projectUrl: anUrlString;
		remoteUrl: aRemoreUrlStrng;
		committish: committish committishType:committishType;
		yourself
%

!		Instance methods for 'RwGitRepositoryDefinition'

category: 'testing'
method: RwGitRepositoryDefinition
canCommit

	^ true
%

category: 'actions'
method: RwGitRepositoryDefinition
clone

	"attach to existing cloned disk structure or clone project from remote repository"

	"who wins? resolve or clone"

	Rowan projectTools clone
		cloneRepository: self
%

category: 'accessing'
method: RwGitRepositoryDefinition
commitId

	^ [  Rowan gitTools gitcommitShaIn: self gitRoot pathString ]
		on: Error
		do: [ :ignored | 
			"most likely no commits yet"
			'' ].
%

category: 'loading'
method: RwGitRepositoryDefinition
commitLog: logLimit

	^ Rowan gitTools gitlogtool: 'HEAD' limit: logLimit gitRepoDirectory: self gitRoot pathString
%

category: 'actions'
method: RwGitRepositoryDefinition
doCommit: message

	| gitTool gitRootPath commitMessageFileName status |
	gitTool := Rowan gitTools.
	gitRootPath := self repositoryRoot pathString.
	commitMessageFileName := gitTool createTmpFileWith: message.
	gitTool gitaddIn: gitRootPath with: '-A .'.
	gitTool gitcommitIn: gitRootPath with: '--file=' , commitMessageFileName.
	status := gitTool gitlogIn: gitRootPath with: '-1'.
	Transcript
		cr;
		show: '==============';
		cr;
		show: status.
	^ status
%

category: 'accessing'
method: RwGitRepositoryDefinition
gitRoot
	"The root directory of the git repository that the project is located in. If the project is not git based
		or the git root is not explicitly assigned, git root is synonymous with repository root."

	^ self properties at: 'gitRoot' ifAbsent: [ self repositoryRoot ]
%

category: 'accessing'
method: RwGitRepositoryDefinition
gitRoot: aGitRootReferenceOrString

	aGitRootReferenceOrString ifNil: [ ^ self properties removeKey: 'gitRoot' ifAbsent: [] ].
	^ self properties at: 'gitRoot' put: aGitRootReferenceOrString asFileReference
%

category: 'accessing'
method: RwGitRepositoryDefinition
remoteUrl

	^ self properties at: 'remoteUrl' ifAbsentPut: [ self _createRemoteUrl ]
%

category: 'accessing'
method: RwGitRepositoryDefinition
remoteUrl: aRemoteUrlString

	^ self properties at: 'remoteUrl' put: aRemoteUrlString
%

category: 'accessing'
method: RwGitRepositoryDefinition
repositoryCommitId

	^ [  Rowan gitTools gitcommitShaIn: self gitRoot pathString ]
			on: Error
			do: [ :ignored | 
			"most likely no commits yet"
			'' ]
%

category: 'actions'
method: RwGitRepositoryDefinition
resolve

	"attach to existing git repository structure, clone, or create"

	"who wins? resolve or clone"

	Rowan projectTools clone
		cloneRepository: self
%

category: 'private'
method: RwGitRepositoryDefinition
_createRemoteUrl

	| projectUrl remoteUrl segments |
	self projectUrl isEmpty ifTrue:  [ ^ nil ].
	projectUrl := RwUrl fromString: self projectUrl.
	remoteUrl := 'git@' , projectUrl authority , ':'.
	segments := projectUrl segments.
	remoteUrl := segments size = 1
		ifTrue: [ remoteUrl , (segments at: 1) , '.git ' ]
		ifFalse: [ remoteUrl , (segments at: 1) , '/' , (projectUrl segments at: 2) , '.git ' ].
	^ remoteUrl
%

! Class implementation for 'RwMemoryRepositoryDefinition'

!		Instance methods for 'RwMemoryRepositoryDefinition'

category: 'private'
method: RwMemoryRepositoryDefinition
_fileSystem

	^ FileSystem memory
%

! Class implementation for 'RwDefinitionSetDefinition'

!		Instance methods for 'RwDefinitionSetDefinition'

category: 'accessing'
method: RwDefinitionSetDefinition
addDefinition: aDefinition

	| key |
	key := aDefinition key.
	(definitions includesKey: key)
		ifTrue: [ self error: 'Duplicate definition ' ].
	definitions at: key put: aDefinition
%

category: 'accessing'
method: RwDefinitionSetDefinition
definitionNames

	^ self definitions keys asArray
%

category: 'accessing'
method: RwDefinitionSetDefinition
definitions

	^ definitions
%

category: 'accessing'
method: RwDefinitionSetDefinition
definitionWithKey: aKey ifAbsent: absentBlock

	^ definitions at: aKey ifAbsent: absentBlock
%

category: 'deriving'
method: RwDefinitionSetDefinition
deriveLoadedThings

	self subclassResponsibility: #'deriveLoadedThings'
%

category: 'enumerating'
method: RwDefinitionSetDefinition
do: aBlock

	^ self definitions do: aBlock
%

category: 'initialization'
method: RwDefinitionSetDefinition
initialize

	super initialize.
	definitions := Dictionary new
%

category: 'testing'
method: RwDefinitionSetDefinition
isEmpty

	"Answer true if this definition does not actually define anything."

	^ super isEmpty & definitions isEmpty
%

category: 'properties'
method: RwDefinitionSetDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container.
	But PackageSets have no container, so we don't expect them to have a key."

	^nil
%

category: 'accessing'
method: RwDefinitionSetDefinition
keys

	^ definitions keys
%

category: 'copying'
method: RwDefinitionSetDefinition
postCopy

	super postCopy.
	definitions := definitions copy
%

category: 'printing'
method: RwDefinitionSetDefinition
printOn: aStream

	aStream nextPutAll: self asString
%

category: 'accessing'
method: RwDefinitionSetDefinition
size

	^ definitions size
%

! Class implementation for 'RwPackageSetDefinition'

!		Instance methods for 'RwPackageSetDefinition'

category: 'accessing'
method: RwPackageSetDefinition
addPackage: aDefinition

	self addDefinition: aDefinition
%

category: 'deriving'
method: RwPackageSetDefinition
deriveLoadedThings

	^ RwEntitySet
		withAll:
			((self definitionNames
				collect: [ :packageName | Rowan image loadedPackageNamed: packageName ifAbsent: [  ] ])
				select: [ :each | each notNil ])
%

category: 'accessing'
method: RwPackageSetDefinition
packageNames

	^ self definitionNames
%

category: 'accessing'
method: RwPackageSetDefinition
packages

	^ self definitions
%

! Class implementation for 'RwProjectSetDefinition'

!		Instance methods for 'RwProjectSetDefinition'

category: 'accessing'
method: RwProjectSetDefinition
addProject: aDefinition

	self addDefinition: aDefinition
%

category: 'deriving'
method: RwProjectSetDefinition
deriveLoadedThings

	"extract the loaded projects that correspond to the project defintions held by the receiver"

	^ RwEntitySet
		withAll:
			((self definitionNames
				collect: [ :projectName | Rowan image loadedProjectNamed: projectName ifAbsent: [  ] ])
				select: [ :each | each notNil ])
%

category: 'accessing'
method: RwProjectSetDefinition
projectNamed: projectName

	^ self 
		projectNamed: projectName
		ifAbsent: [ self error: 'No project named ', projectName printString , ' found.']
%

category: 'accessing'
method: RwProjectSetDefinition
projectNamed: projectName ifAbsent: absentBlock

	^ self definitionWithKey: projectName ifAbsent: absentBlock
%

category: 'accessing'
method: RwProjectSetDefinition
projectNames

	^ self definitionNames
%

category: 'accessing'
method: RwProjectSetDefinition
projects

	^ self definitions
%

! Class implementation for 'RwMethodDefinition'

!		Class methods for 'RwMethodDefinition'

category: 'instance creation'
classmethod: RwMethodDefinition
newForSelector: selector protocol: protocol source: source

	^ self
		withProperties:
			(Dictionary with: 'selector' -> selector with: 'protocol' -> protocol)
		source: source
%

category: 'instance creation'
classmethod: RwMethodDefinition
newForSource: methodSource protocol: protocol

	| selector |
	selector := Rowan platform parseSelectorFrom: methodSource.
	^ self
		newForSelector: selector asSymbol
		protocol: protocol
		source: methodSource
%

category: 'instance creation'
classmethod: RwMethodDefinition
withProperties: propertiesDictionary source: sourceString 

	^(self basicNew)
		properties: propertiesDictionary;
		source: sourceString;
		yourself
%

!		Instance methods for 'RwMethodDefinition'

category: 'testing'
method: RwMethodDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & source isNil
%

category: 'private'
method: RwMethodDefinition
key

	^properties at: 'selector' ifAbsent: [nil]
%

category: 'accessing'
method: RwMethodDefinition
protocol

	^properties at: 'protocol'
%

category: 'accessing'
method: RwMethodDefinition
protocol: aString

	properties at: 'protocol' put: aString
%

category: 'accessing'
method: RwMethodDefinition
selector

	^properties at: 'selector'
%

category: 'accessing'
method: RwMethodDefinition
source

	^source
%

category: 'accessing'
method: RwMethodDefinition
source: sourceString

	source := sourceString
%

! Class implementation for 'RwPackageDefinition'

!		Class methods for 'RwPackageDefinition'

category: 'instance creation'
classmethod: RwPackageDefinition
newNamed: packageName

	^ self
		withProperties: (Dictionary with: 'name' -> packageName)
		classDefinitions: Dictionary new
		classExtensions: Dictionary new
%

category: 'instance creation'
classmethod: RwPackageDefinition
withProperties: properties classDefinitions: classDefinitions classExtensions: classExtensionDefinitions

	^(self basicNew)
		properties: properties;
		classDefinitions: classDefinitions;
		classExtensions: classExtensionDefinitions;
		yourself
%

!		Instance methods for 'RwPackageDefinition'

category: 'accessing'
method: RwPackageDefinition
addClassDefinition: aClassDefinition

	^ self addDefinition: aClassDefinition to: classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
addClassExtensionDefinition: aClassExtensionDefinition

	^ self addDefinition: aClassExtensionDefinition to: classExtensions
%

category: 'accessing'
method: RwPackageDefinition
addClassExtensionNamed: className

	^ self addClassExtensionDefinition: (RwClassExtensionDefinition newForClassNamed: className)
%

category: 'accessing'
method: RwPackageDefinition
addClassNamed: className super: superclassName category: categryName

	^ self addClassDefinition: (RwClassDefinition newForClassNamed: className super: superclassName  category: categryName)
%

category: 'accessing'
method: RwPackageDefinition
addClassNamed: className super: superclassName instvars: instvars classinstvars: classinstvars classvars: classvars category: category comment: comment pools: pools type: type

	^ self addClassDefinition: 
		(RwClassDefinition 
			newForClassNamed: className 
				super: superclassName 
				instvars: instvars 
				classinstvars: 
				classinstvars 
				classvars: classvars 
				category: category 
				comment: comment 
				pools: pools 
				type: type)
%

category: 'accessing'
method: RwPackageDefinition
classDefinitionNamed: className

	^ self classDefinitionNamed: className ifAbsent: [ self error: 'No class definition found with the name ', className printString ]
%

category: 'accessing'
method: RwPackageDefinition
classDefinitionNamed: className ifAbsent: absentBlock

	^ self classDefinitions at: className ifAbsent: absentBlock
%

category: 'accessing'
method: RwPackageDefinition
classDefinitions

	^classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
classDefinitions: classDefinitionDictionary

	classDefinitions := classDefinitionDictionary
%

category: 'accessing'
method: RwPackageDefinition
classExtensionDefinitionNamed: className ifAbsent: absentBlock

	^ self classExtensions at: className ifAbsent: absentBlock
%

category: 'accessing'
method: RwPackageDefinition
classExtensions

	^classExtensions
%

category: 'accessing'
method: RwPackageDefinition
classExtensions: classExtensionDefinitionsDictionary

	classExtensions := classExtensionDefinitionsDictionary
%

category: 'initialization'
method: RwPackageDefinition
initialize

	super initialize.
	classDefinitions := Dictionary new.
	classExtensions := Dictionary new
%

category: 'testing'
method: RwPackageDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & classDefinitions isEmpty & classExtensions isEmpty
%

category: 'properties'
method: RwPackageDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container."

	^self propertyAt: 'name' ifAbsent: [nil]
%

category: 'copying'
method: RwPackageDefinition
postCopy

	| oldDefs |
	super postCopy.
	oldDefs := classDefinitions.
	classDefinitions := Dictionary new.
	oldDefs keysAndValuesDo: [:key :value | classDefinitions at: key put: value copy ].
	oldDefs := classExtensions.
	classExtensions := Dictionary new.
	oldDefs keysAndValuesDo: [:key :value | classExtensions at: key put: value copy ].
%

category: 'accessing'
method: RwPackageDefinition
removeClassDefinition: aClassDefinition

	self removeDefinition: aClassDefinition from: classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
removeClassExtensionDefinition: aClassExtension

	self removeDefinition: aClassExtension from: classExtensions
%

category: 'accessing'
method: RwPackageDefinition
removeClassExtensionDefinitionNamed: className

	self removeKey: className from: classExtensions
%

category: 'accessing'
method: RwPackageDefinition
removeClassNamed: className

	self removeKey: className from: classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
updateClassDefinition: aClassDefinition

	self updateDefinition: aClassDefinition in: classDefinitions
%

! Class implementation for 'RwProjectDefinition'

!		Class methods for 'RwProjectDefinition'

category: 'instance creation'
classmethod: RwProjectDefinition
newForDiskBasedProjectNamed: aString

	| spec |
	spec := RwSimpleProjectSpecification new
		specName: aString;
		repoSpec: RwDiskRepositorySpecification new;
		yourself.
	^ self newForSpecification: spec
%

category: 'instance creation'
classmethod: RwProjectDefinition
newForGitBasedProjectNamed: aString

	| spec |
	spec := RwSimpleProjectSpecification new
		specName: aString;
		yourself.
	^ self newForSpecification: spec
%

category: 'instance creation'
classmethod: RwProjectDefinition
newForSpecification: aRwSpecification

	^ self
		withProperties:
			(Dictionary new
				add: 'name' -> aRwSpecification specName;
				add: 'spec' -> aRwSpecification;
				yourself)
		packageDefinitions: Dictionary new
%

category: 'instance creation'
classmethod: RwProjectDefinition
withProperties: properties packageDefinitions: packageDefinitions

	^ self basicNew
		properties: properties;
		packages: packageDefinitions;
		yourself
%

!		Instance methods for 'RwProjectDefinition'

category: 'accessing'
method: RwProjectDefinition
addOrUpdatePackage: aPackageDefinition

	| key |
	key := aPackageDefinition key.
	packages at: key put: aPackageDefinition
%

category: 'accessing'
method: RwProjectDefinition
addPackage: aPackageDefinition

	| key |
	key := aPackageDefinition key.
	(packages includesKey: key) ifTrue: [self error: 'Duplicate package'].
	^ packages at: key put: aPackageDefinition
%

category: 'accessing'
method: RwProjectDefinition
addPackageNamed: packageName

	^ self addPackage: (RwPackageDefinition newNamed: packageName)
%

category: 'accessing'
method: RwProjectDefinition
addPackagesNamed: packageNames

	packageNames
		do: [ :packageName | self addPackage: (RwPackageDefinition newNamed: packageName) ]
%

category: 'properties'
method: RwProjectDefinition
canCommit

	^ self specification canCommit
%

category: 'properties'
method: RwProjectDefinition
comment

	^ self specification comment
%

category: 'properties'
method: RwProjectDefinition
comment: aString

	self specification comment: aString
%

category: 'actions'
method: RwProjectDefinition
commit: message
	"lperform commit on the repository associated with receiver ..."

	^ Rowan projectTools commit commitProjectDefinition: self message: message
%

category: 'properties'
method: RwProjectDefinition
configsPath

	^ self specification configsPath
%

category: 'properties'
method: RwProjectDefinition
configsPath: aDirectoryPathString

	self specification configsPath: aDirectoryPathString
%

category: 'properties'
method: RwProjectDefinition
configurationExportUrl

	"Return an RwFileUrl suitable for saving the receiver's configuration in the appropriate configs directory"

	| exportPath |
	self repositoryUrl
		ifNil: [ self error: 'RepositoryUrl has not been set. Receiver has not bee associated with an existing Rowan project on disk.' ].
	exportPath := self repositoryRootPath , '/' , self configsPath , '/'.
	^('file:' , exportPath) asRwUrl
%

category: 'properties'
method: RwProjectDefinition
configurationTemplate

	"Return a generic RwProjectLoadConfiguration based on the list of packages in the reciever"

	| config groupNames |
	config := RwProjectLoadConfiguration new
		name: 'Default';
		projectName: self specification specName;
		yourself.
	groupNames := self specification defaultGroupNames.
	groupNames
		do: [:groupName | config addDefinedGroupName: groupName ].
	config 
		conditionalPackagesAtConditions: { Rowan platform basePlatformAttribute } 
		andGroup: (groupNames at: 1) 
		addPackageNames: self packageNames.
	^ config
%

category: 'properties'
method: RwProjectDefinition
defaultConfigurationNames

	^self specification defaultConfigurationNames
%

category: 'properties'
method: RwProjectDefinition
defaultGroupNames

	^self specification defaultGroupNames
%

category: 'accessing'
method: RwProjectDefinition
definitionWithKey: aKey ifAbsent: absentBlock

	^packages at: aKey ifAbsent: absentBlock
%

category: 'actions'
method: RwProjectDefinition
export

	Rowan projectTools write writeDeprecatedProjectDefinition: self
%

category: 'initialization'
method: RwProjectDefinition
initialize

	super initialize.
	packages := Dictionary new
%

category: 'testing'
method: RwProjectDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & packages isEmpty
%

category: 'properties'
method: RwProjectDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container."

	^self propertyAt: 'name' ifAbsent: [nil]
%

category: 'accessing'
method: RwProjectDefinition
keys

	^packages keys
%

category: 'actions'
method: RwProjectDefinition
load
	"load the receiver into the image"

	^ Rowan projectTools load loadProjectDefinition: self
%

category: 'properties'
method: RwProjectDefinition
loadedCommitId

	^ self specification loadedCommitId
%

category: 'properties'
method: RwProjectDefinition
loadedConfigurationNames

	^ self specification loadedConfigurationNames
%

category: 'properties'
method: RwProjectDefinition
loadedConfigurationNames: anArray

	^ self specification imageSpec loadedConfigurationNames: anArray
%

category: 'properties'
method: RwProjectDefinition
loadedGroupNames: anArray

	^ self specification imageSpec loadedGroupNames: anArray
%

category: 'accessing'
method: RwProjectDefinition
packageNamed: aString

	^ self
		packageNamed: aString
		ifAbsent: [ self error: 'A package named ' , aString printString , ' was not found.' ]
%

category: 'accessing'
method: RwProjectDefinition
packageNamed: aString ifAbsent: absentBlock

	^ self packages at: aString ifAbsent: absentBlock
%

category: 'accessing'
method: RwProjectDefinition
packageNames
  ^ self packages keys asArray
%

category: 'accessing'
method: RwProjectDefinition
packageNames: packageNames

	packageNames
		do: [ :packageName | self addPackageNamed: packageName ]
%

category: 'accessing'
method: RwProjectDefinition
packages

	^packages
%

category: 'accessing'
method: RwProjectDefinition
packages: aPackageDefinitionDictionary

	packages := aPackageDefinitionDictionary
%

category: 'copying'
method: RwProjectDefinition
postCopy

	| oldPackages |
	super postCopy.
	oldPackages := packages.
	packages := Dictionary new.
	oldPackages keysAndValuesDo: [:key : value | packages at: key put: value copy ] .
%

category: 'tool api'
method: RwProjectDefinition
readProjectSet

	^ Rowan projectTools read  readProjectSetForProjectDefinition: self
%

category: 'reading'
method: RwProjectDefinition
readProjectSetReadTool: readTool withConfigurations: theConfigNames groupNames: theGroupNames

	^ readTool
		readProjectSetForProjectDefinition: self
			withConfigurations: theConfigNames 
			groupNames: theGroupNames
%

category: 'accessing'
method: RwProjectDefinition
removePackage: aPackageDefinition

	| key |
	key := aPackageDefinition key.
	(packages includesKey: key) ifFalse: [self error: 'Package not present.'].
	packages removeKey: key
%

category: 'accessing'
method: RwProjectDefinition
removePackageNamed: packageName

	^self removePackage: (self packageNamed: packageName)
%

category: 'properties'
method: RwProjectDefinition
repoPath

	^ self specification repoPath
%

category: 'properties'
method: RwProjectDefinition
repoPath: aDirectoryPathString

	self specification repoPath: aDirectoryPathString
%

category: 'properties'
method: RwProjectDefinition
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ self repositoryRootPath asFileReference
%

category: 'properties'
method: RwProjectDefinition
repositoryRootPath

	^ self specification repositoryRootPath
%

category: 'properties'
method: RwProjectDefinition
repositoryRootPath: rootRepoPath

	self specification repositoryRootPath: rootRepoPath
%

category: 'properties'
method: RwProjectDefinition
repositoryUrl

	^ self specification repositoryUrl
%

category: 'properties'
method: RwProjectDefinition
repositoryUrl: aString

	self specification repositoryUrl: aString
%

category: 'properties'
method: RwProjectDefinition
specification

	^ properties at: 'spec'
%

category: 'properties'
method: RwProjectDefinition
specsPath

	^ self specification specsPath
%

category: 'properties'
method: RwProjectDefinition
specsPath: aDirectoryPathString

	self specification specsPath: aDirectoryPathString
%

category: 'loading'
method: RwProjectDefinition
updateLoadedCommitId

	| loadedCommitId |
	loadedCommitId := [  Rowan gitTools gitcommitShaIn: self repositoryRoot pathString ]
		on: Error
		do: [ :ignored | 
			"most likely no commits yet"
			^ nil ].
	self specification imageSpec loadedCommitId: loadedCommitId
%

category: 'properties'
method: RwProjectDefinition
useGit

	^ self specification useGit
%

! Class implementation for 'RwComponentProjectDefinition'

!		Class methods for 'RwComponentProjectDefinition'

category: 'instance creation'
classmethod: RwComponentProjectDefinition
newForDiskBasedProjectNamed: projectName

	^ self newForProjectReference: (RwProjectReferenceDefinition
		projectName: projectName 
			useGit: false )
%

category: 'instance creation'
classmethod: RwComponentProjectDefinition
newForGitBasedProjectNamed: projectName

	^ self newForProjectReference: (RwProjectReferenceDefinition
		projectName: projectName 
			useGit: true )
%

category: 'instance creation'
classmethod: RwComponentProjectDefinition
newForProjectReference: aRwProjectReferenceDefintion

	^ self
		withProperties:
			(Dictionary new
				add: 'name' -> aRwProjectReferenceDefintion projectAlias;
				add: 'projectRef' -> aRwProjectReferenceDefintion;
				yourself)
		packageDefinitions: Dictionary new
%

category: 'instance creation'
classmethod: RwComponentProjectDefinition
newForSpecification: aRwSpecification

	^ RwComponentProjectDefinition newForProjectReference: (RwProjectReferenceDefinition newForSpecification: aRwSpecification)
%

category: 'instance creation'
classmethod: RwComponentProjectDefinition
newForUrl: specUrl

	^ self newForSpecification: specUrl asRwUrl asSpecification
%

category: 'instance creation'
classmethod: RwComponentProjectDefinition
projectName: projectName componentNamesToLoad: componentNamesToLoad groupNamesToLoad: groupNamesToLoad defaultComponentName: defaultComponentName defaultGroupName: defaultGroupName packageFormat: packageFormat projectHome: projectHomeFileReferenceOrString specsPath: specsPath componentsPath: componentsPath packagesPath: packagesPath projectsPath: projectsPath projectUrl: projectUrl committish: commitish committishType: committishType comment: comment

	| projectRef |
	projectRef := RwProjectReferenceDefinition new
		projectName: projectName;
		configurationNames: componentNamesToLoad;
		defaultComponentName: defaultComponentName;
		groupNames: groupNamesToLoad;
		useGit: true;
		comment: comment;
		projectHome: projectHomeFileReferenceOrString;
		configsPath: componentsPath;
		packagesPath: packagesPath;
		projectsPath: projectsPath;
		specsPath: specsPath;
		packageFormat: packageFormat;
		defaultGroupName: defaultGroupName;
		projectUrl: projectUrl;
		committish: commitish
			committishType: committishType;
		yourself.
	^ self newForProjectReference: projectRef
%

category: 'instance creation'
classmethod: RwComponentProjectDefinition
projectName: projectName componentNamesToLoad: componentNamesToLoad groupNamesToLoad: groupNamesToLoad defaultComponentName: defaultComponentName defaultGroupName: defaultGroupName packageFormat: packageFormat projectHome: projectHomeFileReferenceOrString specsPath: specsPath componentsPath: componentsPath packagesPath: packagesPath projectsPath: projectsPath useGit: useGit comment: comment

	| projectRef |
	projectRef := RwProjectReferenceDefinition new
		projectName: projectName;
		configurationNames: componentNamesToLoad;
		defaultComponentName: defaultComponentName;
		groupNames: groupNamesToLoad;
		useGit: useGit;
		comment: comment;
		projectHome: projectHomeFileReferenceOrString;
		configsPath: componentsPath;
		packagesPath: packagesPath;
		projectsPath: projectsPath;
		specsPath: specsPath;
		packageFormat: packageFormat;
		defaultGroupName: defaultGroupName;
		yourself.
	^ self newForProjectReference: projectRef
%

category: 'instance creation'
classmethod: RwComponentProjectDefinition
projectName: projectName projectHome: projectHomeFileReferenceOrString useGit: useGit comment: comment

	| projectRef |
	projectRef := RwProjectReferenceDefinition new
		projectName: projectName;
		useGit: useGit;
		comment: comment;
		projectHome: projectHomeFileReferenceOrString;
		yourself.
	^ self newForProjectReference: projectRef
%

category: 'instance creation'
classmethod: RwComponentProjectDefinition
withProperties: properties packageDefinitions: packageDefinitions

	^ self basicNew
		properties: properties;
		packages: packageDefinitions;
		yourself
%

!		Instance methods for 'RwComponentProjectDefinition'

category: 'visiting'
method: RwComponentProjectDefinition
acceptVisitor: aVisitor

	^ aVisitor visitComponentProjectDefinition: self
%

category: 'accessing'
method: RwComponentProjectDefinition
addComponentNamed: aComponentName comment: commentString

	| component |
	component := self 
		components at: aComponentName 
		ifAbsentPut: [ RwComponentLoadConfiguration newNamed: aComponentName for: self name ].
	^ component 
		addDefinedGroupName: self defaultGroupName includeGroups: #();
		comment: commentString;
		yourself
%

category: 'accessing'
method: RwComponentProjectDefinition
addComponentNamed: aComponentName definedGroupNames: groupNameDict gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc comment: commentString

	| component |
	component := self 
		components at: aComponentName 
		ifAbsentPut: [ RwComponentLoadConfiguration newNamed: aComponentName for: self name ].
	groupNameDict keysAndValuesDo: [:groupName :includeGroups |
		component addDefinedGroupName: groupName includeGroups: includeGroups ].
	component
		conditionalPackageMapSpecsAtGemStoneUserId: aSymbolDictAssoc key 
			setDefaultSymbolDictNameTo: aSymbolDictAssoc value;
		comment: commentString.
	^ component
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackageNamed: packageName

	^ self
		addPackageNamed: packageName 
			toComponentNamed: self defaultComponentName 
			withConditions: #( 'common' ) 
			andGroupName: self defaultGroupName
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackageNamed: packageName toComponentNamed: componentName withConditions: conditionArray andGroupName: groupName

	| package component |
	package := super addPackageNamed: packageName.
	component := self components 
		at: componentName 
		ifAbsentPut: [ RwComponentLoadConfiguration newNamed: componentName for: self name ].
	component
		conditionalPackagesAtConditions: conditionArray
			andGroup: groupName
			addPackageNames: { packageName }.
	^package
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackageNamed: packageName toComponentNamed: componentName withConditions: conditionArray andGroupName: groupName  gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc

	| package component |
	package := super addPackageNamed: packageName.
	component := self components
		at: componentName 
		ifAbsentPut: [ RwComponentLoadConfiguration newNamed: componentName for: self name ].
	component
		conditionalPackageMapSpecsAtGemStoneUserId: aSymbolDictAssoc key
			andPackageName: packageName
			setSymbolDictNameTo: aSymbolDictAssoc value;
		conditionalPackagesAtConditions: conditionArray
			andGroup: groupName
			addPackageNames: { packageName }.
	^package
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackageNamed: packageName toComponentNamed: componentName withConditions: conditionArray gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc

	| package component |
	package := super addPackageNamed: packageName.
	component := self components
		at: componentName 
		ifAbsentPut: [ RwComponentLoadConfiguration newNamed: componentName for: self name ].
	component
		conditionalPackageMapSpecsAtGemStoneUserId: aSymbolDictAssoc key
			andPackageName: packageName 
			setSymbolDictNameTo: aSymbolDictAssoc value;
		conditionalPackagesAtConditions: conditionArray
			andGroup: self defaultGroupName
			addPackageNames: { packageName }.
	^package
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackageNamed: packageName withConditions: conditionArray

	| package component |
	package := self
		addPackageNamed: packageName 
			toComponentNamed: self defaultComponentName 
			withConditions: conditionArray
			andGroupName: self defaultGroupName.
	component := self components 
		at: self defaultComponentName 
		ifAbsentPut: [ RwComponentLoadConfiguration newNamed: self defaultComponentName for: self name ].
	component
		conditionalPackagesAtConditions: conditionArray
			andGroup: self defaultGroupName
			addPackageNames: { packageName }.
	^package
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackageNamed: packageName withConditions: conditionArray andGroupName: groupName

	| package component |
	package := self
		addPackageNamed: packageName 
			toComponentNamed: self defaultComponentName 
			withConditions: conditionArray
			andGroupName: groupName.
	component := self components
		at: self defaultComponentName 
		ifAbsentPut: [ RwComponentLoadConfiguration newNamed: self defaultComponentName for: self name ].
	component
		conditionalPackagesAtConditions: conditionArray
			andGroup: groupName
			addPackageNames: { packageName }.
	^package
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackageNamed: packageName withConditions: conditionArray andGroupName: groupName gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc

	| package component |
	package := self
		addPackageNamed: packageName 
			toComponentNamed: self defaultComponentName 
			withConditions: conditionArray
			andGroupName: groupName.
	component := self components
		at: self defaultComponentName 
		ifAbsentPut: [ RwComponentLoadConfiguration newNamed: self defaultComponentName for: self name ].
	component
		conditionalPackageMapSpecsAtGemStoneUserId: aSymbolDictAssoc key
			andPackageName: packageName
			setSymbolDictNameTo: aSymbolDictAssoc value;
		conditionalPackagesAtConditions: conditionArray
			andGroup: groupName
			addPackageNames: { packageName }.
	^package
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackageNamed: packageName withConditions: conditionArray gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc

	| package component |
	package := self
		addPackageNamed: packageName 
			toComponentNamed: self defaultComponentName 
			withConditions: conditionArray
			andGroupName: self defaultGroupName.
	component := self components
		at: self defaultComponentName 
		ifAbsentPut: [ RwComponentLoadConfiguration newNamed: self defaultComponentName for: self name ].
	component
		conditionalPackageMapSpecsAtGemStoneUserId: aSymbolDictAssoc key 
			andPackageName: packageName
			setSymbolDictNameTo: aSymbolDictAssoc value.
	^package
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackages: somePackageNames forComponent: aComponent
	"should be sent from the component visitor ... not unexpected to have a duplicate, but the new
		component --- presumably freshly read from disk --- wins"

	| componentName |
	componentName := aComponent name.
	(self components 
		at: componentName 
		ifAbsent: [])
			ifNil: [ self components at: componentName put: aComponent ]
			ifNotNil: [:theComponent |
				theComponent ~~ aComponent
					ifTrue: [ 
						"newest component wins"
						self components at: componentName put: aComponent ] ].
	somePackageNames asSet do: [:packageName |
		super addPackageNamed: packageName ].
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackagesNamed: packageNames

	^ packageNames collect: [:packageName | 
		self addPackageNamed: packageName ]
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackagesNamed: packageNames toComponentNamed: componentName withConditions: conditionArray andGroupName: groupName


	^ packageNames collect: [:packageName | 
		self addPackageNamed: packageName toComponentNamed: componentName withConditions: conditionArray andGroupName: groupName ]
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackagesNamed: packageNames toComponentNamed: componentName withConditions: conditionArray andGroupName: groupName  gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc

	^ packageNames collect: [:packageName | 
		self addPackageNamed: packageName toComponentNamed: componentName withConditions: conditionArray andGroupName: groupName  gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc ]
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackagesNamed: packageNames toComponentNamed: componentName withConditions: conditionArray gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc

	^ packageNames collect: [:packageName | 
		self addPackageNamed: packageName toComponentNamed: componentName withConditions: conditionArray gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc ]
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackagesNamed: packageNames withConditions: conditionArray

	^ packageNames collect: [:packageName |
			self addPackageNamed: packageName withConditions: conditionArray ]
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackagesNamed: packageNames withConditions: conditionArray andGroupName: groupName

	^ packageNames collect: [:packageName | 
		self addPackageNamed: packageName withConditions: conditionArray andGroupName: groupName ]
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackagesNamed: packageNames withConditions: conditionArray andGroupName: groupName gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc

	^ packageNames collect: [:packageName | 
		self addPackageNamed: packageName withConditions: conditionArray andGroupName: groupName gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc ]
%

category: 'accessing'
method: RwComponentProjectDefinition
addPackagesNamed: packageNames withConditions: conditionArray gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc 

	^ packageNames collect: [:packageName | 
		self addPackageNamed: packageName withConditions: conditionArray gemstoneDefaultSymbolDictionaryForUser: aSymbolDictAssoc ]
%

category: 'properties'
method: RwComponentProjectDefinition
canCommit

	^ self projectRef canCommit
%

category: 'actions'
method: RwComponentProjectDefinition
clone
	"clone remote git project to disk"

	self projectRef clone.
	^ self read						"refresh receiver from the cloned repository and answer project definition set that contains reciever along with any dependent projects"
%

category: 'actions'
method: RwComponentProjectDefinition
commit: message
	"commit the repository associated with receiver ..."

	self canCommit
		ifFalse: [ 
			| msg |
			msg := 'repository for project ' , self name printString
				, ' does not support commit operations.'.
			self inform: msg.
			^ msg ].
	^ self projectRef doCommit: message
%

category: 'accessing'
method: RwComponentProjectDefinition
componentNamed: aComponentName

	^ self componentNamed: aComponentName ifAbsent: [ self error: 'The component named ', aComponentName printString, ' was not found' ]
%

category: 'accessing'
method: RwComponentProjectDefinition
componentNamed: aComponentName ifAbsent: absentBlock

	^ self components 
		at: aComponentName 
		ifAbsent: absentBlock
%

category: 'accessing'
method: RwComponentProjectDefinition
components

	^ self projectRef components
%

category: 'accessing'
method: RwComponentProjectDefinition
components: aComponentDefinitionDictionary

	self projectRef components: aComponentDefinitionDictionary
%

category: 'properties'
method: RwComponentProjectDefinition
configsPath

	^ self projectRef configsPath
%

category: 'properties'
method: RwComponentProjectDefinition
configsPath: aDirectoryPathString

	self projectRef configsPath: aDirectoryPathString
%

category: 'properties'
method: RwComponentProjectDefinition
configsRoot
	^ self projectRef configsRoot
%

category: 'actions'
method: RwComponentProjectDefinition
create
	"write the project structure to disk, if it doesn't already exist"

	Rowan projectTools create
		createComponentProject: self.
%

category: 'accessing'
method: RwComponentProjectDefinition
defaultComponentName

	^ self projectRef defaultComponentName
%

category: 'accessing'
method: RwComponentProjectDefinition
defaultComponentName: aString

	^ self projectRef defaultComponentName: aString
%

category: 'properties'
method: RwComponentProjectDefinition
defaultConfigurationNames

	^ self propertyAt: 'defaultConfigurationNames' ifAbsent: [ self projectRef configurationNames ]
%

category: 'accessing'
method: RwComponentProjectDefinition
defaultGroupName

	^ self projectRef defaultGroupName
%

category: 'accessing'
method: RwComponentProjectDefinition
defaultGroupName: aString

	^ self projectRef defaultGroupName: aString
%

category: 'properties'
method: RwComponentProjectDefinition
defaultGroupNames

	^ self projectRef groupNames
%

category: 'accessing'
method: RwComponentProjectDefinition
defaultSymbolDictionary: symDictName forUser: userId

	(self componentNamed: self defaultComponentName)
		conditionalPackageMapSpecsAtGemStoneUserId: userId 
			setDefaultSymbolDictNameTo: symDictName
%

category: 'actions'
method: RwComponentProjectDefinition
export

	Rowan projectTools write writeComponentProjectDefinition: self
%

category: 'exporting'
method: RwComponentProjectDefinition
exportComponents

	self components isEmpty ifTrue: [
		self addComponentNamed: self defaultComponentName comment: '' ].
	self components values do: [:component|
		component exportToUrl: 'file:',  self configsRoot pathString, '/' ].
	self components isEmpty
		ifTrue: [
			"add README.md as placeholder to ensure that the directory is preserved by git"
			(self configsRoot /  'README', 'md') writeStreamDo: [ :fileStream | ] ]
%

category: 'exporting'
method: RwComponentProjectDefinition
exportPackages
	"attempt to do incremental write to disk, however, if disk cannot be read, write all packages to disk"
	| projectSetDefinition |
	projectSetDefinition := [ (self class newForProjectReference: self projectRef) readProjectSet ]
		on: Error
		do: [:ignored | RwProjectSetDefinition new ].
	self exportPackages: projectSetDefinition.
%

category: 'exporting'
method: RwComponentProjectDefinition
exportPackages: diskProjectSetDefinition

	| projectSetDefinition visitor projectSetModification writerVisitorClass |
	(self packagesRoot /  'properties', 'st') 
		writeStreamDo: [ :fileStream | 
			fileStream nextPutAll: '{ '; 
				lf;
				tab;
				nextPutAll: '#format : ' , self packageFormat printString, ',' ;
				lf;
				tab;
				nextPutAll: '#convention : ', self packageConvention printString;
				lf;
				nextPutAll: '}';
				lf ].

"write out packages"
	writerVisitorClass := self packageFormat = 'tonel'
		ifTrue: [ RwModificationTonelWriterVisitor ]
		ifFalse: [ RwModificationFiletreeWriterVisitor ].
	projectSetDefinition:= RwProjectSetDefinition new.
	projectSetDefinition addDefinition: self.
	projectSetModification := projectSetDefinition compareAgainstBase: diskProjectSetDefinition.
	visitor := writerVisitorClass new.

	visitor visit: projectSetModification.
%

category: 'exporting'
method: RwComponentProjectDefinition
exportProjects

	self projectNames do: [:projectName |
		self error: 'not yet implemented' ].
	self projectNames isEmpty
		ifTrue: [
			"add README.md as placeholder to ensure that the directory is preserved by git"
			(self projectsRoot /  'README', 'md') writeStreamDo: [ :fileStream | ] ]
%

category: 'exporting'
method: RwComponentProjectDefinition
exportSpecification

	self projectRef exportSpecification
%

category: 'accessing'
method: RwComponentProjectDefinition
gitRoot: aGitRootReferenceOrString 

	^ self projectRef gitRoot: aGitRootReferenceOrString
%

category: 'actions'
method: RwComponentProjectDefinition
load
	"load the receiver into the image"

	^ Rowan projectTools load loadComponentProjectDefinition: self
%

category: 'accessing'
method: RwComponentProjectDefinition
loadedCommitId

	^ self projectRef loadedCommitId
%

category: 'properties'
method: RwComponentProjectDefinition
loadedConfigurationNames

	^ self projectRef loadedConfigurationNames
%

category: 'properties'
method: RwComponentProjectDefinition
loadedConfigurationNames: configNames

	"noop - project ref component keys is list of loaded config names"

	"https://github.com/GemTalk/Rowan/issues/308"

	"eventually this method will be completely removed/deprecated"

	configNames asArray sort = self loadedConfigurationNames asArray sort
		ifFalse: [ self error: 'The configNames are expected to match the component keys' ]
%

category: 'properties'
method: RwComponentProjectDefinition
loadedGroupNames

	^ self projectRef loadedGroupNames
%

category: 'properties'
method: RwComponentProjectDefinition
loadedGroupNames: anArray

	^ self projectRef loadedGroupNames: anArray
%

category: 'accessing'
method: RwComponentProjectDefinition
packageConvention

	^ self projectRef packageConvention
%

category: 'accessing'
method: RwComponentProjectDefinition
packageConvention: aString

	self projectRef packageConvention: aString
%

category: 'accessing'
method: RwComponentProjectDefinition
packageFormat

	^ self projectRef packageFormat
%

category: 'accessing'
method: RwComponentProjectDefinition
packageFormat: aString

	self projectRef packageFormat: aString
%

category: 'accessing'
method: RwComponentProjectDefinition
packageFormatIfAbsent: aBlock

	^ self projectRef packageFormatIfAbsent: aBlock
%

category: 'properties'
method: RwComponentProjectDefinition
packagesPath

	^ self projectRef packagesPath
%

category: 'properties'
method: RwComponentProjectDefinition
packagesPath: aString

	^ self projectRef packagesPath: aString
%

category: 'properties'
method: RwComponentProjectDefinition
packagesRoot

	^ self projectRef packagesRoot
%

category: 'accessing'
method: RwComponentProjectDefinition
projectAlias

	^ self projectRef projectAlias
%

category: 'accessing'
method: RwComponentProjectDefinition
projectAlias: aStringOrNil

	self projectRef projectAlias: aStringOrNil
%

category: 'accessing'
method: RwComponentProjectDefinition
projectHome

	^ self projectRef projectHome
%

category: 'accessing'
method: RwComponentProjectDefinition
projectHome: aProjectHomeReferenceOrString

	^ self projectRef projectHome: aProjectHomeReferenceOrString
%

category: 'accessing'
method: RwComponentProjectDefinition
projectNames

	^ self projectRef projectNames
%

category: 'accessing'
method: RwComponentProjectDefinition
projectNames: anArray

	self projectRef projectNames: anArray
%

category: 'accessing'
method: RwComponentProjectDefinition
projectRef

	^ self propertyAt: 'projectRef' ifAbsent: [ ]
%

category: 'accessing'
method: RwComponentProjectDefinition
projectRef: aRwProjectReferenceDefinition

	^ self propertyAt: 'projectRef' put: aRwProjectReferenceDefinition
%

category: 'properties'
method: RwComponentProjectDefinition
projectsPath

	^ self projectRef projectsPath
%

category: 'properties'
method: RwComponentProjectDefinition
projectsPath: aString

	^ self projectRef projectsPath: aString
%

category: 'properties'
method: RwComponentProjectDefinition
projectsRoot

	^ self projectRef projectsRoot
%

category: 'actions'
method: RwComponentProjectDefinition
read
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the default component and group names"

	"return a project definition set that will contain the project definition along with any dependent project definitions"

	^ Rowan projectTools read
		readProjectSetForComponentProjectDefinition: self 
			withConfigurations: self defaultConfigurationNames
			groupNames: self defaultGroupNames
%

category: 'actions'
method: RwComponentProjectDefinition
read: platformConfigurationAttributes
	"refresh the contents of the receiver ... the reciever will match the definitions on disk based on the default component and group names"

	"return a project definition set that will contain the project definition along with any dependent project definitions"

	^ Rowan projectTools read
		readProjectSetForComponentProjectDefinition: self 
			withConfigurations: self defaultConfigurationNames
			groupNames: self defaultGroupNames
			platformConfigurationAttributes: platformConfigurationAttributes
%

category: 'tool api'
method: RwComponentProjectDefinition
readProjectSet

	^ Rowan projectTools read  readProjectSetForComponentProjectDefinition: self
%

category: 'actions'
method: RwComponentProjectDefinition
readProjectSetForPackageNames: packageNames
	"drop all existing packages on the floor and replace with fresh versions of the packageNames read from disk"

	| format visitorClass |
	packages := Dictionary new. 
	format := self 
		packageFormatIfAbsent: [  
			| formatFromDisk |
			formatFromDisk := (RwAbstractReaderWriterVisitor _repositoryPropertyDictFor: self packagesRoot)
				at: #format ifAbsent: [ 'tonel' ].
			self packageFormat: formatFromDisk.
			formatFromDisk ].
	visitorClass := format = 'tonel'
		ifTrue: [ RwRepositoryComponentProjectTonelReaderVisitor ]
		ifFalse: [ RwRepositoryComponentProjectFiletreeReaderVisitor ].
	^ visitorClass new
		packageNames: packageNames;
		visit: self.
%

category: 'reading'
method: RwComponentProjectDefinition
readProjectSetReadTool: readTool withConfigurations: theConfigNames groupNames: theGroupNames

	^ readTool
		readProjectSetForComponentProjectDefinition: self
			withConfigurations: theConfigNames 
			groupNames: theGroupNames
%

category: 'properties'
method: RwComponentProjectDefinition
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ self projectRef repositoryRoot
%

category: 'properties'
method: RwComponentProjectDefinition
repositoryRoot: aFileReferenceOrPath
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ self projectRef repositoryRoot: aFileReferenceOrPath
%

category: 'temporary compat'
method: RwComponentProjectDefinition
repositoryRootPath

	^ self repositoryRoot fullName
%

category: 'temporary compat'
method: RwComponentProjectDefinition
specification

self deprecated: 'temporary patch .. sender should be replaced with projectRef'.
	^ self projectRef asSpecification
%

category: 'properties'
method: RwComponentProjectDefinition
specsPath

	^ self projectRef specsPath
%

category: 'properties'
method: RwComponentProjectDefinition
specsPath: aDirectoryPathString

	self projectRef specsPath: aDirectoryPathString
%

category: 'properties'
method: RwComponentProjectDefinition
specsRoot

	^ self projectRef specsRoot
%

category: 'loading'
method: RwComponentProjectDefinition
updateLoadedCommitId

	self projectRef updateLoadedCommitId
%

category: 'properties'
method: RwComponentProjectDefinition
useGit

	^ self projectRef useGit
%

! Class implementation for 'RwProjectReferenceDefinition'

!		Class methods for 'RwProjectReferenceDefinition'

category: 'instance creation'
classmethod: RwProjectReferenceDefinition
newForSpecification: aRwSpecification

	^ self
		newNamed: aRwSpecification projectName 
			forSpecification: aRwSpecification 
			projectHome: nil
%

category: 'instance creation'
classmethod: RwProjectReferenceDefinition
newForSpecification: aRwSpecification projectHome: projectHomeFileReferenceOrString

	^ self 
		newNamed: aRwSpecification specName 
			forSpecification: aRwSpecification 
			projectHome: projectHomeFileReferenceOrString
%

category: 'instance creation'
classmethod: RwProjectReferenceDefinition
newNamed: projectName forSpecification: aRwSpecification

	^ self
		newNamed: projectName 
			forSpecification: aRwSpecification 
			projectHome: nil
%

category: 'instance creation'
classmethod: RwProjectReferenceDefinition
newNamed: projectName forSpecification: aRwSpecification projectHome: projectHomeFileReferenceOrString

	^ self
		projectName: projectName
			configurationNames: aRwSpecification defaultConfigurationNames
			groupNames: aRwSpecification defaultGroupNames
			defaultComponentName: aRwSpecification defaultComponentName
			useGit: aRwSpecification useGit
			projectUrl: aRwSpecification projectUrl
			comment: aRwSpecification comment
			projectHome: projectHomeFileReferenceOrString
			committish: aRwSpecification repoSpec committish
			committishType: aRwSpecification repoSpec committishType
			configsPath: aRwSpecification configsPath
			packagesPath: aRwSpecification repoPath
			projectsPath: aRwSpecification projectsPath
			specsPath: aRwSpecification specsPath
%

category: 'instance creation'
classmethod: RwProjectReferenceDefinition
projectName: projectName configurationNames: configurationNames groupNames: groupNames defaultComponentName: defaultComponentName useGit: useGit projectUrl: projectUrl comment: comment projectHome: projectHomeFileReferenceOrString committish: committish committishType: committishType configsPath: configsPath packagesPath: packagesPath projectsPath: projectsPath specsPath: specsPath

	^ self new
		projectName: projectName;
		configurationNames: configurationNames;
		defaultComponentName: defaultComponentName;
		groupNames: groupNames;
		projectUrl: projectUrl;
		useGit: useGit;
		comment: comment;
		projectHome: projectHomeFileReferenceOrString;
		committish: committish committishType: committishType;
		configsPath: configsPath;
		packagesPath: packagesPath;
		projectsPath: projectsPath;
		specsPath: specsPath;
		yourself
%

category: 'instance creation'
classmethod: RwProjectReferenceDefinition
projectName: projectName configurationNames: configurationNames groupNames: groupNames defaultComponentName: defaultComponentName useGit: useGit projectUrl: projectUrl projectHome: projectHomeFileReferenceOrString committish: committish committishType: committishType comment: comment

	^ self new
		projectName: projectName;
		configurationNames: configurationNames;
		groupNames: groupNames;
		 defaultComponentName: defaultComponentName;
		useGit: useGit;
		projectUrl: projectUrl;
		projectHome: projectHomeFileReferenceOrString;
		comment: comment;
		committish: committish committishType: committishType;
		yourself
%

category: 'instance creation'
classmethod: RwProjectReferenceDefinition
projectName: projectName configurationNames: configurationNames groupNames: groupNames useGit: useGit projectUrl: projectUrl comment: comment

	^ self new
		projectName: projectName;
		configurationNames: configurationNames;
		groupNames: groupNames;
		useGit: useGit;
		projectUrl: projectUrl;
		comment: comment;
		yourself
%

category: 'instance creation'
classmethod: RwProjectReferenceDefinition
projectName: projectName configurationNames: configurationNames groupNames: groupNames useGit: useGit projectUrl: projectUrl committish: committish committishType: committishType comment: comment

	^ self new
		projectName: projectName;
		configurationNames: configurationNames;
		groupNames: groupNames;
		useGit: useGit;
		projectUrl: projectUrl;
		comment: comment;
		committish: committish committishType: committishType;
		yourself
%

category: 'instance creation'
classmethod: RwProjectReferenceDefinition
projectName: projectName configurationNames: configurationNames groupNames: groupNames useGit: useGit projectUrl: projectUrl projectHome: projectHomeFileReferenceOrString committish: committish committishType: committishType comment: comment

	^ self new
		projectName: projectName;
		configurationNames: configurationNames;
		groupNames: groupNames;
		useGit: useGit;
		projectUrl: projectUrl;
		projectHome: projectHomeFileReferenceOrString;
		comment: comment;
		committish: committish committishType: committishType;
		yourself
%

category: 'instance creation'
classmethod: RwProjectReferenceDefinition
projectName: projectName useGit: useGit

	^ self new
		projectName: projectName;
		useGit: useGit;
		yourself
%

!		Instance methods for 'RwProjectReferenceDefinition'

category: 'visiting'
method: RwProjectReferenceDefinition
acceptVisitor: aVisitor

	^ aVisitor visitProjectReferenceDefinition: self
%

category: 'accessing'
method: RwProjectReferenceDefinition
branch: aString

	self committish: aString committishType: 'branch'
%

category: 'properties'
method: RwProjectReferenceDefinition
canCommit

	^ self repositoryDefinition canCommit
%

category: 'actions'
method: RwProjectReferenceDefinition
clone

	"who wins? resolve or clone"

	^ self repositoryDefinition clone
%

category: 'accessing'
method: RwProjectReferenceDefinition
comment

	^ self properties at: 'comment' ifAbsent: [ '' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
comment: aString

	^ self properties at: 'comment' put: aString
%

category: 'accessing'
method: RwProjectReferenceDefinition
commitLog: logLimit

	^ self repositoryDefinition commitLog: logLimit
%

category: 'accessing'
method: RwProjectReferenceDefinition
committish

	^ self properties at: 'committish' ifAbsent: [ 'master' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
committish: aString committishType: committishTypeString

	self properties at: 'committish' put: aString.
	self properties at: 'committishType' put: committishTypeString.
%

category: 'accessing'
method: RwProjectReferenceDefinition
committishType

	^ self properties at: 'committishType'  ifAbsent: [ 'branch' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
components

	^ self properties at: 'components' ifAbsentPut: [ Dictionary new ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
components: aComponentDefinitionDictionary

	^ self properties at: 'components' put: aComponentDefinitionDictionary
%

category: 'accessing'
method: RwProjectReferenceDefinition
configsPath

	^ self properties at: 'configsPath' ifAbsent: [ 'rowan/components' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
configsPath: aString

	^ self properties at: 'configsPath' put: aString
%

category: 'accessing'
method: RwProjectReferenceDefinition
configsRoot

	^self repositoryRoot / self configsPath
%

category: 'accessing'
method: RwProjectReferenceDefinition
configurationNames

	^ self properties at: 'configurationNames' ifAbsent: [ { self defaultComponentName } ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
configurationNames: anArray

	^ self properties at: 'configurationNames' put: anArray
%

category: 'actions'
method: RwProjectReferenceDefinition
create
	"write the project structure to disk, if it doesn't already exist"

	Rowan projectTools create
		createProjectRepository: self.
%

category: 'accessing'
method: RwProjectReferenceDefinition
defaultComponentName

	^ self properties at: 'defaultComponentName' ifAbsent: [ 'Core' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
defaultComponentName: aString

	^ self properties at: 'defaultComponentName' put: aString
%

category: 'accessing'
method: RwProjectReferenceDefinition
defaultGroupName

	^ self properties at: 'defaultGroupName' ifAbsent: [ 'core' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
defaultGroupName: aString

	^ self properties at: 'defaultGroupName' put: aString
%

category: 'actions'
method: RwProjectReferenceDefinition
doCommit: message

	^ self repositoryDefinition doCommit: message
%

category: 'exporting'
method: RwProjectReferenceDefinition
exportSpecification

	| spec |
	spec := self asSpecification.
	spec exportToUrl: 'file:',  self specsRoot pathString, '/'
%

category: 'accessing'
method: RwProjectReferenceDefinition
gitRoot: aGitRootReferenceOrString 

	self repositoryDefinition gitRoot: aGitRootReferenceOrString
%

category: 'accessing'
method: RwProjectReferenceDefinition
groupNames

	^ self properties at: 'groupNames' ifAbsent: [{ self defaultGroupName } ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
groupNames: anArray

	^ self properties at: 'groupNames' put: anArray
%

category: 'temporary compat'
method: RwProjectReferenceDefinition
imageSpec
self deprecated: 'temporary method ... simulating RwSpecification api'.
	^self
%

category: 'accessing'
method: RwProjectReferenceDefinition
key

	^ self projectName
%

category: 'accessing'
method: RwProjectReferenceDefinition
loadedCommitId

	^ self properties at: 'loadedCommitId' ifAbsent: [ '' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
loadedCommitId:  aCommitId

	^ self properties at: 'loadedCommitId' put: aCommitId
%

category: 'accessing'
method: RwProjectReferenceDefinition
loadedConfigurationNames

	^ self components isEmpty
		ifTrue: [ self configurationNames ]
		ifFalse: [ (self components values select: [:each | each isIndependentlyLoadable ]) collect: [:each | each name ] ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
loadedConfigurationNames: anArray

	"https://github.com/GemTalk/Rowan/issues/308"

	"eventually this method will be completely removed/deprecated"

	^ self configurationNames: anArray
%

category: 'accessing'
method: RwProjectReferenceDefinition
loadedGroupNames

	^ self groupNames
%

category: 'accessing'
method: RwProjectReferenceDefinition
loadedGroupNames: anArray

	^ self groupNames: anArray
%

category: 'accessing'
method: RwProjectReferenceDefinition
packageConvention

	^ self properties at: 'packageConvention' ifAbsent: [ 'RowanHybrid' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
packageConvention: aString

	"
		RowanHybrid	- [default] Class category is package name, method protocol with leading $* is case insensitive package name
		Monticello		- Class category is package name, method protocol with leading $* begins with case insensitive package name
		Rowan			- Class category and method protocol are not overloaded with packaging information
	"

	(#( 'RowanHybrid' 'Monticello' 'Rowan' ) includes: aString)
		ifFalse: [ self error: 'Unknown package convention ', aString printString, '. Should be one of: RowanHybrid, Monticello, or Rowan' ].
	^ self properties at: 'packageConvention' put: aString
%

category: 'accessing'
method: RwProjectReferenceDefinition
packageFormat

	^ self packageFormatIfAbsent: [ 'tonel' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
packageFormat: aString

	(#( 'tonel' 'filetree' ) includes: aString)
		ifFalse: [ self error: 'Unknown package format ', aString printString, '. Should be one of: tonel, or filetree' ].
	^ self properties at: 'packageFormat' put: aString
%

category: 'accessing'
method: RwProjectReferenceDefinition
packageFormatIfAbsent: absentBlock

	^ self properties at: 'packageFormat' ifAbsent: absentBlock
%

category: 'accessing'
method: RwProjectReferenceDefinition
packagesPath

	^ self properties at: 'packagesPath' ifAbsent: [ 'rowan/src' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
packagesPath: aString

	^ self properties at: 'packagesPath' put: aString
%

category: 'accessing'
method: RwProjectReferenceDefinition
packagesRoot

	^self repositoryRoot / self packagesPath
%

category: 'copying'
method: RwProjectReferenceDefinition
postCopy

	| components |
	super postCopy.
	components := self components copy.
	components keysAndValuesDo: [:key :value | components at: key put: value copy ].
	self components: components
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectAlias

	^ self properties at: 'projectAlias' ifAbsent: [ self projectName ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectAlias: aStringOrNil

	aStringOrNil ifNil: [ ^ self properties removeKey: 'projectAlias' ifAbsent: [] ].
	^ self properties at: 'projectAlias' put: aStringOrNil
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectHome

	^ self properties at: 'projectHome' ifAbsent: [ FileLocator rowanProjectsHome ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectHome: projectHomeFileReferenceOrString

	self repositoryDefinition: nil. "changing project home invalidates the current repository definition"
	projectHomeFileReferenceOrString
		ifNil: [ ^ self properties removeKey: 'projectHome' ifAbsent: [] ].
	self properties at: 'projectHome' put: projectHomeFileReferenceOrString asFileReference.
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectName

	^ self properties at: 'projectName' ifAbsent: []
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectName: aString

	^ self properties at: 'projectName' put: aString
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectNames

	^ self properties at: 'projectNames' ifAbsent: [ #() ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectNames: anArray

	^ self properties at: 'projectNames' put: anArray
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectsPath

	^ self properties at: 'projectsPath' ifAbsent: [ 'rowan/projects' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectsPath: aString

	^ self properties at: 'projectsPath' put: aString
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectsRoot

	^self repositoryRoot / self projectsPath
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectUrl

	^ self properties at: 'projectUrl' ifAbsent: [ '' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
projectUrl: aString

	^ self properties at: 'projectUrl' put: aString
%

category: 'accessing'
method: RwProjectReferenceDefinition
remoteUrl

	^ self repositoryDefinition remoteUrl
%

category: 'accessing'
method: RwProjectReferenceDefinition
remoteUrl: aRemoteUrl

	self repositoryDefinition remoteUrl: aRemoteUrl
%

category: 'accessing'
method: RwProjectReferenceDefinition
repositoryCommitId

	^ self repositoryDefinition repositoryCommitId
%

category: 'accessing'
method: RwProjectReferenceDefinition
repositoryDefinition

	^ self properties at: 'repositoryDefinition' ifAbsentPut: [ self _repositoryDefinitionForProjectHome: self projectHome ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
repositoryDefinition: aRepositoryDefinition

	aRepositoryDefinition ifNil: [ ^ self properties removeKey:  'repositoryDefinition' ifAbsent: [] ].
	^ self properties at: 'repositoryDefinition' put: aRepositoryDefinition
%

category: 'accessing'
method: RwProjectReferenceDefinition
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^self projectHome / self projectAlias
%

category: 'accessing'
method: RwProjectReferenceDefinition
repositoryRoot: aFileReferenceOrPath
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	| fileRef |
	fileRef := aFileReferenceOrPath asFileReference.
	self projectHome: fileRef parent.
	self projectAlias: fileRef basename
%

category: 'temporary compat'
method: RwProjectReferenceDefinition
repositoryRootPath

	^ self repositoryRoot pathString
%

category: 'temporary compat'
method: RwProjectReferenceDefinition
repoSpec

self deprecated: 'temporary method ... simulating RwSpecification api'.
	^self
%

category: 'actions'
method: RwProjectReferenceDefinition
resolve

	"who wins? resolve or clone"

	^ self repositoryDefinition resolve
%

category: 'accessing'
method: RwProjectReferenceDefinition
SHA: aString

	self committish: aString committishType: 'SHA'
%

category: 'accessing'
method: RwProjectReferenceDefinition
specsPath

	^ self properties at: 'specsPath' ifAbsent: [ 'rowan/specs' ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
specsPath: aString

	^ self properties at: 'specsPath' put: aString
%

category: 'accessing'
method: RwProjectReferenceDefinition
specsRoot

	^self repositoryRoot / self specsPath
%

category: 'accessing'
method: RwProjectReferenceDefinition
tag: aString

	self committish: aString committishType: 'tag'
%

category: 'loading'
method: RwProjectReferenceDefinition
updateLoadedCommitId

	self loadedCommitId: self repositoryDefinition commitId
%

category: 'temporary compat'
method: RwProjectReferenceDefinition
updateLoadedCommitIdForTool: aRwTool
self deprecated: 'temporary method ... simulating RwSpecification api'.
  ^ aRwTool doGitUpdateLoadedCommitId
%

category: 'accessing'
method: RwProjectReferenceDefinition
useGit

	^ self properties at: 'useGit' ifAbsent: [ false ]
%

category: 'accessing'
method: RwProjectReferenceDefinition
useGit: aBool

	^ self properties at: 'useGit' put: aBool
%

category: 'actions'
method: RwProjectReferenceDefinition
validateRepository
	"cofirm that the repository appears to be complete relative to this project"

	{
		'configs' -> self configsRoot. 
		'packages' -> self packagesRoot. 
		'specs' -> self specsRoot. 
		'projects' -> self projectsRoot
	}
		do: [ :assoc | 
			(assoc value) exists 
				ifFalse: [ self error: 'The repository at ', self repositoryRootPath printString, ' is missing the ', (assoc key) printString, ' directory.'  ] ].
%

category: 'private'
method: RwProjectReferenceDefinition
_createRepositoryFrom: repoDef 

	self error: 'not yet implemented'
%

category: 'private'
method: RwProjectReferenceDefinition
_repositoryDefinitionClass

	self useGit ifTrue: [ ^ RwGitRepositoryDefinition ].
	^ RwAbstractRepositoryDefinition
%

category: 'private'
method: RwProjectReferenceDefinition
_repositoryDefinitionForProjectHome: projectHomeFileReferenceOrString


	| existingProjectRepository |
	existingProjectRepository := 
		Rowan image 
			projectRepositoryNamed: self projectAlias
				ifAbsent: [
					| newProjectRepository |
					newProjectRepository := self _repositoryDefinitionClass
						newNamed: self projectAlias
							repositoryRoot: projectHomeFileReferenceOrString asFileReference / self projectAlias
							projectUrl: self projectUrl
							committish: self committish 
							committishType: self committishType.
					Rowan image addProjectRepository: newProjectRepository.
					^ newProjectRepository ].
	"confirm that the existing project repository is compatible with the receiver"
	existingProjectRepository projectUrl = self projectUrl
		ifFalse: [ self error: 'incompatible project repository found in registry' ].
	^ existingProjectRepository
%

! Class implementation for 'RwElementsModification'

!		Class methods for 'RwElementsModification'

category: 'instance creation'
classmethod: RwElementsModification
new

	^self basicNew initialize
%

!		Instance methods for 'RwElementsModification'

category: 'modifications'
method: RwElementsModification
addElementModification: aModification

	aModification isEmpty
		ifFalse: [elementsModified at: aModification key put: aModification]
%

category: 'Accessing'
method: RwElementsModification
elementsModified
	^elementsModified
%

category: 'initialization'
method: RwElementsModification
initialize

	elementsModified := Dictionary new
%

category: 'testing'
method: RwElementsModification
isEmpty

	^elementsModified isEmpty
%

category: 'Accessing'
method: RwElementsModification
modificationOf: aKey

	^elementsModified at: aKey
%

category: 'printing'
method: RwElementsModification
printOn: aStream

	super printOn: aStream.
	self isEmpty ifTrue: [aStream nextPutAll: ' (empty)']
%

category: 'Accessing'
method: RwElementsModification
removeModificationOf: aKey

	elementsModified removeKey: aKey
%

! Class implementation for 'RwClassesModification'

!		Instance methods for 'RwClassesModification'

category: 'visiting'
method: RwClassesModification
acceptVisitor: aVisitor

	^aVisitor visitClassesModification: self
%

! Class implementation for 'RwClassExtensionsModification'

!		Instance methods for 'RwClassExtensionsModification'

category: 'visiting'
method: RwClassExtensionsModification
acceptVisitor: aVisitor

	^aVisitor visitClassExtensionsModification: self
%

! Class implementation for 'RwEntitySetModification'

!		Instance methods for 'RwEntitySetModification'

category: 'accessing'
method: RwEntitySetModification
movedClasses

	^ movedClasses
%

category: 'accessing'
method: RwEntitySetModification
movedMethods

	^ movedMethods
%

! Class implementation for 'RwPackageSetModification'

!		Instance methods for 'RwPackageSetModification'

category: 'visiting'
method: RwPackageSetModification
acceptVisitor: aVisitor

	^aVisitor visitPackageSetModification: self
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsAddedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> true -> newMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> false -> newMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsAddedByPackageModification: packageModification toDictionary: dictionary

	self
		addMethodsAddedByClassesOrExtensionsModification: packageModification
				classesModification
		inPackage: packageModification after
		toDictionary: dictionary.
	self
		addMethodsAddedByClassesOrExtensionsModification: packageModification
				classExtensionsModification
		inPackage: packageModification after
		toDictionary: dictionary
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsRemovedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> true -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification before
										methodKey: oldMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> false -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: oldMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsRemovedByPackageModification: packageModification toDictionary: dictionary

	self
		addMethodsRemovedByClassesOrExtensionsModification: packageModification
				classesModification
		inPackage: packageModification before
		toDictionary: dictionary.
	self
		addMethodsRemovedByClassesOrExtensionsModification: packageModification
				classExtensionsModification
		inPackage: packageModification before
		toDictionary: dictionary
%

category: 'enumerating'
method: RwPackageSetModification
classesModificationAndPackageModificationAndProjectModificationDo: aBlock

	"enumerate the classesModification in the packagesModification in the projectModification in the receiver.
		The classesModification, packageModification are arguments to the block. "

	elementsModified
		do: [ :packageModification | aBlock cull: packageModification classesModification cull: packageModification  ]
%

category: 'enumerating'
method: RwPackageSetModification
classesModificationAndPackageModificationDo: aBlock

	"enumerate the classesModification in the packagesModification in the receiver.
		The classesModification and ppackageModification are arguments to the block. "

	elementsModified
		do: [ :packageModification | aBlock cull: packageModification classesModification cull: packageModification  ]
%

category: 'private - moves'
method: RwPackageSetModification
findAddedClasses

	| addedClasses |
	addedClasses := Dictionary new.
	elementsModified do: 
			[:packageModification |
			| classesModification |
			classesModification := packageModification classesModification.
			classesModification elementsModified do: 
					[:classModification |
					classModification before isEmpty
						ifTrue: 
							[| newClass |
							newClass := classModification after.
							addedClasses at: newClass key
								put: (RwClassAdditionOrRemoval
										packageDefinition: packageModification before
										classKey: newClass key
										classesModification: classesModification)]]].
	^addedClasses
%

category: 'private - moves'
method: RwPackageSetModification
findAddedMethods
	"Answer a dictionary of added methods."

	| addedMethods |
	addedMethods := Dictionary new.
	elementsModified do: 
			[:packageModification |
			self addMethodsAddedByPackageModification: packageModification
				toDictionary: addedMethods].
	^addedMethods
%

category: 'private - moves'
method: RwPackageSetModification
findRemovedClasses

	| removedClasses |
	removedClasses := Dictionary new.
	elementsModified do: 
			[:packageModification |
			| classesModification |
			classesModification := packageModification classesModification.
			classesModification elementsModified do: 
					[:classModification |
					classModification after isEmpty
						ifTrue: 
							[| oldClass |
							oldClass := classModification before.
							removedClasses at: oldClass key
								put: (RwClassAdditionOrRemoval
										packageDefinition: packageModification after
										classKey: oldClass key
										classesModification: classesModification)]]].
	^removedClasses
%

category: 'private - moves'
method: RwPackageSetModification
findRemovedMethods
	"Answer a dictionary of removed methods."

	| removedMethods |
	removedMethods := Dictionary new.
	elementsModified do: 
			[:packageModification |
			self addMethodsRemovedByPackageModification: packageModification
				toDictionary: removedMethods].
	^removedMethods
%

category: 'initialization'
method: RwPackageSetModification
initialize

	super initialize.
	movedClasses := Set new.
	movedMethods := Set new
%

category: 'private - moves'
method: RwPackageSetModification
updateForClassMoveFrom: removal to: addition
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition classModification |
	oldDefinition := (removal classesModification
				modificationOf: removal classKey) before.
	newDefinition := (addition classesModification
				modificationOf: addition classKey) after.

	"Delete the removal and the addition."
	removal classesModification removeModificationOf: removal classKey.
	addition classesModification removeModificationOf: addition classKey.

	"Record the move."
	movedClasses add: (RwClassMove
				classBefore: oldDefinition
				classAfter: newDefinition
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition).

	"Does the class have other modifications that need to be recorded?"
	classModification := newDefinition compareAgainstBase: oldDefinition.
	classModification isEmpty
		ifFalse: 
			[addition classesModification addElementModification: classModification]
%

category: 'moves'
method: RwPackageSetModification
updateForClassMoves

	| classAdditions classRemovals |
	classAdditions := self findAddedClasses.
	classRemovals := self findRemovedClasses.

	"Any keys that match between added and removed should be considered a move."
	classAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := classRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [self updateForClassMoveFrom: removal to: addition]]
%

category: 'private - moves'
method: RwPackageSetModification
updateForMethodMoveFrom: removal to: addition
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition methodModification |
	oldDefinition := (removal methodsModification
				modificationOf: removal methodKey) before.
	newDefinition := (addition methodsModification
				modificationOf: addition methodKey) after.

	"Delete the removal and the addition."
	removal methodsModification removeModificationOf: removal methodKey.
	addition methodsModification removeModificationOf: addition methodKey.

	"Record the move."
	movedMethods add: (RwMethodMove
				methodBefore: oldDefinition
				methodAfter: newDefinition
				classOrExtensionBefore: removal classDefinitionOrExtension
				classOrExtensionAfter: addition classDefinitionOrExtension
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition
				isMeta: addition isMeta).

	"Does the method have other modifications that need to be recorded?"
	methodModification := newDefinition compareAgainstBase: oldDefinition.
	methodModification isEmpty
		ifFalse: 
			[addition methodsModification addElementModification: methodModification]
%

category: 'moves'
method: RwPackageSetModification
updateForMethodMoves
	"Methods that have been moved between packages will initially show up as a remove and an add rather than a move.
	Find moved methods and correct the structure."

	| methodAdditions methodRemovals |
	methodAdditions := self findAddedMethods.
	methodRemovals := self findRemovedMethods.
	"Any keys that match between added and removed should be considered a move."
	methodAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := methodRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [self updateForMethodMoveFrom: removal to: addition]]
%

! Class implementation for 'RwProjectSetModification'

!		Instance methods for 'RwProjectSetModification'

category: 'visiting'
method: RwProjectSetModification
acceptVisitor: aVisitor

	^ aVisitor visitProjecteSetModification: self
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsAddedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package inProject: project toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before key
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> true -> newMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before key
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> false -> newMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsAddedByPackageModification: packageModification inProject: projectModification toDictionary: dictionary

	packageModification after key notNil
	ifTrue: [ 
		"ignore additions for packages that have been removed"
		self
			addMethodsAddedByClassesOrExtensionsModification: packageModification
					classesModification
			inPackage: packageModification after
			inProject: projectModification after
			toDictionary: dictionary.
		self
			addMethodsAddedByClassesOrExtensionsModification: packageModification
					classExtensionsModification
			inPackage: packageModification after
			inProject: projectModification after
			toDictionary: dictionary]
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsRemovedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package inProject: project toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after key
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> true -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification before
										methodKey: oldMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after key
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> false -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: oldMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsRemovedByPackageModification: packageModification inProject: projectModification toDictionary: dictionary

	packageModification before key notNil
	ifTrue: [ 
		"ignore removals for packages that have been added"
		self
			addMethodsRemovedByClassesOrExtensionsModification: packageModification
					classesModification
			inPackage: packageModification before
			inProject: projectModification before
			toDictionary: dictionary.
		self
			addMethodsRemovedByClassesOrExtensionsModification: packageModification
					classExtensionsModification
			inPackage: packageModification before
			inProject: projectModification before
			toDictionary: dictionary ]
%

category: 'enumerating'
method: RwProjectSetModification
classesModificationAndPackageModificationAndProjectModificationDo: aBlock

	"enumerate the classesModification in the packagesModification in the projectModification in the receiver.
		The classesModification, packageModification, and projectModification are arguments to the block. "

	elementsModified
		do: [ :projectModification | 
			projectModification packagesModification elementsModified
				do: [ :packageModification | aBlock cull: packageModification classesModification cull: packageModification cull: projectModification ] ]
%

category: 'private - moves'
method: RwProjectSetModification
findAddedClasses

	| addedClasses |
	addedClasses := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				| classesModification |
				classesModification := packageModification classesModification.
				classesModification elementsModified do: 
						[:classModification |
						classModification before isEmpty
							ifTrue: 
								[| newClass |
								newClass := classModification after.
								addedClasses at: newClass key
									put: (RwClassAdditionOrRemoval
											projectDefinition: projectModification after
											packageDefinition: packageModification after
											classKey: newClass key
											classesModification: classesModification)]]]].
	^addedClasses
%

category: 'private - moves'
method: RwProjectSetModification
findAddedMethods
	"Answer a dictionary of added methods."

	| addedMethods |
	addedMethods := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				self addMethodsAddedByPackageModification: packageModification
					inProject: projectModification
					toDictionary: addedMethods] ].
	^addedMethods
%

category: 'private - moves'
method: RwProjectSetModification
findRemovedClasses

	| removedClasses |
	removedClasses := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				| classesModification |
				classesModification := packageModification classesModification.
				classesModification elementsModified do: 
						[:classModification |
						classModification after isEmpty
							ifTrue: 
								[| oldClass |
								oldClass := classModification before.
								removedClasses at: oldClass key
									put: (RwClassAdditionOrRemoval
											projectDefinition: projectModification before
											packageDefinition: packageModification before
											classKey: oldClass key
											classesModification: classesModification)]]]].
	^removedClasses
%

category: 'private - moves'
method: RwProjectSetModification
findRemovedMethods
	"Answer a dictionary of removed methods."

	| removedMethods |
	removedMethods := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				self addMethodsRemovedByPackageModification: packageModification
					inProject: projectModification
					toDictionary: removedMethods]].
	^removedMethods
%

category: 'initialization'
method: RwProjectSetModification
initialize

	super initialize.
	movedClasses := Set new.
	movedMethods := Set new
%

category: 'private - moves'
method: RwProjectSetModification
updateForClassMoveFrom: removal to: addition
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition classModification |
	oldDefinition := (removal classesModification
				modificationOf: removal classKey) before.
	newDefinition := (addition classesModification
				modificationOf: addition classKey) after.

	"Delete the removal and the addition."
	removal classesModification removeModificationOf: removal classKey.
	addition classesModification removeModificationOf: addition classKey.

	"Record the move."
	movedClasses add: (RwClassMove
				classBefore: oldDefinition
				classAfter: newDefinition
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition
				projectBefore: removal projectDefinition
				projectAfter: addition projectDefinition).

	"Does the class have other modifications that need to be recorded?"
	classModification := newDefinition compareAgainstBase: oldDefinition.
	classModification isEmpty
		ifFalse: 
			[addition classesModification addElementModification: classModification]
%

category: 'moves'
method: RwProjectSetModification
updateForClassMoves

	| classAdditions classRemovals |
	classAdditions := self findAddedClasses.
	classRemovals := self findRemovedClasses.

	"Any keys that match between added and removed should be considered a move."
	classAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := classRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [self updateForClassMoveFrom: removal to: addition]]
%

category: 'private - moves'
method: RwProjectSetModification
updateForMethodMoveFrom: removal to: addition  isMeta: isMeta
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition methodModification |
	oldDefinition := (removal methodsModification
				modificationOf: removal methodKey) before.
	newDefinition := (addition methodsModification
				modificationOf: addition methodKey) after.

	"Delete the removal and the addition."
	removal methodsModification removeModificationOf: removal methodKey.
	addition methodsModification removeModificationOf: addition methodKey.

	"Record the move."
	movedMethods add: (RwMethodMove
				methodBefore: oldDefinition
				methodAfter: newDefinition
				classOrExtensionBefore: removal classDefinitionOrExtension
				classOrExtensionAfter: addition classDefinitionOrExtension
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition
				projectBefore: removal projectDefinition
				projectAfter: addition projectDefinition
				isMeta: addition isMeta).

	"Does the method have other modifications that need to be recorded?"
	methodModification := newDefinition compareAgainstBase: oldDefinition.
	methodModification 
		isMeta: isMeta;
		classDefinition: addition classDefinitionOrExtension.
	methodModification isEmpty
		ifFalse: 
			[addition methodsModification addElementModification: methodModification]
%

category: 'moves'
method: RwProjectSetModification
updateForMethodMoves
	"Methods that have been moved between packages will initially show up as a remove and an add rather than a move.
	Find moved methods and correct the structure."

	| methodAdditions methodRemovals |
	methodAdditions := self findAddedMethods.
	methodRemovals := self findRemovedMethods.
	"Any keys that match between added and removed should be considered a move."
	methodAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := methodRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [ self updateForMethodMoveFrom: removal to: addition isMeta: key key value]]
%

! Class implementation for 'RwMethodsModification'

!		Class methods for 'RwMethodsModification'

category: 'instance creation'
classmethod: RwMethodsModification
extendedClassName: ignored

	^ self new
%

!		Instance methods for 'RwMethodsModification'

category: 'visiting'
method: RwMethodsModification
acceptVisitor: aVisitor

	^aVisitor visitMethodsModification: self
%

category: 'merging'
method: RwMethodsModification
mergeForExistingClassWith: anExistingMethodsModification

	"merge anExistingMethodsModification modifictions into the receiver"

	anExistingMethodsModification elementsModified
		keysAndValuesDo: [ :selector :anExistingMethodModification | 
			"anExistingMethodsModification contains any new  or modified methods that 
				were applied to this class and they all need to be brought forward 
				along with the forced new versions of methods (those not changed or removed)"
			(elementsModified at: selector ifAbsent: [  ])
				ifNil: [
					"added method"
					elementsModified at: selector put: anExistingMethodModification ]
				ifNotNil: [
					 "modified method"
					elementsModified 
						at: selector 
						put: anExistingMethodModification asMethodModificationForNewClassVersion] ]
%

category: 'merging'
method: RwMethodsModification
mergeForNewClassVersionWith: aMethodsModification

	"merge aMethodsModification modifictions into the receiver"

	"add all method modifications to the receiver, there should be no selector overlap, if there is 
		the receiver wins --- but for now we'll error out. "

	aMethodsModification elementsModified
		keysAndValuesDo: [ :selector :aMethodModification | 
			(elementsModified at: selector ifAbsent: [  ])
				ifNil: [elementsModified at: selector put: aMethodModification]
				ifNotNil: [ :existingMethodModification | 
					existingMethodModification mergeForNewClassVersionWith: aMethodModification ] ]
%

! Class implementation for 'RwExtensionMethodsModification'

!		Class methods for 'RwExtensionMethodsModification'

category: 'instance creation'
classmethod: RwExtensionMethodsModification
extendedClassName: aString

	^ self new
		extendedClassName: aString;
		yourself
%

!		Instance methods for 'RwExtensionMethodsModification'

category: 'visiting'
method: RwExtensionMethodsModification
acceptVisitor: aVisitor

	^ aVisitor visitExtensionMethodsModification: self
%

category: 'modifications'
method: RwExtensionMethodsModification
addElementModification: aModification

	aModification isEmpty
		ifFalse: [ 
			| anExtensionModification |
			anExtensionModification := aModification asExtensionMethodModification.
			anExtensionModification extendedClassName: self extendedClassName.
			elementsModified at: anExtensionModification key put: anExtensionModification ]
%

category: 'accessing'
method: RwExtensionMethodsModification
extendedClassName

   ^extendedClassName
%

category: 'accessing'
method: RwExtensionMethodsModification
extendedClassName: anObject

	extendedClassName := anObject
%

! Class implementation for 'RwPackagesModification'

!		Instance methods for 'RwPackagesModification'

category: 'visiting'
method: RwPackagesModification
acceptVisitor: aVisitor

	^ aVisitor visitPackagesModification: self
%

! Class implementation for 'RwPropertiesModification'

!		Instance methods for 'RwPropertiesModification'

category: 'visiting'
method: RwPropertiesModification
acceptVisitor: aVisitor

	^aVisitor visitPropertiesModification: self
%

! Class implementation for 'RwSourceModification'

!		Instance methods for 'RwSourceModification'

category: 'visiting'
method: RwSourceModification
acceptVisitor: aVisitor

	^aVisitor visitSourceModification: self
%

! Class implementation for 'RwEntitySet'

!		Class methods for 'RwEntitySet'

category: 'instance creation'
classmethod: RwEntitySet
withAll: somePackageRefs

	^(self new)
		initialize;
		addAll: somePackageRefs;
		yourself
%

!		Instance methods for 'RwEntitySet'

category: 'accessing'
method: RwEntitySet
addAll: aRwDefinitionOrRwLoadedThingCollection

	aRwDefinitionOrRwLoadedThingCollection
		do: [ :entity | entities at: entity name put: entity ].
	^ aRwDefinitionOrRwLoadedThingCollection
%

category: 'definitions'
method: RwEntitySet
asDefinitionSet

	| result |
	result := RwDefinitionSetDefinition new.
	entities do: [ :entity | result addDefinition: entity asDefinition ].
	^ result
%

category: 'definitions'
method: RwEntitySet
asPackageDefinitionSet

	| result |
	result := RwPackageSetDefinition new.
	entities do: [ :entity | result addDefinition: entity asDefinition ].
	^ result
%

category: 'definitions'
method: RwEntitySet
asProjectDefinitionSet

	| result |
	result := RwProjectSetDefinition new.
	entities do: [ :entity | result addDefinition: entity asDefinition ].
	^ result
%

category: 'enumeration'
method: RwEntitySet
do: aBlock

	^ entities do: aBlock
%

category: 'accessing'
method: RwEntitySet
entities

	^ entities
%

category: 'initialization'
method: RwEntitySet
initialize

	entities := Dictionary new
%

category: 'accessing'
method: RwEntitySet
size

	^ entities size
%

! Class implementation for 'RwGsFileUtilities'

!		Class methods for 'RwGsFileUtilities'

category: 'utilities'
classmethod: RwGsFileUtilities
deleteAll: aDirectory
  "Delete all the files and directories under the named directory.
	 Ensure we don't try to recursively delete . or .."

  self deleteAll: aDirectory rejecting: [ :filename | false ]
%

category: 'utilities'
classmethod: RwGsFileUtilities
deleteAll: aDirectory rejecting: rejectBlock
  "Delete all the files and directories under the named directory.
       Reject file and directores in aDirectory that are rejected by rejectBlock.
       The rejectBlock is not used recursively.
       Ensure we don't try to recursively delete . or .."

  | filename isFile |
  (GsFile contentsAndTypesOfDirectory: aDirectory onClient: false)
    doWithIndex: [ :each :index | 
      index odd
        ifTrue: [ filename := each ]
        ifFalse: [ 
          isFile := each.
          isFile
            ifTrue: [ 
              (rejectBlock value: filename)
                ifFalse: [ 
                  (rejectBlock value: filename)
                    ifFalse: [ GsFile removeServerFile: filename ] ] ]
            ifFalse: [ 
              (self _endsWithSpecial: filename)
                ifFalse: [ 
                  (rejectBlock value: filename)
                    ifFalse: [ 
                      self deleteAll: filename rejecting: rejectBlock.
                      GsFile removeServerDirectory: filename ] ] ] ] ]
%

category: 'utilities'
classmethod: RwGsFileUtilities
deleteDirectory: aDirectory
  "Delete the named directory and all of it contents"

	self deleteAll: aDirectory.
   GsFile removeServerDirectory: aDirectory
%

category: 'utilities'
classmethod: RwGsFileUtilities
directoryEntriesFrom: aDirectory
	"Answer fully qualified paths to the contents of aDirectory."

	^(GsFile contentsOfDirectory: aDirectory onClient: false) ifNil: [#()]
%

category: 'utilities'
classmethod: RwGsFileUtilities
directoryExists: aDirectory

	"handle the case where GsFile class>>existsOnServer: returns nil"
	^ (GsFile existsOnServer: aDirectory) == true
%

category: 'utilities'
classmethod: RwGsFileUtilities
directoryFromPath: directoryPath relativeTo: aDirectory

	^((aDirectory endsWith: self pathNameDelimiter)
		or: [directoryPath beginsWith: self pathNameDelimiter])
			ifTrue: [aDirectory , directoryPath]
			ifFalse: [aDirectory , self pathNameDelimiter , directoryPath]
%

category: 'private'
classmethod: RwGsFileUtilities
endsWithSpecial: filename
	"Answer true if the given filename ends with any of the special sequences
	'/..' '/.' '\..' '\.', false otherwise."

	| filenameSize finalChars |
	filenameSize := filename size.
	finalChars := filename copyFrom: filenameSize - 1 to: filenameSize.
	finalChars = '/.' ifTrue: [^true].
	finalChars = '\.' ifTrue: [^true].
	finalChars := filename copyFrom: filenameSize - 2 to: filenameSize.
	finalChars = '/..' ifTrue: [^true].
	finalChars = '\..' ifTrue: [^true].
	^false
%

category: 'utilities'
classmethod: RwGsFileUtilities
ensureDirectoryExists: aDirectory

	| lastSeparator |
	(GsFile existsOnServer: aDirectory) == true ifTrue: [^aDirectory].
	(GsFile createServerDirectory: aDirectory) ifNotNil: [^aDirectory].
	lastSeparator := aDirectory findLastSubString: self pathNameDelimiter
				startingAt: aDirectory size.
	lastSeparator <= 1 ifTrue: [self error: 'Cannot create directory'].
	self ensureDirectoryExists: (aDirectory copyFrom: 1 to: lastSeparator - 1).
	self ensureDirectoryExists: aDirectory
%

category: 'utilities'
classmethod: RwGsFileUtilities
entryNamesFrom: aDirectory
  "Answer just the name of the contents of aDirectory."

  ^ (((self directoryEntriesFrom: aDirectory)
    collect: [ :each | self localNameFrom: each ])
    reject: [ :each | each = '.' or: [ each = '..' ] ])
    sortWithBlock: [ :a :b | a <= b ]
%

category: 'utilities'
classmethod: RwGsFileUtilities
localNameFrom: aDirectory

	| endOfPath |
	endOfPath := aDirectory findLastSubString: self pathNameDelimiter
				startingAt: aDirectory size.
	^aDirectory copyFrom: endOfPath + 1 to: aDirectory size
%

category: 'utilities'
classmethod: RwGsFileUtilities
pathNameDelimiter

	^'/'
%

category: 'utilities'
classmethod: RwGsFileUtilities
readStreamFor: filePath do: aOneArgBlock

	| file stream result |
	GsFile serverErrorString.
	file := GsFile openReadOnServer: filePath.
	GsFile serverErrorString
		ifNotNil: [:errorMessage | self error: errorMessage].
	
	[stream := ReadStreamPortable
				on: (String withAll: file contents asByteArray decodeFromUTF8).
	result := aOneArgBlock value: stream]
			ensure: [file close].
	^result
%

category: 'utilities'
classmethod: RwGsFileUtilities
readStreamFor: filePath in: aDirectory do: aOneArgBlock

	self
		readStreamFor: (self directoryFromPath: filePath relativeTo: aDirectory)
		do: aOneArgBlock
%

category: 'utilities'
classmethod: RwGsFileUtilities
writeStreamFor: filePath in: aDirectory do: aOneArgBlock

	| file stream |
	GsFile serverErrorString.
	file := GsFile openWriteOnServer: (self directoryFromPath: filePath relativeTo: aDirectory).
	GsFile serverErrorString ifNotNil: [:errorMessage | self error: errorMessage].
	stream := WriteStreamPortable on: String new.
	[aOneArgBlock value: stream] ensure: [file nextPutAll: stream contents encodeAsUTF8; close]
%

category: 'private'
classmethod: RwGsFileUtilities
_endsWithSpecial: filename
  "Answer true if the given filename ends with any of the special sequences
	'/..' '/.' '\..' '\.', false otherwise."

  | filenameSize finalChars |
  filenameSize := filename size.
  finalChars := filename copyFrom: filenameSize - 1 to: filenameSize.
  finalChars = '/.'
    ifTrue: [ ^ true ].
  finalChars = '\.'
    ifTrue: [ ^ true ].
  finalChars := filename copyFrom: filenameSize - 2 to: filenameSize.
  finalChars = '/..'
    ifTrue: [ ^ true ].
  finalChars = '\..'
    ifTrue: [ ^ true ].
  ^ false
%

! Class implementation for 'RwGsImage'

!		Class methods for 'RwGsImage'

category: 'querying'
classmethod: RwGsImage
addLoadedProject: aRwLoadedProject

	"Register a project"

	| projectName projectRegistry |
	aRwLoadedProject projectOwnerId: self currentUserId.
	projectName := aRwLoadedProject name.
	projectRegistry := self
		_loadedProjectRegistryForUserId: aRwLoadedProject projectOwnerId.
	projectRegistry
		at: projectName
		ifAbsent: [ ^ projectRegistry at: projectName put: aRwLoadedProject ].
	self
		error:
			'There is already a project named ' , projectName printString , ' registered'
%

category: 'testing'
classmethod: RwGsImage
canWrite: anObject

	^ System canWrite: anObject
%

category: 'querying'
classmethod: RwGsImage
currentUserId

	^ GsCurrentSession currentSession userProfile userId
%

category: 'operations'
classmethod: RwGsImage
ensureSessionMethodsEnabled

	"Ensure that session methods are enabled for the current user."

	GsPackagePolicy current enabled
		ifFalse: [ GsPackagePolicy current enable ].
%

category: 'querying'
classmethod: RwGsImage
existingSymbolDictionaryNamed: dictName

	"If the current session's transient symbol list includes a dictionary with the given name, answer it. "

	| symbolName |
	symbolName := dictName asSymbol.
	^ self symbolList
		detect: [ :each | (each at: symbolName ifAbsent: [ nil ]) == each ]
		ifNone: [ nil ]
%

category: 'querying'
classmethod: RwGsImage
loadedClassAndSymbolDicitonaryForClass: class ifPresent: presentBlock ifAbsent: absentBlock

        "scan the symbol list for a RwLoadedClass instances for the given compiled method"

        self symbolList
                do: [ :symbolDict |
                        symbolDict rowanSymbolDictionaryRegistry
                                ifNotNil: [ :registry |
                                        (registry classRegistry at: class classHistory ifAbsent: [  ])
                                                ifNotNil: [ :loadedClass | ^ presentBlock value: symbolDict value: loadedClass ] ] ].
        ^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedClassExtensionsForClass: class

	"lookup the loadedClassExtensions for the given class"

	| history found |
	history := class classHistory.
	found := IdentitySet new.
	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry classExtensionRegistry at: history ifAbsent: [  ])
						ifNotNil: [ :loadedClassExtensionSet | found addAll: loadedClassExtensionSet ] ] ].
	^ found
%

category: 'querying'
classmethod: RwGsImage
loadedClassExtensionsNamed: className ifFound: foundBlock ifAbsent: absentBlock

	"scan the symbol list for a RwLoadedClassExtension instances of the given name"

	| class found |
	class := self objectNamed: className.
	class ifNil: [ ^ absentBlock value ].
	found := self loadedClassExtensionsForClass: class.
	found isEmpty
		ifFalse: [ ^ foundBlock value: found ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedClassForClass: class ifAbsent: absentBlock

	"Lookup the given class in the classRegistry"

	| history |
	history := class classHistory.
	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry classRegistry at: history ifAbsent: [  ])
						ifNotNil: [ :loadedClass | ^ loadedClass ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedClassNamed: className

	^ self
		loadedClassNamed: className
		ifAbsent: [ self error: 'loaded class named ' , className printString , ' not found.' ]
%

category: 'querying'
classmethod: RwGsImage
loadedClassNamed: className ifAbsent: absentBlock

	^ self
		loadedClassNamed: className
		ifFound: [ :loadedClass | ^ loadedClass ]
		ifAbsent: absentBlock
%

category: 'querying'
classmethod: RwGsImage
loadedClassNamed: className ifFound: foundBlock ifAbsent: absentBlock

	"scan the symbol list for a RwLoadedClass instance of the given name"

	| class loadedClass |
	class := self objectNamed: className.
	class ifNil: [ ^ absentBlock value ].
	loadedClass := self
		loadedClassForClass: class
		ifAbsent: [ ^ absentBlock value ].
	^ foundBlock value: loadedClass
%

category: 'querying'
classmethod: RwGsImage
loadedHybridPackageNamed: aHybridName ifAbsent: absentBlock

	"scan the symbol list a RwLoadedPackage instance of the given hybrid name"

	"a hybrid package name has a leading '*' followed by the name of a package ... 
		where the hybrid package name is not expected to preserve case"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry loadedHybridPackageNamed: aHybridName ifAbsent: [  ])
						ifNotNil: [ :loadedPackage | ^ loadedPackage ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedMethod: selector inClassNamed: className isMeta: isMeta ifFound: foundBlock ifAbsent: absentBlock

	"scan the symbol list for a RwLoadedMethod instances for the given selector in the named class"

	| behavior compiledMethod |
	behavior := self objectNamed: className.
	behavior ifNil: [ ^ absentBlock value ].
	isMeta
		ifTrue: [ behavior := behavior class ].
	compiledMethod := behavior
		compiledMethodAt: selector asSymbol
		environmentId: 0
		otherwise: nil.
	compiledMethod ifNil: [ ^ absentBlock value ].
	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry methodRegistry at: compiledMethod ifAbsent: [  ])
						ifNotNil: [ :loadedMethod | ^ foundBlock value: loadedMethod ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedMethodAndSymbolDicitonaryForMethod: compiledMethod ifPresent: presentBlock ifAbsent: absentBlock

        "scan the symbol list for a RwLoadedMethod instances for the given compiled method"

        self symbolList
                do: [ :symbolDict |
                        symbolDict rowanSymbolDictionaryRegistry
                                ifNotNil: [ :registry |
                                        (registry methodRegistry at: compiledMethod ifAbsent: [  ])
                                                ifNotNil: [ :loadedMethod | ^ presentBlock value: symbolDict value: loadedMethod ] ] ].
        ^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedMethodForMethod: compiledMethod

	"scan the symbol list for a RwLoadedMethod instances for the given compiled method"

	^ self
		loadedMethodForMethod: compiledMethod
		ifAbsent: [ 
			self
				error:
					'No loadedMethod found for the comiled method ' , compiledMethod printString ]
%

category: 'querying'
classmethod: RwGsImage
loadedMethodForMethod: compiledMethod ifAbsent: absentBlock

	"scan the symbol list for a RwLoadedMethod instances for the given compiled method"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry methodRegistry at: compiledMethod ifAbsent: [  ])
						ifNotNil: [ :loadedMethod | ^ loadedMethod ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedPackageNamed: aString

	^ self
		loadedPackageNamed: aString
		ifAbsent: [ self error: 'No loaded package named ' , aString printString , ' found' ]
%

category: 'querying'
classmethod: RwGsImage
loadedPackageNamed: aName ifAbsent: absentBlock

	"scan the symbol list a RwLoadedPackage instance of the given name"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry loadedPackageNamed: aName ifAbsent: [  ])
						ifNotNil: [ :loadedPackage | ^ loadedPackage ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedProjectNamed: aString

	^ self
		loadedProjectNamed: aString
		ifPresent: [:loadedProject | loadedProject ]
		ifAbsent: [ self error: 'No loaded project named ' , aString printString , ' found' ]
%

category: 'querying'
classmethod: RwGsImage
loadedProjectNamed: aString ifAbsent: absentBlock

	"Look up a loaded project in the loaded project registry"

	^ self
		loadedProjectNamed: aString
		ifPresent: [:loadedProject | loadedProject ]
		ifAbsent: absentBlock
%

category: 'querying'
classmethod: RwGsImage
loadedProjectNamed: aString ifPresent: presentBlock ifAbsent: absentBlock

	"Look up a loaded project in the loaded project registry"

	| loadedProject |
	loadedProject := self _loadedProjectRegistry
		at: aString
		ifAbsent: [
			| matchingProjects |
			matchingProjects := self loadedProjects select: [:each | each name = aString ].
			matchingProjects size > 1 ifTrue: [ self error: 'Multiple projects with same name available from symbol dictionaries in symbol list' ].
			matchingProjects size = 0 ifTrue: [ ^ absentBlock value ].
			matchingProjects any ].
	^ presentBlock cull: loadedProject
%

category: 'querying'
classmethod: RwGsImage
loadedProjects

	"Return the list of loaded projects based on the packages that are visible in the current transient symbol list."

	| loadedProjects |
	loadedProjects := (self _loadedProjectRegistryForUserId: self currentUserId) values asIdentitySet. "list of projects created by current user"
	(self symbolList select: [:symDict | 
		symDict rowanSymbolDictionaryRegistry notNil])
		do: [:symDict | 
			"visible loaded packages"
			symDict rowanSymbolDictionaryRegistry packageRegistry values 
				do: [:loadedPackage | 
					"visible loaded projects"
					loadedProjects add: loadedPackage loadedProject ] ].
	^loadedProjects
%

category: 'querying'
classmethod: RwGsImage
loadedRegistryForPackageNamed:  aName

	"scan the symbol list for a RwLoadedPackage instance of the given name and return the registry"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry loadedPackageNamed: aName ifAbsent: [  ])
						ifNotNil: [ :loadedPackage | ^ registry ] ] ].
	^self error: 'The package ', aName printString, ' was not found'
%

category: 'querying'
classmethod: RwGsImage
newOrExistingSymbolDictionaryNamed: dictName

	"If the current session's transient symbol list includes a dictionary with the given name, answer it.
	Otherwise, create one, add it to the beginning of both transient and persistent symbol lists, and 
	answer it."

	| symbolName session symbolList symbolDict |
	symbolName := dictName asSymbol.
	session := GsCurrentSession currentSession.
	symbolList := session symbolList.
	symbolDict := symbolList
		detect: [ :each | (each at: symbolName ifAbsent: [ nil ]) == each ]
		ifNone: [ 
			| newDict size |
			newDict := SymbolDictionary new
				name: symbolName;
				objectSecurityPolicy: symbolList objectSecurityPolicy;
				yourself.
			size := System myUserProfile symbolList size.
			System myUserProfile insertDictionary: newDict at: size + 1.
			newDict ].
	symbolDict rowanSymbolDictionaryRegistry
		ifNil: [ RwGsSymbolDictionaryRegistry installIn: symbolDict ].
	^ symbolDict
%

category: 'querying'
classmethod: RwGsImage
objectNamed: aSymbol

	"Returns the first object in the current session's symbol list that has the given
 name.  If no object with the given name is found, returns nil."

	^ self symbolList objectNamed: aSymbol
%

category: 'querying'
classmethod: RwGsImage
packageNames

	"Return list of package names. All sytem projects are visible, but not all packages of visible projects
		are visible."

	| packageNames visiblePackageNames |
	packageNames := Set new.
	visiblePackageNames := Set new.
	(self symbolList select: [:symDict | 
		symDict rowanSymbolDictionaryRegistry notNil])
		do: [:symDict | 
			visiblePackageNames 
				addAll: symDict rowanSymbolDictionaryRegistry packageRegistry keys ].
	self loadedProjects
		do: [ :loadedProject | 
			loadedProject packageNames do: [:packageName |
				(visiblePackageNames includes: packageName) ifTrue: [ packageNames add: packageName ] ] ].
	^ packageNames asArray
%

category: 'querying'
classmethod: RwGsImage
packageNamesForLoadedProjectNamed: projectName

	"Return list of package names for the loaded project with the given name. All sytem projects are visible, but not all packages of visible projects
		are visible."

	| packageNames visiblePackageNames |
	packageNames := Set new.
	visiblePackageNames := Set new.
	(self symbolList select: [:symDict | 
		symDict rowanSymbolDictionaryRegistry notNil])
		do: [:symDict | 
			visiblePackageNames 
				addAll: symDict rowanSymbolDictionaryRegistry packageRegistry keys ].
	(self loadedProjectNamed: projectName) packageNames do: [:packageName |
				(visiblePackageNames includes: packageName) ifTrue: [ packageNames add: packageName ] ].
	^ packageNames asArray
%

category: 'cypress (old)'
classmethod: RwGsImage
projectNames

	"Return list of project names"

	^ (self loadedProjects collect: [ :loadedProject | loadedProject name ]) asArray
%

category: 'querying'
classmethod: RwGsImage
removeLoadedClassExtensionsForClass: class

	"The class has or will be deleted from the system, remove the loadedClassExtensions that refer
		to the given class"

	| history |
	history := class classHistory.
	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | registry classExtensionRegistry removeKey: history ifAbsent: [  ] ] ]
%

category: 'querying'
classmethod: RwGsImage
removeLoadedMethodForCompileMethod: compiledMethod

	"The given compiled method is being removed from the system, remove the loadedMethod associated 
		with the compiled method."

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | registry methodRegistry removeKey: compiledMethod ifAbsent: [  ] ] ]
%

category: 'querying'
classmethod: RwGsImage
resolveClassNamed: aName

	"If the given name is bound to a class in the environment of the current session, 
	answer that class. Otherwise, answer nil."

	| resolved |
	resolved := self objectNamed: aName.
	^ (resolved isBehavior and: [ resolved isMeta not ])
		ifTrue: [ resolved ]
		ifFalse: [ nil ]
%

category: 'querying'
classmethod: RwGsImage
resolveName: aName

	"Searches the current session's symbol list for an Association whose key is equal to
 aString, and returns that Association.  If no such Association is found in the
 symbol list, returns nil. Uses the current session's transient copy of the symbol list."

	^ GsCurrentSession currentSession resolveSymbol: aName asSymbol
%

category: 'querying'
classmethod: RwGsImage
symbolList

	"Answer the current session (transient) symbol list"

	^ GsCurrentSession currentSession symbolList
%

category: 'private'
classmethod: RwGsImage
_loadedProjectRegistry

	^ self _loadedProjectRegistryForUserId: self currentUserId
%

category: 'private'
classmethod: RwGsImage
_loadedProjectRegistryForUserId: aUserId

	| userProfile userPlatformDict |
	userProfile := AllUsers userWithId: aUserId.
	(userProfile defaultObjectSecurityPolicy ifNil: [true] ifNotNil: [:x |x currentUserCanRead])
		ifFalse: [
			"do not have permissions to read objects created by <aUserId>"
			^ nil ].
	userPlatformDict := RwPlatform _userPlatformDictionaryForUser: aUserId.
	^ userPlatformDict
		at: #'RwGsLoadedProjectRegistry'
		ifAbsent: [ 
			(self currentUserId = aUserId)
				ifFalse: [ ^ nil ].
			userPlatformDict at: #'RwGsLoadedProjectRegistry' put: StringKeyValueDictionary new ]
%

category: 'cypress (old)'
classmethod: RwGsImage
_projectRegistry

	^ self _projectRegistryForUserId: self currentUserId
%

category: 'querying'
classmethod: RwGsImage
_removeLoadedProject: aRwLoadedProject

	"note that it is not safe to just remove a loaded project from the registry, however this method is supplied as a convenience for tests"

	| projectName projectRegistry |
	projectName := aRwLoadedProject name.
	projectRegistry := self
		_loadedProjectRegistryForUserId: aRwLoadedProject projectOwnerId.
	(projectRegistry at: projectName ifAbsent: [ ^ nil ]) == aRwLoadedProject
		ifFalse: [ 
			self
				error:
					'The specified project is not identical to the loaded project in the registry ... this is not expected' ].
	projectRegistry removeKey: projectName
%

! Class implementation for 'RwGsImagePatchVisitor_254'

!		Class methods for 'RwGsImagePatchVisitor_254'

category: 'instance creation'
classmethod: RwGsImagePatchVisitor_254
new

	^super new initialize
%

!		Instance methods for 'RwGsImagePatchVisitor_254'

category: 'private'
method: RwGsImagePatchVisitor_254
addAddedPackage: aPackageDefinition

	currentPackage := aPackageDefinition.
	patchSet addAddedPackage: currentPackage inProject: currentProject.
%

category: 'private'
method: RwGsImagePatchVisitor_254
addAddedProject: aProjectDefinition

	currentProject := aProjectDefinition.
	patchSet addAddedProject: currentProject
%

category: 'private'
method: RwGsImagePatchVisitor_254
addClasses: classDefinitions

	classDefinitions
		do: [ :classDefinition | 
			"https://github.com/dalehenrich/Rowan/issues/210 - make sure that the added classes are not already loaded
				in a project that is not included in this load"
			(Rowan globalNamed: classDefinition name) ifNotNil: [:global | (RwExistingVisitorAddingExistingClassNotification new classDefinition: classDefinition) signal ]].
	classDefinitions
		do: [ :classDefinition | 
			patchSet
				addAddedClass: classDefinition
				inPackage: currentPackage
				inProject: currentProject.
			classDefinition classMethodDefinitions
				do: [ :classMethodDefinition | 
					patchSet
						addAddedClassMethod: classMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ].
			classDefinition instanceMethodDefinitions
				do: [ :instanceMethodDefinition | 
					patchSet
						addAddedInstanceMethod: instanceMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ] ]
%

category: 'private'
method: RwGsImagePatchVisitor_254
addClassExtensions: classExtensions

	classExtensions
		do: [ :classDefinition | 
			patchSet
				addExtendedClass: classDefinition
				inPackage: currentPackage
				inProject: currentProject.
			classDefinition classMethodDefinitions
				do: [ :classMethodDefinition | 
					patchSet
						addExtendedClassMethod: classMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ].
			classDefinition instanceMethodDefinitions
				do: [ :instanceMethodDefinition | 
					patchSet
						addExtendedInstanceMethod: instanceMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ] ]
%

category: 'private'
method: RwGsImagePatchVisitor_254
addDeletedPackage: aPackageDefinition

	currentPackage := aPackageDefinition.
	patchSet addDeletedPackage: currentPackage inProject: currentProject
%

category: 'private'
method: RwGsImagePatchVisitor_254
deleteClasses: classDefinitions

	classDefinitions
		do: [ :classDefinition | 
			patchSet
				addDeletedClass: classDefinition
				inPackage: currentPackage
				inProject: currentProject.
			classDefinition classMethodDefinitions
				do: [ :classMethodDefinition | 
					patchSet
						addDeletedClassMethod: classMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ].
			classDefinition instanceMethodDefinitions
				do: [ :instanceMethodDefinition | 
					patchSet
						addDeletedInstanceMethod: instanceMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ] ]
%

category: 'initialization'
method: RwGsImagePatchVisitor_254
initialize

	patchSet := self _patchSetClass new
%

category: 'accessing'
method: RwGsImagePatchVisitor_254
patchSet
	^patchSet
%

category: 'public'
method: RwGsImagePatchVisitor_254
visit: aPackageSetModification

	^aPackageSetModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitClassesModification: aClassesModification

	aClassesModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitClassExtensionModification: aClassExtensionModification

	aClassExtensionModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassExtensionModification after.
	aClassExtensionModification instanceMethodsModification acceptVisitor: self.
	aClassExtensionModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitClassExtensionsModification: aClassExtensionsModification

	aClassExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitClassModification: aClassModification

	aClassModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassModification after.
	aClassModification instanceMethodsModification acceptVisitor: self.
	aClassModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitClassModificationForcingNewVersion: aClassModification

	aClassModification
		addModificationForcingNewClassVersionToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassModification after.
	aClassModification instanceMethodsModification acceptVisitor: self.
	aClassModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitExtensionMethodModification: anExtensionMethodModification

	anExtensionMethodModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitExtensionMethodModificationForNewClassVersion: aMethodModification

	aMethodModification
		addExtensionModificationToPatchSetForNewClassVersion: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitExtensionMethodsModification: anExtensionMethodsModification

	anExtensionMethodsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitMethodModification: aMethodModification

	aMethodModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitMethodModificationForNewClassVersion: aMethodModification

	aMethodModification
		addModificationToPatchSetForNewClassVersion: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitMethodsModification: aMethodsModification

	aMethodsModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitPackageModification: aPackageModification

	| propertiesModification |
	aPackageModification isAddition
		ifTrue: [ self addAddedPackage: aPackageModification after ].
	aPackageModification isDeletion
		ifTrue: [ self addDeletedPackage: aPackageModification before ].
	currentPackage := aPackageModification after.
	aPackageModification isModification
		ifTrue: [ 
			propertiesModification := aPackageModification propertiesModification.
			propertiesModification isEmpty
				ifFalse: [ patchSet addMovedPackage: currentPackage inProject: currentProject ] ].
	aPackageModification classesModification acceptVisitor: self.
	aPackageModification classExtensionsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitPackageSetModification: aPackageSetModification

	aPackageSetModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitPackagesModification: aPackagesModification

	aPackagesModification elementsModified do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitProjecteSetModification: aProjectSetModification

	aProjectSetModification movedClasses do: [:movedClass | 
		movedClass addMovedClassToPatchSet: patchSet ].
	aProjectSetModification movedMethods do: [:movedMethod | 
		movedMethod addMovedMethodToPatchSet: patchSet ].
	aProjectSetModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitProjectModification: aProjectModification

	| propertiesModification |
	aProjectModification isAddition
		ifTrue: [ 
			self addAddedProject: aProjectModification after.
			aProjectModification packagesModification acceptVisitor: self.
			^ self ].
	aProjectModification isDeletion
		ifTrue: [ 
			self addDeletedProject: aProjectModification before.
			aProjectModification packagesModification acceptVisitor: self.
			^ self ].
	currentProject := aProjectModification after.
	propertiesModification := aProjectModification propertiesModification.
	propertiesModification isEmpty
		ifFalse: [ 
			"https://github.com/dalehenrich/Rowan/issues/180"
			| modifiedProperties |
			modifiedProperties := String new.
			propertiesModification elementsModified keys do: [:key | modifiedProperties add: ' '; add: key printString ].
			self error: 'internal error - unexpected non-empty project properties modification:', modifiedProperties, '. See Issue #180'  ].
	aProjectModification packagesModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitPropertiesModification: aPropertiesModification

	self error: 'internal error - not yet implemented'
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitSourceModification: aSourceModification

	self error: 'internal error - not yet implemented'
%

category: 'private'
method: RwGsImagePatchVisitor_254
_patchSetClass

	^ RwGsPatchSet_254
%

! Class implementation for 'RwGsInstanceMigrator'

!		Class methods for 'RwGsInstanceMigrator'

category: 'instance creation'
classmethod: RwGsInstanceMigrator
aggressiveMigration

	^ self new
		maxThreads: SystemRepository _aggressiveMaxThreadCount;
		maxCpuPercentage: 95;
		yourself
%

category: 'instance creation'
classmethod: RwGsInstanceMigrator
conservativeMigration

	^ self new
%

category: 'instance creation'
classmethod: RwGsInstanceMigrator
noMigration

	^ self new
		migrationEnabled: false;
		yourself
%

!		Instance methods for 'RwGsInstanceMigrator'

category: 'accessing'
method: RwGsInstanceMigrator
maxCpuPercentage

	^ maxCpuPercentage ifNil: [ 90 ]
%

category: 'accessing'
method: RwGsInstanceMigrator
maxCpuPercentage: anObject

   maxCpuPercentage := anObject
%

category: 'accessing'
method: RwGsInstanceMigrator
maxThreads

	^ maxThreads ifNil: [ 2 ]
%

category: 'accessing'
method: RwGsInstanceMigrator
maxThreads: anObject

   maxThreads := anObject
%

category: 'migration'
method: RwGsInstanceMigrator
migrateInstancesOf: aClassArray

	| instancesArray classCount |
	self migrationEnabled
		ifFalse: [ ^ self ].
	System commit.
	instancesArray := SystemRepository
		listInstances: aClassArray
		limit: 0
		toDirectory: nil
		withMaxThreads: self maxThreads
		maxCpuUsage: self maxCpuPercentage
		memoryOnly: false.
	classCount := 1.
	1 to: instancesArray size by: 2 do: [ :index | 
		| class instances history instanceCount |
		class := aClassArray at: classCount.
		instanceCount := instancesArray at: index.
		instances := instancesArray at: index + 1.
		history := class classHistory.
		instanceCount > 0
			ifTrue: [ class migrateInstances: instances to: history last ].
		[ 1 < history size ] whileTrue: [ | cl | cl := history first. cl classHistory removeVersion: cl ].
		classCount := classCount + 1 ]
%

category: 'accessing'
method: RwGsInstanceMigrator
migrationEnabled

	^ migrationEnabled ifNil: [ true ]
%

category: 'accessing'
method: RwGsInstanceMigrator
migrationEnabled: anObject

   migrationEnabled := anObject
%

! Class implementation for 'RwGsDeferredInstanceMigrator'

!		Instance methods for 'RwGsDeferredInstanceMigrator'

category: 'accessing'
method: RwGsDeferredInstanceMigrator
classesToMigrate

	^ classesToMigrate
%

category: 'migration'
method: RwGsDeferredInstanceMigrator
migrateInstancesOf: aClassArray

	"Record the list of classes with new class versions"

	classesToMigrate := aClassArray
%

! Class implementation for 'RwGsPatch'

!		Instance methods for 'RwGsPatch'

category: 'accessing'
method: RwGsPatch
packageDefinition
	^packageDefinition
%

category: 'accessing'
method: RwGsPatch
packageDefinition: newValue
	packageDefinition := newValue
%

category: 'accessing'
method: RwGsPatch
packageName

	^packageDefinition key
%

category: 'accessing'
method: RwGsPatch
projectDefinition

	^ projectDefinition ifNil: [ RwUnmanagedProjectDefinition new ]
%

category: 'accessing'
method: RwGsPatch
projectDefinition: newValue
	projectDefinition := newValue
%

category: 'accessing'
method: RwGsPatch
projectName

	^projectDefinition key
%

category: 'utility'
method: RwGsPatch
resolveName: aName

	"Answer a SymbolAssociation for the given name."

	^ Rowan image resolveName: aName
%

category: 'accessing'
method: RwGsPatch
symbolDictionary

	^ self symbolDictionaryFor: self packageName
%

category: 'accessing'
method: RwGsPatch
symbolDictionaryFor: aPackageName

	^ self symbolDictionaryFor: aPackageName projectDefinition: self projectDefinition
%

category: 'accessing'
method: RwGsPatch
symbolDictionaryFor: aPackageName projectDefinition: aProjectDefinition

	| symDictName symDict |
	symDictName := aProjectDefinition symbolDictNameForPackageNamed: aPackageName.
	symDict := GsCurrentSession currentSession symbolList objectNamed: symDictName asSymbol.
	symDict
		ifNotNil: [ symDict rowanSymbolDictionaryRegistry ifNotNil: [ ^ symDict ] ].
	^ Rowan image newOrExistingSymbolDictionaryNamed: symDictName
%

category: 'accessing'
method: RwGsPatch
symbolDictionaryRegistry

	^ self symbolDictionary rowanSymbolDictionaryRegistry
%

category: 'accessing'
method: RwGsPatch
symbolDictionaryRegistryFor: aPackageName

	^ (self symbolDictionaryFor: aPackageName) rowanSymbolDictionaryRegistry
%

! Class implementation for 'RwGsClassPatch'

!		Class methods for 'RwGsClassPatch'

category: 'instance creation'
classmethod: RwGsClassPatch
for: aClassDefinition inPackage: aPackageDefinition

	^(self new)
		classDefinition: aClassDefinition;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassPatch'

category: 'actions'
method: RwGsClassPatch
addToNewClassesByName: aDictionary

	"Dictionary is class name -> classAdditionPatch. Error on duplicate name."

	| name |
	name := classDefinition key.
	name ifNil: [ self error: 'Class definition with no name.' ].
	(aDictionary includesKey: name)
		ifTrue: [ self error: 'Duplicate name' ].
	aDictionary at: name put: self
%

category: 'private'
method: RwGsClassPatch
basicCreateClassWithSuperclass: superclass

	"For GemStone, the valid values are:
	bytes
	variable
	normal for non-indexable pointer object"

	"Must be in-synch with RwGsLoadedClass>>updateClassTypeFromClass"

	| type oldVersion createdClass gs_options oldConstraints |
	type := classDefinition classType.
	oldVersion := self oldClassVersion.
	oldConstraints := oldVersion
		ifNil: [ #() ]
		ifNotNil: [ oldVersion _rwSortedConstraints ].
	gs_options := (classDefinition gs_options)
		collect: [ :each | each asSymbol ].
	createdClass := type = 'normal'
		ifTrue: [ 
			superclass
				subclass: classDefinition key
				instVarNames: (classDefinition propertyAt: 'instvars')
				classVars: (classDefinition propertyAt: 'classvars')
				classInstVars: (classDefinition propertyAt: 'classinstvars')
				poolDictionaries: (classDefinition propertyAt: 'pools')
				inDictionary: nil
				newVersionOf: oldVersion
				description: (classDefinition propertyAt: 'comment' ifAbsent: [ '' ])
				constraints: oldConstraints
				options: gs_options ]
		ifFalse: [ 
			type = 'variable'
				ifTrue: [ 
					superclass
						indexableSubclass: classDefinition key
						instVarNames: (classDefinition propertyAt: 'instvars')
						classVars: (classDefinition propertyAt: 'classvars')
						classInstVars: (classDefinition propertyAt: 'classinstvars')
						poolDictionaries: (classDefinition propertyAt: 'pools')
						inDictionary: nil
						newVersionOf: oldVersion
						description: (classDefinition propertyAt: 'comment' ifAbsent: [ '' ])
						constraints: oldConstraints
						options: gs_options ]
				ifFalse: [ 
					type = 'bytes'
						ifTrue: [ 
							(classDefinition propertyAt: 'instvars') isEmpty
								ifFalse: [ self error: 'Cannot define byte class with named instvars.' ].
							superclass
								byteSubclass: classDefinition key
								classVars: (classDefinition propertyAt: 'classvars')
								classInstVars: (classDefinition propertyAt: 'classinstvars')
								poolDictionaries: (classDefinition propertyAt: 'pools')
								inDictionary: nil
								newVersionOf: oldVersion
								description: (classDefinition propertyAt: 'comment' ifAbsent: [ '' ])
								options: gs_options ]
						ifFalse: [ self error: 'Unknown class type' ] ] ].
	^ createdClass
%

category: 'accessing'
method: RwGsClassPatch
classDefinition
	^classDefinition
%

category: 'accessing'
method: RwGsClassPatch
classDefinition: newValue
	classDefinition := newValue
%

category: 'accessing'
method: RwGsClassPatch
className

	^classDefinition key
%

category: 'actions'
method: RwGsClassPatch
createClassFor: aPatchSet

	| createdClass |
	createdClass := self privateCreateClassFor: aPatchSet.
	aPatchSet createdClass: createdClass.
	^ createdClass
%

category: 'patching moved classes'
method: RwGsClassPatch
installPropertiesPatchFor: aPatchSet classMove: aClassMove

	| theRegistry |
	theRegistry := (self symbolDictionaryFor: aClassMove packageAfter name projectDefinition: aClassMove projectAfter)
		rowanSymbolDictionaryRegistry.
	self installPropertiesPatchFor: aPatchSet registry: theRegistry
%

category: 'versioning'
method: RwGsClassPatch
oldClassVersion
	"The old version is what is currently bound to the class definition's name."

	^ (self resolveName: classDefinition key) value
%

category: 'private'
method: RwGsClassPatch
privateCreateClassFor: aPatchSet

	| superclass |
	superclass := aPatchSet 
		superclassNamed: classDefinition superclassName 
		ifAbsent: [
			"https://github.com/GemTalk/Rowan/issues/471"
			"if we can't look up the class, try accessing the superclass from the class itself"
			(aPatchSet tempSymbols 
				at: classDefinition name asSymbol
				ifAbsent: [ self error: 'Class not found ', classDefinition className printString ]) superClass ].
	superclass
		ifNil: [ 
			classDefinition superclassName = 'nil'
				ifFalse: [ 
					self
						error:
							'The class named ' , classDefinition superclassName printString
								, ' does not exist.' ] ].
	^ self privateCreateClassWithSuperclass: superclass
%

category: 'private'
method: RwGsClassPatch
privateCreateClassWithSuperclass: superclass

	| classProperties infoSource category createdClass |
	createdClass := self basicCreateClassWithSuperclass: superclass.
	classProperties := classDefinition properties.
	infoSource := Rowan configuration packageInfoSource.
	category := infoSource == #'Category'
		ifTrue: [ self packageName ]
		ifFalse: [ classProperties at: 'category' ifAbsent: [  ] ].
	createdClass category: category.
	^ createdClass
%

category: 'accessing'
method: RwGsClassPatch
superclassName

	^classDefinition superclassName
%

category: 'private'
method: RwGsClassPatch
_classFormat: fmt forSubclassType: classType
	"Legal types are normal, variable, and bytes."

	"These values need to be moved into Class"
	^classType = 'normal'
		ifTrue: [ fmt ]
		ifFalse: 
			[ classType = 'variable'
				ifTrue: [ fmt bitOr: 16r4.	"add indexable bit" ]
				ifFalse: 
					[ classType = 'bytes'
						ifTrue: [ (fmt bitAnd: 16r3 bitInvert) bitOr: 16r1 + 16r4 ]
						ifFalse: [self error: 'Unknown class type']]]
%

category: 'private'
method: RwGsClassPatch
_gemStoneConstraintsFrom:	gs_constraints
	"reify the constraints array converting to references to instvar names and classes"

	(gs_constraints isKindOf: Array)
		ifTrue: [ 
			gs_constraints isEmpty
				ifTrue: [^ #() ]
				ifFalse: [
					| theConstraints |
					 theConstraints := {}.
					gs_constraints do: [ :ar | 
						(ar isKindOf: Array)
							ifTrue: [ theConstraints add: { (ar at: 1) asSymbol . Rowan globalNamed: (ar at: 2) } ]
							ifFalse: [ theConstraints add: (Rowan globalNamed: ar) ] ].
					^ theConstraints ] ]
		ifFalse: [ ^ Rowan globalNamed: gs_constraints ].
%

! Class implementation for 'RwGsClassAdditionSymbolDictPatch'

!		Instance methods for 'RwGsClassAdditionSymbolDictPatch'

category: 'actions'
method: RwGsClassAdditionSymbolDictPatch
createAndInstallLoadedClass

	self symbolDictionaryRegistry
		createAndInstallLoadedClassForClass: newClass 
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'actions'
method: RwGsClassAdditionSymbolDictPatch
createClassFor: aPatchSet
	newClass := super createClassFor: aPatchSet.
	symbolAssociation := aPatchSet tempAssociationFor: newClass name.
	^ newClass
%

category: 'actions'
method: RwGsClassAdditionSymbolDictPatch
installClassInSystem

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	self symbolDictionaryRegistry
		addClassAssociation: symbolAssociation
		forClass: newClass
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'accessing'
method: RwGsClassAdditionSymbolDictPatch
newClass
	^newClass
%

category: 'versioning'
method: RwGsClassAdditionSymbolDictPatch
oldClassVersion
	"We are adding a new class, so there is no old version."

	^nil
%

! Class implementation for 'RwGsClassConstraintsSymDictPatch'

!		Instance methods for 'RwGsClassConstraintsSymDictPatch'

category: 'actions'
method: RwGsClassConstraintsSymDictPatch
addToNewClassesByName: aDictionary

	"noop"

	
%

category: 'installing'
method: RwGsClassConstraintsSymDictPatch
installPropertiesPatchFor: aPatchSet

	self installPropertiesPatchFor: aPatchSet registry: self symbolDictionaryRegistry
%

category: 'installing'
method: RwGsClassConstraintsSymDictPatch
installPropertiesPatchFor: aPatchSet registry: aSymbolDictionaryRegistry

	" update class and update loadedClass with new constraints"

	| className existingClass theConstraints existingConstraintsMap existingVaryingConstraint theConstraintsMap theVaryingConstraint keys 
		existingConstraints instVarNames |
	className := classDefinition key asSymbol.
	existingClass := aPatchSet createdClasses
		at: className
		ifAbsent: [ 
			aPatchSet tempSymbols
				at: className
				ifAbsent: [ self error: 'Cannot find class to update constraints for.' ] ].
	existingConstraintsMap := Dictionary new.
	existingVaryingConstraint := existingClass _varyingConstraint.
	instVarNames := existingClass allInstVarNames.
	existingConstraints := [ existingClass _constraints ] on: Deprecated do: [:ex | ex resume ].
	1 to: existingConstraints size do: [:index |
		existingConstraintsMap at: (instVarNames at: index) put: (existingConstraints at: index ) ].
	theConstraints := self _gemStoneConstraintsFrom:	classDefinition gs_constraints.
	theConstraintsMap := Dictionary new.
	theVaryingConstraint := Object.
	theConstraints do: [:arrayOrVaryingConstraintClass |
		arrayOrVaryingConstraintClass _isArray
			ifTrue: [ theConstraintsMap at: (arrayOrVaryingConstraintClass at: 1) put: (arrayOrVaryingConstraintClass at: 2) ]
			ifFalse: [ theVaryingConstraint := arrayOrVaryingConstraintClass ] ].
	keys := existingConstraintsMap keys copy.
	keys addAll: theConstraintsMap keys.
	keys do: [:key | 
		| existingConstraint theConstraint |
		existingConstraint := existingConstraintsMap at: key ifAbsent: [].
		theConstraint := theConstraintsMap at: key ifAbsent: [].
		existingConstraint == theConstraint
			ifFalse: [ 
				| instVarString |
				instVarString := key asString.
				existingConstraint == nil
					ifTrue: [ 
						"add theConstraint" 
						existingClass _rwInstVar: instVarString constrainTo: theConstraint ]
					ifFalse: [ 
						theConstraint == nil
							ifTrue: [ 
								"remove the constraint" 
								existingClass _rwInstVar: instVarString constrainTo: Object ]
							ifFalse: [
								"change the value of the constraint"
                                existingClass _rwInstVar: instVarString constrainTo: theConstraint ] ] ] ].
	existingVaryingConstraint == theVaryingConstraint
		ifFalse: [
			"change the varying constraint"
			[ existingClass _setVaryingConstraint: theVaryingConstraint] on: Deprecated do: [:ex | ex resume ] ].
	aSymbolDictionaryRegistry updateClassProperties: existingClass implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
%

! Class implementation for 'RwGsClassDeletionSymbolDictPatch'

!		Class methods for 'RwGsClassDeletionSymbolDictPatch'

category: 'instance creation'
classmethod: RwGsClassDeletionSymbolDictPatch
for: aClassDefinition

	^self new classDefinition: aClassDefinition
%

!		Instance methods for 'RwGsClassDeletionSymbolDictPatch'

category: 'actions'
method: RwGsClassDeletionSymbolDictPatch
addToNewClassesByName: aDictionary

	"noop"

	
%

category: 'deleting'
method: RwGsClassDeletionSymbolDictPatch
deleteClassFromSystem

	self symbolDictionaryRegistry deleteClassNamedFromPackage: self className implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'accessing'
method: RwGsClassDeletionSymbolDictPatch
symbolDictionaryFor: aPackageName

	"because this is a deletion, we can look up the symbol dictionariy directly"

	| className class | 
	className := self classDefinition name.
	class := Rowan globalNamed: className.
	Rowan image 
		loadedClassAndSymbolDicitonaryForClass: class 
		ifPresent: [:symDict :loadedClass | ^symDict ]
		ifAbsent: [ self error: 'No symbol dictionary found for the class ', className printString ].
%

! Class implementation for 'RwGsClassExtensionSymbolDictPatch'

!		Instance methods for 'RwGsClassExtensionSymbolDictPatch'

category: 'actions'
method: RwGsClassExtensionSymbolDictPatch
installClassExtensionInSystem

	"The class must already exist.
        Create or update the LoadedClassExtension for the extended class."

	(self projectDefinition
		useSessionMethodsForExtensionsForPackageNamed: self packageName)
		ifTrue: [ | resolved |
			((resolved := GsCurrentSession currentSession symbolList objectNamed: self className asSymbol) notNil and: [resolved isBehavior and: [ resolved isMeta not ]])
				ifFalse: [ 
					self
						error:
							'The extension class named ' , self className printString , ' cannot be found.' ] ]
		ifFalse: [ 
			self symbolDictionaryRegistry
				ensureExtensionClassNamed: self className
				existsForPackageNamed: self packageName
				implementationClass: RwGsSymbolDictionaryRegistry_Implementation ]
%

! Class implementation for 'RwGsClassPropertiesSymDictPatch'

!		Instance methods for 'RwGsClassPropertiesSymDictPatch'

category: 'actions'
method: RwGsClassPropertiesSymDictPatch
addToNewClassesByName: aDictionary

	"noop"

	
%

category: 'installing'
method: RwGsClassPropertiesSymDictPatch
installPropertiesPatchFor: aPatchSet

	self installPropertiesPatchFor: aPatchSet registry: self symbolDictionaryRegistry
%

category: 'installing'
method: RwGsClassPropertiesSymDictPatch
installPropertiesPatchFor: aPatchSet registry: aSymbolDictionaryRegistry

	" update class and update loadedClass with new properties"

	| className existingClass createdClass |
	className := classDefinition key asSymbol.
	existingClass := aPatchSet createdClasses
		at: className
		ifAbsent: [ 
			aPatchSet tempSymbols
				at: className
				ifAbsent: [ self error: 'Cannot find class to update properties for.' ] ].
	createdClass := self createClassFor: aPatchSet.	"use createClassFor:, but not expected to create new class version"
	createdClass == existingClass
		ifFalse: [ 
			self
				error:
					'internal error - class changed during class property update ... should have been a class versioning patch' ].
	aSymbolDictionaryRegistry updateClassProperties: existingClass implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

! Class implementation for 'RwGsClassSymbolDictionaryMoveSymDictPatch'

!		Class methods for 'RwGsClassSymbolDictionaryMoveSymDictPatch'

category: 'instance creation'
classmethod: RwGsClassSymbolDictionaryMoveSymDictPatch
for: aClassModification inPackage: aPackageDefinition

	^ self new
		classModification: aClassModification;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassSymbolDictionaryMoveSymDictPatch'

category: 'accessing'
method: RwGsClassSymbolDictionaryMoveSymDictPatch
classModification

	^classModification
%

category: 'accessing'
method: RwGsClassSymbolDictionaryMoveSymDictPatch
classModification: aClassModification

	classModification := aClassModification.
	classDefinition := classModification after
%

category: 'installing'
method: RwGsClassSymbolDictionaryMoveSymDictPatch
installSymbolDictionaryPatchFor: aPatchSet

	| before originalSymbolDictionary assoc newSymbolDictionary theClass registry |
	theClass := Rowan globalNamed: classDefinition name.
	before := classModification before.
	originalSymbolDictionary := Rowan globalNamed: before gs_symbolDictionary.
	assoc := originalSymbolDictionary associationAt: before key asSymbol.
	registry := originalSymbolDictionary rowanSymbolDictionaryRegistry.
	registry deleteClassNamedFromPackage: classDefinition name implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	newSymbolDictionary := Rowan globalNamed: (projectDefinition symbolDictNameForPackageNamed: packageDefinition name) .
	registry := newSymbolDictionary rowanSymbolDictionaryRegistry.
	registry 
		addClassAssociation: assoc 
			forClass: theClass 
			toPackageNamed: packageDefinition name
			implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'installing'
method: RwGsClassSymbolDictionaryMoveSymDictPatch
installSymbolDictionaryPatchFor: aPatchSet classMove: aClassMove

	RwGsSymbolDictionaryRegistry_Implementation moveClassFor: aClassMove
%

! Class implementation for 'RwGsClassVariableChangeSymbolDictPatch'

!		Instance methods for 'RwGsClassVariableChangeSymbolDictPatch'

category: 'actions'
method: RwGsClassVariableChangeSymbolDictPatch
createClassFor: aPatchSet

	"we're using createClassFor: to apply the class variable modifications. not expected to 
		create a new class version"

	| oldClassVersion newClassVersion |
	oldClassVersion := self oldClassVersion.
	newClassVersion := self privateCreateClassFor: aPatchSet.
	oldClassVersion == newClassVersion
		ifFalse: [ 
			self
				error:
					'internal error - unexpected new class version for class variable modification' ].
	^ oldClassVersion
%

category: 'installing'
method: RwGsClassVariableChangeSymbolDictPatch
installPropertiesPatchFor: aPatchSet

	self installPropertiesPatchFor: aPatchSet registry: self symbolDictionaryRegistry
%

category: 'installing'
method: RwGsClassVariableChangeSymbolDictPatch
installPropertiesPatchFor: aPatchSet registry: aSymbolDictionaryRegistry

	" update class and update loadedClass with new properties"

	| className existingClass |
	className := classDefinition key asSymbol.
	existingClass := aPatchSet createdClasses
		at: className
		ifAbsent: [ 
			aPatchSet tempSymbols
				at: className
				ifAbsent: [ self error: 'Cannot find class to update properties for.' ] ].
	aSymbolDictionaryRegistry updateClassProperties: existingClass  implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

! Class implementation for 'RwGsClassVersioningPatch'

!		Class methods for 'RwGsClassVersioningPatch'

category: 'patching'
classmethod: RwGsClassVersioningPatch
addPatchedClassModification: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet

	"Need to decide whether the patches in aClassModification warrant a new class version or 
	 simple property changes."

	^ self new
		addPatchedClassModification: aClassModification
		inPackage: aPackageDefinition
		inProject: aProjectDefinition
		toPatchSet: aRwGsPatchSet
%

category: 'patching'
classmethod: RwGsClassVersioningPatch
addPatchedClassModificationForcingNewClassVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet

	"Need to decide whether the patches in aClassModification warrant a new class version or 
	 simple property changes."

	^ self new
		addPatchedClassModificationForcingNewClassVersion: aClassModification
		inPackage: aPackageDefinition
		inProject: aProjectDefinition
		toPatchSet: aRwGsPatchSet
%

category: 'instance creation'
classmethod: RwGsClassVersioningPatch
for: aClassModification inPackage: aPackageDefinition

	^ self new
		classModification: aClassModification;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassVersioningPatch'

category: 'patching'
method: RwGsClassVersioningPatch
addPatchedClassModification: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet

	"Need to decide whether the patches in aClassModification warrant a new class version or 
	 simple property changes."

	| dict existingClass newFormat afterClassDefinition beforeClassDefinition newSuperclassAssoc afterSymDict beforeSymDict |
	packageDefinition := aPackageDefinition.
	projectDefinition := aProjectDefinition.
	afterClassDefinition := aClassModification after.
	beforeClassDefinition := aClassModification before.
	(newSuperclassAssoc := self resolveName: afterClassDefinition superclassName)
		ifNil: [
			"new superclass does not currently exist ... so it will be a new class, which means a new class version, guaranteed"
			aRwGsPatchSet
				addPatchedClassNewVersion: aClassModification
				inPackage: aPackageDefinition
				inProject: aProjectDefinition.
			^ self ].
	dict := Rowan image symbolList objectNamed: beforeClassDefinition gs_symbolDictionary.
	existingClass := dict
		at: beforeClassDefinition name asSymbol
		ifAbsent: [ self error: 'Internal error. Attempt to modify a class whose name is not bound.' ].
	newFormat := self
		_classFormat: existingClass superclass format
		forSubclassType: afterClassDefinition classType.
	afterSymDict := self symbolDictionary name asString.
	beforeSymDict := beforeClassDefinition gs_symbolDictionary.
	beforeSymDict ~= afterSymDict
		ifTrue: [
			aRwGsPatchSet
				addPatchedClassSymbolDictionaryMove: aClassModification
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ].
	self
		_newSubclassWithSuperclass: newSuperclassAssoc value
		isEquivalentToSubclass: existingClass
		newOpts: (afterClassDefinition gs_options collect: [:each | each asSymbol])
		newFormat: newFormat
		newInstVars: afterClassDefinition instVarNames
		newClassInstVars: afterClassDefinition classInstVarNames
		newPools: afterClassDefinition poolDictionaryNames
		newClassVars: afterClassDefinition classVarNames
		newConstraints: (self _gemStoneConstraintsFrom: afterClassDefinition gs_constraints)
		patchedClassProperties: [
			aClassModification propertiesModification isEmpty
				ifFalse: [ 
					aRwGsPatchSet
						addPatchedClassProperties: afterClassDefinition
						inPackage: aPackageDefinition
						inProject: aProjectDefinition ] ]
		patchedConstraints: [
			aRwGsPatchSet
						addPatchedClassConstraints: afterClassDefinition
						inPackage: aPackageDefinition
						inProject: aProjectDefinition ]
		patchedClassVars: [ 
			aRwGsPatchSet
				addPatchedClassClassVariables: afterClassDefinition
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ]
		patchedClassNewVersions: [ 
			aRwGsPatchSet
				addPatchedClassNewVersion: aClassModification
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ]
%

category: 'patching'
method: RwGsClassVersioningPatch
addPatchedClassModificationForcingNewClassVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet

	"Uncontitionally create a new class version"

	| dict existingClass beforeClassDefinition |
	packageDefinition := aPackageDefinition.
	projectDefinition := aProjectDefinition.
	beforeClassDefinition := aClassModification before.
	dict := Rowan image symbolList objectNamed: beforeClassDefinition gs_symbolDictionary.
	existingClass := dict
		at: beforeClassDefinition name asSymbol
		ifAbsent: [ self error: 'Internal error. Attempt to modify a class whose name is not bound.' ].
	aRwGsPatchSet
		addPatchedClassNewVersion: aClassModification
		inPackage: aPackageDefinition
		inProject: aProjectDefinition
%

category: 'accessing'
method: RwGsClassVersioningPatch
classModification: aClassModification

	classModification := aClassModification.
	classDefinition := classModification after
%

category: 'actions'
method: RwGsClassVersioningPatch
createClassFor: aPatchSet
	"we're using createClassFor: to apply the class modifications to the existing class
	oldClassVersion and produce a new class version"

	oldClassVersion := self oldClassVersion.
	newClassVersion := super createClassFor: aPatchSet.
	symbolAssociation := self resolveName: newClassVersion name.
	^ newClassVersion
%

category: 'accessing'
method: RwGsClassVersioningPatch
oldClassDefinition

	^ classModification before
%

category: 'versioning'
method: RwGsClassVersioningPatch
oldClassVersion

	"The old version is what is currently bound to the old class definition's name."

	^ (self resolveName: self oldClassDefinition key) value
%

category: 'actions'
method: RwGsClassVersioningPatch
updateSymbolAssociation

	oldClassVersion == newClassVersion 
		ifTrue: [ 
			"no newClassVersion created when property modifications applied .. not a problem"
			^self ].
	symbolAssociation value: newClassVersion
%

category: 'private'
method: RwGsClassVersioningPatch
_newSubclassWithSuperclass: newSuperclass isEquivalentToSubclass: oldClass 
newOpts: optionsArray newFormat: theFormat newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars 
newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars newConstraints: aConstraint
patchedClassProperties: patchedClassPropertiesBlock 
patchedConstraints: patchedConstraintsBlock 
patchedClassVars: patchedClassVarsBlock 
patchedClassNewVersions: patchedClassNewVersionsBlock

	" based on Class>>_equivalentSubclass:superCls:name:newOpts:newFormat:newInstVars:newClassInstVars:newPools:newClassVars:inDict:isKernel: and ultimately needs to be rolled back into base, so that class creation and Rowan use the same new class version rules.
"

	"Class>>_equivalentSubclass:... has unwanted side effects"

	"squeezed down to the bare minimum"

	"oldClass is equivalent to the subclass that would be created using
 the other arguments if 
     instVar names match exactly ,
   and class instVar names match exactly ,
   and the classVars in oldClass can be modified to add/remove Associations 
     to match anArrayOfClassVars ,
   and pool dictionaries match exactly

  With respect to options and format, oldClass is equivalent if
    The state of format bits dbTransient, instancesNonPersistent, instancesInvariant  
     match exactly ,
    and subclassesDisallowed cannot be set in the new subclass if it not set in oldClass ,
    and modifiable  cannot be set if it is not set in oldClass  ,
    and  (SELF_CAN_BE_SPECIAL, NSC_DUPLICATES, INDEXABLE, IMPLEMENTATION, NO_STRUCT_UPDATE bits)
        of the formats must match exactly.
"

	| supr opts ivs civs poolds cvars cons cvarsPatched |
	cvarsPatched := (anArrayOfClassVars asSortedCollection = oldClass classVarNames asSortedCollection) not.
	self
		_newSubclassWithSuperclass: newSuperclass
		isEquivalentToSubclass: oldClass
		newOpts: optionsArray
		newFormat: theFormat
		newInstVars: anArrayOfInstvarNames
		newClassInstVars: anArrayOfClassInstVars
		newPools: anArrayOfPoolDicts
		newClassVars: anArrayOfClassVars
		newConstraints: aConstraint
		suprBlock: [ :bool | supr := bool not ]
		optsBlock: [ :bool | opts := bool not ]
		ivsBlock: [ :bool | ivs := bool not ]
		civsBlock: [ :bool | civs := bool not ]
		poolsBlock: [ :bool | poolds := bool not ]
		cvarsBlock: [ :bool | cvars := bool not ]
		consBlock:  [ :bool | cons := bool not ].
	(supr or: [ opts or: [ ivs or: [ civs or: [ poolds or: [cvars ] ] ] ] ])
		ifTrue: [ 
			"new class version means that class vars will be patched (for free) before methods compiled"
			patchedClassNewVersionsBlock value.
			^ self ].
	cvarsPatched
		ifTrue: [ 
			"have to patch class variables BEFORE methods are compiled"
			patchedClassVarsBlock value ].
	cons
		ifTrue: [
			"constraint changes are added in separate step after all classes have been created"
			patchedConstraintsBlock value ].
	"class property changes that do not affect method compilation"
	patchedClassPropertiesBlock value
%

category: 'private'
method: RwGsClassVersioningPatch
_newSubclassWithSuperclass: newSuperclass isEquivalentToSubclass: oldClass 
newOpts: optionsArray newFormat: theFormat newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars 
newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars newConstraints: aConstraint 
suprBlock: suprBlock optsBlock: optsBlock ivsBlock: ivsBlock civsBlock: civsBlock poolsBlock: poolsBlock cvarsBlock: cvarsBlock consBlock: consBlock

	" based on Class>>_equivalentSubclass:superCls:name:newOpts:newFormat:newInstVars:newClassInstVars:newPools:newClassVars:inDict:isKernel: and ultimately needs to be rolled back into base, so that class creation and Rowan use the same new class version rules.
"

	"Class>>_equivalentSubclass:... has unwanted side effects"

	"squeezed down to the bare minimum"

	"oldClass is equivalent to the subclass that would be created using
 the other arguments if 
     instVar names match exactly ,
   and class instVar names match exactly ,
   and the classVars in oldClass can be modified to add/remove Associations 
     to match anArrayOfClassVars ,
   and pool dictionaries match exactly

  With respect to options and format, oldClass is equivalent if
    The state of format bits dbTransient, instancesNonPersistent, instancesInvariant  
     match exactly ,
    and subclassesDisallowed cannot be set in the new subclass if it not set in oldClass ,
    and modifiable  cannot be set if it is not set in oldClass  ,
    and  (SELF_CAN_BE_SPECIAL, NSC_DUPLICATES, INDEXABLE, IMPLEMENTATION, NO_STRUCT_UPDATE bits)
        of the formats must match exactly.
"

	| fmtArr |
	fmtArr := newSuperclass _validateOptions: optionsArray withFormat: theFormat newClassName: oldClass name asString.
	(oldClass isKindOf: Class)
		ifFalse: [ oldClass _validateClass: Class ].
	suprBlock value: oldClass superClass == newSuperclass.
	optsBlock value: (oldClass _optionsChangableTo: fmtArr).
	ivsBlock value: (oldClass _instVarsEqual: anArrayOfInstvarNames).
	civsBlock value: (oldClass class _instVarsEqual: anArrayOfClassInstVars).
	poolsBlock value: (oldClass _poolDictsEqual: anArrayOfPoolDicts).
	cvarsBlock value: (oldClass _classVarsChangableTo: anArrayOfClassVars copy).
	consBlock value: (aConstraint size = 0 or: [oldClass _constraintsEqual: aConstraint ])
%

! Class implementation for 'RwGsClassVersioningSymbolDictPatch'

!		Class methods for 'RwGsClassVersioningSymbolDictPatch'

category: 'instance creation'
classmethod: RwGsClassVersioningSymbolDictPatch
for: aClassModification inPackage: aPackageDefinition

	^ self new
		classModification: aClassModification;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassVersioningSymbolDictPatch'

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatch
classModification: aClassModification

	classModification := aClassModification.
	classDefinition := classModification after
%

category: 'actions'
method: RwGsClassVersioningSymbolDictPatch
createClassFor: aPatchSet

	"we're using createClassFor: to apply the class modifications to the existing class
	oldClassVersion and produce a new class version"

	oldClassVersion := self oldClassVersion.	"grab the class version BEFORE creating newClassVersion ...it may be needed later"
	newClassVersion := super createClassFor: aPatchSet.
	symbolAssociation := self resolveName: newClassVersion name.
	^ newClassVersion
%

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatch
existingSymbolDictionary
	"answer the current symbol dictionary for the class ... before being (potentially) moved to a different symbolDictionary"

	| symDictName symDict |
	symDictName := classModification before gs_symbolDictionary.
	symDict := GsCurrentSession currentSession symbolList objectNamed: symDictName asSymbol.
	symDict
		ifNotNil: [ symDict rowanSymbolDictionaryRegistry ifNotNil: [ ^ symDict ] ].
	^ Rowan image newOrExistingSymbolDictionaryNamed: symDictName
%

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatch
existingSymbolDictionaryRegistry

	^ self existingSymbolDictionary rowanSymbolDictionaryRegistry
%

category: 'patching'
method: RwGsClassVersioningSymbolDictPatch
installNewClassVersionInSystem

	"Install the new class association in the symbolAssociation for the class.
	 Update the LoadedClass with properties for the new classversion."

	self symbolDictionaryRegistry addNewClassVersionToAssociation: newClassVersion implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'patching'
method: RwGsClassVersioningSymbolDictPatch
moveNewClassVersionInSystem: aClassMove

	"Move the class association for the class.
	 Update the LoadedClass with properties for the new classversion."

	| theRegistry |
	theRegistry := (self symbolDictionaryFor: aClassMove packageAfter name projectDefinition: aClassMove projectAfter)
		rowanSymbolDictionaryRegistry.

	theRegistry addNewClassVersionToAssociation: newClassVersion 
			implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'versioning'
method: RwGsClassVersioningSymbolDictPatch
newClassVersion

	^ newClassVersion
%

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatch
oldClassDefinition

	^ classModification before
%

category: 'versioning'
method: RwGsClassVersioningSymbolDictPatch
oldClassVersion

	"The old version is what is currently bound to the old class definition's name."

	oldClassVersion ifNotNil: [ ^ oldClassVersion ].
	^ (self resolveName: self oldClassDefinition key) value
%

category: 'new version support'
method: RwGsClassVersioningSymbolDictPatch
updateNewClassVersionPatchesForExtensionsIn: aProjectSetModification patchSet: aPatchSet

	| className class |
	className := classDefinition name.
	class := Rowan globalNamed: className.
	self
		_updateNewClassVersionPatchesForClass: class
		in: aProjectSetModification
		patchSet: aPatchSet
%

category: 'new version support'
method: RwGsClassVersioningSymbolDictPatch
updateNewClassVersionPatchesForSubclassesIn: aProjectSetModification patchSet: patchSet

	| subclassesOfClassWithNewVersions existingClass classesWithNewVersions |
	existingClass := self oldClassVersion.
	subclassesOfClassWithNewVersions := IdentitySet new.
	subclassesOfClassWithNewVersions
		addAll: ((ClassOrganizer new allSubclassesOf: existingClass) reject: [:class | (Rowan image loadedClassForClass: class ifAbsent: []) isNil ]).
	classesWithNewVersions := patchSet classesWithNewVersions
		collect: [ :patch | patch oldClassVersion ].
	subclassesOfClassWithNewVersions removeAllPresent: classesWithNewVersions.
	subclassesOfClassWithNewVersions
		do: [ :subclass | 
			| loadedClass loadedPackage loadedProject loadedClassDefinition subclassName newVersionClassModification 
				projectModification packageModification classesModification classesModified |
			subclassName := subclass name asString.
			loadedClass := Rowan image loadedClassNamed: subclassName.
			loadedClassDefinition := loadedClass asDefinition.
			loadedPackage := loadedClass loadedPackage.
			loadedProject := loadedClass loadedProject.
			newVersionClassModification := loadedClassDefinition
				compareAgainstBaseForcingNewClassVersion: loadedClassDefinition.

			projectModification := aProjectSetModification elementsModified 
				at: loadedProject name 
				ifAbsentPut: [
					| def |
					"arrange for anew project modification to be added"
					def := loadedProject asDefinition.
					(RwProjectModification before: def after: def)
						propertiesModification: RwPropertiesModification new;
						packagesModification: RwPackagesModification new;
						yourself ].
			packageModification := projectModification packagesModification elementsModified 
					at: loadedPackage name 
					ifAbsentPut: [  
						| def |
						"arrange for a new package modification to be added"
						def := loadedPackage asDefinition.
						(RwPackageModification before: def after: def)
							classesModification: RwClassesModification new;
							classExtensionsModification: RwClassExtensionsModification new;
							yourself  ].
			classesModification := packageModification classesModification.
			classesModified := classesModification elementsModified.
			classesModification isEmpty
				ifTrue: [ 
					classesModified at: subclassName put: newVersionClassModification.
					newVersionClassModification
						mergeForNewClassVersionWith: newVersionClassModification ]
				ifFalse: [ 
					(classesModified at: subclassName ifAbsent: [  ])
						ifNil: [
							classesModified at: subclassName put: newVersionClassModification.
							newVersionClassModification
								mergeForNewClassVersionWith: newVersionClassModification ]
						ifNotNil: [ :existingClassModification | 
							existingClassModification isDeletion
								ifTrue: [ 
									"a deletion is not unexpected ... "
									]
								ifFalse: [
									newVersionClassModification mergeForExistingClassWith: existingClassModification.
									classesModified at: subclassName put: newVersionClassModification ] ] ] .
			self
				_updateNewClassVersionPatchesForClass: subclass
				in: aProjectSetModification
				patchSet: patchSet ]
%

category: 'new version support'
method: RwGsClassVersioningSymbolDictPatch
updatePatchesForNewClassVersion: aProjectSetModification patchSet: patchSet

	| existingClass loadedClass loadedPackageName loadedClassDefinition newVersionClassModification existingClassName movedDeletedMap |
	movedDeletedMap := Dictionary new.
	patchSet movedClassesMap keysAndValuesDo: [:className :classMove | movedDeletedMap at: className put: classMove ].
	existingClass := self oldClassVersion.
	existingClassName := existingClass name asString.

	loadedClass := self existingSymbolDictionaryRegistry existingForClass: existingClass.
	loadedClassDefinition := loadedClass asDefinition.
	loadedPackageName := loadedClass loadedPackage name.

	newVersionClassModification := self classDefinition
		compareAgainstBaseForNewClassVersion: loadedClassDefinition.
	newVersionClassModification isEmpty
		ifFalse: [ 
			"only newVersionClassModification with substance need further processing"
			aProjectSetModification
				classesModificationAndPackageModificationAndProjectModificationDo: [ :classesModification :packageModification | 
					classesModification isEmpty
						ifFalse: [ 
							| classesModified |
							classesModified := classesModification elementsModified.
							(classesModified at: existingClassName ifAbsent: [  ])
								ifNil: [ "not unexpected ... if there are multiple packages involved" ]
								ifNotNil: [ :existingClassModification | 
									| deleteClassModification |
									deleteClassModification := false.
									(movedDeletedMap at: existingClassName ifAbsent: []) ifNotNil: [:classMove |
										deleteClassModification := classMove packageBefore name = packageModification after name ].
									deleteClassModification
										ifTrue: [classesModified removeKey: existingClassName]
										ifFalse: [
											newVersionClassModification mergeForExistingClassWith: existingClassModification.
											classesModified at: existingClassName put: newVersionClassModification ] ] ] ] ]
%

category: 'private'
method: RwGsClassVersioningSymbolDictPatch
_createMethodExtensionModificationForNewVersionOfClassNamed: className isMeta: isMeta loadedMethod: loadedMethod projectSetModification: aProjectSetModification

	| loadedProject loadedPackage loadedClassExtension projectModification packageModification 
		classExtensionModification methodsModification methodDef source sourceModification modification
		afterMethodDef beforeMethodDef |
	loadedClassExtension := loadedMethod loadedClass.
	loadedPackage := loadedMethod loadedPackage.
	loadedProject := loadedMethod loadedProject.
	projectModification := aProjectSetModification elementsModified
		at: loadedProject name
		ifAbsentPut: [
			| def |
			def := loadedProject asDefinition.
			(RwProjectModification before: def after: def)
				propertiesModification: RwPropertiesModification new;
				packagesModification: RwPackagesModification new;
				yourself ].
	packageModification := projectModification packagesModification
		elementsModified
		at: loadedPackage name
		ifAbsentPut: [ 
			| def |
			"arrange for a new package to be added"
			def := loadedPackage asDefinition.
			(RwPackageModification before: def after: def)
				classesModification: RwClassesModification new;
				classExtensionsModification: RwClassExtensionsModification new;
				yourself ].
	classExtensionModification := packageModification classExtensionsModification
		elementsModified
		at: className
		ifAbsentPut: [ 
			| def |
			def := (loadedPackage loadedClassExtensions at: className) asDefinition.
			(RwClassExtensionModification
				before: RwClassExtensionDefinition new
				after: def)
				instanceMethodsModification:
						(RwExtensionMethodsModification extendedClassName: className);
				classMethodsModification:
						(RwExtensionMethodsModification extendedClassName: className);
				yourself ].
	methodsModification := isMeta
		ifTrue: [ classExtensionModification classMethodsModification elementsModified ]
		ifFalse: [ classExtensionModification instanceMethodsModification elementsModified ].
	(methodsModification at: loadedMethod selector ifAbsent: [  ])
		ifNil: [
			afterMethodDef := beforeMethodDef := methodDef := loadedMethod asDefinition.
			source := methodDef source.
			sourceModification := RwSourceModification new
				addElementModification:
						(RwUnconditionalPropertyModification
								key: 'source'
								oldValue: source
								newValue: source);
				yourself.
			modification := (RwExtensionMethodModificationForNewClassVersion
				before: beforeMethodDef
				after: afterMethodDef)
				isMeta: isMeta;
				classDefinition: loadedClassExtension asDefinition;
				propertiesModification: RwPropertiesModification new;
				sourceModification: sourceModification;
				yourself ]
		ifNotNil: [:theMethodModification |
			modification := (RwExtensionMethodModificationForNewClassVersion
				before: theMethodModification before
				after: theMethodModification after)
				isMeta: isMeta;
				classDefinition: loadedClassExtension asDefinition;
				propertiesModification: theMethodModification propertiesModification;
				sourceModification: theMethodModification sourceModification;
				yourself ].

	methodsModification at: loadedMethod selector put: modification
%

category: 'private'
method: RwGsClassVersioningSymbolDictPatch
_updateNewClassVersionPatchesForClass: class in: aProjectSetModification patchSet: aPatchSet

	| className extensionMap emptyDict |
	className := class name asString.
	extensionMap := Dictionary new.
	emptyDict := Dictionary new.
	(Rowan image loadedClassExtensionsForClass: class)
		do: [ :loadedClassExtension | 
			| dict |
			dict := extensionMap at: className ifAbsentPut: [ Dictionary new ].
			loadedClassExtension
				loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClass :loadedMethod | 
					(dict at: 'instance' ifAbsentPut: [ Dictionary new ])
						at: loadedMethod selector
						put: loadedMethod ]
				loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClass :loadedMethod | 
					(dict at: 'class' ifAbsentPut: [ Dictionary new ])
						at: loadedMethod selector
						put: loadedMethod ] ].
	extensionMap isEmpty
		ifTrue: [ ^ self ].
	aPatchSet
		allPatchesAffectingLiveMethodsDo: [ :patch | 
			| methodsDict selectorDict |
			methodsDict := extensionMap
				at: patch classDefinition name
				ifAbsent: [ emptyDict ].
			selectorDict := patch isMeta
				ifTrue: [ methodsDict at: 'class' ifAbsent: [ emptyDict ] ]
				ifFalse: [ methodsDict at: 'instance' ifAbsent: [ emptyDict ] ] ]
		deletedMethodsDo: [ :patch | 
			| methodsDict selectorDict |
			methodsDict := extensionMap
				at: patch classDefinition name
				ifAbsent: [ emptyDict ].
			selectorDict := patch isMeta
				ifTrue: [ methodsDict at: 'class' ifAbsent: [ emptyDict ] ]
				ifFalse: [ methodsDict at: 'instance' ifAbsent: [ emptyDict ] ].
			selectorDict removeKey: patch methodDefinition selector ifAbsent: [  ] ].
	extensionMap
		valuesDo: [ :methodsDict | 
			(methodsDict at: 'instance' ifAbsent: [ emptyDict ])
				valuesDo: [ :loadedMethod | 
					self
						_createMethodExtensionModificationForNewVersionOfClassNamed: className
						isMeta: false
						loadedMethod: loadedMethod
						projectSetModification: aProjectSetModification ].
			(methodsDict at: 'class' ifAbsent: [ emptyDict ])
				valuesDo: [ :loadedMethod | 
					self
						_createMethodExtensionModificationForNewVersionOfClassNamed: className
						isMeta: true
						loadedMethod: loadedMethod
						projectSetModification: aProjectSetModification ] ]
%

! Class implementation for 'RwGsMethodPatch'

!		Class methods for 'RwGsMethodPatch'

category: 'instance creation'
classmethod: RwGsMethodPatch
forMethod: aMethodDefinition isMeta: isMeta inClass: aClassDefinition inPackage: aPackageDefinition

	^(self new)
		methodDefinition: aMethodDefinition;
		isMeta: isMeta;
		classDefinition: aClassDefinition;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsMethodPatch'

category: 'accessing'
method: RwGsMethodPatch
behavior

	^ behavior
%

category: 'accessing'
method: RwGsMethodPatch
classDefinition

	^ classDefinition
%

category: 'accessing'
method: RwGsMethodPatch
classDefinition: newValue
	classDefinition := newValue
%

category: 'accessing'
method: RwGsMethodPatch
className

	^ self classDefinition key
%

category: 'accessing'
method: RwGsMethodPatch
compiledMethod

	^ compiledMethod
		ifNil: [ 
			| methodDictionary |
			methodDictionary := (behavior persistentMethodDictForEnv: 0 ) ifNil:[ Dictionary new ].
			selector := methodDefinition selector.
			compiledMethod := methodDictionary
				at: selector
				ifAbsent: [ self error: 'internal error - compiled method not present in method dictionary' ] ]
%

category: 'compiling'
method: RwGsMethodPatch
compileUsingNewClasses: createdClasses andExistingClasses: tempSymbols

	| sourceString symbolList protocol |
	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ self error: 'Class ' , self className printString , ' not found.' ].

	sourceString := methodDefinition source.
	symbolList := SymbolList with: tempSymbols.
	protocol := (methodDefinition propertyAt: 'protocol') asSymbol.
	compiledMethod := behavior
		compileMethod: sourceString
		dictionaries: symbolList
		category: protocol
		intoMethodDict: false "we do not want the compiled method added to the class methodDictionary"
		intoCategories: nil
		intoPragmas: nil
		environmentId: self methodEnvironmentId
%

category: 'initializers'
method: RwGsMethodPatch
isAnInitializer

	"answer true if I represent a class initialization method"

	^ isMeta and: [ selector == #'initialize' ]
%

category: 'accessing'
method: RwGsMethodPatch
isMeta

	^ isMeta
%

category: 'accessing'
method: RwGsMethodPatch
isMeta: newValue
	isMeta := newValue
%

category: 'private'
method: RwGsMethodPatch
loadedClassOrExtensionForMethod

	"The loaded class or extension should already exist."

	| loadedPackage className |
	loadedPackage := Rowan image
		loadedPackageNamed: self packageName
		ifAbsent: [ 
			self
				error: 'Internal error -- attempt to add a method to a nonexistent package.' ].
	className := classDefinition key.
	^ loadedPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- attempt to add a method to a package in which its class is neither defined nor extended.' ]
%

category: 'accessing'
method: RwGsMethodPatch
methodDefinition
	^methodDefinition
%

category: 'accessing'
method: RwGsMethodPatch
methodDefinition: newValue
	methodDefinition := newValue
%

category: 'compiling'
method: RwGsMethodPatch
methodEnvironmentId

	"use the project load spec package properties"

	^ self projectDefinition methodEnvForPackageNamed: self packageName
%

category: 'private-installing'
method: RwGsMethodPatch
packageProtocolName

	"If I'm for an extension method, my protocol in the image may need to be *<packageName>*."

	^ '*' , self packageName
%

category: 'private'
method: RwGsMethodPatch
primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols

	| className class |
	classDefinition key
		ifNil: [ 
			"class is being deleted ... we're done"
			^ self ].
	className := classDefinition key asSymbol.
	class := createdClasses
		at: className
		ifAbsent: [ 
			tempSymbols
				at: className
				ifAbsent: [ 
					"cannot find class ... caller can decide whether or not that is a problem"
					^ self ] ].
	behavior := isMeta
		ifTrue: [ class class ]
		ifFalse: [ class ]
%

category: 'printing'
method: RwGsMethodPatch
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' for ';
		nextPutAll: self className asString.
	isMeta
		ifTrue: [ aStream nextPutAll: ' class' ].
	aStream
		nextPutAll: '>>';
		nextPutAll: methodDefinition key asString
%

category: 'private-installing'
method: RwGsMethodPatch
propertiesProtocolName

	^methodDefinition propertyAt: 'protocol' ifAbsent: ['unknown']
%

category: 'initializers'
method: RwGsMethodPatch
runInitializer

	"execute class initialization methods"

	self isAnInitializer
		ifTrue: [ behavior thisClass initialize ]
%

category: 'accessing'
method: RwGsMethodPatch
selector

	^ selector
%

category: 'private-installing'
method: RwGsMethodPatch
setProtocolTo: protocolString

	| protocolSymbol |
	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [behavior addCategory: protocolSymbol].
	behavior moveMethod: selector toCategory: protocolSymbol
%

! Class implementation for 'RwGsMethodAdditionSymbolDictPatch'

!		Instance methods for 'RwGsMethodAdditionSymbolDictPatch'

category: 'installing'
method: RwGsMethodAdditionSymbolDictPatch
installMethod

	self symbolDictionaryRegistry
		addNewCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

category: 'installing'
method: RwGsMethodAdditionSymbolDictPatch
installMovedMethod: aClassMove newClassVersionPatch: newClassVersionPatch
	"the receiver represents an existing method for a class with a new version that has moved to a new package"

	"the old method in the old class version must be removed from the loaded things in the new registry, since it was moved earlier, 
		then the regular installMethod should be performed --- new version requires that all methods be compiled"

	"https://github.com/dalehenrich/Rowan/issues/316"

	| oldClassVersion oldBehavior theRegistry |
	theRegistry := (self symbolDictionaryFor: aClassMove packageAfter name projectDefinition: aClassMove projectAfter)
		rowanSymbolDictionaryRegistry.

	oldClassVersion := newClassVersionPatch oldClassVersion.
	oldClassVersion ~~ newClassVersionPatch newClassVersion
		ifTrue: [ 
			"only do this work if we truly have a new class version"
			oldBehavior := self isMeta
				ifTrue: [ oldClassVersion class ]
				ifFalse: [ oldClassVersion ].
			(oldBehavior compiledMethodAt: self methodDefinition selector otherwise: nil)
				ifNotNil: [ :oldCompiledMethod |
					"new methods will not be in the old method dictionary"
					(theRegistry methodRegistry
						at: oldCompiledMethod
						ifAbsent: [])
							ifNil: [
								theRegistry
									error:
										'Internal error -- no existing LoadedMethod found for deleted method.' ]
							ifNotNil: [ :oldLoadedMethod | theRegistry methodRegistry removeKey: oldCompiledMethod ] ] ].

	theRegistry
		addNewCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: aClassMove packageAfter name
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodDeletionSymbolDictPatch'

!		Instance methods for 'RwGsMethodDeletionSymbolDictPatch'

category: 'deleting'
method: RwGsMethodDeletionSymbolDictPatch
deleteMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class is being deleted, nothing else to do"
			^ self ].

	self symbolDictionaryRegistry
		deleteMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionSymbolDictPatch
deleteMovedLoadedMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class is being deleted, nothing else to do"
			^ self ].

	self symbolDictionaryRegistry
		deleteMovedLoadedMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionSymbolDictPatch
deleteMovedMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class is being deleted, nothing else to do"
			^ self ].

	self symbolDictionaryRegistry
		deleteMovedMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionSymbolDictPatch
deleteNewVersionMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	"remove the method from deleted things"

	self symbolDictionaryRegistry
		_doDeleteCompiledMethodFromLoadedThings: self compiledMethod
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'initializers'
method: RwGsMethodDeletionSymbolDictPatch
isAnInitializer

	"answer true if I represent a class initialization method"

	^ false
%

category: 'initializers'
method: RwGsMethodDeletionSymbolDictPatch
runInitializer
	"noop"
%

category: 'accessing'
method: RwGsMethodDeletionSymbolDictPatch
symbolDictionary
	"For deleting methods, we have to find the symbol dictionary where the loaded method is currently stored ... "

	^ Rowan image 
			loadedMethodAndSymbolDicitonaryForMethod: self compiledMethod 
			ifPresent: [ :symbolDict :loadedMethod | ^ symbolDict ]
			ifAbsent: [ ^ super symbolDictionary ]
%

! Class implementation for 'RwGsMethodDeletionExtensionSymbolDictPatch'

!		Instance methods for 'RwGsMethodDeletionExtensionSymbolDictPatch'

category: 'accessing'
method: RwGsMethodDeletionExtensionSymbolDictPatch
className

	^ self extendedClassName
%

category: 'accessing'
method: RwGsMethodDeletionExtensionSymbolDictPatch
extendedClassName

   ^extendedClassName
%

category: 'accessing'
method: RwGsMethodDeletionExtensionSymbolDictPatch
extendedClassName: anObject

	extendedClassName := anObject
%

category: 'private'
method: RwGsMethodDeletionExtensionSymbolDictPatch
primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols

	| className class |
	className := extendedClassName asSymbol.
	class := createdClasses
		at: className
		ifAbsent: [ 
			tempSymbols
				at: className
				ifAbsent: [ 
					"class is being deleted ... we're done"
					^ self] ].
	behavior := isMeta
		ifTrue: [ class class ]
		ifFalse: [ class ]
%

! Class implementation for 'RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch'

!		Instance methods for 'RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch'

category: 'accessing'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
compiledMethod

	^ compiledMethod
		ifNil: [ 
			| dictsArray mDict |
			dictsArray := self symbolDictionaryRegistry homeSessionMethods
				methodAndCategoryDictionaryFor: behavior.
			mDict := dictsArray at: 1.
			selector := methodDefinition selector.
			compiledMethod := mDict
				at: selector
				ifAbsent: [ 
					self
						error:
							'internal error - compiled session method not present in method dictionary' ] ]
%

category: 'deleting'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
deleteMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class cannot be found, so the method is already gone"
			^ self ].

	self symbolDictionaryRegistry
		deleteMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
deleteMovedLoadedMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class cannot be found, so the method is already gone"
			^ self ].

	self symbolDictionaryRegistry
		deleteMovedLoadedMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
deleteMovedMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class cannot be found, so the method is already gone"
			^ self ].

	self symbolDictionaryRegistry
		deleteMovedMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
deleteNewVersionMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	"noop for class extension methods"
%

category: 'accessing'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
symbolDictionary

	^self symbolDictionaryFor: self packageName
%

! Class implementation for 'RwGsMethodExtensionSymbolDictPatch'

!		Instance methods for 'RwGsMethodExtensionSymbolDictPatch'

category: 'installing'
method: RwGsMethodExtensionSymbolDictPatch
installMethod

	self symbolDictionaryRegistry
		addExtensionCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: self packageName
		 implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

category: 'installing'
method: RwGsMethodExtensionSymbolDictPatch
installMovedMethod: aMethodMove newClassVersionPatch: newClassVersionPatch
	"the receiver represents an existing method for a class with a new version that has moved to a new package"

	"the old method in the old class version must be removed from the loaded things in the new registry, since it was moved earlier, 
		then the regular installMethod should be performed --- new version requires that all methods be compiled"

	"https://github.com/dalehenrich/Rowan/issues/316"

	| oldClassVersion oldBehavior theRegistry |
	theRegistry := (self symbolDictionaryFor: aMethodMove packageAfter name projectDefinition: aMethodMove projectAfter)
		rowanSymbolDictionaryRegistry.
	oldClassVersion := newClassVersionPatch oldClassVersion.
	oldClassVersion ~~ newClassVersionPatch newClassVersion
		ifTrue: [ 
			"only do this work if we truly have a new class version"
			oldBehavior := self isMeta
				ifTrue: [ oldClassVersion class ]
				ifFalse: [ oldClassVersion ].
			(oldBehavior compiledMethodAt: self methodDefinition selector otherwise: nil)
				ifNotNil: [ :oldCompiledMethod |
					"new methods will not be in the old method dictionary"
					(theRegistry methodRegistry
						at: oldCompiledMethod
						ifAbsent: [])
							ifNil: [
								theRegistry
									error:
										'Internal error -- no existing LoadedMethod found for deleted method.' ]
							ifNotNil: [ :oldLoadedMethod | theRegistry methodRegistry removeKey: oldCompiledMethod ] ] ].

	theRegistry
		addExtensionCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: aMethodMove packageAfter name
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodExtensionSessionMethodSymbolDictPatch'

!		Instance methods for 'RwGsMethodExtensionSessionMethodSymbolDictPatch'

category: 'compiling'
method: RwGsMethodExtensionSessionMethodSymbolDictPatch
compileUsingNewClasses: createdClasses andExistingClasses: tempSymbols

	| sourceString symbolList protocol |
	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ self error: 'Class ' , self className printString , ' not found.' ].

	sourceString := methodDefinition source.
	symbolList := SymbolList with: tempSymbols.
	protocol := (methodDefinition propertyAt: 'protocol') asSymbol.

	methDict := GsMethodDictionary new.
	catDict := GsMethodDictionary new.
	compiledMethod := behavior
		compileMethod: sourceString
		dictionaries: symbolList
		category: protocol
		intoMethodDict: methDict
		intoCategories: catDict
		intoPragmas: pArray
		environmentId: self methodEnvironmentId
%

category: 'installing'
method: RwGsMethodExtensionSessionMethodSymbolDictPatch
installMethod

	"expecting only a single method to be compiled here"

	compiledMethod := self symbolDictionaryRegistry
		addExtensionSessionMethods: methDict
		catDict: catDict
		for: behavior
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation.

	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodPropertiesSymDictPatch'

!		Instance methods for 'RwGsMethodPropertiesSymDictPatch'

category: 'installing'
method: RwGsMethodPropertiesSymDictPatch
installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols

	" update method protocol and update loadedMethod with new compiled method"

	| methodDictionary oldCompiledMethod |
	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ self error: 'Class ' , self className printString , ' not found.' ].

	methodDictionary := (behavior persistentMethodDictForEnv: 0 ) ifNil:[ Dictionary new ].
	selector := methodDefinition selector.
	oldCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			self
				error:
					'Internal error -- no existing CompileMethod found for patched method.' ].

	self symbolDictionaryRegistry
		moveCompiledMethod: oldCompiledMethod
		toProtocol: self propertiesProtocolName
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'initializers'
method: RwGsMethodPropertiesSymDictPatch
isAnInitializer

	"answer true if I represent a class initialization method"

	^ false
%

category: 'initializers'
method: RwGsMethodPropertiesSymDictPatch
runInitializer
	"noop"
%

! Class implementation for 'RwGsMethodExtensionSessionMethodPropertiesSymDictPatch'

!		Instance methods for 'RwGsMethodExtensionSessionMethodPropertiesSymDictPatch'

category: 'installing'
method: RwGsMethodExtensionSessionMethodPropertiesSymDictPatch
installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols

	^ super installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols
%

! Class implementation for 'RwGsMethodSourceSymbolDictPatch'

!		Instance methods for 'RwGsMethodSourceSymbolDictPatch'

category: 'installing'
method: RwGsMethodSourceSymbolDictPatch
installSourcePatch

	" update methodDictionary and update loadedMethod with new compiled method"

	self symbolDictionaryRegistry addRecompiledMethod: compiledMethod implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodExtensionSessionMethodSourceSymbolDictPatch'

!		Instance methods for 'RwGsMethodExtensionSessionMethodSourceSymbolDictPatch'

category: 'installing'
method: RwGsMethodExtensionSessionMethodSourceSymbolDictPatch
installSourcePatch

	" update methodDictionary and update loadedMethod with new compiled method"

	self symbolDictionaryRegistry addRecompiledSessionMethodMethod: compiledMethod implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsPackagePatch'

!		Class methods for 'RwGsPackagePatch'

category: 'instance creation'
classmethod: RwGsPackagePatch
for: aPackageDefinition

	^self new packageDefinition: aPackageDefinition
%

! Class implementation for 'RwGsPackageAdditionSymbolDictPatch'

!		Instance methods for 'RwGsPackageAdditionSymbolDictPatch'

category: 'applying'
method: RwGsPackageAdditionSymbolDictPatch
createLoadedPackage

	| loadedPackage loadedProject |
	loadedPackage := self symbolDictionaryRegistry
		createLoadedPackageFromDefinition: self packageDefinition
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation.

	projectDefinition ifNil: [ ^ self ].

	loadedProject := Rowan image
		loadedProjectNamed: projectDefinition name
		ifAbsent: [ 
			self
				error:
					'expected a loaded project named ' , projectDefinition name printString ].

	loadedProject addLoadedPackage: loadedPackage
%

! Class implementation for 'RwGsPackageDeletionSymbolDictPatch'

!		Instance methods for 'RwGsPackageDeletionSymbolDictPatch'

category: 'deleting'
method: RwGsPackageDeletionSymbolDictPatch
deletePackage

	(Rowan image loadedRegistryForPackageNamed: packageDefinition name)
		deletePackage: packageDefinition name
%

! Class implementation for 'RwGsPackageMoveSymbolDictPatch'

!		Instance methods for 'RwGsPackageMoveSymbolDictPatch'

category: 'moving'
method: RwGsPackageMoveSymbolDictPatch
movePackage

	"Loader already makes sure that the package is created properly, but we do have to make sure that the old package is deleted from it's original location"

	(Rowan image loadedRegistryForPackageNamed: packageDefinition name)
		movePackage: packageDefinition name to: packageDefinition gs_symbolDictionary
%

! Class implementation for 'RwGsProjectPatch'

!		Class methods for 'RwGsProjectPatch'

category: 'instance creation'
classmethod: RwGsProjectPatch
for: aProjectDefinition

	^self new projectDefinition: aProjectDefinition
%

!		Instance methods for 'RwGsProjectPatch'

category: 'applying'
method: RwGsProjectPatch
updateProjectProperties

	| loadedProject |
	loadedProject := Rowan image
		loadedProjectNamed: self projectName
		ifAbsent: [ self error: 'Internal error. Attempt to update unregistered project.' ].
	loadedProject setPropertiesTo: self projectDefinition properties
%

! Class implementation for 'RwGsProjectAdditionPatch'

!		Instance methods for 'RwGsProjectAdditionPatch'

category: 'applying'
method: RwGsProjectAdditionPatch
createLoadedProject

	| projectName existingLoadedProject newLoadedProject |
	projectName := self projectName.
	existingLoadedProject := Rowan image
		loadedProjectNamed: projectName
		ifAbsent: [ nil ].
	existingLoadedProject
		ifNotNil: [ self error: 'Internal error -- Attempt to add a project that exists.' ].
	newLoadedProject := projectDefinition asLoadedSymbolDictProject.
	Rowan image addLoadedProject: newLoadedProject.
	self updateProjectProperties
%

category: 'applying'
method: RwGsProjectAdditionPatch
updateProjectProperties

	"noop - properties updated during createLoadedProject"

	
%

! Class implementation for 'RwGsPatchSet_254'

!		Class methods for 'RwGsPatchSet_254'

category: 'private - method initialization order'
classmethod: RwGsPatchSet_254
methodPatchesInInitializationOrder: methodPatches

	"Returns acollection of the specified methodPatches ordered in superclass order, which is sufficient for initialization order."

	| order toBeOrdered processed aClass patchMap |
	patchMap := IdentityKeyValueDictionary new.
	methodPatches do: [:methodPatch |
		patchMap at: methodPatch behavior thisClass put: methodPatch ].
	toBeOrdered := patchMap keys asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[ (aClass := self _anyElementOf: toBeOrdered ifEmpty: [ nil ]) isNil ]
		whileFalse: [ 
			self
				_orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed ].
  ^ (order collect: [:orderedClass | patchMap at: orderedClass ifAbsent: []]) select: [:patch | patch notNil ]
%

category: 'instance creation'
classmethod: RwGsPatchSet_254
new

	^super new initialize
%

category: 'private - method initialization order'
classmethod: RwGsPatchSet_254
_anyElementOf: aCollection ifEmpty: aBlock
	aCollection do: [ :each | ^ each ].
	^ aBlock value
%

category: 'private - method initialization order'
classmethod: RwGsPatchSet_254
_orderBySuperclass: aClass from: toBeOrdered into: order ignoring: processed
  "Private. Add to 'order', superclasses first, aClass and any of its superclasses 
	that appear in 'toBeOrdered' but do not appear in 'processed'.
	Remove from 'toBeOrdered' any class added to 'ordered'.
	Any class seen, add to 'processed' whether or not added to 'order'."

  | superclass |
  superclass := aClass superclass.
  superclass isNil | (processed includes: superclass)
    ifFalse: [ 
      self
        _orderBySuperclass: superclass
        from: toBeOrdered
        into: order
        ignoring: processed ].
  processed add: aClass.
  (toBeOrdered includes: aClass)
    ifTrue: [ 
      toBeOrdered remove: aClass.
      order add: aClass ]
%

!		Instance methods for 'RwGsPatchSet_254'

category: 'building'
method: RwGsPatchSet_254
addAddedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedClasses
		add:
			((self _classAdditionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'private - applying'
method: RwGsPatchSet_254
addAddedClassesToTempSymbols
	"Just need the names for now, they don't need to resolve to anything in particular."

	addedClasses do: [:patch | 
		| key |
		key :=  patch className asSymbol.
		(tempSymbols includesKey: key) ifTrue: [ self error: 'Encountered an existing association for a new class ', key asString ].
		tempSymbols at: key put: nil ].
%

category: 'building'
method: RwGsPatchSet_254
addAddedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedMethods
		add:
			((self _methodAdditionPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addAddedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedMethods
		add:
			((self _methodAdditionPatchClass
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addAddedPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedPackages
		add:
			((self _packageAdditionPatchClass for: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addAddedProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedProjects
		add: (self _projectAdditionPatchClass for: aProjectDefinition) yourself
%

category: 'private - applying'
method: RwGsPatchSet_254
addAndUpdateLoadedPackages
	"Update the LoadedPackages to reflect the results of this patchSet. Does not update the other loadedThings."

	addedPackages
		do: [:packageAdditionPatch | packageAdditionPatch createLoadedPackage]
%

category: 'private - applying'
method: RwGsPatchSet_254
addAndUpdateLoadedProjects

	"Update the LoadedProjects to reflect the results of this patchSet. Does not update the other loadedThings."

	addedProjects
		do: [ :projectAdditionPatch | projectAdditionPatch createLoadedProject ].
	projectsWithPropertyChanges do: [ :patch | patch updateLoadedProject ]
%

category: 'modification dispatching'
method: RwGsPatchSet_254
addClassModification: aRwClassModification toPatchSetInPackage: aPackage inProject: aProjectDefinition

	"Double dispatch from aRwClassModification ... needed to isolate the loader methods from meaningful changes 
		while updating the loader using the loader"

	aRwClassModification isAddition
		ifTrue: [ 
			"https://github.com/dalehenrich/Rowan/issues/210 - make sure that the added classes are not already loaded
				in a project that is not included in this load"
			(Rowan globalNamed: aRwClassModification after name) ifNotNil: [:global | (RwExistingVisitorAddingExistingClassNotification new classDefinition: aRwClassModification after) signal ].
			self
				addAddedClass: aRwClassModification after
				inPackage: aPackage
				inProject: aProjectDefinition.
			(aRwClassModification propertiesModification elementsModified at: 'gs_constraints' ifAbsent: [])
				ifNotNil: [:constraints |  
					"arrange to add constraints to a newly created class - constraints not created during class creation"
					self 
						addPatchedClassConstraints: aRwClassModification after 
						inPackage: aPackage 
						inProject: aProjectDefinition ] ].
	aRwClassModification isDeletion
		ifTrue: [ 
			self
				addDeletedClass: aRwClassModification before
				inPackage: aPackage
				inProject: aProjectDefinition ].
	aRwClassModification isModification
		ifTrue: [ 
			RwGsClassVersioningPatch
				addPatchedClassModification: aRwClassModification
				inPackage: aPackage
				inProject: aProjectDefinition
				toPatchSet: self.
			(aRwClassModification propertiesModification elementsModified at: 'gs_constraints' ifAbsent: [])
				ifNotNil: [:constraints |  
					"arrange to add constraints to a newly created class - constraints not created during class creation"
					self 
						addPatchedClassConstraints: aRwClassModification after 
						inPackage: aPackage 
						inProject: aProjectDefinition ] ]
%

category: 'building'
method: RwGsPatchSet_254
addClassMove: aRwClassMove

	movedClasses add: aRwClassMove
%

category: 'private - applying'
method: RwGsPatchSet_254
addCreatedClassesAndVersionsTo: newClassesByName

	addedClasses do: [ :patch | patch addToNewClassesByName: newClassesByName ].
	classesWithClassVariableChanges
		do: [ :each | each addToNewClassesByName: newClassesByName ].
	classesWithNewVersions
		do: [ :each | each addToNewClassesByName: newClassesByName ]
%

category: 'building'
method: RwGsPatchSet_254
addDeletedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedClasses
		add:
			((self _classDeletionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addDeletedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			((self _methodDeletionPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addDeletedExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition named: className inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			(((self _methodExtensionDeletionPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				extendedClassName: className;
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addDeletedExtendedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition named: className inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			(((self _methodExtensionDeletionPatchClass: aPackageDefinition key)
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				extendedClassName: className;
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addDeletedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			((self _methodDeletionPatchClass
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addDeletedPackage: packageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedPackages
		add:
			((self _packageDeletionPatchClass for: packageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addExtendedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedClasses
		add:
			((self _classExtensionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedMethods
		add:
			(((self _methodExtensionPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addExtendedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedMethods
		add:
			(((self _methodExtensionPatchClass: aPackageDefinition key)
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'modification dispatching'
method: RwGsPatchSet_254
addForcingNewClassVersionModification: aRwClassModificationForcingNewClassVersion toPatchSetInPackage: aPackage inProject: aProjectDefinition

	"Double dispatch from aRwClassModificationForcingNewClassVersion ... needed to isolate the loader methods from meaningful changes 
		while updating the loader using the loader"

	aRwClassModificationForcingNewClassVersion isAddition
		ifTrue: [ self error: 'unexpected addition for modification forcing new class version' ].
	aRwClassModificationForcingNewClassVersion isDeletion
		ifTrue: [ self error: 'unexpected deletion for modification forcing new class version' ].
	aRwClassModificationForcingNewClassVersion isModification
		ifTrue: [ 
			RwGsClassVersioningPatch
				addPatchedClassModificationForcingNewClassVersion: aRwClassModificationForcingNewClassVersion
				inPackage: aPackage
				inProject: aProjectDefinition
				toPatchSet: self ]
%

category: 'building'
method: RwGsPatchSet_254
addMethodMove: aRwMethodMove

	movedMethods add: aRwMethodMove
%

category: 'building'
method: RwGsPatchSet_254
addMovedPackage: packageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	movedPackages
		add:
			((self _packageMovePatchClass for: packageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassClassVariables: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithClassVariableChanges
		add:
			((self _classVariablePatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassConstraints: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithConstraintChanges
		add:
			((self _classConstraintPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			((self _methodSourcePatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassMethodProperties: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			((self _methodPropertiesPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassNewVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.

	classesWithNewVersions
		add:
			((self _classVersioningPatchClass
				for: aClassModification
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassProperties: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithPropertyChanges
		add:
			((self _classPropertiesPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassSymbolDictionaryMove: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithSymbolDictionaryChanges
		add:
			((self _classSymbolDictionaryMovePatchClass
				for: aClassModification
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			(((self _methodExtensionSourcePatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedExtendedClassMethodProperties: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			(((self _methodExtensionPropertiesPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedExtendedInstanceMethod: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			(((self _methodExtensionSourcePatchClass: aPackageDefinition key)
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedExtendedInstanceMethodProperties: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			(((self _methodExtensionPropertiesPatchClass: aPackageDefinition key)
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedInstanceMethod: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			((self _methodSourcePatchClass
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedInstanceMethodProperties: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			((self _methodPropertiesPatchClass
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'private - applying'
method: RwGsPatchSet_254
allPatchesAffectingLiveMethodsDo: liveMethodsBlock deletedMethodsDo: deletedMethodsBlock

	"Evaluate aBlock with every patch that can affect a method, traverse deletions separately."

	{addedMethods.
	extendedMethods.
	methodsNeedingRecompile} do: [ :patches | patches do: liveMethodsBlock ].
	deletedMethods do: deletedMethodsBlock
%

category: 'private - applying'
method: RwGsPatchSet_254
anyElementOfCollection: aCollection
	"if aCollection is empty, answer nil. Otherwise, answer the first in enumeration order (which is unspecified for unordered collections)."

	aCollection do: [:each | ^each].
	^nil
%

category: 'public'
method: RwGsPatchSet_254
apply

	"Apply the changes I represent to the running image."
(UserGlobals at: #ConditionalHalt ifAbsent: [ false ]) ifTrue: [ self halt ].
	self
		setupForApply;
		removeDeletedClassesFromTempSymbols;
		addAddedClassesToTempSymbols;
		recordCompiledForNewClassVersionDeletions;
		createNewClassesAndClassVersions;
		compileMethods.
	self reportAnyErrors
		ifTrue: [ ^ self ].	"No errors -- go ahead and install what's been compiled."
	self
		addAndUpdateLoadedProjects;
		addAndUpdateLoadedPackages;
		removeDeletedClassesFromSystem;
		"removeDeletedClassExtensionsFromSystem;" 
		installAddedClasses;
		movePackages;
		moveClassesBetweenSymbolDictionaries;
		installAddedClassExtensions;
		doMoveClassesBetweenPackages;
		doMoveMethodsBetweenPackages;
		updateSymbolAssociations;
		updateClassProperties;
		removeDeletedMethods;
		updateMethodDictionaries;
		updateMethodProperties;
		"removeDeletedClassesAndExtensionsFromPackages;"
		removeDeletedPackages;
		commit;
		runInitializers;
		commit;
		migrateInstances;
		commit
%

category: 'public'
method: RwGsPatchSet_254
applyForNewClassVersions: anInstanceMigrator

	"ignore deleted methods when applying patches to new class version.
		all methods effectively deleted from class when the new class version is created, "

	| classNames |
	instanceMigrator := anInstanceMigrator.
	classNames := Set new.
	classesWithNewVersions
		do: [ :patch | classNames add: patch classDefinition key ].
	deletedMethods copy
		do: [ :patch | 
			(classNames includes: patch className)
				ifTrue: [ 
					deleteNewVersionMethods add: patch.
					deletedMethods remove: patch ] ].
	self apply
%

category: 'accessing'
method: RwGsPatchSet_254
classesWithNewVersions

	^ classesWithNewVersions
%

category: 'private - applying'
method: RwGsPatchSet_254
commit
	"I don't think I like the idea that we commit during a load ... the developer should always be in control of
		when a commit is performed ... automatic instance migration does do commits, however, it is a developer
		choice to do the commits ... if an error occurs after a commit is performed, I am concerned that the loaded 
		state of system will be corrupted ... "

	false ifTrue: [ System commit ]
%

category: 'private - applying'
method: RwGsPatchSet_254
compileMethodPatch: aMethodAdditionPatch

	aMethodAdditionPatch compileUsingNewClasses: createdClasses
		andExistingClasses: tempSymbols
%

category: 'private - applying'
method: RwGsPatchSet_254
compileMethods

	addedMethods do: [:each | self compileMethodPatch: each].
	extendedMethods do: [:each | self compileMethodPatch: each].
	methodsNeedingRecompile do: [:each | self compileMethodPatch: each]
%

category: 'private - applying'
method: RwGsPatchSet_254
createClassesFromWorklist: workList andClassesByName: newClassesByName
	"Pick one class or class version from the workList and create it, creating any superclasses or superclass versions that are to be created.
	Remove any classes created from the workList."

	| className |
	className := self anyElementOfCollection: workList.
	className ifNil: [self error: 'Empty WorkList.'].
	self
		createClassNamed: className
		fromWorkList: workList
		andClassesByName: newClassesByName
%

category: 'private - applying'
method: RwGsPatchSet_254
createClassNamed: className fromWorkList: workList andClassesByName: newClassesByName
	"Create the named class from the workList, creating any superclasses or superclass versions that are to be created.
	Remove any classes created from the workList."

	| patch superclassName |
	workList remove: className.
	patch := newClassesByName at: className.
	superclassName := patch superclassName.
	(workList includes: superclassName)
		ifTrue: 
			[self
				createClassNamed: superclassName
				fromWorkList: workList
				andClassesByName: newClassesByName].
	patch createClassFor: self
%

category: 'patch access'
method: RwGsPatchSet_254
createdClass: aClass

	| className |
	className := aClass name.
	(createdClasses at: className ifAbsent: [ ])
		ifNil: [ 
			createdClasses
				add: (SymbolAssociation newWithKey: className value: aClass) ]
		ifNotNil: [:cl | 
			cl == aClass
				ifFalse: [ 
					"new version created, update entry in createdClasses"
					createdClasses at: className put: aClass ] ]
%

category: 'accessing'
method: RwGsPatchSet_254
createdClasses
	^ createdClasses
%

category: 'private - applying'
method: RwGsPatchSet_254
createNewClassesAndClassVersions

	"Who: Added classes and classes with new versions and classes with class variable changes
	   How: Create the new class or class version. Superclass by identity, not name resolution.
	   Order: Superclasses first.
	   Errors: Collect for reporting later"

	| newClassesByName workList |
	newClassesByName := Dictionary new.
	self addCreatedClassesAndVersionsTo: newClassesByName.
	workList := Set withAll: newClassesByName keys.
	[ workList isEmpty ]
		whileFalse: [ self createClassesFromWorklist: workList andClassesByName: newClassesByName ]
%

category: 'private - applying'
method: RwGsPatchSet_254
doMoveClassesBetweenPackages

	| image |
	image := Rowan image.
	movedClasses 
		do: [:aClassMove |
			| loadedClass |
			loadedClass := image loadedClassNamed: aClassMove classBefore name.
			loadedClass loadedPackage removeLoadedClass: loadedClass.
			(image loadedPackageNamed: aClassMove packageAfter name)
				addLoadedClass: loadedClass ]
%

category: 'private - applying'
method: RwGsPatchSet_254
doMoveMethodsBetweenPackages

	| image |
	image := Rowan image.
	movedMethods 
		do: [:aMethodMove |
			| packageDef classOrExtensionDef loadedPackage loadedClassOrExtension loadedMethods loadedMethod compiledMethod registry |
			packageDef := aMethodMove packageBefore.
			classOrExtensionDef := aMethodMove classOrExtensionBefore.
			loadedPackage := image loadedPackageNamed: packageDef name.
			loadedClassOrExtension := loadedPackage 
				classOrExtensionForClassNamed: classOrExtensionDef name 
				ifAbsent: [ 
					self error: 'internal error - no loaded class or extension found for class ', 
						classOrExtensionDef name printString, 
						'  in package ', 
						packageDef name printString ].
			loadedMethods := aMethodMove isMeta
				ifTrue: [ loadedClassOrExtension loadedClassMethods ]
				ifFalse: [ loadedClassOrExtension loadedInstanceMethods ].
			loadedMethod := loadedMethods at: aMethodMove methodBefore selector.

			registry := image loadedRegistryForPackageNamed: loadedPackage name.

			loadedClassOrExtension removeLoadedMethod: loadedMethod.
			loadedClassOrExtension isLoadedClassExtension
				ifTrue: [
					loadedClassOrExtension isEmpty
						ifTrue: [ 
							| theKey classExtensionRegistry |
							theKey := loadedClassOrExtension handle classHistory.
							classExtensionRegistry := registry classExtensionRegistry.
							(classExtensionRegistry at: theKey ifAbsent: [])
								ifNotNil: [ :loadedClassExtensions |
									loadedClassExtensions isEmpty
										ifFalse: [ 
											loadedClassExtensions remove: loadedClassOrExtension.
											loadedClassExtensions isEmpty
												ifTrue: [ classExtensionRegistry removeKey: theKey ] ] ].
							loadedPackage removeLoadedClassExtension: loadedClassOrExtension ] ].

            compiledMethod := loadedMethod handle.
			registry methodRegistry removeKey: compiledMethod ifAbsent: [].

			packageDef := aMethodMove packageAfter.
			classOrExtensionDef := aMethodMove classOrExtensionAfter.
			loadedPackage := image loadedPackageNamed: packageDef name.
			registry := (Rowan globalNamed: (aMethodMove projectAfter  symbolDictNameForPackageNamed: aMethodMove packageAfter name)) rowanSymbolDictionaryRegistry.
			loadedClassOrExtension := loadedPackage 
				classOrExtensionForClassNamed: classOrExtensionDef name 
				ifAbsent: [ 
					classOrExtensionDef isClassExtension
						ifTrue: [ 
							"add a new class extension on demand"
							(aMethodMove projectAfter
								useSessionMethodsForExtensionsForPackageNamed: aMethodMove packageAfter name)
								ifTrue: [ | resolved |
									((resolved := GsCurrentSession currentSession symbolList objectNamed: classOrExtensionDef name asSymbol) notNil 
										and: [resolved isBehavior and: [ resolved isMeta not ]])
										ifFalse: [ 
											self
												error:
													'The extension class named ' , self className printString , ' cannot be found.' ].
"logic is not quite correct here ... need to create a lodedClassExtension for this puppy ... deferring session method work to a later date"
"https://github.com/dalehenrich/Rowan/issues/254"]
								ifFalse: [
									registry
										ensureExtensionClassNamed: classOrExtensionDef name
										existsForPackageNamed: packageDef name
										implementationClass: RwGsSymbolDictionaryRegistry_Implementation ].
							loadedPackage loadedClassExtensions at: classOrExtensionDef name ]
						ifFalse: [ 
							self error: 'internal error - no loaded class found for class ', 
								classOrExtensionDef name printString, 
								'  in package ', 
								packageDef name printString ] ].

			loadedClassOrExtension addLoadedMethod: loadedMethod.

			registry methodRegistry at: compiledMethod put: loadedMethod ]
%

category: 'initialization'
method: RwGsPatchSet_254
initialize

	addedPackages := Set new.
	addedProjects := Set new.
	deletedPackages := Set new.
	movedPackages := Set new.
	projectsWithPropertyChanges := Set new.
	deletedClasses := Set new.
	addedClasses := Set new.
	extendedClasses := Set new.
	classesWithNewVersions := Set new.
	classesWithClassVariableChanges := Set new.
	classesWithPropertyChanges := Set new.
	classesWithConstraintChanges := Set new.
	classesWithSymbolDictionaryChanges := Set new.
	movedClasses := Set new.
	movedClassesMap := Dictionary new.
	deletedMethods := Set new.
	deleteNewVersionMethods := Set new.
	movedMethods := Set new.
	addedMethods := Set new.
	extendedMethods := Set new.
	methodsNeedingRecompile := Set new.
	methodsWithPropertyChanges := Set new.
	tempSymbols := SymbolDictionary new.
	createdClasses := Dictionary new.
	errors := Set new
%

category: 'private - applying'
method: RwGsPatchSet_254
installAddedClasses
	"Copy the name association from TempSymbols to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	addedClasses do: [:patch |  patch installClassInSystem ]
%

category: 'private - applying'
method: RwGsPatchSet_254
installAddedClassExtensions

	extendedClasses do: [ :each | each installClassExtensionInSystem ]
%

category: 'accessing'
method: RwGsPatchSet_254
instanceMigrator

	^ instanceMigrator
%

category: 'private - applying'
method: RwGsPatchSet_254
migrateInstances

	"conditionally migrate instances of classes with new versions"

	| classSet |
	classSet := classesWithNewVersions collect: [ :patch | patch oldClassVersion ].
	classSet isEmpty
		ifTrue: [ ^ self ].
	instanceMigrator
		ifNil: [ 
			"if instanceMigrator is not set, then we are not ready to do instance migration on this pass"
			^ self ].
	instanceMigrator migrateInstancesOf: classSet asArray
%

category: 'private - applying'
method: RwGsPatchSet_254
moveClassesBetweenSymbolDictionaries

	classesWithSymbolDictionaryChanges do: [:each | 
		| className |
		className := each classDefinition name.
		(movedClassesMap at: className ifAbsent: [])
				ifNil: [ each installSymbolDictionaryPatchFor: self ]
				ifNotNil: [:classMove | each installSymbolDictionaryPatchFor: self classMove: classMove ] ].
%

category: 'accessing'
method: RwGsPatchSet_254
movedClassesMap
	^ movedClassesMap
%

category: 'private - applying'
method: RwGsPatchSet_254
movePackages

	movedPackages do: [:each | each movePackage ]
%

category: 'private - applying'
method: RwGsPatchSet_254
recordCompiledForNewClassVersionDeletions

	deleteNewVersionMethods
		do: [ :each | each primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols ]
%

category: 'private - applying'
method: RwGsPatchSet_254
removeDeletedClassesFromSystem
	"Remove the name binding from the SymbolDictionaries in the live SymbolList
        Remove the LoadedClass from its LoadedPackage"

	deletedClasses do: [:patch | patch deleteClassFromSystem ]
%

category: 'private - applying'
method: RwGsPatchSet_254
removeDeletedClassesFromTempSymbols
	"Deleted class names should not resolve during compilation."

	deletedClasses do: [:patch | tempSymbols removeKey: patch className asSymbol ]
%

category: 'private - applying'
method: RwGsPatchSet_254
removeDeletedMethods

	deletedMethods
		do: [ :methodDeletionPatch | 
			| className |
			className := methodDeletionPatch className.
			methodDeletionPatch deleteMethodNewClasses: createdClasses andExistingClasses: tempSymbols ].
	deleteNewVersionMethods
		do: [ :methodDeletionPatch | 
			methodDeletionPatch
				deleteNewVersionMethodNewClasses: createdClasses
				andExistingClasses: tempSymbols  ]
%

category: 'private - applying'
method: RwGsPatchSet_254
removeDeletedPackages

	deletedPackages do: [:each | each deletePackage ]
%

category: 'private - applying'
method: RwGsPatchSet_254
reportAnyErrors
	"We're currently not collecting errors, but once we do, this will be the place they are reported.
	Answer true if errors detected (and exception resumed), false otherwise."

	^errors isEmpty
		ifFalse: 
			[self halt: 'Errors detected. Aborting application of patch.'.
			true]
		ifTrue: [false]
%

category: 'private - applying'
method: RwGsPatchSet_254
runInitializers

	"run the class initialization methods as needed"

	| methodPatches orderedMethodPatches blackList |
	blackList := Rowan automaticClassInitializationBlackList.
	methodPatches := (addedMethods copy
		addAll: extendedMethods;
		addAll: methodsNeedingRecompile;
		yourself) select: [:each | each isAnInitializer ].
	methodPatches isEmpty ifTrue: [ ^ self ].
	orderedMethodPatches :=  (self class respondsTo: #methodPatchesInInitializationOrder:)
		ifTrue: [ self class methodPatchesInInitializationOrder: methodPatches ]
		ifFalse: [ methodPatches ].
	orderedMethodPatches do: [ :methodPatch | 
		(blackList includes: methodPatch projectDefinition name)
			ifFalse: [ 
				(RwExecuteClassInitializeMethodsAfterLoadNotification new
					candidateClass: methodPatch behavior thisClass) signal 
						ifTrue: [ methodPatch runInitializer ] ] ]
%

category: 'private - applying'
method: RwGsPatchSet_254
setupForApply

	"Copy the entire namespace from the user's transient SymbolList into a temporary SymbolDictionary in a temporary 
	SymbolList, the tempSymbols. The tempSymbols, once suitably modified, will be used as the environment in which 
	to compile methods during this apply operation."

	| symbolList |
	tempSymbols := SymbolDictionary new.
	symbolList := Rowan image symbolList.	
	"If there are any duplicated symbols, we only want the one that will be found first one, 
	so we copy in reverse order of search order, thereby overwriting later definitions with earlier ones."
	symbolList
		reverseDo: [ :dict | 
			"Need to preserve association identity, tempSymbols is used for compiling methods"
			dict associationsDo: [ :assoc | tempSymbols add: assoc ] ].

	self setupForMovedClasses
%

category: 'private - applying'
method: RwGsPatchSet_254
setupForMovedClasses

	self _createMovedClasses
%

category: 'private - applying'
method: RwGsPatchSet_254
setupForNewClassVersionUpdates

	self _createMovedClasses
%

category: 'patch access'
method: RwGsPatchSet_254
superclassNamed: aName

	^ self superclassNamed: aName ifAbsent: [ self error: 'Superclass not found: ' , aName printString ]
%

category: 'patch access'
method: RwGsPatchSet_254
superclassNamed: aName ifAbsent: absentBlock

	| superclassName |
	superclassName := aName asSymbol.
	^ createdClasses
		at: superclassName
		ifAbsent: [ 
			tempSymbols
				at: superclassName
				ifAbsent: absentBlock ]
%

category: 'accessing'
method: RwGsPatchSet_254
symbolDictionaryRegistryClass

	^ self _currentProjectDefinition
		ifNil: [ RwGsSymbolDictionaryRegistry ]
		ifNotNil: [ :projectDefinition | projectDefinition symbolDictionaryRegistryClass ]
%

category: 'patch access'
method: RwGsPatchSet_254
tempAssociationFor: aName
	^ tempSymbols associationAt: aName
%

category: 'accessing'
method: RwGsPatchSet_254
tempSymbols
	^ tempSymbols
%

category: 'private - applying'
method: RwGsPatchSet_254
updateClassProperties

	"For classes with changes that don't require versioning, 
	update the properties in the class and the LoadedClasses as appropriate."

	(classesWithClassVariableChanges copy
		addAll: classesWithPropertyChanges;
		addAll: classesWithConstraintChanges;
		yourself) do: [ :each | 
			(movedClassesMap at: each className ifAbsent: [])
				ifNil: [ each installPropertiesPatchFor: self ]
				ifNotNil: [:aClassMove | each installPropertiesPatchFor: self classMove: aClassMove ] ]
%

category: 'private - applying'
method: RwGsPatchSet_254
updateMethodDictionaries
	"For added methods and methods that need recompiling,
	copy from temporary methodDictionaries to live methodDictionaries
	For added methods, create LoadedMethods and add to the appropriate LoadedClass
	or LoadedExtension
	For methods that need recompiling updated the LoadedMethods registration. "

	| movedClassesWithNewVersionMap movedExtensionMethodsMap |
	movedClassesWithNewVersionMap := Dictionary new.
	classesWithNewVersions do: [:patch | 
		(movedClassesMap at: patch className ifAbsent: []) 
			ifNotNil: [:aClassMove | 
				movedClassesWithNewVersionMap at: patch className put: {aClassMove . patch} ] ]. 
	addedMethods do: [:patch |
		| className |
		className := patch className.
		(movedClassesWithNewVersionMap at: className ifAbsent: [])
			ifNil: [ patch installMethod ]
			ifNotNil: [:ar | 
				"https://github.com/dalehenrich/Rowan/issues/316"
				patch installMovedMethod: (ar at: 1) newClassVersionPatch: (ar at: 2) ] ].
	movedClassesWithNewVersionMap isEmpty
		ifFalse: [
			"calculate moved extension methods map only if there are moved new class versions as well"
			movedExtensionMethodsMap := Dictionary new.
			movedMethods do: [:aMethodMove |
				| classExtDict key methodDict  |
				classExtDict := movedExtensionMethodsMap  at: aMethodMove classOrExtensionAfter name ifAbsentPut: [ Dictionary new].
				key := aMethodMove isMeta ifTrue: [ 'class' ] ifFalse: [ 'instance'].
				methodDict := classExtDict at: key ifAbsentPut: [ Dictionary new ]. 
				methodDict at: aMethodMove methodAfter selector put: aMethodMove ] ].
	extendedMethods do: [:patch |
		| className |
		className := patch className.
		(movedClassesWithNewVersionMap at: className ifAbsent: [])
			ifNil: [ patch installMethod ]
			ifNotNil: [:ar | 
				"https://github.com/dalehenrich/Rowan/issues/316"
				(movedExtensionMethodsMap at: className ifAbsent: [])
					ifNil: [ patch installMethod ]
					ifNotNil: [:classExtDict |
						| methodDict |
						methodDict := patch isMeta
							ifTrue: [ classExtDict at: 'class' ifAbsent: [ Dictionary new ] ]
							ifFalse: [ classExtDict at: 'instance' ifAbsent: [ Dictionary new ] ].
						(methodDict at: patch methodDefinition selector ifAbsent: [])
							ifNil: [ patch installMethod ]
							ifNotNil: [:aMethodMove |
								patch installMovedMethod: aMethodMove newClassVersionPatch: (ar at: 2) ] ] ] ].
	methodsNeedingRecompile do: [:each | each installSourcePatch ]
%

category: 'private - applying'
method: RwGsPatchSet_254
updateMethodProperties

	methodsWithPropertyChanges
		do: [:each | each installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols ]
%

category: 'private - applying'
method: RwGsPatchSet_254
updateSymbolAssociations
	"Install new class versions."

	classesWithNewVersions do: [:each | 
		(movedClassesMap at: each className ifAbsent: [])
			ifNil: [ each installNewClassVersionInSystem ]
			ifNotNil: [:aClassMove | each moveNewClassVersionInSystem: aClassMove ].
		 ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classAdditionPatchClass

	^ RwGsClassAdditionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classConstraintPatchClass

	^ RwGsClassConstraintsSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classDeletionPatchClass

	^ RwGsClassDeletionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classExtensionPatchClass

	^ RwGsClassExtensionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classPropertiesPatchClass

	^ RwGsClassPropertiesSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classSymbolDictionaryMovePatchClass

	^ RwGsClassSymbolDictionaryMoveSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classVariablePatchClass

	^ RwGsClassVariableChangeSymbolDictPatch 
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classVersioningPatchClass

	^ RwGsClassVersioningSymbolDictPatch
%

category: 'private - applying'
method: RwGsPatchSet_254
_createMovedClasses

	movedClasses do: [:movedClass | 
		movedClassesMap 
			at: movedClass classBefore name 
			put: movedClass ].
%

category: 'private - applying'
method: RwGsPatchSet_254
_currentProjectDefinition

	^ currentProjectDefinition
		ifNil: [ 
			currentProjectDefinition := Rowan image
				loadedProjectNamed: Rowan unpackagedName
				ifAbsent: [ RwUnmanagedProjectDefinition new ] ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodAdditionPatchClass

	^ RwGsMethodAdditionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodDeletionPatchClass

	^ RwGsMethodDeletionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodExtensionDeletionPatchClass: packageName

	^ (self _currentProjectDefinition
		useSessionMethodsForExtensionsForPackageNamed: packageName)
			ifTrue: [ RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch ]
			ifFalse: [ RwGsMethodDeletionExtensionSymbolDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodExtensionPatchClass: packageName

	^ (self _currentProjectDefinition
		useSessionMethodsForExtensionsForPackageNamed: packageName)
			ifTrue: [ RwGsMethodExtensionSessionMethodSymbolDictPatch ]
			ifFalse: [ RwGsMethodExtensionSymbolDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodExtensionPropertiesPatchClass:  packageName

	^ (self _currentProjectDefinition
			useSessionMethodsForExtensionsForPackageNamed: packageName)
				ifTrue: [ RwGsMethodExtensionSessionMethodPropertiesSymDictPatch ]
				ifFalse: [ RwGsMethodPropertiesSymDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodExtensionSourcePatchClass: packageName

	^ (self _currentProjectDefinition
			useSessionMethodsForExtensionsForPackageNamed: packageName)
				ifTrue: [ RwGsMethodExtensionSessionMethodSourceSymbolDictPatch ]
				ifFalse: [ RwGsMethodSourceSymbolDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodPropertiesPatchClass

	^ RwGsMethodPropertiesSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodSourcePatchClass

	^ RwGsMethodSourceSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_packageAdditionPatchClass

	^ RwGsPackageAdditionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_packageDeletionPatchClass

	^ RwGsPackageDeletionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_packageMovePatchClass

	^ RwGsPackageMoveSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_projectAdditionPatchClass

	^ RwGsProjectAdditionPatch
%

! Class implementation for 'RwGsSymbolDictionaryRegistry'

!		Class methods for 'RwGsSymbolDictionaryRegistry'

category: 'accessing'
classmethod: RwGsSymbolDictionaryRegistry
defaultProtocolString

	^ 'as yet unclassified'
%

category: 'installation'
classmethod: RwGsSymbolDictionaryRegistry
globalSymbol

	^ #'RwSymbolDictionaryRegistry'
%

category: 'installation'
classmethod: RwGsSymbolDictionaryRegistry
installIn: aSymbolDictionary

	| registry |
	registry := self newForSymbolDictionary: aSymbolDictionary.
	aSymbolDictionary at: self globalSymbol put: registry.
	^ registry
%

category: 'instance creation'
classmethod: RwGsSymbolDictionaryRegistry
newForSymbolDictionary: aSymbolDictionary

	^ self new
		_symbolDictionary: aSymbolDictionary;
		initialize;
		yourself
%

!		Instance methods for 'RwGsSymbolDictionaryRegistry'

category: 'private'
method: RwGsSymbolDictionaryRegistry
addClassAssociation: assoc forClass: class toPackageNamed: packageName

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	^ self class registry_ImplementationClass addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addClassAssociation: assoc forClass: class toPackageNamed: packageName implementationClass: implementationClass

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName

	^ self class registry_ImplementationClass addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName

	"expecting only a single method to be in methDict/catDict"

	^ self class registry_ImplementationClass addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName implementationClass: implementationClass

	"expecting only a single method to be in methDict/catDict"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addMovedDeletedMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName

	"there is an existing compiled method that has already been deleted from another package ... so we're adding it
		back using specialized processing"

	^ self class registry_ImplementationClass addMovedDeletedMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addMovedDeletedMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName implementationClass: implementationClass

	"there is an existing compiled method that has already been deleted from another package ... so we're adding it
		back using specialized processing"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addMovedDeletedMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addNewClassVersionToAssociation: newClass

	"a new class version is being added to the association in the receiver previously occupied by the original class"

	^ self class registry_ImplementationClass addNewClassVersionToAssociation: newClass instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addNewClassVersionToAssociation: newClass implementationClass: implementationClass

	"a new class version is being added to the association in the receiver previously occupied by the original class"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addNewClassVersionToAssociation: newClass instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName

	^ self class registry_ImplementationClass addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addRecompiledMethod: newCompiledMethod

	"add a recompiled compiled method to behavior and update the loaded things"

	^ self class registry_ImplementationClass addRecompiledMethod: newCompiledMethod instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addRecompiledMethod: newCompiledMethod implementationClass: implementationClass

	"add a recompiled compiled method to behavior and update the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addRecompiledMethod: newCompiledMethod instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addRecompiledSessionMethodMethod: newCompiledMethod

	"add a recompiled session method compiled method to behavior and update the loaded things"

	^ self class registry_ImplementationClass addRecompiledSessionMethodMethod: newCompiledMethod instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addRecompiledSessionMethodMethod: newCompiledMethod implementationClass: implementationClass

	"add a recompiled session method compiled method to behavior and update the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addRecompiledSessionMethodMethod: newCompiledMethod instance: self
%

category: 'method - adopt api'
method: RwGsSymbolDictionaryRegistry
adoptCompiledMethod: compiledMethod classExtension: classExtension for: behavior protocol: protocolString toPackageNamed: packageName

	| methodDictionary selector protocolSymbol existing loadedMethod loadedPackage loadedClassOrExtension |
	classExtension
		ifTrue: [
			"to adopt and extension method, it is much less complicated" 
			^ self 
				addExtensionCompiledMethod: compiledMethod 
				for: behavior 
				protocol: protocolString 
				toPackageNamed: packageName ].

	methodDictionary := (behavior persistentMethodDictForEnv: 0 ) ifNil:[ Dictionary new ].
	selector := compiledMethod selector.
	compiledMethod == (methodDictionary at: selector ifAbsent: [ self error: 'expected an existing compiled method' ])
		ifFalse: [ self error: 'The given compiled method does not the existing compiled method in the class.' ].

	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [ behavior addCategory: protocolSymbol ].
	behavior moveMethod: selector toCategory: protocolSymbol.

	existing := methodRegistry at: compiledMethod ifAbsent: [ nil ].
	existing
		ifNotNil: [
			"existing LoadedMethod found for compiled method ... ignore already packaged methods"
			^ self ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	methodRegistry at: compiledMethod put: loadedMethod.

	loadedPackage := self
		loadedPackageNamed: packageName
		ifAbsent: [ 
			self
				error: 'Internal error -- attempt to add a method to a nonexistent package.' ].

	loadedClassOrExtension := loadedPackage
		loadedClassOrClassExtensionForClass: behavior
		ifAbsent: [ 
			self
				error:
					'Internal error -- attempt to add a method to a package in which its class is neither defined nor extended.' ].
	loadedClassOrExtension addLoadedMethod: loadedMethod
%

category: 'accessing'
method: RwGsSymbolDictionaryRegistry
classExtensionRegistry

	^ classExtensionRegistry
%

category: 'accessing'
method: RwGsSymbolDictionaryRegistry
classRegistry

   ^classRegistry
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
createAndInstallLoadedClassForClass: class toPackageNamed: packageName

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	^ self class registry_ImplementationClass createAndInstallLoadedClassForClass: class toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
createAndInstallLoadedClassForClass: class toPackageNamed: packageName implementationClass: implementationClass

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass createAndInstallLoadedClassForClass: class toPackageNamed: packageName instance: self
%

category: 'package - patch api'
method: RwGsSymbolDictionaryRegistry
createLoadedPackageFromDefinition: packageDefinition

	^ self class registry_ImplementationClass createLoadedPackageFromDefinition: packageDefinition instance: self
%

category: 'package - patch api'
method: RwGsSymbolDictionaryRegistry
createLoadedPackageFromDefinition: packageDefinition implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass createLoadedPackageFromDefinition: packageDefinition instance: self
%

category: 'package - patch api'
method: RwGsSymbolDictionaryRegistry
createLoadedPackageNamed: packageName properties: properties

	^ self class registry_ImplementationClass createLoadedPackageNamed: packageName properties: properties instance: self
%

category: 'package - patch api'
method: RwGsSymbolDictionaryRegistry
createLoadedPackageNamed: packageName properties: properties  implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass createLoadedPackageNamed: packageName properties: properties instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
deleteClassFromPackage: class

	"a class association is being deleted from the receiver remove it from the loaded things"

	^ self class registry_ImplementationClass deleteClassFromPackage: class instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
deleteClassFromPackage: class implementationClass: implementationClass

	"a class association is being deleted from the receiver remove it from the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteClassFromPackage: class instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
deleteClassNamedFromPackage: className

	"a class association is being deleted from the receiver remove it from the loaded things"

	^ self class registry_ImplementationClass deleteClassNamedFromPackage: className instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
deleteClassNamedFromPackage: className implementationClass: implementationClass

	"a class association is being deleted from the receiver remove it from the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteClassNamedFromPackage: className instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteCompiledMethod: compiledMethod from: behavior

	"delete a compiled method from behavior and remove it from the loaded things"

	^ self class registry_ImplementationClass deleteCompiledMethod: compiledMethod from: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteCompiledMethod: compiledMethod from: behavior implementationClass: implementationClass

	"delete a compiled method from behavior and remove it from the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteCompiledMethod: compiledMethod from: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteMethod: selector for: behavior

	^ self class registry_ImplementationClass deleteMethod: selector for: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteMethod: selector for: behavior implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteMethod: selector for: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteMovedLoadedMethod: selector for: behavior implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteMovedLoadedMethod: selector for: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteMovedMethod: selector for: behavior implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteMovedMethod: selector for: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deletePackage: packageName

	^  self class registry_ImplementationClass deletePackage: packageName instance: self
%

category: 'class disown api'
method: RwGsSymbolDictionaryRegistry
disownClass: class

	"Remove the specified class and all of it's packaged instance and class methods from the loaded things."

	^ self class registry_ImplementationClass disownClass: class instance: self
%

category: 'class disown api'
method: RwGsSymbolDictionaryRegistry
disownClassExtensions: class forLoadedPackage: loadedPackage

	"Remove the extension methods in the named class for the named package"

	^ self class registry_ImplementationClass disownClassExtensions: class forLoadedPackage: loadedPackage instance: self
%

category: 'class disown api'
method: RwGsSymbolDictionaryRegistry
disownClassExtensions: class forPackageNamed: packageName

	"Remove the extension methods in the named class for the named package"

	^ self class registry_ImplementationClass disownClassExtensions: class forPackageNamed: packageName instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
ensureExtensionClassNamed: className existsForPackageNamed: packageName

	^ self class registry_ImplementationClass ensureExtensionClassNamed: className existsForPackageNamed: packageName instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
ensureExtensionClassNamed: className existsForPackageNamed: packageName implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass ensureExtensionClassNamed: className existsForPackageNamed: packageName instance: self
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
existingForClass: aClass

	"Answer the registered LoadedClass for the given class."

	^ self
		existingForClass: aClass
		ifAbsent: [ self error: 'no loaded class found for ' , aClass name printString ]
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
existingForClass: aClass ifAbsent: absentBlock

	"Answer the registered LoadedClass for the given class."

	^ classRegistry at: aClass classHistory ifAbsent: absentBlock
%

category: 'package - creation api'
method: RwGsSymbolDictionaryRegistry
existingOrNewLoadedPackageNamed: packageName

	^ self class registry_ImplementationClass existingOrNewLoadedPackageNamed: packageName instance: self
%

category: 'package - creation api'
method: RwGsSymbolDictionaryRegistry
existingOrNewLoadedPackageNamed: packageName implementationClass: implementationClass

	^ implementationClass existingOrNewLoadedPackageNamed: packageName instance: self
%

category: 'session methods'
method: RwGsSymbolDictionaryRegistry
homeSessionMethods

	| package |
	package := self _symbolDictionary at: GsPackage globalName otherwise: nil.
	package ifNil: [ package := GsPackage installIn: self _symbolDictionary ].
	^ package
%

category: 'initialization'
method: RwGsSymbolDictionaryRegistry
initialize

	| symbolDictObjectSecurityPolicy |
	packageRegistry := KeyValueDictionary new.	"keyed by package name"
	classRegistry := IdentityKeyValueDictionary new.	"keyed by class classHistory"
	classExtensionRegistry := IdentityKeyValueDictionary new.	"keyed by class classHistory"
	methodRegistry := IdentityKeyValueDictionary new.	"keyed by compiledMethod"

	symbolDictObjectSecurityPolicy := symbolDictionary objectSecurityPolicy.
	packageRegistry objectSecurityPolicy: symbolDictObjectSecurityPolicy.
	classRegistry objectSecurityPolicy: symbolDictObjectSecurityPolicy.
	classExtensionRegistry objectSecurityPolicy: symbolDictObjectSecurityPolicy.
	methodRegistry objectSecurityPolicy: symbolDictObjectSecurityPolicy.
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock

	^ self class registry_ImplementationClass loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock instance: self
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock instance: self
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
loadedPackageNamed: packageName ifAbsent: absentBlock

	^ self class registry_ImplementationClass loadedPackageNamed: packageName ifAbsent: absentBlock instance: self
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
loadedPackageNamed: packageName ifAbsent: absentBlock implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass loadedPackageNamed: packageName ifAbsent: absentBlock instance: self
%

category: 'accessing'
method: RwGsSymbolDictionaryRegistry
methodRegistry

   ^methodRegistry
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
moveCompiledMethod: compiledMethod toProtocol: newProtocol

	"move a compiled method into a different protocol and update loaded things"

	^ self class registry_ImplementationClass moveCompiledMethod: compiledMethod toProtocol: newProtocol instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
moveCompiledMethod: compiledMethod toProtocol: newProtocol implementationClass: implementationClass

	"move a compiled method into a different protocol and update loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass moveCompiledMethod: compiledMethod toProtocol: newProtocol instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
movePackage: packageName to: symbolDictionaryName

	^  self class registry_ImplementationClass movePackage: packageName  to: symbolDictionaryName instance: self
%

category: 'package - creation api'
method: RwGsSymbolDictionaryRegistry
newLoadedPackageNamed: packageName

	^ self class registry_ImplementationClass newLoadedPackageNamed: packageName instance: self
%

category: 'package - creation api'
method: RwGsSymbolDictionaryRegistry
newLoadedPackageNamed: packageName implementationClass: implementationClass

	^ implementationClass newLoadedPackageNamed: packageName instance: self
%

category: 'accessing'
method: RwGsSymbolDictionaryRegistry
packageRegistry

   ^packageRegistry
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
updateClassProperties: class

	"class properties have changed, update the clas properties of the loaded things"

	^ self class registry_ImplementationClass updateClassProperties: class instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
updateClassProperties: class  implementationClass: implementationClass

	"class properties have changed, update the clas properties of the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass updateClassProperties: class instance: self
%

category: 'method - private api'
method: RwGsSymbolDictionaryRegistry
_doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior

	"remove a compiled method from loaded things"

	^ self class registry_ImplementationClass _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: self
%

category: 'method - private api'
method: RwGsSymbolDictionaryRegistry
_doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior implementationClass: implementationClass

	"remove a compiled method from loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_loadedClassFor: class noNewVersion: noNewVersionBlock

	self
		_loadedClassFor: class
		noNewVersion: noNewVersionBlock
		newVersion: [ :loadedClass | 
			self
				error:
					'internal error - the value associated with the key ' , class name printString
						, ' is not identical to the given class' ]
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_loadedClassFor: class noNewVersion: noNewVersionBlock newVersion: newVersionBlock

	| loadedClass classKey |
	(class isKindOf: Class)
		ifFalse: [ self error: 'internal error - expected a class' ].
	loadedClass := classRegistry
		at: class classHistory
		ifAbsent: [ 
			self
				error:
					'internal error - No package found for the class ' , class name printString ].
	classKey := loadedClass key asSymbol.
	self
		_symbolDictionaryAssociationAt: classKey
		ifPresent: [ :assoc | 
			assoc value == class
				ifTrue: [ ^ noNewVersionBlock cull: loadedClass cull: assoc ]
				ifFalse: [ ^ newVersionBlock cull: loadedClass cull: assoc ] ].

	self
		error:
			'internal error - there is no assocation present in the receiver for the given class '
				, classKey asString printString
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionary

	^ symbolDictionary
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionary: aSymbolDictionary

	symbolDictionary := aSymbolDictionary
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionaryAssociationAt: aKey ifPresent: oneArgBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the symbol association associated with the key, otherwise answer nil."

	| anAssoc |
	anAssoc := self _symbolDictionary associationAt: aKey otherwise: nil.
	anAssoc ifNotNil: [ ^ oneArgBlock cull: anAssoc ].
	^ nil
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionaryAssociationAt: key ifPresent: oneArgBlock ifAbsent: absentBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the symbol association associated with the key, otherwise answer the value of absentBlock."

	self
		_symbolDictionaryAssociationAt: key
		ifPresent: [ :v | ^ oneArgBlock cull: v ].
	^ absentBlock value
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionaryAt: key ifPresent: oneArgBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v := self _symbolDictionary at: key ifAbsent: [ ^ nil ].
	^ oneArgBlock cull: v
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionaryAt: key ifPresent: oneArgBlock ifAbsent: absentBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the value associated with the key, otherwise answer the value of absentBlock."

	| v |
	v := self _symbolDictionary at: key ifAbsent: [ ^absentBlock value ].
	^ oneArgBlock cull: v
%

! Class implementation for 'RwGsSymbolDictionaryRegistry_Implementation'

!		Class methods for 'RwGsSymbolDictionaryRegistry_Implementation'

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: registryInstance

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	| loadedPackage loadedClass |
	loadedPackage := self existingOrNewLoadedPackageNamed: packageName instance: registryInstance.

	loadedClass := registryInstance classRegistry
		at: class classHistory
		ifAbsent: [ 
			loadedClass := RwGsLoadedSymbolDictClass newForClass: class.
			loadedPackage addLoadedClass: loadedClass.
			loadedClass updatePropertiesFromClassFor: registryInstance.
			registryInstance classRegistry at: class classHistory put: loadedClass.
			(loadedPackage loadedClassExtensions at: class name ifAbsent: [  ])
				ifNotNil: [ :loadedClassExtension | 
					"I think we need to subsume the loadedClassExtension methods into a loadedClass ..."
					"have yet to come with a test case that takes this path"
					registryInstance error: 'internal error - unexpected class extenstions for a loaded class ', class name asString printString , ' that has no entry in classRegistry in package ', loadedPackage name printString, '.' ] ].

	self 
		_symbolDictionary: registryInstance _symbolDictionary 
		at: assoc key 
		ifPresent: [:theClass |
			theClass ~~ class
				ifTrue: [
					(RwExistingAssociationWithSameKeyNotification new
						errorMessage: 'Found an existing association in the ',  
								registryInstance _symbolDictionary name asString printString, 
								' symbol dictionary with a duplicate key ',
								assoc key printString, 
								' while attempting to add a new class' )
						signal.
					(registryInstance _symbolDictionary associationAt: assoc key) value: class ] ]
		ifAbsent: [
			assoc value: class.
			registryInstance _symbolDictionary add: assoc].
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: registryInstance

	| methodDictionary selector protocolSymbol existing loadedMethod loadedPackage loadedClassExtension |
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	selector := compiledMethod selector.
	methodDictionary at: selector put: compiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [ behavior addCategory: protocolSymbol ].
	behavior moveMethod: selector toCategory: protocolSymbol.

	existing := registryInstance methodRegistry at: compiledMethod ifAbsent: [ nil ].
	existing
		ifNotNil: [ 
			registryInstance
				error:
					'Internal error -- existing LoadedMethod found for extension compiled method.' ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	registryInstance methodRegistry at: compiledMethod put: loadedMethod.

	loadedPackage := Rowan image 
		loadedPackageNamed: packageName 
		ifAbsent: [ self existingOrNewLoadedPackageNamed: packageName instance: registryInstance ].

	loadedClassExtension := loadedPackage
		loadedClassExtensionForClass: behavior
		ifAbsent: [ 
			| class ext |
			class := behavior theNonMetaClass.
			ext := RwGsLoadedSymbolDictClassExtension
				newForClass: class
				inPackage: loadedPackage.
			(registryInstance classExtensionRegistry
				at: class classHistory
				ifAbsentPut: [ IdentitySet new ]) add: ext.
			ext ].
	loadedClassExtension addLoadedMethod: loadedMethod.
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName instance: registryInstance


	"expecting only a single method to be in methDict/catDict"

	| dictsArray mDict cDict existing loadedMethod loadedPackage loadedClassExtension compiledMethod |
	dictsArray := registryInstance homeSessionMethods methodAndCategoryDictionaryFor: behavior.
	mDict := dictsArray at: 1.
	cDict := dictsArray at: 2.
	catDict
		keysAndValuesDo: [ :protocolSymbol :selectors | 
			| symbolSet |
			symbolSet := cDict
				at: protocolSymbol
				ifAbsent: [ cDict at: protocolSymbol put: SymbolSet new ].
			symbolSet addAll: selectors ].
	methDict
		keysAndValuesDo: [ :sel :meth | 
			mDict at: sel put: meth.
			GsPackagePolicy current updateMethodLookupCacheFor: meth in: behavior.
			compiledMethod := meth ].

	existing := registryInstance methodRegistry at: compiledMethod ifAbsent: [ nil ].
	existing
		ifNotNil: [ 
			registryInstance
				error:
					'Internal error -- existing LoadedMethod found for extension compiled method.' ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	registryInstance methodRegistry at: compiledMethod put: loadedMethod.

	loadedPackage := self existingOrNewLoadedPackageNamed: packageName instance: registryInstance.

	loadedClassExtension := loadedPackage
		loadedClassExtensionForClass: behavior
		ifAbsent: [ 
			| class ext |
			class := behavior theNonMetaClass.
			ext := RwGsLoadedSymbolDictClassExtension
				newForClass: class
				inPackage: loadedPackage.
			(registryInstance classExtensionRegistry
				at: class classHistory
				ifAbsentPut: [ IdentitySet new ]) add: ext.
			ext ].
	loadedClassExtension addLoadedMethod: loadedMethod.

	^ compiledMethod
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addMovedDeletedMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: registryInstance

	"there is an existing compiled method that has already been deleted from another package ... so we're adding it
		back using specialized processing"

	| methodDictionary selector |
	methodDictionary := (behavior persistentMethodDictForEnv: 0 ) ifNil:[ Dictionary new ].
	selector := compiledMethod selector.
	methodDictionary 
		at: selector 
		ifAbsent: [  
			registryInstance
				error:
					'Internal error -- attempt to move a method that does not exist'  ].
	self _addMovedDeletedMethod: compiledMethod instance: registryInstance.
	^ self moveCompiledMethod: compiledMethod toProtocol: protocolString instance: registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addNewClassVersionToAssociation: newClass instance: registryInstance

	"a new class version is being added to the association in the receiver previously occupied by the original class"

	^ self 
		_loadedClassFor: newClass
		noNewVersion: [ 
			"newClass is actually not a new class version of existing class, that's okay... update properties anyway"
			self updateClassProperties: newClass instance: registryInstance.
			^ registryInstance ]
		newVersion: [ :loadedClass :assoc | 
			"association for class is present, install in association and update the loadedthing"
			assoc value: newClass.
			loadedClass handleClassDeletionOrNewVersion
				ifTrue: [ loadedClass updatePropertiesFromClassFor: registryInstance ]
				ifFalse: [ registryInstance error: 'internal error - new version of class not properly installed' ] ]
		instance: registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: registryInstance

	| methodDictionary selector protocolSymbol existing loadedMethod loadedPackage loadedClassOrExtension |
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	selector := compiledMethod selector.
	(methodDictionary at: selector ifAbsent: [  ])
		ifNotNil: [ :oldCompiledMethod | 
			"there is an existing compiled method ... that means we're adding a recompiled methoded and moving it to the (possibly new) protocol"
			self addRecompiledMethod: compiledMethod instance: registryInstance.
			^ self 
				moveCompiledMethod: compiledMethod toProtocol: protocolString instance: registryInstance ].
	methodDictionary at: selector put: compiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [ behavior addCategory: protocolSymbol ].
	behavior moveMethod: selector toCategory: protocolSymbol.

	existing := registryInstance methodRegistry at: compiledMethod ifAbsent: [ nil ].
	existing
		ifNotNil: [ registryInstance error: 'Internal error -- existing LoadedMethod found for compiled method.' ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	registryInstance methodRegistry at: compiledMethod put: loadedMethod.

	loadedPackage := self
		loadedPackageNamed: packageName
		ifAbsent: [ 
			registryInstance
				error: 'Internal error -- attempt to add a method to a nonexistent package.' ]
		instance: registryInstance.

	loadedClassOrExtension := loadedPackage
		loadedClassOrClassExtensionForClass: behavior
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- attempt to add a method to a package in which its class is neither defined nor extended.' ].
	loadedClassOrExtension addLoadedMethod: loadedMethod.
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addRecompiledMethod: newCompiledMethod instance: registryInstance

	"add a recompiled compiled method to behavior and update the loaded things"

	| selector behavior methodDictionary oldCompiledMethod loadedMethod |
	selector := newCompiledMethod selector.
	behavior := newCompiledMethod inClass.
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	oldCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- expected an existing compiled method in the method dictionary' ].

	oldCompiledMethod == newCompiledMethod
		ifTrue: [ 
			"exit early, no more work to be done"
			^ registryInstance ].
	methodDictionary at: selector put: newCompiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	loadedMethod := registryInstance methodRegistry
		at: oldCompiledMethod
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for the old compiledMethod.' ].
	registryInstance methodRegistry removeKey: oldCompiledMethod.
	loadedMethod handle: newCompiledMethod.
	registryInstance methodRegistry at: newCompiledMethod put: loadedMethod.
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addRecompiledSessionMethodMethod: newCompiledMethod instance: registryInstance

	"add a recompiled session method compiled method to behavior and update the loaded things"

	| selector behavior dictsArray mDict cDict oldCompiledMethod loadedMethod |
	selector := newCompiledMethod selector.
	behavior := newCompiledMethod inClass.
	dictsArray := registryInstance homeSessionMethods methodAndCategoryDictionaryFor: behavior.
	mDict := dictsArray at: 1.
	cDict := dictsArray at: 2.
	oldCompiledMethod := mDict
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- expected an existing compiled method in the session method method dictionary' ].

	oldCompiledMethod == newCompiledMethod
		ifTrue: [ 
			"exit early, no more work to be done"
			^ registryInstance ].
	mDict at: selector put: newCompiledMethod.
	GsPackagePolicy current
		updateMethodLookupCacheFor: newCompiledMethod
		in: behavior.

	loadedMethod := registryInstance methodRegistry
		at: oldCompiledMethod
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for the old compiledMethod.' ].
	registryInstance methodRegistry removeKey: oldCompiledMethod.
	loadedMethod handle: newCompiledMethod.
	registryInstance methodRegistry at: newCompiledMethod put: loadedMethod
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
createAndInstallLoadedClassForClass: class toPackageNamed: packageName instance: registryInstance

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	| loadedPackage loadedClass |
	loadedPackage := self existingOrNewLoadedPackageNamed: packageName instance: registryInstance.

	registryInstance classRegistry
		at: class classHistory
		ifAbsent: [ 
			loadedClass := RwGsLoadedSymbolDictClass newForClass: class.
			loadedPackage addLoadedClass: loadedClass.
			loadedClass updatePropertiesFromClassFor: registryInstance.
			registryInstance classRegistry at: class classHistory put: loadedClass.
			(loadedPackage loadedClassExtensions at: class name ifAbsent: [  ])
				ifNotNil: [ :loadedClassExtension | 
					"I think we need to subsume the loadedClassExtension methods into a loadedClass ..."
					"have yet to come with a test case that takes this path"
					registryInstance error: 'internal error - unexpected class extenstions for a loaded class ', class name asString printString , ' that has no entry in classRegistry in package ', loadedPackage name printString, '.' ] ].
	^ registryInstance
%

category: 'package - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
createLoadedPackageFromDefinition: packageDefinition instance: registryInstance

	^ self
		createLoadedPackageNamed: packageDefinition key
		properties: packageDefinition properties
		instance: registryInstance
%

category: 'package - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
createLoadedPackageNamed: packageName properties: properties instance: registryInstance 

	| existingLoadedPackage newLoadedPackage |
	existingLoadedPackage := registryInstance packageRegistry at: packageName ifAbsent: [ nil ].
	existingLoadedPackage
		ifNotNil: [ self error: 'Internal error -- Attempt to add a package that exists.' ].
	newLoadedPackage := RwGsLoadedSymbolDictPackage newNamed: packageName.
	newLoadedPackage setPropertiesTo: properties.
	registryInstance packageRegistry at: packageName put: newLoadedPackage.
	^ newLoadedPackage
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteClassFromPackage: class instance: registryInstance

	"a class association is being deleted from the receiver remove it from the loaded things and remove class from system"

	| removeClassFromSystem |
	removeClassFromSystem := RwDeleteClassFromSystemNotification new
		candidateClass: class;
		signal. "handle and `resume: true` if you want class to remain in system, unpackaged"
	^ self _doDeleteClassFromLoadedThings: class removeClassFromSystem: removeClassFromSystem instance: registryInstance
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteClassNamedFromPackage: className instance: registryInstance

	"a class association is being deleted from the receiver remove it from the loaded things"

	| class |
	class := registryInstance _symbolDictionary
		at: className asSymbol
		ifAbsent: [ registryInstance error: 'No class found for the given class name: ' , className printString ].
	^ self deleteClassFromPackage: class instance: registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteCompiledMethod: compiledMethod from: behavior instance: registryInstance

	"delete a compiled method from behavior and remove it from the loaded things"

	self _doDeleteCompiledMethod: compiledMethod from: behavior instance: registryInstance.

	self _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: registryInstance.

	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteMethod: selector for: behavior instance: registryInstance

	| compiledMethod |

	compiledMethod := behavior compiledMethodAt: selector.
	self deleteCompiledMethod: compiledMethod from: behavior instance: registryInstance.
	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteMovedCompiledMethod: compiledMethod from: behavior instance: registryInstance

	"delete a compiled method from behavior - moved method already removed from the loaded things"

	self _doDeleteCompiledMethod: compiledMethod from: behavior instance: registryInstance.

	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteMovedLoadedMethod: selector for: behavior instance: registryInstance

	| compiledMethod |

	compiledMethod := behavior compiledMethodAt: selector.
	self _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: registryInstance.
	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteMovedMethod: selector for: behavior instance: registryInstance

	| compiledMethod |

	compiledMethod := behavior compiledMethodAt: selector.
	self deleteMovedCompiledMethod: compiledMethod from: behavior instance: registryInstance.
	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deletePackage: packageName instance: registryInstance

	| loadedPackage |
	loadedPackage := registryInstance packageRegistry
		removeKey: packageName
		ifAbsent: [ registryInstance error: 'package ' , packageName printString , ' not found' ].
	loadedPackage loadedProject removeLoadedPackage: loadedPackage.
	^ registryInstance
%

category: 'class disown api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
disownClass: class instance: registryInstance

	"Remove the specified class and all of it's packaged instance and class methods from the loaded things."

	self
		_loadedClassFor: class
		noNewVersion: [ :loadedClass | 
			loadedClass disownFromLoaded: registryInstance.
			registryInstance classRegistry removeKey: class classHistory ]
		instance: registryInstance.
	^ registryInstance
%

category: 'class disown api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
disownClassExtensions: class forLoadedPackage: loadedPackage instance: registryInstance

	"Remove the extension methods in the class for the given package"

	| loadedClassExtension |
	loadedClassExtension := loadedPackage
		loadedClassExtensionForClass: class
		ifAbsent: [ self error: 'No class extensions found for the class ', class name asString printString, ' in the package ', loadedPackage name printString ].
	
	loadedClassExtension disownFromLoaded: registryInstance.

	loadedPackage removeLoadedClassExtension: loadedClassExtension.

	^ registryInstance
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
ensureExtensionClassNamed: className existsForPackageNamed: packageName instance: registryInstance

	| extensionClass loadedPackage loadedClassExtension |
	extensionClass := registryInstance _symbolDictionary
		at: className asSymbol
		ifAbsent: [ 
			registryInstance
				error:
					'The extension class named ' , className printString
						, ' cannot be found in this symbol dictionary (' , registryInstance _symbolDictionary name printString
						,
							'). Packages that extend a class must be loaded into the symbol dictionary in which the class is installed.' ].
	loadedPackage := self existingOrNewLoadedPackageNamed: packageName instance: registryInstance.

	loadedPackage
		loadedClassExtensionForClass: extensionClass
		ifAbsent: [ 
			loadedClassExtension := RwGsLoadedSymbolDictClassExtension
				newForClass: extensionClass
				inPackage: loadedPackage.
			(registryInstance classExtensionRegistry
				at: extensionClass classHistory
				ifAbsentPut: [ IdentitySet new ]) add: loadedClassExtension ].
	^ registryInstance
%

category: 'package - creation api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
existingOrNewLoadedPackageNamed: packageName instance: registryInstance

	^ registryInstance packageRegistry
			at: packageName
			ifAbsent: [ 
				registryInstance packageRegistry
					at: packageName
					put: (RwGsLoadedSymbolDictPackage newNamed: packageName) ].
%

category: 'loaded queries'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock instance: registryInstance

	| packageName |
	(hybridPackageName at: 1) = $*
		ifFalse: [ 
			registryInstance
				error:
					'Improperly formed hybrid package name' , hybridPackageName printString
						, '. Expected a leading ''*''' ].
	packageName := (hybridPackageName copyFrom: 2 to: hybridPackageName size)
		asLowercase.
	registryInstance packageRegistry keys
		do: [ :key | 
			key asLowercase = packageName
				ifTrue: [ ^ registryInstance packageRegistry at: key ] ].
	^ absentBlock value
%

category: 'loaded queries'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
loadedPackageNamed: packageName ifAbsent: absentBlock instance: registryInstance

	^ registryInstance packageRegistry at: packageName ifAbsent: absentBlock
%

category: 'class symbol dict - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
moveClassFor: classMove
	" move class from <oldRegistry> to <newRegistry> which includes moveing the loaded methods associated with the class"

	"loaded things are handled elsewhere, just need to update the various registries ... and move the association"

	"extension methods will be dealt with later"

	| originalSymbolDictionary newSymbolDictionary before assoc theClass loadedClass theBehavior oldRegistry newRegistry |

	before := classMove classBefore.
	originalSymbolDictionary := Rowan globalNamed: before gs_symbolDictionary.
	assoc := originalSymbolDictionary associationAt: before key asSymbol.
	theClass := assoc value.
	theBehavior := theClass class.
	oldRegistry := originalSymbolDictionary rowanSymbolDictionaryRegistry.

	newSymbolDictionary := Rowan globalNamed: (classMove projectAfter symbolDictNameForPackageNamed: classMove packageAfter name) .
	newRegistry := newSymbolDictionary rowanSymbolDictionaryRegistry.

	loadedClass := oldRegistry classRegistry removeKey: theClass classHistory.
	originalSymbolDictionary removeKey: assoc key.

	self 
		_symbolDictionary: newSymbolDictionary 
		at: assoc key 
		ifPresent: [:class |
			theClass ~~ class
				ifTrue: [ self error: ' internal error - found an existing association in the ',  
								newSymbolDictionary name asString printString, 
								' symbol dictionary with a duplicate key ',
								assoc key printString, 
								' while attempting to move class ', assoc key asString printString ] ]
		ifAbsent: [ newSymbolDictionary add: assoc ].

	newRegistry classRegistry at: theClass classHistory put: loadedClass.

	loadedClass loadedInstanceMethods values do: [:loadedMethod |
		| compiledMethod |
		compiledMethod := theClass compiledMethodAt: loadedMethod selector asSymbol.
		oldRegistry methodRegistry removeKey: compiledMethod.
		newRegistry methodRegistry at: compiledMethod put: loadedMethod ].
	loadedClass loadedClassMethods values do: [:loadedMethod |
		| compiledMethod |
		compiledMethod := theBehavior compiledMethodAt: loadedMethod selector asSymbol.
		oldRegistry methodRegistry removeKey: compiledMethod.
		newRegistry methodRegistry at: compiledMethod put: loadedMethod ].
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
moveCompiledMethod: compiledMethod toProtocol: newProtocol instance: registryInstance

	"move a compiled method into a different protocol and update loaded things"

	| behavior selector loadedMethod oldCat catSym catDict methodDictionary existingCompiledMethod |
	selector := compiledMethod selector.
	behavior := compiledMethod inClass.

	methodDictionary := (behavior persistentMethodDictForEnv: 0 ) ifNil:[ Dictionary new ].
	existingCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing CompileMethod found for patched method.' ].
	existingCompiledMethod == compiledMethod
		ifFalse: [ 
			registryInstance
				error:
					'Internal error - the existingCompiledMethod is not identical to the compiled method arg' ].

	oldCat := behavior categoryOfSelector: selector environmentId: 0.
	catSym := newProtocol asSymbol.
	catDict := behavior _baseCategorysForStore: 0.
	oldCat ifNotNil: [ (catDict at: oldCat) remove: selector ].
	catDict
		at: catSym
		ifAbsent: [ behavior addCategory: newProtocol environmentId: 0 ].
	(catDict at: catSym) add: selector.

	behavior moveMethod: selector toCategory: newProtocol environmentId: 0.

	loadedMethod := registryInstance methodRegistry
		at: compiledMethod
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for the compiledMethod.' ].

	loadedMethod updateForProtocolChange.
	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
movePackage: packageName to: symbolDictionaryName instance: fromRegistryInstance

	| loadedPackage toRegistryInstance |
	loadedPackage := fromRegistryInstance packageRegistry
		removeKey: packageName
		ifAbsent: [ fromRegistryInstance error: 'package ' , packageName printString , ' not found' ].
	toRegistryInstance := (Rowan image newOrExistingSymbolDictionaryNamed: symbolDictionaryName) rowanSymbolDictionaryRegistry.
	(toRegistryInstance packageRegistry at: packageName ifAbsent: [])
		ifNotNil: [:unexpectedLoadedPackage | toRegistryInstance error: 'package ', packageName printString, ' unexpectedly found in ', symbolDictionaryName printString ].
	toRegistryInstance packageRegistry at: packageName put: loadedPackage.
	^ fromRegistryInstance
%

category: 'package - creation api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
newLoadedPackageNamed: packageName instance: registryInstance

	(registryInstance packageRegistry includesKey: packageName)
		ifTrue: [ registryInstance error: 'The package ', packageName printString, ' already exists' ].
	^ registryInstance existingOrNewLoadedPackageNamed: packageName implementationClass: self
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
updateClassProperties: class instance: registryInstance

	"class properties have changed, update the clas properties of the loaded things"

	(class isKindOf: Class)
		ifFalse: [ registryInstance error: 'internal error - expected a class' ].
	registryInstance
		_loadedClassFor: class
		noNewVersion: [ :loadedClass | 
			"association for class is present, update the loaded thing"
			loadedClass updatePropertiesFromClassFor: registryInstance ].
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_addMovedDeletedMethod: newCompiledMethod  instance: registryInstance

	"add a recompiled compiled method that was previously removed from loaded things
		to behavior and update the loaded things appropriately"

	| selector behavior methodDictionary oldCompiledMethod loadedMethod |
	selector := newCompiledMethod selector.
	behavior := newCompiledMethod inClass.
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	oldCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- expected an existing compiled method in the method dictionary' ].

	oldCompiledMethod == newCompiledMethod
		ifTrue: [ 
			"exit early, no more work to be done"
			^ registryInstance ].
	methodDictionary at: selector put: newCompiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	loadedMethod := registryInstance methodRegistry
		at: oldCompiledMethod
		ifAbsent: [].
	loadedMethod ifNotNil: [  
			registryInstance
				error:
					'Internal error -- unexpected loaded method found - deleteMethod processing should have removed the loaded method already' ].

	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: newCompiledMethod.

	registryInstance methodRegistry at: newCompiledMethod put: loadedMethod.
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_clearLookupCachesFor: aBehavior env: envId

"Invalidates method lookup caches for all classes.
 Invalidates all send-site caches for the specified environment.

 envId must be a SmallInteger >= 0 and <= 255 .
"

 "set bit in VM's cbCodeChanged word so it can propagate to
  other VMs upon commit.  Code which adds or removes entries
  in persistent method dictionaries must send this method. "

	aBehavior 
		_clearLookupCaches: envId;
		_codeChangedForEnv: envId
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_doDeleteClassFromLoadedThings: class removeClassFromSystem: removeClassFromSystem instance: registryInstance

	"a class association is being deleted from the receiver remove it from the loaded things. Conditionally remove class from system"

	self
		_loadedClassFor: class
		noNewVersion: [ :loadedClass | 
			"association for class is present, finish delete operation"
			loadedClass removeFromLoaded: registryInstance.
			registryInstance classRegistry removeKey: class classHistory.
			removeClassFromSystem ifTrue: [ registryInstance _symbolDictionary removeKey: loadedClass key asSymbol ] ]
		instance: registryInstance.
	^ registryInstance
%

category: 'method - private api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_doDeleteCompiledMethod: compiledMethod from: behavior instance: registryInstance

	"delete a compiled method from behavior"

	| selector |
	selector := compiledMethod selector.
	behavior removeSelector: selector asString environmentId: 0.

	^ registryInstance
%

category: 'method - private api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: registryInstance

	"remove a compiled method from loaded things"

	| loadedMethod loadedPackage loadedClassOrExtension |
	loadedMethod := registryInstance methodRegistry
		at: compiledMethod
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for deleted method.' ].

	registryInstance methodRegistry removeKey: compiledMethod.

	loadedPackage := loadedMethod loadedPackage.
	loadedClassOrExtension := loadedPackage
		classOrExtensionForClass: behavior
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- attempt to remove a method from a package in which its class is neither defined nor extended.' ].

	loadedClassOrExtension removeLoadedMethod: loadedMethod.
	loadedClassOrExtension isLoadedClassExtension
		ifTrue: [
			loadedClassOrExtension isEmpty
				ifTrue: [ 
					| theKey classExtensionRegistry |
					theKey := loadedClassOrExtension handle classHistory.
					classExtensionRegistry := registryInstance classExtensionRegistry.
					(classExtensionRegistry at: theKey) remove: loadedClassOrExtension.
					(classExtensionRegistry at: theKey) isEmpty
						ifTrue: [ classExtensionRegistry removeKey: theKey ].
					loadedPackage removeLoadedClassExtension: loadedClassOrExtension ] ].

	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_loadedClassFor: class noNewVersion: noNewVersionBlock instance: registryInstance

	self
		_loadedClassFor: class
		noNewVersion: noNewVersionBlock
		newVersion: [ :loadedClass | 
			self
				error:
					'internal error - the value associated with the key ' , class name printString
						, ' is not identical to the given class' ]
		instance: registryInstance.
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_loadedClassFor: class noNewVersion: noNewVersionBlock newVersion: newVersionBlock instance: registryInstance

	| loadedClass classKey |
	(class isKindOf: Class)
		ifFalse: [ registryInstance error: 'internal error - expected a class' ].
	loadedClass := registryInstance classRegistry
		at: class classHistory
		ifAbsent: [ 
			registryInstance
				error:
					'internal error - No package found for the class ' , class name printString ].
	classKey := loadedClass key asSymbol.
	self
		_symbolDictionary: registryInstance _symbolDictionary
		associationAt: classKey
		ifPresent: [ :assoc | 
			assoc value == class
				ifTrue: [ ^ noNewVersionBlock cull: loadedClass cull: assoc ]
				ifFalse: [ ^ newVersionBlock cull: loadedClass cull: assoc ] ].

	registryInstance
		error:
			'internal error - there is no assocation present in the receiver for the given class '
				, classKey asString printString.
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_symbolDictionary: symbolDictionary associationAt: aKey ifPresent: oneArgBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the symbol association associated with the key, otherwise answer nil."

	| anAssoc |
	anAssoc := symbolDictionary associationAt: aKey otherwise: nil.
	anAssoc ifNotNil: [ ^ oneArgBlock cull: anAssoc ].
	^ nil
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_symbolDictionary: symbolDictionary associationAt: key ifPresent: oneArgBlock ifAbsent: absentBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the symbol association associated with the key, otherwise answer the value of absentBlock."

	self
		_symbolDictionary: symbolDictionary 
		associationAt: key
		ifPresent: [ :v | ^ oneArgBlock cull: v ].
	^ absentBlock value
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_symbolDictionary: symbolDictionary at: key ifPresent: oneArgBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v := symbolDictionary at: key ifAbsent: [ ^ nil ].
	^ oneArgBlock cull: v
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_symbolDictionary: symbolDictionary at: key ifPresent: oneArgBlock ifAbsent: absentBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the value associated with the key, otherwise answer the value of absentBlock."

	| v |
	v := symbolDictionary at: key ifAbsent: [ ^absentBlock value ].
	^ oneArgBlock cull: v
%

! Class implementation for 'RwLoadedThing'

!		Class methods for 'RwLoadedThing'

category: 'accessing'
classmethod: RwLoadedThing
absentToken

	^AbsentToken
%

category: 'class initialization'
classmethod: RwLoadedThing
initialize
  "RwLoadedThing initialize"

  AbsentToken := '<absent>'
%

category: 'instance creation'
classmethod: RwLoadedThing
newNamed: aName

	^(self new)
		initialize;
		initializeForName: aName;
		yourself
%

!		Instance methods for 'RwLoadedThing'

category: 'accessing'
method: RwLoadedThing
absentToken

	^AbsentToken
%

category: 'private'
method: RwLoadedThing
definitionsFor: loadedThings

	| result |
	result := Dictionary new: loadedThings size.
	loadedThings
		do: [:loadedThing | result at: loadedThing key put: loadedThing asDefinition].
	^result
%

category: 'accessing'
method: RwLoadedThing
handle
	"Answer a reference to the platform-specific image object for which I hold information."

	^handle
%

category: 'accessing'
method: RwLoadedThing
handle: anObject
	"Set my reference to the platform-specific image object for which I hold information."

	self markPackageDirty.
	handle := anObject
%

category: 'initialization'
method: RwLoadedThing
initialize

	properties := Dictionary new
%

category: 'initialization'
method: RwLoadedThing
initializeForName: aName

	name := aName
%

category: 'accessing'
method: RwLoadedThing
loadedPackage

	^ self subclassResponsibility: #'loadedPackage'
%

category: 'accessing'
method: RwLoadedThing
loadedProject

	^ self loadedPackage loadedProject
%

category: 'accessing'
method: RwLoadedThing
name

	^name
%

category: 'accessing'
method: RwLoadedThing
name: aString

	self markPackageDirty.
	name := aString
%

category: 'accessing'
method: RwLoadedThing
prettyName

	^self name
%

category: 'printing'
method: RwLoadedThing
printOn: aStream

	super printOn: aStream.
	name
		ifNotNil: 
			[aStream
				space;
				nextPutAll: name]
%

category: 'private'
method: RwLoadedThing
propertiesForDefinition

	^properties copy
%

category: 'accessing'
method: RwLoadedThing
propertyAt: propertyName

	^properties at: propertyName ifAbsent: [AbsentToken]
%

category: 'accessing'
method: RwLoadedThing
propertyAt: propertyName ifAbsent: aBlock

	^properties at: propertyName ifAbsent: aBlock
%

category: 'accessing'
method: RwLoadedThing
propertyAt: propertyName put: aValue
	"Value should be a string"

	self markPackageDirty.
	^properties at: propertyName put: aValue
%

category: 'accessing'
method: RwLoadedThing
removeProperty: propertyName

	self markPackageDirty.
	^properties removeKey: propertyName ifAbsent: [AbsentToken]
%

category: 'accessing'
method: RwLoadedThing
setPropertiesTo: aDictionary

	properties := aDictionary copy
%

! Class implementation for 'RwLoadedClass'

!		Instance methods for 'RwLoadedClass'

category: 'definitions'
method: RwLoadedClass
asDefinition
	"Create a Definition corresponding to what I define in the image."
	^RwClassDefinition
		withProperties: self propertiesForDefinition
		classMethodDefinitions: self classMethodDefinitions
		instanceMethodDefinitions: self instanceMethodDefinitions
%

category: 'accessing'
method: RwLoadedClass
classCategory

	^self propertyAt: 'category'
%

category: 'accessing'
method: RwLoadedClass
classClassVarNames

	^self propertyAt: 'classvars'
%

category: 'accessing'
method: RwLoadedClass
classComment

	^self propertyAt: 'comment' ifAbsent: ['']
%

category: 'accessing'
method: RwLoadedClass
classInstVarNames

	^self propertyAt: 'instvars'
%

category: 'private'
method: RwLoadedClass
classMethodDefinitions

	^self definitionsFor: loadedClassMethods
%

category: 'accessing'
method: RwLoadedClass
classPoolDictionaries

	^self propertyAt: 'pools'
%

category: 'accessing'
method: RwLoadedClass
classSuperclass

	^self propertyAt: 'superclass'
%

category: 'accessing'
method: RwLoadedClass
classSymbolDictionaryName

	^self propertyAt: 'gs_SymbolDictionary'
%

category: 'testing'
method: RwLoadedClass
includesSelector: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods includesKey: aSelector ]
		ifFalse: [ loadedInstanceMethods includesKey: aSelector ]
%

category: 'private'
method: RwLoadedClass
instanceMethodDefinitions

	^self definitionsFor: loadedInstanceMethods
%

category: 'testing'
method: RwLoadedClass
isEmpty

	^loadedInstanceMethods isEmpty and: [loadedClassMethods isEmpty]
%

category: 'testing'
method: RwLoadedClass
isLoadedClass

	^ true
%

category: 'testing'
method: RwLoadedClass
isLoadedClassExtension

	^ false
%

category: 'accessing'
method: RwLoadedClass
loadedClassMethods

	^ loadedClassMethods
%

category: 'accessing'
method: RwLoadedClass
loadedInstanceMethods 

	^ loadedInstanceMethods
%

category: 'enumeration'
method: RwLoadedClass
loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedInstanceMethods
		valuesDo: [ :loadedMethod | 
			loadedInstanceMethodBlock
				cull:  self loadedProject
				cull: self loadedPackage
				cull: self 
				cull: loadedMethod
				
	].
	loadedClassMethods
		valuesDo: [ :loadedMethod | 
			loadedClassMethodBlock
				cull: self loadedProject
				cull: self loadedPackage
				cull: self 
				cull: loadedMethod
	]
%

category: 'testing'
method: RwLoadedClass
loadedMethodAt: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods at: aSelector ifAbsent: [nil]]
		ifFalse: [ loadedInstanceMethods at: aSelector ifAbsent: [nil] ]
%

category: 'accessing'
method: RwLoadedClass
loadedPackage

	^loadedPackage
%

category: 'accessing'
method: RwLoadedClass
loadedPackage: aLoadedPackage

	loadedPackage := aLoadedPackage
%

category: 'private'
method: RwLoadedClass
markPackageDirty

	loadedPackage markDirty
%

category: 'accessing'
method: RwLoadedClass
packageName

	^loadedPackage name
%

category: 'other'
method: RwLoadedClass
prettyName

	^' class ', self name
%

! Class implementation for 'RwGsLoadedSymbolDictClass'

!		Class methods for 'RwGsLoadedSymbolDictClass'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictClass
newForClass: aClass

	^self new initializeForClass: aClass
%

!		Instance methods for 'RwGsLoadedSymbolDictClass'

category: 'methods'
method: RwGsLoadedSymbolDictClass
addLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
addLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
addLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self addLoadedClassMethod: aLoadedMethod]
		ifFalse: [self addLoadedInstanceMethod: aLoadedMethod]
%

category: 'removing'
method: RwGsLoadedSymbolDictClass
disownFromLoaded: aPackageSymbolDictionary

	loadedInstanceMethods
		valuesDo: [ :loadedInstanceMethod | 
			self removeLoadedInstanceMethod: loadedInstanceMethod.
			aPackageSymbolDictionary methodRegistry
				removeKey: loadedInstanceMethod handle ].
	loadedClassMethods
		valuesDo: [ :loadedClassMethod | 
			self removeLoadedClassMethod: loadedClassMethod.
			aPackageSymbolDictionary methodRegistry removeKey: loadedClassMethod handle ].
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
handleClassDeletion

	"The class to which I refer has been deleted, so I must unregister myself.
	Normally, I will have a loadedPackage, but if something interrupted my initialization it might be nil."

	GsPackagePolicy currentOrNil
		ifNotNil: [ :pp | 
			pp
				removeAllMethodsFor: handle;
				removeAllMethodsFor: handle class ].
	(Rowan image loadedClassExtensionsForClass: handle)
		do: [ :loadedClassExtension | loadedClassExtension handleClassDeletion ].
	Rowan image removeLoadedClassExtensionsForClass: handle.
	self loadedPackage removeLoadedClass: self
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
handleClassDeletionOrNewVersion

	"The class is deleted if both:
	* its name no longer resolves to a class in the classHistory of the class I remember.
	* no class in the classHistory of the class I remember is accessible under its name.
	If my name no longer resolves to my class, but another class in its classHistory does resolve,
	consider it a class re-version or rename.
	Answer true if the class still exists, false if it has been deleted."

	| resolved thoseResolving |
	resolved := Rowan image resolveClassNamed: name.
	resolved == handle
		ifTrue: [ ^ true ].	"Has been deleted, renamed, or a new version under the same name.
	Answer false if deleted, set handle and answer true otherwise."
	thoseResolving := handle classHistory reverse
		select: [ :aClass | aClass == (Rowan image resolveClassNamed: aClass name) ].
	thoseResolving size = 0
		ifTrue: [ 
			self handleClassDeletion.
			^ false ].
	thoseResolving size > 1
		ifTrue: [ 
			RwNotification
				signal:
					'Class history with multiple "current" members found. One associated name is '
						, name ].
	handle := thoseResolving first.
	^ true
%

category: 'initialization'
method: RwGsLoadedSymbolDictClass
initialize

	super initialize.
	loadedInstanceMethods := KeyValueDictionary new.
	loadedClassMethods := KeyValueDictionary new
%

category: 'initialization'
method: RwGsLoadedSymbolDictClass
initializeForClass: aClass

	self initialize.
	self initializeForName: aClass name asString.
	handle := aClass
%

category: 'initialization'
method: RwGsLoadedSymbolDictClass
initializeForName: aClassName

	super initializeForName: aClassName.
	properties at: 'name' put: aClassName
%

category: 'accessing'
method: RwGsLoadedSymbolDictClass
key
	"Answer some token that will uniquely identify me relative to any other LoadedClass in the same package."

	^name
%

category: 'removing'
method: RwGsLoadedSymbolDictClass
removeFromLoaded: aPackageSymbolDictionary

	self disownFromLoaded: aPackageSymbolDictionary.
	self handleClassDeletion
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
removeLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in loadedClass']
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
removeLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in loadedClass']
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
removeLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self removeLoadedClassMethod: aLoadedMethod]
		ifFalse: [self removeLoadedInstanceMethod: aLoadedMethod]
%

category: 'private'
method: RwGsLoadedSymbolDictClass
symbolDictionaryName: aName

	self propertyAt: 'gs_SymbolDictionary' put: aName asString
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateCategoryFromClass

	| propertyName oldValue newValue absentToken |
	propertyName := 'category'.
	absentToken := self absentToken.
	oldValue := self propertyAt: propertyName.
	newValue := handle _classCategory ifNil: [ absentToken ].
	(newValue ~~ absentToken and: [ newValue isEmpty ])
		ifTrue: [ newValue := absentToken ].	"Absent token must be compared by identity, because a comment of '<absent>' would be equal to no comment."
	(oldValue == absentToken | (newValue == absentToken)
		ifTrue: [ oldValue == newValue ]
		ifFalse: [ oldValue = newValue ])
		ifFalse: [ 
			newValue == absentToken
				ifTrue: [ self removeProperty: propertyName ]
				ifFalse: [ self propertyAt: propertyName put: newValue ] ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassInstvarNamesFromClass
	"Order of instvars does not matter to Cypress (at least not in GemStone) so we keep the instvar names sorted."

	| propertyName oldNames newNames |
	propertyName := 'classinstvars'.
	oldNames := self propertyAt: propertyName.
	newNames := handle class instVarNames collect: [:each | each asString].
	oldNames = newNames ifFalse: [self propertyAt: propertyName put: newNames]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassNameFromClass

	| oldName newName |
	oldName := name.
	newName := handle name asString.
	oldName = newName
		ifFalse: 
			[self name: newName.
			self propertyAt: 'name' put: name]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassTypeFromClass
	"For GemStone, the valid values are:
	bytes
	variable
	normal for non-indexable pointer object"

	"Must be in-synch with RwGsClassCreationPatch>>basicCreateClassFor:"

	| propertyName oldValue newValue |
	propertyName := 'type'.
	oldValue := self propertyAt: propertyName.
	newValue := handle isBytes
						ifTrue: [
							handle superClass isBytes not
								ifTrue: [ 'bytes' ]
								ifFalse: [ 'normal' ]]
						ifFalse: [ 
							handle isSpecial
								ifTrue: [ 'immediate' ]
								ifFalse: 
									[ handle isNsc
										ifTrue: [ 'normal' ]
										ifFalse:  [
											(handle isVariable and: [handle superClass isVariable not])
												ifTrue: [ 'variable' ]
												ifFalse: [ 'normal' ] ] ] ].

	oldValue = newValue
		ifFalse: 
			[ self propertyAt: propertyName put: newValue ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassVariableNamesFromClass
	"Order of variable names does not matter to Cypress (at least not for GemStone) so we keep the names sorted."

	| propertyName oldNames newNames |
	propertyName := 'classvars'.
	oldNames := self propertyAt: propertyName.
	newNames := (handle classVarNames collect: [:each | each asString])
				asSortedCollection asArray.
	oldNames = newNames ifFalse: [self propertyAt: propertyName put: newNames]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateCommentFromClass

	| propertyName oldValue newValue absentToken |
	propertyName := 'comment'.
	absentToken := self absentToken.
	oldValue := self propertyAt: propertyName.
	(oldValue ~~ absentToken and: [oldValue isEmpty])
		ifTrue: [oldValue := absentToken].
	newValue := (handle _extraDictAt: #comment) ifNil: [absentToken].
	(newValue ~~ absentToken and: [newValue isEmpty])
		ifTrue: [newValue := absentToken].

	"Absent token must be compared by identity, because a comment of '<absent>' would be equal to no comment."
	(oldValue == absentToken | (newValue == absentToken)
		ifTrue: [oldValue == newValue]
		ifFalse: [oldValue = newValue])
			ifFalse: 
				[newValue == absentToken
					ifTrue: [self removeProperty: propertyName]
					ifFalse: [self propertyAt: propertyName put: newValue]]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateConstraintsFromClass
	| propertyName oldValue newValue sortedConstraints |
	propertyName := 'gs_constraints'.
	oldValue := self propertyAt: propertyName.
	sortedConstraints := handle _rwSortedConstraints.
	(sortedConstraints isKindOf: Array ) 
		ifTrue: [
			newValue := (sortedConstraints collect: [:ar | 
					(ar isKindOf: Array )
						ifTrue: [ {(ar at: 1) asString . (ar at: 2) name asString } ]
						ifFalse: [ 
							"varyingConstraint"
							ar name asString ] ]) asArray.
			newValue isEmpty ifTrue: [newValue := self absentToken] ]
		ifFalse: [
			newValue :=  sortedConstraints 
				ifNil: [ self absentToken ]
				ifNotNil: [ sortedConstraints ] ].

	"Since the absent token is not equal to any other valid value, we can skip the identity check in this case."
	oldValue = newValue
		ifFalse: 
			[newValue == self absentToken
				ifTrue: [self removeProperty: propertyName]
				ifFalse: [self propertyAt: propertyName put: newValue]]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateInstvarNamesFromClass
	"Order of instvars does not matter to Cypress (at least not in GemStone) so we keep the instvar names sorted."

	| propertyName oldNames newNames |
	propertyName := 'instvars'.
	oldNames := self propertyAt: propertyName.
	newNames := handle instVarNames collect: [:each | each asString].
	oldNames = newNames ifFalse: [self propertyAt: propertyName put: newNames]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateOptionsFromClass
	"Options are GemStone-specific. If the class has no options, the property is absent.
	Otherwise, the property is a sorted array of strings. The valid values are:

	dbTransient
	disallowGciStore
	instancesInvariant
	instancesNonPersistent
	modifiable
	subclassesDisallowed
	traverseByCallback

	Not all combinations are legal, but we don't have to worry about that here, since we're getting the values
	from the image, and the image is trusted to only have valid values."

	| propertyName oldValue newValue |
	propertyName := 'gs_options'.
	oldValue := self propertyAt: propertyName.
	newValue := (handle _rwOptionsArray collect: [:option | option asString])
				asSortedCollection asArray.
	newValue isEmpty ifTrue: [newValue := self absentToken].

	"Since the absent token is not equal to any other valid value, we can skip the identity check in this case."
	oldValue = newValue
		ifFalse: 
			[newValue == self absentToken
				ifTrue: [self removeProperty: propertyName]
				ifFalse: [self propertyAt: propertyName put: newValue]]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updatePoolDictionaryNamesFromClass
	"Order of pool dictionaries *does* matter in GemStone, so we keep the names in the order given in the image."

	| propertyName oldNames newNames |
	propertyName := 'pools'.
	oldNames := self propertyAt: propertyName.
	newNames := (handle sharedPools collect: [ :each | each name asString ])
		asArray.
	oldNames = newNames
		ifFalse: [ self propertyAt: propertyName put: newNames ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updatePropertiesFromClassFor: aSymbolDictionaryRegistry

	"Update my properties from the class. Leave unknown properties alone, they may apply to another platform."

	self
		updateSymbolDictionaryFromClassFor:
				aSymbolDictionaryRegistry _symbolDictionary;
		updateClassNameFromClass;
		updateSuperclassNameFromClass;
		updateInstvarNamesFromClass;
		updateClassInstvarNamesFromClass;
		updateClassVariableNamesFromClass;
		updatePoolDictionaryNamesFromClass;
		updateClassTypeFromClass;
		updateOptionsFromClass;
		updateConstraintsFromClass;
		updateCommentFromClass;
		updateCategoryFromClass
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateSuperclassNameFromClass
  | oldName newName |
  oldName := self propertyAt: 'superclass'.
  newName := handle superclass
    ifNil: [ 'nil' ]
    ifNotNil: [ :superclass | superclass name asString ].
  oldName = newName
    ifFalse: [ self propertyAt: 'superclass' put: newName ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateSymbolDictionaryFromClassFor: aSymbolDictionary

	| newName oldName |
	newName := aSymbolDictionary name.
	oldName := self propertyAt: 'gs_SymbolDictionary'.
	oldName = newName
		ifFalse: [ self symbolDictionaryName: newName ]
%

! Class implementation for 'RwLoadedClassExtension'

!		Instance methods for 'RwLoadedClassExtension'

category: 'definitions'
method: RwLoadedClassExtension
asDefinition
	"Create a Definition corresponding to what I define in the image."
	^RwClassExtensionDefinition
		withProperties: self propertiesForDefinition
		classMethodDefinitions: self classMethodDefinitions
		instanceMethodDefinitions: self instanceMethodDefinitions
%

category: 'private'
method: RwLoadedClassExtension
classMethodDefinitions

	^self definitionsFor: loadedClassMethods
%

category: 'testing'
method: RwLoadedClassExtension
includesSelector: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods includesKey: aSelector ]
		ifFalse: [ loadedInstanceMethods includesKey: aSelector ]
%

category: 'private'
method: RwLoadedClassExtension
instanceMethodDefinitions

	^self definitionsFor: loadedInstanceMethods
%

category: 'testing'
method: RwLoadedClassExtension
isEmpty

	^loadedInstanceMethods isEmpty and: [loadedClassMethods isEmpty]
%

category: 'testing'
method: RwLoadedClassExtension
isLoadedClass

	^ false
%

category: 'testing'
method: RwLoadedClassExtension
isLoadedClassExtension

	^ true
%

category: 'accessing'
method: RwLoadedClassExtension
loadedClassMethods

	^ loadedClassMethods
%

category: 'accessing'
method: RwLoadedClassExtension
loadedInstanceMethods 

	^ loadedInstanceMethods
%

category: 'enumeration'
method: RwLoadedClassExtension
loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedInstanceMethods
		valuesDo: [ :loadedMethod | 
			loadedInstanceMethodBlock
				cull: self loadedProject 
				cull: self loadedPackage
				cull: self 
				cull: loadedMethod
				
	].
	loadedClassMethods
		valuesDo: [ :loadedMethod | 
			loadedClassMethodBlock
				cull: self loadedProject
				cull: self loadedPackage
				cull: self 
				cull: loadedMethod 
				
	].
%

category: 'private'
method: RwLoadedClassExtension
loadedMethodAt: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods at: aSelector ifAbsent: [nil]]
		ifFalse: [ loadedInstanceMethods at: aSelector ifAbsent: [nil] ]
%

category: 'accessing'
method: RwLoadedClassExtension
loadedPackage

	^loadedPackage
%

category: 'accessing'
method: RwLoadedClassExtension
loadedPackage: aLoadedPackage

	loadedPackage := aLoadedPackage
%

category: 'private'
method: RwLoadedClassExtension
markPackageDirty

	loadedPackage markDirty
%

category: 'accessing'
method: RwLoadedClassExtension
packageName

	^loadedPackage name
%

! Class implementation for 'RwGsLoadedSymbolDictClassExtension'

!		Class methods for 'RwGsLoadedSymbolDictClassExtension'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictClassExtension
newForClass: aClass inPackage: aLoadedPackage

	^ self new initializeForClass: aClass inPackage: aLoadedPackage
%

!		Instance methods for 'RwGsLoadedSymbolDictClassExtension'

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
addLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
addLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
addLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self addLoadedClassMethod: aLoadedMethod]
		ifFalse: [self addLoadedInstanceMethod: aLoadedMethod]
%

category: 'removing'
method: RwGsLoadedSymbolDictClassExtension
disownFromLoaded: aPackageSymbolDictionary

	loadedInstanceMethods
		valuesDo: [ :loadedInstanceMethod | 
			self removeLoadedInstanceMethod: loadedInstanceMethod.
			aPackageSymbolDictionary methodRegistry
				removeKey: loadedInstanceMethod handle ].
	loadedClassMethods
		valuesDo: [ :loadedClassMethod | 
			self removeLoadedClassMethod: loadedClassMethod.
			aPackageSymbolDictionary methodRegistry removeKey: loadedClassMethod handle ].

	(aPackageSymbolDictionary classExtensionRegistry at: handle classHistory) remove: self.
	(aPackageSymbolDictionary classExtensionRegistry at: handle classHistory) isEmpty
		ifTrue: [ aPackageSymbolDictionary classExtensionRegistry removeKey: handle classHistory ].
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClassExtension
handleClassDeletion

	"The class to which I refer is or has been deleted. Clean up the loaded extension methods.
		I expect the caller to remove me from the registry."

	loadedInstanceMethods values , loadedClassMethods values
		do: [ :loadedMethod | loadedMethod handleClassDeletion ].
	self loadedPackage removeLoadedClassExtension: self
%

category: 'initialization'
method: RwGsLoadedSymbolDictClassExtension
initialize

	super initialize.
	loadedInstanceMethods := KeyValueDictionary new.
	loadedClassMethods := KeyValueDictionary new
%

category: 'initialization'
method: RwGsLoadedSymbolDictClassExtension
initializeForClass: aClass inPackage: aLoadedPackage

	self initialize.
	name := aClass name asString.
	handle := aClass.
	aLoadedPackage addLoadedClassExtension: self.
	self propertyAt: 'name' put: name
%

category: 'accessing'
method: RwGsLoadedSymbolDictClassExtension
key
	"Answer some token that will uniquely identify me relative to any other LoadedExtendedClass in the same package."

	^name
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
removeLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in LoadedClassExtension']
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
removeLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in LoadedClassExtension']
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
removeLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self removeLoadedClassMethod: aLoadedMethod]
		ifFalse: [self removeLoadedInstanceMethod: aLoadedMethod]
%

! Class implementation for 'RwLoadedMethod'

!		Instance methods for 'RwLoadedMethod'

category: 'definitions'
method: RwLoadedMethod
asDefinition
	"Create a Definition corresponding to what I define in the image."

	^RwMethodDefinition withProperties: self propertiesForDefinition
		source: self source
%

category: 'accessing'
method: RwLoadedMethod
classIsMeta

	^classIsMeta
%

category: 'accessing'
method: RwLoadedMethod
classIsMeta: aBoolean

	classIsMeta := aBoolean
%

category: 'queries'
method: RwLoadedMethod
loadedClass

	^loadedClass
%

category: 'accessing'
method: RwLoadedMethod
loadedClass: aLoadedClass

	loadedClass := aLoadedClass
%

category: 'queries'
method: RwLoadedMethod
loadedPackage

	^self loadedClass loadedPackage
%

category: 'private'
method: RwLoadedMethod
markPackageDirty
	"LoadedClass may still be nil if we're creating a new LoadedMethod."

	loadedClass ifNotNil: [loadedClass markPackageDirty]
%

category: 'accessing'
method: RwLoadedMethod
methodCategory

	^ properties at: 'protocol'
%

category: 'definitions'
method: RwLoadedMethod
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at: 'selector' put: name.
	^props
%

category: 'accessing'
method: RwLoadedMethod
selector

	^ properties at: 'selector'
%

category: 'accessing'
method: RwLoadedMethod
source

	self subclassResponsibility
%

! Class implementation for 'RwGsLoadedSymbolDictMethod'

!		Class methods for 'RwGsLoadedSymbolDictMethod'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictMethod
forMethod: aGsNMethod

	| instance |
	instance := self newNamed: aGsNMethod selector.
	instance
		handle: aGsNMethod;
		updateFromHandle.
	^ instance
%

!		Instance methods for 'RwGsLoadedSymbolDictMethod'

category: 'private'
method: RwGsLoadedSymbolDictMethod
definingPackageOfClass

	^loadedClass loadedPackage
%

category: 'private-updating'
method: RwGsLoadedSymbolDictMethod
handleClassDeletion

	"The class to which I refer has been deleted, so I must unregister myself."

	Rowan image removeLoadedMethodForCompileMethod: handle
%

category: 'accessing'
method: RwGsLoadedSymbolDictMethod
key

	"Answer some token that will uniquely identify me relative to any other LoadedMethod in the same LoadedClass."

	^ name	"This is inadequate because the same selector can be defined in both class and metaclass?"
%

category: 'accessing'
method: RwGsLoadedSymbolDictMethod
source

	^handle sourceString copy
%

category: 'private-updating'
method: RwGsLoadedSymbolDictMethod
updateForProtocolChange
	"Check to see whether I'm in a different protocol. If I am, that could change which package I'm in and I need to update that."

	| oldProtocol newProtocol |
	oldProtocol := self propertyAt: 'protocol'.
	newProtocol := (handle inClass categoryOfSelector: handle selector)
				asString.

	"Must test for AbsentToken by identity, or a new protocol of '<absent>' would not  be detected."
	oldProtocol == AbsentToken | (oldProtocol ~= newProtocol)
		ifTrue: [	self propertyAt: 'protocol' put: newProtocol ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictMethod
updateFromHandle

	"update method properties: selector and protocol, and classIsMeta"

	self updateForProtocolChange.
	self propertyAt: 'selector' put: handle selector asSymbol.
	classIsMeta := handle inClass isMeta
%

! Class implementation for 'RwLoadedPackage'

!		Instance methods for 'RwLoadedPackage'

category: 'accessing'
method: RwLoadedPackage
addLoadedClass: aLoadedClass

	self markDirty.
	loadedClasses at: aLoadedClass key put: aLoadedClass.
	aLoadedClass loadedPackage: self
%

category: 'accessing'
method: RwLoadedPackage
addLoadedClassExtension: aLoadedClassExtension

	self markDirty.
	loadedClassExtensions at: aLoadedClassExtension key
		put: aLoadedClassExtension.
	aLoadedClassExtension loadedPackage: self
%

category: 'definitions'
method: RwLoadedPackage
asDefinition
	"Create a Definition corresponding to what I define in the image."

	^RwPackageDefinition
		withProperties: self propertiesForDefinition
		classDefinitions: self classDefinitions
		classExtensions: self classExtensionDefinitions
%

category: 'other'
method: RwLoadedPackage
asExtensionName

	^'*', self name asLowercase
%

category: 'private'
method: RwLoadedPackage
classDefinitions
	"Create definitions from all of the classes I define, and answer the collection of them"

	^self definitionsFor: loadedClasses
%

category: 'private'
method: RwLoadedPackage
classExtensionDefinitions
	"Create definitions from all of the class extensions I define, and answer the collection of them"

	^self definitionsFor: loadedClassExtensions
%

category: 'queries'
method: RwLoadedPackage
classOrExtensionForClassNamed: className ifAbsent: absentBlock

	^loadedClasses at: className
		ifAbsent: [loadedClassExtensions at: className ifAbsent: absentBlock]
%

category: 'testing'
method: RwLoadedPackage
isDirty

	^ isDirty
%

category: 'testing'
method: RwLoadedPackage
isEmpty

	^loadedClasses isEmpty and: [loadedClassExtensions isEmpty]
%

category: 'accessing'
method: RwLoadedPackage
key

	^ name
%

category: 'enumeration'
method: RwLoadedPackage
loadedClassedDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedClasses
		valuesDo: [ :loadedClass | 
			loadedClassBlock cull: self loadedProject cull: self cull: loadedClass.
			loadedClass
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ].
	loadedClassExtensions
		valuesDo: [ :loadedClassExtension | 
			loadedClassExtensionBlock
				cull: self loadedProject
				cull: self
				cull: loadedClassExtension.
			loadedClassExtension
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ]
%

category: 'accessing'
method: RwLoadedPackage
loadedClasses
	^loadedClasses
%

category: 'enumeration'
method: RwLoadedPackage
loadedClassesDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock 

	loadedClasses
		valuesDo: [ :loadedClass | 
			loadedClassBlock 
				cull: loadedClass
				cull: self loadedProject 
				cull: self].
	loadedClassExtensions
		valuesDo: [ :loadedClassExtension | 
			loadedClassExtensionBlock
				cull: loadedClassExtension
				cull: self loadedProject
				cull: self ]
%

category: 'enumeration'
method: RwLoadedPackage
loadedClassesDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedClasses
		valuesDo: [ :loadedClass | 
			loadedClassBlock 
				cull: loadedClass
				cull: self loadedProject 
				cull: self. 
			loadedClass
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ].
	loadedClassExtensions
		valuesDo: [ :loadedClassExtension | 
			loadedClassExtensionBlock
				cull: loadedClassExtension
				cull: self loadedProject
				cull: self.
			loadedClassExtension
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ]
%

category: 'accessing'
method: RwLoadedPackage
loadedClassExtensions
	^loadedClassExtensions
%

category: 'accessing'
method: RwLoadedPackage
loadedProject

   ^loadedProject
%

category: 'accessing'
method: RwLoadedPackage
loadedProject: anObject

   loadedProject := anObject
%

category: 'private'
method: RwLoadedPackage
markDirty
	"I have been changed independent of a change to my repository, and therefore may be out of sync with my repository"

	isDirty := true
%

category: 'private'
method: RwLoadedPackage
markNotDirty
	"I have been changed to be consistent with my source, so mark not dirty."

	isDirty := false
%

category: 'private'
method: RwLoadedPackage
markPackageDirty

	self markDirty
%

category: 'other'
method: RwLoadedPackage
prettyName

	^' package ', self name
%

category: 'accessing'
method: RwLoadedPackage
projectName

	^ loadedProject name
%

category: 'accessing'
method: RwLoadedPackage
removeLoadedClass: aLoadedClass

	self markDirty.
	loadedClasses removeKey: aLoadedClass key.
	aLoadedClass loadedPackage: nil
%

category: 'accessing'
method: RwLoadedPackage
removeLoadedClassExtension: aLoadedClassExtension

	self markDirty.
	loadedClassExtensions removeKey: aLoadedClassExtension key.
	aLoadedClassExtension loadedPackage: nil
%

! Class implementation for 'RwGsLoadedSymbolDictPackage'

!		Instance methods for 'RwGsLoadedSymbolDictPackage'

category: 'queries'
method: RwGsLoadedSymbolDictPackage
classOrExtensionForClass: behavior ifAbsent: absentBlock

	| className |
	className := behavior thisClass name asString.
	^ self classOrExtensionForClassNamed: className ifAbsent: absentBlock
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
classOrExtensionForClassNamed: className ifAbsent: absentBlock

	^ loadedClasses
		at: className
		ifAbsent: [ loadedClassExtensions at: className ifAbsent: absentBlock ]
%

category: 'initialization'
method: RwGsLoadedSymbolDictPackage
initialize

	super initialize.
	loadedClasses := KeyValueDictionary new.
	loadedClassExtensions := KeyValueDictionary new.
	"A new package is dirty until it has been shown to be identical to a repository."
	isDirty := true
%

category: 'initialization'
method: RwGsLoadedSymbolDictPackage
initializeForName: aName

	super initializeForName: aName.
	properties at: 'name' put: aName
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
loadedClassExtensionForClass: aClass ifAbsent: absentBlock

	"If there is an existing extension for the given (non-meta) class in this package, answer it, otherwise invoke absentBlock."

	^ loadedClassExtensions
		at: aClass thisClass name asString
		ifAbsent: absentBlock
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
loadedClassForClass: aClass ifAbsent: absentBlock

	"If there is an existing loadedClass for the given (non-meta) class in this package, answer it, otherwise invoke absentBlock.."

	^ loadedClasses at: aClass thisClass name asString ifAbsent: absentBlock
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
loadedClassOrClassExtensionForClass: aClass ifAbsent: absentBlock

	"If there is an existing loaded class or loaded class extesnion for the given (non-meta) class in this package, answer it, otherwise invoke absentBlock."

	^ loadedClasses
		at: aClass thisClass name asString
		ifAbsent: [ self loadedClassExtensionForClass: aClass ifAbsent: absentBlock ]
%

category: 'private'
method: RwGsLoadedSymbolDictPackage
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at:  'gs_SymbolDictionary' put: (Rowan image loadedRegistryForPackageNamed: self name) _symbolDictionary name asString.
	^ props
%

! Class implementation for 'RwLoadedProject'

!		Class methods for 'RwLoadedProject'

category: 'instance creation'
classmethod: RwLoadedProject
newForLoadSpecification: aLoadSpecification

	^ self new
		initialize;
		initializeForLoadSpecification: aLoadSpecification;
		yourself
%

category: 'accessing'
classmethod: RwLoadedProject
_projectDefinitionSourceKey
	"The value of the property key indicates which source the project definition was derived from.
		Currently used when deciding whether to change the loaded commit id, during a load ... 
		if the load is derived from a loaded project (RwLoadedProject class _projectDefinitionSourceValue), 
		then it isn't necessary to update the loaded commit id."

	^ '_Project_Definition_Source'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectDiskDefinitionSourceValue
	"This value of the property key indicates that the source of the project definition was loaded from disk, 
		then it isn't necessary to update the loaded commit id."

	^ 'loaded from disk'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectLoadedDefinitionSourceValue
	"This value of the property key indicates that the source of the project definition was derived from
		a loaded project, then it isn't necessary to update the loaded commit id."

	^ 'loaded project'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectUnknownDefinitionSourceValue
	"This value of the property key indicates that the source of the project definition is unknown."

	^ 'unknown'
%

!		Instance methods for 'RwLoadedProject'

category: 'accessing'
method: RwLoadedProject
addLoadedPackage: aLoadedPackage

	self markDirty.
	loadedPackages at: aLoadedPackage key put: aLoadedPackage.
	aLoadedPackage loadedProject: self
%

category: 'definitions'
method: RwLoadedProject
asDefinition

	"Create a Definition corresponding to what I define in the image."

	^ RwProjectDefinition
		withProperties: self propertiesForDefinition
		packageDefinitions: self loadedPackageDefinitions
%

category: 'commit log'
method: RwLoadedProject
commitLog: logLimit

	self subclassResponsibility: #commitLog:
%

category: 'initialization'
method: RwLoadedProject
initialize

	super initialize.
	loadedPackages := KeyValueDictionary new.
	isDirty := true. "a project is dirty if it has changes that are not written to disk"
%

category: 'initialization'
method: RwLoadedProject
initializeForLoadSpecification: aLoadSpecification

	self initializeForName: aLoadSpecification specName.
	handle := aLoadSpecification
%

category: 'testing'
method: RwLoadedProject
isDirty

	"a project is dirty if it has changes that are not written to disk, or it's packages have changes that are not written to  disk."

	isDirty ifTrue: [ ^ true].
	self loadedPackages
		do: [ :loadedPackage | 
			loadedPackage isDirty
				ifTrue: [ ^ true ] ].
	^ false
%

category: 'testing'
method: RwLoadedProject
isEmpty

	^ loadedPackages isEmpty
%

category: 'accessing'
method: RwLoadedProject
key

	^ name
%

category: 'accessing'
method: RwLoadedProject
loadedCommitId

	self subclassResponsibility: #loadedCommitId
%

category: 'accessing'
method: RwLoadedProject
loadedPackageDefinitions

	"Create definitions from all of the packages I define, and answer the collection of them"

	^ self definitionsFor: loadedPackages
%

category: 'accessing'
method: RwLoadedProject
loadedPackages

	^ loadedPackages
%

category: 'accessing'
method: RwLoadedProject
loadedPackages: anObject

   loadedPackages := anObject
%

category: 'enumeration'
method: RwLoadedProject
loadedPackagesDo: loadedPackageBlock loadedClassedDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedPackages
		valuesDo: [ :loadedPackage | 
			loadedPackageBlock cull: self cull: loadedPackage.
			loadedPackage
				loadedClassedDo: loadedClassBlock
				loadedClassExtensionsDo: loadedClassExtensionBlock
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ]
%

category: 'accessing'
method: RwLoadedProject
loadedProject

	^ self
%

category: 'accessing'
method: RwLoadedProject
loadSpecification

	^ handle
%

category: 'private'
method: RwLoadedProject
markDirty
	"I have been changed independent of a change to my repository, and therefore may be out of sync with my repository"

	isDirty := true
%

category: 'private'
method: RwLoadedProject
markNotDirty
	"I have been changed to be consistent with my source, so mark not dirty."

	isDirty := false
%

category: 'private'
method: RwLoadedProject
markProjectDirty

	self markDirty
%

category: 'accessing'
method: RwLoadedProject
packageNames

	"Return list of package names in the receiver"

	^ self loadedPackages keys asArray
%

category: 'accessing'
method: RwLoadedProject
prettyName

	^' project ' , self name
%

category: 'accessing'
method: RwLoadedProject
projectDefinitionSourceProperty

	^ properties at: RwLoadedProject _projectDefinitionSourceKey ifAbsent: [ RwLoadedProject _projectUnknownDefinitionSourceValue ]
%

category: 'accessing'
method: RwLoadedProject
projectUrl

	"Return the projectUrl used to clone the project"

	^ self specification projectUrl
%

category: 'definitions'
method: RwLoadedProject
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at: 'name' put: name.
	props at: self class _projectDefinitionSourceKey put: self class _projectLoadedDefinitionSourceValue.
	^ props
%

category: 'accessing'
method: RwLoadedProject
removeLoadedPackage: aLoadedPackage

	self markDirty.
	loadedPackages removeKey: aLoadedPackage key
%

category: 'accessing'
method: RwLoadedProject
repositoryCommitId

	self subclassResponsibility: #repositoryCommitId
%

category: 'properties'
method: RwLoadedProject
specification

	^ properties at: 'spec'
%

category: 'testing'
method: RwLoadedProject
useGit

	^ self subclassResponsibility: #useGit
%

! Class implementation for 'RwGsLoadedSymbolDictComponentProject'

!		Class methods for 'RwGsLoadedSymbolDictComponentProject'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictComponentProject
newForProjectReferenceDefinition: aProjectReferenceDefinition

	^ self new
		initialize;
		initializeForProjectReferenceDefinition: aProjectReferenceDefinition;
		yourself
%

!		Instance methods for 'RwGsLoadedSymbolDictComponentProject'

category: 'definitions'
method: RwGsLoadedSymbolDictComponentProject
asDefinition

	"Create a Definition corresponding to what I define in the image."

	^ RwComponentProjectDefinition
		withProperties: self propertiesForDefinition
		packageDefinitions: self loadedPackageDefinitions
%

category: 'commit log'
method: RwGsLoadedSymbolDictComponentProject
commitLog: logLimit

	^ self projectRef commitLog: logLimit
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
components

	^ self projectRef components
%

category: 'initialization'
method: RwGsLoadedSymbolDictComponentProject
initializeForLoadSpecification: aLoadSpecification

	self initializeForName: aLoadSpecification specName.
	handle := RwProjectReferenceDefinition newForSpecification: aLoadSpecification
%

category: 'initialization'
method: RwGsLoadedSymbolDictComponentProject
initializeForProjectReferenceDefinition: aProjectReferenceDefinition

	self initializeForName: aProjectReferenceDefinition projectAlias.
	handle := aProjectReferenceDefinition copy
%

category: 'properties'
method: RwGsLoadedSymbolDictComponentProject
loadedCommitId

	^ self projectRef loadedCommitId
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
loadedComponentDefinitions

	"Create definitions from all of the components I define, and answer the collection of them"

	| components |
	components := self componenents copy.
	components keysAndValuesDo: [:key :value | components at: key put: value copy ].
	^ components
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
loadedConfigurationNames

	^ self projectRef loadedConfigurationNames
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
loadedConfigurationNames: configNames

	"noop - project ref component keys is list of loaded config names"

	"https://github.com/GemTalk/Rowan/issues/308"

	"eventually this method will be completely removed/deprecated"

	configNames asArray sort = self loadedConfigurationNames asArray sort
		ifFalse: [ self error: 'The configNames are expected to match the component keys' ]
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
loadedGroupNames: groupNames


	self projectRef loadedGroupNames: groupNames
%

category: 'private'
method: RwGsLoadedSymbolDictComponentProject
markPackageDirty
	"... indicates that receiver needs to mark it's container as dirty .... "

	self markDirty
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
projectOwnerId

	^ self propertyAt: 'projectOwnerId'
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
projectOwnerId: aString

	^ self propertyAt: 'projectOwnerId' put: aString
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
projectRef

	^ self handle
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
projectUrl

	"Return the projectUrl used to clone the project"

	^ self projectRef projectUrl
%

category: 'definitions'
method: RwGsLoadedSymbolDictComponentProject
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at: 'projectRef' put: handle copy.
	^ props
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
repositoryCommitId

	^ self projectRef repositoryCommitId
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ self projectRef repositoryRoot
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
repositoryRootPath

	^ self repositoryRoot pathString
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
specification

self deprecated: 'temporary patch .. sender should send direct message to receiver'.
	^ handle
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
symbolDictNameForPackageNamed: packageName

	^self projectRef symbolDictNameForPackageNamed: packageName
%

category: 'loading'
method: RwGsLoadedSymbolDictComponentProject
updateLoadedCommitId

	self projectRef updateLoadedCommitId
%

category: 'accessing'
method: RwGsLoadedSymbolDictComponentProject
useGit

	^ self projectRef useGit
%

! Class implementation for 'RwGsLoadedSymbolDictProject'

!		Instance methods for 'RwGsLoadedSymbolDictProject'

category: 'commit log'
method: RwGsLoadedSymbolDictProject
commitLog: logLimit

	self useGit ifFalse: [ ^ '' ].
	^ Rowan gitTools gitlogtool: 'HEAD' limit: logLimit gitRepoDirectory: self repositoryRootPath
%

category: 'accessing'
method: RwGsLoadedSymbolDictProject
loadedCommitId

	^ self specification loadedCommitId
%

category: 'accessing'
method: RwGsLoadedSymbolDictProject
loadedConfigurationNames: configNames

	self specification imageSpec loadedConfigurationNames: configNames
%

category: 'accessing'
method: RwGsLoadedSymbolDictProject
loadedGroupNames: groupNames

	self specification imageSpec loadedGroupNames: groupNames
%

category: 'specifiction'
method: RwGsLoadedSymbolDictProject
projectOwnerId

	^ (self specification platformSpec at: 'gemstone') projectOwnerId
%

category: 'specifiction'
method: RwGsLoadedSymbolDictProject
projectOwnerId: aUserId

	^ (self specification platformSpec at: 'gemstone') projectOwnerId: aUserId
%

category: 'definitions'
method: RwGsLoadedSymbolDictProject
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at: 'spec' put: handle.
	^ props
%

category: 'accessing'
method: RwGsLoadedSymbolDictProject
repositoryCommitId

	| rootPath |
	self useGit
		ifFalse: [ ^ '' ].
	rootPath := self repositoryRootPath.
	rootPath ifNil: [ ^ '' ].
	^ Rowan gitTools gitcommitShaIn: rootPath
%

category: 'accessing'
method: RwGsLoadedSymbolDictProject
repositoryRoot
	"Root directory of the project. The configsPath, repoPath, specsPath, and projectsPath are specified relative to the repository root."

	^ self repositoryRootPath
		ifNotNil: [:path | path asFileReference ]
%

category: 'accessing'
method: RwGsLoadedSymbolDictProject
repositoryRootPath

	^ self specification repositoryRootPath
%

category: 'properties'
method: RwGsLoadedSymbolDictProject
specification

	^ handle
%

category: 'accessing'
method: RwGsLoadedSymbolDictProject
symbolDictNameForPackageNamed: packageName

	| spec gemstoneSpec |
	spec := self specification.
	gemstoneSpec := spec platformSpec at: 'gemstone'.
	^ gemstoneSpec symbolDictNameForPackageNamed: packageName.
%

category: 'loading'
method: RwGsLoadedSymbolDictProject
updateLoadedCommitId

	| loadedCommitId |
	self useGit ifFalse: [ ^ nil ].
	loadedCommitId := [  Rowan gitTools gitcommitShaIn: self repositoryRoot pathString ]
		on: Error
		do: [ :ignored | 
			"most likely no commits yet"
			^ nil ].
	self specification imageSpec loadedCommitId: loadedCommitId
%

category: 'accessing'
method: RwGsLoadedSymbolDictProject
useGit

	^ self specification useGit
%

! Class implementation for 'RwMethodAdditionOrRemoval'

!		Class methods for 'RwMethodAdditionOrRemoval'

category: 'instance creation'
classmethod: RwMethodAdditionOrRemoval
packageDefinition: aPackageDefinition classDefinitionOrExtension: aClassDefinitionOrExtension methodKey: aMethodKey isMeta: isMeta methodsModification: aMethodsModification

	^(self new)
		packageDefinition: aPackageDefinition;
		classDefinitionOrExtension: aClassDefinitionOrExtension;
		methodKey: aMethodKey;
		isMeta: isMeta;
		methodsModification: aMethodsModification;
		yourself
%

category: 'instance creation'
classmethod: RwMethodAdditionOrRemoval
projectDefinition: aProjectDefinition packageDefinition: aPackageDefinition classDefinitionOrExtension: aClassDefinitionOrExtension methodKey: aMethodKey isMeta: isMeta methodsModification: aMethodsModification

	^(self new)
		projectDefinition: aProjectDefinition;
		packageDefinition: aPackageDefinition;
		classDefinitionOrExtension: aClassDefinitionOrExtension;
		methodKey: aMethodKey;
		isMeta: isMeta;
		methodsModification: aMethodsModification;
		yourself
%

!		Instance methods for 'RwMethodAdditionOrRemoval'

category: 'Accessing'
method: RwMethodAdditionOrRemoval
classDefinitionOrExtension
	^classDefinitionOrExtension
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
classDefinitionOrExtension: newValue
	classDefinitionOrExtension := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
isMeta
	^isMeta
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
isMeta: newValue
	isMeta := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
methodKey
	^methodKey
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
methodKey: newValue
	methodKey := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
methodsModification
	^methodsModification
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
methodsModification: newValue
	methodsModification := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
packageDefinition
	^packageDefinition
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
packageDefinition: newValue
	packageDefinition := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
projectDefinition
	^ projectDefinition
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
projectDefinition: newValue
	projectDefinition := newValue
%

! Class implementation for 'RwModification'

!		Class methods for 'RwModification'

category: 'instance creation'
classmethod: RwModification
before: beforeDefinition after: afterDefinition

	^(self new initialize)
		before: beforeDefinition;
		after: afterDefinition;
		yourself
%

!		Instance methods for 'RwModification'

category: 'Accessing'
method: RwModification
after
	^after
%

category: 'Updating'
method: RwModification
after: newValue
	after := newValue
%

category: 'Accessing'
method: RwModification
before
	^before
%

category: 'Updating'
method: RwModification
before: newValue
	before := newValue
%

category: 'initializing'
method: RwModification
initialize
	"Dummy that understands isEmpty for printing"

	propertiesModification := #()
%

category: 'testing'
method: RwModification
isAddition

	^before isEmpty
%

category: 'testing'
method: RwModification
isDeletion

	^after isEmpty
%

category: 'testing'
method: RwModification
isEmpty

	^propertiesModification isEmpty
%

category: 'testing'
method: RwModification
isModification

	^after isEmpty not and: [ before isEmpty not ]
%

category: 'Accessing'
method: RwModification
key

	| beforeKey |
	beforeKey := before key.
	^beforeKey ifNil: [after key] ifNotNil: [beforeKey]
%

category: 'Printing'
method: RwModification
printOn: aStream

	super printOn: aStream.
	self isEmpty ifTrue: [aStream nextPutAll: ' (empty)']
%

category: 'Accessing'
method: RwModification
propertiesModification
	^propertiesModification
%

category: 'Updating'
method: RwModification
propertiesModification: newValue
	propertiesModification := newValue
%

! Class implementation for 'RwClassModification'

!		Instance methods for 'RwClassModification'

category: 'visiting'
method: RwClassModification
acceptVisitor: aVisitor

	^aVisitor visitClassModification: self
%

category: 'Accessing'
method: RwClassModification
classMethodsModification
	^classMethodsModification
%

category: 'Updating'
method: RwClassModification
classMethodsModification: newValue
	classMethodsModification := newValue
%

category: 'initialization'
method: RwClassModification
initialize
	"Dummy initialization that understands isEmpty for printing."

	super initialize.
	instanceMethodsModification := #().
	classMethodsModification := #()
%

category: 'Accessing'
method: RwClassModification
instanceMethodsModification
	^instanceMethodsModification
%

category: 'Updating'
method: RwClassModification
instanceMethodsModification: newValue
	instanceMethodsModification := newValue
%

category: 'testing'
method: RwClassModification
isEmpty

	^super isEmpty & instanceMethodsModification isEmpty
		& classMethodsModification isEmpty
%

category: 'merging'
method: RwClassModification
mergeForExistingClassWith: anExistingClassModification

	"merge aClassModification modifictions into the receiver"

	anExistingClassModification propertiesModification isEmpty
		ifFalse: [
			self propertiesModification isEmpty
				ifFalse: ["the properties modification for the receiver can be safely ignored" ].
			propertiesModification := anExistingClassModification propertiesModification copy ].
	instanceMethodsModification
		mergeForExistingClassWith: anExistingClassModification instanceMethodsModification.
	classMethodsModification
		mergeForExistingClassWith: anExistingClassModification classMethodsModification.
	after := anExistingClassModification after
%

category: 'merging'
method: RwClassModification
mergeForNewClassVersionWith: aClassModification

	"merge aClassModification modifictions into the receiver"

	aClassModification propertiesModification isEmpty
		ifFalse: [ 
			self
				error:
					'internal error - an incoming class modification is not expected to have properties when a new class version is involved' ].
	instanceMethodsModification
		mergeForNewClassVersionWith: aClassModification instanceMethodsModification.
	classMethodsModification
		mergeForNewClassVersionWith: aClassModification classMethodsModification
%

! Class implementation for 'RwClassExtensionModification'

!		Instance methods for 'RwClassExtensionModification'

category: 'visiting'
method: RwClassExtensionModification
acceptVisitor: aVisitor

	^aVisitor visitClassExtensionModification: self
%

category: 'patching'
method: RwClassExtensionModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ 
			aPatchSet
				addExtendedClass: self after
				inPackage: aPackage
				inProject: aProjectDefinition ].
	self isDeletion
		ifTrue: [ 
			"nothing interesting to do for deletion"
			 ].
	self isModification
		ifTrue: [ 
			"nothing interesting to do for modification"
			 ]
%

! Class implementation for 'RwClassModificationForcingNewClassVersion'

!		Instance methods for 'RwClassModificationForcingNewClassVersion'

category: 'visiting'
method: RwClassModificationForcingNewClassVersion
acceptVisitor: aVisitor

	^ aVisitor visitClassModificationForcingNewVersion: self
%

! Class implementation for 'RwMethodModification'

!		Instance methods for 'RwMethodModification'

category: 'visiting'
method: RwMethodModification
acceptVisitor: aVisitor

	^ aVisitor visitMethodModification: self
%

category: 'patching'
method: RwMethodModification
addExtensionModificationToPatchSetForNewClassVersion: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ self error: 'internal error - unexpected method addition' ].
	self isDeletion
		ifTrue: [ self error: 'internal error - unexpected method deletion' ].
	self isModification
		ifTrue: [ 
			"treat like an addition, since it is an addition of a method to the new class version"
			self isMeta
				ifTrue: [ 
					aPatchSet
						addExtendedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addExtendedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ] ]
%

category: 'patching'
method: RwMethodModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addAddedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addAddedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isDeletion
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addDeletedClassMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addDeletedInstanceMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isModification
		ifTrue: [ 
			sourceModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedClassMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedInstanceMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ].
			propertiesModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedClassMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedInstanceMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ] ]
%

category: 'converting'
method: RwMethodModification
asExtensionMethodModification

	^ (RwExtensionMethodModification before: before after: after)
		isMeta: self isMeta;
		propertiesModification: propertiesModification;
		sourceModification: sourceModification;
		classDefinition: self classDefinition;
		yourself
%

category: 'converting'
method: RwMethodModification
asMethodModificationForNewClassVersion

	^ (RwMethodModificationForNewClassVersion before: before after: after)
		isMeta: self isMeta;
		classDefinition: self classDefinition;
		propertiesModification: self propertiesModification;
		sourceModification: self sourceModification;
		yourself
%

category: 'Accessing'
method: RwMethodModification
classDefinition
	^classDefinition
%

category: 'Updating'
method: RwMethodModification
classDefinition: aClassDefinition
	classDefinition := aClassDefinition
%

category: 'testing'
method: RwMethodModification
isEmpty

	^super isEmpty & sourceModification isEmpty
%

category: 'Accessing'
method: RwMethodModification
isMeta
	^isMeta
%

category: 'Updating'
method: RwMethodModification
isMeta: newValue
	isMeta := newValue
%

category: 'merging'
method: RwMethodModification
mergeForNewClassVersionWith: aMethodModification

	"validate that this is a proper modification"

	self sourceModification isEmpty
		ifTrue: [ 
			aMethodModification sourceModification isEmpty
				ifTrue: [ 
					self
						error:
							'internal error - unexpected missing source modification during method modification for new class version merge' ]
				ifFalse: [ 
					"this is as it should be ... method source must be carried forward to the new class version"
					 ] ].
	self propertiesModification isEmpty
		ifTrue: [ 
			aMethodModification propertiesModification isEmpty
				ifFalse: [ self error: 'internal error - not yet implemented' ] ]
%

category: 'Accessing'
method: RwMethodModification
sourceModification
	^sourceModification
%

category: 'Accessing'
method: RwMethodModification
sourceModification: aRWSourceModification
	sourceModification := aRWSourceModification
%

! Class implementation for 'RwExtensionMethodModification'

!		Instance methods for 'RwExtensionMethodModification'

category: 'visiting'
method: RwExtensionMethodModification
acceptVisitor: aVisitor

	^ aVisitor visitExtensionMethodModification: self
%

category: 'patching'
method: RwExtensionMethodModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addExtendedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addExtendedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isDeletion
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addDeletedExtendedClassMethod: self before
						inClass: self classDefinition
						named: self extendedClassName
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addDeletedExtendedInstanceMethod: self before
						inClass: self classDefinition
						named: self extendedClassName
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isModification
		ifTrue: [ 
			sourceModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedExtendedClassMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedExtendedInstanceMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ].
			propertiesModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedExtendedClassMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedExtendedInstanceMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ] ]
%

category: 'converting'
method: RwExtensionMethodModification
asExtensionMethodModification

	^ self
%

category: 'accessing'
method: RwExtensionMethodModification
classDefinition: aClassDefinition
	classDefinition := aClassDefinition
%

category: 'accessing'
method: RwExtensionMethodModification
extendedClassName

   ^extendedClassName
%

category: 'accessing'
method: RwExtensionMethodModification
extendedClassName: anObject

   extendedClassName := anObject
%

! Class implementation for 'RwMethodModificationForNewClassVersion'

!		Instance methods for 'RwMethodModificationForNewClassVersion'

category: 'visiting'
method: RwMethodModificationForNewClassVersion
acceptVisitor: aVisitor

	^ aVisitor visitMethodModificationForNewClassVersion: self
%

category: 'patching'
method: RwMethodModificationForNewClassVersion
addModificationToPatchSetForNewClassVersion: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isDeletion
		ifTrue: [ 
			"method deletions on a new class version can be ignored: https://github.com/dalehenrich/Rowan/issues/353"
			"method deletions on a new class version needs to have the loaded things taken core of: https://github.com/dalehenrich/Rowan/issues/393"

			"treat like a deletion, since this ends up being a deletion of a method from the new class version"
			self isMeta
				ifTrue: [ 
					aPatchSet
						addDeletedClassMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addDeletedInstanceMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ] ].
	(self isAddition or: [ self isModification ])
		ifTrue: [ 
			"treat like an addition, since this ends up being an addition of a method to the new class version"
			self isMeta
				ifTrue: [ 
					aPatchSet
						addAddedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addAddedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ] ].
%

! Class implementation for 'RwExtensionMethodModificationForNewClassVersion'

!		Instance methods for 'RwExtensionMethodModificationForNewClassVersion'

category: 'visiting'
method: RwExtensionMethodModificationForNewClassVersion
acceptVisitor: aVisitor

	^ aVisitor visitExtensionMethodModificationForNewClassVersion: self
%

! Class implementation for 'RwPackageModification'

!		Instance methods for 'RwPackageModification'

category: 'visiting'
method: RwPackageModification
acceptVisitor: aVisitor

	^aVisitor visitPackageModification: self
%

category: 'Accessing'
method: RwPackageModification
classesModification
	^classesModification
%

category: 'Updating'
method: RwPackageModification
classesModification: newValue
	classesModification := newValue
%

category: 'Accessing'
method: RwPackageModification
classExtensionsModification
	^classExtensionsModification
%

category: 'Updating'
method: RwPackageModification
classExtensionsModification: newValue
	classExtensionsModification := newValue
%

category: 'initialization'
method: RwPackageModification
initialize
	"Dummy initialization that understands isEmpty for printing."

	super initialize.
	classesModification := #().
	classExtensionsModification := #()
%

category: 'testing'
method: RwPackageModification
isEmpty

	^super isEmpty & classesModification isEmpty
		& classExtensionsModification isEmpty
%

! Class implementation for 'RwProjectModification'

!		Instance methods for 'RwProjectModification'

category: 'visiting'
method: RwProjectModification
acceptVisitor: aVisitor

	^ aVisitor visitProjectModification: self
%

category: 'initialization'
method: RwProjectModification
initialize

	"Dummy initialization that understands isEmpty for printing."

	super initialize.
	packagesModification := #()
%

category: 'testing'
method: RwProjectModification
isEmpty

	^ super isEmpty & packagesModification isEmpty
%

category: 'accessing'
method: RwProjectModification
packagesModification

   ^packagesModification
%

category: 'accessing'
method: RwProjectModification
packagesModification: anObject

   packagesModification := anObject
%

! Class implementation for 'RwMove'

!		Instance methods for 'RwMove'

category: 'Accessing'
method: RwMove
packageAfter
	^packageAfter
%

category: 'Updating'
method: RwMove
packageAfter: newValue
	packageAfter := newValue
%

category: 'Accessing'
method: RwMove
packageBefore
	^packageBefore
%

category: 'Updating'
method: RwMove
packageBefore: newValue
	packageBefore := newValue
%

category: 'Accessing'
method: RwMove
projectAfter
	^projectAfter
%

category: 'Updating'
method: RwMove
projectAfter: newValue
	projectAfter := newValue
%

category: 'Accessing'
method: RwMove
projectBefore
	^projectBefore
%

category: 'Updating'
method: RwMove
projectBefore: newValue
	projectBefore := newValue
%

! Class implementation for 'RwClassMove'

!		Class methods for 'RwClassMove'

category: 'instance creation'
classmethod: RwClassMove
classBefore: beforeClassDefinition classAfter: afterClassDefinition packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition

	^(self new)
		classBefore: beforeClassDefinition;
		classAfter: afterClassDefinition;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		yourself
%

category: 'instance creation'
classmethod: RwClassMove
classBefore: beforeClassDefinition classAfter: afterClassDefinition packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition projectBefore: beforeProjectDefinition projectAfter: afterProjectDefinition

	^(self new)
		classBefore: beforeClassDefinition;
		classAfter: afterClassDefinition;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		projectBefore: beforeProjectDefinition;
		projectAfter: afterProjectDefinition;
		yourself
%

!		Instance methods for 'RwClassMove'

category: 'Accessing'
method: RwClassMove
classAfter
	^classAfter
%

category: 'Updating'
method: RwClassMove
classAfter: newValue
	classAfter := newValue
%

category: 'Accessing'
method: RwClassMove
classBefore
	^classBefore
%

category: 'Updating'
method: RwClassMove
classBefore: newValue
	classBefore := newValue
%

! Class implementation for 'RwMethodMove'

!		Class methods for 'RwMethodMove'

category: 'unknown'
classmethod: RwMethodMove
methodBefore: beforeMethodDefinition methodAfter: afterMethodDefinition classOrExtensionBefore: beforeClassDefinitionOrExtension classOrExtensionAfter: afterClassDefinitionOrExtension packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition isMeta: isMeta

	^(self new)
		methodBefore: beforeMethodDefinition;
		methodAfter: afterMethodDefinition;
		classOrExtensionBefore: beforeClassDefinitionOrExtension;
		classOrExtensionAfter: afterClassDefinitionOrExtension;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		isMeta: isMeta;
		yourself
%

category: 'unknown'
classmethod: RwMethodMove
methodBefore: beforeMethodDefinition methodAfter: afterMethodDefinition classOrExtensionBefore: beforeClassDefinitionOrExtension classOrExtensionAfter: afterClassDefinitionOrExtension packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition projectBefore: beforeProjectDefinition projectAfter: afterProjectDefinition isMeta: isMeta

	^(self new)
		methodBefore: beforeMethodDefinition;
		methodAfter: afterMethodDefinition;
		classOrExtensionBefore: beforeClassDefinitionOrExtension;
		classOrExtensionAfter: afterClassDefinitionOrExtension;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		projectBefore: beforeProjectDefinition;
		projectAfter: afterProjectDefinition;
		isMeta: isMeta;
		yourself
%

!		Instance methods for 'RwMethodMove'

category: 'Accessing'
method: RwMethodMove
classOrExtensionAfter
	^classOrExtensionAfter
%

category: 'Updating'
method: RwMethodMove
classOrExtensionAfter: newValue
	classOrExtensionAfter := newValue
%

category: 'Accessing'
method: RwMethodMove
classOrExtensionBefore
	^classOrExtensionBefore
%

category: 'Updating'
method: RwMethodMove
classOrExtensionBefore: newValue
	classOrExtensionBefore := newValue
%

category: 'Accessing'
method: RwMethodMove
isMeta
	^isMeta
%

category: 'Updating'
method: RwMethodMove
isMeta: newValue
	isMeta := newValue
%

category: 'Accessing'
method: RwMethodMove
methodAfter
	^methodAfter
%

category: 'Updating'
method: RwMethodMove
methodAfter: newValue
	methodAfter := newValue
%

category: 'Accessing'
method: RwMethodMove
methodBefore
	^methodBefore
%

category: 'Updating'
method: RwMethodMove
methodBefore: newValue
	methodBefore := newValue
%

! Class implementation for 'RwPlatform'

!		Instance methods for 'RwPlatform'

category: 'automatic class initialization'
method: RwPlatform
automaticClassInitializationBlackList

	"Answer list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		preferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setPreferenceFor: preferenceSymbol to: list.
			list]
%

category: 'automatic class initialization'
method: RwPlatform
automaticClassInitializationBlackList_default

	"Answer default list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		defaultPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setDefaultPreferenceFor: preferenceSymbol to: list.
			list]
%

category: 'automatic class initialization'
method: RwPlatform
automaticClassInitializationBlackList_global

	"Answer global list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		globalPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setDefaultPreferenceFor: preferenceSymbol to: list.
			list]
%

category: 'queries'
method: RwPlatform
basePlatformAttribute
	"Answer the generic configuration attribute for the platform"

	"Examples include: 'gemstone', 'pharo', 'squeak'"


	self subclassResponsibility: #basePlatformAttribute
%

category: 'preferences'
method: RwPlatform
clearAllPreferencesFor: preferenceSymbol 

	self subclassResponisbility: #clearAllPreferencesFor:
%

category: 'automatic class initialization'
method: RwPlatform
clearAutomaticClassInitializationBlackList

	"Answer list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwPlatform
clearAutomaticClassInitializationBlackList_default

	"Answer default list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearDefaultPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwPlatform
clearAutomaticClassInitializationBlackList_global

	"Answer default list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearGlobalPreferenceFor: preferenceSymbol
%

category: 'preferences'
method: RwPlatform
clearDefaultPreferenceFor: preferenceSymbol 

	self subclassResponisbility: #clearDefaultPreferenceFor:
%

category: 'preferences'
method: RwPlatform
clearPreferenceFor: preferenceSymbol 

	self subclassResponisbility: #clearPreferenceFor:
%

category: 'preferences'
method: RwPlatform
defaultPreferenceFor: preferenceSymbol

	^ self defaultPreferenceFor: preferenceSymbol ifAbsent: [ self error: 'No preference found for ', preferenceSymbol asString printString ]
%

category: 'preferences'
method: RwPlatform
defaultPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self subclassResponisbility: #defaultPreferenceFor:ifAbsent:
%

category: 'queries'
method: RwPlatform
fileUtilities
	"Answer the platform-specific object for accessing files and directories"

	self subclassResponsibility: #fileUtilities
%

category: 'queries'
method: RwPlatform
globalNamed: aString

	"Answer a global object with the given name.  If no object with the given name is found, returns nil."

	self subclassResponsibility: #'globalNamed:'
%

category: 'queries'
method: RwPlatform
loadedPackageClass
	"Answer the platform-specific class for LoadedPackage"

	self subclassResponsibility: #'loadedPackageClass'
%

category: 'queries'
method: RwPlatform
platformConfigurationAttributes
	"Answer the configuration attributes. Currently 'common' is the only shared attribute."

	"subclasses need to override and provide additional platform-specific attributes"

	^ #('common')
%

category: 'preferences'
method: RwPlatform
preferenceFor: preferenceSymbol

	^ self preferenceFor: preferenceSymbol ifAbsent: [ self error: 'No preference found for ', preferenceSymbol asString printString ]
%

category: 'preferences'
method: RwPlatform
preferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self subclassResponisbility: #preferenceFor:ifAbsent:
%

category: 'preferences'
method: RwPlatform
setDefaultPreferenceFor: preferenceSymbol to: anObject

	self subclassResponisbility: #setDefaultPreferenceFor:to:
%

category: 'preferences'
method: RwPlatform
setPreferenceFor: preferenceSymbol to: anObject

	self subclassResponisbility: #setPreferenceFor:to:
%

category: 'queries'
method: RwPlatform
tools
	"Answer the platform-specific class for tools"

	self subclassResponsibility: #tools
%

category: 'automatic class initialization'
method: RwPlatform
_automaticClassInitializationBlackList_symbol

	^#automaticClassInitializationBlackList
%

! Class implementation for 'RwGsPlatform'

!		Instance methods for 'RwGsPlatform'

category: 'automatic class initialization'
method: RwGsPlatform
automaticClassInitializationBlackList_session

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		sessionPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setSessionPreferenceFor: preferenceSymbol to: list.
			list ]
%

category: 'automatic class initialization'
method: RwGsPlatform
automaticClassInitializationBlackList_user

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		userPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setUserPreferenceFor: preferenceSymbol to: list.
			list ]
%

category: 'queries'
method: RwGsPlatform
basePlatformAttribute
	"Answer the generic configuration attribute for the platform"


	^ 'gemstone'
%

category: 'preferences'
method: RwGsPlatform
clearAllPreferencesFor: preferenceSymbol


	self 
		clearSessionPreferenceFor: preferenceSymbol;
		clearUserPreferenceFor: preferenceSymbol;
		clearGlobalPreferenceFor: preferenceSymbol;
		yourself
%

category: 'automatic class initialization'
method: RwGsPlatform
clearAutomaticClassInitializationBlackList_global

	"Answer global list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearGlobalPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwGsPlatform
clearAutomaticClassInitializationBlackList_session

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearSessionPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwGsPlatform
clearAutomaticClassInitializationBlackList_user

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearUserPreferenceFor: preferenceSymbol
%

category: 'preferences'
method: RwGsPlatform
clearDefaultPreferenceFor: preferenceSymbol
	"global preferences implements default preference"

	self clearGlobalPreferenceFor: preferenceSymbol
%

category: 'preferences - gemstone'
method: RwGsPlatform
clearGlobalPreferenceFor: preferenceSymbol

	self _globalPreferenceDict removeKey: preferenceSymbol ifAbsent: []
%

category: 'preferences'
method: RwGsPlatform
clearPreferenceFor: preferenceSymbol
	"clear sessoin and userPreferences - preserve non-gemstone semantics"

	self 
		clearSessionPreferenceFor: preferenceSymbol;
		clearUserPreferenceFor: preferenceSymbol;
		yourself
%

category: 'preferences - gemstone'
method: RwGsPlatform
clearSessionPreferenceFor: preferenceSymbol

	self _sessionPreferenceDict removeKey: preferenceSymbol ifAbsent: []
%

category: 'preferences - gemstone'
method: RwGsPlatform
clearUserPreferenceFor: preferenceSymbol

	self _userPreferenceDict removeKey: preferenceSymbol ifAbsent: []
%

category: 'defaults'
method: RwGsPlatform
defaultConfiguration

	^ RwConfiguration new
		packageInfoSource: #'SymbolDictionary';
		yourself
%

category: 'preferences'
method: RwGsPlatform
defaultPreferenceFor: preferenceSymbol ifAbsent: aBlock

	"global preferences implements default preference"

	^self globalPreferenceFor: preferenceSymbol ifAbsent: aBlock
%

category: 'queries'
method: RwGsPlatform
fileUtilities
  "Answer the platform-specific object for accessing files and directories"

  ^ RwGsFileUtilities
%

category: 'queries'
method: RwGsPlatform
globalNamed: aString

	"Answer a global object with the given name.  If no object with the given name is found, returns nil."

	^ Rowan image objectNamed: aString
%

category: 'preferences - gemstone'
method: RwGsPlatform
globalPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _globalPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: aBlock
%

category: 'queries'
method: RwGsPlatform
image

	"Answer the platform-specific object for querying the local image"

	^ alternateImageClass ifNil: [ RwGsImage ]
%

category: 'initialization'
method: RwGsPlatform
initialize

	self automaticClassInitializationBlackList
%

category: 'queries'
method: RwGsPlatform
instanceMigrator

	^ instanceMigrator
		ifNil: [ instanceMigrator := RwGsInstanceMigrator noMigration ]
%

category: 'queries'
method: RwGsPlatform
instanceMigrator: anInstanceMigrator

	instanceMigrator := anInstanceMigrator
%

category: 'queries'
method: RwGsPlatform
orderedDictionaryClass
  "Answer the platform-specific OrderedDictionary-compatible class"

  ^ GsTonelOrderedDictionary
%

category: 'parsing'
method: RwGsPlatform
parseSelectorFrom: methodString

	| meth |
	^ [ 
	meth := self
		_parseMethod: methodString
		category: #'xyzzy'
		using: self image symbolList
		environmentId: 0.
	meth class ~~ GsNMethod
		ifTrue: [ 
			"if error slot is nil, then the method wasn't compiled because of errors"
			(meth at: 2) == nil
				ifFalse: [ ^ nil ].
			meth := meth at: 1 ].
	meth selector asString ]
		on: CompileError
		do: [ :ex | ex return: '_____could_not_parse_selector_from_method_source_____' ]
%

category: 'queries'
method: RwGsPlatform
platformConfigurationAttributes
	"Answer the configuration attributes for the current platform."

	^ super platformConfigurationAttributes, {self basePlatformAttribute. 'gemstone-kernel'. (System stoneVersionReport at: 'gsVersion') asRwGemStoneVersionNumber}
%

category: 'preferences'
method: RwGsPlatform
preferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _sessionPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: [ 
			self 
				_userPreferenceDict at: preferenceSymbol 
				ifAbsent: [
					self _globalPreferenceDict 
						at: preferenceSymbol
						ifAbsent:aBlock ] ]
%

category: 'preferences - gemstone'
method: RwGsPlatform
sessionPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _sessionPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: aBlock
%

category: 'preferences'
method: RwGsPlatform
setDefaultPreferenceFor: preferenceSymbol to: anObject

	"global preferences implements default preference"

	^self setGlobalPreferenceFor: preferenceSymbol to: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
setGlobalPreferenceFor: preferenceSymbol to: anObject

	self _globalPreferenceDict at: preferenceSymbol put: anObject
%

category: 'preferences'
method: RwGsPlatform
setPreferenceFor: preferenceSymbol to: anObject

	"clear session; set userPreferences - preserve non-gemstone semantics"

	self clearSessionPreferenceFor: preferenceSymbol.
	^self setUserPreferenceFor: preferenceSymbol to: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
setSessionPreferenceFor: preferenceSymbol to: anObject

	self _sessionPreferenceDict at: preferenceSymbol put: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
setUserPreferenceFor: preferenceSymbol to: anObject

	self _userPreferenceDict at: preferenceSymbol put: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
userPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _userPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: aBlock
%

category: 'private'
method: RwGsPlatform
_alternateImageClass

	^ alternateImageClass
%

category: 'private'
method: RwGsPlatform
_alternateImageClass: anImageClass

	alternateImageClass := anImageClass
%

category: 'private'
method: RwGsPlatform
_globalPreferenceDict

	^ (self class _userPlatformDictionaryForUser: 'SystemUser') at: #RwGlobalPlatform_Preferences ifAbsentPut: [ Dictionary new ]
%

category: 'private'
method: RwGsPlatform
_parseMethod: source category: cat using: aSymbolList environmentId: anEnvironmentId
	"Compiles the method into disposable dictionaries, if possible.
	 Attempts auto-recompile for undefinedSymbols.
	 Returns the compiled method or signals a CompileError."

	| undefinedSymbolList undefinedSymbols |
	undefinedSymbols := SymbolDictionary new name: #UndefinedSymbols.
	undefinedSymbolList := SymbolList with: undefinedSymbols.
	^
	[UndefinedObject
		compileMethod: source
		dictionaries: aSymbolList
		category: cat
		intoMethodDict: GsMethodDictionary new
		intoCategories: GsMethodDictionary new
		intoPragmas: nil
		environmentId: anEnvironmentId]
			onSynchronous: (Array with: CompileError with: CompileWarning)
			do: (Array with: 
						[:ex |
						| undefSymbol symbols |
						undefSymbol := true.
						symbols := Array new.
						ex errorDetails do: 
								[:errArray |
								(errArray atOrNil: 1) == 1031
									ifTrue: [symbols add: (errArray atOrNil: 5) asSymbol]
									ifFalse: [undefSymbol := false]].
						undefSymbol
							ifTrue: 
								["attempt auto-define of undefined symbols"
								symbols do: [:sym | undefinedSymbols at: sym put: nil].
								
								[^UndefinedObject
									compileMethod: source
									dictionaries: aSymbolList , undefinedSymbolList
									category: cat
									intoMethodDict: GsMethodDictionary new
									intoCategories: GsMethodDictionary new
									intoPragmas: nil
									environmentId: anEnvironmentId]
										onException: CompileError
										do: [:exb | undefSymbol := false]].
						undefSymbol ifFalse: [ex outer]]
					with: [:ex | ex resume])
%

category: 'private'
method: RwGsPlatform
_sessionPreferenceDict

	^ SessionTemps current at: #RwSessionPlatform_Preferences ifAbsentPut: [ Dictionary new ]
%

category: 'private'
method: RwGsPlatform
_userPreferenceDict

	^ self class _userPlatformDictionary at: #RwUserPlatform_Preferences ifAbsentPut: [ Dictionary new ]
%

! Class implementation for 'RwProjectLoadConfigurationVisitor'

!		Class methods for 'RwProjectLoadConfigurationVisitor'

category: 'instance creation'
classmethod: RwProjectLoadConfigurationVisitor
new

	^super new initialize
%

!		Instance methods for 'RwProjectLoadConfigurationVisitor'

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
configurationBasePath

	^ configurationBasePath
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
configurationBasePath: aString

	configurationBasePath := aString
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
configurationNames

	^ configurationNames
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
groupNames

	^ groupNames
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
groupNames: aColl

	groupNames := aColl copy
%

category: 'initialization'
method: RwProjectLoadConfigurationVisitor
initialize

	packageNames := Set new.
	visitedConfigurationNames := Set new.
	configurationNames := Set new.
	platformAttributes := #().
	groupNames := {}.
	configurationBasePath := ''.
	packageMapSpecs := Dictionary new.
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
packageMapSpecs

	^ packageMapSpecs
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
packageNames

	^ packageNames
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
platformAttributes

	^ platformAttributes
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
platformAttributes: aColl

	platformAttributes := aColl
%

category: 'visiting'
method: RwProjectLoadConfigurationVisitor
visit: aProjectConfiguration

	^aProjectConfiguration acceptVisitor: self
%

category: 'visiting'
method: RwProjectLoadConfigurationVisitor
visitNested: aProjectConfiguration

	^aProjectConfiguration acceptNestedVisitor: self
%

category: 'visiting'
method: RwProjectLoadConfigurationVisitor
visitNestedProjectLoadConfiguration: aNestedProjectLoadConfiguration

	(visitedConfigurationNames includes: aNestedProjectLoadConfiguration name)
		ifTrue: [ ^ self ].

	self _visited: aNestedProjectLoadConfiguration. 

	self _processConditionalPackageNames: aNestedProjectLoadConfiguration.

	self _processConditionalPackageMapSpecs: aNestedProjectLoadConfiguration.

	self configurationNames addAll: aNestedProjectLoadConfiguration configurationNames.
	(self _configurations: self configurationBasePath, '/' forProject: aNestedProjectLoadConfiguration projectName)
		do: [:config | config acceptNestedVisitor: self ].
%

category: 'visiting'
method: RwProjectLoadConfigurationVisitor
visitProjectCompoundConfiguration: aProjectCompoundConfiguration

	(visitedConfigurationNames includes: aProjectCompoundConfiguration name)
		ifTrue: [ ^ self ].

	self _visited: aProjectCompoundConfiguration. 

	self _addPackageNames: aProjectCompoundConfiguration packageNames for: aProjectCompoundConfiguration.

	aProjectCompoundConfiguration _configurations
		do: [:config | config acceptCompoundVisitor: self ].
%

category: 'visiting'
method: RwProjectLoadConfigurationVisitor
visitProjectLoadConfiguration: aProjectLoadConfiguration

	| seedGroupNames |
	(visitedConfigurationNames includes: aProjectLoadConfiguration name)
		ifTrue: [ ^ self ].

	self _visited: aProjectLoadConfiguration. 

	definedGroupNames := aProjectLoadConfiguration definedGroupNames.
	seedGroupNames := groupNames asSet copy.
	[seedGroupNames isEmpty ]
		whileFalse: [ 
			seedGroupNames copy do: [:groupName |
				| referencedGroupNames |
				"make sure that required groups are included in group names, recursively"
				seedGroupNames remove: groupName.
				referencedGroupNames := definedGroupNames at: groupName ifAbsent: [ #() ].
				groupNames addAll: referencedGroupNames.
				seedGroupNames addAll: referencedGroupNames ] ].

	self _processConditionalPackageNames: aProjectLoadConfiguration.

	self _processConditionalPackageMapSpecs: aProjectLoadConfiguration.

	self configurationNames addAll: aProjectLoadConfiguration configurationNames.
	(self _configurations: self configurationBasePath, '/' forProject: aProjectLoadConfiguration projectName)
		do: [:config | config acceptNestedVisitor: self ].
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_addPackageNames: somePackageNames for: aConfiguration

	self packageNames addAll: somePackageNames
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_configurations: configDirPath forProject: aProjectName

	| urlBase |
	self configurationNames isEmpty ifTrue: [ ^ #() ].
	urlBase := 'file:' ,configDirPath asFileReference pathString, '/'.
	^ self configurationNames
		collect: [ :configName | 
			| url |
			url := urlBase , configName , '.ston'.
			(RwAbstractProjectConfiguration fromUrl: url)
				projectName: aProjectName;
				yourself ]
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_matchPlatformAttributes: platformPatternMatcher

	self platformAttributes do: [:anObject |
		(platformPatternMatcher match: anObject) ifTrue: [ ^true ] ].
	^false
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_platformAttributeMatchIn: platformMatchersList

	platformMatchersList do: [:platformPatternMatcher |
		(self _matchPlatformAttributes: platformPatternMatcher) 
			ifTrue: [ ^true ] ].
	^false
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_processConditionalPackageMapSpecs: aProjectLoadConfiguration

	| currentUserId |
	currentUserId := Rowan image currentUserId.
	aProjectLoadConfiguration conditionalPackageMapSpecMatchers keysAndValuesDo: [:platformMatcher :thePackageMapSpecsMap | 
		(self _platformAttributeMatchIn: {platformMatcher})
			ifTrue: [
				(thePackageMapSpecsMap 
					at: currentUserId 
					ifAbsent: [ 
						"<allusers> is preferred, but for the alpha, there are outstanding configs that use <default>"
						thePackageMapSpecsMap at: 'default'  
							ifAbsent: [ thePackageMapSpecsMap at: 'allusers'  ifAbsent: [] ] ])
								ifNotNil: [:thePackageMapSpecs |
									(thePackageMapSpecs at: #defaultSymbolDictName otherwise: nil) 
										ifNotNil: [:name | packageMapSpecs at: #defaultSymbolDictName put: name ].
									(thePackageMapSpecs at: #defaultUseSessionMethodsForExtensions otherwise: nil) 
										ifNotNil: [:boolean | packageMapSpecs at: #defaultUseSessionMethodsForExtensions put: boolean  ].
									(thePackageMapSpecs at: #packageNameToPlatformPropertiesMap otherwise: nil) 
										ifNotNil: [:theMap | 
											| map |
											map := packageMapSpecs at: #packageNameToPlatformPropertiesMap ifAbsentPut: [ Dictionary new ].
											theMap keysAndValuesDo: [:thePackageName :thePropMap | 
												thePropMap keysAndValuesDo: [:thePropertyName :thePropertyValue |
													| packageMap |
													packageMap  := map at: thePackageName ifAbsentPut: [ Dictionary new ].
													(#('symbolDictName' 'userId' 'useSessionMethodsForExtensions' ) includes: thePropertyName)
														ifTrue: [ packageMap at: thePropertyName put: thePropertyValue  ] 
														ifFalse: [ self error: 'Unrecognized property name ', thePropertyName printString, ' in package name to properties map' ] ] ] ] ] ] ]
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_processConditionalPackageNames: aProjectLoadConfiguration

	aProjectLoadConfiguration conditionalPackageMatchers keysAndValuesDo: [:platformMatchers :groupMap | 
		(self _platformAttributeMatchIn: platformMatchers)
			ifTrue: [
				groupMap keysAndValuesDo: [:group :map |
					(self groupNames includes: group)
						ifTrue: [ 
							self _addPackageNames: (map at: #packageNames ifAbsent: [ #() ]) for: aProjectLoadConfiguration.
							self configurationNames addAll: (map at: #configurationNames ifAbsent: [ #()] ) ] ] ] ].
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_visited: aConfiguration

	visitedConfigurationNames add:  aConfiguration name.
%

! Class implementation for 'RwProjectLoadComponentVisitor'

!		Instance methods for 'RwProjectLoadComponentVisitor'

category: 'initialization'
method: RwProjectLoadComponentVisitor
initialize

	super initialize.
	projectNames := Set new.
	projectLoadSpecs := Set new.
	visitedComponents := Dictionary new
%

category: 'accessing'
method: RwProjectLoadComponentVisitor
projectBasePath

	^ projectBasePath
%

category: 'accessing'
method: RwProjectLoadComponentVisitor
projectBasePath: aString

	projectBasePath := aString
%

category: 'accessing'
method: RwProjectLoadComponentVisitor
projectComponentDefinition

	^ projectComponentDefinition
%

category: 'accessing'
method: RwProjectLoadComponentVisitor
projectComponentDefinition: aProjectComponentDefinition

	projectComponentDefinition := aProjectComponentDefinition
%

category: 'accessing'
method: RwProjectLoadComponentVisitor
projectLoadSpecs

	^ projectLoadSpecs
%

category: 'accessing'
method: RwProjectLoadComponentVisitor
projectNames

	^ projectNames
%

category: 'visiting'
method: RwProjectLoadComponentVisitor
visitComponentLoadConfiguration: aComponentLoadConfiguration

	| seedGroupNames |
	(visitedConfigurationNames includes: aComponentLoadConfiguration name)
		ifTrue: [ ^ self ].

	self _visited: aComponentLoadConfiguration. 

	definedGroupNames := aComponentLoadConfiguration definedGroupNames.
	seedGroupNames := groupNames asSet copy.
	[seedGroupNames isEmpty ]
		whileFalse: [ 
			seedGroupNames copy do: [:groupName |
				| referencedGroupNames |
				"make sure that required groups are included in group names, recursively"
				seedGroupNames remove: groupName.
				referencedGroupNames := definedGroupNames at: groupName ifAbsent: [ #() ].
				groupNames addAll: referencedGroupNames.
				seedGroupNames addAll: referencedGroupNames ] ].

	self _processConditionalPackageNames: aComponentLoadConfiguration.

	self _processConditionalPackageMapSpecs: aComponentLoadConfiguration.

	self configurationNames addAll: aComponentLoadConfiguration configurationNames.
	(self _configurations: self configurationBasePath, '/' forProject: aComponentLoadConfiguration projectName)
		do: [:config | config acceptNestedVisitor: self ].

	self projectNames addAll: aComponentLoadConfiguration projectNames.
	(self _projects: self projectBasePath, '/' forProject: aComponentLoadConfiguration projectName)
		do: [:projectSpec | projectSpec acceptVisitor: self ].
%

category: 'visiting'
method: RwProjectLoadComponentVisitor
visitComponentSpecification: aComponentSpecification

	self projectLoadSpecs add: aComponentSpecification
%

category: 'accessing'
method: RwProjectLoadComponentVisitor
visitedComponents

	^ visitedComponents
%

category: 'private'
method: RwProjectLoadComponentVisitor
_addPackageNames: somePackageNames for: aComponent

	self projectComponentDefinition addPackages: somePackageNames forComponent: aComponent
%

category: 'private'
method: RwProjectLoadComponentVisitor
_projects: projectDirPath forProject: ignored

	| urlBase |
	self projectNames isEmpty ifTrue: [ ^ #() ].
	urlBase := 'file:' ,projectDirPath asFileReference pathString, '/'.
	^ self projectNames
		collect: [ :prjName | 
			| url |
			url := urlBase , prjName , '.ston'.
			(RwSpecification fromUrl: url)
				projectName: prjName;
				yourself ]
%

category: 'private'
method: RwProjectLoadComponentVisitor
_visited: aComponent

	super _visited: aComponent.
	visitedComponents at: aComponent name put: aComponent.
%

! Class implementation for 'RwProjectLoadConfigurationAnalysisVisitor'

!		Instance methods for 'RwProjectLoadConfigurationAnalysisVisitor'

category: 'initialization'
method: RwProjectLoadConfigurationAnalysisVisitor
initialize

	super initialize.
	visitedConfigurationMap := Dictionary new.
	packageToConfigurationMap := Dictionary new
%

category: 'accessing'
method: RwProjectLoadConfigurationAnalysisVisitor
packageToConfigurationMap 

	^ packageToConfigurationMap
%

category: 'accessing'
method: RwProjectLoadConfigurationAnalysisVisitor
visitedConfigurationMap 

	^ visitedConfigurationMap
%

category: 'private'
method: RwProjectLoadConfigurationAnalysisVisitor
_addPackageNames: somePackageNames for: aConfiguration

	super _addPackageNames: somePackageNames for: aConfiguration.
	somePackageNames do: [:aPackageName |
		(packageToConfigurationMap at: aPackageName ifAbsentPut: [ {} ])
			add: aConfiguration ]
%

category: 'private'
method: RwProjectLoadConfigurationAnalysisVisitor
_visited: aConfiguration

	super _visited: aConfiguration.
	visitedConfigurationMap at:  aConfiguration name put: aConfiguration.
%

! Class implementation for 'RwPropertyModification'

!		Class methods for 'RwPropertyModification'

category: 'instance creation'
classmethod: RwPropertyModification
key: key oldValue: oldValue newValue: newValue

	^(self new)
		key: key;
		oldValue: oldValue;
		newValue: newValue;
		yourself
%

!		Instance methods for 'RwPropertyModification'

category: 'testing'
method: RwPropertyModification
isEmpty

	^oldValue = newValue
%

category: 'Accessing'
method: RwPropertyModification
key
	^key
%

category: 'Updating'
method: RwPropertyModification
key: znewValue
	key := znewValue
%

category: 'Accessing'
method: RwPropertyModification
newValue
	^newValue
%

category: 'Updating'
method: RwPropertyModification
newValue: znewValue
	newValue := znewValue
%

category: 'Accessing'
method: RwPropertyModification
oldValue
	^oldValue
%

category: 'Updating'
method: RwPropertyModification
oldValue: znewValue
	oldValue := znewValue
%

! Class implementation for 'RwUnconditionalPropertyModification'

!		Instance methods for 'RwUnconditionalPropertyModification'

category: 'testing'
method: RwUnconditionalPropertyModification
isEmpty

	^ false
%

! Class implementation for 'RwSpecification'

!		Class methods for 'RwSpecification'

category: 'instance creation'
classmethod: RwSpecification
fromUrl: specNameOrUrl

	"self fromUrl: 'file:/export/foos1/users/dhenrich/dev/_home/shared/repos/rowan/CypressReferenceImplementation/rowanLoadSpec.ston'"

	"self fromUrl: 'sampleLoadSpec'"

	"self fromUrl: 'https://raw.githubusercontent.com/dalehenrich/CypressReferenceImplementation/rowan/rowanLoadSpec.ston'"

	| url |
	url := specNameOrUrl asRwUrl.
	url scheme isNil
		ifTrue: [ 
			^ Rowan image
				loadedProjectNamed: specNameOrUrl
				ifAbsent: [ self error: 'No project named ' , specNameOrUrl printString , ' found' ] ].
	url scheme = 'file'
		ifTrue: [ 
			CypressFileUtilities current
				readStreamFor: url fileName
				in: url pathForDirectory
				do: [ :stream | 
					^ (STON fromStream: stream)
						initializeForImport;
						yourself ] ].
	url scheme asString = 'https'
		ifTrue: [ 
			| client response |
			GsSecureSocket disableCertificateVerificationOnClient.
			client := (Rowan globalNamed: 'ZnClient') new.
			response := client
				beOneShot;
				enforceHttpSuccess: true;
				get: url.
			^ (STON fromString: response decodeFromUTF8)
				initializeForImport;
				yourself ].
	self error: 'Unknown scheme: ' , url scheme printString
%

category: 'instance creation'
classmethod: RwSpecification
new

	^self basicNew initialize
%

!		Instance methods for 'RwSpecification'

category: 'conversion'
method: RwSpecification
asSpecification

	^ self
%

category: 'private'
method: RwSpecification
currentVersion
	"
		0.1.0 - initial version for specs
		0.2.0 - defaultConfigurationNames and defaultGroupNames i.v. added to RwProjectSpecification
		0.3.0 - remoteUrl i.v. added to RwGitRepositorySpecification
	"
	^ '0.3.0'
%

category: 'initialization'
method: RwSpecification
initialize
  
%

category: 'initialization'
method: RwSpecification
initializeForExport
  "if spec has been exported, clear out any of the fields that represent local disk state"
%

category: 'initialization'
method: RwSpecification
initializeForImport

  "if spec has been imported, clear out any of the fields that represent local disk state"
  
%

category: 'copying'
method: RwSpecification
postCopy
  "don't forget to copy any compound state objects"

  
%

category: 'accessing'
method: RwSpecification
projectUrl: ignored
  
%

category: 'accessing'
method: RwSpecification
version

	^ nil
%

! Class implementation for 'RwImageSpecification'

!		Instance methods for 'RwImageSpecification'

category: 'accessing'
method: RwImageSpecification
loadedCommitId

	^ loadedCommitId ifNil: [ '' ]
%

category: 'accessing'
method: RwImageSpecification
loadedCommitId: anObject
  loadedCommitId := anObject
%

category: 'accessing'
method: RwImageSpecification
loadedConfigurationNames

	^ loadedConfigurationNames
%

category: 'accessing'
method: RwImageSpecification
loadedConfigurationNames: aCollection

	loadedConfigurationNames := aCollection
%

category: 'accessing'
method: RwImageSpecification
loadedGroupNames

	^ loadedGroupNames
%

category: 'accessing'
method: RwImageSpecification
loadedGroupNames: aCollection

	loadedGroupNames := aCollection
%

category: 'copying'
method: RwImageSpecification
postCopy
  "don't forget to copy any compound state objects"

  super postCopy
%

category: 'accessing'
method: RwImageSpecification
repositoryUrl

   ^repositoryUrl
%

category: 'accessing'
method: RwImageSpecification
repositoryUrl: anObject

   repositoryUrl := anObject
%

! Class implementation for 'RwGemStoneSpecification'

!		Instance methods for 'RwGemStoneSpecification'

category: 'accessing'
method: RwGemStoneSpecification
defaultMethodEnv

	^ defaultMethodEnv ifNil: [ defaultMethodEnv := 0 ]
%

category: 'accessing'
method: RwGemStoneSpecification
defaultMethodEnv: anInteger

	defaultMethodEnv := anInteger
%

category: 'accessing'
method: RwGemStoneSpecification
defaultSymbolDictName

	^ defaultSymbolDictName ifNil: [ 'UserGlobals' ]
%

category: 'accessing'
method: RwGemStoneSpecification
defaultSymbolDictName: aString

	defaultSymbolDictName := aString
%

category: 'accessing'
method: RwGemStoneSpecification
defaultUseSessionMethodsForExtensions

	^ defaultUseSessionMethodsForExtensions
		ifNil: [ defaultUseSessionMethodsForExtensions := false ]
%

category: 'accessing'
method: RwGemStoneSpecification
defaultUseSessionMethodsForExtensions: aBool

	aBool ifTrue: [ Rowan image ensureSessionMethodsEnabled ].
	defaultUseSessionMethodsForExtensions := aBool
%

category: 'initialization'
method: RwGemStoneSpecification
initialize

	super initialize.
	packageNameToPlatformPropertiesMap := Dictionary new
%

category: 'initialization'
method: RwGemStoneSpecification
initializeForExport
  "if spec has been exported, clear out any of the fields that represent local disk state"

	super initializeForExport.
	projectOwnerId := nil.
%

category: 'accessing'
method: RwGemStoneSpecification
methodEnv: methodEnv forPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ packageNameToPlatformPropertiesMap at: packageName put: Dictionary new ].
	packageProperties at: 'methodEnv' put: methodEnv
%

category: 'accessing'
method: RwGemStoneSpecification
methodEnvForPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ ^ self defaultMethodEnv ].
	^ packageProperties at: 'methodEnv' ifAbsent: [ ^ self defaultMethodEnv ]
%

category: 'accessing'
method: RwGemStoneSpecification
packageNameToPlatformPropertiesMap

	^ packageNameToPlatformPropertiesMap
%

category: 'accessing'
method: RwGemStoneSpecification
packageNameToPlatformPropertiesMap: aDictionary

	packageNameToPlatformPropertiesMap := aDictionary
%

category: 'copying'
method: RwGemStoneSpecification
postCopy

	"don't forget to copy any compound state objects"

	super postCopy.
	packageNameToPlatformPropertiesMap := packageNameToPlatformPropertiesMap copy.
	packageNameToPlatformPropertiesMap
		keysAndValuesDo: [ :key :value | packageNameToPlatformPropertiesMap at: key put: value copy ]
%

category: 'accessing'
method: RwGemStoneSpecification
projectOwnerId

	^ projectOwnerId ifNil: [ Rowan image currentUserId ]
%

category: 'accessing'
method: RwGemStoneSpecification
projectOwnerId: anObject

   projectOwnerId := anObject
%

category: 'accessing'
method: RwGemStoneSpecification
setSymbolDictName: symbolDictName forPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ packageNameToPlatformPropertiesMap at: packageName put: Dictionary new ].
	symbolDictName 
		ifNil: [
			"remove the entry if it exists"
			packageProperties removeKey: 'symbolDictName' ifAbsent: [].
			^self ].
	packageProperties at: 'symbolDictName' put: symbolDictName
%

category: 'accessing'
method: RwGemStoneSpecification
setUseSessionMethodsForExtensions: aBool forPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ packageNameToPlatformPropertiesMap at: packageName put: Dictionary new ].
	aBool 
		ifNil: [
			"remove the entry if it exists"
			packageProperties removeKey: 'useSessionMethodsForExtensions' ifAbsent: [].
			^self ].
	aBool ifTrue: [ Rowan image ensureSessionMethodsEnabled ].
	packageProperties at: 'useSessionMethodsForExtensions' put: aBool
%

category: 'accessing'
method: RwGemStoneSpecification
symbolDictNameForPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ ^ self defaultSymbolDictName ].
	^ packageProperties
		at: 'symbolDictName'
		ifAbsent: [ ^ self defaultSymbolDictName ]
%

category: 'accessing'
method: RwGemStoneSpecification
userId: userId forPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ packageNameToPlatformPropertiesMap at: packageName put: Dictionary new ].
	packageProperties at: 'userId' put: userId
%

category: 'accessing'
method: RwGemStoneSpecification
useSessionMethodsForExtensionsForPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ ^ self defaultUseSessionMethodsForExtensions ].
	^ packageProperties
		at: 'useSessionMethodsForExtensions'
		ifAbsent: [ ^ self defaultUseSessionMethodsForExtensions ]
%

! Class implementation for 'RwProjectSpecification'

!		Class methods for 'RwProjectSpecification'

category: 'instance creation'
classmethod: RwProjectSpecification
newNamed: aString

	^ self new
		specName: aString;
		yourself
%

!		Instance methods for 'RwProjectSpecification'

category: 'converting'
method: RwProjectSpecification
asDefinition

	"answer an RwProjectDefintion created using the reciever"

	^RwProjectDefinition newForSpecification: self
%

category: 'testing'
method: RwProjectSpecification
canCommit
  ^ self repositoryUrl notNil and: [ self repoSpec canCommit ]
%

category: 'accessing'
method: RwProjectSpecification
comment

   ^comment
%

category: 'accessing'
method: RwProjectSpecification
comment: anObject

   comment := anObject
%

category: 'actions'
method: RwProjectSpecification
commitForTool: aRwTool message: messageString
  ^ self repoSpec commitForTool: aRwTool message: messageString
%

category: 'accessing'
method: RwProjectSpecification
configsPath

	^ configsPath ifNil: [ configsPath := 'rowan/configs' ]
%

category: 'accessing'
method: RwProjectSpecification
configsPath: anObject

   configsPath := anObject
%

category: 'accessing'
method: RwProjectSpecification
defaultConfigurationNames

	^ defaultConfigurationNames
%

category: 'accessing'
method: RwProjectSpecification
defaultConfigurationNames: anArray

	defaultConfigurationNames := anArray
%

category: 'accessing'
method: RwProjectSpecification
defaultGroupNames

	^ defaultGroupNames
%

category: 'accessing'
method: RwProjectSpecification
defaultGroupNames: anArray

	defaultGroupNames := anArray
%

category: 'exporting'
method: RwProjectSpecification
export

	| url exportUrl exportPath |
	self repositoryUrl
		ifNil: [ self error: 'exportToUrl: must be used if repositoryUrl has not been set' ].
	url := RwUrl fromString: self repositoryUrl.
	exportPath := self repositoryRootPath asFileReference / self specsPath.
	exportPath ensureCreateDirectory.
	exportUrl := exportPath fileSystem isMemoryFileSystem
		ifTrue: [ 'memory:' , exportPath pathString ]
		ifFalse: [ 'file:' , exportPath pathString, '/' ].
	^ self exportToUrl: exportUrl
%

category: 'exporting'
method: RwProjectSpecification
exportToUrl: fileUrl

	^ self copy
		initializeForExport
		_exportToUrl: fileUrl
%

category: 'exporting'
method: RwProjectSpecification
exportToUrl: fileUrl as: fileName

	^ self copy
		initializeForExport
		_exportToUrl: fileUrl as: fileName
%

category: 'accessing'
method: RwProjectSpecification
imageSpec

	^ imageSpec ifNil: [ imageSpec := RwSimpleProjectImageSpecification new ]
%

category: 'accessing'
method: RwProjectSpecification
imageSpec: anObject

   imageSpec := anObject
%

category: 'initialization'
method: RwProjectSpecification
initializeForExport

	"before spec is exported, clear out any of the fields that are not to be included"

	super initializeForExport.
	imageSpec := nil.
	platformSpec := nil.
	repoSpec initializeForExport
%

category: 'initialization'
method: RwProjectSpecification
initializeForImport

	"if spec has been imported, clear out any of the fields that represent local disk state"

	super initializeForImport.
	imageSpec := nil.
	platformSpec valuesDo: [:each | each initializeForImport ].
	repoSpec initializeForImport
%

category: 'accessing'
method: RwProjectSpecification
loadedCommitId

	imageSpec ifNil: [ ^ '' ].
	^ self imageSpec loadedCommitId
%

category: 'accessing'
method: RwProjectSpecification
loadedConfigurationNames

	imageSpec ifNil: [ ^ #() ].
	^ self imageSpec loadedConfigurationNames
%

category: 'accessing'
method: RwProjectSpecification
loadedGroupNames

	imageSpec ifNil: [ ^ #() ].
	^ self imageSpec loadedGroupNames
%

category: 'accessing'
method: RwProjectSpecification
packageOrGroupNamesToLoad: packageOrGroupNames

	self subclassResponsibility: #packageOrGroupNamesToLoad:
%

category: 'accessing'
method: RwProjectSpecification
packagesPath

	^ self repoPath
%

category: 'accessing'
method: RwProjectSpecification
packagesPath: aString

	self repoPath: aString
%

category: 'accessing'
method: RwProjectSpecification
platformSpec: anObject

   platformSpec := anObject
%

category: 'copying'
method: RwProjectSpecification
postCopy
  "don't forget to copy any compound state objects"

  | oldPlatformSpec |
  super postCopy.
  oldPlatformSpec := platformSpec.
  platformSpec := Dictionary new.
  oldPlatformSpec
    keysAndValuesDo: [ :key :value | platformSpec at: key put: value copy ].
  repoSpec := repoSpec copy.
  imageSpec := imageSpec copy
%

category: 'accessing'
method: RwProjectSpecification
projectUrl

   ^projectUrl
%

category: 'accessing'
method: RwProjectSpecification
projectUrl: anObject

   projectUrl := anObject
%

category: 'actions'
method: RwProjectSpecification
pullForTool: aRwTool remote: remoteString
  ^ self repoSpec pullForTool: aRwTool remote: remoteString
%

category: 'actions'
method: RwProjectSpecification
pushForTool: aRwTool remote: remoteString
  ^ self repoSpec pushForTool: aRwTool remote: remoteString
%

category: 'accessing'
method: RwProjectSpecification
remote

	^ self repoSpec remote
%

category: 'accessing'
method: RwProjectSpecification
remoteUrl

   ^repoSpec remoteUrl
%

category: 'accessing'
method: RwProjectSpecification
repoPath

   ^repoPath ifNil: [ repoPath := 'rowan/src' ]
%

category: 'accessing'
method: RwProjectSpecification
repoPath: anObject

   repoPath := anObject
%

category: 'accessing'
method: RwProjectSpecification
repositoryRootPath
  ^ self repoSpec repositoryRootPath
%

category: 'accessing'
method: RwProjectSpecification
repositoryRootPath: anObject
  self repoSpec repositoryRootPath: anObject
%

category: 'accessing'
method: RwProjectSpecification
repositoryUrl

   ^self imageSpec repositoryUrl
%

category: 'accessing'
method: RwProjectSpecification
repositoryUrl: anObject

   self imageSpec repositoryUrl: anObject
%

category: 'accessing'
method: RwProjectSpecification
repoSpec

   ^repoSpec
%

category: 'accessing'
method: RwProjectSpecification
repoSpec: anObject

   repoSpec := anObject
%

category: 'accessing'
method: RwProjectSpecification
specName

   ^specName
%

category: 'accessing'
method: RwProjectSpecification
specName: anObject

   specName := anObject
%

category: 'accessing'
method: RwProjectSpecification
specsPath

	^ specsPath ifNil: [ specsPath := 'rowan/specs' ]
%

category: 'accessing'
method: RwProjectSpecification
specsPath: anObject

   specsPath := anObject
%

category: 'actions'
method: RwProjectSpecification
updateLoadedCommitIdForTool: aRwTool
  ^ self repoSpec updateLoadedCommitIdForTool: aRwTool
%

category: 'accessing'
method: RwProjectSpecification
useGit

	^ self repoSpec useGit
%

category: 'accessing'
method: RwProjectSpecification
version
	"answer the version of the class --- used to mark the version of the class for objects written to disk"

	"see currentVersion method for list of versions"

	"currently RwProjectSpecification is the only instance being versioned as it represents the version of the whole structure, 
		but I don't want to rule out the possiblity that other specs may need to be independently versioned."

	^ version
%

category: 'exporting'
method: RwProjectSpecification
_exportToUrl: fileUrl
	^ self _exportToUrl: fileUrl as: self specName , '.ston'
%

category: 'exporting'
method: RwProjectSpecification
_exportToUrl: fileUrl as: fileName
  | url |
  url := RwUrl fromString: fileUrl.
  url schemeName = 'file'
    ifTrue: [ 
      CypressFileUtilities current
        writeStreamFor: fileName
        in: url pathForDirectory
        do: [ :stream | 
          | string |
          string := STON toStringPretty: self.
          stream nextPutAll: string.
          ^ self ] ].
  url schemeName = 'memory'
    ifTrue: [ 
		(FileSystem currentMemoryFileSystem workingDirectory / url pathForDirectory / fileName)
			writeStreamDo: [ :stream | 
			  | string |
			  string := STON toStringPretty: self.
			  stream nextPutAll: string.
			  ^ self ] ].
  ^ nil	"otherwise a noop"
%

category: 'private'
method: RwProjectSpecification
_myUserProfile
  ^ System myUserProfile
%

! Class implementation for 'RwComponentSpecification'

!		Instance methods for 'RwComponentSpecification'

category: 'visiting'
method: RwComponentSpecification
acceptVisitor: aVisitor

	^ aVisitor visitComponentSpecification: self
%

category: 'converting'
method: RwComponentSpecification
asDefinition

	"answer an RwComponentProjectDefinition created using the reciever"
	^RwComponentProjectDefinition newForSpecification: self
%

category: 'converting'
method: RwComponentSpecification
asProjectReferenceDefinition

	"answer an RwProjectReferenceDefinition created using the reciever"
	^RwProjectReferenceDefinition newForSpecification: self
%

category: 'accessing'
method: RwComponentSpecification
defaultComponentName

	^ defaultComponentName ifNil: [ 'Core' ]
%

category: 'accessing'
method: RwComponentSpecification
defaultComponentName: aString

	defaultComponentName := aString
%

category: 'accessing'
method: RwComponentSpecification
projectName

	^ projectName ifNil: [ self specName ]
%

category: 'accessing'
method: RwComponentSpecification
projectName: aString

	projectName := aString
%

category: 'accessing'
method: RwComponentSpecification
projectsPath

	^ projectsPath ifNil: [ 'rowan/projects' ]
%

category: 'accessing'
method: RwComponentSpecification
projectsPath: aString 

	projectsPath := aString
%

category: 'accessing'
method: RwComponentSpecification
version

	"return an RwSemanticVersionNumber"

	^ self repoSpec version
%

! Class implementation for 'RwReferenceSpecification'

!		Instance methods for 'RwReferenceSpecification'

category: 'accessing'
method: RwReferenceSpecification
referenceUrl

   ^referenceUrl
%

category: 'accessing'
method: RwReferenceSpecification
referenceUrl: anObject

   referenceUrl := anObject
%

category: 'actions'
method: RwReferenceSpecification
resolve
%

! Class implementation for 'RwRepositorySpecification'

!		Instance methods for 'RwRepositorySpecification'

category: 'testing'
method: RwRepositorySpecification
canCommit
  ^ false
%

category: 'actions'
method: RwRepositorySpecification
commitForTool: aRwTool message: messageString
  "commit not supported by default"

  
%

category: 'initialization'
method: RwRepositorySpecification
initializeForExport
  "if spec has been exported, clear out any of the fields that represent local disk state"

  super initializeForImport.
  repositoryRootPath := nil
%

category: 'initialization'
method: RwRepositorySpecification
initializeForImport
  "if spec has been imported, clear out any of the fields that represent local disk state"

  super initializeForImport.
  repositoryRootPath := nil
%

category: 'copying'
method: RwRepositorySpecification
postCopy
  "don't forget to copy any compound state objects"

  super postCopy
%

category: 'actions'
method: RwRepositorySpecification
pullForTool: aRwTool remote: remoteOrNil
  "pull not supported by default"

  
%

category: 'actions'
method: RwRepositorySpecification
pushForTool: aRwTool remote: remoteOrNil
  "push not supported by default"

  
%

category: 'accessing'
method: RwRepositorySpecification
remoteUrl

	^ nil
%

category: 'accessing'
method: RwRepositorySpecification
repositoryRootPath

   ^repositoryRootPath
%

category: 'accessing'
method: RwRepositorySpecification
repositoryRootPath: anObject

   repositoryRootPath := anObject
%

category: 'accessing'
method: RwRepositorySpecification
repositoryRootReference

   ^repositoryRootPath asFileReference
%

category: 'actions'
method: RwRepositorySpecification
updateLoadedCommitIdForTool: aRwTool
  "commit not supported by default"

  
%

category: 'accessing'
method: RwRepositorySpecification
useGit

	^ false
%

category: 'accessing'
method: RwRepositorySpecification
version

	^ nil
%

! Class implementation for 'RwDiskRepositorySpecification'

!		Instance methods for 'RwDiskRepositorySpecification'

category: 'accessing'
method: RwDiskRepositorySpecification
committish
  ^ ''
%

category: 'accessing'
method: RwDiskRepositorySpecification
committishType
  ^ ''
%

category: 'copying'
method: RwDiskRepositorySpecification
postCopy
  "don't forget to copy any compound state objects"

  super postCopy
%

! Class implementation for 'RwGitRepositorySpecification'

!		Instance methods for 'RwGitRepositorySpecification'

category: 'accessing'
method: RwGitRepositorySpecification
branch: aString

	self committish: aString committishType: 'branch'
%

category: 'testing'
method: RwGitRepositorySpecification
canCommit
  ^ true
%

category: 'actions'
method: RwGitRepositorySpecification
commitForTool: aRwTool message: messageString
  ^ aRwTool doGitCommit: messageString
%

category: 'accessing'
method: RwGitRepositorySpecification
committish
  ^ committish
%

category: 'accessing'
method: RwGitRepositorySpecification
committish: anObject
  committish := anObject
%

category: 'accessing'
method: RwGitRepositorySpecification
committishType

	" branch, SHA, tag, tagPattern"

	^ committishType
%

category: 'accessing'
method: RwGitRepositorySpecification
committishType: anObject
  committishType := anObject
%

category: 'initialization'
method: RwGitRepositorySpecification
initialize
  super initialize.
  committish := 'master'.
  committishType := 'branch'
%

category: 'initialization'
method: RwGitRepositorySpecification
initializeForExport
  "if spec has been exported, clear out any of the fields that represent local disk state"

  super initializeForImport.
  remote := nil
%

category: 'initialization'
method: RwGitRepositorySpecification
initializeForImport
  "if spec has been imported, clear out any of the fields that represent local disk state"

  super initializeForImport.
  remote := nil
%

category: 'copying'
method: RwGitRepositorySpecification
postCopy
  "don't forget to copy any compound state objects"

  super postCopy
%

category: 'actions'
method: RwGitRepositorySpecification
pullForTool: aRwTool remote: remoteString
  ^ aRwTool doGitPull: remoteString
%

category: 'actions'
method: RwGitRepositorySpecification
pushForTool: aRwTool remote: remoteString
  ^ aRwTool doGitPush: remoteString
%

category: 'accessing'
method: RwGitRepositorySpecification
remote

	^ remote ifNil: [ 'origin' ]
%

category: 'accessing'
method: RwGitRepositorySpecification
remote: anObject

   remote := anObject
%

category: 'accessing'
method: RwGitRepositorySpecification
remoteUrl

	^ remoteUrl
%

category: 'accessing'
method: RwGitRepositorySpecification
remoteUrl: aRemoteUrlString

	remoteUrl := aRemoteUrlString
%

category: 'accessing'
method: RwGitRepositorySpecification
SHA: aString

	self committish: aString committishType: 'SHA'
%

category: 'accessing'
method: RwGitRepositorySpecification
tag: aString

	self committish: aString committishType: 'tag'
%

category: 'accessing'
method: RwGitRepositorySpecification
tagPattern: aString

	self committish: aString committishType: 'tagPattern'
%

category: 'actions'
method: RwGitRepositorySpecification
updateLoadedCommitIdForTool: aRwTool
  ^ aRwTool doGitUpdateLoadedCommitId
%

category: 'accessing'
method: RwGitRepositorySpecification
useGit

	^ true
%

category: 'accessing'
method: RwGitRepositorySpecification
version

	| vers |
	vers :=  self versionString.
	vers isEmpty ifTrue: [ ^ nil ].
	^ vers asRwSemanticVersionNumber
%

category: 'accessing'
method: RwGitRepositorySpecification
versionString

	self committishType =  'tag'
		ifFalse: [ ^ '' ].
	self committish first = $v
		ifTrue: [ ^self committish copyFrom: 2 to: self committish size ].
	^self committish
%

! Class implementation for 'RwUrl'

!		Class methods for 'RwUrl'

category: 'instance creation'
classmethod: RwUrl
fromString: aString
  "Return a URL from a string and handle
	a String without a scheme as a HttpUrl."

  "RwUrl fromString: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'"

  "RwUrl fromString: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"

  "RwUrl fromString: 'telnet:chaos.resnet.gatech.edu'"

  "RwUrl fromString: 'file:/etc/passwd'"

  | remainder index scheme fragment newUrl |
  remainder := aString trimSeparators.
  index := remainder indexOf: $#.
  index > 0
    ifTrue: [ 
      "extract the fragment, if any"
      fragment := remainder copyFrom: index + 1 to: remainder size.
      remainder := remainder copyFrom: 1 to: index - 1 ].
  scheme := self schemeNameForString: remainder.
  (scheme = 'http' or: [ scheme = 'https' ])
    ifTrue: [ ^ self httpFromString: aString ].
  newUrl := (self urlClassForScheme: scheme) new
    privateInitializeFromText: remainder.
  newUrl privateFragment: fragment.
  ^ newUrl
%

category: 'constants'
classmethod: RwUrl
schemeName

	"When searching for a class to handle a particular scheme, make sure that Url classes never match by default. This is so that abstract Url classes e.g. HierarchicalUrl can be iterated over, but will not be selected"

	^ #'none'
%

category: 'parsing'
classmethod: RwUrl
schemeNameForString: aString
	"Get the scheme name from a string, or return nil if it's not specified. 
	Used in internal parsing routines - an outsider may as well use asUrl. 
	Return scheme in lowercases."
	
	"Url schemeNameForString: 'http://www.yahoo.com'"
	"Url schemeNameForString: '/etc/passwed'"
	"Url schemeNameForString: '/etc/testing:1.2.3'"

	| index schemeName |
	index := aString indexOf: $: ifAbsent: [^ nil].
	schemeName := aString copyFrom: 1 to: index - 1.
	(schemeName allSatisfy: [:each | each isLetter]) ifFalse: [^ nil].
	^ schemeName asLowercase
%

category: 'parsing'
classmethod: RwUrl
urlClassForScheme: scheme

	"explicitly list the classes to be matched: https://github.com/dalehenrich/Rowan/issues/211"

	^ {RwFileUrl. RwCypressUrl. RwTonelUrl. RwFiletreeUrl. RwGithubUrl. RwGenericUrl. RwHierarchicalUrl. RwSmalltalkRepositoryUrl. RwGitFileTreeUrl}
				detect: [ :urlClass | urlClass schemeName = scheme ]
				ifNone: [ RwGenericUrl ].
%

!		Instance methods for 'RwUrl'

category: 'converting'
method: RwUrl
asRwRepository
  "return a platform appropriate repository for the repository identified in the receiver"

  ^ self subclassResponsibility: #'asRwRepository'
%

category: 'converting'
method: RwUrl
asRwUrl
  ^ self
%

category: 'converting'
method: RwUrl
asString

	^self printString
%

category: 'converting'
method: RwUrl
asUrl
	^self
%

category: 'accessing'
method: RwUrl
authority
	^''
%

category: 'rowan support'
method: RwUrl
createRwRepositoryForFormat: repositoryFormat forPath: repositoryDirectoryPath
  repositoryFormat = 'tonel'
    ifTrue: [ ^ self createRwTonelRepositoryForPath: repositoryDirectoryPath ].
  repositoryFormat = 'filetree'
    ifTrue: [ ^ self createRwFiletreeRepositoryForPath: repositoryDirectoryPath ].
  repositoryFormat = 'cypress'
    ifTrue: [ ^ self createRwCypressRepositoryForPath: repositoryDirectoryPath ]
%

category: 'rowan support'
method: RwUrl
createRwRepositoryForPath: repositoryDirectoryPath
  | hasCypress hasFiletree hasTonel repositoryFormat |
  hasTonel := hasCypress := hasFiletree := false.
  (self fileUtils directoryEntriesFrom: repositoryDirectoryPath)
    do: [ :entry | 
      | filename |
      filename := self fileUtils localNameFrom: entry.
      filename = 'properties.st'
        ifTrue: [ hasTonel := true ].
      filename = '.cypress'
        ifTrue: [ hasCypress := true ].
      filename = '.filetree'
        ifTrue: [ hasFiletree := true ] ].
  hasCypress | hasTonel
    ifTrue: [
      | theFilename |
      theFilename := hasTonel
        ifTrue: [ 'properties.st' ]
        ifFalse: [ '.cypress' ].
      self fileUtils
        readStreamFor: theFilename
        in: repositoryDirectoryPath
        do: [ :fileStream | 
          repositoryFormat := (STON fromStream: fileStream)
            at: #'format'
            ifAbsent: [ 'filetree' ] ].
      ^ self
        createRwRepositoryForFormat: repositoryFormat
        forPath: repositoryDirectoryPath ].
  hasFiletree
    ifTrue: [ ^ self createRwRepositoryForFormat: 'filetree' forPath: repositoryDirectoryPath ].
  ^ self createRwRepositoryForFormat: 'cypress' forPath: repositoryDirectoryPath
%

category: 'rowan support'
method: RwUrl
fileUtils
  ^ Rowan fileUtilities
%

category: 'fragment'
method: RwUrl
fragment
	^fragment
%

category: 'accessing'
method: RwUrl
pathFor: coll
  | ans sz |
  ans := WriteStreamPortable on: String new.
  sz := coll size.
  1 to: sz do: [ :index | 
    | pathElem |
    pathElem := coll at: index.
    ans nextPutAll: pathElem.
    index < sz
      ifTrue: [ ans nextPut: $/ ] ].
  ^ ans contents
%

category: 'printing'
method: RwUrl
printOn: aStream

	^self subclassResponsibility: #printOn:
%

category: 'fragment'
method: RwUrl
privateFragment: aString
	fragment := aString
%

category: 'parsing'
method: RwUrl
privateInitializeFromText: aString

	^self subclassResponsibility: #privateInitializeFromText:
%

category: 'parsing'
method: RwUrl
privateInitializeFromText: aString relativeTo: aUrl
	"initialize from the given string, as a relative URL.  aString will have had the scheme name removed, if it was present to begin with.  If it was, then the scheme name was the same as the receiver's scheme name"

	"by default, just do regular initialization"
	^self privateInitializeFromText: aString
%

category: 'classification'
method: RwUrl
scheme
	"return a string with the scheme of this URL.  For instance, HTTP"

	^self subclassResponsibility: #scheme
%

! Class implementation for 'RwFileUrl'

!		Class methods for 'RwFileUrl'

category: 'instance creation'
classmethod: RwFileUrl
fromString: aString
	"Method that can be called explicitly to create a FileUrl."

	^self new privateInitializeFromText: aString
%

category: 'constants'
classmethod: RwFileUrl
schemeName
	^'file'
%

!		Instance methods for 'RwFileUrl'

category: 'converting'
method: RwFileUrl
asRwRepository
  "return a platform appropriate repository for the repository located in the directory referenced by the receiver"

  ^ self createRwRepositoryForPath: self pathForDirectory
%

category: 'accessing'
method: RwFileUrl
fileName
	"Return the last part of the path,
	most often a filename but can also be a directory."

	^self path last
%

category: 'testing'
method: RwFileUrl
firstPartIsDriveLetter
	"Return true if the first part of the path is a letter
	followed by a $: like 'C:' "
	
	| firstPart |
	path isEmpty ifTrue: [^false].
	firstPart := path first.
	^firstPart size = 2 and: [
		firstPart first isLetter
			and: [firstPart last = $:]]
%

category: 'accessing'
method: RwFileUrl
host
	"Return the host name, either 'localhost', '', or a fully qualified domain name."
	
	^host ifNil: ['']
%

category: 'accessing'
method: RwFileUrl
host: hostName
	"Set the host name, either 'localhost', '', or a fully qualified domain name."
	
	host := hostName
%

category: 'private-initialization'
method: RwFileUrl
host: aHostString pathParts: aCollection isAbsolute: aBoolean

	host := aHostString.
	path := aCollection.
	isAbsolute := aBoolean
%

category: 'private-initialization'
method: RwFileUrl
initializeFromPathString: aPathString
	"<aPathString> is a file path as a String.
	We construct a path collection using various heuristics."

	| pathString hasDriveLetter |
	pathString := aPathString.
	pathString isEmpty ifTrue: [pathString := '/'].
	"Copy without empty string preceeding first / or between duplicated /s."
	path := ((pathString subStrings: '/') copyWithout: '') collect: [:token | token unescapePercents].

	"A path like 'C:' refers in practice to 'c:/'"
	((pathString endsWith: '/') or:
		[(hasDriveLetter := self firstPartIsDriveLetter) and: [path size = 1]])
			ifTrue: [path add: ''].

	"Decide if we are absolute by checking for leading $/ or
	beginning with drive letter. Smarts for other OSes?"
	self isAbsolute: ((pathString beginsWith: '/')
						or: [hasDriveLetter ifNil: [self firstPartIsDriveLetter]])
%

category: 'accessing'
method: RwFileUrl
isAbsolute
	"Should the path be considered absolute to
	the filesystem instead of relative to the default directory?"
 
	^isAbsolute
%

category: 'accessing'
method: RwFileUrl
isAbsolute: aBoolean
	"Set if the path should be considered absolute to
	the filesystem instead of relative to the default directory."

	isAbsolute := aBoolean
%

category: 'accessing'
method: RwFileUrl
path
	"Return an ordered collection of the path elements."
	
	^path
%

category: 'accessing'
method: RwFileUrl
path: aCollection
	"Set the collection of path elements."

	path := aCollection
%

category: 'paths'
method: RwFileUrl
pathDirString
	"Path to directory as url, using slash as delimiter.
	Filename is left out."

	^String streamContents: [ :s |
		isAbsolute ifTrue: [ s nextPut: $/ ].
		1 to: self path size - 1 do: [ :ii |
			s nextPutAll: (path at: ii); nextPut: $/]]
%

category: 'paths'
method: RwFileUrl
pathForDirectory
	"Path using local file system's pathname delimiter.
	DOS paths with drive letters should not
	be prepended with a delimiter even though
	they are absolute. Filename is left out."

	| delimiter |
	delimiter :=  CypressFileUtilities current pathNameDelimiter.
	^String streamContents: [ :s |
		(self isAbsolute and: [self firstPartIsDriveLetter not])
			ifTrue: [ s nextPutAll: delimiter ].
		1 to: self path size - 1 do: [ :ii |
			s nextPutAll: (path at: ii); nextPutAll: delimiter]]
%

category: 'paths'
method: RwFileUrl
pathForFile
  ^ self pathString
%

category: 'private-initialization'
method: RwFileUrl
pathParts: aCollection isAbsolute: aBoolean

	^self host: nil pathParts: aCollection isAbsolute: aBoolean
%

category: 'paths'
method: RwFileUrl
pathString
	"Path as it appears in a URL with $/ as delimiter."
	
	
	^String streamContents: [ :s | | first |
		self isAbsolute ifTrue:[ s nextPut: $/ ].
		first := true.
		self path do: [ :p |
			first ifFalse: [ s nextPut: $/ ].
			first := false.
			s nextPutAll: p  ] ]
%

category: 'copying'
method: RwFileUrl
postCopy
	"Be sure not to share the path with the copy."

	super postCopy.
	path := path copy
%

category: 'printing'
method: RwFileUrl
printOn: aStream
	"Return the FileUrl according to RFC3986
		'file:'['//'<host>]<path>#<fragment>
	Note that <host> being '' is equivalent to 'localhost' and is not printed."

	aStream nextPutAll: self schemeName;
		nextPut: $:.

	"File URLs with hosts (which are fairly useless) cannot be relative."
	host isEmpty ifFalse: [isAbsolute ifFalse: [aStream nextPutAll: '<ErroneousURL>'. ^nil].
						aStream nextPutAll: '//';
						nextPutAll: host].

	aStream
		nextPutAll: self pathString.

	fragment ifNotNil:
		[aStream
			nextPut: $#;
			nextPutAll: fragment ].
%

category: 'private-initialization'
method: RwFileUrl
privateInitializeFromText: aString
	"Calculate host and path from a file URL in String format.
	Some malformed formats are allowed and interpreted by guessing."

	| schemeName pathString bare i |
	bare := aString trimSeparators.
	schemeName := RwUrl schemeNameForString: bare.
	(schemeName == nil  or: [schemeName ~= self schemeName])
		ifTrue: [
			host := ''.
			pathString := bare]
		ifFalse: [
			"First remove schemeName and colon"
			bare := bare copyFrom: (schemeName size + 2) to: bare size.
			"A proper file URL then has two slashes before host,
			A malformed URL is interpreted as using syntax file:<path>."
			(bare beginsWith: '//')
				ifTrue: [i := bare indexOf: $/ startingAt: 3.
						i=0 ifTrue: [
								host := bare copyFrom: 3 to: bare size.
								pathString := '']
							ifFalse: [
								host := bare copyFrom: 3 to: i-1.
								pathString := bare copyFrom: host size + 3 to: bare size]]
				ifFalse: [host := ''.
						pathString := bare]].
	self initializeFromPathString: pathString
%

category: 'private-initialization'
method: RwFileUrl
privateInitializeFromText: pathString relativeTo: aUrl
	"<pathString> should be a filesystem path.
	This url is adjusted to be aUrl + the path."

	| newPath |
	self host: aUrl host.
	self initializeFromPathString: pathString.
	self isAbsolute: aUrl isAbsolute.

	newPath := aUrl path copy.
	newPath removeLast.	"empty string that says its a directory"
	path do: [ :token |
		((token ~= '..') and: [token ~= '.']) ifTrue: [ 
			newPath addLast: token unescapePercents ].
		token = '..' ifTrue: [ 
			newPath isEmpty ifFalse: [ 
				newPath last = '..' ifFalse: [ newPath removeLast ] ] ].
		"token = '.' do nothing" ].
	path := newPath

	
%

category: 'classification'
method: RwFileUrl
scheme
	^self class schemeName
%

category: 'classification'
method: RwFileUrl
schemeName
	^self class schemeName
%

category: 'accessing'
method: RwFileUrl
segments

	^ path
%

! Class implementation for 'RwCypressUrl'

!		Class methods for 'RwCypressUrl'

category: 'constants'
classmethod: RwCypressUrl
schemeName
  ^ 'cypress'
%

! Class implementation for 'RwTonelUrl'

!		Class methods for 'RwTonelUrl'

category: 'constants'
classmethod: RwTonelUrl
schemeName
	^'tonel'
%

!		Instance methods for 'RwTonelUrl'

category: 'converting'
method: RwTonelUrl
asRwRepository
  "return a platform appropriate repository for the repository located in the directory referenced by the receiver"

  ^ self createRwTonelRepositoryForPath: self pathForDirectory
%

! Class implementation for 'RwFiletreeUrl'

!		Class methods for 'RwFiletreeUrl'

category: 'constants'
classmethod: RwFiletreeUrl
schemeName
	^'filetree'
%

!		Instance methods for 'RwFiletreeUrl'

category: 'converting'
method: RwFiletreeUrl
asRwRepository
  "return a platform appropriate repository for the repository located in the directory referenced by the receiver"

  ^ self createRwFiletreeRepositoryForPath: self pathForDirectory
%

category: 'printing'
method: RwFiletreeUrl
printOn: aStream
  aStream
    nextPutAll: self schemeName;
    nextPut: $:.
  aStream nextPutAll: '//'.
  aStream nextPutAll: self pathString
%

category: 'private-initialization'
method: RwFiletreeUrl
privateInitializeFromText: aString
  "Calculate host and path from a file URL in String format.
	Some malformed formats are allowed and interpreted by guessing."

  | schemeName pathString bare |
  host := ''.
  bare := aString trimSeparators.
  schemeName := RwUrl schemeNameForString: bare.
  (schemeName == nil or: [ schemeName ~= self schemeName ])
    ifTrue: [ pathString := bare ]
    ifFalse: [ 
      "First remove schemeName and colon"
      bare := bare copyFrom: schemeName size + 2 to: bare size.
      (bare beginsWith: '//')
        ifTrue: [ pathString := bare copyFrom: 3 to: bare size ]
        ifFalse: [ pathString := bare ] ].
  self initializeFromPathString: pathString
%

! Class implementation for 'RwGithubUrl'

!		Class methods for 'RwGithubUrl'

category: 'constants'
classmethod: RwGithubUrl
schemeName
  ^ 'github'
%

!		Instance methods for 'RwGithubUrl'

category: 'converting'
method: RwGithubUrl
asRwRepository
  "return a platform appropriate repository for the repository identified in the receiver"

  ^ self halt: 'not yet implemented'
%

category: 'accessing'
method: RwGithubUrl
dirPath
  ^ self pathFor: dir
%

category: 'accessing'
method: RwGithubUrl
isAbsolute
	"Should the path be considered absolute to
	the filesystem instead of relative to the default directory?"
 
	^false
%

category: 'printing'
method: RwGithubUrl
printOn: aStream
  aStream
    nextPutAll: self schemeName;
    nextPut: $:.
  aStream nextPutAll: '//'.
  aStream nextPutAll: self pathString
%

category: 'private-initialization'
method: RwGithubUrl
privateInitializeFromText: aString
  | parsedPath |
  super privateInitializeFromText: aString.
  parsedPath := {host} , path.
  (parsedPath
    detect: [ :e | e includes: $: ]
    ifNone: [ 
      project := parsedPath copyFrom: 1 to: parsedPath size - 1.
      dir := parsedPath copyFrom: 2 to: parsedPath size ])
    ifNotNil: [ :pivot | 
      project := parsedPath copyFrom: 1 to: (parsedPath indexOf: pivot) - 1.
      project addLast: (pivot copyUpTo: $:).
      committish := pivot copyFrom: (pivot indexOf: $:) + 1 to: pivot size.
      dir := parsedPath
        copyFrom: (parsedPath indexOf: pivot) + 1
        to: parsedPath size ].
  path := parsedPath.
  host := ''
%

category: 'accessing'
method: RwGithubUrl
projectPath
  ^ self pathFor: project
%

! Class implementation for 'RwGenericUrl'

!		Class methods for 'RwGenericUrl'

category: 'parsing'
classmethod: RwGenericUrl
fromString: aString
	| schemeName locator |
	schemeName := RwUrl schemeNameForString: aString.
	schemeName ifNil: [ ^self schemeName: 'xnoscheme' locator: aString ].
	locator := aString copyFrom: (schemeName size + 2) to: aString size.
	^self schemeName: schemeName locator: locator
%

category: 'instance creation'
classmethod: RwGenericUrl
schemeName: schemeName  locator: locator
	^self new schemeName: schemeName  locator: locator
%

!		Instance methods for 'RwGenericUrl'

category: 'access'
method: RwGenericUrl
locator
	^locator
%

category: 'paths'
method: RwGenericUrl
pathForDirectory

	^self locator
%

category: 'printing'
method: RwGenericUrl
printOn: aStream
	
	self schemeName ifNotNil: [
		aStream nextPutAll: self schemeName; nextPut: $:].
	
	aStream nextPutAll: self locator.

	self fragment ifNotNil: [
		aStream nextPut: $#; nextPutAll: self fragment].
%

category: 'parsing'
method: RwGenericUrl
privateInitializeFromText: aString
	schemeName := RwUrl schemeNameForString: aString.
	locator :=  schemeName 
		ifNil: [ aString ]
		ifNotNil: [ aString copyFrom: (schemeName size+2) to: aString size ].
%

category: 'parsing'
method: RwGenericUrl
privateInitializeFromText: aString relativeTo: aUrl
	schemeName := aUrl schemeName.
	locator := aString.
%

category: 'classification'
method: RwGenericUrl
scheme
	^ self schemeName.
%

category: 'access'
method: RwGenericUrl
schemeName
	^schemeName
%

category: 'private'
method: RwGenericUrl
schemeName: schemeName0  locator: locator0
	schemeName := schemeName0.
	locator := locator0.
%

! Class implementation for 'RwHierarchicalUrl'

!		Class methods for 'RwHierarchicalUrl'

category: 'instance creation'
classmethod: RwHierarchicalUrl
schemeName: schemeName  authority: authority  path: path  query: query
	^self new schemeName: schemeName  authority: authority  path: path  query: query
%

!		Instance methods for 'RwHierarchicalUrl'

category: 'access'
method: RwHierarchicalUrl
authority
	^authority
%

category: 'printing'
method: RwHierarchicalUrl
fullPath
  | ans |
  ans := WriteStreamPortable on: String new.
  path
    do: [ :pathElem | 
      ans nextPut: $/.
      ans nextPutAll: pathElem ].
  self query == nil
    ifFalse: [ 
      ans nextPut: $?.
      ans nextPutAll: self query ].
  self fragment == nil
    ifFalse: [ 
      ans nextPut: $#.
      ans nextPutAll: self fragment ].
  ^ ans contents
%

category: 'access'
method: RwHierarchicalUrl
isAbsolute
	
	path size > 0 ifFalse: [^ false].
	(path at: 1) size > 0 ifFalse: [^ false].
	^ ((path at: 1) at: 1) ~~ $.
%

category: 'access'
method: RwHierarchicalUrl
password
	"http://user:pword@foo.com' asUrl password"
	^password
%

category: 'access'
method: RwHierarchicalUrl
path
	"return a collection of the decoded path elements, as strings"
	^path
%

category: 'access'
method: RwHierarchicalUrl
path: aCollection
	"Set the collection of path elements."

	path := aCollection
%

category: 'access'
method: RwHierarchicalUrl
port
	^port
%

category: 'copying'
method: RwHierarchicalUrl
postCopy
	"Be sure not to share the path with the copy"

	super postCopy.
	path := path copy
%

category: 'printing'
method: RwHierarchicalUrl
printOn: aStream
  aStream nextPutAll: self schemeName.
  aStream nextPutAll: '://'.
  self username
    ifNotNil: [ 
      aStream nextPutAll: self username.
      self password
        ifNotNil: [ 
          aStream nextPutAll: ':'.
          aStream nextPutAll: self password ].
      aStream nextPutAll: '@' ].
  aStream nextPutAll: self authority.
  port
    ifNotNil: [ 
      aStream
        nextPut: $:;
        nextPutAll: port printString ].
  path
    do: [ :pathElem | 
      aStream nextPut: $/.
      aStream nextPutAll: pathElem ].
  self query == nil
    ifFalse: [ 
      aStream nextPut: $?.
      aStream nextPutAll: self query ].
  self fragment == nil
    ifFalse: [ 
      aStream nextPut: $#.
      aStream nextPutAll: self fragment ]
%

category: 'parsing'
method: RwHierarchicalUrl
privateInitializeFromText: aString

	| remainder ind specifiedSchemeName |
	remainder := aString.
	schemeName
		ifNil: [ 
			specifiedSchemeName := RwUrl schemeNameForString: remainder.
			specifiedSchemeName
				ifNotNil: [ 
					schemeName := specifiedSchemeName.
					remainder := remainder copyFrom: schemeName size + 2 to: remainder size ].
			schemeName
				ifNil: [ 
					"assume HTTP"
					schemeName := 'http' ] ].	"remove leading // if it's there"
	(remainder beginsWith: '//')
		ifTrue: [ remainder := remainder copyFrom: 3 to: remainder size ].	"get the query"
	ind := remainder indexOf: $?.
	ind > 0
		ifTrue: [ 
			query := remainder copyFrom: ind + 1 to: remainder size.
			remainder := remainder copyFrom: 1 to: ind - 1 ].	"get the authority"
	ind := remainder indexOf: $/.
	ind > 0
		ifTrue: [ 
			ind = 1
				ifTrue: [ authority := '' ]
				ifFalse: [ 
					authority := remainder copyFrom: 1 to: ind - 1.
					remainder := remainder copyFrom: ind + 1 to: remainder size ] ]
		ifFalse: [ 
			authority := remainder.
			remainder := '' ].	"extract the username+password"
	(authority includes: $@)
		ifTrue: [ 
			username := authority copyUpTo: $@.
			authority := authority
				copyFrom: (authority indexOf: $@) + 1
				to: authority size.
			(username includes: $:)
				ifTrue: [ 
					password := (username copyFrom: (username indexOf: $:) + 1 to: username size)
						unescapePercents asByteArray decodeFromUTF8 asString.
					username := (username copyUpTo: $:) unescapePercents asByteArray
						decodeFromUTF8 asString ]
				ifFalse: [ 
					password := nil.
					username := username unescapePercents asByteArray decodeFromUTF8 asString ] ].	"Extract the port"
	(authority includes: $:)
		ifTrue: [ 
			| lastColonIndex portString |
			lastColonIndex := authority findLast: [ :c | c = $: ].
			portString := authority copyFrom: lastColonIndex + 1 to: authority size.
			(portString allSatisfy: [ :each | each isDigit ])
				ifTrue: [ 
					port := Integer fromString: portString.
					port > 65535
						ifTrue: [ self error: 'Invalid port number' ].
					authority := authority copyFrom: 1 to: lastColonIndex - 1 ]
				ifFalse: [ self error: 'Invalid port number' ] ].	"get the path"
	path := self privateParsePath: remainder relativeTo: #()
%

category: 'parsing'
method: RwHierarchicalUrl
privateParsePath: remainder relativeTo: basePath 
	| nextTok s parsedPath |
	s := remainder readStream.
	parsedPath := OrderedCollection new.
	parsedPath addAll: basePath.
	parsedPath isEmpty ifFalse: [ parsedPath removeLast ].
	
	[ s peek = $/ ifTrue: [ s next ].
	nextTok := WriteStreamPortable on: String new.
	[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].
	nextTok := nextTok contents unescapePercents.
	nextTok = '..' 
		ifTrue: [ parsedPath size > 0 ifTrue: [ parsedPath removeLast ] ]
		ifFalse: [ nextTok ~= '.' ifTrue: [ parsedPath add: nextTok ] ].
	s atEnd ] whileFalse.
	parsedPath isEmpty ifTrue: [ parsedPath add: '' ].
	^ parsedPath
%

category: 'access'
method: RwHierarchicalUrl
query
	"return the query, the part after any ?.  Any %XY's have already been decoded.  If there wasno query part, nil is returned (it is possible to also have an empty query"
	^query 
%

category: 'classification'
method: RwHierarchicalUrl
scheme
	^ self schemeName.
%

category: 'access'
method: RwHierarchicalUrl
schemeName
	^schemeName
%

category: 'private'
method: RwHierarchicalUrl
schemeName: schemeName0  authority: authority0  path: path0  query: query0
	"initialize a new instance"
	schemeName := schemeName0.
	authority := authority0.
	path := path0.
	query := query0.
%

category: 'access'
method: RwHierarchicalUrl
username
	"http://user:pword@foo.com' asUrl username"
	^username
%

! Class implementation for 'RwSmalltalkRepositoryUrl'

!		Class methods for 'RwSmalltalkRepositoryUrl'

category: 'constants'
classmethod: RwSmalltalkRepositoryUrl
schemeName
  ^ 'smalltalk'
%

!		Instance methods for 'RwSmalltalkRepositoryUrl'

category: 'converting'
method: RwSmalltalkRepositoryUrl
asRwRepository
  "return a platform appropriate repository for the repository identified in the receiver"

  ^ self halt: 'not yet implemented'
%

category: 'accessing'
method: RwSmalltalkRepositoryUrl
committish

   ^committish
%

category: 'accessing'
method: RwSmalltalkRepositoryUrl
dir

   ^dir
%

category: 'accessing'
method: RwSmalltalkRepositoryUrl
dirPath
  ^ self pathFor: dir
%

category: 'parsing'
method: RwSmalltalkRepositoryUrl
privateParsePath: remainder relativeTo: basePath
  | parsedPath |
  parsedPath := super privateParsePath: remainder relativeTo: basePath.
  (parsedPath
    detect: [ :e | e includes: $: ]
    ifNone: [ 
      project := parsedPath copyFrom: 1 to: parsedPath size - 1.
      dir := parsedPath copyFrom: 2 to: parsedPath size ])
    ifNotNil: [ :pivot | 
      project := parsedPath copyFrom: 1 to: (parsedPath indexOf: pivot) - 1.
      project addLast: (pivot copyUpTo: $:).
      committish := pivot copyFrom: (pivot indexOf: $:) + 1 to: pivot size.
      dir := parsedPath
        copyFrom: (parsedPath indexOf: pivot) + 1
        to: parsedPath size ].
  ^ parsedPath
%

category: 'accessing'
method: RwSmalltalkRepositoryUrl
project

   ^project
%

category: 'accessing'
method: RwSmalltalkRepositoryUrl
projectPath
  ^ self pathFor: project
%

! Class implementation for 'RwGitFileTreeUrl'

!		Class methods for 'RwGitFileTreeUrl'

category: 'constants'
classmethod: RwGitFileTreeUrl
schemeName
  ^ 'gitfiletree'
%

! Class implementation for 'RwAuditReport'

!		Class methods for 'RwAuditReport'

category: 'other'
classmethod: RwAuditReport
for: anObject

	^self new owner: anObject; 
			log;
			yourself
%

!		Instance methods for 'RwAuditReport'

category: 'other'
method: RwAuditReport
log

	GsFile gciLogClient: '  -- Auditing ', owner prettyName.
%

category: 'other'
method: RwAuditReport
owner

	^owner
%

category: 'other'
method: RwAuditReport
owner: anObject


	owner := anObject
%

category: 'other'
method: RwAuditReport
printOn: aStream
	
	aStream nextPutAll: '==============Auditing ', self owner prettyName asString; lf.
	self do: [:e | 
		(e isKindOf: Array) ifTrue: [
			e do: [:err | err printOn: aStream. aStream lf]
		] ifFalse: [e printOn: aStream].
	]
%

! Class implementation for 'RBFormatterTests'

!		Instance methods for 'RBFormatterTests'

category: 'private'
method: RBFormatterTests
formatClass: aClass
	aClass selectors
		do: [ :each | self formatClass: aClass selector: each ]
%

category: 'private'
method: RBFormatterTests
formatClass: aClass selector: aSymbol
	self formatters
		do: [ :each | self formatClass: aClass selector: aSymbol formatter: each ]
%

category: 'private'
method: RBFormatterTests
formatClass: aClass selector: aSymbol formatter: aFormatterClass
	| source tree1 tree2 | 
	source := aClass sourceCodeAt: aSymbol.
	tree1 := RBParser parseMethod: source.
	tree2 := RBParser 
		parseMethod: (aFormatterClass new format: tree1)
		onError: [ :err :pos | self assert: false ].
	self assert: tree1 = tree2
%

category: 'private'
method: RBFormatterTests
formatMethodSource: source expected: expectedArray
  1 to: self formatters size do: [ :index | 
    | formatter |
    formatter := self formatters at: index.
    self
      formatMethodSource: source
      formatter: formatter
      expected: (expectedArray at: index) ]
%

category: 'private'
method: RBFormatterTests
formatMethodSource: source formatter: aFormatterClass expected: expected
  | tree1 tree2 x |
  tree1 := RBParser parseMethod: source.
  tree2 := RBParser
    parseMethod: (aFormatterClass new format: tree1)
    onError: [ :err :pos | self assert: false ].
  x := tree2 source.
self assert: x size = expected size.
1 to: x size do: [:index | | z y | self assert: (z := x at: index) = (y := expected at: index) ].
  self assert: x = expected.
  self assert: tree1 = tree2
%

category: 'accessing'
method: RBFormatterTests
formatters
	^ Array with: RBFormatter with: RBConfigurableFormatter
%

category: 'testing'
method: RBFormatterTests
testCoreSystem
  #(#'Object' #'Behavior' #'Boolean' #'Integer' #'SmallInteger' #'Collection' #'String')
    do: [ :each | 
      | class |
      class := Rowan globalNamed: each.
      self
        formatClass: class;
        formatClass: class class ]
%

category: 'testing'
method: RBFormatterTests
testIndexingSystem
  #(#'IXCompoundQueryPredicateTests' #'IXGsClassicQueryBlockOptimizerTests' #'IXQueryBlockPredicateTests' #'IXQueryExpressionPrintStringTests' #'IXQueryExpressionTests' #'IXQueryPredicateTests')
    do: [ :each | 
       (Rowan globalNamed: each) ifNotNil: [ :class | 
          class ifNotNilself
            formatClass: class;
            formatClass: class class ] ]
%

category: 'testing'
method: RBFormatterTests
testQueryBlocks
  "GemStone query blocks must have () around predicates when more than one predicate is involved and the only operator between predicates is & ... formatter may be a little more conservative"

  self
    formatMethodSource: 'select: nsc nsc select: { :person | adam == adam }'
    expected:
      {'select: nsc 
	nsc select: {:person | adam == adam}'.
      'select: nsc
  nsc select: { :person | adam == adam }'}.
  self
    formatMethodSource:
      'select: nsc nsc select: { :person | (true) & (1 < person) & (person <= 3) }'
    expected:
      {'select: nsc 
	nsc select: {:person | (true) & (1 < person) & (person <= 3)}'.
      'select: nsc
  nsc select: { :person | true & (1 < person) & (person <= 3) }'}.
  self
    formatMethodSource:
      'select: nsc nsc select: { :person | (person.isMale) & (1 < person.numberOfChildren) & (person.numberOfChildren <= 3) }'
    expected:
      {'select: nsc 
	nsc select: 
			{:person | 
			(person.isMale) & (1 < person.numberOfChildren) 
				& (person.numberOfChildren <= 3)}'.
      'select: nsc
  nsc
    select: { :person | (person.isMale) & (1 < person.numberOfChildren) & (person.numberOfChildren <= 3) }'}.
  self
    formatMethodSource:
      'select: nsc nsc select: { :person | (person.isMale == true) & (1 < person.numberOfChildren) & (person.numberOfChildren <= 3) }'
    expected:
      {'select: nsc 
	nsc select: 
			{:person | 
			(person.isMale == true) & (1 < person.numberOfChildren) 
				& (person.numberOfChildren <= 3)}'.
      'select: nsc
  nsc
    select: { :person | 
      (person.isMale == true) & (1 < person.numberOfChildren)
        & (person.numberOfChildren <= 3) }'}.
  self
    formatMethodSource:
      'select: nsc nsc select: {:person | (person.isMale) & (person.firstName = ''Casey'')}'
    expected:
      {'select: nsc 
	nsc select: {:person | (person.isMale) & (person.firstName = ''Casey'')}'.
      'select: nsc
  nsc select: { :person | (person.isMale) & (person.firstName = ''Casey'') }'}
%

! Class implementation for 'RBGemStoneNumberParserTest'

!		Instance methods for 'RBGemStoneNumberParserTest'

category: 'tests'
method: RBGemStoneNumberParserTest
testNumberParser

	"Bugs in Number class>>fromStream: that needed to be fixed for use in RBParser"

	self assert: (Number rwFromStream: '1.2' readStream) = 1.2.
	self assert: (Number rwFromStream: '1.' readStream) = 1.0.
	self assert: (Number rwFromStream: '1' readStream) = 1.
	self assert: (Number rwFromStream: '16r10000"' readStream) =  65536.
%

category: 'tests'
method: RBGemStoneNumberParserTest
testRadixNumberParser

	"Bugs in Number class>>fromStream: that needed to be fixed for use in RBParser"

	| x |
	self assert: (x := Number rwFromStream: '11rA' readStream) = 10.
%

! Class implementation for 'RBParserTest'

!		Instance methods for 'RBParserTest'

category: 'accessing'
method: RBParserTest
compare: anObject to: anotherObject 
	self assert: anObject hash = anotherObject hash.
	self assert: anObject = anotherObject
%

category: 'accessing'
method: RBParserTest
exampleClasses
	^ Array with: RBParser with: RBScanner with: RBProgramNode with: RBConfigurableFormatter
%

category: 'private'
method: RBParserTest
parseError: each
	RBParser 
		parseExpression: each first 
		onError: [ :string :pos | ^ self assert: pos = each last ].
	self assert: false description: 'Parser didn''t fail'
%

category: 'tests'
method: RBParserTest
testArray
	| tree |
	#(('{}' 0 0) ('{.}' 0 1) ('{..}' 0 2) ('{foo. bar}' 2 1) ('{foo. bar.}' 2 2) ('{foo. bar. .}' 2 3) ('{. foo. bar}' 2 2) ('{foo.. bar}' 2 2)) do: [ :each |
		tree := RBParser parseExpression: each first.
		self assert: tree statements size = each second.
		self assert: tree periods size = each last.
		self assert: tree left = 1.
		self assert: tree right = each first size ]
%

category: 'tests'
method: RBParserTest
testBestNodeFor
	| tree |
	tree := self treeWithReallyEverything.
	tree nodesDo: 
			[:each | 
			each sourceInterval isEmpty 
				ifFalse: 
					[self assert: ((tree bestNodeFor: each sourceInterval) = each 
								or: [each parent isCascade and: [each parent messages last = each]])]]
%

category: 'tests'
method: RBParserTest
testBlockRewrites
	| rewriter tree |
	tree := RBParser 
				parseMethod: 'method: asdf
	<primitive: 1>
	<primitive: 2>
	^asdf + self foo + asdf'.
	rewriter := RBParseTreeRewriter new.
	rewriter 
		replace: 'asdf'
		with: 'fdsa'
		when: [:aNode | aNode parent parent isReturn].
	rewriter replace: 'self foo'
		withValueFrom: [:aNode | RBVariableNode named: aNode selector asString].
	rewriter 
		replaceArgument: 'asdf'
		withValueFrom: [:aNode | RBVariableNode named: 'xxx']
		when: [:aNode | false].
	rewriter executeTree: tree.
	self compare: tree
		to: (RBParser 
				parseMethod: 'method: asdf
	<primitive: 1>
	<primitive: 2>
	^asdf +  foo + fdsa')
%

category: 'tests'
method: RBParserTest
testCascadeReplacement
	| cascade |
	cascade := RBParser parseExpression: 'self foo; bar; baz'.
	(cascade messages at: 2) 
		replaceWith: (RBParser parseExpression: 'self bar: 2').
	self compare: cascade
		to: (RBParser parseExpression: 'self foo; bar: 2; baz')
%

category: 'tests'
method: RBParserTest
testComparingTrees
	self compare: self treeWithEverything to: self treeWithEverything.
	self compare: self treeWithReallyEverything to: self treeWithReallyEverything.
	
	self exampleClasses do: [ :class |
		class selectors do: [ :selector | 
			self
				compare: (class parseTreeFor: selector) 
				to: (class parseTreeFor: selector) ] ]
%

category: 'tests'
method: RBParserTest
testCopy
	| tree |
	tree := self treeWithEverything.
	self compare: tree to: tree copy.
	tree := self treeWithReallyEverything.
	self compare: tree to: tree copy.
	
	self exampleClasses do: [ :class |
		class selectors do: [ :each |
			tree := class parseTreeFor: each.
			self compare: tree to: tree copy ] ]
%

category: 'tests'
method: RBParserTest
testCopyInContext
	| tree |
	tree := self treeWithEverything.
	self compare: tree to: (tree copyInContext: Dictionary new).
	tree := self treeWithReallyEverything.
	self compare: tree to: (tree copyInContext: Dictionary new).
	
	self exampleClasses do: [ :class |
		class selectors do: [ :each |
			tree := class parseTreeFor: each.
			self compare: tree to: (tree copyInContext: Dictionary new) ] ]
%

category: 'tests'
method: RBParserTest
testCreationProtocol
	| messageNode |
	self compare: (RBMessageNode 
				receiver: (RBVariableNode named: 'self')
				selector: #+
				arguments: (Array with: (RBLiteralNode value: 0)))
		to: (RBParser parseExpression: 'self + 0').
	messageNode := RBMessageNode receiver: (RBVariableNode named: 'self')
				selector: #foo.
	self compare: (RBMethodNode selector: #bar
				body: (RBSequenceNode statements: (OrderedCollection 
								with: (RBCascadeNode messages: (OrderedCollection with: messageNode with: messageNode)))))
		to: (RBParser parseMethod: 'bar self foo; foo')
%

category: 'tests'
method: RBParserTest
testEqualToWithMapping
	| tree |
	tree := self treeWithEverything.
	self assert: (tree equalTo: tree withMapping: Dictionary new).
	tree := self treeWithReallyEverything.
	self assert: (tree equalTo: tree withMapping: Dictionary new).
	
	self exampleClasses do: [ :class |
		class selectors do: [ :each |
			tree := class parseTreeFor: each.
			self assert: (tree equalTo: tree withMapping: Dictionary new) ] ]
%

category: 'tests'
method: RBParserTest
testEquivalentExceptRenaming
	#(('a 3-4' 'a 4-3' false ) ('a #[3 4]' 'a #(3 4)' false ) ('a variable1 ~~ "comment" variable2' 'a variable1 ~~ variable2' true ) ('a variable1' 'a variable2' false ) ('a [:a :b | a + b]' 'a [:b :a | a + b]' false ) ('a | a b | a + b' 'a | b a | a + b' true ) ('a | a | a msg1; msg2' 'a | b | b msg2; msg2' false ) ('a c' 'a d' true ) ('a | a b | a := b. ^b msg1' 'a | a b | b := a. ^a msg1' true ) ('a | a b | a := b. ^b msg1: a' 'a | a b | b := a. ^b msg1: a' false ) ('a: b b + 4' 'a: e e + 4' true ) ('a: b b + 4' 'b: b b + 4' false ) ('a: b b: c b + c' 'a: c b: b c + b' true ) ('a: a b: b a + b' 'a: b b: a a + b' false ) ) do: [:each | self assert: ((RBParser parseMethod: each first)
				equalTo: (RBParser parseMethod: (each at: 2))
				exceptForVariables: #('c' ))
				== each last ]
%

category: 'tests'
method: RBParserTest
testFormatter
	self exampleClasses do: [ :class |
		class selectors do: [ :selector | 
		self 
			compare: (class parseTreeFor: selector)
			to: (RBParser parseMethod: (class parseTreeFor: selector) printString) ] ]
%

category: 'tests'
method: RBParserTest
testGsNumberParsing
  | numbers node |
  numbers := #(#('16#11' 16#11)).
  numbers
    do: [ :spec | 
      node := RBParser parseExpression: spec first.
      self assert: node token source = spec first.
      self assert: node value = spec second ]
%

category: 'tests'
method: RBParserTest
testIntervals
	| tree |
	tree := self treeWithReallyEverything.
	tree nodesDo: 
			[:each | 
			(each parent isNil or: [each parent isCascade not and: [ each parent isLiteral not]]) 
				ifTrue: 
					[| newNode source |
					source := tree source copyFrom: each start to: each stop.
					each isPragma ifFalse: [
						newNode := each isMethod 
								ifTrue: [RBParser parseMethod: source]
								ifFalse: [RBParser parseExpression: source].
						self compare: each to: newNode]]]
%

category: 'tests'
method: RBParserTest
testIsA
	| nodes types |
	nodes := Bag new.
	types := Set new.
	#(#(#isAssignment 1) #(#isBlock 1) #(#isCascade 1) #(#isLiteral 2) #(#isMessage 3) #(#isMethod 1) #(#isReturn 1) #(#isSequence 2) #(#isValue 15) #(#isVariable 7) #(#isUsed 10) #(#isDirectlyUsed 9) #(#hasParentheses 1) #(#isBinary 0) #(#isPrimitive 0) #(#isImmediate 10) #(#isWrite 1) #(#isRead 3)) 
		do: 
			[:each | 
			each last timesRepeat: [nodes add: each first].
			types add: each first].
	self treeWithEverything nodesDo: 
			[:each | 
			types do: 
					[:sel | 
					((each respondsTo: sel) and: [each perform: sel]) 
						ifTrue: [nodes remove: sel]]].
	self assert: nodes isEmpty
%

category: 'tests'
method: RBParserTest
testLiteralArray
	| tree collection |
	tree := RBParser parseExpression: '#( a #b #''c'' . + - 1 -2 3.4 #true true #false false #nil nil "comment" ''string'' #[ 1 2 3 ] #(1 2 3))'.
	collection := OrderedCollection new.
	collection add: #a; add: #b; add: #c; add: #'.'; add: #+; add: #-; add: 1; add: -2; add: 3.4; add: #true; add: true; add: #false; add: false; add: #nil; add: nil; add: 'string'; add: #[1 2 3]; add: #(1 2 3).	
	tree value with: collection do: [ :token :value | 
		self assert: token value = value ]
%

category: 'tests'
method: RBParserTest
testLiteralIntevals
	| tree |
	tree := RBParser parseExpression: '#(#a b #( c ))'.
	self assert: tree contents first start = 3.
	self assert: tree contents first stop = 4.
	self assert: tree contents last contents first start = 11
%

category: 'tests'
method: RBParserTest
testMatchInContext
	| tree |
	tree := self treeWithEverything.
	self assert: (tree match: tree inContext: Dictionary new).
	tree := self treeWithReallyEverything.
	self assert: (tree match: tree inContext: Dictionary new).
	
	self exampleClasses do: [ :class |
		class selectors do: [ :each |
			tree := class parseTreeFor: each.
			self assert: (tree match: tree inContext: Dictionary new) ] ]
%

category: 'tests'
method: RBParserTest
testMethodPatterns
	#(#('+ a ^self + a' #+) #('foo ^self foo' #foo) #('foo: a bar: b ^a + b' #foo:bar:)) 
		do: [:each | self assert: (RBParser parseMethodPattern: each first) == each last]
%

category: 'tests'
method: RBParserTest
testModifying
	| tree |
	tree := RBParser 
				parseMethod: 'foo: a bar: b | c | self first. self second. a + b + c'.
	self deny: tree lastIsReturn.
	self deny: (tree body statements at: 2) isUsed.
	self assert: tree body statements last arguments first isUsed.
	self assert: (tree isLast: tree body statements last).
	self deny: (tree isLast: tree body statements first).
	self assert: (tree defines: 'a').
	self deny: (tree defines: 'c').
	self assert: (tree body defines: 'c').
	self deny: (tree body defines: 'a').
	tree
		addReturn;
		selector: #bar:foo:.
	(tree body)
		addTemporaryNamed: 'd';
		removeTemporaryNamed: 'c'.
	self compare: tree
		to: (RBParser 
				parseMethod: 'bar: a foo: b | d | self first. self second. ^a + b + c').
	self 
		assert: ((tree argumentNames asSet)
				removeAll: #('a' 'b');
				yourself) isEmpty.
	self 
		assert: ((tree allDefinedVariables asSet)
				removeAll: #('a' 'b' 'd');
				yourself) isEmpty.
	tree := RBParser parseExpression: 'self foo: 0'.
	tree selector: #+.
	self compare: tree to: (RBParser parseExpression: 'self + 0').
	self should: [tree selector: #foo] raise: TestResult error.
%

category: 'tests'
method: RBParserTest
testMultimatch
	| rewriter count |
	count := 0.
	rewriter := RBParseTreeRewriter new.
	rewriter 
		replace: '``@object at: ``@foo'
		with: '``@object foo: ``@foo'
		when: [:aNode | (count := count + 1) == 2].
	self compare: (rewriter
				executeTree: (RBParser parseExpression: 'self at: (bar at: 3)');
				tree)
		to: (RBParser parseExpression: 'self at: (bar foo: 3)')
%

category: 'tests'
method: RBParserTest
testNodesDo
	| size |
	size := 0.
	self treeWithEverything nodesDo: [:e | size := size + 1].
	self assert: size = 19
%

category: 'tests'
method: RBParserTest
testNumberParsing
  | numbers node |
  numbers := #(#('1' 1) #('-1' -1) #('123' 123) #('123' 123) #('-123' -123) #('1.1' 1.1) #('-1.1' -1.1) #('1.23' 1.23) #('-1.23' -1.23) #('1e3' 1e3) #('1d3' 1d3) #('-1e3' -1e3) #('1e-3' 1e-3) #('-1e-3' -1e-3) #('0.50s2' 0.50s2) #('0.500s3' 0.500s3) #('0.050s3' 0.050s3)).	"('1q3' 1q3) "	"('2r1e8'  2r1e8) ('-2r1e8' -2r1e8) ('2r1E-8' 2r1e-8) ('-2r1e-8' -2r1e-8) "
  numbers
    do: [ :spec | 
      node := RBParser parseExpression: spec first.
      self assert: node token source = spec first.
      self assert: node value = spec second ]
%

category: 'tests'
method: RBParserTest
testNumberRadixParsing
	2 to: 32 do: [ :radix | 
		| radixString |
		radixString := radix printString, 'r'.
		0 to: 72 do: [ :i | 
			| x |
			self  assert: (x := ((RBParser parseExpression: (radixString, (i printStringRadix: radix)))
				value)) = i ] ]
%

category: 'tests'
method: RBParserTest
testParents
	(Array with: self treeWithEverything with: self treeWithReallyEverything) do: [ :tree |
		(Array with: tree with: tree copy) do: [ :root |
			root nodesDo: [ :node |
				node children do: [ :each |
					(each parent isMessage and: [ each parent isCascaded ]) ifFalse: [ 
						self assert: each parent == node.
						self assert: each methodNode == root ] ] ] ] ]
%

category: 'tests'
method: RBParserTest
testParserErrors
	#(#('self foo. + 3' 11) #('#(' 3) #('self 0' 6) #('self asdf;;asfd' 11)) 
		do: [:each | self parseError: each]
%

category: 'tests'
method: RBParserTest
testParsingLiteralMessages
	self assert: (RBParser parseExpression: 'nil self nil') isMessage.
	self assert: (RBParser parseExpression: 'self true') isMessage.
	self assert: (RBParser parseExpression: 'self false') isMessage.
	self assert: (RBParser parseExpression: 'self -1') isMessage.
	
	self assert: (RBParser parseMethod: 'nil') isMethod.
	self assert: (RBParser parseMethod: 'true') isMethod.
	self assert: (RBParser parseMethod: 'false') isMethod
%

category: 'tests'
method: RBParserTest
testPatternCascade
	| rewriter |
	rewriter := RBParseTreeRewriter new.
	rewriter replace: 'self `;messages; foo: 4; `;messages1'
		with: 'self `;messages1; bar: 4; `;messages'.
	self compare: (rewriter
				executeTree: (RBParser 
							parseExpression: 'self foo; printString; foo: 4; bar. self foo: 4');
				tree)
		to: (RBParser 
				parseExpression: 'self bar; bar: 4; foo; printString. self foo:4')
%

category: 'tests'
method: RBParserTest
testPositions
	| blockNode |
	blockNode := RBParser parseExpression: '[:a :b | ]'.
	self assert: blockNode left = 1.
	self assert: blockNode right = 10.
	self assert: blockNode bar = 8.
	self assert: blockNode sourceInterval = (1 to: 10).
	self assert: blockNode size = 1.	"test dummy collection protocol"
	blockNode printString.	"coverage"
	self deny: (blockNode isLast: (RBVariableNode named: 'b')).
	self compare: blockNode
		to: (RBBlockNode 
				arguments: (OrderedCollection with: (RBVariableNode named: 'a')
						with: (RBVariableNode named: 'b'))
				body: (RBSequenceNode statements: OrderedCollection new)).
%

category: 'tests'
method: RBParserTest
testPragmas
	| tree node |
	#( ('foo <foo>' #foo ()) ('foo <foo: 1>' #foo: (1)) ('foo <foo: 1.2>' #foo: (1.2)) ('foo <foo: -3>' #foo: (-3)) ('foo <foo: a>' #foo: (a)) ('foo <foo: #a>' #foo: (a)) ('foo <foo: $a>' #foo: ($a)) ('foo <foo: ''bar''>' #foo: ('bar')) ('foo <foo: true>' #foo: (true)) ('foo <foo: false>' #foo: (false)) ('foo <foo: nil>' #foo: (nil)) ('foo <foo: #(1 2)>' #foo: ((1 2))) ('foo <foo: 1 bar: 2>' #foo:bar: (1 2))) do: [ :each |
		tree := RBParser parseMethod: each first.
		self assert: (tree pragmas size = 1).
		node := tree pragmas first.
		self assert: node selector = each second.
		1 to: node arguments size do: [ :i |
			self assert: (node arguments at: i) value = (each last at: i) ].
		self assert: (each first at: node start) = $<.
		self assert: (each first at: node stop) = $> ]
%

category: 'tests'
method: RBParserTest
testPrimitives
  self assert: (Object parseTreeFor: #'_basicAt:') isPrimitive.
  #(#('foo ^true' false) #('foo <some: tag> ^true' false) #(' foo <some: tag> <primitive: 123> ^true' true))
    do: [ :each | self assert: (RBParser parseMethod: each first) isPrimitive = each last ]
%

category: 'tests'
method: RBParserTest
testProtectedPrimitives
  self assert: (GemStoneParameters parseTreeFor: #'_getArg:key:') isPrimitive.
  #(#('foo ^true' false) #('foo <some: tag> ^true' false) #(' foo <some: tag> <protected primitive: 123> ^true' true))
    do: [ :each | self assert: (RBParser parseMethod: each first) isPrimitive = each last ]
%

category: 'tests'
method: RBParserTest
testQuerying
	| tree aNode arg1Node bNode |
	tree := RBParser 
				parseMethod: ('test: a`	| b |`	b := (self foo: a; bar) baz.`	b := super test: b.`	^[:arg1 | self foa1 + (super foo: arg1 foo: a foo: b)]' 
						copyReplaceAll: '`'
						with: (String with: (Character codePoint: 13))).
	self 
		assert: tree selfMessages asSortedCollection asArray = #(#bar #foa1 #foo:).
	self assert: tree superMessages asSortedCollection asArray 
				= #(#foo:foo:foo: #test:).
	aNode := tree whichNodeIsContainedBy: (112 to: 112).
	self assert: aNode name = 'a'.
	bNode := tree whichNodeIsContainedBy: (119 to: 119).
	self assert: bNode name = 'b'.
	arg1Node := tree whichNodeIsContainedBy: (102 to: 105).
	self assert: arg1Node name = 'arg1'.
	self assert: (arg1Node statementNode isMessage 
				and: [arg1Node statementNode selector = #+]).
	self assert: (arg1Node whoDefines: 'arg1') isBlock.
	self assert: (aNode whoDefines: 'a') isMethod.
	self assert: (aNode whoDefines: 'b') isSequence.
	self assert: (tree whichNodeIsContainedBy: (91 to: 119)) selector 
				= #foo:foo:foo:.
	self assert: (tree whichNodeIsContainedBy: (69 to: 121)) isBlock.
	self assert: (tree whichNodeIsContainedBy: (69 to: 118)) isNil.
	self assert: aNode blockVariables asSortedCollection asArray = #('arg1').
	self assert: aNode temporaryVariables asSortedCollection asArray = #('b').
	self assert: tree allDefinedVariables asSortedCollection asArray 
				= #('a' 'arg1' 'b').
	self assert: tree allArgumentVariables asSortedCollection asArray 
				= #('a' 'arg1').
	self 
		assert: tree allTemporaryVariables asSortedCollection asArray = #('b')
%

category: 'tests'
method: RBParserTest
testReadBeforeWritten
	#(('a ifTrue: [^self]' true ) ('self foo. a := b' false ) ('condition ifTrue: [a := b] ifFalse: [self foo: a]' true ) ('condition ifTrue: [a := b] ifFalse: [self foo]. a isNil' true ) ('condition ifTrue: [a := b]. a := c' false ) ('[a := b] whileFalse: [a isNil]' false ) ('self foo: b' false ) ) do: 
		[:each | 
		self assert: ((RBReadBeforeWrittenTester readBeforeWritten: #('a' ) in: (RBParser parseExpression: each first))
				includes: 'a')
				== each last.
		self assert: (RBReadBeforeWrittenTester isVariable: 'a' readBeforeWrittenIn: (RBParser parseExpression: each first))
				= each last].
	#('| temp read written written1 |
			read ifTrue: [^self].
			written1 := self foo ifFalse: [written := true] ifTrue: [written := false].
			[temp := true] whileTrue: [temp notNil & written].
			^temp' '| read written |
			self foo ifTrue: [written := true] ifFalse: [written := false].
			self foo ifTrue: [read := true].
			^read' '| read written |
			self foo do: [:i | i].
			[| i | i := 1. i == 1] whileFalse: [read notNil]' '| written |
			[written := 2] whileFalse.
			self do: [:each | | read | each & read]' '| read |
			self do: [:each | read := each].
			self do: [:each | each & read]' ) do: 
		[:each | 
		| read | 
		read := RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: (RBParser parseExpression: each).
		self assert: (read size = 1 and: [read includes: 'read'])]
%

category: 'tests'
method: RBParserTest
testReadBeforeWritten1
	self 
		assert: (RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: (RBParser 
						parseMethod: 'addAll: aCollection 
	"Answer aCollection, having added all elements
	 of aCollection to the receiver.

	 Fail if aCollection is not a kind of
	 Collection."

	| newSize elementsSize growSize |
	(newSize := aCollection size * 2) > elements size ifTrue: [self rehash: newSize].
	elementsSize := elements size.
	growSize := elementsSize // 2.
	aCollection do: 
			[:newObject | 
			| hashIndex element |
			newObject == nil ifFalse: 
					[hashIndex := self hashIndexFor: newObject.
					
					[(element := elements at: hashIndex) == nil
						ifTrue: 
							[elements at: hashIndex put: newObject.
							(elementCount := elementCount + 1) > growSize ifTrue: 
									[self expand.
									elementsSize := elements size.
									growSize := elementsSize // 2].
							true]
						ifFalse: [element == newObject]]
							whileFalse: 
								[(hashIndex := hashIndex + 1) > elementsSize ifTrue: [hashIndex := 1]]]].
	^aCollection')) 
				isEmpty
%

category: 'tests'
method: RBParserTest
testReplacingNodes
	| tree search block |
	tree := RBParser 
				parseMethod: '+ a | a b | self ifTrue: [a] ifFalse: [b := c]. a := b. [:b :c :a | a foo: a; foo1: a; foo2: a foo: b]. {a. b}. ^a'.
	search := RBParseTreeSearcher new.
	block := [:aNode :answer | aNode replaceWith: (RBVariableNode named: 'q')].
	search
		matches: 'a' do: block;
		matchesArgument: 'a' do: block.
	search executeTree: tree.
	self 
		assert: tree = (RBParser 
						parseMethod: '+ q | q b | self ifTrue: [q] ifFalse: [b := c]. q := b. [:b :c :q | q foo: q; foo1: q; foo2: q foo: b]. {q. b}. ^q').
	self 
		assert: tree removeDeadCode = (RBParser 
						parseMethod: '+ q | q b | self ifTrue: [] ifFalse: [b := c]. q := b. {q. b}. ^q')
%

category: 'tests'
method: RBParserTest
testRewriteMethods
	"#('source' 'target' 'source pattern' 'target pattern')"
	#(#('arg1: a arg2: b | temp1 temp2 | self stmt1 ifTrue: [^a]. self arg1: a arg2: b' 'arg2: a arg1: b | temp1 temp2 | self stmt1 ifTrue: [^a]. self arg2: b arg2: a' '`arg1: `var1 `arg2: `var2 | `@temps | ``@.stmts. self `arg1: `var1 `arg2: `var2. `@.stmts1' '`arg2: `var1 `arg1: `var2 | `@temps | ``@.stmts. self `arg2: `var2 `arg2: `var1. `@.stmts1') #('arg1: a arg2: b | temp1 temp2 | self stmt1. self arg1: a arg2: b' 'arg1: a arg2: b | temp1 temp2 | [self stmt1] repeat' '`@args: `@vars | `@temps | `@.stmts. self `@args: `@vars' '`@args: `@vars | `@temps | [`@.stmts] repeat') #('+ a | temps | ^self primitiveValue' '- a | temps | ^self primitiveValue' '+ `temp | `@tmps | `@.stmts' '- `temp | `@tmps | `@.stmts') #('a self stmt1. self stmt2' 'a self stmt1. self stmt2' 'b | `@temps | `@.stmts' 'c | `@temps | `@.stmts') #('a <foo: 1 bar: 2>' 'a <bar: 2 foo: 1>' 'a <`sel1: `#arg1 `sel2: `#arg2>' 'a <`sel2: `#arg2 `sel1: `#arg1>') #('a <foo> self foo' 'b <foo> self foo' 'a `@.stmts' 'b `@.stmts'))
		do: 
			[:each | 
			| rewrite |
			rewrite := RBParseTreeRewriter new.
			rewrite replaceMethod: (each at: 3) with: each last.
			self compare: (RBParser 
						parseMethod: (rewrite
								executeTree: (RBParser parseMethod: each first);
								tree) formattedCode)
				to: (RBParser parseMethod: (each at: 2)).
			rewrite := RBParseTreeRewriter new.
			rewrite replaceTree: (RBParser parseRewriteMethod: (each at: 3))
				withTree: (RBParser parseRewriteMethod: each last).
			self compare: (RBParser 
						parseMethod: (rewrite
								executeTree: (RBParser parseMethod: each first);
								tree) formattedCode)
				to: (RBParser parseMethod: (each at: 2))]
%

category: 'tests'
method: RBParserTest
testRewrites
	"#('source' 'target' 'source pattern' 'target pattern')"
	#(('[:c | |a| a foo1; foo2]' '[:c | |a| b foo1; foo2]' 'a' 'b' ) ('self foo: 1. bar foo1 foo: 2. (self foo: a) foo: (b foo: c)' 'self bar: 1. bar foo1 bar: 2. (self bar: a) bar: (b bar: c)' '``@rcvr foo: ``@arg1' '``@rcvr bar: ``@arg1' ) ('3 + 4' '4 + 4' '3' '4' ) ('a := self a' 'b := self a' 'a' 'b' ) ('^self at: 1 put: 2' '^self put: 1 put: 2' '^`@rcvr `at: `@arg1 put: `@arg2' '^`@rcvr put: `@arg1 put: `@arg2' ) ('1 + 2 + 3' '0 + 0 + 0' '`#literal' '0' ) ('1 + 2 + 3. 3 foo: 4' '3 + (2 + 1). 4 foo: 3' '``@rcvr `msg: ``@arg' '``@arg `msg: ``@rcvr' ) ('self foo: a bar: b. 1 foo: a bar: b' '2 foo: a bar: b. 1 foo: a bar: b' 'self `@msg: `@args' '2 `@msg: `@args' ) ('a := b. a := c + d' 'b := a. a := c + d' '`var1 := `var2' '`var2 := `var1' ) ('^self foo value: 1' 'self return: (self foo value: 1)' '^`@anything' 'self return: `@anything' ) ('self first; second. self first; second. self a. self b' '2 timesRepeat: [self first; second]. self a. self b' '`.Stmt1. `.Stmt1. `@.stmts' '2 timesRepeat: [`.Stmt1]. `@.stmts' ) ('[:a | self a: 1 c: 2; b]' '[:a | self d: 2 e: 1; f. self halt]' '`@rcvr `msg1: `@arg1 `msg2: `@arg2; `msg' '`@rcvr d: `@arg2 e: `@arg1; f. self halt' )  ) do: 
		[:each | 
		| rewrite | 
		rewrite := RBParseTreeRewriter new.
		rewrite replace: (each at: 3)
			with: each last.
		self compare: (RBParser parseExpression: (rewrite executeTree: (RBParser parseExpression: each first);
				 tree) formattedCode)
			to: (RBParser parseExpression: (each at: 2))]
%

category: 'tests'
method: RBParserTest
testSearching
	| searcher |
	searcher := RBParseTreeSearcher new.
	searcher matches: '``@rcv at: ``@arg `sel: ``@arg1'
		do: [:aNode :answer | answer + 1].
	self 
		assert: (searcher executeTree: (RBParser 
						parseExpression: 'self at: 1 put: 2; at: 2 ifAbsent: []; ifAbsent: 2 at: 1; at: 4; foo')
				initialAnswer: 0) = 2.
	searcher := RBParseTreeSearcher new.
	searcher matches: '``@rcv `at: ``@arg1 `at: ``@arg2'
		do: [:aNode :answer | answer + 1].
	self 
		assert: (searcher executeTree: (RBParser 
						parseExpression: 'self at: 1 at: 3; at: 1 put: 32; at: 2; foo; at: 1 at: 1 at: 2')
				initialAnswer: 0) = 1.
	searcher := RBParseTreeSearcher new.
	searcher matchesMethod: 'at: `object `put: `o1 ``@rcv `put: 1'
		do: [:aNode :answer | true].
	self assert: (searcher 
				executeTree: (RBParser parseMethod: 'at: a put: b self foo put: 1')
				initialAnswer: false)
%

category: 'tests'
method: RBParserTest
testStatements
	| tree |
	#(('' 0 0) ('.' 0 1) ('| bar |' 0 0) ('| bar | .' 0 1) ('| bar | ..' 0 2) ('foo. bar' 2 1) ('foo. bar.' 2 2) ('foo. bar. .' 2 3) ('. foo. bar' 2 2)) do: [ :each |
		tree := RBParser parseExpression: each first.
		self assert: tree statements size = each second.
		self assert: tree periods size = each last ]
%

category: 'tests'
method: RBParserTest
testSymbolLiteral
	| tree |
	#(('# foo' #foo) ('#"bar"foo' #foo) ('##foo' #foo) ('###foo' #foo) ('#foo:' #foo:) ('#foo::' #'foo::') ('#foo::bar' #'foo::bar') ('#foo::bar:' #'foo::bar:') ('#foo::bar::' #'foo::bar::')) do: [ :pair |
		tree := RBParser parseExpression: pair first.
		self assert: tree value = pair second.		
		self assert: tree start = 1.
		self assert: tree stop = pair first size ].
	#(('#1' 1) ('#12' 12) ('#12.3' 12.3) ('# 1' 1) ('##1' 1) ('#"bar"1' 1)) do: [ :pair | 
		tree := RBParser parseExpression: pair first.
		self assert: tree value = pair second.		
		self assert: tree start > 1.
		self assert: tree stop = pair first size ]
%

category: 'tests'
method: RBParserTest
testSymbolNumber
	| tree |
	#(('#1' 1) ('#12' 12) ('#12.3' 12.3) ('# 1' 1) ('##1' 1) ('#"bar"1' 1)) do: [ :pair | 
		tree := RBParser parseExpression: pair first.
		self assert: tree value = pair second.		
		self assert: tree start > 1.
		self assert: tree stop = pair first size ]
%

category: 'private'
method: RBParserTest
treeWithEverything
	^ RBParser parseMethod: 'method: arg1 | temps | temps := #(10). temps foo; foo. ^(temps collect: [:e | ])'
%

category: 'private'
method: RBParserTest
treeWithReallyEverything
	^ RBParser parseMethod: 'method: arg1 <foo> <foo: 1.2> | temps | temps := #[ 1 2 3 ]. temps := #(true false nil 1 1.2 $a foo #foo ''foo'' #() #(1 2) #[] #[1 2]). { 1 negated. 1 + 2. 1 raisedTo: 2 }. temps foo; foo: self. ^ (temps collect: [:e | | btemps | ((e isNil)) ])'
%

! Class implementation for 'RBProgramNodeTest'

!		Class methods for 'RBProgramNodeTest'

category: 'accessing'
classmethod: RBProgramNodeTest
packageNamesUnderTest
	^ #('AST-Core')
%

!		Instance methods for 'RBProgramNodeTest'

category: 'accessing'
method: RBProgramNodeTest
node
	^ node ifNil: [ node := RBProgramNode new ]
%

category: 'accessing'
method: RBProgramNodeTest
parseExpression: aString
	^ RBParser parseExpression: aString
%

category: 'accessing'
method: RBProgramNodeTest
parseMethod: aString
	^ RBParser parseMethod: aString
%

category: 'running'
method: RBProgramNodeTest
setUp
	super setUp.
	previous := RBProgramNode formatterClass.
	RBProgramNode formatterClass: RBFormatter
%

category: 'running'
method: RBProgramNodeTest
tearDown
  super tearDown.
  RBProgramNode formatterClass: previous.
  node := previous := nil
%

category: 'testing-adding'
method: RBProgramNodeTest
testAddNode
	| tree treeNode |
	tree := self parseExpression: '1. 2'.
	treeNode := tree addNode: (self parseExpression: '3').
	self assert: (self parseExpression: '1. 2. 3') = tree.
	self assert: tree statements last = treeNode.
	
	tree := self parseExpression: '{ 1. 2 }'.
	treeNode := tree addNode: (self parseExpression: '3').
	self assert: (self parseExpression: '{ 1. 2. 3 }') = tree.
	self assert: tree statements last = treeNode
%

category: 'testing-adding'
method: RBProgramNodeTest
testAddNodeBefore
	| tree treeNode |
	tree := self parseExpression: '1. 3'.
	treeNode := tree
		addNode: (self parseExpression: '2')
		before: tree statements last.
	self assert: (self parseExpression: '1. 2. 3') = tree.
	self assert: (tree statements at: 2) = treeNode.
	
	tree := self parseExpression: '{ 1. 3 }'.
	treeNode := tree
		addNode: (self parseExpression: '2')
		before: tree statements last.
	self assert: (self parseExpression: '{ 1. 2. 3 }') = tree.
	self assert: (tree statements at: 2) = treeNode
%

category: 'testing-adding'
method: RBProgramNodeTest
testAddNodeFirst
	| tree treeNode |
	tree := self parseExpression: '2. 3'.
	treeNode := tree addNodeFirst: (self parseExpression: '1').
	self assert: (self parseExpression: '1. 2. 3') = tree.
	self assert: tree statements first = treeNode.
	
	tree := self parseExpression: '{ 2. 3 }'.
	treeNode := tree addNodeFirst: (self parseExpression: '1').
	self assert: (self parseExpression: '{ 1. 2. 3 }') = tree.
	self assert: tree statements first = treeNode
%

category: 'testing-adding'
method: RBProgramNodeTest
testAddNodes
	| tree treeNodes |
	tree := self parseExpression: '1. 2'.
	treeNodes := tree addNodes: (self parseExpression: '3. 4') statements.
	self assert: (self parseExpression: '1. 2. 3. 4') = tree.
	self assert: (tree statements at: 3) = treeNodes first.
	self assert: (tree statements at: 4) = treeNodes last.
	
	tree := self parseExpression: '{ 1. 2 }'.
	treeNodes := tree addNodes: (self parseExpression: '3. 4') statements.
	self assert: (self parseExpression: '{ 1. 2. 3. 4 }') = tree.
	self assert: (tree statements at: 3) = treeNodes first.
	self assert: (tree statements at: 4) = treeNodes last
%

category: 'testing-adding'
method: RBProgramNodeTest
testAddNodesBefore
	| tree treeNodes |
	tree := self parseExpression: '1. 4'.
	treeNodes := tree 
		addNodes: (self parseExpression: '2. 3') statements
		before: tree statements last.
	self assert: (self parseExpression: '1. 2. 3. 4') = tree.
	self assert: (tree statements at: 2) = treeNodes first.
	self assert: (tree statements at: 3) = treeNodes last.
	
	tree := self parseExpression: '{ 1. 4 }'.
	treeNodes := tree 
		addNodes: (self parseExpression: '2. 3') statements
		before: tree statements last.
	self assert: (self parseExpression: '{ 1. 2. 3. 4 }') = tree.
	self assert: (tree statements at: 2) = treeNodes first.
	self assert: (tree statements at: 3) = treeNodes last
%

category: 'testing-adding'
method: RBProgramNodeTest
testAddNodesFirst
	| tree treeNodes |
	tree := self parseExpression: '3. 4'.
	treeNodes := tree addNodesFirst: (self parseExpression: '1. 2') statements.
	self assert: (self parseExpression: '1. 2. 3. 4') = tree.
	self assert: (tree statements at: 1) = treeNodes first.
	self assert: (tree statements at: 2) = treeNodes last.
	
	tree := self parseExpression: '{ 3. 4 }'.
	treeNodes := tree addNodesFirst: (self parseExpression: '1. 2') statements.
	self assert: (self parseExpression: '{ 1. 2. 3. 4 }') = tree.
	self assert: (tree statements at: 1) = treeNodes first.
	self assert: (tree statements at: 2) = treeNodes last
%

category: 'testing-adding'
method: RBProgramNodeTest
testAddReturn
	| tree return |
	tree := self parseExpression: '1. 2'.
	return := tree addReturn.
	self assert: tree statements last = return.
	self assert: (self parseExpression: '1. ^ 2') = tree.
	
	tree := self parseExpression: '3. ^ 4'.
	return := tree addReturn.
	self assert: tree statements last = return.
	self assert: (self parseExpression: '3. ^ 4') = tree
%

category: 'testing-adding'
method: RBProgramNodeTest
testAddSelfReturn
	| tree return |
	tree := self parseExpression: '1. 2'.
	return := tree addSelfReturn.
	self assert: tree statements last = return.
	self assert: (self parseExpression: '1. 2. ^ self') = tree.
	
	tree := self parseExpression: '3. ^ 4'.
	return := tree addSelfReturn.
	self assert: tree statements last = return.
	self assert: (self parseExpression: '3. ^ 4') = tree
%

category: 'testing-adding'
method: RBProgramNodeTest
testAddTemporariesNamed
	| tree variables |
	tree := self parseExpression: '| a | a'.
	variables := tree addTemporariesNamed: #('b' 'c').
	self assert: variables first isVariable.
	self assert: variables first name = 'b'.
	self assert: variables second isVariable.
	self assert: variables second name = 'c'.
	self assert: tree temporaries second = variables first.
	self assert: tree temporaries last = variables second
%

category: 'testing-adding'
method: RBProgramNodeTest
testAddTemporaryNamed
	| tree variable |
	tree := self parseExpression: '| a | a'.
	variable := tree addTemporaryNamed: 'b'.
	self assert: variable isVariable.
	self assert: variable name = 'b'.
	self assert: tree temporaries last = variable
%

category: 'testing-properties'
method: RBProgramNodeTest
testHasProperty
	self deny: (self node hasProperty: #foo).
	self node propertyAt: #foo put: 123.
	self assert: (self node hasProperty: #foo)
%

category: 'testing-properties'
method: RBProgramNodeTest
testPropertyAt
	self should: [ self node propertyAt: #foo ] raise: Error.
	self node propertyAt: #foo put: true.
	self assert: (self node propertyAt: #foo)
%

category: 'testing-properties'
method: RBProgramNodeTest
testPropertyAtIfAbsent
	self assert: (self node propertyAt: #foo ifAbsent: [ true ]).
	self node propertyAt: #foo put: true.
	self assert: (self node propertyAt: #foo ifAbsent: [ false ])
%

category: 'testing-properties'
method: RBProgramNodeTest
testPropertyAtIfAbsentPut
	self assert: (self node propertyAt: #foo ifAbsentPut: [ true ]).
	self assert: (self node propertyAt: #foo ifAbsentPut: [ false ])
%

category: 'testing-properties'
method: RBProgramNodeTest
testRemoveProperty
	self should: [ self node removeProperty: #foo ] raise: Error.
	self node propertyAt: #foo put: true.
	self assert: (self node removeProperty: #foo)
%

category: 'testing-properties'
method: RBProgramNodeTest
testRemovePropertyIfAbsent
	self assert: (self node removeProperty: #foo ifAbsent: [ true ]).
	self node propertyAt: #foo put: true.
	self assert: (self node removeProperty: #foo ifAbsent: [ false ])
%

category: 'testing-replacing'
method: RBProgramNodeTest
testReplaceLiteral
	| tree |
	tree := self parseMethod: 'run "1" 123 "2"'.
	tree body statements first
		replaceWith: (self parseExpression: '$a').
	self assert: tree newSource = 'run "1" $a "2"'.
	
	tree := self parseMethod: 'run "1" 123 "2"'.
	tree body statements first
		replaceWith: (self parseExpression: 'zork').
	self assert: tree newSource = 'run "1" zork "2"'
%

category: 'testing-replacing'
method: RBProgramNodeTest
testReplaceLiteralArray
	| tree |
	tree := self parseMethod: 'run "1" #(1 2 3) "2"'.
	tree body statements first
		replaceWith: (self parseExpression: '#[1 2 3]').
	self assert: tree newSource = 'run "1" #[1 2 3] "2"'.
	
	tree := self parseMethod: 'run "1" #(1 2 3) "2"'.
	tree body statements first
		replaceWith: (self parseExpression: '123').
	self assert: tree newSource = 'run "1" 123 "2"'.

	tree := self parseMethod: 'run "1" #[1 2 3] "2"'.
	tree body statements first
		replaceWith: (self parseExpression: '#(1 2 3)').
	self assert: tree newSource = 'run "1" #(1 2 3) "2"'.
	
	tree := self parseMethod: 'run "1" #[1 2 3] "2"'.
	tree body statements first
		replaceWith: (self parseExpression: '123').
	self assert: tree newSource = 'run "1" 123 "2"'
%

category: 'testing-replacing'
method: RBProgramNodeTest
testReplaceMessage
	| tree |
	tree := self parseMethod: 'run "1" self "2" run "3"'.
	tree body statements first
		replaceWith: (self parseExpression: 'self runCase').
	self assert: tree newSource = 'run "1" self "2" runCase "3"'
%

category: 'testing-replacing'
method: RBProgramNodeTest
testReplaceMessageArgument
	| tree |
	tree := self parseMethod: 'foo "1" self "2" foo: "3" foo "4"'.
	tree body statements first arguments first
		replaceWith: (self parseExpression: 'bar').
	self assert: tree newSource = 'foo "1" self "2" foo: "3" bar "4"'.

	tree := self parseMethod: 'foo "1" self "2" foo: "3" foo "4"'.
	tree body statements first arguments first
		replaceWith: (self parseExpression: 'bar msg1 msg2').
	self assert: tree newSource = 'foo "1" self "2" foo: "3" bar msg1 msg2 "4"'.
	
	tree := self parseMethod: 'foo "1" self "2" foo: "3" foo bar "4"'.
	tree body statements first arguments first
		replaceWith: (self parseExpression: 'bar').
	self assert: tree newSource = 'foo "1" self "2" foo: "3" bar "4"'.
%

category: 'testing-replacing'
method: RBProgramNodeTest
testReplaceMessageReceiver
	| tree |
	tree := self parseMethod: 'foo "1" self "2" foo: "3" 123 "4"'.
	tree body statements first receiver 
		replaceWith: (self parseExpression: 'bar').
	self assert: tree newSource = 'foo "1" bar "2" foo: "3" 123 "4"'.
	
	tree := self parseMethod: 'foo "1" self "2" foo: "3" 123 "4"'.
	tree body statements first receiver 
		replaceWith: (self parseExpression: 'bar msg1 msg2').
	self assert: tree newSource = 'foo "1" bar msg1 msg2 "2" foo: "3" 123 "4"'.
	
	tree := self parseMethod: 'foo "1" self foo "2" foo: "3" 123 "4"'.
	tree body statements first receiver
		replaceWith: (self parseExpression: 'bar').
	self assert: tree newSource = 'foo "1" bar "2" foo: "3" 123 "4"'
%

category: 'testing-replacing'
method: RBProgramNodeTest
testReplaceMethodBinary
	| tree |
	tree := self parseMethod: '= "1" anObject "2" ^ "3" 4 "5"'.
	tree renameSelector: #runCase andArguments: #().
	self assert: tree newSource = 'runCase "2" ^ "3" 4 "5"'.
	
	tree := self parseMethod: '= "1" anObject "2" ^ "3" 4 "5"'.
	tree renameSelector: #~~ andArguments: (Array with: (self parseExpression: 'first')).
	self assert: tree newSource = '~~ "1" first "2" ^ "3" 4 "5"'.

	tree := self parseMethod: '= "1" anObject "2" ^ "3" 4 "5"'.
	tree renameSelector: #assert: andArguments: (Array with: (RBVariableNode named: 'first')).
	self assert: tree newSource = 'assert: "1" first "2" ^ "3" 4 "5"'.

	tree := self parseMethod: '= "1" anObject "2" ^ "3" 4 "5"'.
	tree renameSelector: #assert:description: andArguments: (Array with: (RBVariableNode named: 'first') with: (RBVariableNode named: 'second')).
	self assert: tree newSource = 'assert: first description: second "2" ^ "3" 4 "5"'
%

category: 'testing-replacing'
method: RBProgramNodeTest
testReplaceMethodKeyword
	| tree |
	tree := self parseMethod: 'deny: "1" anObject "2" ^ "3" 4 "5"'.
	tree renameSelector: #runCase andArguments: #().
	self assert: tree newSource = 'runCase "2" ^ "3" 4 "5"'.
	
	tree := self parseMethod: 'deny: "1" anObject "2" ^ "3" 4 "5"'.
	tree renameSelector: #~~ andArguments: (Array with: (self parseExpression: 'first')).
	self assert: tree newSource = '~~ "1" first "2" ^ "3" 4 "5"'.

	tree := self parseMethod: 'deny: "1" anObject "2" ^ "3" 4 "5"'.
	tree renameSelector: #assert: andArguments: (Array with: (RBVariableNode named: 'first')).
	self assert: tree newSource = 'assert: "1" first "2" ^ "3" 4 "5"'.

	tree := self parseMethod: 'deny: "1" anObject "2" ^ "3" 4 "5"'.
	tree renameSelector: #assert:description: andArguments: (Array with: (RBVariableNode named: 'first') with: (RBVariableNode named: 'second')).
	self assert: tree newSource = 'assert: first description: second "2" ^ "3" 4 "5"'
%

category: 'testing-replacing'
method: RBProgramNodeTest
testReplaceMethodKeywordLong
	| tree |
	tree := self parseMethod: 'deny: "1" anObject "2" description: "3" anotherObject "4" ^ "5" 6 "7"'.
	tree renameSelector: #runCase andArguments: #().
	self assert: tree newSource = 'runCase "4" ^ "5" 6 "7"'.
	
	tree := self parseMethod: 'deny: "1" anObject "2" description: "3" anotherObject "4" ^ "5" 6 "7"'.
	tree renameSelector: #~~ andArguments: (Array with: (self parseExpression: 'first')).
	self assert: tree newSource = '~~ first "4" ^ "5" 6 "7"'.

	tree := self parseMethod: 'deny: "1" anObject "2" description: "3" anotherObject "4" ^ "5" 6 "7"'.
	tree renameSelector: #assert: andArguments: (Array with: (self parseExpression: 'first')).
	self assert: tree newSource = 'assert: first "4" ^ "5" 6 "7"'.

	tree := self parseMethod: 'deny: "1" anObject "2" description: "3" anotherObject "4" ^ "5" 6 "7"'.
	tree renameSelector: #assert:description: andArguments: (Array with: (self parseExpression: 'first') with: (self parseExpression: 'second')).
	self assert: tree newSource = 'assert: "1" first "2" description: "3" second "4" ^ "5" 6 "7"'
%

category: 'testing-replacing'
method: RBProgramNodeTest
testReplaceMethodUnary
	| tree |
	tree := self parseMethod: 'run "1" ^ "2" 3 "4"'.
	tree renameSelector: #runCase andArguments: #().
	self assert: tree newSource = 'runCase "1" ^ "2" 3 "4"'.
	
	tree := self parseMethod: 'run "1" ^ "2" 3 "4"'.
	tree renameSelector: #~~ andArguments: (Array with: (self parseExpression: 'first')).
	self assert: tree newSource = '~~ first "1" ^ "2" 3 "4"'.

	tree := self parseMethod: 'run "1" ^ "2" 3 "4"'.
	tree renameSelector: #assert: andArguments: (Array with: (self parseExpression: 'first')).
	self assert: tree newSource = 'assert: first "1" ^ "2" 3 "4"'.

	tree := self parseMethod: 'run "1" ^ "2" 3 "4"'.
	tree renameSelector: #assert:description: andArguments: (Array with: (self parseExpression: 'first') with: (self parseExpression: 'second')).
	self assert: tree newSource = 'assert: first description: second "1" ^ "2" 3 "4"'
%

category: 'testing-replacing'
method: RBProgramNodeTest
testReplaceVariable
	| tree |
	tree := self parseMethod: 'run "1" foo "2"'.
	tree body statements first
		replaceWith: (self parseExpression: 'zork').
	self assert: tree newSource = 'run "1" zork "2"'.
	
	tree := self parseMethod: 'run "1" foo "2"'.
	tree body statements first
		replaceWith: (self parseExpression: '123').
	self assert: tree newSource = 'run "1" 123 "2"'
%

! Class implementation for 'RBSmallDictionaryTest'

!		Instance methods for 'RBSmallDictionaryTest'

category: 'running'
method: RBSmallDictionaryTest
setUp
	super setUp.
	dict := RBSmallDictionary new
%

category: 'testing'
method: RBSmallDictionaryTest
testAtError
	dict at: #a put: 1.
	self shouldnt: [ dict at: #a ] raise: Error.
	self should: [ dict at: #b ] raise: Error
%

category: 'testing'
method: RBSmallDictionaryTest
testAtIfAbsent
	dict at: #a put: 666.
	self assert: (dict at: #a ifAbsent: [ nil ]) = 666.
	self assert: (dict at: #b ifAbsent: [ nil ]) isNil
%

category: 'testing'
method: RBSmallDictionaryTest
testAtPut
	self assert: (dict at: #a put: 3) = 3.
	self assert: (dict at: #a) = 3.
	self assert: (dict at: #a put: 4) = 4.
	self assert: (dict at: #a) = 4.
	self assert: (dict at: nil put: 5) = 5.
	self assert: (dict at: nil) = 5
%

category: 'testing'
method: RBSmallDictionaryTest
testCopy
	| copy |
	dict at: 'France' put: 'Paris'.
	dict at: 'Italie' put: 'Rome'.
	copy := dict copy.
	copy at: 'Germany' put: 'Berlin'.
	dict at: 'Switzerland' put: 'Bern'.
	self assert: copy size = 3.
	self assert: (copy includesKey: 'Germany').
	self deny: (copy includesKey: 'Switzerland').
	self assert: dict size = 3.
	self assert: (dict includesKey: 'Switzerland').
	self deny: (dict includesKey: 'Germany')
%

category: 'testing'
method: RBSmallDictionaryTest
testEmpty
	dict at: 'France' put: 'Paris'.
	dict at: 'Italie' put: 'Rome'.
	dict empty.
	self assert: dict isEmpty.
	self deny: (dict includesKey: 'France').
	self deny: (dict includesKey: 'Italie').
	self assert: dict keys isEmpty.
	self assert: dict values isEmpty
%

category: 'testing'
method: RBSmallDictionaryTest
testIncludesKey
	dict at: 'Italie' put: nil.
	dict at: 'France' put: 'Paris'.
	self assert: (dict includesKey: 'Italie').
	self assert: (dict includesKey: 'France').
	self deny: (dict includesKey: 'Switzerland')
%

category: 'testing'
method: RBSmallDictionaryTest
testKeys
	dict at: 'France' put: 'Paris'.
	dict at: 'Italie' put: 'Rome'.
	self assert: dict keys = #('France' 'Italie')
%

category: 'testing'
method: RBSmallDictionaryTest
testKeysAndValuesDo
	| keys values |
	dict at: 'France' put: 'Paris'.
	dict at: 'Italie' put: 'Rome'.
	keys := OrderedCollection new.
	values := OrderedCollection new.
	dict keysAndValuesDo: [ :key :value | 
		keys add: key.
		values add: value ].
	self assert: keys asArray = #('France' 'Italie').
	self assert: values asArray = #('Paris' 'Rome')
%

category: 'testing'
method: RBSmallDictionaryTest
testKeysDo
	| keys |
	dict at: 'France' put: 'Paris'.
	dict at: 'Italie' put: 'Rome'.
	keys := OrderedCollection new.
	dict keysDo: [ :each | keys add: each ].
	self assert: keys asArray = #('France' 'Italie')
%

category: 'testing'
method: RBSmallDictionaryTest
testRemoveKey
	dict at: #a put: 1.
	dict at: #b put: 2.
	self assert: (dict keys size) = 2.
	self assert: (dict removeKey: #a) = 1.
	self assert: (dict keys size) = 1.
	self assert: (dict at: #a ifAbsent: [ true ]).
	self assert: (dict at: #b) = 2.
	self should: [ dict removeKey: #a ] raise: Error
%

category: 'testing'
method: RBSmallDictionaryTest
testRemoveKeyIfAbsent
	dict at: #a put: 1.
	dict at: #b put: 2.
	self assert: (dict keys size) = 2.
	self assert: (dict removeKey: #a ifAbsent: [ false ]) = 1.
	self assert: (dict keys size) = 1.
	self assert: (dict at: #a ifAbsent: [ true ]).
	self assert: (dict at: #b) = 2.
	self assert: (dict removeKey: #a ifAbsent: [ true ])
%

category: 'testing'
method: RBSmallDictionaryTest
testValues
	dict at: 'France' put: 'Paris'.
	dict at: 'Italie' put: 'Rome'.
	self assert: dict values = #('Paris' 'Rome')
%

category: 'testing'
method: RBSmallDictionaryTest
testValuesDo
	| values |
	dict at: 'France' put: 'Paris'.
	dict at: 'Italie' put: 'Rome'.
	values := OrderedCollection new.
	dict valuesDo: [ :each | values add: each ].
	self assert: values asArray = #('Paris' 'Rome')
%

! Class extensions for 'Behavior'

!		Instance methods for 'Behavior'

category: '*rowan-gemstone-3215'
method: Behavior
moveMethod: aSelector toCategory: categoryName environmentId: envId

	"Moves the method aSelector (a String) from its current category to the
 specified category (also a String).  If either aSelector or categoryName is
 not in the receiver's method dictionary, or if aSelector is already in
 categoryName, generates an error..
 This method does not account for selectors inherited from superclasses."

	| selSym catSym oldCat |
	self _validatePrivilege
		ifFalse: [ ^ nil ].
	(self includesCategory: categoryName environmentId: envId)
		ifFalse: [ ^ self _categoryNotFound: categoryName ].
	oldCat := self categoryOfSelector: aSelector environmentId: envId.

"Backport of a change in behavior that was made in 3.4 and is needed for Rowan" 
"
	oldCat ifNil: [ ^ self _error: #'classErrSelectorNotFound' args: {aSelector} ].
"

	catSym := categoryName asSymbol.
	selSym := aSelector asSymbol.

	(envId ~~ 0
		or: [ self canWriteMethods or: [ GsPackagePolicy current enabled not ] ])
		ifTrue: [ 
			| catDict |
			catDict := self _baseCategorysForStore: envId.
			oldCat ifNotNil: [(catDict at: oldCat) remove: selSym].
			(catDict at: catSym) add: selSym ]
		ifFalse: [ GsPackagePolicy current moveSelector: selSym toCategory: catSym for: self ].
	self _needsAnnouncement
		ifTrue: [ self _announceMethodMoved: (self compiledMethodAt: selSym) oldCategory: oldCat ]
%

category: '*ast-kernel-core'
method: Behavior
parseTreeFor: aSymbol	
	^ RBParser parseMethod: (self sourceCodeAt: aSymbol) onError: [ :msg :pos | ^ nil ]
%

category: '*rowan-gemstone-kernel'
method: Behavior
rowanPackageName

	"answer the name of the package that the receiver is a member of. Answer 'Rowan unpackagedName` if 
		the receiver is not a member of any package"

	| loadedClass |
	loadedClass := Rowan image
		loadedClassForClass: self thisClass
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedClass loadedPackage name
%

category: '*rowan-gemstone-kernel'
method: Behavior
rowanProjectName

	"answer the name of the project that the receiver is a member of. Answer `Rowan unpackagedName` if 
		the receiver is not a member of any project"

	| loadedClass |
	loadedClass := Rowan image
		loadedClassForClass: self thisClass
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedClass loadedProject name
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileExtensionMethod: sourceString category: categoryName packageName: packageName

	| aCategory |
	
	categoryName first == $* ifFalse: [self error: 'Extension category must  contain * as first character'].
	(aCategory isEquivalent: '*', packageName asLowercase) ifFalse: [self error: 'Extension category name must match lowercased name of Rowan package'].
	^ Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategory asString asLowercase
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		inPackageNamed: packageName
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileExtensionMethod: sourceString package: aPackageName

	| aCategory |
	aCategory := '*', aPackageName asLowercase .
	^Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategory asString asLowercase
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileMethod: sourceString category: aCategoryString

	^ Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategoryString asString
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileMethod: sourceString category: aCategoryString packageName: packageName

	^ Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategoryString
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		inPackageNamed: packageName
%

category: '*rowan-gemstone-35x'
method: Behavior
rwGuaranteePersistentMethodDictForEnv: envId
	"in 3.5, the method persistentMethodDictForEnv: DOES NOT always return a GsMethodDictionary,
		as classes are created without a GsMethodDictionary for envId 0."

	<primitive: 2001>
	| prot |
	prot := System _protectedMode .
	[ 
		| newDict |
		(self persistentMethodDictForEnv: envId) ifNotNil: [:oldDict | ^ oldDict ].
		newDict := GsMethodDictionary new.
		self persistentMethodDictForEnv: envId put: newDict.
		^ newDict ] 
		ensure:[ prot _leaveProtectedMode ].
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwMoveMethod: methodSelector toCategory: categoryName

	^ Rowan projectTools browser
		moveMethod: methodSelector
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		toProtocol: categoryName
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwRemoveCategory: categoryName

	^ Rowan projectTools browser
		removeProtocol: categoryName 
		fromClassNamed:  self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwRemoveSelector: methodSelector

	^ Rowan projectTools browser
		removeMethod: methodSelector
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-35x'
method: Behavior
_constraintOn: aSymbol

"Returns the class kind constraint for the instance variable represented by
 aSymbol.  If aSymbol does not represent an instance variable of objects whose
 behavior is defined by the receiver, returns nil.
 If the instance variable aSymbol is not constrained, returns Object ."

| ivNams constrs |

ivNams := instVarNames .
constrs := constraints .
1 to: self instSize do: [ :i |
  aSymbol == (ivNams  at: i) ifTrue:[ ^ self _constraintAt: i ].
].
^ nil
%

category: '*rowan-gemstone-35x'
method: Behavior
_ivOffsetAndConstraint: aSymbol

"Searches the instVarNames instance variable of the receiver for an instance
 variable named aSymbol, and returns an Array containing the offset and the
 constraint for that instance variable.  Returns nil if no instance variable
 exists with the name aSymbol."

| idx |
idx := instVarNames indexOfIdentical: aSymbol .
idx == 0 ifTrue:[ ^ nil ].
^ { idx .  self _constraintAt: idx } 
%

category: '*rowan-gemstone-35x'
method: Behavior
_namedIvConstraintAtOffset: offset

"Returns the constraint, if any, on the named instance variable at the
 specified offset.  Returns Object if there is no such named instance variable,
 or if the instance variable at that offset is not constrained."

(offset > self instSize ) ifTrue:[ ^ Object ] .
^ self _constraintAt: offset 
%

category: '*rowan-gemstone-35x'
method: Behavior
_newConstraint: aClass atOffset: offset

"Execute the constraint change for Behavior | instvar:ConstraintTo:
 assuming all error and variance checks have been done."
| constrs |
self deprecated: 'Behavior>>_newConstraint:atOffset: deprecated, Constraints are no longer supported'.
self _validatePrivilege ifTrue:[ 
  (constrs := constraints) size == 0 ifTrue:[ | sz |
    aClass == Object ifTrue:[ ^ self "do nothing"].
    sz := self instSize .
    (constrs := Array new: sz ) replaceFrom: 1 to: sz withObject: Object.
    constraints := constrs .
  ].
  constrs at: offset put: aClass .
  (aClass == Object) ifFalse:[ self _setConstraintBit ].
  self _refreshClassCache: false .
]
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rowanCopyMethodsAndVariablesFrom: sourceClass dictionaries: dicts

"Copies all instance and class methods, pool dictionaries, and values of
 class variables from the given class to ourselves. 

 Returns an Array of methods in the source class which failed to compile.
 Some of them might be class methods.  The Array will be empty if none failed.

 Method environmentIds are copied from the source methods.
"

| failed srccls targcls sel doit otherCvs |

self _validatePrivilege ifFalse:[ ^ nil ].
self == sourceClass ifTrue:[ 
  "because iteration is directly over the source's categories dictionaries"
  ^ self error: 'source of copy must not be self' 
].
failed := { } .

"Copy pool dictionaries"
sourceClass _poolDictionaries do: [ :dict | | poolDicts |
  poolDicts := poolDictionaries .
  (poolDicts ~~ nil and:[ poolDicts includesIdentical: dict]) ifFalse: [
      poolDicts ifNil:[ poolDicts := { } . poolDictionaries := poolDicts ]
          ifNotNil:[ poolDicts isInvariant ifTrue:[
                       poolDicts := Array withAll: poolDicts . poolDictionaries := poolDicts
                     ]].
      poolDicts add: dict
  ].
].

"Copy class variable values"
otherCvs := sourceClass _classVars .
otherCvs ifNotNil:[ | destCvs |
   destCvs := classVars . 
   otherCvs == destCvs ifTrue: [ self halt ].
   otherCvs associationsDo: [ :assn | | other |
    destCvs ifNotNil:[ other := destCvs associationAt: assn key otherwise: nil ].
	(other == assn)
		ifTrue: [
			"avoid sharing associations between the reciever and sourceClass"
			destCvs removeKey: other key.	"remove the association"
			destCvs at: assn key put: assn value
		].
    (other == nil or: [other value == nil and: [assn value ~~ nil]]) ifTrue: [
        destCvs ifNil:[ destCvs := self _createClassVarsDict ].
        destCvs at: assn key put: assn value
    ].
  ].
].

"Copy class and instance methods"
1 to: 2 do: [ :j | | envId |
  j == 1 ifTrue:[ srccls := sourceClass.  targcls := self ] 
        ifFalse:[ srccls := sourceClass class.  targcls := self class ].
  envId := 0 .
  srccls categorysDo:[ :cat :sels |
      1 to: sels size do: [ :s | | oldMeth |
	sel := sels at: s.
	doit := true.
	doit ifTrue: [ | methEnvId |
          oldMeth := srccls compiledMethodAt: sel environmentId: envId .
	  methEnvId := oldMeth environmentId .
          methEnvId == envId ifFalse:[ self error:'environmentId mismatch']. 
	  ( targcls 
	     _compileMethodTrappingErrors: oldMeth sourceString 
	     dictionaries: dicts category: cat environmentId: envId ) ifNotNil:[
	    failed add: oldMeth 
          ].
        ].
      ].
  ].
].

^failed.
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rwInstVar: aString constrainTo: aClass
"Copy of instVar:constratinTo: without requiring that class be mutable"

"Changes the receiver's constraint on the instance variable named
 aString to aClass.

 The argument aString must be the name of an instance variable defined in the
 receiver or inherited from a superclass.  aClass must be a kind of Class.
 The receiver, and any subclasses for which a constraint change will result,
 must be modifiable; otherwise, an error will be generated.

 If the superclass of the receiver has a constraint on the same instance
 variable, then aClass must be identical to, or a subclass of, that inherited
 constraint.

 For each of the receiver's subclasses, if the constraint on the specified
 instance variable is aClass or is a subclass of aClass, then that constraint
 will be unchanged.  Otherwise, the subclass's constraint will be changed to
 aClass."

| ivInfo offset mySubclasses superConstraintClass |
self _validatePrivilege ifFalse:[ ^ nil ].
aClass _validateIsClass ifFalse:[ ^ nil ].
(Symbol _existingWithAll: aString) ifNotNil:[ :aSymbol |
  ivInfo := self _ivOffsetAndConstraint: aSymbol .
].
ivInfo ifNil:[ ^ self _error: #classErrNotAVar args:{ aString } ] .
offset := ivInfo at: 1 .
superConstraintClass := self superClass _namedIvConstraintAtOffset: offset.
(aClass ~~ Object and: [superConstraintClass ~~ Object])
ifTrue: [ 
	(aClass validateSubclassOf: superConstraintClass) ifFalse:[
	  ^ nil
	] ].
mySubclasses := self subclasses .
self _rwNewConstraint: aClass atOffset: offset .
mySubclasses do:[:x| x _rwNewInheritedConstraint: aClass atOffset: offset ] .
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rwNewConstraint: aClass atOffset: offset

	| oldConstraintsArray newConstraintsArray constraintsIndex instanceVariableNames |
	oldConstraintsArray := constraints.
	newConstraintsArray := oldConstraintsArray copy.
	instanceVariableNames := self class allInstVarNames.
	constraintsIndex := instanceVariableNames indexOf: #constraints.
	self _unsafeAt: constraintsIndex put: newConstraintsArray.

	[ self _newConstraint: aClass atOffset: offset ] on: Deprecated do: [:ex | ex resume ].

	constraints immediateInvariant
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rwNewInheritedConstraint: aClass atOffset: offset

"Change the constraint for offset to aClass if that offset is not
 already constrained to be a subclass of aClass.  Assume all
 variance and error checks have been done."

self _validatePrivilege ifTrue:[ 
  ((self _constraintAt: offset ) isSubclassOf: aClass ) ifFalse:[
    self _rwNewConstraint: aClass atOffset: offset .
    self subclasses do:[:aSubcls|
       aSubcls _rwNewInheritedConstraint: aClass atOffset: offset ].
  ] .
]
 
%

category: '*rowan-gemstone-35x'
method: Behavior
_setConstraintBit

"Sets the constraint bit in the 'format' instance variable of the receiver."

self deprecated: 'Behavior>>_setConstraintBit deprecated, Constraints are no longer supported'.
self _validatePrivilege ifTrue:[
  format := format bitOr: 16#10 .
]
%

category: '*rowan-gemstone-35x'
method: Behavior
_setVaryingConstraint: aClass

"Assign a new value to the constraint on unnamed variables of the receiver,
 assuming all checks have been made."

| constrs ofs |

self deprecated: 'Behavior>>_setVaryingConstraint: deprecated, Constraints are no longer supported'.
self _validatePrivilege ifTrue:[
  constrs := constraints .
  ofs := self instSize + 1 .
  constrs size == 0 ifTrue:[ 
    aClass == Object ifTrue:[ ^ self "nothing to do"].
    (constrs := Array new: ofs) replaceFrom: 1 to: ofs withObject: Object .
    constraints := constrs .
  ].
  constrs at: ofs put: aClass .
  (aClass == Object) ifFalse:[ self _setConstraintBit ].
  self _refreshClassCache: false .
]
%

! Class extensions for 'Boolean'

!		Instance methods for 'Boolean'

category: '*ast-kernel-core'
method: Boolean
rbStoreOn: aStream
  aStream nextPutAll: self asString
%

! Class extensions for 'ByteArray'

!		Instance methods for 'ByteArray'

category: '*rowan-gemstone-kernel'
method: ByteArray
byteArrayMap

	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"

	| map |
	map := ByteArray new: 256 withAll: 0.
	self do: [ :ascii | map at: ascii + 1 put: 1 ].
	^ map
%

! Class extensions for 'CharacterCollection'

!		Instance methods for 'CharacterCollection'

category: '*rowan-gemstone-kernel'
method: CharacterCollection
asRwGemStoneVersionNumber

	^ RwGemStoneVersionNumber fromString: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
asRwRepository

	"return a platform appropriate repository for the repository identified in the receiver"

	^ self asRwUrl asRwRepository
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
asRwSemanticVersionNumber

	^ RwSemanticVersionNumber fromString: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
asRwUrl

	""

	^ RwUrl fromString: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
indexOfAnyOf: specialChars startingAt: oldPos

	oldPos to: self size do: [ :i | 
		(specialChars includes: (self at: i))
			ifTrue: [ ^ i ] ].
	^ 0
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
indexOfAnyOf: aByteArray startingAt: start ifAbsent: aBlock

	"returns the index of the first character in the given set, starting from start"

	| ans |
	ans := self class
		findFirstInString: self
		inSet: aByteArray asByteArray byteArrayMap
		startingAt: start.
	ans = 0
		ifTrue: [ ^ aBlock value ]
		ifFalse: [ ^ ans ]
%

category: '*ast-kernel-core'
method: CharacterCollection
rbStoreOn: aStream
  "Print inside string quotes, doubling inbedded quotes."

  | x |
  aStream nextPut: $'.
  1 to: self size do: [ :i | 
    aStream nextPut: (x := self at: i).
    x = $'
      ifTrue: [ aStream nextPut: x ] ].
  aStream nextPut: $'
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
rwPlatformAttributeMatchForGemStoneVersion: anRwGemStoneVersionConfigurationPlatformAttributeMatcher

	^ anRwGemStoneVersionConfigurationPlatformAttributeMatcher matchString: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
rwPlatformAttributeMatchForString: anRwStringConfigurationPlatformAttributeMatcher

	^ anRwStringConfigurationPlatformAttributeMatcher matchString: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
rwSemanticIntegerLessThanSelf: anInteger

	"integers have greater precedence than strings"
	"anInteger < aString-> true"

  ^ true
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
rwSemanticStringLessThanSelf: aString

	^ aString < self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
rwSemanticVersionComponentLessThan: aRwSemanticVersonComponent

	^ aRwSemanticVersonComponent rwSemanticStringLessThanSelf: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
unescapePercents

	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"

	| ans c asciiVal pos oldPos specialChars |
	ans _ WriteStream on: String new.
	oldPos _ 1.
	specialChars _ '+%'.

	[ 
	pos _ self indexOfAnyOf: specialChars startingAt: oldPos.
	pos > 0 ]
		whileTrue: [ 
			ans nextPutAll: (self copyFrom: oldPos to: pos - 1).
			c _ self at: pos.
			c = $+
				ifTrue: [ ans nextPut: $  ]
				ifFalse: [ 
					(c = $% and: [ pos + 2 <= self size ])
						ifTrue: [ 
							asciiVal _ ((self at: pos + 1) asUppercase digitValueInRadix: 16) * 16
								+ ((self at: pos + 2) asUppercase digitValueInRadix: 16).
							pos _ pos + 2.
							asciiVal > 255
								ifTrue: [ ^ self ].	"not really an escaped string"
							ans nextPut: (Character value: asciiVal) ]
						ifFalse: [ ans nextPut: c ] ].
			oldPos _ pos + 1 ].
	ans nextPutAll: (self copyFrom: oldPos to: self size).
	^ ans contents
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
withGemstoneLineEndings

	"assume the string is textual, and that CR, LF, and CRLF are all 
  valid line endings.  Replace each occurence with a single LF"

	| cr lf crlf inPos outPos outString lineEndPos newOutPos |
	cr := Character cr.
	lf := Character lf.
	crlf := ByteArray new.
	crlf
		add: cr asciiValue;
		add: lf asciiValue.

	inPos := 1.
	outPos := 1.
	outString := self class _newString: self size.

	[ 
	lineEndPos := self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [ 0 ].
	lineEndPos ~= 0 ]
		whileTrue: [ 
			newOutPos := outPos + (lineEndPos - inPos + 1).
			outString
				replaceFrom: outPos
				to: newOutPos - 2
				with: self
				startingAt: inPos.
			outString at: newOutPos - 1 put: lf.
			outPos := newOutPos.

			((self at: lineEndPos) = cr
				and: [ lineEndPos < self size and: [ (self at: lineEndPos + 1) = lf ] ])
				ifTrue: [ 
					"CRLF ending"
					inPos := lineEndPos + 2 ]
				ifFalse: [ 
					"CR or LF ending"
					inPos := lineEndPos + 1 ] ].	"no more line endings.  copy the rest"
	newOutPos := outPos + (self size - inPos + 1).
	outString
		replaceFrom: outPos
		to: newOutPos - 1
		with: self
		startingAt: inPos.

	^ outString copyFrom: 1 to: newOutPos - 1
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
withoutGemstoneLineEndings

	"assume the string is textual, and that CR, LF, and CRLF are all 
	valid line endings.  Remove each occurence. "

	| cr lf crlf inPos outPos outString lineEndPos newOutPos |
	cr := Character cr.
	lf := Character lf.
	crlf := ByteArray new.
	crlf
		add: cr asciiValue;
		add: lf asciiValue.

	inPos := 1.
	outPos := 1.
	outString := self class _newString: self size.

	[ 
	lineEndPos := self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [ 0 ].
	lineEndPos ~= 0 ]
		whileTrue: [ 
			newOutPos := outPos + (lineEndPos - inPos + 1).
			outString
				replaceFrom: outPos
				to: newOutPos - 2
				with: self
				startingAt: inPos.
			outPos := newOutPos - 1.

			((self at: lineEndPos) = cr
				and: [ lineEndPos < self size and: [ (self at: lineEndPos + 1) = lf ] ])
				ifTrue: [ 
					"CRLF ending"
					inPos := lineEndPos + 2 ]
				ifFalse: [ 
					"CR or LF ending"
					inPos := lineEndPos + 1 ] ].	"no more line endings.  copy the rest"
	newOutPos := outPos + (self size - inPos + 1).
	outString
		replaceFrom: outPos
		to: newOutPos - 1
		with: self
		startingAt: inPos.

	^ outString copyFrom: 1 to: newOutPos - 1
%

! Class extensions for 'Class'

!		Instance methods for 'Class'

category: '*rowan-gemstone-35x'
method: Class
indexableSubclass: aString instVarNames: anArrayOfInstvarNames classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDict inDictionary: aDictionary newVersionOf: oldClass description: aDescription constraints: constraintsArray options: optionsArray
	^ self indexableSubclass: aString instVarNames: anArrayOfInstvarNames classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDict inDictionary: aDictionary newVersionOf: oldClass description: aDescription options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwByteSubclass: aString classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'bytes'
		superclass: self name asString
		instVarNames: #()
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwByteSubclass: aString classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName  options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'bytes'
		superclass: self name asString
		instVarNames: #()
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: #()
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwComment

	"Provide direct access to comment of class, bypassing default comeent string."
  
  ^ (self _extraDictAt: #comment) ifNil: [ '' ]
%

category: '*rowan-gemstone-kernel'
method: Class
rwComment: aString

	^ Rowan projectTools browser
		updateClassComment: aString
		forClassNamed: self thisClass name asString
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: #()
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: #()
		options: optionsArray
%

category: '*rowan-gemstone-35x'
method: Class
subclass: aString instVarNames: anArrayOfInstvarNames classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts inDictionary: aDictionary newVersionOf: oldClass description: aDescription constraints: theConstraints options: optionsArray
	^ self subclass: aString instVarNames: anArrayOfInstvarNames classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts inDictionary: aDictionary newVersionOf: oldClass description: aDescription options: optionsArray
%

category: '*rowan-gemstone-35x'
method: Class
_constraintsEqual: anArray
  "Result true if receiver's constraints equal to anArray or 
   if anArray is empty and receiver's constraints are all Object ."
^ [ | myConstr superInstSiz ofs arySiz |
    anArray _isArray ifTrue:[
      myConstr := constraints .
      superInstSiz := superClass ifNil:[ 0 ] ifNotNil:[:sc | sc instSize] .
      (arySiz := anArray size) == 0 ifTrue:[
	superInstSiz + 1 to: myConstr size do:[:j | 
	  (myConstr at:j ) == Object ifFalse:[ 
	     (j == (self instSize + 1) and:[ superClass ~~ nil]) ifTrue:[
	       ^ self _varyingConstraint isVersionOf: superClass _varyingConstraint 
	     ].
	     ^ false 
	  ].
	].
      ] ifFalse:[ | varConstr instSiz myConstrSiz ivNams |
	instSiz := self instSize .
	varConstr := (myConstr atOrNil: instSiz + 1) ifNil:[ Object]. 
	ofs := 1 .
	myConstr := myConstr copyFrom: superInstSiz + 1 to: instSiz .
	"elements of myConstr, and varConstr, set to nil when finding a matching
	 element in anArray."
	myConstrSiz := myConstr size .
	ivNams := instVarNames .
	1 to: arySiz do:[:j | | elem |
	  elem := anArray at: j .
	  elem _isArray ifTrue:[ | ivNam |
	    ivNam := elem atOrNil: 1 .
	    1 to: myConstrSiz do:[:m |
	      (ivNams at: (superInstSiz + m)) == ivNam ifTrue:[ 
		 ((elem atOrNil: 2) isVersionOf: (myConstr at: m))   ifTrue:[
		   myConstr at: m put: nil .
		 ] ifFalse:[
		   ^ false 
		 ].
	      ].
	    ].
	  ] ifFalse:[
	    j == arySiz ifTrue:[ 
	      (elem isVersionOf: varConstr) ifTrue:[ varConstr := nil ] ifFalse:[ ^ false ]
	    ] ifFalse:[ 
	      ^ false 
	    ].
	  ].
	].
	"items neither nil nor Object were missing from anArray"
	(varConstr == nil or:[ varConstr == Object ]) ifFalse:[ ^ false ].
	1 to: myConstrSiz do:[:j| | cx |
	  ((cx := myConstr at: j ) == nil or:[ cx == Object]) ifFalse:[ ^ false ]
	].
      ]
    ] ifFalse:[
      (self varyingConstraint isVersionOf: anArray) ifFalse:[ ^ false ].
    ].
    true
  ] onSynchronous: Error do:[:ex| false ].
%

category: '*rowan-gemstone-35x'
method: Class
_equivalentSubclass: oldClass superCls: actualSelf name: aString newOpts: optionsArray newFormat: theFormat newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars inDict: aDictionary constraints: aConstraint isKernel: isKernelBool

	 self _equivalentSubclass: oldClass superCls: actualSelf name: aString newOpts: optionsArray newFormat: theFormat newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars inDict: aDictionary isKernel: isKernelBool
%

category: '*rowan-gemstone-kernel'
method: Class
_rwDefinitionOfConstraints
"This is the part of the definition that describes constraints.  Constraints are
 deprecated and not enforced, but may still be useful for some purposes.
 Returns a string of the form
     constraints: { <Array of instance-variable-symbol/class-name pairs> }
 "

| result firstElement constraintArray |
result := String new.

result add: 'constraints: '.
( constraints isKindOf: Array ) ifTrue: [
	constraintArray := self _rwSortedConstraints.
    result addAll: '{ '.
    firstElement := true.
    constraintArray do: [ :ar |
        " if not the first constraint, prefix with a period to separate
          from the last constraint "
        firstElement ifFalse: [
          result add: ' . '; lf; add: '                '
        ]
        ifTrue: [
          firstElement := false
        ].
		(ar  isKindOf: Array ) 
			ifTrue: [
				result add: '{ #'; add: (ar at: 1) ;
					add: ' . '; add: (ar at: 2) name; addLast: $} ]
			ifFalse: [ 
				"varyingConstraint"
				result add: ar name ].
      ].
    result add: ' }'.
  ]
  ifFalse: [
    constraints class class == Metaclass3 ifTrue: [
      result add: constraints name.
    ]
    ifFalse: [
      result add: ' nil'
    ].
  ].

^result
%

category: '*rowan-gemstone-kernel'
method: Class
_rwOptionsArray
  "copy of _optionsArray"

  | result optCount | 
  result := { } .
  optCount := 0 .
  self instancesDbTransient ifTrue:[ result add: #dbTransient . optCount := optCount + 1 ].
  self instancesNonPersistent ifTrue:[ result add:  #instancesNonPersistent  . optCount := optCount + 1 ].
  self instancesInvariant ifTrue:[ result add:  #instancesInvariant  . optCount := optCount + 1 ].
  optCount > 1 ifTrue:[
    self _error: #classErrBadFormat
        with:'only one of #dbTransient #instancesNonPersistent  #instancesInvariant allowed' .
  ].
  "self _structuralUpdatesDisallowed ifTrue:[ result add: #disallowGciStore  ]." "commented out variant of _optionsArray (https://github.com/dalehenrich/Rowan/issues/292)"
  self isModifiable ifTrue:[ result add: #modifiable  ].
  self subclassesDisallowed ifTrue:[ result add: #subclassesDisallowed  ].
  "self _traversalByCallback ifTrue:[ result add: #traverseByCallback  ]." "commented out variant of _optionsArray (https://github.com/dalehenrich/Rowan/issues/292)"
  ^ result
%

category: '*rowan-gemstone-kernel'
method: Class
_rwOptionsForDefinition 
  "copy of _optionsForDefinition"

  | result arr |
  result :=  'options: #(' copy .
  arr := self _rwOptionsArray .
  1 to: arr size do:[:j | result add: $ ; add: (arr at: j) ].
  result add: $)  .
  ^ result
%

category: '*rowan-gemstone-kernel'
method: Class
_rwSortedConstraints
"as of https://github.com/dalehenrich/Rowan/issues/293, no longer sorting in alphabetical order ... instance variable order is the right answer"

|   aConstraint constraintArray |
( constraints isKindOf: Array ) ifTrue: [
	constraintArray := {}.
    1 to: self instSize do: [ :x |
      aConstraint := constraints atOrNil: x .
      ((aConstraint ~~ nil _and: [aConstraint ~~ Object])
          _and:[ superClass == nil
            _or:[ ((superClass _namedIvConstraintAt: x) isVersionOf: aConstraint) not ]] )
      ifTrue: [ constraintArray add: {(instVarNames at: x) . aConstraint } ] ].

    aConstraint:= self _varyingConstraint.
    ( (aConstraint ~~ Object) _and:
        [(superClass _varyingConstraint) ~~ aConstraint] )
		ifTrue: [ constraintArray add: aConstraint ]
  ]
  ifFalse: [
    constraints class class == Metaclass3 ifTrue: [
      ^ constraints
    ]
    ifFalse: [
      ^nil
    ].
  ].

^constraintArray
%

category: '*rowan-gemstone-35x'
method: Class
_subclass: className instVarNames: anArrayOfInstvarNames format: theFormat constraints: theConstraints classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts inDictionary: aDictionary inClassHistory: aClassHistory description: aDescription options: optionsArray
  ^ self _subclass: className instVarNames: anArrayOfInstvarNames format: theFormat classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts inDictionary: aDictionary inClassHistory: aClassHistory description: aDescription options: optionsArray
%

! Class extensions for 'CypressAddition'

!		Instance methods for 'CypressAddition'

category: '*rowan-cypress-kernel'
method: CypressAddition
isAddition
  ^ true
%

! Class extensions for 'CypressClassDefinition'

!		Instance methods for 'CypressClassDefinition'

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
accept: aVisitor
	aVisitor visitClassDefinition: self.
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
commentStamp

	^ ''
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
createOrReviseClass

	^ self subclassType = ''
		ifTrue: [ self createOrReviseRegularClass ]
		ifFalse: [ 
			self subclassType = 'byteSubclass'
				ifTrue: [ self createOrReviseByteClass ]
				ifFalse: [ 
					| typ |
					typ := self subclassType.
					(typ = 'indexableSubclass' or: [ typ = 'variable' ])
						ifTrue: [ self createOrReviseIndexableClass ]
						ifFalse: [ self error: 'unknown subclass type: ' , self subclassType printString ] ] ]
%

category: '*rowan-tools-kernel'
method: CypressClassDefinition
definitionString

	| classType type |
	type := self subclassType.
	type = ''
		ifTrue: [ classType := 'normal' ]
		ifFalse: [ 
			(type = 'indexableSubclass' or: [ type = 'variable' ])
				ifTrue: [ classType := 'variable' ]
				ifFalse: [ 
					type = 'byteSubclass'
						ifTrue: [ classType := 'bytes' ]
						ifFalse: [ self error: 'unknown subclass type: ' , type ] ] ].
	^ Rowan projectTools browser
		classCreationTemplateForSubclassOf: superclassName
		className: self name printString
		type: classType
		instanceVariablesString: self instanceVariablesString
		classVariablesString: self classVariablesString
		classInstanceVariablesString: self classInstanceVariablesString
		poolDictionariesString: self poolDictionariesString
		comment: self comment printString
		category: self category printString
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
hasClassInstanceVariables

	^ self classInstVarNames isEmpty not
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
printDefinitionOn: stream

        stream
            nextPutAll: self superclassName;
            space;
            nextPutAll: self classCreationSelector;
            nextPut: $# ;
            nextPutAll: self className;
            cr; tab.
        stream
            nextPutAll: 'instanceVariableNames: ';
            store: self instanceVariablesString;
            cr; tab;
            nextPutAll: 'classVariableNames: ';
            store: self classVariablesString;
            cr; tab;
            nextPutAll: 'poolDictionaries: ';
            store: self poolDictionariesString;
            cr; tab;
            nextPutAll: 'category: ';
            store: self category asString 
%

! Class extensions for 'CypressDefinition'

!		Instance methods for 'CypressDefinition'

category: '*rowan-tools-kernel'
method: CypressDefinition
isOrganizationDefinition
  ^false
%

! Class extensions for 'CypressHierarchicalUrl'

!		Instance methods for 'CypressHierarchicalUrl'

category: '*rowan-gemstone-3215'
method: CypressHierarchicalUrl
segments
	^ path
%

! Class extensions for 'CypressMethodDefinition'

!		Instance methods for 'CypressMethodDefinition'

category: '*rowan-cypress-kernel'
method: CypressMethodDefinition
accept: aVisitor
	^ aVisitor visitMethodDefinition: self
%

category: '*rowan-tools-kernel'
method: CypressMethodDefinition
timeStamp

	"fake out a timeStamp for GsJade package changes browser... should not end up being 
		displayed in chagnes browser, but transport layer expects a timeStamp at the moment"

	^ 'dkh 3/29/2018 14:21'
%

! Class extensions for 'CypressModification'

!		Instance methods for 'CypressModification'

category: '*rowan-cypress-kernel'
method: CypressModification
isModification
  ^ true
%

! Class extensions for 'CypressPatchOperation'

!		Instance methods for 'CypressPatchOperation'

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
<= other
	^ self definition <= other definition
%

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
isAddition
	^ false
%

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
isModification
	^ false
%

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
isRemoval
	^ false
%

! Class extensions for 'CypressRemoval'

!		Instance methods for 'CypressRemoval'

category: '*rowan-cypress-kernel'
method: CypressRemoval
isRemoval
  ^ true
%

! Class extensions for 'CypressTonelRepository'

!		Instance methods for 'CypressTonelRepository'

category: '*rowan-cypress-kernel'
method: CypressTonelRepository
packageNames

	"only directories with a package.st file in them"

	| utils |
	utils := self fileUtils.
	^ (((utils directoryEntriesFrom: self directoryPath , '*')
		reject: [ :each | 
			| aGsFileStat |
			aGsFileStat := GsFile _stat: each isLstat: false.
			aGsFileStat _isSmallInteger
				ifTrue: [ false ]
				ifFalse: [ aGsFileStat isDirectory not ] ])
		collect: [ :each | utils localNameFrom: each ])
		reject: [ :each | each = '.' or: [ each = '..' ] ]
%

! Class extensions for 'DiskStore'

!		Instance methods for 'DiskStore'

category: '*rowan-components-kernel'
method: DiskStore
rowanRepositoryDefinitionClass

	^ RwDiskRepositoryDefinition
%

! Class extensions for 'DoubleByteSymbol'

!		Instance methods for 'DoubleByteSymbol'

category: '*ast-kernel-core'
method: DoubleByteSymbol
rbStoreOn: aStream
  aStream nextPut: $#.
  super rbStoreOn: aStream
%

! Class extensions for 'ExecBlock'

!		Instance methods for 'ExecBlock'

category: '*rowan-gemstone-3215'
method: ExecBlock
cull: anArg

	"Return the value of the receiver evaluated with 0 or 1 arguments. If the block
   expects 1 argument pass anArg as the value of the argument"

	^ self argumentCount == 0
		ifTrue: [ self value ]
		ifFalse: [ self value: anArg ]
%

category: '*rowan-gemstone-3215'
method: ExecBlock
cull: firstArg cull: secondArg

	"Return the value of the receiver evaluated with between 0 and 2 arguments,
   discarding arguments not needed by the receiver."

	| nargs |
	(nargs := self argumentCount) < 2
		ifTrue: [ 
			nargs == 1
				ifTrue: [ ^ self value: firstArg ].
			^ self value ].
	^ self value: firstArg value: secondArg
%

category: '*rowan-gemstone-3215'
method: ExecBlock
cull: firstArg cull: secondArg cull: thirdArg

	"Return the value of the receiver evaluated with between 0 and 3 arguments,
   discarding arguments not needed by the receiver."

	| nargs |
	(nargs := self argumentCount) < 3
		ifTrue: [ 
			nargs == 2
				ifTrue: [ ^ self value: firstArg value: secondArg ].
			nargs == 1
				ifTrue: [ ^ self value: firstArg ].
			^ self value ].
	^ self value: firstArg value: secondArg value: thirdArg
%

category: '*rowan-gemstone-3215'
method: ExecBlock
cull: firstArg cull: secondArg cull: thirdArg cull: fourthArg

	"Return the value of the receiver evaluate with between 0 and 4 arguments,
   discarding arguments not needed by the receiver."

	| nargs |
	(nargs := self argumentCount) <= 2
		ifTrue: [ 
			nargs == 2
				ifTrue: [ ^ self value: firstArg value: secondArg ].
			nargs == 1
				ifTrue: [ ^ self value: firstArg ].
			^ self value ].
	nargs == 3
		ifTrue: [ ^ self value: firstArg value: secondArg value: thirdArg ].
	^ self
		value: firstArg
		value: secondArg
		value: thirdArg
		value: fourthArg
%

! Class extensions for 'FileLocator'

!		Class methods for 'FileLocator'

category: '*rowan-components-kernel'
classmethod: FileLocator
rowanProjectsHome
	"Answer the path to $ROWAN_PROJECTS_HOME"

	^ self origin: #rowanProjectsHome
%

! Class extensions for 'FileSystem'

!		Instance methods for 'FileSystem'

category: '*rowan-components-kernel'
method: FileSystem
rowanRepositoryDefinitionClass

	^ store rowanRepositoryDefinitionClass
%

! Class extensions for 'FileSystemStore'

!		Instance methods for 'FileSystemStore'

category: '*rowan-components-kernel'
method: FileSystemStore
rowanRepositoryDefinitionClass

	self subclassResponsibility: #rowanRepositoryDefinitionClass
%

! Class extensions for 'GsFile'

!		Class methods for 'GsFile'

category: '*rowan-gemstone-3215'
classmethod: GsFile
_stat: aName  isLstat: aBoolean 

"uses the server file system access. 
 Returns a SmallInteger errno value if an error occurs or 
 or if aName is not a valid file or directory. Otherwise
 returns a new instance of GsFileStat. "
<primitive: 757>
aName _validateClass: String .
aBoolean _validateClass: Boolean .
self _primitiveFailed: #stat:isLstat: args: { aName . aBoolean }
%

! Class extensions for 'GsNMethod'

!		Instance methods for 'GsNMethod'

category: '*rowan-gemstone-kernel'
method: GsNMethod
rowanPackageName

	"answer the name of the package that the receiver is a member of. Answer `Rowan unpackagedName` if 
		the receiver is not a member of any package"

	| loadedMethod |
	loadedMethod := Rowan image
		loadedMethodForMethod: self
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedMethod loadedPackage name
%

category: '*rowan-gemstone-kernel'
method: GsNMethod
rowanProjectName

	"answer the name of the project that the receiver is a member of. Answer `Rowan unpackagedName` if 
		the receiver is not a member of any project"

	| loadedMethod |
	loadedMethod := Rowan image
		loadedMethodForMethod: self
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedMethod loadedProject name
%

! Class extensions for 'GsPackagePolicy'

!		Class methods for 'GsPackagePolicy'

category: '*rowan-gemstone-3215'
classmethod: GsPackagePolicy
currentOrNil

	"Returns nil or the previously installed and enabled GsPackagePolicy."

	| pp |
	pp := ((GsSession currentSession objectNamed: #'UserGlobals') ifNil: [ ^ nil ])
		at: self globalName
		otherwise: nil.
	pp
		ifNotNil: [ 
			pp enabled
				ifTrue: [ ^ pp ] ].
	^ nil
%

! Class extensions for 'Integer'

!		Class methods for 'Integer'

category: '*ast-kernel-core'
classmethod: Integer
_rwFinishFromStream: aStream signFound: aSignFound factor: aFactor radix: radix
  "BinaryExponent = ( 'e' | 'E' | 'd' | 'D' | 'q' ) ['-' | '+'] Digits
   DecimalExponent = ( 'f' | 'F' ) ['-' | '+'] Digits
   Digit = '0' | '1' | '2' | ... | '9'
   Digits = Digit {Digit}
   Exponent = BinaryExponent | DecimalExponent | ScaledDecimalExponent | FixedPointExponent
   FractionalPart = '.' Digits [Exponent]
   FixedPointExponent = 'p' [ ['-' | '+'] Digits ] 
   Number = RadixedLiteral | NumericLiteral
   Numeric = Digit | 'A' | 'B' | ... | 'Z'
   NumericLiteral = Digits ( [FractionalPart] | [Exponent] )
   Numerics = Numeric { Numeric }
   RadixedLiteral = Digits ( '#' | 'r' ) ['-'] Numerics
   ScaledDecimalExponent = 's' [ ['-' | '+'] Digits ]
"
  "parse Numerics (plus option sign) for RadixedLiteral"

  | number ch signFound factor |
  signFound := aSignFound.
  factor := aFactor.
  number := 0.
  (aStream peek isEquivalent: $-)
    ifTrue: [ 
      signFound
        ifTrue: [ ^ self _errIncorrectFormat: aStream ].
      aStream next.
      signFound := true.
      factor := -1 ]
    ifFalse: [ 
      (aStream peek isEquivalent: $+)
        ifTrue: [ 
          signFound
            ifTrue: [ ^ self _errIncorrectFormat: aStream ].
          aStream next.
          signFound := true ] ].
  [ aStream atEnd not and: [ | peekCh | peekCh := aStream peek. radix <= 10 ifTrue: [ peekCh isDigit ] ifFalse: [ peekCh isAlphaNumeric ] ] ]
    whileTrue: [ 
      ch := aStream next.
      number := number * radix + (ch digitValueInRadix: radix) ].
  ^ number * factor
%

!		Instance methods for 'Integer'

category: '*rowan-gemstone-kernel'
method: Integer
rwSemanticIntegerLessThanSelf: anInteger

	^ anInteger < self
%

category: '*rowan-gemstone-kernel'
method: Integer
rwSemanticStringLessThanSelf:  aString
  "integers have greater precedence than strings"
	" aString < anInteger -> false"

  ^ false
%

category: '*rowan-gemstone-kernel'
method: Integer
rwSemanticVersionComponentLessThan: aRwSemanticVersonComponent

	^ aRwSemanticVersonComponent rwSemanticIntegerLessThanSelf: self
%

! Class extensions for 'MemoryStore'

!		Instance methods for 'MemoryStore'

category: '*rowan-components-kernel'
method: MemoryStore
rowanRepositoryDefinitionClass

	^ RwMemoryRepositoryDefinition
%

! Class extensions for 'Number'

!		Class methods for 'Number'

category: '*ast-kernel-core'
classmethod: Number
rwFromStream: aStream
  "BinaryExponent = ( 'e' | 'E' | 'd' | 'D'  'q' | 'Q') ['-' | '+'] Digits
   DecimalExponent = ( 'f' | 'F' ) ['-' | '+'] Digits
   Digit = '0' | '1' | '2' | ... | '9'
   Digits = Digit {Digit}
   Exponent = BinaryExponent | DecimalExponent | ScaledDecimalExponent | FixedPointExponent
   FractionalPart = '.' Digits [Exponent]
   FixedPointExponent = 'p' [ ['-' | '+'] Digits ] 
   Number = RadixedLiteral | NumericLiteral
   Numeric = Digit | 'A' | 'B' | ... | 'Z'
   NumericLiteral = Digits ( [FractionalPart] | [Exponent] )
   Numerics = Numeric { Numeric }
   RadixedLiteral = Digits ( '#' | 'r' ) ['-'] Numerics
   ScaledDecimalExponent = 's' [ ['-' | '+'] Digits ]
"
  | ch integerPart factor signFound |
  self _checkReadStream: aStream forClass: CharacterCollection.
  ch := aStream next.
  [ ch unicodeIsWhitespace] whileTrue: [ ch := aStream next ].
  aStream skip: -1.
  integerPart := 0.
  factor := 1.
  signFound := false.
  (aStream peek isEquivalent: $-)
    ifTrue: [ 
      aStream next.
      signFound := true.
      factor := -1 ]
    ifFalse: [ 
      (aStream peek isEquivalent: $+)
        ifTrue: [ 
          aStream next.
          signFound := true ] ].
  (aStream atEnd or: [ aStream peek isDigit not ])
    ifTrue: [ ^ self _errIncorrectFormat: aStream ].
  [ aStream atEnd not and: [ (ch := aStream peek) isDigit ] ]
    whileTrue: [ 
      aStream next.
      integerPart := integerPart * 10 + ch digitValue ].

  (ch == $r or: [ ch == $# ])
    ifTrue: [ 
      "found a radix separator"
      aStream next.
      ^ Integer
        _rwFinishFromStream: aStream
        signFound: signFound
        factor: factor
        radix: integerPart ].
  (ch isEquivalent: (Locale decimalPoint at: 1))
    ifTrue: [ 
      | chch |
		chch := aStream peek2. ".?"
		chch notNil
			ifTrue: [
				"not at eof"
				chch isDigit 
					ifFalse: [
						"we're done"
						^ integerPart * factor ] ].
	  "found a decimal point, followed by a numeric character."
      aStream next.
      ^ BinaryFloat
        _finishFromStream: aStream
        signFound: signFound
        factor: factor
        integerPart: integerPart ].
  (#( $e $E $d $D $q $s $p $f $F ) includesIdentical: ch) ifTrue:[ 
      aStream next.
      ^ BinaryFloat
        _finishFromStream: aStream
        signFound: signFound
        factor: factor
        integerPart: integerPart
        fractionalPart: 0
        exponent: ch ].
  ^ integerPart * factor
%

!		Instance methods for 'Number'

category: '*ast-kernel-core'
method: Number
rbStoreOn: aStream
  self printOn: aStream
%

! Class extensions for 'Object'

!		Instance methods for 'Object'

category: '*gemstone-interactions-kernel'
method: Object
confirm: aString
  ^ (GsConfirmInteraction prompt: aString) signal
%

category: '*gemstone-interactions-kernel'
method: Object
inform: aString
  "Display aString to the user."

  ^ (GsInformInteraction message: aString) signal
%

category: '*gemstone-interactions-kernel'
method: Object
inspect
  ^ (GsInspectInteraction theObject: self) signal
%

category: '*rowan-gemstone-kernel'
method: Object
rwPlatformAttributeMatchForGemStoneVersion: anRwGemStoneVersionConfigurationPlatformAttributeMatcher
  ^ self
    error: 'Expected a String or a RwGemStoneVersion'
%

category: '*rowan-gemstone-kernel'
method: Object
rwPlatformAttributeMatchForString: anRwStringConfigurationPlatformAttributeMatcher
  ^ self
    error: 'Expected a String or a RwGemStoneVersion'
%

category: '*rowan-gemstone-kernel'
method: Object
rwSemanticIntegerLessThanSelf: anInteger
  ^ self
    error: 'Invalid semantic verson component - should be an Integer.'
%

category: '*rowan-gemstone-kernel'
method: Object
rwSemanticStringLessThanSelf: aString
  ^ self
    error: 'Invalid semantic verson component - should be String.'
%

category: '*rowan-gemstone-kernel'
method: Object
rwSemanticVersionComponentLessThan: aRwSemanticVersonComponent
  ^ self
    error: 'Invalid semantic verson component - should be String or Integer.'
%

category: '*ast-kernel-core'
method: Object
value

	^self
%

! Class extensions for 'QuadByteSymbol'

!		Instance methods for 'QuadByteSymbol'

category: '*ast-kernel-core'
method: QuadByteSymbol
rbStoreOn: aStream
  aStream nextPut: $#.
  super rbStoreOn: aStream
%

! Class extensions for 'Rowan'

!		Class methods for 'Rowan'

category: '*rowan-gemstone-core'
classmethod: Rowan
clearGlobalAutomaticClassInitializationBlackList

	"Clear global list of project names for which automatic class initialiation should be disabled.
		user black list only applies to current user."

	^ self platform clearAutomaticClassInitializationBlackList_global
%

category: '*rowan-gemstone-core'
classmethod: Rowan
clearSessionAutomaticClassInitializationBlackList

	"Clear session list of project names for which automatic class initialiation should be disabled.
		Session black list only active for duration of GemStone session."

	^ self platform clearAutomaticClassInitializationBlackList_session
%

category: '*rowan-gemstone-core'
classmethod: Rowan
clearUserAutomaticClassInitializationBlackList

	"Clear user list of project names for which automatic class initialiation should be disabled.
		user black list only applies to current user."

	^ self platform clearAutomaticClassInitializationBlackList_user
%

category: '*rowan-gemstone-core'
classmethod: Rowan
globalAutomaticClassInitializationBlackList

	"Answer global list of project names for which automatic class initialiation should be disabled.
		Session black list only active for duration of GemStone session."

	^ self platform automaticClassInitializationBlackList_global
%

category: '*rowan-core'
classmethod: Rowan
initialize

	"Rowan initialize."

	configuration := self platform defaultConfiguration.
	self platform initialize
%

category: '*rowan-gemstone-core'
classmethod: Rowan
sessionAutomaticClassInitializationBlackList

	"Answer session list of project names for which automatic class initialiation should be disabled.
		Session black list only active for duration of GemStone session."

	^ self platform automaticClassInitializationBlackList_session
%

category: '*rowan-gemstone-core'
classmethod: Rowan
userAutomaticClassInitializationBlackList

	"Answer user list of project names for which automatic class initialiation should be disabled.
		user black list only applies to current user."

	^ self platform automaticClassInitializationBlackList_user
%

! Class extensions for 'RowanInterface'

!		Instance methods for 'RowanInterface'

category: '*rowan-gemstone-core'
method: RowanInterface
_gemstonePlatformSpec

	^ self _specification platformSpec at: 'gemstone'
%

! Class extensions for 'RwAbstractClassDefinition'

!		Instance methods for 'RwAbstractClassDefinition'

category: '*rowan-gemstone-definitions'
method: RwAbstractClassDefinition
modificationForcingNewVersion

	^ self _modificationForcingNewClassVersion before: self after: self
%

category: '*rowan-cypress-definitions'
method: RwAbstractClassDefinition
name
  ^ self key
%

! Class extensions for 'RwAbstractTool'

!		Instance methods for 'RwAbstractTool'

category: '*rowan-tools-gemstone'
method: RwAbstractTool
_log: aString

"
If the client is a topaz process, the default logger writes to the 
 current output file as controlled by topaz OUTPUT PUSH statements, 
 else to stdout.
"
	GsFile gciLogClient: aString
%

! Class extensions for 'RwClassDefinition'

!		Class methods for 'RwClassDefinition'

category: '*rowan-cypress-definitions'
classmethod: RwClassDefinition
fromCypressClassStructure: aCypressClassStructure
  ^ self new
    fromCypressClassStructure: aCypressClassStructure;
    yourself
%

!		Instance methods for 'RwClassDefinition'

category: '*rowan-cypress-definitions'
method: RwClassDefinition
category

	^ properties at: 'category' ifAbsent: [  ]
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
category: aString

	^ properties at: 'category' put: aString
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
classInstVarNames
  ^ properties at: 'classinstvars'
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
classInstVarNames: anArray

	^ properties at: 'classinstvars' put: anArray
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
comment
  ^ properties at: 'comment' ifAbsent: ['']
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
compareAgainstBaseForcingNewClassVersion: aDefinition

	"all unchanged and unremoved methods need to be applied to the patch"

	| modification instanceMethodsModification classMethodsModification |
	modification := self _modificationForcingNewClassVersion
		before: aDefinition
		after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	instanceMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	classMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	self
		compareDictionary: instanceMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition instanceMethodDefinitions
		into: instanceMethodsModification
		elementClass: RwMethodDefinition
		isMeta: false.
	self
		compareDictionary: classMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition classMethodDefinitions
		into: classMethodsModification
		elementClass: RwMethodDefinition
		isMeta: true.
	modification
		instanceMethodsModification: instanceMethodsModification;
		classMethodsModification: classMethodsModification.
	^ modification
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
fromCypressClassStructure: aCypressClassStructure

	properties
		at: 'category' put: aCypressClassStructure category;
		at: 'classinstvars' put: aCypressClassStructure classInstanceVariableNames;
		at: 'classvars' put: aCypressClassStructure classVariableNames;
		yourself.
	aCypressClassStructure comment ifNotNil: [ :cmt | properties at: 'comment' put: cmt ].
	aCypressClassStructure gs_options isEmpty ifFalse: [ properties at: 'gs_options' put: aCypressClassStructure gs_options ].
	aCypressClassStructure gs_constraints isEmpty ifFalse: [ properties at: 'gs_constraints' put: aCypressClassStructure gs_constraints ].
	properties
		at: 'instvars' put: aCypressClassStructure instanceVariableNames;
		at: 'name' put: aCypressClassStructure className;
		at: 'pools' put: aCypressClassStructure poolDictionaryNames;
		at: 'superclass' put: aCypressClassStructure superclassName;
		yourself.
	aCypressClassStructure subclassType isEmpty
		ifTrue: [ properties at: 'type' put: 'normal' ]
		ifFalse: [ properties at: 'type' put: aCypressClassStructure subclassType asString ].
	aCypressClassStructure instanceMethods
		do: [ :cypMethodDef | 
			self
				addInstanceMethodDefinition:
					(RwMethodDefinition fromCypressMethod: cypMethodDef) ].
	aCypressClassStructure classMethods
		do: [ :cypMethodDef | 
			self
				addClassMethodDefinition:
					(RwMethodDefinition fromCypressMethod: cypMethodDef) ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_constraints

	^self properties
				at: 'gs_constraints'
				ifAbsent: [ #() ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_constraints: constraintsArray

	(constraintsArray _isArray and: [ constraintsArray isEmpty not ])
		ifTrue: [ 
			self properties
				at: 'gs_constraints'
				put: constraintsArray ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_options

	^self properties
				at: 'gs_options'
				ifAbsent: [ #() ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_options: optionsArray

	(optionsArray _isArray and: [ optionsArray isEmpty not ])
		ifTrue: [ 
			self properties
				at: 'gs_options'
				put:
					(optionsArray collect: [ :each | each asString ]) asSortedCollection asArray ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_symbolDictionary

	^ self properties
		at: 'gs_SymbolDictionary'
		ifAbsent: []
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_symbolDictionary: aSymbolDictionaryName

	self properties
		at: 'gs_SymbolDictionary'
		put: aSymbolDictionaryName asString
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
poolDictionaryNames
  ^ properties at: 'pools'
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
subclassType
  | type |
  type := properties at: 'type'.
  type = 'normal'
    ifTrue: [ ^ '' ].
  ^ type
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue
 
	propertyKey = 'comment' ifFalse: [ ^super _compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue ].
	propertyValue = baseValue
		ifTrue: [ ^ true ]
		ifFalse: [ 
			"empty or nil comments need to compare equal in GemStone"
			^(propertyValue == nil or: [ propertyValue isEmpty]) and: [ baseValue == nil or: [ baseValue isEmpty] ] ]
%

category: '*rowan-core-definitions-extensions'
method: RwClassDefinition
_methodsModificationClass

	^ RwMethodsModification
%

category: '*rowan-core-definitions-extensions'
method: RwClassDefinition
_modificationClass

	^ RwClassModification
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
_modificationForcingNewClassVersion

	^ RwClassModificationForcingNewClassVersion
%

! Class extensions for 'RwClassExtensionDefinition'

!		Instance methods for 'RwClassExtensionDefinition'

category: '*rowan-core-definitions-extensions'
method: RwClassExtensionDefinition
comparePropertiesAgainstBase: aDefinition
	"property differences aren't of interest for a class extension ..."

	^ RwPropertiesModification new
%

category: '*rowan-core-definitions-extensions'
method: RwClassExtensionDefinition
_methodsModificationClass

	^ RwExtensionMethodsModification
%

category: '*rowan-core-definitions-extensions'
method: RwClassExtensionDefinition
_modificationClass

	^ RwClassExtensionModification
%

! Class extensions for 'RwClassModification'

!		Instance methods for 'RwClassModification'

category: '*rowan-gemstone-loader-extensions'
method: RwClassModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	aPatchSet
		addClassModification: self 
		toPatchSetInPackage: aPackage 
		inProject: aProjectDefinition.
%

! Class extensions for 'RwClassModificationForcingNewClassVersion'

!		Instance methods for 'RwClassModificationForcingNewClassVersion'

category: '*rowan-gemstone-loader-extensions'
method: RwClassModificationForcingNewClassVersion
addModificationForcingNewClassVersionToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	aPatchSet
		addForcingNewClassVersionModification: self 
		toPatchSetInPackage: aPackage 
		inProject: aProjectDefinition
%

category: '*rowan-gemstone-loader-extensions'
method: RwClassModificationForcingNewClassVersion
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self shouldNotImplement: #addModificationToPatchSet:inPackage:inProject:
%

! Class extensions for 'RwClassMove'

!		Instance methods for 'RwClassMove'

category: '*rowan-gemstone-loader-extensions'
method: RwClassMove
addMovedClassToPatchSet: aPatchSet

	aPatchSet addClassMove: self
%

! Class extensions for 'RwComponentProjectDefinition'

!		Instance methods for 'RwComponentProjectDefinition'

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
asLoadedSymbolDictProject

	^ RwGsLoadedSymbolDictComponentProject newForProjectReferenceDefinition: self projectRef.
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
defaultSymbolDictName

	^ self projectRef defaultSymbolDictName
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
defaultSymbolDictName: symDictName

	self projectRef defaultSymbolDictName: symDictName
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
defaultUseSessionMethodsForExtensions

	^ self projectRef defaultUseSessionMethodsForExtensions
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
defaultUseSessionMethodsForExtensions: aBool

	self projectRef defaultUseSessionMethodsForExtensions: aBool
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
methodEnvForPackageNamed: packageName

	^self projectRef methodEnvForPackageNamed: packageName
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
packageNameToPlatformPropertiesMap

	^self projectRef packageNameToPlatformPropertiesMap
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
packageNameToPlatformPropertiesMap: aDictionary

	^self projectRef packageNameToPlatformPropertiesMap: aDictionary
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
register

	Rowan image 
		loadedProjectNamed: self name
		ifAbsent: [
			| newLoadedProject |
			newLoadedProject := RwGsLoadedSymbolDictComponentProject newForProjectReferenceDefinition: self projectRef.
			Rowan image addLoadedProject: newLoadedProject ]
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
setSymbolDictName: symbolDictName forPackageNamed: packageName

	^self projectRef setSymbolDictName: symbolDictName forPackageNamed: packageName
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
symbolDictNameForPackageNamed: packageName

	^self projectRef symbolDictNameForPackageNamed: packageName
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
updateGsPlatformSpecLoadedProjectInfo: projectInfo

	| thePackageMapSpecs |
	thePackageMapSpecs := projectInfo at:  'packageMapSpecs' .
	(thePackageMapSpecs at: #defaultSymbolDictName otherwise: nil) 
		ifNotNil: [:name | self defaultSymbolDictName: name ].
	(thePackageMapSpecs at: #defaultUseSessionMethodsForExtensions otherwise: nil) 
		ifNotNil: [:boolean | 
			self defaultUseSessionMethodsForExtensions: boolean  ].
	(thePackageMapSpecs at: #packageNameToPlatformPropertiesMap otherwise: nil) 
		ifNotNil: [:map | self packageNameToPlatformPropertiesMap: map]
%

category: '*rowan-gemstone-components-extensions'
method: RwComponentProjectDefinition
useSessionMethodsForExtensionsForPackageNamed: packageName

	^ self projectRef useSessionMethodsForExtensionsForPackageNamed: packageName
%

! Class extensions for 'RwComponentSpecification'

!		Instance methods for 'RwComponentSpecification'

category: '*rowan-gemstone-components-extensions'
method: RwComponentSpecification
register

	Rowan image 
		loadedProjectNamed: self specName
		ifAbsent: [
			| newLoadedProject |
			newLoadedProject := RwGsLoadedSymbolDictComponentProject newForLoadSpecification: self.
			Rowan image addLoadedProject: newLoadedProject ]
%

! Class extensions for 'RwDefinition'

!		Instance methods for 'RwDefinition'

category: '*rowan-core-definitions-extensions'
method: RwDefinition
comparePropertiesAgainstBase: aDefinition

	| keys modification |
	modification := RwPropertiesModification new.
	keys := properties keys copy.
	keys addAll: aDefinition properties keys.
	keys do: 
			[:key |
				| before after |
				before := aDefinition propertyAt: key ifAbsent: [nil].
				after := self propertyAt: key ifAbsent: [nil].
				(self _compareProperty: key propertyVaue: before againstBaseValue: after)
					ifFalse: 
						[modification addElementModification: (RwPropertyModification
							key: key
							oldValue: before
							newValue: after)]].
	^modification
%

! Class extensions for 'RwFileUrl'

!		Instance methods for 'RwFileUrl'

category: '*rowan-url-extensions'
method: RwFileUrl
asConfiguration
  "Answer a concrete RwAbstractProjectConfiguration "

  ^ RwAbstractProjectConfiguration fromUrl: self
%

category: '*rowan-url-extensions'
method: RwFileUrl
asSpecification
  "Answer an RwSpecification "

  ^ RwSpecification fromUrl: self
%

! Class extensions for 'RwGitTool'

!		Instance methods for 'RwGitTool'

category: '*rowan-tools-gemstone'
method: RwGitTool
createTmpFileWith: fileContents

	| file filename |
	filename := (self performOnServer: '/bin/mktemp --tmpdir commitMessage.XXXX' logging: true) trimRight.
	[ 
	| count |
	file := GsFile openWriteOnServer: filename.
	(count := file nextPutAll: fileContents withGemstoneLineEndings)
		ifNil: [ self error: 'failed write' ] ]
		ensure: [ file close ].
	^ filename
%

category: '*rowan-tools-gemstone'
method: RwGitTool
performOnServer: commandLine status: statusBlock
  | performOnServerStatusArray |
  performOnServerStatusArray := System _performOnServer: commandLine.
  ^ statusBlock value: performOnServerStatusArray
%

! Class extensions for 'RwGsImage'

!		Class methods for 'RwGsImage'

category: '*rowan-gemstone-components'
classmethod: RwGsImage
addProjectRepository: newProjectRepository

	"Register a repository"

	| repositoryName projectRepositoryRegistry |
	repositoryName := newProjectRepository name.
	projectRepositoryRegistry := self
		_projectRepositoryRegistry.
	projectRepositoryRegistry
		at: repositoryName
		ifAbsent: [ ^ projectRepositoryRegistry at: repositoryName put: newProjectRepository ].
	self
		error:
			'There is already a project repository named ' , repositoryName printString , ' registered'
%

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsImage
applyModification_254: aProjectSetModification instanceMigrator: instanceMigrator
	(self _shouldCloneRowanLoader: aProjectSetModification)
		ifTrue: [ 
			| visitorClass |
			visitorClass := self _cloneRowanLoaderSymbolDictionary at: #RwGsImagePatchVisitor_254.
			self 
				applyModification_254: aProjectSetModification 
				visitorClass:visitorClass 
				instanceMigrator: instanceMigrator ]
		ifFalse: [ 
			self 
				applyModification_254: aProjectSetModification 
				visitorClass: RwGsImagePatchVisitor_254 
				instanceMigrator: instanceMigrator ]
%

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsImage
applyModification_254: aProjectSetModification visitorClass: visitorClass instanceMigrator: instanceMigrator

	| visitor patchSet newClassVersionPatchSet |
	visitor := visitorClass new.
	visitor visit: aProjectSetModification.
	patchSet := visitor patchSet.
	patchSet classesWithNewVersions isEmpty
		ifTrue: [ 
			patchSet apply.
			^ self ].
	patchSet setupForNewClassVersionUpdates.
	patchSet classesWithNewVersions
		do: [ :each | 
			each
				updatePatchesForNewClassVersion: aProjectSetModification 
					patchSet: patchSet;
				updateNewClassVersionPatchesForExtensionsIn: aProjectSetModification
					patchSet: patchSet;
				updateNewClassVersionPatchesForSubclassesIn: aProjectSetModification
					patchSet: patchSet ].
	visitor := visitorClass new.
	visitor visit: aProjectSetModification.
	newClassVersionPatchSet := visitor patchSet.
	newClassVersionPatchSet applyForNewClassVersions: instanceMigrator
%

category: '*rowan-gemstone-components'
classmethod: RwGsImage
projectRepositoryNamed: aString

	^ self
		projectRepositoryNamed: aString
		ifAbsent: [ self error: 'No project repository named ' , aString printString , ' found' ]
%

category: '*rowan-gemstone-components'
classmethod: RwGsImage
projectRepositoryNamed: aString ifAbsent: absentBlock

	"Look up a project repository."

	^ self _projectRepositoryRegistry
		at: aString
		ifAbsent: absentBlock
%

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsImage
_cloneRowanLoaderSymbolDictionary

	"in order to cleanly update Rowan using Rowan, it is necessary to isolate a copy of all of the loader code
		in a separate symbol dictionary and then use the isolated copy to execute the update."

	| rowanLoaderSymbolDict clonedSymDictName clonedSymDict |
	rowanLoaderSymbolDict := Rowan globalNamed: 'RowanLoader'.
	clonedSymDictName := #'RowanLoader_cloned'.
	clonedSymDict := rowanLoaderSymbolDict 
		_rowanCloneSymbolDictionaryNamed: clonedSymDictName 
		symbolList: GsCurrentSession currentSession symbolList.
	Transcript cr; show: 'RowanLoader symbol dictionary cloned'.
	^ clonedSymDict
%

category: '*rowan-gemstone-components'
classmethod: RwGsImage
_projectRepositoryRegistry

	^ self _projectRepositoryRegistryForUserId: self currentUserId
%

category: '*rowan-gemstone-components'
classmethod: RwGsImage
_projectRepositoryRegistryForUserId: aUserId

	| userProfile userPlatformDict |
	userProfile := AllUsers userWithId: aUserId.
	(userProfile defaultObjectSecurityPolicy ifNil: [true] ifNotNil: [:x |x currentUserCanRead])
		ifFalse: [
			"do not have permissions to read objects created by <aUserId>"
			^ nil ].
	userPlatformDict := RwPlatform _userPlatformDictionaryForUser: aUserId.
	^ userPlatformDict
		at: #'RwGsProjectRepositoryRegistry'
		ifAbsent: [ 
			(self currentUserId = aUserId)
				ifFalse: [ ^ nil ].
			userPlatformDict at: #'RwGsProjectRepositoryRegistry' put: StringKeyValueDictionary new ]
%

category: '*rowan-gemstone-components'
classmethod: RwGsImage
_removeProjectRepository:  aRwProjectRepository

	"note that it is not safe to just remove a project repository from the registry, however this method is supplied as a convenience for tests"

	| repositoryName repositoryRegistry |
	repositoryName := aRwProjectRepository name.
	repositoryRegistry := self _projectRepositoryRegistry.
	(repositoryRegistry at: repositoryName ifAbsent: [ ^ nil ]) == aRwProjectRepository
		ifFalse: [ 
			self
				error:
					'The specified project repository is not identical to the project repository in the registry ... this is not expected' ].
	repositoryRegistry removeKey: repositoryName
%

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsImage
_shouldCloneRowanLoader: aProjectSetModification

	"When modifications are made to the Rowan-GemStone-Loader package in the Rowan project, we need to clone the RowanLoader symbol dictionary"

	| projectModification packageModification |
	projectModification := aProjectSetModification elementsModified at: 'Rowan' ifAbsent: [ ^ false ].
	packageModification := projectModification packagesModification elementsModified at: 'Rowan-GemStone-Loader' ifAbsent: [ ^ false ].
	^ packageModification isEmpty not
%

! Class extensions for 'RwGsPlatform'

!		Instance methods for 'RwGsPlatform'

category: '*rowan-services-extensions'
method: RwGsPlatform
classServiceClass

	^ RowanClassService
%

category: '*rowan-tools-extensions-gemstone'
method: RwGsPlatform
classTools

	"Answer the platform-specific class for class tools"

	^ RwClassTool
%

category: '*rowan-tools-extensions-gemstone'
method: RwGsPlatform
gitTools

	"Answer the platform-specific class for git tools"

	^ RwGitTool new
%

category: '*rowan-services-extensions'
method: RwGsPlatform
jadeServerClassNamed: className

	| jadeClasses |
	jadeClasses := Array with: (UserGlobals at: #JadeServer). 
	jadeClasses add: (UserGlobals at: #JadeServer64bit32). 
	^jadeClasses detect:[:cls | cls name == className] ifNone:[self error: 'Could not look up a JadeServer class: ', className]
%

category: '*rowan-services-extensions'
method: RwGsPlatform
methodServiceClass

	^ RowanMethodService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
packageServiceClass

	^ RowanPackageService
%

category: '*rowan-tools-extensions-gemstone'
method: RwGsPlatform
packageTools
	"Answer the platform-specific class for package tools"

	^RwPackageTool
%

category: '*rowan-services-extensions'
method: RwGsPlatform
projectServiceClass

	^ RowanProjectService
%

category: '*rowan-tools-extensions-gemstone'
method: RwGsPlatform
projectTools
	"Answer the platform-specific class for project tools"

	^RwProjectTool
%

category: '*rowan-services-extensions'
method: RwGsPlatform
serviceClass

	^ RowanService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
serviceClasses
	"Explicitly add each class rather than sending #allSubclasses so
	that users other than SystemUser have visibility. Visibility in Rowan
	is determined at compile time."
	
	| array |
	array := Array with: RowanService. 
	array add: RowanAnsweringService; 
		add: RowanBrowserService;
		add: RowanClassService; 
		add: RowanDebuggerService; 
		add: RowanFrameService;
		add: RowanMethodService;
		add: RowanPackageService; 
		add: RowanProcessService;
		add: RowanProjectService;
		add: RowanQueryService;
		add: RowanVariableService.
	^array
%

category: '*rowan-services-extensions'
method: RwGsPlatform
serviceClassFor: className

	^self serviceClasses detect:[:cls | cls name asString = className asString] ifNone:[]
%

! Class extensions for 'RwGsSymbolDictionaryRegistry'

!		Class methods for 'RwGsSymbolDictionaryRegistry'

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsSymbolDictionaryRegistry
registry_ImplementationClass

	^ RwGsSymbolDictionaryRegistry_Implementation
%

! Class extensions for 'RwMethodDefinition'

!		Class methods for 'RwMethodDefinition'

category: '*rowan-cypress-definitions'
classmethod: RwMethodDefinition
fromCypressMethod: cypMethodDef
  ^ self new
    fromCypressMethod: cypMethodDef;
    yourself
%

!		Instance methods for 'RwMethodDefinition'

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareAgainstBase: aDefinition 

	| modification |
	modification := RwMethodModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification: (self compareSourceAgainstBase: aDefinition).
	^modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareAgainstBaseForNewClassVersion: aDefinition

	| modification |
	modification := RwMethodModificationForNewClassVersion
		before: aDefinition
		after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification:
				(self compareSourceAgainstBaseForNewClassVersion: aDefinition).
	^ modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareExtensionMethodsAgainstBase: aDefinition

	| modification |
	modification := RwExtensionMethodModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification: (self compareSourceAgainstBase: aDefinition).
	^ modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareSourceAgainstBase: aDefinition

	| modification |
	modification := RwSourceModification new.
	aDefinition source ~= self source
		ifTrue: [
			| before after |
			before := aDefinition source.
			after := self source.
			modification addElementModification: (RwPropertyModification
								key: 'source'
								oldValue: before
								newValue: after) ].
	^modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareSourceAgainstBaseForNewClassVersion: aDefinition

	"unconditional modification for new class versions"

	| modification before after |
	modification := RwSourceModification new.
	before := aDefinition source.
	after := self source.
	modification
		addElementModification:
			(RwUnconditionalPropertyModification
				key: 'source'
				oldValue: before
				newValue: after).
	^ modification
%

category: '*rowan-cypress-definitions'
method: RwMethodDefinition
fromCypressMethod: cypMethodDef
  properties
    at: 'selector' put: cypMethodDef selector asSymbol;
    at: 'protocol' put: cypMethodDef category;
    yourself.
  self source: cypMethodDef source
%

! Class extensions for 'RwMethodMove'

!		Instance methods for 'RwMethodMove'

category: '*rowan-gemstone-loader-extensions'
method: RwMethodMove
addMovedMethodToPatchSet: aPatchSet

	aPatchSet addMethodMove: self
%

! Class extensions for 'RwPackage'

!		Instance methods for 'RwPackage'

category: '*rowan-gemstone-core'
method: RwPackage
methodEnv

	^ self _gemstonePlatformSpec methodEnvForPackageNamed: self name
%

category: '*rowan-gemstone-core'
method: RwPackage
symbolDictName

	^ self _gemstonePlatformSpec symbolDictNameForPackageNamed: self name
%

category: '*rowan-gemstone-core'
method: RwPackage
useSessionMethodsForExtensions

	^ self _gemstonePlatformSpec
		useSessionMethodsForExtensionsForPackageNamed: self name
%

! Class extensions for 'RwPackageDefinition'

!		Instance methods for 'RwPackageDefinition'

category: '*rowan-core-definitions-extensions'
method: RwPackageDefinition
compareAgainstBase: aDefinition

	| modification classesModification classExtensionsModification |
	modification := RwPackageModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	classesModification := RwClassesModification new.
	classExtensionsModification := RwClassExtensionsModification new.
	self
		compareDictionary: classDefinitions
		againstBaseDictionary: aDefinition classDefinitions
		into: classesModification
		elementClass: RwClassDefinition.
	self
		compareDictionary: classExtensions
		againstBaseDictionary: aDefinition classExtensions
		into: classExtensionsModification
		elementClass: RwClassExtensionDefinition.
	modification
		classesModification: classesModification;
		classExtensionsModification: classExtensionsModification.
	^modification
%

category: '*rowan-gemstone-definitions'
method: RwPackageDefinition
gs_symbolDictionary

	^ self properties
		at: 'gs_SymbolDictionary'
		ifAbsent: []
%

category: '*rowan-gemstone-definitions'
method: RwPackageDefinition
gs_symbolDictionary: aSymbolDictionaryName

	self properties
		at: 'gs_SymbolDictionary'
		put: aSymbolDictionaryName asString
%

category: '*rowan-cypress-definitions'
method: RwPackageDefinition
name
  ^ self key
%

! Class extensions for 'RwPackageSetDefinition'

!		Instance methods for 'RwPackageSetDefinition'

category: '*rowan-core-definitions-extensions'
method: RwPackageSetDefinition
compareAgainstBase: aDefinition

	| result |
	result := RwPackageSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary: aDefinition definitions
		into: result
		elementClass: RwPackageDefinition.
	^ result
%

! Class extensions for 'RwPlatform'

!		Class methods for 'RwPlatform'

category: '*rowan-gemstone-core'
classmethod: RwPlatform
current

	^ self _userPlatformDictionary 
		at: #RwUserPlatformInstance 
		ifAbsentPut: [ RwGsPlatform new ]
%

category: '*rowan-gemstone-core'
classmethod: RwPlatform
reset

	^ self _userPlatformDictionary 
		removeKey: #RwUserPlatformInstance 
		ifAbsent: [ ]
%

category: '*rowan-gemstone-core'
classmethod: RwPlatform
_userPlatformDictionary

	"Platform globals are put into the current user's UserGlobals so that the values can be persisted.
		if the user does not have write access to UserGlobals, we'll store in session-specific dictionary"

	^self _userPlatformDictionaryForUser: RwGsImage currentUserId
%

category: '*rowan-gemstone-core'
classmethod: RwPlatform
_userPlatformDictionaryForUser: aUserId

	"Platform globals are put into the current user's UserGlobals so that the values can be persisted.
		if the user does not have write access to UserGlobals, we'll store in session-specific dictionary"

	| userGlobals |
	userGlobals := (AllUsers userWithId: aUserId) objectNamed: 'UserGlobals'.
	^ (System canWrite: userGlobals)
		ifTrue: [ userGlobals ]
		ifFalse: [ SessionTemps current ]
%

!		Instance methods for 'RwPlatform'

category: '*rowan-core'
method: RwPlatform
projectNamed: aName

	"Answer a project with the given name.  If no project with the given name is found, signals error."

	| project |
	project := RwProject newNamed: aName.
	project _loadedProject.	"signal error, if the project does not exist"
	^ project
%

category: '*rowan-core'
method: RwPlatform
projectNamed: aName ifPresent: presentBlock ifAbsent: absentBlock

	"Lookup a loaded project with the given name, if found evaluate the <presentBlock>, if not evaluate the <absentBlock.."

	^ Rowan image
		loadedProjectNamed: aName
		ifPresent: [:loadedProject |  presentBlock cull: (RwProject newNamed: aName) ]
		ifAbsent: absentBlock
%

! Class extensions for 'RwProject'

!		Instance methods for 'RwProject'

category: '*rowan-gemstone-core'
method: RwProject
defaultSymbolDictName

	^ self _gemstonePlatformSpec defaultSymbolDictName
%

category: '*rowan-gemstone-core'
method: RwProject
defaultUseSessionMethodsForExtensions

	^ self _gemstonePlatformSpec defaultUseSessionMethodsForExtensions
%

category: '*rowan-gemstone-core'
method: RwProject
methodEnvForPackageNamed: packageName

	^ self _gemstonePlatformSpec methodEnvForPackageNamed: packageName
%

category: '*rowan-gemstone-core'
method: RwProject
symbolDictNameForPackageNamed: packageName

	^ self _gemstonePlatformSpec symbolDictNameForPackageNamed: packageName
%

category: '*rowan-gemstone-core'
method: RwProject
useSessionMethodsForExtensionsForPackageNamed: packageName

	^ self _gemstonePlatformSpec
		useSessionMethodsForExtensionsForPackageNamed: packageName
%

! Class extensions for 'RwProjectDefinition'

!		Instance methods for 'RwProjectDefinition'

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
asLoadedSymbolDictProject

	^ RwGsLoadedSymbolDictProject newForLoadSpecification: self specification.
%

category: '*rowan-core-definitions-extensions'
method: RwProjectDefinition
compareAgainstBase: aDefinition

	| modification packagesModification |
	modification := RwProjectModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	packagesModification := RwPackagesModification new.
	self
		compareDictionary: packages
		againstBaseDictionary: aDefinition packages
		into: packagesModification
		elementClass: RwPackageDefinition.
	modification packagesModification: packagesModification.
	^ modification
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
defaultSymbolDictName

	^ (self specification platformSpec at: 'gemstone') defaultSymbolDictName
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
defaultSymbolDictName: symbolDictName

	(self specification platformSpec at: 'gemstone')
		defaultSymbolDictName: symbolDictName
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
defaultUseSessionMethodsForExtensions: aBool

	(self specification platformSpec at: 'gemstone')
		defaultUseSessionMethodsForExtensions: aBool
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
methodEnvForPackageNamed: packageName

	^ (self specification platformSpec at: 'gemstone')
		methodEnvForPackageNamed: packageName
%

category: '*rowan-cypress-definitions'
method: RwProjectDefinition
name
  ^ self key
%

category: '*rowan-core-definitions-extensions'
method: RwProjectDefinition
projectDefinitionSourceProperty

	^ properties at: RwLoadedProject _projectDefinitionSourceKey ifAbsent: [ RwLoadedProject _projectUnknownDefinitionSourceValue ]
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
projectOwnerId

	^ (self specification platformSpec at: 'gemstone') projectOwnerId
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
projectOwnerId: aUserId

	(self specification platformSpec at: 'gemstone') projectOwnerId: aUserId
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
setSymbolDictName: symbolDictName forPackageNamed: packageName

	(self specification platformSpec at: 'gemstone')
		setSymbolDictName: symbolDictName
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
setUseSessionMethodsForExtensions: aBool forPackageNamed: packageName

	(self specification platformSpec at: 'gemstone')
		setUseSessionMethodsForExtensions: aBool
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
symbolDictionaryRegistryClass

	^ RwGsSymbolDictionaryRegistry
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
symbolDictNameForPackageNamed: packageName

	^ (self specification platformSpec at: 'gemstone')
		symbolDictNameForPackageNamed: packageName
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
updateGsPlatformSpecLoadedProjectInfo: projectInfo

	| spec gemstoneSpec thePackageMapSpecs |
	spec := self specification.
	thePackageMapSpecs := projectInfo at:  'packageMapSpecs' .
	gemstoneSpec := spec platformSpec at: 'gemstone'.
	(thePackageMapSpecs at: #defaultSymbolDictName otherwise: nil) 
		ifNotNil: [:name | gemstoneSpec defaultSymbolDictName: name ].
	(thePackageMapSpecs at: #defaultUseSessionMethodsForExtensions otherwise: nil) 
		ifNotNil: [:boolean | 
			gemstoneSpec defaultUseSessionMethodsForExtensions: boolean  ].
	(thePackageMapSpecs at: #packageNameToPlatformPropertiesMap otherwise: nil) 
		ifNotNil: [:map | gemstoneSpec packageNameToPlatformPropertiesMap: map]
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
useSessionMethodsForExtensionsForPackageNamed: packageName

	^ (self specification platformSpec at: 'gemstone')
		useSessionMethodsForExtensionsForPackageNamed: packageName
%

category: '*rowan-core-definitions-extensions'
method: RwProjectDefinition
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue

	({ 'projectOwnerId' . 'spec'. RwLoadedProject _projectDefinitionSourceKey. 'projectRef' } includes: propertyKey)
		ifTrue: [ 
		"projectRef entries are considered to be equal for comparison purposes"
		"spec entries are considered to be equal for comparison purposes"
		"_projectDefinitionSourceKey entries are considered equal for comparison purpposes"
		"projectOwnerId entries are considered equal for comparison purpposes"
		^ true ].
	^ super _compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue
%

! Class extensions for 'RwProjectReferenceDefinition'

!		Instance methods for 'RwProjectReferenceDefinition'

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
asSpecification

	| repoSpec platformSpec platformDict |
	self useGit
		ifTrue: [
			repoSpec := RwGitRepositorySpecification new
				committish: self committish;
				committishType: self committishType;
				remoteUrl: self remoteUrl;
				yourself ]
		ifFalse: [  repoSpec := RwDiskRepositorySpecification new ] .
	platformSpec := RwGemStoneSpecification new.
	platformSpec packageNameToPlatformPropertiesMap: self packageNameToPlatformPropertiesMap.
	platformDict := (Dictionary new) at: 'gemstone' put: platformSpec; yourself.
	^ RwComponentSpecification new
		specName: self projectName;
		projectUrl: self projectUrl;
		repoPath: self packagesPath;
		configsPath: self configsPath;
		specsPath: self specsPath;
		projectsPath: self projectsPath;
		defaultComponentName: self defaultComponentName;
		defaultConfigurationNames: self configurationNames;
		defaultGroupNames: self groupNames;
		comment: self comment;
		repoSpec: repoSpec;
		platformSpec: platformDict;
		yourself.
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
defaultMethodEnv

	^ self properties at: 'defaultMethodEnv' ifAbsent: [ 0 ]
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
defaultMethodEnv: anInteger

	^ self properties at: 'defaultMethodEnv' put: anInteger
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
defaultSymbolDictName

	^ self properties at: 'defaultSymbolDictName' ifAbsent: [ 'UserGlobals' ]
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
defaultSymbolDictName: aString

	^ self properties at: 'defaultSymbolDictName' put: aString
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
defaultUseSessionMethodsForExtensions

	^ self properties at: 'defaultUseSessionMethodsForExtensions' ifAbsent: [ false ]
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
defaultUseSessionMethodsForExtensions: aBool

	^ self properties at: 'defaultUseSessionMethodsForExtensions' put: aBool
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
methodEnvForPackageNamed: packageName

	| packageProperties |
	packageProperties :=self packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ ^ self defaultMethodEnv ].
	^ packageProperties at: 'methodEnv' ifAbsent: [ self defaultMethodEnv ]
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
packageNameToPlatformPropertiesMap

	^ self properties at: 'packageNameToPlatformPropertiesMap' ifAbsentPut: [ Dictionary new ]
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
packageNameToPlatformPropertiesMap: aDictionary

	^ self properties at: 'packageNameToPlatformPropertiesMap' put: aDictionary
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
setSymbolDictName: symbolDictName forPackageNamed: packageName

	| packageProperties packageNameToPlatformPropertiesMap |
	packageNameToPlatformPropertiesMap := self packageNameToPlatformPropertiesMap.
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ packageNameToPlatformPropertiesMap at: packageName put: Dictionary new ].
	symbolDictName 
		ifNil: [
			"remove the entry if it exists"
			packageProperties removeKey: 'symbolDictName' ifAbsent: [].
			^self ].
	packageProperties at: 'symbolDictName' put: symbolDictName
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
symbolDictNameForPackageNamed: packageName

	| packageProperties |
	packageProperties := self packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ ^ self defaultSymbolDictName ].
	^ packageProperties
		at: 'symbolDictName'
		ifAbsent: [ ^ self defaultSymbolDictName ]
%

category: '*rowan-gemstone-components-extensions'
method: RwProjectReferenceDefinition
useSessionMethodsForExtensionsForPackageNamed: packageName

	| packageProperties |
	packageProperties := self packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ ^ self defaultUseSessionMethodsForExtensions ].
	^ packageProperties
		at: 'useSessionMethodsForExtensions'
		ifAbsent: [ ^ self defaultUseSessionMethodsForExtensions ]
%

! Class extensions for 'RwProjectSetDefinition'

!		Instance methods for 'RwProjectSetDefinition'

category: '*rowan-core-definitions-extensions'
method: RwProjectSetDefinition
compareAgainstBase: aDefinition

	| result |
	result := RwProjectSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary: aDefinition definitions
		into: result
		elementClass: RwProjectDefinition.
	^ result
%

category: '*rowan-core-definitions-extensions'
method: RwProjectSetDefinition
compareAgainstBase_254: aDefinition

	| result |
	result := RwProjectSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary: aDefinition definitions
		into: result
		elementClass: RwProjectDefinition.
	result
		updateForClassMoves;
		updateForMethodMoves.
	^ result
%

! Class extensions for 'RwProjectSpecification'

!		Instance methods for 'RwProjectSpecification'

category: '*rowan-gemstone-specifications'
method: RwProjectSpecification
initialize

	super initialize.
	comment := ''.
	configsPath := 'rowan/configs'.
	repoPath := 'rowan/src'.
	specsPath := 'rowan/specs'.
	platformSpec := Dictionary new
		at: 'gemstone' put: RwGemStoneSpecification new;
		yourself.
	repoSpec := RwGitRepositorySpecification new.
	version := self currentVersion.
	defaultConfigurationNames := {'Default'}.
	defaultGroupNames := {'default'}.
%

category: '*rowan-gemstone-specifications'
method: RwProjectSpecification
platformSpec

   ^platformSpec ifNil: [ 
		platformSpec := Dictionary new
			at: 'gemstone' put: RwGemStoneSpecification new;
			yourself ].
%

! Class extensions for 'RwSpecification'

!		Instance methods for 'RwSpecification'

category: '*rowan-gemstone-specifications'
method: RwSpecification
register

	Rowan image 
		loadedProjectNamed: self specName
		ifAbsent: [
			| newLoadedProject |
			newLoadedProject := RwGsLoadedSymbolDictProject newForLoadSpecification: self.
			Rowan image addLoadedProject: newLoadedProject ]
%

! Class extensions for 'RwUnmanagedProjectDefinition'

!		Instance methods for 'RwUnmanagedProjectDefinition'

category: '*rowan-gemstone-definitions'
method: RwUnmanagedProjectDefinition
defaultSymbolDictName

	^ 'UnmanagedPackages'
%

category: '*rowan-gemstone-definitions'
method: RwUnmanagedProjectDefinition
methodEnvForPackageNamed: packageName

	^ 0
%

category: '*rowan-gemstone-definitions'
method: RwUnmanagedProjectDefinition
projectOwnerId

	^ Rowan image currentUserId
%

category: '*rowan-gemstone-definitions'
method: RwUnmanagedProjectDefinition
symbolDictNameForPackageNamed: packageName

	^ self defaultSymbolDictName
%

category: '*rowan-gemstone-definitions'
method: RwUnmanagedProjectDefinition
useSessionMethodsForExtensionsForPackageNamed: packageName

	^ true
%

! Class extensions for 'RwUrl'

!		Class methods for 'RwUrl'

category: '*rowan-url-3215'
classmethod: RwUrl
httpFromString: aString
  ^CypressUrl absoluteFromText: aString
%

!		Instance methods for 'RwUrl'

category: '*rowan-url-cypress'
method: RwUrl
createRwCypressRepositoryForPath: repositoryDirectoryPath
  | repo |
  repo := CypressFileSystemRepository new
    initializeDefaultRepositoryProperties;
    codeFormatProperty: 'Cypress';
    strictCodeFormat: false;
    initializeForDirectory: repositoryDirectoryPath;
    url: self printString;
    yourself.
  ^ repo
%

category: '*rowan-url-cypress'
method: RwUrl
createRwFiletreeRepositoryForPath: repositoryDirectoryPath

	^ CypressFileSystemRepository new
		initializeDefaultRepositoryProperties;
		initializeForDirectory: repositoryDirectoryPath;
		codeFormatProperty: 'FileTree';
		strictCodeFormat: false;
		initializeReaderAndWriterClasses;
		url: self printString;
		yourself
%

category: '*rowan-url-cypress'
method: RwUrl
createRwTonelRepositoryForPath: repositoryDirectoryPath
  ^ CypressTonelRepository new
    initializeDefaultRepositoryProperties;
    initializeForDirectory: repositoryDirectoryPath;
    codeFormatProperty: 'Tonel';
    strictCodeFormat: false;
    initializeReaderAndWriterClasses;
    url: self printString;
    yourself
%

! Class extensions for 'SequenceableCollection'

!		Class methods for 'SequenceableCollection'

category: '*rowan-gemstone-kernel'
classmethod: SequenceableCollection
new: size withAll: value

	"Answer an instance of me, with number of elements equal to size, each 
	of which refers to the argument, value."

	^ (self new: size)
		atAllPut: value;
		yourself
%

!		Instance methods for 'SequenceableCollection'

category: '*rowan-gemstone-kernel'
method: SequenceableCollection
copyUpTo: anObject

	"Answer all elements up to but not including anObject. If there
  is no such object, answer a copy of the receiver."

	| idx |
	idx := self indexOf: anObject startingAt: 1.
	idx == 0
		ifTrue: [ ^ self copy ]
		ifFalse: [ ^ self copyFrom: 1 to: idx - 1 ]
%

category: '*ast-kernel-core'
method: SequenceableCollection
rbStoreElementsFrom: firstIndex to: lastIndex on: aStream
  | noneYet defaultElement arrayElement |
  noneYet := true.
  defaultElement := nil.
  firstIndex to: lastIndex do: [ :index | 
    arrayElement := self at: index.
    arrayElement = defaultElement
      ifFalse: [ 
        noneYet
          ifTrue: [ noneYet := false ]
          ifFalse: [ aStream nextPut: $; ].
        aStream nextPutAll: ' at: '.
        index rbStoreOn: aStream.
        aStream nextPutAll: ' put: '.
        arrayElement rbStoreOn: aStream] ].
  ^ noneYet
%

category: '*ast-kernel-core'
method: SequenceableCollection
rbStoreOn: aStream
  aStream nextPutAll: '(('.
  aStream nextPutAll: self class name.
  aStream nextPutAll: ' new: '.
  self size rbStoreOn: aStream.
  aStream nextPut: $).
  (self rbStoreElementsFrom: 1 to: self size on: aStream)
    ifFalse: [ aStream nextPutAll: '; yourself' ].
  aStream nextPut: $)
%

! Class extensions for 'String'

!		Instance methods for 'String'

category: '*rowan-gemstone-kernel'
method: String
decodeFromUTF8

"Deprecated.  Applications should use instances of Utf8 to hold UTF-8 data.
 Decode receiver from UTF8 format."

"Undeprecated by Rowan, because the method has been undeprecated in later GemStone versions"

" Returns either a Unicode7 , Unicode16 or Unicode32 ,
 using the minimum character size needed to represent decoded result."

 ^ self _decodeFromUtf8: true
%

! Class extensions for 'Symbol'

!		Instance methods for 'Symbol'

category: '*ast-kernel-core'
method: Symbol
rbStoreOn: aStream
  aStream nextPut: $#.
  super rbStoreOn: aStream
%

! Class extensions for 'SymbolDictionary'

!		Instance methods for 'SymbolDictionary'

category: '*rowan-gemstone-kernel'
method: SymbolDictionary
rowanSymbolDictionaryRegistry

	"answer the RwGsSymbolDictionaryRegistry instance installed in the receiver, otherwise answer nil"

	^ self at: #'RwSymbolDictionaryRegistry' ifAbsent: [  ]
%

category: '*rowan-gemstone-35x'
method: SymbolDictionary
_rowanCloneSymbolDictionaryNamed: aSymbol symbolList: symbolList

	"return a new symbol dictionary containing copies of all of the classes in the receiver ... the state of each class should be the same with 
		respect to class intance variables and class variables ... similar to what happens when a new version of a class is created, except the
		copied classes are not in the class history of the original class"

	"it is expected that the receiver is in the <symbolList>"

	| toBeOrdered order clonedSymDict processed aClass clonedClasses |
    "order the list of classes in the receiver in superclass order, so that superclasses are cloned before the subclasses are cloned"
	toBeOrdered := (self values select: [:each | each isBehavior ]) asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[ (aClass := RwGsPatchSet_254 _anyElementOf: toBeOrdered ifEmpty: [ nil ]) isNil ]
		whileFalse: [ 
			RwGsPatchSet_254
				_orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed ].
	"create clone and clone all of the classes before compiling methods"
	clonedSymDict := self class new.
	clonedSymDict name: aSymbol.
	clonedClasses := OrderedCollection new.
	[
		symbolList add: clonedSymDict before: self. "install clone after receiver, so that methods will be compiled and reference the cloned classes"
		"clone the body of classes before compiling methods"
		order do: [:oldClass |
			| oldClassName clonedClass hist superclass |
			oldClassName := oldClass name asSymbol.
			hist := oldClass classHistory copy.	"make copy ... leverage the new class version behavior, which preserves a lot of state, without 
																adding the new class to old class' class hitory"
			superclass := symbolList objectNamed: oldClass superclass name. "look up superclass, in case superclass has been cloned"
			clonedClass :=  superclass
				_subclass: oldClassName asString 
				instVarNames: oldClass instVarNames
				format: oldClass format  
				classVars: oldClass classVarNames
				classInstVars: oldClass class instVarNames
				poolDictionaries: #()
				inDictionary: nil
				inClassHistory: hist
				description: ''
				options: oldClass _nonInheritedOptions.
			clonedSymDict at: oldClassName put: clonedClass.
			clonedClasses add: {clonedClass. oldClass} ].
			"compile methods in cloned class"
			clonedClasses do: [:ar | | x clonedClass oldClass |
				clonedClass := ar at: 1.
				oldClass := ar at: 2.
				(x := clonedClass _rowanCopyMethodsAndVariablesFrom: oldClass dictionaries: symbolList)
					isEmpty 
						ifFalse: [ self error: 'failed to compile methods in the cloned class ', oldClass name asString printString ] ] ] 
		ensure: [ 
			"do not leave clone in the symbol list"
			symbolList remove: clonedSymDict ifAbsent: [] ].
	^ clonedSymDict
%

! Class extensions for 'UndefinedObject'

!		Instance methods for 'UndefinedObject'

category: '*ast-kernel-core'
method: UndefinedObject
rbStoreOn: aStream
  aStream nextPutAll: self asString
%

category: '*rowan-gemstone-kernel'
method: UndefinedObject
subclass: aString 
instVarNames: anArrayOfInstvarNames 
classVars: anArrayOfClassVars 
classInstVars: anArrayOfClassInstVars 
poolDictionaries: anArrayOfPoolDicts 
inDictionary: aDictionary 
newVersionOf: oldClass 
description: aDescription 
constraints: constraintsArray
options: optionsArray

  | descr theClass superClassOffset |
  descr := aDescription.
  oldClass ifNotNil: [ 
     (Object _equivalentSubclass: oldClass
        superCls: self
        name: aString
        newOpts: optionsArray
        newFormat: oldClass format
        newInstVars: anArrayOfInstvarNames
        newClassInstVars: anArrayOfClassInstVars
        newPools: anArrayOfPoolDicts
        newClassVars: anArrayOfClassVars
        inDict: aDictionary
        constraints: constraintsArray isKernel: false ) ifTrue: [
            oldClass _commentOrDescription: aDescription.
            ^oldClass "avoid creation of a new version"
        ].
      descr ifNil: [descr := oldClass rwComment]
  ].
  theClass := Object
        subclass: aString
        instVarNames: anArrayOfInstvarNames
        classVars: anArrayOfClassVars
        classInstVars: anArrayOfClassInstVars
        poolDictionaries: anArrayOfPoolDicts
        inDictionary: aDictionary
        newVersionOf: oldClass
        description: descr
		constraints: constraintsArray
        options: optionsArray.
  theClass == oldClass
    ifFalse:
      [superClassOffset := Behavior _ivOffsetOf: #superClass.
      theClass _unsafeAt: superClassOffset put: nil.
      theClass class _unsafeAt: superClassOffset put: Object class superClass].
  ^theClass
%

! Class extensions for 'Warning'

!		Instance methods for 'Warning'

category: '*gemstone-interactions-kernel'
method: Warning
defaultAction
  "The user should be notified of the occurrence of an exceptional
	occurrence and given an option of continuing or aborting the
	computation. The description of the occurrence should include
	any text specified as the argument of the #signal: message."

  | response |
  response := (GsNotifyInteraction
    prompt:
      self description withoutGemstoneLineEndings , ' Press ''Proceed'' to continue.'
    confirm: 'Proceed'
    cancel: 'Debug'
    abort: 'Cancel') signal.
  response == true
    ifTrue: [ ^ super defaultAction ].
  response == false
    ifTrue: [ self halt: 'Debugging: ' , self description ].
  ^ Processor activeProcess terminate
%

! Class Initialization

run
RBConfigurableFormatter initialize.
RBPatternScanner initialize.
RBScanner initialize.
Rowan initialize.
RwLoadedThing initialize.
RwModificationFiletreeWriterVisitor initialize.
%

