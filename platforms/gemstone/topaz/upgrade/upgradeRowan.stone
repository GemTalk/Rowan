#!/usr/bin/env superdoit_stone
# Standard options are always present unless customoptions section is used
#
options
{
  SuperDoitOptionalOptionWithRequiredArg long: 'projectsHome' default: '/home/dhenrich/rogue/_homes/rogue/_home/server/stones/dbo_anon_3215/git'.
	SuperDoitOptionalOptionWithNoArg long: 'installRowan'.
	SuperDoitOptionalOptionWithNoArg long: 'commit'.
	SuperDoitOptionalOptionWithNoArg long: 'audit'.
	SuperDoitOptionalOptionWithNoArg long: 'customerRepair'.
	SuperDoitOptionalOptionWithNoArg long: 'rowanRepair'.
	SuperDoitOptionalOptionWithNoArg long: 'skip'.
	SuperDoitOptionalOptionWithNoArg long: 'customerReload'.
	SuperDoitOptionalOptionWithNoArg long: 'rowanReload'.
	SuperDoitOptionalOptionWithNoArg long: 'persistIt'.
}
%
usage
-----
USAGE
  # with GS_HOME set (<stone-name> optional if run in $GS_HOME/servers/stones/<stone-name> directory)
  $basename [--help | -h] [--debug | -D] [-- [<stone-name> [<topaz-command-line-args>] ] ]
  # with GEMSTONE set
  $basename [--help | -h] [--debug | -D] -- ([-r] | -l | -L) -I <path-to-.topazini> [<topaz-command-line-args>]

DESCRIPTION
  experiments in upgrading Rowan

OPTIONS
  <stone-name>               Name of the GsDevKit_home stone. <stone-name> argument
                             may be skipped if the script is run in a GsDevKit_home
                             stone directory (i.e., $GS_HOME/server/stones/<stone-name>
  <topaz-command-line-args>  topaz options that should be passed to topaz when running
                             running the script
  -h, --help                 display usage message
  -D, --debug                bring up topaz debugger in the event of a script error

EXAMPLES
  $basename --help                           -- gs_351             # with GS_HOME set
  $basename -h                               -- -l -I ./.topazini  # with GEMSTONE set
  $basename --help
  $basename -D <script-arguments>            <topaz-arguments>
  $basename --debug <script-arguments>       <topaz-arguments>
  $basename <script-arguments>               <topaz-arguments>

  $basename -D --installRowan --commit
  $basename -D --rowanRepair --skip --commit
  $basename -D --rowanRepair                    # expected to run clean before reload
  $basename -D --customerRepair --skip --commit
  $basename -D --customerRepair                 # expected to run clean before reload
  $basename -D --rowanReload --commit
  $basename -D --customerReload --commit
  $basename -D --audit                          # audit all projects ... run clean
-----
%
instvars
audit
repairMethodMap
repairedCount
skipCount
repairedByReload
errorMessages
auditErrors
%
method
auditForProjectsNamed: theProjectNames
	| res |
	res := KeyValueDictionary new.
	theProjectNames do: [:prjName | res addAll: (Rowan projectTools audit auditForProjectNamed: prjName )	].
	^res
%
method
countAuditErrors
	auditErrors ifNil: [ auditErrors := 0 ].
	audit keysAndValuesDo: [:packageName :classAuditErrors |
		classAuditErrors keysAndValuesDo: [:className :auditAssocs |
			auditErrors := auditErrors + auditAssocs size ] ].
	self logMessage: auditErrors printString, ' audit errors'.
%
method
customerRepairNonIdenticalClassMethodFor: methodSpec inClassNamed: className inPackageNamed: packageName
	^ self customerRepairNonIdenticalMethodFor: methodSpec inClassNamed: className isMeta: true inPackageNamed: packageName
%
method
customerRepairNonIdenticalInstanceMethodFor: methodSpec inClassNamed: className inPackageNamed: packageName
	^ self customerRepairNonIdenticalMethodFor: methodSpec inClassNamed: className isMeta: false inPackageNamed: packageName
%
method
customerRepairNonIdenticalMethodFor: methodSpec inClassNamed: className isMeta: isMeta inPackageNamed: packageName
	| loadedMethod loadedClass loadedPackage loadedProject selector theClass theBehavior oldCompiledMethod
		registryInstance newCompiledMethod |

	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedClass := loadedPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ self error: 'No loaded class or loaded extension class found for ', className printString ].
	selector := self selectorFromMethodSpec: methodSpec.
	loadedMethod := isMeta
		ifTrue: [ loadedClass loadedClassMethods at: selector ]
		ifFalse: [ loadedClass loadedInstanceMethods at: selector ].
	loadedProject := loadedMethod loadedProject.
	theClass := Rowan globalNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].
	newCompiledMethod := theBehavior compiledMethodAt: selector otherwise: nil.
	oldCompiledMethod := loadedMethod handle.

	newCompiledMethod == oldCompiledMethod
		ifTrue: [
			"confirm audit error"
			self error: 'identical compiled methods when non-identical compiled methods expected for ', className, (isMeta ifTrue: [ ' class >> ' ] ifFalse: [' >> ']), selector printString ].

	"For customer repair, we ignore the newCompiledMethod (if it exists), since the incoming
		method will be installed using Rowan"

	registryInstance := Rowan image loadedRegistryForPackageNamed: packageName.
	(self globalNamed: 'RwGsSymbolDictionaryRegistry_Implementation')
		_doDeleteCompiledMethodFromLoadedThings: oldCompiledMethod
		for: theBehavior
		instance: registryInstance.

	repairedCount := self repairedCount + 1.
%
method
cypressClassNames
	^ {
	'CypressLoaderErrorNotification' .
	'CypressFileSystemGitRepository' .
	'CypressUnknownPackageInformation' .
	'CypressAbstractPackageFiler' .
	'CypressFileUtilities' .
	'CypressFlexiblePackageReader' .
	'CypressHierarchicalUrl' .
	'CypressSnapshot' .
	'CypressHttpsUrl' .
	'CypressDictionaryRepository' .
	'CypressPackageStringComparator' .
	'CypressLoaderError' .
	'CypressObject' .
	'CypressConflictingPackageInformation' .
	'CypressFileTreeFormatPackageReader' .
	'CypressPatch' .
	'CypressTopazUrl' .
	'CypressSmalltalkUrl' .
	'CypressEnvironmentPackageManager' .
	'CypressBrowserUrl' .
	'CypressMailtoUrl' .
	'CypressJsonParser' .
	'CypressStructure' .
	'CypressPackageWriter' .
	'CypressAddition' .
	'CypressVersionReference' .
	'CypressGsGeneralDependencySorter' .
	'CypressUrl' .
	'CypressTopazFileoutWriter' .
	'CypressError' .
	'CypressFileTreeFormatPackageWriter' .
	'CypressFileUrl' .
	'CypressPackageComparator' .
	'CypressStrictFileTreeFormatDoNothingPackageWriter' .
	'CypressGitFileUrl' .
	'CypressAbstractFileoutWriter' .
	'CypressPackageManager' .
	'CypressAbstractFileoutRepository' .
	'CypressAbstractRepository' .
	'CypressGemStoneDirectoryUtilities' .
	'CypressDefinition' .
	'CypressKnownPackageInformation' .
	'CypressDefinitionIndex' .
	'CypressResolvedReference' .
	'CypressSmalltalkFileoutWriter' .
	'CypressFileSystemRepository' .
	'CypressCypressFileUrl' .
	'CypressClassStructure' .
	'CypressJsonError' .
	'CypressFileTreeFormatFileUrl' .
	'CypressEnvironmentDependencySorter' .
	'CypressReference' .
	'CypressFileTreeReadOnlyFileUrl' .
	'CypressModification' .
	'CypressMessageDigestStream' .
	'CypressSmalltalkRepository' .
	'CypressEnvironmentLoader' .
	'CypressHttpUrl' .
	'CypressPackageManager3' .
	'CypressPackageReader' .
	'CypressFtpUrl' .
	'CypressPackageManager2' .
	'CypressLoaderMissingClasses' .
	'CypressRemoval' .
	'CypressPackageStructure' .
	'CypressLaxFileUrl' .
	'CypressMethodStructure' .
	'CypressGenericUrl' .
	'CypressPackageDefinition' .
	'CypressPackageReference' .
	'CypressMethodDefinition' .
	'CypressDoNothingPackageReader' .
	'CypressClassDefinition' .
	'CypressPatchOperation' .
	'CypressAbstractFileUrl' .
	'CypressAbstractPackageWriter' .
	'CypressGitFileTreeUrl' .
	'CypressPackageInformation' .
	'CypressLoader' .
	'CypressAbstractPackageInformation' .
	'CypressAbstractPackageReader' .
	'CypressEnvironmentPackageDefinition' .
	'CypressEclipsedPackageInformation' .
	'CypressTopazRepository' .
	'CypressDependencySorter' .
	}
%
method
errorMessages
^ errorMessages ifNil: [ errorMessages := Bag new ].
%
method
forCustomer
	^ self customerRepair | self customerReload
%
method
moveCypressClassesToGlobals: cypressClassNames
	cypressClassNames do: [:name |
		(ObsoleteClasses associationAt: name asSymbol ifAbsent: [])
			ifNotNil: [:assoc | Globals addAssociation: assoc ] ].
%
method
projectNames
	| rowanProjectNames |
	rowanProjectNames := #( 'Rowan' 'STON' 'Cypress' 'Tonel' ).
	^ self positionalArgs isEmpty
		ifTrue: [
			self forCustomer
				ifTrue: [
					| customerProjectNames |
					customerProjectNames := Rowan projectNames.
					customerProjectNames removeAllPresent: rowanProjectNames.
					customerProjectNames ]
				ifFalse: [
					self audit
						ifTrue: [ Rowan projectNames ]
						ifFalse: [ rowanProjectNames ] ] ]
		ifFalse: [ self positionalArgs ]
%
method
reloadCustomer
	| customerProjectNames |
	self logMessage: 'Upgrade customer projects'.
	customerProjectNames := self projectNames.
	customerProjectNames do: [:projectName |
		self logMessage: 'Loading ', projectName.
		Rowan projectTools load loadProjectNamed: projectName ].
	self commit
		ifTrue: [
			System commit.
			self logMessage: 'customer load commit' ]
%
method
reloadRowan
	#( 'Rowan' 'Cypress' 'STON' 'Tonel' )
		do: [:projectName |
			"make sure test group is loaded ... include deprecated packages for now"
			[
			| groupNames |
			groupNames := #('tests' 'deprecated' 'jadeServer').
			self logMessage: 'Loading ', projectName.
			Rowan projectTools load
				loadProjectNamed: projectName
				withGroupNames: groupNames ]
					on: CompileWarning do: [:ex | ex resume ] ].
%
method
repairAuditFailures
	audit keysAndValuesDo: [:packageName :classAuditErrors |
		| method |
		classAuditErrors keysAndValuesDo: [:className :auditAssocs |
			auditAssocs do: [:assoc |
				| error repairSelector |
				method := assoc key.
				error := assoc value.
				self errorMessages add: error.
				self audit
					ifFalse: [
						repairSelector := self repairMethodMap
							at: error
							ifAbsent: [
								self skip
									ifTrue: [
										#skipRepair:inClassNamed:inPackageNamed:
									]
									ifFalse: [ self error: 'unrepairable audit error: ', error printString  ] ].
						self perform: repairSelector
							with: method
							with: className
							with: packageName ] ] ] ].
%
method
repairedByReload
	^ repairedByReload ifNil: [ repairedByReload := 0 ].
%
method
repairedCount
	^ repairedCount ifNil: [ repairedCount := 0 ].
%
method
repairedWhenDefinitionsReloaded:ignoredMethod inClassNamed: ignoredClassName inPackageNamed: ignoredPackageName
	repairedByReload := self repairedByReload + 1
%
method
repairMethodMap
	repairMethodMap ifNotNil: [ ^ repairMethodMap ].
	repairMethodMap := Dictionary new.
	self forCustomer
		ifTrue: [
			"With the exception of the 'Extension...' error, the listed audit errors are expected to be seen as a result of
				removing methods from kernel methods during upgradeImage"
			repairMethodMap
				at: 'Extension category name can not be same as class package' put: #repairedWhenDefinitionsReloaded:inClassNamed:inPackageNamed:;
				at: 'Missing instance method extension category ' put: #repairedWhenDefinitionsReloaded:inClassNamed:inPackageNamed:;
				at: 'Missing class method extension category ' put: #repairedWhenDefinitionsReloaded:inClassNamed:inPackageNamed:;
				at: 'Missing compiled class method. ' put: #customerRepairNonIdenticalClassMethodFor:inClassNamed:inPackageNamed:;
				at: 'Missing compiled instance method. ' put: #customerRepairNonIdenticalInstanceMethodFor:inClassNamed:inPackageNamed:;
				at: 'Compiled instance method is not identical to loaded instance method. ' put: #customerRepairNonIdenticalInstanceMethodFor:inClassNamed:inPackageNamed:;
				at: 'Compiled instance method is not identical to loaded method. ' put: #customerRepairNonIdenticalInstanceMethodFor:inClassNamed:inPackageNamed:;
				at: 'Compiled classmethod is not identical to loaded class method ' put: #customerRepairNonIdenticalClassMethodFor:inClassNamed:inPackageNamed:;
				at: 'Comment has changed in compiled class v loaded class' put: #repairedWhenDefinitionsReloaded:inClassNamed:inPackageNamed:;
				yourself ]
		ifFalse: [
			self audit
				ifFalse: [
					repairMethodMap
						at: 'Compiled instance method is not identical to loaded method. ' put: #repairNonIdenticalInstanceMethodFor:inClassNamed:inPackageNamed:;
						at: 'Compiled classmethod is not identical to loaded class method ' put: #repairNonIdenticalClassMethodFor:inClassNamed:inPackageNamed:;
						at: 'Comment has changed in compiled class v loaded class' put: #repairedWhenDefinitionsReloaded:inClassNamed:inPackageNamed:;
				yourself ] ].
	^ repairMethodMap
%
method
repairNonIdenticalClassMethodFor: methodSpec inClassNamed: className inPackageNamed: packageName
	^ self repairNonIdenticalMethodFor: methodSpec inClassNamed: className isMeta: true inPackageNamed: packageName
%
method
repairNonIdenticalInstanceMethodFor: methodSpec inClassNamed: className inPackageNamed: packageName
	^ self repairNonIdenticalMethodFor: methodSpec inClassNamed: className isMeta: false inPackageNamed: packageName
%
method
repairNonIdenticalMethodFor: methodSpec inClassNamed: className isMeta: isMeta inPackageNamed: packageName
	| loadedMethod loadedClass loadedPackage loadedProject selector theClass theBehavior oldCompiledMethod
		newCompiledMethod registryInstance |

	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedClass := loadedPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ self error: 'No loaded class or loaded extension class found for ', className printString ].
	selector := self selectorFromMethodSpec: methodSpec.
	loadedMethod := isMeta
		ifTrue: [ loadedClass loadedClassMethods at: selector ]
		ifFalse: [ loadedClass loadedInstanceMethods at: selector ].
	loadedProject := loadedMethod loadedProject.
	theClass := Rowan globalNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].
	newCompiledMethod := theBehavior compiledMethodAt: selector.
	oldCompiledMethod := loadedMethod handle.

	newCompiledMethod == oldCompiledMethod
		ifTrue: [
			"confirm audit error"
			self error: 'identical compiled methods when non-identical compiled methods expected for ', className, (isMeta ifTrue: [ ' class >> ' ] ifFalse: [' >> ']), selector printString ].

	registryInstance := Rowan image loadedRegistryForPackageNamed: packageName.
	registryInstance methodRegistry removeKey: oldCompiledMethod.
	loadedMethod handle: newCompiledMethod.
	registryInstance methodRegistry at: newCompiledMethod put: loadedMethod.
	repairedCount := self repairedCount + 1.
%
method
selectorFromMethodSpec: methodSpec
	| index |
	index := methodSpec indexOfSubCollection: ' >> ' startingAt: 1.
	^ (methodSpec copyFrom: index + 4 to: methodSpec size) asSymbol
%
method
skipCount
	^ skipCount ifNil: [ skipCount := 0 ]
%
method
skipRepair: ignoredMethod inClassNamed: ignoredClassName inPackageNamed: ignoredPackageName
	skipCount := self skipCount + 1
%
doit
	self persistIt ifTrue: [ self persist. self logMessage: 'PERSISTED'. ^ self noResult ].
	self logMessage: 'Rowan v', Rowan versionString, ' currently installed in GemStone', (System stoneVersionAt: 'gsVersion') .
	self installRowan
		ifTrue: [
			self logMessage: 'Moving active Cypress classes from ObsoleteClasses to Globals'.
			self moveCypressClassesToGlobals: self cypressClassNames.
			self logMessage: 'Installing RowanV12.gs'.
			(RwSemanticVersionNumber fromString: Rowan versionString) = (RwSemanticVersionNumber fromString: '1.2.13')
				ifFalse: [ self error: 'expected to be upgrading Rowan v1.2.13' ].
			GsFileIn fromServerPath: self projectsHome, '/Rowan/platforms/gemstone/topaz/upgrade/3.6.2/RowanV12.gs'.
			self logMessage: 'Installed RowanV12.gs'.
			self commit
				ifTrue: [
					System commit.
					self logMessage: 'post install commit' ] ].
	self rowanReload
		ifTrue: [
			self reloadRowan.
			self commit
				ifTrue: [
					System commit.
					self logMessage: 'post rowan reload commit' ] ].
	self customerReload
		ifTrue: [
			self reloadCustomer.
			self commit
				ifTrue: [
					System commit.
					self logMessage: 'post customer reload commit' ] ].
	(self audit or: [ self rowanRepair or: [ self customerRepair ] ])
		ifTrue: [
			audit := self auditForProjectsNamed: self projectNames.
			self countAuditErrors.
			self rowanRepair
				ifTrue: [
					self logMessage: ' repair ROWAN audit failures'.
					audit isEmpty
						ifFalse: [
							self repairAuditFailures.
							self commit
								ifTrue: [
									System commit.
									self logMessage: 'post audit/repair commit' ] ] ]
				ifFalse: [
					self customerRepair
						ifTrue: [
							self logMessage: ' repair CUSTOMER audit failures'.
							audit isEmpty
								ifFalse: [
									self repairAuditFailures.
									self commit
										ifTrue: [
											System commit.
											self logMessage: 'post audit/repair commit' ]  ] ]
						ifFalse: [
							self logMessage: ' full audit'.
							audit isEmpty
								ifFalse: [
									"just summarize audit failures for report"
									self repairAuditFailures ] ] ] ].
	self logMessage: 'Audit errors encountered:'.
	self errorMessages asSet asArray do: [:message |
		self logMessage: '	', message , '(seen ', (errorMessages occurrencesOf: message) printString, ' times)'].
	self logMessage: '---'.
	self logMessage: 'Repaired ', self repairedCount printString, ' audit failures'.
	self logMessage: 'Repaired ', self repairedByReload printString, ' by RELOAD audit failures'.
	self logMessage: 'Skipped ', self skipCount printString, ' audit repairs'.
	^ 'success'
%
