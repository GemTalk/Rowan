! Class Declarations
! Generated file, do not Edit

doit
(Error
	subclass: 'CypressError'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressError
removeallclassmethods CypressError

doit
(Error
	subclass: 'CypressJsonError'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressJsonError
removeallclassmethods CypressJsonError

doit
(Error
	subclass: 'CypressLoaderError'
	instVarNames: #( exception patchOperation )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

CypressLoaderError is used to report a failure applying a specific CypressPatchOperation.
The CypressLoader made a first attempt to apply the Patch Operation and reported a 
CypressLoaderErrorNotification, set aside the Patch Operation, and has retried it after applying
all other Patch Operations.


Instance Variables:

patchOperation:		the CypressPatchOperation that could not be applied.
exception:			the Error which occurred while trying to apply the Patch Operation.
';
		immediateInvariant.
true.
%

removeallmethods CypressLoaderError
removeallclassmethods CypressLoaderError

doit
(Error
	subclass: 'CypressLoaderMissingClasses'
	instVarNames: #( requirementsMap )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressLoaderMissingClasses
removeallclassmethods CypressLoaderMissingClasses

doit
(Error
	subclass: 'TonelParseError'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Tonel-Core';
		comment: 'I''m a parsing error. 
I happen whenever the parsing of a tonel file is broken in someway.';
		immediateInvariant.
true.
%

removeallmethods TonelParseError
removeallclassmethods TonelParseError

doit
(Magnitude
	indexableSubclass: 'RwGemStoneVersionNumber'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		comment: '# GemStone version format

GemStone versions are simply an unbounded collection of $. separated positive integers.';
		immediateInvariant.
true.
%

removeallmethods RwGemStoneVersionNumber
removeallclassmethods RwGemStoneVersionNumber

doit
(Magnitude
	subclass: 'RwSemanticVersionNumber'
	instVarNames: #( normalVersion preReleaseVersion buildVersion )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		comment: 'RwSemanticVersionNumber conforms to version 2.0.0 of  [Semantic Versioning 2.0.0](http://semver.org/)

**Semantic Versioning Specification** extracted from [Semantic versioning 2.0.0](https://raw.githubusercontent.com/semver/semver/347f73f880ebe1de61891832bf8702e864ca0998/semver.md):

Semantic Versioning 2.0.0
==============================

Summary
-------

Given a version number MAJOR.MINOR.PATCH, increment the:

1. MAJOR version when you make incompatible API changes,
1. MINOR version when you add functionality in a backwards-compatible
   manner, and
1. PATCH version when you make backwards-compatible bug fixes.

Additional labels for pre-release and build metadata are available as extensions
to the MAJOR.MINOR.PATCH format.

Introduction
------------

In the world of software management there exists a dreaded place called
"dependency hell." The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.

As a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
These rules are based on but not necessarily limited to pre-existing
widespread common practices in use in both closed and open-source software.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.

I call this system "Semantic Versioning." Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.


Semantic Versioning Specification (SemVer)
------------------------------------------

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be
interpreted as described in [RFC 2119](http://tools.ietf.org/html/rfc2119).

1. Software using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.

1. A normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.

1. Once a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.

1. Major version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.

1. Version 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.

1. Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.

1. Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.

1. Major version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.

1. A pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphen
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.

1. Build metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.

1. Precedence refers to how versions are compared to each other when ordered.
Precedence MUST be calculated by separating the version into major, minor, patch
and pre-release identifiers in that order (Build metadata does not figure
into precedence). Precedence is determined by the first difference when
comparing each of these identifiers from left to right as follows: Major, minor,
and patch versions are always compared numerically. Example: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. When major, minor, and patch are equal, a pre-release version has
lower precedence than a normal version. Example: 1.0.0-alpha < 1.0.0. Precedence
for two pre-release versions with the same major, minor, and patch version MUST
be determined by comparing each dot separated identifier from left to right
until a difference is found as follows: identifiers consisting of only digits
are compared numerically and identifiers with letters or hyphens are compared
lexically in ASCII sort order. Numeric identifiers always have lower precedence
than non-numeric identifiers. A larger set of pre-release fields has a higher
precedence than a smaller set, if all of the preceding identifiers are equal.
Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.

BackusNaur Form Grammar for Valid SemVer Versions
--------------------------------------------------

    <valid semver> ::= <version core>
                     | <version core> "-" <pre-release>
                     | <version core> "+" <build>
                     | <version core> "-" <pre-release> "+" <build>

    <version core> ::= <major> "." <minor> "." <patch>

    <major> ::= <numeric identifier>

    <minor> ::= <numeric identifier>

    <patch> ::= <numeric identifier>

    <pre-release> ::= <dot-separated pre-release identifiers>

    <dot-separated pre-release identifiers> ::= <pre-release identifier>
                                              | <pre-release identifier> "." <dot-separated pre-release identifiers>

    <build> ::= <dot-separated build identifiers>

    <dot-separated build identifiers> ::= <build identifier>
                                        | <build identifier> "." <dot-separated build identifiers>

    <pre-release identifier> ::= <alphanumeric identifier>
                               | <numeric identifier>

    <build identifier> ::= <alphanumeric identifier>
                         | <digits>

    <alphanumeric identifier> ::= <non-digit>
                                | <non-digit> <identifier characters>
                                | <identifier characters> <non-digit>
                                | <identifier characters> <non-digit> <identifier characters>

    <numeric identifier> ::= "0"
                           | <positive digit>
                           | <positive digit> <digits>

    <identifier characters> ::= <identifier character>
                              | <identifier character> <identifier characters>

    <identifier character> ::= <digit>
                             | <non-digit>

    <non-digit> ::= <letter>
                  | "-"

    <digits> ::= <digit>
               | <digit> <digits>

    <digit> ::= "0"
              | <positive digit>

    <positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

    <letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
               | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
               | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
               | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
               | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
               | "y" | "z"


Why Use Semantic Versioning?
----------------------------

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that "close" isn''t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called "Firetruck." It requires a
Semantically Versioned package named "Ladder." At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there''s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.


FAQ
---

### How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

### How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you''re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.

### Doesn''t this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you''re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.

### If even the tiniest backwards incompatible changes to the public API require a major version bump, won''t I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you''ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

### Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that''s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

### What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you''ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it''s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

### What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it''s obviously a minor level increment.

### What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

### How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.

### Does SemVer have a size limit on the version string?

No, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.

### Is "v1.2.3" a semantic version?

No, "v1.2.3" is not a semantic version. However, prefixing a semantic version
with a "v" is a common way (in English) to indicate it is a version number.
Abbreviating "version" as "v" is often seen with version control. Example:
`git tag v1.2.3 -m "Release version 1.2.3"`, in which case "v1.2.3" is a tag
name and the semantic version is "1.2.3".


About
-----

The Semantic Versioning specification is authored by [Tom
Preston-Werner](http://tom.preston-werner.com), inventor of Gravatar and
cofounder of GitHub.

If you''d like to leave feedback, please [open an issue on
GitHub](https://github.com/mojombo/semver/issues).


License
-------

Creative Commons - CC BY 3.0
http://creativecommons.org/licenses/by/3.0/';
		immediateInvariant.
true.
%

removeallmethods RwSemanticVersionNumber
removeallclassmethods RwSemanticVersionNumber

doit
(Notification
	subclass: 'CypressLoaderErrorNotification'
	instVarNames: #( exception patchOperation )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

CypressLoaderErrorNotification is used to notify a consumer of the CypressLoader that a particular CypressPatchOperation failed.
As a Notification, it resumes by default, logging the error to the Transcript.


Instance Variables:

patchOperation:		the CypressPatchOperation that could not be applied.
exception:			the Error which occurred while trying to apply the Patch Operation.
';
		immediateInvariant.
true.
%

removeallmethods CypressLoaderErrorNotification
removeallclassmethods CypressLoaderErrorNotification

doit
(Notification
	subclass: 'GsInteractionRequest'
	instVarNames: #( interaction )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsInteractionRequest
removeallclassmethods GsInteractionRequest

doit
(Notification
	subclass: 'RwNotification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'General way for Cypress to toss things up the stack for consideration by a higher authority.';
		immediateInvariant.
true.
%

removeallmethods RwNotification
removeallclassmethods RwNotification

doit
(RwNotification
	subclass: 'RwAddUpdateRemoveMethodForUnpackagedClassNotification'
	instVarNames: #( errorMessage )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwAddUpdateRemoveMethodForUnpackagedClassNotification
removeallclassmethods RwAddUpdateRemoveMethodForUnpackagedClassNotification

doit
(RwNotification
	subclass: 'RwDeleteClassFromSystemNotification'
	instVarNames: #( candidateClass )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwDeleteClassFromSystemNotification
removeallclassmethods RwDeleteClassFromSystemNotification

doit
(RwNotification
	subclass: 'RwExecuteClassInitializeMethodsAfterLoadNotification'
	instVarNames: #( candidateClass )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExecuteClassInitializeMethodsAfterLoadNotification
removeallclassmethods RwExecuteClassInitializeMethodsAfterLoadNotification

doit
(RwNotification
	subclass: 'RwExistingAssociationWithSameKeyNotification'
	instVarNames: #( errorMessage )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExistingAssociationWithSameKeyNotification
removeallclassmethods RwExistingAssociationWithSameKeyNotification

doit
(RwNotification
	subclass: 'RwExistingVisitorAddingExistingClassNotification'
	instVarNames: #( classDefinition loadedProject )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExistingVisitorAddingExistingClassNotification
removeallclassmethods RwExistingVisitorAddingExistingClassNotification

doit
(RwNotification
	subclass: 'RwPerformingUnpackagedEditNotification'
	instVarNames: #( informMessage )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwPerformingUnpackagedEditNotification
removeallclassmethods RwPerformingUnpackagedEditNotification

doit
(Notification
	subclass: 'TonelShouldIgnore'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Tonel-Core';
		comment: 'I''m a notification to say tonel writer that he should ignore a section. 
This tipically happens on a MCClassTraitDefinition, because it will be managed on MCTraitDefinition.

(see TonelWriter>>typeOf:)';
		immediateInvariant.
true.
%

removeallmethods TonelShouldIgnore
removeallclassmethods TonelShouldIgnore

doit
(Object
	subclass: 'CypressAbstractPackageFiler'
	instVarNames: #( repository packageDirectory packageStructure )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractPackageFiler
removeallclassmethods CypressAbstractPackageFiler

doit
(CypressAbstractPackageFiler
	subclass: 'CypressAbstractFileoutWriter'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractFileoutWriter
removeallclassmethods CypressAbstractFileoutWriter

doit
(CypressAbstractFileoutWriter
	subclass: 'CypressSmalltalkFileoutWriter'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressSmalltalkFileoutWriter
removeallclassmethods CypressSmalltalkFileoutWriter

doit
(CypressAbstractFileoutWriter
	subclass: 'CypressTopazFileoutWriter'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressTopazFileoutWriter
removeallclassmethods CypressTopazFileoutWriter

doit
(CypressAbstractPackageFiler
	subclass: 'CypressAbstractPackageReader'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractPackageReader
removeallclassmethods CypressAbstractPackageReader

doit
(CypressAbstractPackageReader
	subclass: 'CypressDoNothingPackageReader'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressDoNothingPackageReader
removeallclassmethods CypressDoNothingPackageReader

doit
(CypressAbstractPackageReader
	subclass: 'CypressFileTreeFormatPackageReader'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileTreeFormatPackageReader
removeallclassmethods CypressFileTreeFormatPackageReader

doit
(CypressAbstractPackageReader
	subclass: 'CypressFlexiblePackageReader'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFlexiblePackageReader
removeallclassmethods CypressFlexiblePackageReader

doit
(CypressAbstractPackageReader
	subclass: 'CypressPackageReader'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageReader
removeallclassmethods CypressPackageReader

doit
(CypressAbstractPackageFiler
	subclass: 'CypressAbstractPackageWriter'
	instVarNames: #()
	classVars: #()
	classInstVars: #( specials )
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractPackageWriter
removeallclassmethods CypressAbstractPackageWriter

doit
(CypressAbstractPackageWriter
	subclass: 'CypressFileTreeFormatPackageWriter'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileTreeFormatPackageWriter
removeallclassmethods CypressFileTreeFormatPackageWriter

doit
(CypressAbstractPackageWriter
	subclass: 'CypressPackageWriter'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageWriter
removeallclassmethods CypressPackageWriter

doit
(CypressAbstractPackageWriter
	subclass: 'CypressStrictFileTreeFormatDoNothingPackageWriter'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressStrictFileTreeFormatDoNothingPackageWriter
removeallclassmethods CypressStrictFileTreeFormatDoNothingPackageWriter

doit
(CypressAbstractPackageWriter
	subclass: 'TonelCypressWriter'
	instVarNames: #( snapshot sourceDir packageDir writer )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'CypressTonel-Core';
		comment: 'I''m a writer for tonel format';
		immediateInvariant.
true.
%

removeallmethods TonelCypressWriter
removeallclassmethods TonelCypressWriter

doit
(CypressAbstractPackageFiler
	subclass: 'TonelCypressReader'
	instVarNames: #( packageName definitions directoryPath )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'CypressTonel-Core';
		comment: 'I''m a reader for tonel format.';
		immediateInvariant.
true.
%

removeallmethods TonelCypressReader
removeallclassmethods TonelCypressReader

doit
(Object
	subclass: 'CypressAbstractRepository'
	instVarNames: #( url properties readerClass writerClass )
	classVars: #( DefaultCopyrightNotice )
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractRepository
removeallclassmethods CypressAbstractRepository

doit
(CypressAbstractRepository
	subclass: 'CypressAbstractFileoutRepository'
	instVarNames: #( directoryPath )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractFileoutRepository
removeallclassmethods CypressAbstractFileoutRepository

doit
(CypressAbstractFileoutRepository
	subclass: 'CypressSmalltalkRepository'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

This is a "write-only" repository.
It could be made readable, to be able to file-in Smalltalk scripts, but it''s not the same thing.
';
		immediateInvariant.
true.
%

removeallmethods CypressSmalltalkRepository
removeallclassmethods CypressSmalltalkRepository

doit
(CypressAbstractFileoutRepository
	subclass: 'CypressTopazRepository'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

This is a "write-only" repository.
It could be made readable, to be able to file-in Topaz scripts, but it''s not the same thing.
';
		immediateInvariant.
true.
%

removeallmethods CypressTopazRepository
removeallclassmethods CypressTopazRepository

doit
(CypressAbstractRepository
	subclass: 'CypressDictionaryRepository'
	instVarNames: #( dictionary )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressDictionaryRepository
removeallclassmethods CypressDictionaryRepository

doit
(CypressAbstractRepository
	subclass: 'CypressFileSystemRepository'
	instVarNames: #( directoryPath )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileSystemRepository
removeallclassmethods CypressFileSystemRepository

doit
(CypressFileSystemRepository
	subclass: 'CypressFileSystemGitRepository'
	instVarNames: #( remoteUrl )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileSystemGitRepository
removeallclassmethods CypressFileSystemGitRepository

doit
(CypressFileSystemRepository
	subclass: 'CypressTonelRepository'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'CypressTonel-Core';
		comment: 'No class-specific documentation for CypressTonelRepository, hierarchy is: 
Object
  CypressAbstractRepository( url properties readerClass writerClass)
    CypressFileSystemRepository( directoryPath)
      CypressTonelRepository
';
		immediateInvariant.
true.
%

removeallmethods CypressTonelRepository
removeallclassmethods CypressTonelRepository

doit
(Object
	subclass: 'CypressFileUtilities'
	instVarNames: #()
	classVars: #( Current )
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileUtilities
removeallclassmethods CypressFileUtilities

doit
(CypressFileUtilities
	subclass: 'CypressGemStoneDirectoryUtilities'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-GemStoneFileServer';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressGemStoneDirectoryUtilities
removeallclassmethods CypressGemStoneDirectoryUtilities

doit
(Object
	subclass: 'CypressGsGeneralDependencySorter'
	instVarNames: #( candidates dependsOnConverter dependentConverter individualDependencyMap dependencyGraphs candidateAliasMap )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressGsGeneralDependencySorter
removeallclassmethods CypressGsGeneralDependencySorter

doit
(Object
	subclass: 'CypressJsonParser'
	instVarNames: #( stream )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressJsonParser
removeallclassmethods CypressJsonParser

doit
(Object
	subclass: 'CypressObject'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressObject
removeallclassmethods CypressObject

doit
(CypressObject
	subclass: 'CypressAbstractPackageInformation'
	instVarNames: #( name )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractPackageInformation
removeallclassmethods CypressAbstractPackageInformation

doit
(CypressAbstractPackageInformation
	subclass: 'CypressConflictingPackageInformation'
	instVarNames: #( conflictsWith )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressConflictingPackageInformation
removeallclassmethods CypressConflictingPackageInformation

doit
(CypressAbstractPackageInformation
	subclass: 'CypressEclipsedPackageInformation'
	instVarNames: #( eclipsedBy )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressEclipsedPackageInformation
removeallclassmethods CypressEclipsedPackageInformation

doit
(CypressAbstractPackageInformation
	subclass: 'CypressKnownPackageInformation'
	instVarNames: #( repositories digests )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressKnownPackageInformation
removeallclassmethods CypressKnownPackageInformation

doit
(CypressAbstractPackageInformation
	subclass: 'CypressUnknownPackageInformation'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressUnknownPackageInformation
removeallclassmethods CypressUnknownPackageInformation

doit
(CypressObject
	subclass: 'CypressDefinition'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressDefinition
removeallclassmethods CypressDefinition

doit
(CypressDefinition
	subclass: 'CypressClassDefinition'
	instVarNames: #( category classInstVarNames classVarNames comment defaultSymbolDictionaryName instVarNames name poolDictionaryNames subclassType superclassName gs_options gs_constraints )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressClassDefinition
removeallclassmethods CypressClassDefinition

doit
(CypressDefinition
	subclass: 'CypressMethodDefinition'
	instVarNames: #( category classIsMeta className selector source )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressMethodDefinition
removeallclassmethods CypressMethodDefinition

doit
(CypressMethodDefinition
	subclass: 'RwCypressMethodDefinition'
	instVarNames: #( isExtensionMethod )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Cypress-Core';
		immediateInvariant.
true.
%

removeallmethods RwCypressMethodDefinition
removeallclassmethods RwCypressMethodDefinition

doit
(CypressObject
	subclass: 'CypressDefinitionIndex'
	instVarNames: #( definitionMap )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressDefinitionIndex
removeallclassmethods CypressDefinitionIndex

doit
(CypressObject
	subclass: 'CypressDependencySorter'
	instVarNames: #( orderedItems provided required )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressDependencySorter
removeallclassmethods CypressDependencySorter

doit
(CypressDependencySorter
	subclass: 'CypressEnvironmentDependencySorter'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Environmental-Tools';
		immediateInvariant.
true.
%

removeallmethods CypressEnvironmentDependencySorter
removeallclassmethods CypressEnvironmentDependencySorter

doit
(CypressObject
	subclass: 'CypressLoader'
	instVarNames: #( additions defaultSymbolDictionaryName errors exceptionClass methodAdditions obsoletions provisions removals requirements unloadable )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressLoader
removeallclassmethods CypressLoader

doit
(CypressLoader
	subclass: 'CypressEnvironmentLoader'
	instVarNames: #( defaultEnvironmentId lookupSymbolList compilationSymbolList )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Environmental-Tools';
		immediateInvariant.
true.
%

removeallmethods CypressEnvironmentLoader
removeallclassmethods CypressEnvironmentLoader

doit
(CypressObject
	subclass: 'CypressPackageDefinition'
	instVarNames: #( name )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageDefinition
removeallclassmethods CypressPackageDefinition

doit
(CypressPackageDefinition
	subclass: 'CypressEnvironmentPackageDefinition'
	instVarNames: #( lookupSymbolList )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Environmental-Tools';
		comment: 'No class-specific documentation for CypressEnvironmentPackageDefinition, hierarchy is: 
Object
  CypressObject
    CypressPackageDefinition( name)
      CypressEnvironmentPackageDefinition( lookupSymbolList)
';
		immediateInvariant.
true.
%

removeallmethods CypressEnvironmentPackageDefinition
removeallclassmethods CypressEnvironmentPackageDefinition

doit
(CypressObject
	subclass: 'CypressPackageInformation'
	instVarNames: #( name type advice competingPackageNames imageDefinitions savedDefinitions savedLocation repository repositoryDescription imageCounts changesCount )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

CypressPackageInformation documents potential and actual packages for the Cypress Package Manager. 

Candidate package names come from class categories and from method categories beginning with an asterisk. Category names may contain more information than just the package name, such as logical subdivisions within a package or method categorization in addition to the package name. For example, a Package might be named X or Y-Z or whatever. Classes could be categorized as X, Y-Z, X-A, or Y-Z-A, and methods could be categorized as *X, *Y-Z, *X-A, *Y-Z-A, etc. (The various letters X, Y, Z, and A can represent almost any sequence of characters, in either uppercase, lowercase, or both. Package names are case-insensitive.)

There are four types of CypressPackageInformation objects:
 - Known Package - those which are known to represent real packages (e.g., Y-Z). In general, it is because there is a savedLocation specified.
 - Qualified Name - the name is a Known Package name qualified by further details, and cannot be used to represent a Known Package (e.g., X-accessing).
 - Conflicted Name - the name is a prefix of a Known Package name (e.g. given a Known Package named Y-Z, there can be no package named Y).
 - Unknown - the name could represent a package, but it is not known to do so.

Instance Variables
	advice	<String>	Additional information about the type of the instance, usually used only for Qualified Names and Conflcited Names.
	changesCount	<Integer>	The number of differences between the in-image definitions of the package and the definitions previously saved to disk.
	competingPackageNames	<String>*	0 or more strings naming packages in competition with this one.
	imageCounts	<Integer pair>	The number of classes and the number of methods in the image for the package.
	name	<String>	The name of the package or potential package.
	savedLocation	<String>	The path to the directory in which the package was or should be saved, with a trailing slash (e.g., /usr/src/project/).
	type	<String>	One of ''Known Package'', ''Qualified Name'', ''Conflicted Name'', and ''Unknown''.
	imageDefinitions	<CypressDefinition>*	0 or more definitions from the image.
	savedDefinitions	<CypressDefinition>*	0 or more definitions from the savedLocation storage.

';
		immediateInvariant.
true.
%

removeallmethods CypressPackageInformation
removeallclassmethods CypressPackageInformation

doit
(CypressObject
	subclass: 'CypressPatch'
	instVarNames: #( operations )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPatch
removeallclassmethods CypressPatch

doit
(CypressObject
	subclass: 'CypressPatchOperation'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPatchOperation
removeallclassmethods CypressPatchOperation

doit
(CypressPatchOperation
	subclass: 'CypressAddition'
	instVarNames: #( definition )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAddition
removeallclassmethods CypressAddition

doit
(CypressPatchOperation
	subclass: 'CypressModification'
	instVarNames: #( modification obsoletion )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressModification
removeallclassmethods CypressModification

doit
(CypressPatchOperation
	subclass: 'CypressRemoval'
	instVarNames: #( definition )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressRemoval
removeallclassmethods CypressRemoval

doit
(CypressObject
	subclass: 'CypressSnapshot'
	instVarNames: #( definitions )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Definitions';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressSnapshot
removeallclassmethods CypressSnapshot

doit
(CypressObject
	subclass: 'CypressStructure'
	instVarNames: #( name properties packageStructure )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressStructure
removeallclassmethods CypressStructure

doit
(CypressStructure
	subclass: 'CypressClassStructure'
	instVarNames: #( instanceMethods classMethods comment isClassExtension )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressClassStructure
removeallclassmethods CypressClassStructure

doit
(CypressStructure
	subclass: 'CypressMethodStructure'
	instVarNames: #( source isMetaclass classStructure )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressMethodStructure
removeallclassmethods CypressMethodStructure

doit
(CypressMethodStructure
	subclass: 'RwCypressMethodStructure'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Cypress-Core';
		immediateInvariant.
true.
%

removeallmethods RwCypressMethodStructure
removeallclassmethods RwCypressMethodStructure

doit
(CypressStructure
	subclass: 'CypressPackageStructure'
	instVarNames: #( classes extensions )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Structure';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageStructure
removeallclassmethods CypressPackageStructure

doit
(CypressPackageStructure
	subclass: 'RwCypressPackageStructure'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Cypress-Core';
		immediateInvariant.
true.
%

removeallmethods RwCypressPackageStructure
removeallclassmethods RwCypressPackageStructure

doit
(Object
	subclass: 'CypressPackageComparator'
	instVarNames: #( directoryPackageMap diskTimestamps diskSnapshots imageSnapshots snapshotDifferences currentPackageName currentAdditions currentRemovals )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Comparison';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageComparator
removeallclassmethods CypressPackageComparator

doit
(Object
	subclass: 'CypressPackageManager'
	instVarNames: #( knownPackages knownRepositories packageInformationList )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageManager
removeallclassmethods CypressPackageManager

doit
(Object
	subclass: 'CypressPackageManager2'
	instVarNames: #( knownRepositories packageInformationList )
	classVars: #( SavedPackageManagers )
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageManager2
removeallclassmethods CypressPackageManager2

doit
(Object
	subclass: 'CypressPackageManager3'
	instVarNames: #( knownRepositories defaultSymbolDictionaryName resolvedPackageReferences )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageManager3
removeallclassmethods CypressPackageManager3

doit
(CypressPackageManager3
	subclass: 'CypressEnvironmentPackageManager'
	instVarNames: #( defaultSymbolList lookupSymbolList compilationSymbolList defaultEnvironmentId )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Environmental-Tools';
		immediateInvariant.
true.
%

removeallmethods CypressEnvironmentPackageManager
removeallclassmethods CypressEnvironmentPackageManager

doit
(Object
	subclass: 'CypressPackageStringComparator'
	instVarNames: #( directoryPackageMap diskTimestamps diskSnapshots imageSnapshots snapshotDifferences currentPackageName currentOperations )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Comparison';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageStringComparator
removeallclassmethods CypressPackageStringComparator

doit
(Object
	subclass: 'CypressReference'
	instVarNames: #( name )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A CypressReference is an abstract superclass for various kinds of references to Cypress packages. Inspired by GoferReference in Pharo';
		immediateInvariant.
true.
%

removeallmethods CypressReference
removeallclassmethods CypressReference

doit
(CypressReference
	subclass: 'CypressPackageReference'
	instVarNames: #( package branch )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A CypressPackageReference refers to a specific Cypress package.';
		immediateInvariant.
true.
%

removeallmethods CypressPackageReference
removeallclassmethods CypressPackageReference

doit
(CypressPackageReference
	subclass: 'CypressResolvedReference'
	instVarNames: #( repository )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A CypressResolvedReference refers to a specific Cypress package in a repository. This class is the only one that can actually load a package, because it is the only one knowing where to find it.';
		immediateInvariant.
true.
%

removeallmethods CypressResolvedReference
removeallclassmethods CypressResolvedReference

doit
(Object
	subclass: 'CypressUrl'
	instVarNames: #( fragment )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.';
		immediateInvariant.
true.
%

removeallmethods CypressUrl
removeallclassmethods CypressUrl

doit
(CypressUrl
	subclass: 'CypressFileUrl'
	instVarNames: #( host path isAbsolute )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

This class models a file URL according to (somewhat) RFC1738, see http://www.w3.org/Addressing/rfc1738.txt

Here is the relevant part of the RFC:

3.10 FILES

   The file URL scheme is used to designate files accessible on a
   particular host computer. This scheme, unlike most other URL schemes,
   does not designate a resource that is universally accessible over the
   Internet.

   A file URL takes the form:

       file://<host>/<path>

   where <host> is the fully qualified domain name of the system on
   which the <path> is accessible, and <path> is a hierarchical
   directory path of the form <directory>/<directory>/.../<name>.

   For example, a VMS file

     DISK$USER:[MY.NOTES]NOTE123456.TXT

   might become

     <URL:file://vms.host.edu/disk$user/my/notes/note12345.txt>

   As a special case, <host> can be the string "localhost" or the empty
   string; this is interpreted as `the machine from which the URL is
   being interpreted''.

   The file URL scheme is unusual in that it does not specify an
   Internet protocol or access method for such files; as such, its
   utility in network protocols between hosts is limited.

From the above we can conclude that the RFC says that the <path> part never starts or ends with a slash and is always absolute. If the last name can be a directory instead of a file is not specified clearly.

The path is stored as a SequenceableCollection of path parts.

Notes regarding non RFC features in this class:

- If the last path part is the empty string, then the FileUrl is referring to a directory. This is also shown with a trailing slash when converted to a String.

- The FileUrl has an attribute isAbsolute which signals if the path should be considered absolute or relative to the current directory. This distinction is not visible in the String representation of FileUrl, since the RFC does not have that.

- Fragment is supported (kept for historical reasons)

';
		immediateInvariant.
true.
%

removeallmethods CypressFileUrl
removeallclassmethods CypressFileUrl

doit
(CypressFileUrl
	subclass: 'CypressAbstractFileUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressAbstractFileUrl
removeallclassmethods CypressAbstractFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressCypressFileUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressCypressFileUrl
removeallclassmethods CypressCypressFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressFileTreeFormatFileUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileTreeFormatFileUrl
removeallclassmethods CypressFileTreeFormatFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressFileTreeReadOnlyFileUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFileTreeReadOnlyFileUrl
removeallclassmethods CypressFileTreeReadOnlyFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressGitFileUrl'
	instVarNames: #( projectPath projectBranchOrTag repositoryPath )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressGitFileUrl
removeallclassmethods CypressGitFileUrl

doit
(CypressGitFileUrl
	subclass: 'CypressGitFileTreeUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressGitFileTreeUrl
removeallclassmethods CypressGitFileTreeUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressLaxFileUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressLaxFileUrl
removeallclassmethods CypressLaxFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressSmalltalkUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressSmalltalkUrl
removeallclassmethods CypressSmalltalkUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressTonelFileUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'CypressTonel-Core';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressTonelFileUrl
removeallclassmethods CypressTonelFileUrl

doit
(CypressAbstractFileUrl
	subclass: 'CypressTopazUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressTopazUrl
removeallclassmethods CypressTopazUrl

doit
(CypressUrl
	subclass: 'CypressGenericUrl'
	instVarNames: #( schemeName locator )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

a URL type that can''t be broken down in any systematic way.  For example, mailto: and telnet: URLs.  The part after the scheme name is stored available via the #locator message.';
		immediateInvariant.
true.
%

removeallmethods CypressGenericUrl
removeallclassmethods CypressGenericUrl

doit
(CypressGenericUrl
	subclass: 'CypressBrowserUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

URLs that instruct a browser to do something.';
		immediateInvariant.
true.
%

removeallmethods CypressBrowserUrl
removeallclassmethods CypressBrowserUrl

doit
(CypressGenericUrl
	subclass: 'CypressMailtoUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

a URL specifying a mailing address; activating it triggers a mail-sender to start up, if one is present.';
		immediateInvariant.
true.
%

removeallmethods CypressMailtoUrl
removeallclassmethods CypressMailtoUrl

doit
(CypressUrl
	subclass: 'CypressHierarchicalUrl'
	instVarNames: #( schemeName authority path query port username password )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A URL which has a hierarchical encoding.  For instance, http and ftp URLs are hierarchical.';
		immediateInvariant.
true.
%

removeallmethods CypressHierarchicalUrl
removeallclassmethods CypressHierarchicalUrl

doit
(CypressHierarchicalUrl
	subclass: 'CypressFtpUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressFtpUrl
removeallclassmethods CypressFtpUrl

doit
(CypressHierarchicalUrl
	subclass: 'CypressHttpUrl'
	instVarNames: #( realm )
	classVars: #( Passwords )
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A URL that can be accessed via the Hypertext Transfer Protocol (HTTP), ie, a standard Web URL

realm = the name of the security realm that has been discovered for this URL.   Look it up in Passwords.

Passwords = a Dictionary of (realm -> encoded user&password)


TODO: use the username and password, if specified
';
		immediateInvariant.
true.
%

removeallmethods CypressHttpUrl
removeallclassmethods CypressHttpUrl

doit
(CypressHttpUrl
	subclass: 'CypressHttpsUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-Network-Url';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressHttpsUrl
removeallclassmethods CypressHttpsUrl

doit
(Object
	subclass: 'CypressVersionReference'
	instVarNames: #( name package author branch versionNumber )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-PackageManagement';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.

A CypressVersionReference refers to a specific version of a Monticello package.';
		immediateInvariant.
true.
%

removeallmethods CypressVersionReference
removeallclassmethods CypressVersionReference

doit
(Object
	subclass: 'GsInteraction'
	instVarNames: #( defaultActionBlock )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsInteraction
removeallclassmethods GsInteraction

doit
(GsInteraction
	subclass: 'GsChoiceInteraction'
	instVarNames: #( prompt labels values lines )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsChoiceInteraction
removeallclassmethods GsChoiceInteraction

doit
(GsInteraction
	subclass: 'GsConfirmInteraction'
	instVarNames: #( prompt confirm cancel abort )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsConfirmInteraction
removeallclassmethods GsConfirmInteraction

doit
(GsConfirmInteraction
	subclass: 'GsNotifyInteraction'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsNotifyInteraction
removeallclassmethods GsNotifyInteraction

doit
(GsInteraction
	subclass: 'GsInformInteraction'
	instVarNames: #( message )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsInformInteraction
removeallclassmethods GsInformInteraction

doit
(GsInteraction
	subclass: 'GsInspectInteraction'
	instVarNames: #( theObject )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsInspectInteraction
removeallclassmethods GsInspectInteraction

doit
(GsInspectInteraction
	subclass: 'GsExploreInteraction'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsExploreInteraction
removeallclassmethods GsExploreInteraction

doit
(GsInteraction
	subclass: 'GsTextInteraction'
	instVarNames: #( prompt template requestPassword )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsTextInteraction
removeallclassmethods GsTextInteraction

doit
(GsTextInteraction
	subclass: 'GsMultiLineTextInteraction'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsMultiLineTextInteraction
removeallclassmethods GsMultiLineTextInteraction

doit
(Object
	subclass: 'GsInteractionHandler'
	instVarNames: #( choiceBlock confirmBlock informBlock textBlock multiLineTextBlock defaultBlock inspectBlock )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'GemStone-Interactions-Core';
		immediateInvariant.
true.
%

removeallmethods GsInteractionHandler
removeallclassmethods GsInteractionHandler

doit
(Object
	subclass: 'GsTonelOrderedDictionary'
	instVarNames: #( size keys values )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Tonel-GemStoneCommon-Core';
		comment: 'I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating. My implementation features some ideas from the RefactoringBrowser.';
		immediateInvariant.
true.
%

removeallmethods GsTonelOrderedDictionary
removeallclassmethods GsTonelOrderedDictionary

doit
(Object
	subclass: 'JadeServer'
	instVarNames: #( classList classOrganizers readStream writeStream selectedClass methodFilterType methodFilters selections methodCommandResult )
	classVars: #( ExternalInteger GciError GsObject OopType32 OopType64 )
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer
removeallclassmethods JadeServer

doit
(JadeServer
	subclass: 'JadeServer64bit'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer64bit
removeallclassmethods JadeServer64bit

doit
(JadeServer64bit
	subclass: 'JadeServer64bit24'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer64bit24
removeallclassmethods JadeServer64bit24

doit
(JadeServer64bit24
	subclass: 'JadeServer64bit3x'
	instVarNames: #( environment )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer64bit3x
removeallclassmethods JadeServer64bit3x

doit
(JadeServer64bit3x
	subclass: 'JadeServer64bit32'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer64bit32
removeallclassmethods JadeServer64bit32

doit
(JadeServer64bit32
	subclass: 'JadeServer64bit35'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: UserGlobals
	options: #( #logCreation )
)
		category: 'Rowan-JadeServer';
		immediateInvariant.
true.
%

removeallmethods JadeServer64bit35
removeallclassmethods JadeServer64bit35

doit
(Object
	subclass: 'RBParser'
	instVarNames: #( scanner currentToken nextToken errorBlock source comments pragmas )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Parser';
		comment: 'RBParser takes a source code string and generates an AST for it. This is a hand-written, recursive descent parser and has been optimized for speed. The simplest way to call this is either ''RBParser parseExpression: aString'' if you want the AST for an expression, or ''RBParser parseMethod: aString'' if you want to parse an entire method.

Instance Variables:
	currentToken	<RBToken>	The current token being processed.
	emptyStatements	<Boolean>	True if empty statements are allowed. In IBM, they are, in VW they aren''t.
	errorBlock	<BlockClosure>	The block to evaluate on a syntax error.
	nextToken	<RBToken>	The next token that will be processed. This allows one-token lookahead.
	scanner	<RBScanner>	The scanner that generates a stream of tokens to parse.
	source	<String>	The source code to parse
	tags	<Collection of: Interval>	The source intervals of the tags appearing at the top of a method (e.g. Primitive calls)

Shared Variables:
	ParserType	<Symbol>	the type code we are parsing';
		immediateInvariant.
true.
%

removeallmethods RBParser
removeallclassmethods RBParser

doit
(RBParser
	subclass: 'RBPatternParser'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Parser';
		comment: 'RBPatternParser is a subclass of RBParser that allows the extended syntax that creates matching trees. These trees can be used by the ParseTreeMatcher to search and transform source code.
';
		immediateInvariant.
true.
%

removeallmethods RBPatternParser
removeallclassmethods RBPatternParser

doit
(Object
	subclass: 'RBParseTreeRule'
	instVarNames: #( searchTree owner )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Matching';
		comment: 'RBParseTreeRule is the abstract superclass of all of the parse tree searching rules. A parse tree rule is the first class representation of a particular rule to search for. The owner of a rule is the algorithm that actually executes the search. This arrangement allows multiple searches to be conducted by a single Searcher.

Instance Variables:
	owner	<ParseTreeSearcher>	The searcher that is actually performing the search.
	searchTree	<RBProgramNode>	The parse tree to be searched.

';
		immediateInvariant.
true.
%

removeallmethods RBParseTreeRule
removeallclassmethods RBParseTreeRule

doit
(RBParseTreeRule
	subclass: 'RBReplaceRule'
	instVarNames: #( verificationBlock )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Matching';
		comment: 'RBReplaceRule is the abstract superclass of all of the transforming rules. The rules change the source code by replacing the node that matches the rule. Subclasses implement different strategies for this replacement.

Subclasses must implement the following messages:
	matching
		foundMatchFor:

Instance Variables:
	verificationBlock	<BlockClosure>	Is evaluated with the matching node. This allows for further verification of a match beyond simple tree matching.

';
		immediateInvariant.
true.
%

removeallmethods RBReplaceRule
removeallclassmethods RBReplaceRule

doit
(RBReplaceRule
	subclass: 'RBBlockReplaceRule'
	instVarNames: #( replaceBlock )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Matching';
		comment: 'RBBlockReplaceRule replaces the matching node by the result of evaluating replaceBlock. This allows arbitrary computation to come up with a replacement.

Instance Variables:
	replaceBlock	<BlockClosure>	The block that returns the node to replace to matching node with.
';
		immediateInvariant.
true.
%

removeallmethods RBBlockReplaceRule
removeallclassmethods RBBlockReplaceRule

doit
(RBReplaceRule
	subclass: 'RBStringReplaceRule'
	instVarNames: #( replaceTree )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Matching';
		comment: 'RBStringReplaceRule replaces a matched tree with another tree (which may include metavariable from the matching tree). This is a very succint syntax for specifying most rewrites.

Instance Variables:
	replaceTree	<RBProgramNode>	The tree to replace the matched tree with.

';
		immediateInvariant.
true.
%

removeallmethods RBStringReplaceRule
removeallclassmethods RBStringReplaceRule

doit
(RBParseTreeRule
	subclass: 'RBSearchRule'
	instVarNames: #( answerBlock )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Matching';
		comment: 'RBSearchRule is a parse tree rule that simply searches for matches to the rule. Every time a match is found, answerBlock is evaluated with the node that matches and the cureent answer. This two-argument approach allows a collection to be formed from all of the matches (Think inject:into:).

Instance Variables:
	answerBlock	<BlockClosure>	Block to evaluate with the matching node and the current answer.

';
		immediateInvariant.
true.
%

removeallmethods RBSearchRule
removeallclassmethods RBSearchRule

doit
(Object
	subclass: 'RBProgramNode'
	instVarNames: #( parent comments properties )
	classVars: #( FormatterClass )
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBProgramNode is an abstract class that represents an abstract syntax tree node in a Smalltalk program.

Subclasses must implement the following messages:
	accessing
		start
		stop
	visitor
		acceptVisitor:

The #start and #stop methods are used to find the source that corresponds to this node. "source copyFrom: self start to: self stop" should return the source for this node.

The #acceptVisitor: method is used by RBProgramNodeVisitors (the visitor pattern). This will also require updating all the RBProgramNodeVisitors so that they know of the new node.

Subclasses might also want to redefine match:inContext: and copyInContext: to do parse tree searching and replacing.

Subclasses that contain other nodes should override equalTo:withMapping: to compare nodes while ignoring renaming temporary variables, and children that returns a collection of our children nodes.

Instance Variables:
	comments	<Collection of: Interval>	the intervals in the source that have comments for this node
	parent	<RBProgramNode>	the node we''re contained in

Shared Variables:
	FormatterClass	<Behavior>	the formatter class that is used when we are formatted';
		immediateInvariant.
true.
%

removeallmethods RBProgramNode
removeallclassmethods RBProgramNode

doit
(RBProgramNode
	subclass: 'RBMethodNode'
	instVarNames: #( selector selectorParts body source arguments pragmas replacements nodeReplacements )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBMethodNode is the AST that represents a Smalltalk method.

Instance Variables:
	arguments	<SequenceableCollection of: RBVariableNode>	the arguments to the method
	body	<BRSequenceNode>	the body/statements of the method
	nodeReplacements	<Dictionary>	a dictionary of oldNode -> newNode replacements
	replacements	<Collection of: RBStringReplacement>	the collection of string replacements for each node replacement in the parse tree
	selector	<Symbol | nil>	the method name (cached)
	selectorParts	<SequenceableCollection of: RBValueToken>	the tokens for the selector keywords
	source	<String>	the source we compiled
	tags	<Collection of: Interval>	the source location of any resource/primitive tags

';
		immediateInvariant.
true.
%

removeallmethods RBMethodNode
removeallclassmethods RBMethodNode

doit
(RBMethodNode
	subclass: 'RBPatternMethodNode'
	instVarNames: #( isList )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Pattern';
		comment: 'RBPatternMethodNode is a RBMethodNode that will match other method nodes without their selectors being equal. 

Instance Variables:
	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)

';
		immediateInvariant.
true.
%

removeallmethods RBPatternMethodNode
removeallclassmethods RBPatternMethodNode

doit
(RBProgramNode
	subclass: 'RBPragmaNode'
	instVarNames: #( selector selectorParts arguments isProtected left right )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBPragmaNode is an AST node that represents a method pragma.

Instance Variables:
	arguments <SequenceableCollection of: RBLiteralNode> our argument nodes
	left <Integer | nil> position of <
	right <Integer | nil> position of >
	selector <Symbol | nil>	the selector we''re sending (cached)
	selectorParts <SequenceableCollection of: RBValueToken> the tokens for each keyword';
		immediateInvariant.
true.
%

removeallmethods RBPragmaNode
removeallclassmethods RBPragmaNode

doit
(RBPragmaNode
	subclass: 'RBPatternPragmaNode'
	instVarNames: #( isList )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Pattern';
		immediateInvariant.
true.
%

removeallmethods RBPatternPragmaNode
removeallclassmethods RBPatternPragmaNode

doit
(RBProgramNode
	subclass: 'RBReturnNode'
	instVarNames: #( return value )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBReturnNode is an AST node that represents a return expression.

Instance Variables:
	return	<Integer>	the position of the ^ character
	value	<RBValueNode>	the value that is being returned

';
		immediateInvariant.
true.
%

removeallmethods RBReturnNode
removeallclassmethods RBReturnNode

doit
(RBProgramNode
	subclass: 'RBSequenceNode'
	instVarNames: #( leftBar rightBar statements periods temporaries )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBSequenceNode is an AST node that represents a sequence of statements. Both RBBlockNodes and RBMethodNodes contain these.

Instance Variables:
	leftBar	<Integer | nil>	the position of the left | in the temporaries definition
	periods	<SequenceableCollection of: Integer>	the positions of all the periods that separate the statements
	rightBar	<Integer | nil>	the position of the right | in the temporaries definition
	statements	<SequenceableCollection of: RBStatementNode>	the statement nodes
	temporaries	<SequenceableCollection of: RBVariableNode>	the temporaries defined

';
		immediateInvariant.
true.
%

removeallmethods RBSequenceNode
removeallclassmethods RBSequenceNode

doit
(RBProgramNode
	subclass: 'RBValueNode'
	instVarNames: #( parentheses )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBValueNode is an abstract class that represents a node that returns some value.

Subclasses must implement the following messages:
	accessing
		startWithoutParentheses
		stopWithoutParentheses
	testing
		needsParenthesis

Instance Variables:
	parentheses	<SequenceableCollection of: Inteval>	the positions of the parethesis around this node. We need a collection of intervals for stupid code such as "((3 + 4))" that has multiple parethesis around the same expression.

';
		immediateInvariant.
true.
%

removeallmethods RBValueNode
removeallclassmethods RBValueNode

doit
(RBValueNode
	subclass: 'RBArrayNode'
	instVarNames: #( left right statements periods )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'A RBArrayNode is an AST node for runtime arrays.

Instance Variables
	left:	 <Integer | nil> position of {
	periods: <SequenceableCollection of: Integer> the positions of all the periods that separate the statements
	right: <Integer | nil> position of }
	statements: <SequenceableCollection of: RBStatementNode> the statement nodes';
		immediateInvariant.
true.
%

removeallmethods RBArrayNode
removeallclassmethods RBArrayNode

doit
(RBValueNode
	subclass: 'RBAssignmentNode'
	instVarNames: #( variable assignment value )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBAssignmentNode is an AST node for assignment statements

Instance Variables:
	assignment	<Integer>	position of the :=
	value	<RBValueNode>	the value that we''re assigning
	variable	<RBVariableNode>	the variable being assigned

';
		immediateInvariant.
true.
%

removeallmethods RBAssignmentNode
removeallclassmethods RBAssignmentNode

doit
(RBValueNode
	subclass: 'RBBlockNode'
	instVarNames: #( left right colons arguments bar body )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBBlockNode is an AST node that represents a block "[...]".

Instance Variables:
	arguments	<SequenceableCollection of: RBVariableNode>	the arguments for the block
	bar	<Integer | nil>	position of the | after the arguments
	body	<RBSequenceNode>	the code inside the block
	colons	<SequenceableCollection of: Integer>	positions of each : before each argument
	left	<Integer>	position of [
	right	<Integer>	position of ]

';
		immediateInvariant.
true.
%

removeallmethods RBBlockNode
removeallclassmethods RBBlockNode

doit
(RBBlockNode
	subclass: 'RBPatternBlockNode'
	instVarNames: #( valueBlock )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Pattern';
		comment: 'RBPatternBlockNode is the node in matching parse trees (it never occurs in normal Smalltalk code) that executes a block to determine if a match occurs. valueBlock takes two arguments, the first is the actual node that we are trying to match against, and second node is the dictionary that contains all the metavariable bindings that the matcher has made thus far.

Instance Variables:
	valueBlock	<BlockClosure>	The block to execute when attempting to match this to a node.

';
		immediateInvariant.
true.
%

removeallmethods RBPatternBlockNode
removeallclassmethods RBPatternBlockNode

doit
(RBPatternBlockNode
	subclass: 'RBPatternWrapperBlockNode'
	instVarNames: #( wrappedNode )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Pattern';
		comment: 'RBPatternWrapperBlockNode allows further matching using a block after a node has been matched by a pattern node.

Instance Variables:
	wrappedNode	<RBProgramNode>	The original pattern node to match';
		immediateInvariant.
true.
%

removeallmethods RBPatternWrapperBlockNode
removeallclassmethods RBPatternWrapperBlockNode

doit
(RBBlockNode
	subclass: 'RBQueryBlockNode'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		immediateInvariant.
true.
%

removeallmethods RBQueryBlockNode
removeallclassmethods RBQueryBlockNode

doit
(RBValueNode
	subclass: 'RBCascadeNode'
	instVarNames: #( messages semicolons )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBCascadeNode is an AST node for cascaded messages (e.g., "self print1 ; print2").

Instance Variables:
	messages	<SequenceableCollection of: RBMessageNode>	the messages 
	semicolons	<SequenceableCollection of: Integer>	positions of the ; between messages

';
		immediateInvariant.
true.
%

removeallmethods RBCascadeNode
removeallclassmethods RBCascadeNode

doit
(RBValueNode
	subclass: 'RBLiteralNode'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBLiteralNode is an AST node that represents literals.';
		immediateInvariant.
true.
%

removeallmethods RBLiteralNode
removeallclassmethods RBLiteralNode

doit
(RBLiteralNode
	subclass: 'RBLiteralArrayNode'
	instVarNames: #( isByteArray stop contents start )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'A RBLiteralArrayNode is an AST node that represents literal arrays and literal byte arrays.

Instance Variables
	contents: <Array of: RBLiteralNode> literal nodes of the array
	isByteArray: <Boolean> if the receiver is a literal byte array
	start: <Integer | nil> source position of #( or #[
	stop: <Integer | nil> source position of ) or ]';
		immediateInvariant.
true.
%

removeallmethods RBLiteralArrayNode
removeallclassmethods RBLiteralArrayNode

doit
(RBLiteralNode
	subclass: 'RBLiteralValueNode'
	instVarNames: #( token )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBLiteralNode is an AST node that represents literal values (e.g., #foo, true, 1, etc.), but not literal arrays.

Instance Variables:
	token	<RBLiteralToken>	the token that contains the literal value as well as its source positions';
		immediateInvariant.
true.
%

removeallmethods RBLiteralValueNode
removeallclassmethods RBLiteralValueNode

doit
(RBValueNode
	subclass: 'RBMessageNode'
	instVarNames: #( receiver selector selectorParts arguments )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBMessageNode is an AST node that represents a message send.

Instance Variables:
	arguments	<SequenceableCollection of: RBValueNode>	our argument nodes
	receiver	<RBValueNode>	the receiver''s node
	selector	<Symbol | nil>	the selector we''re sending (cached)
	selectorParts	<SequenceableCollection of: RBValueToken>	the tokens for each keyword

';
		immediateInvariant.
true.
%

removeallmethods RBMessageNode
removeallclassmethods RBMessageNode

doit
(RBMessageNode
	subclass: 'RBPatternMessageNode'
	instVarNames: #( isList isCascadeList )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Pattern';
		comment: 'RBPatternMessageNode is a RBMessageNode that will match other message nodes without their selectors being equal. 

Instance Variables:
	isCascadeList	<Boolean>	are we matching a list of message nodes in a cascaded message
	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)';
		immediateInvariant.
true.
%

removeallmethods RBPatternMessageNode
removeallclassmethods RBPatternMessageNode

doit
(RBValueNode
	subclass: 'RBVariableNode'
	instVarNames: #( token )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBVariableNode is an AST node that represent a variable (global, inst var, temp, etc.).

Instance Variables:
	token	<RBValueToken>	the token that contains our name and position

';
		immediateInvariant.
true.
%

removeallmethods RBVariableNode
removeallclassmethods RBVariableNode

doit
(RBVariableNode
	subclass: 'RBPatternVariableNode'
	instVarNames: #( recurseInto isList isLiteral isStatement isAnything )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Pattern';
		comment: 'RBPatternVariableNode is an AST node that is used to match several other types of nodes (literals, variables, value nodes, statement nodes, and sequences of statement nodes).

The different types of matches are determined by the name of the node. If the name contains a # character, then it will match a literal. If it contains, a . then it matches statements. If it contains no extra characters, then it matches only variables. These options are mutually exclusive.

The @ character can be combined with the name to match lists of items. If combined with the . character, then it will match a list of statement nodes (0 or more). If used without the . or # character, then it matches anything except for list of statements. Combining the @ with the # is not supported.

Adding another ` in the name will cause the search/replace to look for more matches inside the node that this node matched. This option should not be used for top level expressions since that would cause infinite recursion (e.g., searching only for "``@anything").

Instance Variables:
	isAnything	<Boolean>	can we match any type of node
	isList	<Boolean>	can we match a list of items (@)
	isLiteral	<Boolean>	only match a literal node (#)
	isStatement	<Boolean>	only match statements (.)
	recurseInto	<Boolean>	search for more matches in the node we match (`)

';
		immediateInvariant.
true.
%

removeallmethods RBPatternVariableNode
removeallclassmethods RBPatternVariableNode

doit
(Object
	subclass: 'RBProgramNodeVisitor'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Visitors';
		comment: 'RBProgramNodeVisitor is an abstract visitor for the RBProgramNodes.

';
		immediateInvariant.
true.
%

removeallmethods RBProgramNodeVisitor
removeallclassmethods RBProgramNodeVisitor

doit
(RBProgramNodeVisitor
	subclass: 'RBConfigurableFormatter'
	instVarNames: #( codeStream indent lookaheadCode originalSource lineStart inQueryBlock )
	classVars: #( CascadedMessageInsideParentheses FormatCommentWithStatements IndentsForKeywords IndentString InQueryBlock KeepBlockInMessage LineUpBlockBrackets MaxLineLength MethodSignatureOnMultipleLines MinimumNewLinesBetweenStatements MultiLineMessages NewLineAfterCascade NewLineBeforeFirstCascade NewLineBeforeFirstKeyword NewLinesAfterMethodComment NewLinesAfterMethodPattern NewLinesAfterTemporaries NumberOfArgumentsForMultiLine OneLineMessages PeriodsAtEndOfBlock PeriodsAtEndOfMethod RetainBlankLinesBetweenStatements StringFollowingReturn StringInsideBlocks StringInsideParentheses TraditionalBinaryPrecedence UseTraditionalBinaryPrecedenceForParentheses )
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Visitors';
		comment: 'RBConfigurableFormatter formats the Refactoring Browser''s parse trees. It has many more formatting options than the default formatter used by the RB. To change the RB to use this formatter, execute "RBProgramNode formatterClass: RBConfigurableFormatter". For some refactorings the RB must reformat the code after the change, so it is good to have a formatter configured to your tastes.

Instance Variables:
	codeStream	<PositionableStream>	the stream we are writing our output to
	indent	<Integer>	how many times are we indenting a new line -- indents are normally tabs but could be any whitespace string
	lineStart	<Integer>	the position of the character that started the current line. This is used for calculating the line length.
	lookaheadCode	<Dictionary key: RBProgramNode value: String>	sometimes we need to lookahead while formatting, this dictionary contains the nodes that have already been formatted by lookahead
	originalSource	<String>	the original source before we started formatting. This is used to extract the comments from the original source.

';
		immediateInvariant.
true.
%

removeallmethods RBConfigurableFormatter
removeallclassmethods RBConfigurableFormatter

doit
(RBProgramNodeVisitor
	subclass: 'RBFormatter'
	instVarNames: #( codeStream lineStart firstLineLength tabs inQueryBlock )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Visitors';
		comment: 'RBFormatter formats a parse tree. It is an example of a Visitor. This is rarely called directly. Sending ''formattedCode'' to a parse tree uses this algorithm to return a pretty-printed version.

Instance Variables:
	codeStream	<PositionableStream>	The buffer where the output is accumulated.
	firstLineLength	<Integer>	The length of the first line of a message send.
	lineStart	<Integer>	The position of the current line''s start.
	tabs	<Integer>	The number of tabs currently indented.

';
		immediateInvariant.
true.
%

removeallmethods RBFormatter
removeallclassmethods RBFormatter

doit
(RBProgramNodeVisitor
	subclass: 'RBParseTreeSearcher'
	instVarNames: #( searches answer argumentSearches context messages )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Matching';
		comment: 'ParseTreeSearcher walks over a normal source code parse tree using the visitor pattern, and then matches these nodes against the meta-nodes using the match:inContext: methods defined for the meta-nodes.

Instance Variables:
	answer	<Object>	the "answer" that is propagated between matches
	argumentSearches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	argument searches (search for the BRProgramNode and perform the BlockClosure when its found)
	context	<RBSmallDictionary>	a dictionary that contains what each meta-node matches against. This could be a normal Dictionary that is created for each search, but is created once and reused (efficiency).
	messages	<Collection>	the sent messages in our searches
	searches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	non-argument searches (search for the BRProgramNode and perform the BlockClosure when its found)';
		immediateInvariant.
true.
%

removeallmethods RBParseTreeSearcher
removeallclassmethods RBParseTreeSearcher

doit
(RBParseTreeSearcher
	subclass: 'RBParseTreeRewriter'
	instVarNames: #( tree )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Matching';
		comment: 'ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then answer is set to true, and the modified tree can be retrieved by the #tree method.

Instance Variables:
	tree	<RBProgramNode>	the parse tree we''re transforming';
		immediateInvariant.
true.
%

removeallmethods RBParseTreeRewriter
removeallclassmethods RBParseTreeRewriter

doit
(RBProgramNodeVisitor
	subclass: 'RBReadBeforeWrittenTester'
	instVarNames: #( read checkNewTemps scopeStack )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Visitors';
		comment: 'RBReadBeforeWrittenTester is a visitor that identifies variables that may have been read before they are initialized.

Instance Variables:
	checkNewTemps	<Boolean>	description of checkNewTemps
	read	<Collection>	description of read
	scopeStack	<OrderedCollection>	description of scopeStack

';
		immediateInvariant.
true.
%

removeallmethods RBReadBeforeWrittenTester
removeallclassmethods RBReadBeforeWrittenTester

doit
(Object
	subclass: 'RBScanner'
	instVarNames: #( stream buffer tokenStart currentCharacter characterType classificationTable comments errorBlock )
	classVars: #( PatternVariableCharacter )
	classInstVars: #( classificationTable )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Parser';
		comment: 'RBScanner is a stream that returns a sequence of token from the string that it is created on. The tokens know where they came from in the source code and which comments were attached to them.

Instance Variables:
	buffer	<PositionableStream>	Accumulates the text for the current token.
	characterType	<ByteSymbol>	The type of the next character. (e.g. #alphabetic, etc.)
	classificationTable	<Array of: Symbol>	Mapping from Character values to their characterType.
	comments	<Collection of: Interval>	Source intervals of scanned comments that must be attached to the next token.
	currentCharacter	<Character>	The character currently being processed.
	errorBlock	<BlockClosure>	The block to execute on lexical errors.
	extendedLiterals	<Boolean>	True if IBM-type literals are allowed. In VW, this is false.
	nameSpaceCharacter	<Character>	The character used to separate namespaces.
	numberType	<ByteSymbol>	The method to perform: to scan a number. 
	separatorsInLiterals	<Boolean>	True if separators are allowed within literals.
	stream	<PositionableStream>	Contains the text to be scanned.
	tokenStart	<Integer>	The source position of the beginning of the current token

Class Instance Variables:
	classificationTable	<Array>		the default classification table for all characters

Shared Variables:
	PatternVariableCharacter	<Character>	the character that starts a pattern node';
		immediateInvariant.
true.
%

removeallmethods RBScanner
removeallclassmethods RBScanner

doit
(RBScanner
	subclass: 'RBPatternScanner'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Parser';
		comment: 'RBPatternScanner is a subclass of RBScanner that allows the extended syntax of pattern matching trees.
';
		immediateInvariant.
true.
%

removeallmethods RBPatternScanner
removeallclassmethods RBPatternScanner

doit
(Object
	subclass: 'RBSmallDictionary'
	instVarNames: #( keys values tally )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Matching';
		comment: 'RBSmallDictionary is a special dictionary optimized for small collections. In addition to the normal dictionary protocol, it also supports an #empty message which "empties" the collection but may hang on to the original elements (so it could collect garbage). Without #empty we would either need to create a new dictionary or explicitly remove everything from the dictionary. Both of these take more time and #empty.

Instance Variables:
array <Array of: Object> array of keys (we don''t use Associations for our key value pairs)
tally <Integer> the size of the dictionary
values <Array of: Object> array of our values
';
		immediateInvariant.
true.
%

removeallmethods RBSmallDictionary
removeallclassmethods RBSmallDictionary

doit
(Object
	subclass: 'RBStringReplacement'
	instVarNames: #( startPosition stopPosition string )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Nodes';
		comment: 'RBStringReplacement represents replacing source in the original method with a different string. These are used when reformatting code after a parse tree change has been made. Depending on the change, it may be possible to minimally change the parse tree without needing to format it.

Instance Variables:
	startPosition	<Integer>	the start position in the original source
	stopPosition	<Integer>	the end position in the original source
	string	<String>	replaces everything from the startPosition to the endPosition with this string

';
		immediateInvariant.
true.
%

removeallmethods RBStringReplacement
removeallclassmethods RBStringReplacement

doit
(Object
	subclass: 'RBToken'
	instVarNames: #( sourcePointer comments )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		comment: 'RBToken is the abstract superclass of all of the RB tokens. These tokens (unlike the standard parser''s) remember where they came from in the original source code.

Subclasses must implement the following messages:
	accessing
		length

Instance Variables:
	sourcePointer	<Integer>	The position in the original source code where this token began.
';
		immediateInvariant.
true.
%

removeallmethods RBToken
removeallclassmethods RBToken

doit
(RBToken
	subclass: 'RBAssignmentToken'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		comment: 'RBAssignmentToken is the first-class representation of the assignment token '':=''
';
		immediateInvariant.
true.
%

removeallmethods RBAssignmentToken
removeallclassmethods RBAssignmentToken

doit
(RBAssignmentToken
	subclass: 'RBShortAssignmentToken'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		immediateInvariant.
true.
%

removeallmethods RBShortAssignmentToken
removeallclassmethods RBShortAssignmentToken

doit
(RBToken
	subclass: 'RBValueToken'
	instVarNames: #( value )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		comment: 'RBValueToken is the abstract superclass of all tokens that have additional information attached. For example, the BinarySelector token holds onto the actual character (e.g. $+).

Instance Variables:
	value	<String>	The value of this token

';
		immediateInvariant.
true.
%

removeallmethods RBValueToken
removeallclassmethods RBValueToken

doit
(RBValueToken
	subclass: 'RBBinarySelectorToken'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		comment: 'RBBinarySelectorToken is the first-class representation of a binary selector (e.g. +)
';
		immediateInvariant.
true.
%

removeallmethods RBBinarySelectorToken
removeallclassmethods RBBinarySelectorToken

doit
(RBValueToken
	subclass: 'RBIdentifierToken'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		comment: 'RBIdentifierToken is the first class representation of an identifier token (e.g. Class)
';
		immediateInvariant.
true.
%

removeallmethods RBIdentifierToken
removeallclassmethods RBIdentifierToken

doit
(RBIdentifierToken
	subclass: 'RBPathToken'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		immediateInvariant.
true.
%

removeallmethods RBPathToken
removeallclassmethods RBPathToken

doit
(RBValueToken
	subclass: 'RBKeywordToken'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		comment: 'RBKeywordToken is the first-class representation of a keyword token (e.g. add:)';
		immediateInvariant.
true.
%

removeallmethods RBKeywordToken
removeallclassmethods RBKeywordToken

doit
(RBValueToken
	subclass: 'RBLiteralArrayToken'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		immediateInvariant.
true.
%

removeallmethods RBLiteralArrayToken
removeallclassmethods RBLiteralArrayToken

doit
(RBValueToken
	subclass: 'RBLiteralToken'
	instVarNames: #( stopPosition )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		comment: 'RBLiteralToken is the first-class representation of a literal token (entire literals, even literal arrays, are a single token in the ST80 grammar.).

Instance Variables:
	stopPosition	<Integer>	The position within the source code where the token terminates.

';
		immediateInvariant.
true.
%

removeallmethods RBLiteralToken
removeallclassmethods RBLiteralToken

doit
(RBLiteralToken
	subclass: 'RBMultiKeywordLiteralToken'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		immediateInvariant.
true.
%

removeallmethods RBMultiKeywordLiteralToken
removeallclassmethods RBMultiKeywordLiteralToken

doit
(RBLiteralToken
	subclass: 'RBNumberLiteralToken'
	instVarNames: #( source )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		immediateInvariant.
true.
%

removeallmethods RBNumberLiteralToken
removeallclassmethods RBNumberLiteralToken

doit
(RBValueToken
	subclass: 'RBPatternBlockToken'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		comment: 'RBPatternBlockToken is the first-class representation of the pattern block token.

';
		immediateInvariant.
true.
%

removeallmethods RBPatternBlockToken
removeallclassmethods RBPatternBlockToken

doit
(RBValueToken
	subclass: 'RBSpecialCharacterToken'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'AST-Core-Tokens';
		comment: 'RBSpecialCharacterToken is the first class representation of special characters.

';
		immediateInvariant.
true.
%

removeallmethods RBSpecialCharacterToken
removeallclassmethods RBSpecialCharacterToken

doit
(Object
	subclass: 'Rowan'
	instVarNames: #()
	classVars: #()
	classInstVars: #( configuration )
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Kernel';
		comment: 'No class-specific documentation for Cypress, hierarchy is: 
Object
  Cypress
';
		immediateInvariant.
true.
%

removeallmethods Rowan
removeallclassmethods Rowan

doit
(Object
	subclass: 'RowanCommandResult'
	instVarNames: #( executionTime )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'Simple object with the results of the Jadeite command.';
		immediateInvariant.
true.
%

removeallmethods RowanCommandResult
removeallclassmethods RowanCommandResult

doit
(RowanCommandResult
	subclass: 'RowanClassCategoryUpdate'
	instVarNames: #( categories selection )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanClassCategoryUpdate
removeallclassmethods RowanClassCategoryUpdate

doit
(RowanCommandResult
	subclass: 'RowanClassesUpdate'
	instVarNames: #( classNames selectionNames )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanClassesUpdate
removeallclassmethods RowanClassesUpdate

doit
(RowanClassesUpdate
	subclass: 'RowanClassHierarchyUpdate'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanClassHierarchyUpdate
removeallclassmethods RowanClassHierarchyUpdate

doit
(RowanClassesUpdate
	subclass: 'RowanMethodsUpdate'
	instVarNames: #( methods methodFilters selectors selectedClass selectedSelectors inheritedClasses inheritedClass type )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanMethodsUpdate
removeallclassmethods RowanMethodsUpdate

doit
(RowanClassesUpdate
	subclass: 'RowanSuperclassUpdate'
	instVarNames: #( tabName )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanSuperclassUpdate
removeallclassmethods RowanSuperclassUpdate

doit
(RowanCommandResult
	subclass: 'RowanClassInfoUpdate'
	instVarNames: #( oop template category comment )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanClassInfoUpdate
removeallclassmethods RowanClassInfoUpdate

doit
(RowanCommandResult
	subclass: 'RowanDictionaryUpdate'
	instVarNames: #( dictionaries selections )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanDictionaryUpdate
removeallclassmethods RowanDictionaryUpdate

doit
(RowanCommandResult
	subclass: 'RowanGlobalsUpdate'
	instVarNames: #( globals )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanGlobalsUpdate
removeallclassmethods RowanGlobalsUpdate

doit
(RowanCommandResult
	subclass: 'RowanGsObject'
	instVarNames: #( gciSession name oopType )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanGsObject
removeallclassmethods RowanGsObject

doit
(RowanGsObject
	subclass: 'RowanGsMethod'
	instVarNames: #( behavior behaviorName breakPoints category isReadOnly originalSource source stepPoints unimplementedSelectors warnings )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanGsMethod
removeallclassmethods RowanGsMethod

doit
(RowanCommandResult
	subclass: 'RowanMethodUpdate'
	instVarNames: #( gsMethod firstSendOffsets method isOverride isTestClass )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanMethodUpdate
removeallclassmethods RowanMethodUpdate

doit
(RowanCommandResult
	subclass: 'RowanPackageUpdate'
	instVarNames: #( packages modifiedPackages selections )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanPackageUpdate
removeallclassmethods RowanPackageUpdate

doit
(RowanCommandResult
	subclass: 'RowanProjectsUpdate'
	instVarNames: #( projects modifiedProjects selection )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanProjectsUpdate
removeallclassmethods RowanProjectsUpdate

doit
(Object
	subclass: 'RowanInterface'
	instVarNames: #( name )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RowanInterface
removeallclassmethods RowanInterface

doit
(RowanInterface
	subclass: 'RwPackage'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwPackage
removeallclassmethods RwPackage

doit
(RowanInterface
	subclass: 'RwProject'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwProject
removeallclassmethods RwProject

doit
(Object
	subclass: 'RowanService'
	instVarNames: #( definition updates command commandArgs updateType organizer )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'Rowan Service is the abstract service class for classes that represent
first class entities in Rowan. They are transported to the client via 
ston. 

On the client, set the command & commandArgs inst vars, then tell
the browser to #issueCommand: with an array of services. A service
received without the the command inst var set will send #update to
the service. #issueCommand: should call JadeServer>>updateFromSton:
which will run the command and return a result. 

Any service that sends updates back to the client willl propogates to 
registered windows. Add a service for return to the client with:
RowanCommandResult addResult: <self>';
		immediateInvariant.
true.
%

removeallmethods RowanService
removeallclassmethods RowanService

doit
(RowanService
	subclass: 'RowanAnsweringService'
	instVarNames: #( answer )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'A place to put miscellaneous commands that don''t fit 
well in other services. 

Also good asking the server questions as it gives back 
an answer whereas other services simply return updated
services.';
		immediateInvariant.
true.
%

removeallmethods RowanAnsweringService
removeallclassmethods RowanAnsweringService

doit
(RowanService
	subclass: 'RowanAutoCommitService'
	instVarNames: #( autoCommit )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'Simple service that provides updates to the client related to auto commit.';
		immediateInvariant.
true.
%

removeallmethods RowanAutoCommitService
removeallclassmethods RowanAutoCommitService

doit
(RowanService
	subclass: 'RowanBrowserService'
	instVarNames: #( projects removedMethods allClasses hierarchyServices testPackages testCount dictionaries selectedClass newCachedSelectors newCachedClasses )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'RowanBrowserService handles services that fall outside
the scope of other services.';
		immediateInvariant.
true.
%

removeallmethods RowanBrowserService
removeallclassmethods RowanBrowserService

doit
(RowanService
	subclass: 'RowanClassService'
	instVarNames: #( name comment instVarNames classVarNames classInstVarNames superclassName subclassType poolDictionaryNames classType meta isExtension version versions oop template filters filterType methods selectedPackageServices packageName definedPackageName selectedMethods projectName hierarchyServices variables categories isTestCase expand visibleTests isNewClass updateAfterCommand isInSymbolList dictionaryName wasRemoved renamedName )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		comment: 'Most class operations done here. 

selectedMethods - client side selection. Used after a method compile.';
		immediateInvariant.
true.
%

removeallmethods RowanClassService
removeallclassmethods RowanClassService

doit
(RowanService
	subclass: 'RowanDebuggerService'
	instVarNames: #( initialProcessOop processes )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanDebuggerService
removeallclassmethods RowanDebuggerService

doit
(RowanService
	subclass: 'RowanDictionaryService'
	instVarNames: #( name classes hierarchyServices globals defaultTemplate )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanDictionaryService
removeallclassmethods RowanDictionaryService

doit
(RowanService
	subclass: 'RowanFrameService'
	instVarNames: #( label method stepPoint vars oop homeMethodSelector homeMethodClassName )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanFrameService
removeallclassmethods RowanFrameService

doit
(RowanService
	subclass: 'RowanLoggingService'
	instVarNames: #( fileName id groupId date time comment services mode location isLogging )
	classVars: #( Current )
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanLoggingService
removeallclassmethods RowanLoggingService

doit
(RowanService
	subclass: 'RowanMethodService'
	instVarNames: #( oop source selector methodDefinitions classService category packageName projectName className meta hasSupers hasSubs compilationWarnings isExtension inSelectedPackage references stepPoints selectedPackageServices superDisplayString accessedInstVars breakPoints testResult definedPackage isTestMethod testRunClassName failedCompile comparisonSource firstReference renamedName isMethodForBlock homeMethodOop )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanMethodService
removeallclassmethods RowanMethodService

doit
(RowanService
	subclass: 'RowanPackageService'
	instVarNames: #( projectDefinition packageName name isDirty classes defaultTemplate projectName testClasses hierarchyServices selectedClass )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanPackageService
removeallclassmethods RowanPackageService

doit
(RowanService
	subclass: 'RowanProcessService'
	instVarNames: #( frames oop status )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanProcessService
removeallclassmethods RowanProcessService

doit
(RowanService
	subclass: 'RowanProjectService'
	instVarNames: #( name sha branch isSkew isDirty packages changes existsOnDisk isLoaded projectUrl rowanProjectsHome )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanProjectService
removeallclassmethods RowanProjectService

doit
(RowanService
	subclass: 'RowanQueryService'
	instVarNames: #( queryResults )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanQueryService
removeallclassmethods RowanQueryService

doit
(RowanService
	subclass: 'RowanTestService'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanTestService
removeallclassmethods RowanTestService

doit
(RowanService
	subclass: 'RowanVariableService'
	instVarNames: #( oop key value className )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanVariableService
removeallclassmethods RowanVariableService

doit
(Object
	subclass: 'RowanServicePreferences'
	instVarNames: #( defaultProjectName )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Services-Core';
		immediateInvariant.
true.
%

removeallmethods RowanServicePreferences
removeallclassmethods RowanServicePreferences

doit
(Object
	subclass: 'RwAbstractConfigurationPlatformAttributeMatcher'
	instVarNames: #( pattern patternMatchBlock )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwAbstractConfigurationPlatformAttributeMatcher
removeallclassmethods RwAbstractConfigurationPlatformAttributeMatcher

doit
(RwAbstractConfigurationPlatformAttributeMatcher
	subclass: 'RwGemStoneVersionConfigurationPlatformAttributeMatcher'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwGemStoneVersionConfigurationPlatformAttributeMatcher
removeallclassmethods RwGemStoneVersionConfigurationPlatformAttributeMatcher

doit
(RwGemStoneVersionConfigurationPlatformAttributeMatcher
	subclass: 'RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher'
	instVarNames: #( pattern2 )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
removeallclassmethods RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher

doit
(RwAbstractConfigurationPlatformAttributeMatcher
	subclass: 'RwStringConfigurationPlatformAttributeMatcher'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwStringConfigurationPlatformAttributeMatcher
removeallclassmethods RwStringConfigurationPlatformAttributeMatcher

doit
(Object
	subclass: 'RwAbstractProjectConfiguration'
	instVarNames: #( name comment projectName version configurationNames )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwAbstractProjectConfiguration
removeallclassmethods RwAbstractProjectConfiguration

doit
(RwAbstractProjectConfiguration
	subclass: 'RwAbstractProjectLoadConfiguration'
	instVarNames: #( conditionalPackages conditionalPackageMatchers conditionalPackageMapSpecs conditionalPackageMapSpecMatchers )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwAbstractProjectLoadConfiguration
removeallclassmethods RwAbstractProjectLoadConfiguration

doit
(RwAbstractProjectLoadConfiguration
	subclass: 'RwNestedProjectLoadConfiguration'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwNestedProjectLoadConfiguration
removeallclassmethods RwNestedProjectLoadConfiguration

doit
(RwAbstractProjectLoadConfiguration
	subclass: 'RwProjectLoadConfiguration'
	instVarNames: #( definedGroupNames )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwProjectLoadConfiguration
removeallclassmethods RwProjectLoadConfiguration

doit
(RwAbstractProjectConfiguration
	subclass: 'RwProjectCompoundConfiguration'
	instVarNames: #( packageNames )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwProjectCompoundConfiguration
removeallclassmethods RwProjectCompoundConfiguration

doit
(RwAbstractProjectConfiguration
	subclass: 'RwProjectConfiguration'
	instVarNames: #( configNames )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Deprecated';
		comment: 'The class RwProjectConfiguration is deprecated in favor of the class RwProjectCompoundConfiguration.

This class will be removed from the system prior to final release.';
		immediateInvariant.
true.
%

removeallmethods RwProjectConfiguration
removeallclassmethods RwProjectConfiguration

doit
(Object
	subclass: 'RwAbstractTool'
	instVarNames: #( specification )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		comment: 'Fundamental concepts:

	read			(disk -> def)
	write			(def -> disk)

	install			(def -> image)
	derive			(image -> def)

	load			(disk ->  image)
	commit			(image -> disk)

	project			manages collections of packages
	package			manages collections of definitions
	definitions	manages properties of classes and methods
	repository		manages disk representation of defintions';
		immediateInvariant.
true.
%

removeallmethods RwAbstractTool
removeallclassmethods RwAbstractTool

doit
(RwAbstractTool
	subclass: 'RwClassTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwClassTool
removeallclassmethods RwClassTool

doit
(RwClassTool
	subclass: 'RwClsAuditTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		comment: 'This class audits individual classes';
		immediateInvariant.
true.
%

removeallmethods RwClsAuditTool
removeallclassmethods RwClsAuditTool

doit
(RwClsAuditTool
	subclass: 'RwClsExtensionAuditTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwClsExtensionAuditTool
removeallclassmethods RwClsExtensionAuditTool

doit
(RwClassTool
	subclass: 'RwClsDiffTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwClsDiffTool
removeallclassmethods RwClsDiffTool

doit
(RwAbstractTool
	subclass: 'RwGitTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwGitTool
removeallclassmethods RwGitTool

doit
(RwAbstractTool
	subclass: 'RwPackageTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPackageTool
removeallclassmethods RwPackageTool

doit
(RwPackageTool
	subclass: 'RwPkgAdoptTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgAdoptTool
removeallclassmethods RwPkgAdoptTool

doit
(RwPackageTool
	subclass: 'RwPkgCommitTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgCommitTool
removeallclassmethods RwPkgCommitTool

doit
(RwPackageTool
	subclass: 'RwPkgCopyTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgCopyTool
removeallclassmethods RwPkgCopyTool

doit
(RwPackageTool
	subclass: 'RwPkgCreateTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgCreateTool
removeallclassmethods RwPkgCreateTool

doit
(RwPackageTool
	subclass: 'RwPkgDiffTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgDiffTool
removeallclassmethods RwPkgDiffTool

doit
(RwPackageTool
	subclass: 'RwPkgDisownTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgDisownTool
removeallclassmethods RwPkgDisownTool

doit
(RwPackageTool
	subclass: 'RwPkgEditTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgEditTool
removeallclassmethods RwPkgEditTool

doit
(RwPackageTool
	subclass: 'RwPkgInstallTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgInstallTool
removeallclassmethods RwPkgInstallTool

doit
(RwPackageTool
	subclass: 'RwPkgListTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgListTool
removeallclassmethods RwPkgListTool

doit
(RwPackageTool
	subclass: 'RwPkgLoadTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgLoadTool
removeallclassmethods RwPkgLoadTool

doit
(RwPackageTool
	subclass: 'RwPkgMoveTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgMoveTool
removeallclassmethods RwPkgMoveTool

doit
(RwPackageTool
	subclass: 'RwPkgQueryTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgQueryTool
removeallclassmethods RwPkgQueryTool

doit
(RwPackageTool
	subclass: 'RwPkgReadTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgReadTool
removeallclassmethods RwPkgReadTool

doit
(RwPackageTool
	subclass: 'RwPkgRecompileTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgRecompileTool
removeallclassmethods RwPkgRecompileTool

doit
(RwPackageTool
	subclass: 'RwPkgRemoveTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgRemoveTool
removeallclassmethods RwPkgRemoveTool

doit
(RwPackageTool
	subclass: 'RwPkgRenameTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgRenameTool
removeallclassmethods RwPkgRenameTool

doit
(RwPackageTool
	subclass: 'RwPkgRevertTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgRevertTool
removeallclassmethods RwPkgRevertTool

doit
(RwPackageTool
	subclass: 'RwPkgWriteTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgWriteTool
removeallclassmethods RwPkgWriteTool

doit
(RwAbstractTool
	subclass: 'RwPkgAuditTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPkgAuditTool
removeallclassmethods RwPkgAuditTool

doit
(RwAbstractTool
	subclass: 'RwProjectTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwProjectTool
removeallclassmethods RwProjectTool

doit
(RwProjectTool
	subclass: 'RwPrjAdoptTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjAdoptTool
removeallclassmethods RwPrjAdoptTool

doit
(RwProjectTool
	subclass: 'RwPrjAuditTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjAuditTool
removeallclassmethods RwPrjAuditTool

doit
(RwProjectTool
	subclass: 'RwPrjBrowserTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjBrowserTool
removeallclassmethods RwPrjBrowserTool

doit
(RwProjectTool
	subclass: 'RwPrjCheckoutTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjCheckoutTool
removeallclassmethods RwPrjCheckoutTool

doit
(RwProjectTool
	subclass: 'RwPrjCloneTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjCloneTool
removeallclassmethods RwPrjCloneTool

doit
(RwProjectTool
	subclass: 'RwPrjCommitTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjCommitTool
removeallclassmethods RwPrjCommitTool

doit
(RwProjectTool
	subclass: 'RwPrjCreateTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjCreateTool
removeallclassmethods RwPrjCreateTool

doit
(RwProjectTool
	subclass: 'RwPrjDeleteTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjDeleteTool
removeallclassmethods RwPrjDeleteTool

doit
(RwProjectTool
	subclass: 'RwPrjDiffTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjDiffTool
removeallclassmethods RwPrjDiffTool

doit
(RwProjectTool
	subclass: 'RwPrjDisownTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjDisownTool
removeallclassmethods RwPrjDisownTool

doit
(RwProjectTool
	subclass: 'RwPrjEditTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjEditTool
removeallclassmethods RwPrjEditTool

doit
(RwProjectTool
	subclass: 'RwPrjInstallTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjInstallTool
removeallclassmethods RwPrjInstallTool

doit
(RwProjectTool
	subclass: 'RwPrjListTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjListTool
removeallclassmethods RwPrjListTool

doit
(RwProjectTool
	subclass: 'RwPrjLoadTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjLoadTool
removeallclassmethods RwPrjLoadTool

doit
(RwProjectTool
	subclass: 'RwPrjLogTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjLogTool
removeallclassmethods RwPrjLogTool

doit
(RwProjectTool
	subclass: 'RwPrjPullTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjPullTool
removeallclassmethods RwPrjPullTool

doit
(RwProjectTool
	subclass: 'RwPrjPushTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjPushTool
removeallclassmethods RwPrjPushTool

doit
(RwProjectTool
	subclass: 'RwPrjQueryTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjQueryTool
removeallclassmethods RwPrjQueryTool

doit
(RwProjectTool
	subclass: 'RwPrjReadTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjReadTool
removeallclassmethods RwPrjReadTool

doit
(RwProjectTool
	subclass: 'RwPrjReconcileTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjReconcileTool
removeallclassmethods RwPrjReconcileTool

doit
(RwProjectTool
	subclass: 'RwPrjRegisterTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjRegisterTool
removeallclassmethods RwPrjRegisterTool

doit
(RwProjectTool
	subclass: 'RwPrjRegistryTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjRegistryTool
removeallclassmethods RwPrjRegistryTool

doit
(RwProjectTool
	subclass: 'RwPrjRevertTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjRevertTool
removeallclassmethods RwPrjRevertTool

doit
(RwProjectTool
	subclass: 'RwPrjSpecTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjSpecTool
removeallclassmethods RwPrjSpecTool

doit
(RwProjectTool
	subclass: 'RwPrjTestTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjTestTool
removeallclassmethods RwPrjTestTool

doit
(RwProjectTool
	subclass: 'RwPrjUnregisterTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjUnregisterTool
removeallclassmethods RwPrjUnregisterTool

doit
(RwProjectTool
	subclass: 'RwPrjUpgradeTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjUpgradeTool
removeallclassmethods RwPrjUpgradeTool

doit
(RwProjectTool
	subclass: 'RwPrjWriteTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwPrjWriteTool
removeallclassmethods RwPrjWriteTool

doit
(RwAbstractTool
	subclass: 'RwRepositoryTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwRepositoryTool
removeallclassmethods RwRepositoryTool

doit
(RwRepositoryTool
	subclass: 'RwRepAddTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwRepAddTool
removeallclassmethods RwRepAddTool

doit
(RwRepositoryTool
	subclass: 'RwRepCommitTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwRepCommitTool
removeallclassmethods RwRepCommitTool

doit
(RwRepositoryTool
	subclass: 'RwRepListTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwRepListTool
removeallclassmethods RwRepListTool

doit
(RwRepositoryTool
	subclass: 'RwRepPackagesTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwRepPackagesTool
removeallclassmethods RwRepPackagesTool

doit
(RwRepositoryTool
	subclass: 'RwRepPullTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwRepPullTool
removeallclassmethods RwRepPullTool

doit
(RwRepositoryTool
	subclass: 'RwRepPushTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwRepPushTool
removeallclassmethods RwRepPushTool

doit
(RwRepositoryTool
	subclass: 'RwRepRemoveTool'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Tools-Core';
		immediateInvariant.
true.
%

removeallmethods RwRepRemoveTool
removeallclassmethods RwRepRemoveTool

doit
(Object
	subclass: 'RwClassAdditionOrRemoval'
	instVarNames: #( projectDefinition packageDefinition classKey classesModification )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypClassAdditionOrRemoval, hierarchy is: 
Object
  CypClassAdditionOrRemoval( packageDefinition classKey classesModification)
';
		immediateInvariant.
true.
%

removeallmethods RwClassAdditionOrRemoval
removeallclassmethods RwClassAdditionOrRemoval

doit
(Object
	subclass: 'RwConfiguration'
	instVarNames: #( packageInfoSource )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Configuration that guides Cypress operation.

Specific parameters:

packageInfoSource
--------------------------
A Symbol indicating where the authoritative repository of information about package membership of classes and methods is.
Acceptable values are platform-specific:

#Cypress -- the information is stored in Cypress-specific objects. Valid on all platforms, but recommended only when all code modifications are done through Cypress or tools that are Cypress-aware

#Category -- Valid for Pharo and GemStone. The category of a class is the name of its package, and a method''s membership in a protocol whose name starts with $* indicates extension methods.

#SymbolDictionary -- Valid for GemStone. The SymbolDictionary in which the class''s name is first found is the name of its package, and a method''s membership in a protocol whose name starts with $* indicates extension methods.

#Store -- Valid for VW. Cypress package membership is Store package membership.';
		immediateInvariant.
true.
%

removeallmethods RwConfiguration
removeallclassmethods RwConfiguration

doit
(Object
	subclass: 'RwDefinition'
	instVarNames: #( properties )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'Abstract.
Defines some "code" entity.
The definition object''s primary responsibility is to hold information.
It holds exactly the same information as the disk representation in some form of Cypress repository.
Other non-definition classes construct and use the information in definitions to read, write, and compare
code.

properties is a dictionary. Keys and values should be strings. These correspond to the properties in a Cypress repository, and are used in various ways, some of them dialect-specific.';
		immediateInvariant.
true.
%

removeallmethods RwDefinition
removeallclassmethods RwDefinition

doit
(RwDefinition
	subclass: 'RwAbstractClassDefinition'
	instVarNames: #( classMethodDefinitions instanceMethodDefinitions )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		immediateInvariant.
true.
%

removeallmethods RwAbstractClassDefinition
removeallclassmethods RwAbstractClassDefinition

doit
(RwAbstractClassDefinition
	subclass: 'RwClassDefinition'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'Defines a class.
Properties should include ''name'' and ''super''.
Other typical properties are ''instvars'' ''classinstvars'' ''classvars''.
Methods are their own definitions: classMethodDefinitions instanceMethodDefinitions
';
		immediateInvariant.
true.
%

removeallmethods RwClassDefinition
removeallclassmethods RwClassDefinition

doit
(RwAbstractClassDefinition
	subclass: 'RwClassExtensionDefinition'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'Extends an existing class with additional methods.
Properties must include ''name'', the name of the class to be extended, but should not include other things like ''super'' or ''instvars''.
';
		immediateInvariant.
true.
%

removeallmethods RwClassExtensionDefinition
removeallclassmethods RwClassExtensionDefinition

doit
(RwDefinition
	subclass: 'RwDefinitionSetDefinition'
	instVarNames: #( definitions )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'No class-specific documentation for CypPackageSetDefinition, hierarchy is: 
Object
  CypDefinition( properties)
    CypPackageSetDefinition( packages)
';
		immediateInvariant.
true.
%

removeallmethods RwDefinitionSetDefinition
removeallclassmethods RwDefinitionSetDefinition

doit
(RwDefinitionSetDefinition
	subclass: 'RwPackageSetDefinition'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'No class-specific documentation for CypPackageSetDefinition, hierarchy is: 
Object
  CypDefinition( properties)
    CypPackageSetDefinition( packages)
';
		immediateInvariant.
true.
%

removeallmethods RwPackageSetDefinition
removeallclassmethods RwPackageSetDefinition

doit
(RwDefinitionSetDefinition
	subclass: 'RwProjectSetDefinition'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'No class-specific documentation for CypPackageSetDefinition, hierarchy is: 
Object
  CypDefinition( properties)
    CypPackageSetDefinition( packages)
';
		immediateInvariant.
true.
%

removeallmethods RwProjectSetDefinition
removeallclassmethods RwProjectSetDefinition

doit
(RwDefinition
	subclass: 'RwMethodDefinition'
	instVarNames: #( source )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		immediateInvariant.
true.
%

removeallmethods RwMethodDefinition
removeallclassmethods RwMethodDefinition

doit
(RwDefinition
	subclass: 'RwPackageDefinition'
	instVarNames: #( classDefinitions classExtensions )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'Defines a package, which is a bunch of class definitions and class extensions.
Properties include ''name''.
Sub-definitions are classDefinitions and classExtensions
';
		immediateInvariant.
true.
%

removeallmethods RwPackageDefinition
removeallclassmethods RwPackageDefinition

doit
(RwDefinition
	subclass: 'RwProjectDefinition'
	instVarNames: #( packages )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		immediateInvariant.
true.
%

removeallmethods RwProjectDefinition
removeallclassmethods RwProjectDefinition

doit
(RwProjectDefinition
	subclass: 'RwUnmanagedProjectDefinition'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		immediateInvariant.
true.
%

removeallmethods RwUnmanagedProjectDefinition
removeallclassmethods RwUnmanagedProjectDefinition

doit
(Object
	subclass: 'RwElementsModification'
	instVarNames: #( elementsModified )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Abstract. Represents a modification to the elements of some code entity. "Modification" means that the code entity exists both before and after, but has differences in some of its elements.

Instvars:

elementsAdded		Dictionary elementKey -> element
elementsRemoved	Dictonary elementKey -> element
elementsModified	Dictionary elementKey -> CypModification  (key may have changed -- if so the key here is the old key)';
		immediateInvariant.
true.
%

removeallmethods RwElementsModification
removeallclassmethods RwElementsModification

doit
(RwElementsModification
	subclass: 'RwClassesModification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the classes or classExtensions of a package. The elements are classes. Key is class name.';
		immediateInvariant.
true.
%

removeallmethods RwClassesModification
removeallclassmethods RwClassesModification

doit
(RwElementsModification
	subclass: 'RwClassExtensionsModification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypClassExtensionsModification, hierarchy is: 
Object
  CypElementsModification( elementsAdded elementsRemoved elementsModified)
    CypClassExtensionsModification
';
		immediateInvariant.
true.
%

removeallmethods RwClassExtensionsModification
removeallclassmethods RwClassExtensionsModification

doit
(RwElementsModification
	subclass: 'RwEntitySetModification'
	instVarNames: #( movedClasses movedMethods )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwEntitySetModification
removeallclassmethods RwEntitySetModification

doit
(RwEntitySetModification
	subclass: 'RwPackageSetModification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between two PackageSets. The elements are packages. Key is package name.
movedClasses are classes that have moved from one package to another within the package set.
movedMethods are methods that have moved from a class definition to an extension of that class, or vice versa, or between two extensions of the same class.';
		immediateInvariant.
true.
%

removeallmethods RwPackageSetModification
removeallclassmethods RwPackageSetModification

doit
(RwEntitySetModification
	subclass: 'RwProjectSetModification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between two PackageSets. The elements are packages. Key is package name.
movedClasses are classes that have moved from one package to another within the package set.
movedMethods are methods that have moved from a class definition to an extension of that class, or vice versa, or between two extensions of the same class.';
		immediateInvariant.
true.
%

removeallmethods RwProjectSetModification
removeallclassmethods RwProjectSetModification

doit
(RwElementsModification
	subclass: 'RwMethodsModification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the instance or class methods defined by a class or class extension. The elements are method definitions. Key is selector (as string).';
		immediateInvariant.
true.
%

removeallmethods RwMethodsModification
removeallclassmethods RwMethodsModification

doit
(RwMethodsModification
	subclass: 'RwExtensionMethodsModification'
	instVarNames: #( extendedClassName )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExtensionMethodsModification
removeallclassmethods RwExtensionMethodsModification

doit
(RwElementsModification
	subclass: 'RwPackagesModification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the classes or classExtensions of a package. The elements are classes. Key is class name.';
		immediateInvariant.
true.
%

removeallmethods RwPackagesModification
removeallclassmethods RwPackagesModification

doit
(RwElementsModification
	subclass: 'RwPropertiesModification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'A modification showing the difference between the properties of a single entity. The elements are associations of propertyName -> propertyValue. Key is property name.';
		immediateInvariant.
true.
%

removeallmethods RwPropertiesModification
removeallclassmethods RwPropertiesModification

doit
(RwElementsModification
	subclass: 'RwSourceModification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'DELETE ME';
		immediateInvariant.
true.
%

removeallmethods RwSourceModification
removeallclassmethods RwSourceModification

doit
(Object
	subclass: 'RwEntitySet'
	instVarNames: #( entities )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Definitions';
		comment: 'Holds some number of RwDefinitions or RwLoadedThingss to be operated on together. The entities put into the receiver should be at the same semantic level: all methods, class, packages , or projects.

When the receiver is sent #asDefinition, the receiver is converted to a RwDefinitionSetDefinition and all entities are converted to their definition counterparts.';
		immediateInvariant.
true.
%

removeallmethods RwEntitySet
removeallclassmethods RwEntitySet

doit
(Object
	subclass: 'RwFileUtilities'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypFileUtilities, hierarchy is: 
Object
  CypFileUtilities
';
		immediateInvariant.
true.
%

removeallmethods RwFileUtilities
removeallclassmethods RwFileUtilities

doit
(RwFileUtilities
	subclass: 'RwGsFileUtilities'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		comment: 'No class-specific documentation for CypGemStoneFileUtilities, hierarchy is: 
Object
  CypFileUtilities
    CypGemStoneFileUtilities
';
		immediateInvariant.
true.
%

removeallmethods RwGsFileUtilities
removeallclassmethods RwGsFileUtilities

doit
(Object
	subclass: 'RwGsImage'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		comment: 'Keeps track of what LoadedPackages are in the GemStone repository, and is the gateway for operations to query or change the image.';
		immediateInvariant.
true.
%

removeallmethods RwGsImage
removeallclassmethods RwGsImage

doit
(Object
	subclass: 'RwGsImagePatchVisitor'
	instVarNames: #( patchSet currentProject currentPackage currentClass currentMethod )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'Walks a diff tree and adds patches to a patchSet that will update the GemStone image (repository) to the code state represented by the ''after'' state of the diff, provided that the ''before'' state of the diff is the current state of the image.';
		immediateInvariant.
true.
%

removeallmethods RwGsImagePatchVisitor
removeallclassmethods RwGsImagePatchVisitor

doit
(Object
	subclass: 'RwGsImagePatchVisitor_254'
	instVarNames: #( patchSet currentProject currentPackage currentClass currentMethod )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'Walks a diff tree and adds patches to a patchSet that will update the GemStone image (repository) to the code state represented by the ''after'' state of the diff, provided that the ''before'' state of the diff is the current state of the image.';
		immediateInvariant.
true.
%

removeallmethods RwGsImagePatchVisitor_254
removeallclassmethods RwGsImagePatchVisitor_254

doit
(Object
	subclass: 'RwGsInstanceMigrator'
	instVarNames: #( migrationEnabled maxThreads maxCpuPercentage )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsInstanceMigrator
removeallclassmethods RwGsInstanceMigrator

doit
(RwGsInstanceMigrator
	subclass: 'RwGsDeferredInstanceMigrator'
	instVarNames: #( classesToMigrate )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsDeferredInstanceMigrator
removeallclassmethods RwGsDeferredInstanceMigrator

doit
(Object
	subclass: 'RwGsPatch'
	instVarNames: #( packageDefinition projectDefinition )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'Abstract. A patch is a single operation to be performed on a GemStone image (repository).';
		immediateInvariant.
true.
%

removeallmethods RwGsPatch
removeallclassmethods RwGsPatch

doit
(RwGsPatch
	subclass: 'RwGsClassPatch'
	instVarNames: #( classDefinition )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassPatch( classDefinition packageDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsClassPatch
removeallclassmethods RwGsClassPatch

doit
(RwGsClassPatch
	subclass: 'RwGsClassAdditionSymbolDictPatch'
	instVarNames: #( newClass symbolAssociation )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassAdditionPatch( classDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsClassAdditionSymbolDictPatch
removeallclassmethods RwGsClassAdditionSymbolDictPatch

doit
(RwGsClassPatch
	subclass: 'RwGsClassConstraintsSymDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		immediateInvariant.
true.
%

removeallmethods RwGsClassConstraintsSymDictPatch
removeallclassmethods RwGsClassConstraintsSymDictPatch

doit
(RwGsClassPatch
	subclass: 'RwGsClassDeletionSymbolDictPatch'
	instVarNames: #( existingClass )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassDeletionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassDeletionPatch( classDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsClassDeletionSymbolDictPatch
removeallclassmethods RwGsClassDeletionSymbolDictPatch

doit
(RwGsClassPatch
	subclass: 'RwGsClassExtensionSymbolDictPatch'
	instVarNames: #( patchClass )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		immediateInvariant.
true.
%

removeallmethods RwGsClassExtensionSymbolDictPatch
removeallclassmethods RwGsClassExtensionSymbolDictPatch

doit
(RwGsClassPatch
	subclass: 'RwGsClassPropertiesSymDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassPropertiesPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassPatch( classDefinition packageDefinition)
      CypGsClassPropertiesPatch( propertiesModification)
';
		immediateInvariant.
true.
%

removeallmethods RwGsClassPropertiesSymDictPatch
removeallclassmethods RwGsClassPropertiesSymDictPatch

doit
(RwGsClassPatch
	subclass: 'RwGsClassSymbolDictionaryMoveSymDictPatch'
	instVarNames: #( classModification )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		immediateInvariant.
true.
%

removeallmethods RwGsClassSymbolDictionaryMoveSymDictPatch
removeallclassmethods RwGsClassSymbolDictionaryMoveSymDictPatch

doit
(RwGsClassPatch
	subclass: 'RwGsClassVariableChangeSymbolDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassVariableChangePatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassVariableChangePatch( oldClassDefinition newClassDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsClassVariableChangeSymbolDictPatch
removeallclassmethods RwGsClassVariableChangeSymbolDictPatch

doit
(RwGsClassPatch
	subclass: 'RwGsClassVersioningPatch'
	instVarNames: #( classModification oldClassVersion newClassVersion symbolAssociation )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassVersioningPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassVersioningPatch( oldClassDefinition newClassDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsClassVersioningPatch
removeallclassmethods RwGsClassVersioningPatch

doit
(RwGsClassPatch
	subclass: 'RwGsClassVersioningSymbolDictPatch'
	instVarNames: #( classModification oldClassVersion newClassVersion symbolAssociation )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsClassVersioningPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassVersioningPatch( oldClassDefinition newClassDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsClassVersioningSymbolDictPatch
removeallclassmethods RwGsClassVersioningSymbolDictPatch

doit
(RwGsPatch
	subclass: 'RwGsMethodPatch'
	instVarNames: #( isMeta methodDefinition classDefinition behavior selector compiledMethod )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsMethodPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsMethodPatch( isMeta methodDefinition classDefinition packageDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodPatch
removeallclassmethods RwGsMethodPatch

doit
(RwGsMethodPatch
	subclass: 'RwGsMethodAdditionSymbolDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsMethodAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsMethodAdditionPatch( isMeta methodDefinition classDefinition packageDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodAdditionSymbolDictPatch
removeallclassmethods RwGsMethodAdditionSymbolDictPatch

doit
(RwGsMethodPatch
	subclass: 'RwGsMethodDeletionSymbolDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsMethodDeletionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsMethodDeletionPatch( isMeta methodDefinition classDefinition packageDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodDeletionSymbolDictPatch
removeallclassmethods RwGsMethodDeletionSymbolDictPatch

doit
(RwGsMethodDeletionSymbolDictPatch
	subclass: 'RwGsMethodDeletionExtensionSymbolDictPatch'
	instVarNames: #( extendedClassName )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodDeletionExtensionSymbolDictPatch
removeallclassmethods RwGsMethodDeletionExtensionSymbolDictPatch

doit
(RwGsMethodDeletionExtensionSymbolDictPatch
	subclass: 'RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
removeallclassmethods RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch

doit
(RwGsMethodPatch
	subclass: 'RwGsMethodExtensionSymbolDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsMethodAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsMethodAdditionPatch( isMeta methodDefinition classDefinition packageDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodExtensionSymbolDictPatch
removeallclassmethods RwGsMethodExtensionSymbolDictPatch

doit
(RwGsMethodExtensionSymbolDictPatch
	subclass: 'RwGsMethodExtensionSessionMethodSymbolDictPatch'
	instVarNames: #( sessionDictsArray methDict catDict pArray )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodExtensionSessionMethodSymbolDictPatch
removeallclassmethods RwGsMethodExtensionSessionMethodSymbolDictPatch

doit
(RwGsMethodPatch
	subclass: 'RwGsMethodPropertiesSymDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsMethodPropertiesPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsMethodPatch( isMeta methodDefinition classDefinition packageDefinition)
      CypGsMethodPropertiesPatch( propertiesModification)
';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodPropertiesSymDictPatch
removeallclassmethods RwGsMethodPropertiesSymDictPatch

doit
(RwGsMethodPropertiesSymDictPatch
	subclass: 'RwGsMethodExtensionSessionMethodPropertiesSymDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodExtensionSessionMethodPropertiesSymDictPatch
removeallclassmethods RwGsMethodExtensionSessionMethodPropertiesSymDictPatch

doit
(RwGsMethodPatch
	subclass: 'RwGsMethodSourceSymbolDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodSourceSymbolDictPatch
removeallclassmethods RwGsMethodSourceSymbolDictPatch

doit
(RwGsMethodSourceSymbolDictPatch
	subclass: 'RwGsMethodExtensionSessionMethodSourceSymbolDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		immediateInvariant.
true.
%

removeallmethods RwGsMethodExtensionSessionMethodSourceSymbolDictPatch
removeallclassmethods RwGsMethodExtensionSessionMethodSourceSymbolDictPatch

doit
(RwGsPatch
	subclass: 'RwGsPackagePatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsPackagePatch, hierarchy is: 
Object
  CypGsPatch
    CypGsPackagePatch( packageDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsPackagePatch
removeallclassmethods RwGsPackagePatch

doit
(RwGsPackagePatch
	subclass: 'RwGsPackageAdditionSymbolDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsPackageAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsPackageAdditionPatch( packageDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsPackageAdditionSymbolDictPatch
removeallclassmethods RwGsPackageAdditionSymbolDictPatch

doit
(RwGsPackagePatch
	subclass: 'RwGsPackageDeletionSymbolDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsPackageAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsPackageAdditionPatch( packageDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsPackageDeletionSymbolDictPatch
removeallclassmethods RwGsPackageDeletionSymbolDictPatch

doit
(RwGsPackagePatch
	subclass: 'RwGsPackageMoveSymbolDictPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		immediateInvariant.
true.
%

removeallmethods RwGsPackageMoveSymbolDictPatch
removeallclassmethods RwGsPackageMoveSymbolDictPatch

doit
(RwGsPatch
	subclass: 'RwGsProjectPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsPackagePatch, hierarchy is: 
Object
  CypGsPatch
    CypGsPackagePatch( packageDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsProjectPatch
removeallclassmethods RwGsProjectPatch

doit
(RwGsProjectPatch
	subclass: 'RwGsProjectAdditionPatch'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'No class-specific documentation for CypGsPackageAdditionPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsPackageAdditionPatch( packageDefinition)
';
		immediateInvariant.
true.
%

removeallmethods RwGsProjectAdditionPatch
removeallclassmethods RwGsProjectAdditionPatch

doit
(Object
	subclass: 'RwGsPatchSet'
	instVarNames: #( instanceMigrator addedProjects addedPackages deletedPackages projectsWithPropertyChanges addedClasses deletedClasses deletedClassesMap movedClassesMap extendedClasses classesWithPropertyChanges classesWithSymbolDictionaryChanges classesWithClassVariableChanges classesWithNewVersions addedMethods deletedMethods deletedExtensionMethods deleteNewVersionMethods movedMethodsMap extendedMethods methodsWithPropertyChanges methodsNeedingRecompile pureMovedMethods tempSymbols createdClasses errors currentProjectDefinition )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'A set of patches (changes) to be applied atomically (or as close to atomically as possible) to a GemStone repository.';
		immediateInvariant.
true.
%

removeallmethods RwGsPatchSet
removeallclassmethods RwGsPatchSet

doit
(Object
	subclass: 'RwGsPatchSet_254'
	instVarNames: #( instanceMigrator addedProjects addedPackages deletedPackages movedPackages projectsWithPropertyChanges addedClasses deletedClasses movedClasses movedClassesMap extendedClasses classesWithPropertyChanges classesWithSymbolDictionaryChanges classesWithClassVariableChanges classesWithConstraintChanges classesWithNewVersions addedMethods deletedMethods deleteNewVersionMethods movedMethods extendedMethods methodsWithPropertyChanges methodsNeedingRecompile tempSymbols createdClasses errors currentProjectDefinition )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'A set of patches (changes) to be applied atomically (or as close to atomically as possible) to a GemStone repository.';
		immediateInvariant.
true.
%

removeallmethods RwGsPatchSet_254
removeallclassmethods RwGsPatchSet_254

doit
(Object
	subclass: 'RwGsSymbolDictionaryRegistry'
	instVarNames: #( symbolDictionary packageRegistry classRegistry classExtensionRegistry methodRegistry )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsSymbolDictionaryRegistry
removeallclassmethods RwGsSymbolDictionaryRegistry

doit
(Object
	subclass: 'RwGsSymbolDictionaryRegistry_Implementation'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanLoader
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Loader';
		comment: 'The Rowan-GemStone-Loader implementation does depend upon having a stable and consistent implementation of the RwGsSymbolDictionaryRegistry behavior for the duration of a load.

Right before a load, all of the classes that make up the Rowan-GemStone-Loader package are copied and isolated from the rest of the system, so that updates to the loader code itself will not change the behavior of the loader implementation while the load is in progress.

The class RwGsSymbolDictionaryRegistry is not part of the Rowan-GemStone-Loader package, because instance of the class are expected to have long lifetimes.

This class implements the behavior for RwGsSymbolDictionaryRegistry and since it is the Rowan-GemStone-Loader package, it can be copied and isolated during a load, without affecting the long lived instances of RwGsSymbolDictionaryRegistry.

The methods in the receiver (class-side only) have an extra `instance:` argument tacked on that refers to the instance of RwGsSymbolDictionaryRegistry that was the original target of the message. For example:

	RwGsSymbolDictionaryRegistry_implementation class>>addClassAssociation:forClass:toPackageNamed:instance:

The methods in RwGsSymbolDictionaryRegistry are implemented with a compiled in reference to the RwGsSymbolDictionaryRegistry_implementation class as follows:

	addClassAssociation: assoc forClass: class toPackageNamed: packageName

		^ RwGsSymbolDictionaryRegistry_implementation addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self

This form is adequate for message sends from classes outside of the Rowan-GemStone-Loader package.

Inside the Rowan-GemStone-Loader package, the messgaes sends must pass in a reference to the `RwGsSymbolDictionaryRegistry_implementation`. This reference will refer to the cloned copy of the class when the RowanLoader symbol dictionary is cloned. The methods have and extra `implementationClass:` that refers to the class and allows the caller to pass in a reference to the cloned class. For example:

	addClassAssociation: assoc forClass: class toPackageNamed: packageName implementationClass: implementationClass

		"Copy the name association to the correct 
			SymbolDictionary in the live SymbolList.
			Create a LoadedClass for the new class, add it to the defining LoadedPackage."

		^ implementationClass addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self';
		immediateInvariant.
true.
%

removeallmethods RwGsSymbolDictionaryRegistry_Implementation
removeallclassmethods RwGsSymbolDictionaryRegistry_Implementation

doit
(Object
	subclass: 'RwLoadedThing'
	instVarNames: #( properties name handle )
	classVars: #( AbsentToken )
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'properties: dictionary of properties
name: name of class or package, selector of method
handle: reference to the class or method object, or to the native package object for dialects that have that.';
		immediateInvariant.
true.
%

removeallmethods RwLoadedThing
removeallclassmethods RwLoadedThing

doit
(RwLoadedThing
	subclass: 'RwLoadedClass'
	instVarNames: #( loadedPackage loadedInstanceMethods loadedClassMethods )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'package: the CypLoadedPackage that defines me and all my methods that are not extension methods.
extensions: a collection of CypLoadedExtendedClasses for this class. From these we can tell which methods don''t belong to our default package.';
		immediateInvariant.
true.
%

removeallmethods RwLoadedClass
removeallclassmethods RwLoadedClass

doit
(RwLoadedClass
	subclass: 'RwGsLoadedSymbolDictClass'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsLoadedSymbolDictClass
removeallclassmethods RwGsLoadedSymbolDictClass

doit
(RwLoadedThing
	subclass: 'RwLoadedClassExtension'
	instVarNames: #( loadedPackage loadedInstanceMethods loadedClassMethods )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypLoadedClassExtension, hierarchy is: 
Object
  CypLoadedThing( properties name handle)
    CypLoadedClassExtension( loadedPackage loadedMethods)
';
		immediateInvariant.
true.
%

removeallmethods RwLoadedClassExtension
removeallclassmethods RwLoadedClassExtension

doit
(RwLoadedClassExtension
	subclass: 'RwGsLoadedSymbolDictClassExtension'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsLoadedSymbolDictClassExtension
removeallclassmethods RwGsLoadedSymbolDictClassExtension

doit
(RwLoadedThing
	subclass: 'RwLoadedMethod'
	instVarNames: #( loadedClass classIsMeta )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypLoadedMethod, hierarchy is: 
Object
  CypLoadedThing( properties name handle)
    CypLoadedMethod
';
		immediateInvariant.
true.
%

removeallmethods RwLoadedMethod
removeallclassmethods RwLoadedMethod

doit
(RwLoadedMethod
	subclass: 'RwGsLoadedSymbolDictMethod'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		comment: 'The MethodRegistry maps GsNMethods to LoadedMethods.';
		immediateInvariant.
true.
%

removeallmethods RwGsLoadedSymbolDictMethod
removeallclassmethods RwGsLoadedSymbolDictMethod

doit
(RwLoadedThing
	subclass: 'RwLoadedPackage'
	instVarNames: #( repository commitId loadedClasses loadedClassExtensions isDirty loadedProject )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'repository: The repository I was loaded from (if known, nil otherwise)
commitId: A repository-specific way of identifying source code commit, if it''s a type of repository that has that kind of information (nil otherwise)
loadedClasses: Dictionary -- keys are (non-meta) classes, values are the LoadedClasses that I define.
loadedClassExtensions: -- Dictionary -- keys are (non-meta) classes, values are the LoadedClassExtensions that I define.';
		immediateInvariant.
true.
%

removeallmethods RwLoadedPackage
removeallclassmethods RwLoadedPackage

doit
(RwLoadedPackage
	subclass: 'RwGsLoadedSymbolDictPackage'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsLoadedSymbolDictPackage
removeallclassmethods RwGsLoadedSymbolDictPackage

doit
(RwLoadedThing
	subclass: 'RwLoadedProject'
	instVarNames: #( loadedPackages isDirty )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwLoadedProject
removeallclassmethods RwLoadedProject

doit
(RwLoadedProject
	subclass: 'RwGsLoadedSymbolDictProject'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwGsLoadedSymbolDictProject
removeallclassmethods RwGsLoadedSymbolDictProject

doit
(Object
	subclass: 'RwMethodAdditionOrRemoval'
	instVarNames: #( projectDefinition packageDefinition classDefinitionOrExtension methodKey isMeta methodsModification )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypMethodAdditionOrRemoval, hierarchy is: 
Object
  CypMethodAdditionOrRemoval( packageDefinition classDefinitionOrExtension methodKey isMeta methodsModification)
';
		immediateInvariant.
true.
%

removeallmethods RwMethodAdditionOrRemoval
removeallclassmethods RwMethodAdditionOrRemoval

doit
(Object
	subclass: 'RwModification'
	instVarNames: #( propertiesModification before after )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Abstract. Represents a modification to some code entity. "Modification" means that the code entity exists both before and after, but has differences in some of its elements.

Instvars:

before		A definition of the state before the modification
after		A definition of state after the modification';
		immediateInvariant.
true.
%

removeallmethods RwModification
removeallclassmethods RwModification

doit
(RwModification
	subclass: 'RwClassModification'
	instVarNames: #( instanceMethodsModification classMethodsModification )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single class definition or class extension.

Instvars:

propertiesModification			PropertiesModification -- changes to class or class extension properties
instanceMethodsModification	MethodsModification -- changes to instance methods defined
classMethodsModification		MethodsModification -- changes to class methods defined';
		immediateInvariant.
true.
%

removeallmethods RwClassModification
removeallclassmethods RwClassModification

doit
(RwClassModification
	subclass: 'RwClassExtensionModification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwClassExtensionModification
removeallclassmethods RwClassExtensionModification

doit
(RwClassModification
	subclass: 'RwClassModificationForcingNewClassVersion'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		immediateInvariant.
true.
%

removeallmethods RwClassModificationForcingNewClassVersion
removeallclassmethods RwClassModificationForcingNewClassVersion

doit
(RwModification
	subclass: 'RwMethodModification'
	instVarNames: #( sourceModification isMeta classDefinition )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single method

Instvars:

propertiesModification			PropertiesModification -- changes to method properties
oldSource						String -- source code before
newSource						String -- source code after';
		immediateInvariant.
true.
%

removeallmethods RwMethodModification
removeallclassmethods RwMethodModification

doit
(RwMethodModification
	subclass: 'RwExtensionMethodModification'
	instVarNames: #( extendedClassName )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExtensionMethodModification
removeallclassmethods RwExtensionMethodModification

doit
(RwMethodModification
	subclass: 'RwMethodModificationForNewClassVersion'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwMethodModificationForNewClassVersion
removeallclassmethods RwMethodModificationForNewClassVersion

doit
(RwMethodModificationForNewClassVersion
	subclass: 'RwExtensionMethodModificationForNewClassVersion'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwExtensionMethodModificationForNewClassVersion
removeallclassmethods RwExtensionMethodModificationForNewClassVersion

doit
(RwModification
	subclass: 'RwPackageModification'
	instVarNames: #( classesModification classExtensionsModification )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single package.

Instvars:

propertiesModification			PropertiesModification -- changes to package properties
classesModification				ClassesModification -- changes to classes defined
classExtensionsModification		ClassesModificaiton -- changes to classes extended';
		immediateInvariant.
true.
%

removeallmethods RwPackageModification
removeallclassmethods RwPackageModification

doit
(RwModification
	subclass: 'RwProjectModification'
	instVarNames: #( packagesModification )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents modifications to a single package.

Instvars:

propertiesModification			PropertiesModification -- changes to package properties
classesModification				ClassesModification -- changes to classes defined
classExtensionsModification		ClassesModificaiton -- changes to classes extended';
		immediateInvariant.
true.
%

removeallmethods RwProjectModification
removeallclassmethods RwProjectModification

doit
(Object
	subclass: 'RwMove'
	instVarNames: #( projectBefore projectAfter packageBefore packageAfter )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwMove
removeallclassmethods RwMove

doit
(RwMove
	subclass: 'RwClassExtensionMove'
	instVarNames: #( classExtensionBefore classExtensionAfter )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwClassExtensionMove
removeallclassmethods RwClassExtensionMove

doit
(RwMove
	subclass: 'RwClassMove'
	instVarNames: #( classBefore classAfter )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents the move of a class definition from one package to another.';
		immediateInvariant.
true.
%

removeallmethods RwClassMove
removeallclassmethods RwClassMove

doit
(RwMove
	subclass: 'RwMethodMove'
	instVarNames: #( methodBefore methodAfter isMeta classOrExtensionBefore classOrExtensionAfter )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'Represents a move of a method from a class definition to a class extension, or from a class extension to a class definition, or between two extensions, of the same class. This should always also result in a change of package, since a class should not be defined and extended in the same package, nor extended twice in the same package.';
		immediateInvariant.
true.
%

removeallmethods RwMethodMove
removeallclassmethods RwMethodMove

doit
(RwMove
	subclass: 'RwPackageMove'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		immediateInvariant.
true.
%

removeallmethods RwPackageMove
removeallclassmethods RwPackageMove

doit
(Object
	subclass: 'RwPlatform'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Kernel';
		comment: 'Provides services specific to the Smalltalk dialect being run,
and locates other services that are dialect-specific.';
		immediateInvariant.
true.
%

removeallmethods RwPlatform
removeallclassmethods RwPlatform

doit
(RwPlatform
	subclass: 'RwGsPlatform'
	instVarNames: #( alternateImageClass enableInstanceMigration instanceMigrator )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Core';
		comment: 'This class is private to Cypress.
A GsPlatform is the gateway object for requesting platform-specific actions.';
		immediateInvariant.
true.
%

removeallmethods RwGsPlatform
removeallclassmethods RwGsPlatform

doit
(Object
	subclass: 'RwProjectLoadConfigurationVisitor'
	instVarNames: #( packageNames packageMapSpecs visitedConfigurationNames platformAttributes definedGroupNames groupNames configurationNames configurationBasePath )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwProjectLoadConfigurationVisitor
removeallclassmethods RwProjectLoadConfigurationVisitor

doit
(RwProjectLoadConfigurationVisitor
	subclass: 'RwProjectLoadConfigurationAnalysisVisitor'
	instVarNames: #( visitedConfigurationMap packageToConfigurationMap )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Configurations';
		immediateInvariant.
true.
%

removeallmethods RwProjectLoadConfigurationAnalysisVisitor
removeallclassmethods RwProjectLoadConfigurationAnalysisVisitor

doit
(Object
	subclass: 'RwPropertyModification'
	instVarNames: #( key oldValue newValue )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypPropertyModification, hierarchy is: 
Object
  CypDiff( changes)
    CypLeafModification( key before after)
      CypPropertyModification
';
		immediateInvariant.
true.
%

removeallmethods RwPropertyModification
removeallclassmethods RwPropertyModification

doit
(RwPropertyModification
	subclass: 'RwPropertyModificationForUpgrade'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'I am used during upgrade to force method recompilation during a load when 
all methods must be recompiled (i.e., upgrade vrom 3.2.15 to 3.6.2)';
		immediateInvariant.
true.
%

removeallmethods RwPropertyModificationForUpgrade
removeallclassmethods RwPropertyModificationForUpgrade

doit
(RwPropertyModification
	subclass: 'RwUnconditionalPropertyModification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Core';
		comment: 'No class-specific documentation for CypPropertyModification, hierarchy is: 
Object
  CypDiff( changes)
    CypLeafModification( key before after)
      CypPropertyModification
';
		immediateInvariant.
true.
%

removeallmethods RwUnconditionalPropertyModification
removeallclassmethods RwUnconditionalPropertyModification

doit
(Object
	subclass: 'RwSpecification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwSpecification
removeallclassmethods RwSpecification

doit
(RwSpecification
	subclass: 'RwImageSpecification'
	instVarNames: #( loadedCommitId loadedConfigurationNames loadedGroupNames repositoryUrl )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwImageSpecification
removeallclassmethods RwImageSpecification

doit
(RwImageSpecification
	subclass: 'RwPackageProjectImageSpecification'
	instVarNames: #( loadedPackageNames )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Deprecated';
		immediateInvariant.
true.
%

removeallmethods RwPackageProjectImageSpecification
removeallclassmethods RwPackageProjectImageSpecification

doit
(RwImageSpecification
	subclass: 'RwSimpleProjectImageSpecification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwSimpleProjectImageSpecification
removeallclassmethods RwSimpleProjectImageSpecification

doit
(RwSpecification
	subclass: 'RwPlatformSpecification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwPlatformSpecification
removeallclassmethods RwPlatformSpecification

doit
(RwPlatformSpecification
	subclass: 'RwGemStoneSpecification'
	instVarNames: #( defaultMethodEnv defaultSymbolDictName defaultUseSessionMethodsForExtensions packageNameToPlatformPropertiesMap projectOwnerId )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-GemStone-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwGemStoneSpecification
removeallclassmethods RwGemStoneSpecification

doit
(RwSpecification
	subclass: 'RwProjectSpecification'
	instVarNames: #( specName version projectUrl platformSpec configsPath specsPath repoSpec repoPath comment imageSpec defaultConfigurationNames defaultGroupNames )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwProjectSpecification
removeallclassmethods RwProjectSpecification

doit
(RwProjectSpecification
	subclass: 'RwPackageProjectSpecification'
	instVarNames: #( packageNames packageNamesInLoadOrder packageNamesToLoad )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Deprecated';
		comment: 'RwPackageLoadSpecification new
    specName: ''rowanLoadSpec'';
    packageNames:
        #(''Cypress-Core'' ''Rowan-Core'' ''Rowan-GemStone'' ''Rowan-Tests'' ''Rowan-Tode'');
    packageNamesToLoad:
        #(''Cypress-Core'' ''Rowan-Core'' ''Rowan-GemStone'' ''Rowan-Tests'');
    repositoryUrl:
        ''tonel:/export/foos1/users/dhenrich/dev/_home/shared/repos/rowan/CypressReferenceImplementation/tonel/'';
    exportToUrl:
        ''file:/export/foos1/users/dhenrich/dev/_home/shared/repos/rowan/CypressReferenceImplementation/''';
		immediateInvariant.
true.
%

removeallmethods RwPackageProjectSpecification
removeallclassmethods RwPackageProjectSpecification

doit
(RwProjectSpecification
	subclass: 'RwSimpleProjectSpecification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		comment: 'RwPackageLoadSpecification new
    specName: ''rowanLoadSpec'';
    packageNames:
        #(''Cypress-Core'' ''Rowan-Core'' ''Rowan-GemStone'' ''Rowan-Tests'' ''Rowan-Tode'');
    packageNamesToLoad:
        #(''Cypress-Core'' ''Rowan-Core'' ''Rowan-GemStone'' ''Rowan-Tests'');
    repositoryUrl:
        ''tonel:/export/foos1/users/dhenrich/dev/_home/shared/repos/rowan/CypressReferenceImplementation/tonel/'';
    exportToUrl:
        ''file:/export/foos1/users/dhenrich/dev/_home/shared/repos/rowan/CypressReferenceImplementation/''';
		immediateInvariant.
true.
%

removeallmethods RwSimpleProjectSpecification
removeallclassmethods RwSimpleProjectSpecification

doit
(RwSpecification
	subclass: 'RwReferenceSpecification'
	instVarNames: #( referenceUrl )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwReferenceSpecification
removeallclassmethods RwReferenceSpecification

doit
(RwSpecification
	subclass: 'RwRepositorySpecification'
	instVarNames: #( repositoryRootPath )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwRepositorySpecification
removeallclassmethods RwRepositorySpecification

doit
(RwRepositorySpecification
	subclass: 'RwDiskRepositorySpecification'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwDiskRepositorySpecification
removeallclassmethods RwDiskRepositorySpecification

doit
(RwRepositorySpecification
	subclass: 'RwGitRepositorySpecification'
	instVarNames: #( committish committishType remote )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanTools
	options: #( #logCreation )
)
		category: 'Rowan-Specifications';
		immediateInvariant.
true.
%

removeallmethods RwGitRepositorySpecification
removeallclassmethods RwGitRepositorySpecification

doit
(Object
	subclass: 'RwUrl'
	instVarNames: #( fragment )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.

The classes in this hierarchy:

RwUrl
 RwFileUrl
  RwCypressUrl
  RwFiletreeUrl
   RwTonelUrl
  RwGithubUrl
 RwGenericUrl
 RwHierarchicalUrl
  RwSmalltalkRepositoryUrl
   RwGitFileTreeUrl

are specificaly designed for parsing URLS for Rowan source code repositories:

 file:/opt/git/shared/repos/rowan/sample/repository
 http://gsdevkit.github.io/GsDevKit_home/rowan/Sample.ston
 https://raw.githubusercontent.com/dalehenrich/sample/master/specs/Sample.ston

 github://GsDevKit/GsDevKit:master/repository
 filetree:///opt/git/shared/repos/rowan/sample/repository
 tonel:/opt/git/shared/repos/rowan/sample/repository
 gitfiletree://gitlab.com/GsDevKit/GsDevKit:master/repository

 cypress:/opt/git/shared/repos/rowan/sample/repository/
 smalltalk://dkh:pass@gitlab.ferlicot.fr:3456/Projet/Bazard:dev/src
 smalltalk://git@git.gemtalksystems.com/btree340:dev/repository
 smalltalk://git@github.com/GsDevKit/GsDevKit:350/repository
 smalltalk://github.com/GsDevKit/GsDevKit:350/repository


The file:, http: and https: schemes should conform to the standard specs. ZnUrl is used for parsing http: and https: urls.

The github:, filetree:, gitfiletree: and tonel: schemes are supported for backward compatibility with schemes that have historically been used to identify Metacello repository urls.

The cypress: and smalltalk: schemes are new and intended to be used moving forward with Metacello and Rowan.

The cypress: url is used to indicate that path to a Cypress-style repository, i.e., a disk-based format for storing Smalltalk packages in filetree or tonel format. A cypress: url does not define the specific repository type (filetree or tonel). The type of the repository is encoded in a .filetree file located in the directory specified by pathString of the url.

The smalltalk: scheme is based on Thierry Goubier''s gitfiletree url[1]. The original github: scheme cannot be used for arbitrary git servers or git servers using non-standard ports or requiring usernames and passwords. Thierry''s scheme handles the full range of possibilites.

[1] https://github.com/dalehenrich/filetree/blob/734eed46ea57ebf5e24e5d935768bd49727fc22f/repository/MonticelloFileTree-Git.package/MCFileTreeGitRepository.class/class/basicFromUrl..st';
		immediateInvariant.
true.
%

removeallmethods RwUrl
removeallclassmethods RwUrl

doit
(RwUrl
	subclass: 'RwFileUrl'
	instVarNames: #( host path isAbsolute )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'This class models a file URL according to (somewhat) RFC1738, see http://www.w3.org/Addressing/rfc1738.txt

Here is the relevant part of the RFC:

3.10 FILES

   The file URL scheme is used to designate files accessible on a
   particular host computer. This scheme, unlike most other URL schemes,
   does not designate a resource that is universally accessible over the
   Internet.

   A file URL takes the form:

       file://<host>/<path>

   where <host> is the fully qualified domain name of the system on
   which the <path> is accessible, and <path> is a hierarchical
   directory path of the form <directory>/<directory>/.../<name>.

   For example, a VMS file

     DISK$USER:[MY.NOTES]NOTE123456.TXT

   might become

     <URL:file://vms.host.edu/disk$user/my/notes/note12345.txt>

   As a special case, <host> can be the string "localhost" or the empty
   string; this is interpreted as `the machine from which the URL is
   being interpreted''.

   The file URL scheme is unusual in that it does not specify an
   Internet protocol or access method for such files; as such, its
   utility in network protocols between hosts is limited.

From the above we can conclude that the RFC says that the <path> part never starts or ends with a slash and is always absolute. If the last name can be a directory instead of a file is not specified clearly.

The path is stored as a SequenceableCollection of path parts.

Notes regarding non RFC features in this class:

- If the last path part is the empty string, then the FileUrl is referring to a directory. This is also shown with a trailing slash when converted to a String.

- The FileUrl has an attribute isAbsolute which signals if the path should be considered absolute or relative to the current directory. This distinction is not visible in the String representation of FileUrl, since the RFC does not have that.

- Fragment is supported (kept for historical reasons)

';
		immediateInvariant.
true.
%

removeallmethods RwFileUrl
removeallclassmethods RwFileUrl

doit
(RwFileUrl
	subclass: 'RwCypressUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'This class implements the cypress: scheme:

 cypress:/opt/git/shared/repos/rowan/sample/repository/

The cypress: url specifies the file system path to the directory where a disk-based Smalltalk package repository resides. The name comes from the original name used to specifay a cross-platform package disk layout[1].

This url does not encode the specific disk format used by the repository (like the filetree: and tonel: schemes). The disk format is specified in a .cypress file in the directory using STON ike the following:

  { #format : ''filetree'' }
  { #format : ''tonel'' }
  { #format : ''cypress'' }

When the cypress: url is resolved, the appropriate platform-specific repository reader will be used to read the packages from disk.

[1] https://raw.githubusercontent.com/CampSmalltalk/Cypress/master/img/CypressStructure-STIC2012.png';
		immediateInvariant.
true.
%

removeallmethods RwCypressUrl
removeallclassmethods RwCypressUrl

doit
(RwCypressUrl
	subclass: 'RwTonelUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'This class implements the tonel: scheme:

  tonel:/opt/git/shared/repos/rowan/sample/repository

The scheme is supported for backward compatibility with the tonel disk format[1]. Not sure whether it''s use has made it into the wild, but it _is_ currently being used in the Rowan implementation.

[1] https://github.com/pharo-vcs/tonel';
		immediateInvariant.
true.
%

removeallmethods RwTonelUrl
removeallclassmethods RwTonelUrl

doit
(RwFileUrl
	subclass: 'RwFiletreeUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'This class implements the filetree: scheme[1]:

 filetree:///opt/git/shared/repos/rowan/sample/repository

This scheme is supported for backward compatibility. Moving forward the cypress: scheme should be used (see RwCypressUrl).

[1] https://github.com/Metacello/metacello/blob/master/docs/MetacelloScriptingAPI.md#filetree';
		immediateInvariant.
true.
%

removeallmethods RwFiletreeUrl
removeallclassmethods RwFiletreeUrl

doit
(RwFileUrl
	subclass: 'RwGithubUrl'
	instVarNames: #( project committish dir )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'This class implements the github: scheme[1]:

  github://GsDevKit/GsDevKit:master/repository

This scheme is supported for backward compatibility. Moving forward the metacello: scheme should be used (see RwMetacelloRepositoryUrl).

[1] https://github.com/Metacello/metacello/blob/master/docs/MetacelloScriptingAPI.md#github';
		immediateInvariant.
true.
%

removeallmethods RwGithubUrl
removeallclassmethods RwGithubUrl

doit
(RwUrl
	subclass: 'RwGenericUrl'
	instVarNames: #( schemeName locator )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'a URL type that can''t be broken down in any systematic way.  For example, mailto: and telnet: URLs.  The part after the scheme name is stored available via the #locator message.';
		immediateInvariant.
true.
%

removeallmethods RwGenericUrl
removeallclassmethods RwGenericUrl

doit
(RwUrl
	subclass: 'RwHierarchicalUrl'
	instVarNames: #( schemeName authority path query port username password )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'A URL which has a hierarchical encoding.  For instance, http and ftp URLs are hierarchical.';
		immediateInvariant.
true.
%

removeallmethods RwHierarchicalUrl
removeallclassmethods RwHierarchicalUrl

doit
(RwHierarchicalUrl
	subclass: 'RwSmalltalkRepositoryUrl'
	instVarNames: #( project committish dir )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'This class implements the smalltalk: scheme:

 smalltalk://dkh:pass@gitlab.ferlicot.fr:3456/Projet/Bazard:dev/src
 smalltalk://git@git.gemtalksystems.com/btree340:dev/repository
 smalltalk://git@github.com/GsDevKit/GsDevKit:350/repository
 smalltalk://github.com/GsDevKit/GsDevKit:350/repository

The smalltalk: scheme is based on Thierry Goubier''s gitfiletree url[1]:

  smalltalk:// <[user[:password]@]host[:port]> / user/ projectName [ : versionIdentifier ] [ / repositoryPath ]

[1] https://github.com/dalehenrich/filetree/blob/734eed46ea57ebf5e24e5d935768bd49727fc22f/repository/MonticelloFileTree-Git.package/MCFileTreeGitRepository.class/class/basicFromUrl..st';
		immediateInvariant.
true.
%

removeallmethods RwSmalltalkRepositoryUrl
removeallclassmethods RwSmalltalkRepositoryUrl

doit
(RwSmalltalkRepositoryUrl
	subclass: 'RwGitFileTreeUrl'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: RowanKernel
	options: #( #logCreation )
)
		category: 'Rowan-Url-Core';
		comment: 'This class implements the gitfiletree: scheme:

 gitfiletree://gitlab.com/GsDevKit/GsDevKit:master/repository

The gitfiletree scheme [1] encodes the following information:

  gitfiletree:// [ user [ : password ] @ ] host [ : port ] / user / project [ : branch ] [ / repositoryPath ]

From the method comment[1]:

  Parameters are:
		dir : the directory inside the repository where the target MC packages are.
		branch : the git branch to fetch.
		protocol: the user name part to add to the ssh Url, default to git, but can also be https (which implies read only access).
		readOnly : is the repository read only? If present, reduce the history to a minimum (and change the GUI).
	Alternative url syntax:
		gitfiletree://github.com/dalehenrich/filetree:pharo5.0_dev/repository
	with:
		host : github.com
		project : dalehenrich/filetree
		branch : pharo5.0_dev
		dir : repository

[1] https://github.com/dalehenrich/filetree/blob/734eed46ea57ebf5e24e5d935768bd49727fc22f/repository/MonticelloFileTree-Git.package/MCFileTreeGitRepository.class/class/basicFromUrl..st';
		immediateInvariant.
true.
%

removeallmethods RwGitFileTreeUrl
removeallclassmethods RwGitFileTreeUrl

doit
(Object
	subclass: 'TonelParser'
	instVarNames: #( packageReader stream lastSelectorParsed )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Tonel-Core';
		comment: 'I''m a parser for tonel files. 
I parse a class with the following format: 

Tonel spec
====

    [comment]
    type { typeDefinition }
    (
        [{ methodMetadata }]
        method [
            methodBody ] 
    )*


comment
---
"
comment string
"
is optional (but it should be there, in good design ;)

type
---
Class|Trait|Extension

typeDefinition
---
a STON file with class/trait/extension metadata

methodMetadata
---
a STON file with method metadata
is optional (but also, recommended)

method
---
method declaration as this: 

Class[ class] >> selector

methodBody 
---
the method body (we do not parse contents, that''s class builder task)';
		immediateInvariant.
true.
%

removeallmethods TonelParser
removeallclassmethods TonelParser

doit
(Object
	subclass: 'TonelWriter'
	instVarNames: #( packageWriter )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Tonel-Core';
		immediateInvariant.
true.
%

removeallmethods TonelWriter
removeallclassmethods TonelWriter

doit
(STONWriter
	subclass: 'TonelSTONWriter'
	instVarNames: #( aliases )
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Tonel-Core';
		comment: 'I''m a modified STON writer to make tonel metadata look as we want.

- it accept aliasses for classes, so I can say OrderedDictionary -> nil (then I do not have an extra information I do not want). Btw, tonel needs to use ordered dictionaries instead plain dictionaries because output needs to be deterministic, and we want to control the order of attributes we publish.
- if dictionary has just one element, it prints it in just one line, to have a more compact view.';
		immediateInvariant.
true.
%

removeallmethods TonelSTONWriter
removeallclassmethods TonelSTONWriter

doit
(WriteStream
	subclass: 'CypressMessageDigestStream'
	instVarNames: #()
	classVars: #()
	classInstVars: #()
	poolDictionaries: #()
	inDictionary: Globals
	options: #( #logCreation )
)
		category: 'Cypress-MesssageDigest';
		comment: 'All Cypress classes are private to GemStone and are likely to be removed in a future release.';
		immediateInvariant.
true.
%

removeallmethods CypressMessageDigestStream
removeallclassmethods CypressMessageDigestStream

! Class implementation for 'CypressLoaderError'

!		Class methods for 'CypressLoaderError'

category: 'instance creation'
classmethod: CypressLoaderError
patchOperation: aPatchOperation exception: anException

	^self new
		initializePatchOperation: aPatchOperation exception: anException;
		yourself
%

!		Instance methods for 'CypressLoaderError'

category: 'accessing'
method: CypressLoaderError
exception
	"Answer the original exception raised when applying the Patch Operation."

	^exception
%

category: 'updating'
method: CypressLoaderError
exception: anException
	"Assign the original exception raised when applying the Patch Operation."

	exception := anException
%

category: 'initializing - private'
method: CypressLoaderError
initialize

	super initialize.
	gsResumable := true
%

category: 'initializing - private'
method: CypressLoaderError
initializeMessageText

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	stream
		nextPutAll: self patchOperation printString;
		nextPutAll: ' failed because ';
		nextPutAll: self exception printString.
	messageText := stream contents
%

category: 'initializing - private'
method: CypressLoaderError
initializePatchOperation: aPatchOperation exception: anException

	self
		patchOperation: aPatchOperation;
		exception: anException;
		initializeMessageText
%

category: 'handling'
method: CypressLoaderError
logNotification: aString

	GsFile gciLogServer: aString.
	Transcript cr; nextPutAll: aString.
%

category: 'accessing'
method: CypressLoaderError
patchOperation
	"Answer the Patch Operation that could not be applied."

	^patchOperation
%

category: 'updating'
method: CypressLoaderError
patchOperation: aCypressPatchOperation
	"Assign the Patch Operation that could not be applied."

	patchOperation := aCypressPatchOperation
%

! Class implementation for 'CypressLoaderMissingClasses'

!		Class methods for 'CypressLoaderMissingClasses'

category: 'instance creation'
classmethod: CypressLoaderMissingClasses
missingRequirementsMap: aDictionary
	"Answer an instance of the receiver initialized on the specified
	 missing requirements. aDictionary maps prerequisite names to
	 a collection of dependent definitions."

	^self new
		initializeRequirementsMap: aDictionary;
		yourself
%

!		Instance methods for 'CypressLoaderMissingClasses'

category: 'initializing - private'
method: CypressLoaderMissingClasses
initialize

	super initialize.
	gsResumable := true
%

category: 'initializing - private'
method: CypressLoaderMissingClasses
initializeMessageText

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	stream nextPutAll: 'Missing classes:'.
	self requirementsMap keysAndValuesDo: 
			[:className :definitions |
			stream
				space;
				nextPutAll: className printString , '(' , definitions size printString
							, ')'].
	messageText := stream contents
%

category: 'initializing - private'
method: CypressLoaderMissingClasses
initializeRequirementsMap: aDictionary

	self
		requirementsMap: aDictionary;
		initializeMessageText.
%

category: 'accessing'
method: CypressLoaderMissingClasses
requirementsMap
	"The requirements map is a Dictionary mapping missing class
	 names to a collection of dependent definitions."

   ^requirementsMap
%

category: 'updating'
method: CypressLoaderMissingClasses
requirementsMap: aDictionary
	"The requirements map is a Dictionary mapping missing class
	 names to a collection of dependent definitions."

	requirementsMap := aDictionary
%

! Class implementation for 'RwGemStoneVersionNumber'

!		Class methods for 'RwGemStoneVersionNumber'

category: 'instance creation'
classmethod: RwGemStoneVersionNumber
fromString: aString

	| new components |
	components := OrderedCollection new.
	(aString substrings: '.') do: [:subString | 
		components add: subString asInteger].
	new := self new: components size.
	1 to: components size do: [:i | new at: i put: (components at: i) ].
	^new
%

!		Instance methods for 'RwGemStoneVersionNumber'

category: 'comparing'
method: RwGemStoneVersionNumber
< aRwGemStoneVersionNumber

	| condensed aCondensed |
	aRwGemStoneVersionNumber species = self species
		ifFalse: [ ^ false ].
	condensed := self collapseZeros.
	aCondensed := aRwGemStoneVersionNumber collapseZeros.
	(condensed ~~ self or: [ aCondensed ~~ aRwGemStoneVersionNumber ])
		ifTrue: [ ^ condensed compareLessThan: aCondensed ].
	^ self compareLessThan: aRwGemStoneVersionNumber
%

category: 'comparing'
method: RwGemStoneVersionNumber
= aRwGemStoneVersionNumber

	| condensed aCondensed |
	aRwGemStoneVersionNumber species = self species
		ifFalse: [ ^ false ].
	condensed := self collapseZeros.
	aCondensed := aRwGemStoneVersionNumber collapseZeros.
	(condensed ~~ self or: [ aCondensed ~~ aRwGemStoneVersionNumber ])
		ifTrue: [ ^ condensed compareEqualTo: aCondensed ].
	^ self compareEqualTo: aRwGemStoneVersionNumber
%

category: 'accessing'
method: RwGemStoneVersionNumber
approximateBase

	| base condensed |
	condensed := self collapseZeros.
	base := condensed copyFrom: 1 to: condensed size - 1.
	base at: base size put: (base at: base size) + 1.
	^base
%

category: 'converting'
method: RwGemStoneVersionNumber
asRwGemStoneVersionNumber

	^self
%

category: 'printing'
method: RwGemStoneVersionNumber
asString
	"Answer a string that represents the receiver."

	^ self printString
%

category: 'private'
method: RwGemStoneVersionNumber
collapseZeros
	"the rule must be that zeros can be collapsed as long as the series of zeros ends in a 0"

	| collection newSize new j lastElementIsStringOrZero canCollapse |
	(self size = 0 or: [ self at: 1 ]) == 0
		ifTrue: [ ^ self ].
	collection := OrderedCollection new.
	lastElementIsStringOrZero := true.
	canCollapse := true.
	self size to: 1 by: -1 do: [ :i | 
		| element |
		element := self at: i.
		(canCollapse and: [ element == 0 ])
			ifTrue: [ 
				lastElementIsStringOrZero
					ifFalse: [ 
						canCollapse := false.
						collection addFirst: element.]]
			ifFalse: [ 
				collection addFirst: element.
				canCollapse := lastElementIsStringOrZero := element isString ] ].
	collection size = self size
		ifTrue: [ ^ self ].
	newSize := collection size.
	new := self species new: newSize.
	j := 0.
	collection
		do: [ :element | 
			new at: j + 1 put: element.
			j := j + 1 ].
	^ new
%

category: 'private'
method: RwGemStoneVersionNumber
compareEqualTo: aRwGemStoneVersionNumber

	| mySize |
	aRwGemStoneVersionNumber species = self species ifFalse: [ ^false ].
	mySize := self size.
	mySize = aRwGemStoneVersionNumber size 
		ifFalse: [ ^false ].
	1 to: mySize do: [:i |
		(self at: i) = (aRwGemStoneVersionNumber at: i) ifFalse: [ ^false ]].
	^true
%

category: 'private'
method: RwGemStoneVersionNumber
compareLessThan: aRwGemStoneVersionNumber

	| mySize aSize commonSize count more |
	mySize := self size.
	aSize := aRwGemStoneVersionNumber size.
	commonSize :=  mySize min: aSize.
	count := 0.
	more := true.
	[ more and: [ count < commonSize ]] whileTrue: [
		(self at: count + 1) = (aRwGemStoneVersionNumber at: count + 1)
			ifTrue: [ count := count + 1 ]
			ifFalse: [ more := false ]].
	count < commonSize
		ifTrue: [ 
			^(self at: count + 1) < (aRwGemStoneVersionNumber at: count + 1) ].
	mySize < aSize
		ifTrue: [ 
			mySize = 0 ifTrue: [ ^true ].
			"if the versions at commonSize are equal and the next version slot in aRwGemStoneVersionNumber 
			 is a string, then it's considered that I'm > aRwGemStoneVersionNumber
			 (i.e., '2.9.9' is greater than '2.9.9-alpha.2')"
			(self at: commonSize) = (aRwGemStoneVersionNumber at: commonSize)
				ifFalse: [ ^true ]. 
			^(aRwGemStoneVersionNumber at: commonSize+1) isString not]
		ifFalse: [ 
			mySize = aSize ifTrue: [ ^false ].
			aSize <= 0 ifTrue: [ ^false ].
			"if the versions at commonSize are equal and the next version slot is a string, 
			 then it's considered that I'm < aRwGemStoneVersionNumber
			 (i.e., '2.9.9-alpha.2' is less than '2.9.9')"
			(self at: commonSize) = (aRwGemStoneVersionNumber at: commonSize)
				ifFalse: [ ^false ].
			 ^(self at: commonSize+1) isString]
%

category: 'copying'
method: RwGemStoneVersionNumber
copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize new j |
	newSize := stop - start + 1.
	new := self species new: newSize.
	j := 0.
	start to: stop do: [:i |
		new at: j + 1 put: (self at: i).
		j := j + 1 ].
	^new
%

category: 'enumerating'
method: RwGemStoneVersionNumber
do: aBlock 
	"Refer to the comment in Collection|do:."
	1 to: self size do:
		[:index | aBlock value: (self at: index)]
%

category: 'enumerating'
method: RwGemStoneVersionNumber
do: elementBlock separatedBy: separatorBlock
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	| beforeFirst | 
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		elementBlock value: each]
%

category: 'comparing'
method: RwGemStoneVersionNumber
hash

"Returns a numeric hash key for the receiver."

| mySize interval hashValue |

(mySize := self size) == 0
  ifTrue: [ ^15243 ].

"Choose an interval so that we sample at most 5 elements of the receiver"
interval := ((mySize - 1) // 4) max: 1.

hashValue := 4459.
1 to: mySize by: interval do: [ :i | | anElement |
  anElement := self at: i.
  (anElement isKindOf: SequenceableCollection)
    ifTrue: [
      hashValue := (hashValue bitShift: -1) bitXor: anElement size.
      ]
    ifFalse: [
      hashValue := (hashValue bitShift: -1) bitXor: anElement hash.
      ].
  ].

^ hashValue abs
%

category: 'printing'
method: RwGemStoneVersionNumber
printOn: aStream

	| beforeFirst | 
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [
				each isString
					ifTrue: [ aStream nextPut: $- ]
					ifFalse: [ aStream nextPut: $. ] ].
		aStream nextPutAll: each asString ]
%

category: 'matching'
method: RwGemStoneVersionNumber
rwPlatformAttributeMatchForGemStoneVersion: anRwGemStoneVersionConfigurationPlatformAttributeMatcher

	^ anRwGemStoneVersionConfigurationPlatformAttributeMatcher matchVersion: self
%

category: 'matching'
method: RwGemStoneVersionNumber
rwPlatformAttributeMatchForString: anRwStringConfigurationPlatformAttributeMatcher

	^ anRwStringConfigurationPlatformAttributeMatcher matchString: self printString
%

category: 'accessing'
method: RwGemStoneVersionNumber
versionString

	| strm |
	strm := WriteStream on: String new.
	self printOn: strm.
	^strm contents
%

category: 'comparing'
method: RwGemStoneVersionNumber
~> aRwGemStoneVersionNumber

	aRwGemStoneVersionNumber size == 1 ifTrue: [ ^false ].
	^self >= aRwGemStoneVersionNumber and: [ self < aRwGemStoneVersionNumber approximateBase ]
%

! Class implementation for 'RwSemanticVersionNumber'

!		Class methods for 'RwSemanticVersionNumber'

category: 'private'
classmethod: RwSemanticVersionNumber
extractNumericComponent: subString
    "$. separated components are integers"

    | number |
    number := [ subString asInteger ]
        on: Error
        do: [ :ex | ex return: subString ].
    ^ number asString = subString
        ifTrue: [ number ]
        ifFalse: [ subString ]
%

category: 'instance creation'
classmethod: RwSemanticVersionNumber
fromString: aString
  | preRelease build versionString identifierCount normalEnd preReleaseEnd normalComponents preReleaseComponents buildComponents |
  normalComponents := OrderedCollection new.
  preReleaseComponents := OrderedCollection new.
  buildComponents := OrderedCollection new.
  preRelease := aString indexOf: $- startingAt: 1.
  build := aString indexOf: $+ startingAt: 1.
  (build > 0 and: [ preRelease > build ])
    ifTrue: [ preRelease := 0 ].
  normalEnd := preRelease = 0
    ifTrue: [ 
      build = 0
        ifTrue: [ aString size ]
        ifFalse: [ build - 1 ] ]
    ifFalse: [ preRelease - 1 ].
  versionString := aString copyFrom: 1 to: normalEnd.
  identifierCount := 0.
  (versionString substrings: '.')
    do: [ :subString | 
      | integer |
	  integer := self integerFromString: subString.
	  integer < 0
		ifTrue: [ 
		  self
			error:
			  'invalid version number: normal version component must be integer '
				, subString printString ] .
      normalComponents add: integer.
      identifierCount := identifierCount + 1 ].
  identifierCount ~= 3
    ifTrue: [ self error: 'invalid version number: normal version must have only 3 components' ].
  preReleaseEnd := build = 0
    ifTrue: [ aString size ]
    ifFalse: [ build - 1 ].
  preRelease > 0
    ifTrue: [ 
      versionString := aString copyFrom: preRelease + 1 to: preReleaseEnd.
      (versionString substrings: '.')
        do: [ :subString | 
          (self isSemanticIdentifier: subString)
            ifFalse: [ 
              self
                error:
                  'invalid version number: preRelease version component must be one of [0-9A-Za-z-]' ].
          preReleaseComponents
            add:
              (self extractNumericComponent: subString) ] ].
  build > 0
    ifTrue: [ 
      versionString := aString copyFrom: build + 1 to: aString size.
      (versionString substrings: '.')
        do: [ :subString | 
          (self isSemanticIdentifier: subString)
            ifFalse: [ 
              self
                error:
                  'invalid version number: build version component must be one of [0-9A-Za-z-]' ].
          buildComponents
            add:
              (self extractNumericComponent: subString) ] ].
  ^ self new
    normalVersion: normalComponents;
    preReleaseVersion: preReleaseComponents;
    buildVersion: buildComponents;
    yourself
%

category: 'private'
classmethod: RwSemanticVersionNumber
integerFromString: aString
  aString
    detect: [ :char | char isDigit not ]
    ifNone: [ 
      | integer |
      integer := aString asInteger.
      ((aString at: 1) = $0 and: [ aString size > 1 ])
        ifTrue: [ 
          self
            error:
              'invalid version number: normal version component must not have leading 0s'
                , aString asString ].
      ^ integer ].
  self
    error:
      'invalid version number: normal version component must be integer '
        , aString asString
%

category: 'private'
classmethod: RwSemanticVersionNumber
isSemanticIdentifier: aString
    "whether the receiver is composed entirely of alphanumerics"

    aString
        do: [ :c | 
            c isAlphaNumeric
                ifFalse: [ 
                    c = $-
                        ifFalse: [ ^ false ] ] ].
    ^ true
%

category: 'private'
classmethod: RwSemanticVersionNumber
validateVersionNumber: svn against: aString
  svn printString = aString
    ifFalse: [ 
      self
        error:
          'The printString of a semantic version number should be equal to the source version string' ]
%

!		Instance methods for 'RwSemanticVersionNumber'

category: 'comparing'
method: RwSemanticVersionNumber
< aRwSemanticVersionNumber
    aRwSemanticVersionNumber species = self species
        ifFalse: [ ^ false ].
    ^ self compareLessThan: aRwSemanticVersionNumber
%

category: 'comparing'
method: RwSemanticVersionNumber
= aMetacelloVersionNumber
    aMetacelloVersionNumber species = self species
        ifFalse: [ ^ false ].
    ^ self compareEqualTo: aMetacelloVersionNumber
%

category: 'accessing'
method: RwSemanticVersionNumber
approximateBase

	| base |
	base := self copyFrom: 1 to: self size - 1.
	base at: base size put: (base at: base size) + 1.
	^base
%

category: 'converting'
method: RwSemanticVersionNumber
asRwSemanticVersionNumber
    ^ self
%

category: 'printing'
method: RwSemanticVersionNumber
asString
	"Answer a string that represents the receiver."

	^ self printString
%

category: 'accessing'
method: RwSemanticVersionNumber
buildVersion
    buildVersion ifNil: [ buildVersion := #() ].
    ^ buildVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
buildVersion: anObject
	buildVersion := anObject
%

category: 'private'
method: RwSemanticVersionNumber
compareEqualTo: aRwSemanticVersionNumber
    aRwSemanticVersionNumber species = self species
        ifFalse: [ ^ false ].
    (self compareEqualTo: self normalVersion other: aRwSemanticVersionNumber normalVersion)
        ifFalse: [ ^ false ].
    (self compareEqualTo: self preReleaseVersion other: aRwSemanticVersionNumber preReleaseVersion)
        ifFalse: [ ^ false ].
    ^ true
%

category: 'private'
method: RwSemanticVersionNumber
compareEqualTo: myComponents other: otherComponents
    | mySize |
    mySize := myComponents size.
    mySize = otherComponents size
        ifFalse: [ ^ false ].
    1 to: mySize do: [ :i | 
        (myComponents at: i) = (otherComponents at: i)
            ifFalse: [ ^ false ] ].
    ^ true
%

category: 'private'
method: RwSemanticVersionNumber
compareLessThan: aRwSemanticVersionNumber
    | myComponents otherComponents defaultResult |
    aRwSemanticVersionNumber species = self species
        ifFalse: [ ^ false ].
    myComponents := self normalVersion.
    otherComponents := aRwSemanticVersionNumber normalVersion.
    defaultResult := true.
    (self compareEqualTo: myComponents other: otherComponents)
        ifTrue: [ defaultResult := false ]
        ifFalse: [ 
            (self compareLessThan: myComponents other: otherComponents version: #'normal')
                ifFalse: [ ^ false ] ].
    myComponents := self preReleaseVersion.
    otherComponents := aRwSemanticVersionNumber preReleaseVersion.
    (self compareEqualTo: myComponents other: otherComponents)
        ifTrue: [ 
            myComponents size > 0
                ifTrue: [ defaultResult := false ] ]
        ifFalse: [ ^ self compareLessThan: myComponents other: otherComponents version: #'preRelease' ].
    ^ defaultResult
%

category: 'private'
method: RwSemanticVersionNumber
compareLessThan: myComponents other: otherComponents version: version
    | mySize aSize commonSize count more |
    mySize := myComponents size.
    aSize := otherComponents size.
    commonSize := mySize min: aSize.
    count := 0.
    more := true.
    [ more and: [ count < commonSize ] ]
        whileTrue: [ 
            (myComponents at: count + 1) = (otherComponents at: count + 1)
                ifTrue: [ count := count + 1 ]
                ifFalse: [ more := false ] ].
    count < commonSize
        ifTrue: [ ^ (myComponents at: count + 1) rwSemanticVersionComponentLessThan: (otherComponents at: count + 1) ].
    mySize < aSize
        ifTrue: [ 
            mySize = 0
                ifTrue: [ 
                    #'preRelease' == version
                        ifTrue: [ ^ false ].
                    ^ true ].
            (myComponents at: commonSize) = (otherComponents at: commonSize)
                ifFalse: [ ^ true ].
            ^ true ]
        ifFalse: [ 
            mySize = aSize
                ifTrue: [ ^ false ].
            aSize = 0
                ifTrue: [ 
                    #'build' == version
                        ifTrue: [ ^ false ].
                    ^ true ].
            (myComponents at: commonSize) = (otherComponents at: commonSize)
                ifFalse: [ ^ false ].
            ^ true ]
%

category: 'copying'
method: RwSemanticVersionNumber
copyFrom: start to: stop 
	"Answer a copy of a subset of the receiver, starting from element at 
	index start until element at index stop."

	| newSize new j |
	newSize := stop - start + 1.
	new := self species new: newSize.
	j := 0.
	start to: stop do: [:i |
		new at: j + 1 put: (self at: i).
		j := j + 1 ].
	^new
%

category: 'operations'
method: RwSemanticVersionNumber
decrementMajorVersion
  self decrementNormalVersionAt: 1
%

category: 'operations'
method: RwSemanticVersionNumber
decrementMinorVersion
  self decrementNormalVersionAt: 2
%

category: 'operations'
method: RwSemanticVersionNumber
decrementMinorVersionNumber
  self decrementNormalVersionAt: 3
%

category: 'private'
method: RwSemanticVersionNumber
decrementNormalVersionAt: index
  | int col |
  col := self normalVersion.
  int := col at: index.
  int > 0
    ifTrue: [ col at: index put: int - 1 ]
%

category: 'operations'
method: RwSemanticVersionNumber
decrementPatchVersion
  self decrementNormalVersionAt: 3
%

category: 'enumerating'
method: RwSemanticVersionNumber
do: aBlock 
	"Refer to the comment in Collection|do:."
	1 to: self size do:
		[:index | aBlock value: (self at: index)]
%

category: 'enumerating'
method: RwSemanticVersionNumber
do: elementBlock separatedBy: separatorBlock
	"Evaluate the elementBlock for all elements in the receiver,
	and evaluate the separatorBlock between."

	| beforeFirst | 
	beforeFirst := true.
	self do:
		[:each |
		beforeFirst
			ifTrue: [beforeFirst := false]
			ifFalse: [separatorBlock value].
		elementBlock value: each]
%

category: 'comparing'
method: RwSemanticVersionNumber
hash
    ^ self versionComponents hash
%

category: 'operations'
method: RwSemanticVersionNumber
incrementMajorVersion
  self incrementNormalVersionAt: 1
%

category: 'operations'
method: RwSemanticVersionNumber
incrementMinorVersion
  self incrementNormalVersionAt: 2
%

category: 'operations'
method: RwSemanticVersionNumber
incrementMinorVersionNumber
  self incrementNormalVersionAt: 3
%

category: 'private'
method: RwSemanticVersionNumber
incrementNormalVersionAt: index
  | int col |
  col := self normalVersion.
  int := col at: index.
  col at: index put: int + 1
%

category: 'operations'
method: RwSemanticVersionNumber
incrementPatchVersion
  self incrementNormalVersionAt: 3
%

category: 'accessing'
method: RwSemanticVersionNumber
normalVersion
    normalVersion ifNil: [ normalVersion := #() ].
    ^ normalVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
normalVersion: anObject
	normalVersion := anObject
%

category: 'copying'
method: RwSemanticVersionNumber
postCopy
  normalVersion := normalVersion copy.
  preReleaseVersion := preReleaseVersion copy.
  buildVersion := buildVersion copy
%

category: 'accessing'
method: RwSemanticVersionNumber
preReleaseVersion
    preReleaseVersion ifNil: [ preReleaseVersion := #() ].
    ^ preReleaseVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
preReleaseVersion: anObject
	preReleaseVersion := anObject
%

category: 'printing'
method: RwSemanticVersionNumber
print: components prefix: prefixChar on: aStream
    | beforeFirst |
    beforeFirst := true.
    components
        do: [ :component | 
            beforeFirst
                ifTrue: [ 
                    beforeFirst := false.
                    prefixChar ifNotNil: [ aStream nextPut: prefixChar ] ]
                ifFalse: [ aStream nextPut: $. ].
            aStream nextPutAll: component asString ]
%

category: 'printing'
method: RwSemanticVersionNumber
printOn: aStream
    self print: self normalVersion prefix: nil on: aStream.
    self print: self preReleaseVersion prefix: $- on: aStream.
    self print: self buildVersion prefix: $+ on: aStream
%

category: 'private'
method: RwSemanticVersionNumber
versionComponents
    ^ self normalVersion , self preReleaseVersion , self buildVersion
%

category: 'accessing'
method: RwSemanticVersionNumber
versionString

	| strm |
	strm := WriteStream on: String new.
	self printOn: strm.
	^strm contents
%

category: 'comparing'
method: RwSemanticVersionNumber
~> aMetacelloVersionNumber

	"if this selector is to survive it will need work ... see RwGemStoneVersionNumber ... I think that collapseZeroes will be needed (in some form) to 
		make this boy give expected results"

	aMetacelloVersionNumber size == 1 ifTrue: [ ^false ].
	^self >= aMetacelloVersionNumber and: [ self < aMetacelloVersionNumber approximateBase ]
%

! Class implementation for 'CypressLoaderErrorNotification'

!		Class methods for 'CypressLoaderErrorNotification'

category: 'instance creation'
classmethod: CypressLoaderErrorNotification
patchOperation: aPatchOperation exception: anException

	^self new
		initializePatchOperation: aPatchOperation exception: anException;
		yourself
%

!		Instance methods for 'CypressLoaderErrorNotification'

category: 'handling'
method: CypressLoaderErrorNotification
defaultAction
	"Log the notification to the GCI log and the Transcript, then resume."

	self logNotification: 'Notice: ' , self asString.
	^super defaultAction
%

category: 'accessing'
method: CypressLoaderErrorNotification
exception
	"Answer the original exception raised when applying the Patch Operation."

	^exception
%

category: 'updating'
method: CypressLoaderErrorNotification
exception: anException
	"Assign the original exception raised when applying the Patch Operation."

	exception := anException
%

category: 'initializing - private'
method: CypressLoaderErrorNotification
initializeMessageText

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	stream
		nextPutAll: self patchOperation printString;
		nextPutAll: ' failed because ';
		nextPutAll: self exception printString.
	messageText := stream contents
%

category: 'initializing - private'
method: CypressLoaderErrorNotification
initializePatchOperation: aPatchOperation exception: anException

	self
		patchOperation: aPatchOperation;
		exception: anException;
		initializeMessageText
%

category: 'handling'
method: CypressLoaderErrorNotification
logNotification: aString

	GsFile gciLogServer: aString.
	Transcript cr; nextPutAll: aString.
%

category: 'accessing'
method: CypressLoaderErrorNotification
patchOperation
	"Answer the Patch Operation that could not be applied."

	^patchOperation
%

category: 'updating'
method: CypressLoaderErrorNotification
patchOperation: aCypressPatchOperation
	"Assign the Patch Operation that could not be applied."

	patchOperation := aCypressPatchOperation
%

! Class implementation for 'GsInteractionRequest'

!		Class methods for 'GsInteractionRequest'

category: 'interacting'
classmethod: GsInteractionRequest
signal: aGsInteraction
  ^ (self new interaction: aGsInteraction) signal
%

!		Instance methods for 'GsInteractionRequest'

category: 'signaling'
method: GsInteractionRequest
defaultAction
  ^ self interaction defaultActionFor: self
%

category: 'Compatibility'
method: GsInteractionRequest
gsArguments
  "This method included here for G/S 2.x only ... not needed nor used in 3.x"

  ^ {(self interaction)}
%

category: 'Instance initialization'
method: GsInteractionRequest
initialize
  super initialize.
  gsNumber := 121001
%

category: 'accessing'
method: GsInteractionRequest
interaction

   "Return the value of the instance variable 'interaction'."
   ^interaction
%

category: 'accessing'
method: GsInteractionRequest
interaction: anObject

   "Modify the value of the instance variable 'interaction'."
   interaction := anObject
%

category: 'signaling'
method: GsInteractionRequest
response: anObject
  self resume: anObject
%

! Class implementation for 'RwDeleteClassFromSystemNotification'

!		Instance methods for 'RwDeleteClassFromSystemNotification'

category: 'accessing'
method: RwDeleteClassFromSystemNotification
candidateClass
	"class to be deleted from system, if receiver is #resumed: with true"

	^ candidateClass
%

category: 'accessing'
method: RwDeleteClassFromSystemNotification
candidateClass: aClassToBeDeleted

	candidateClass := aClassToBeDeleted
%

category: 'handling'
method: RwDeleteClassFromSystemNotification
defaultAction

	^ true
%

! Class implementation for 'RwExecuteClassInitializeMethodsAfterLoadNotification'

!		Instance methods for 'RwExecuteClassInitializeMethodsAfterLoadNotification'

category: 'accessing'
method: RwExecuteClassInitializeMethodsAfterLoadNotification
candidateClass
	"class to which #initialize if receiver is #resumed: with true"

	^ candidateClass
%

category: 'accessing'
method: RwExecuteClassInitializeMethodsAfterLoadNotification
candidateClass: aClassToInitialize

	candidateClass := aClassToInitialize
%

category: 'handling'
method: RwExecuteClassInitializeMethodsAfterLoadNotification
defaultAction

	^ true
%

! Class implementation for 'RwExistingAssociationWithSameKeyNotification'

!		Instance methods for 'RwExistingAssociationWithSameKeyNotification'

category: 'handling'
method: RwExistingAssociationWithSameKeyNotification
defaultAction

	self error: self errorMessage
%

category: 'accessing'
method: RwExistingAssociationWithSameKeyNotification
errorMessage

   ^errorMessage
%

category: 'accessing'
method: RwExistingAssociationWithSameKeyNotification
errorMessage: anObject

   errorMessage := anObject
%

! Class implementation for 'RwExistingVisitorAddingExistingClassNotification'

!		Instance methods for 'RwExistingVisitorAddingExistingClassNotification'

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
classDefinition

	^ classDefinition
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
classDefinition: aClassDefinition

	classDefinition := aClassDefinition
%

category: 'handling'
method: RwExistingVisitorAddingExistingClassNotification
defaultAction

	loadedProject ifNil: [ ^ self error: 'Visitor adding a class ', classDefinition name printString, ' that already exists' ].
	self error: 
		'Visitor adding a class ', 
		classDefinition name printString, 
		' that already exists in the project ', 
		loadedProject name printString, 
		', but the project was not included in the load'
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
loadedProject

	^ loadedProject
%

category: 'accessing'
method: RwExistingVisitorAddingExistingClassNotification
loadedProject: aLoadedProject

	loadedProject := aLoadedProject
%

! Class implementation for 'RwPerformingUnpackagedEditNotification'

!		Instance methods for 'RwPerformingUnpackagedEditNotification'

category: 'handling'
method: RwPerformingUnpackagedEditNotification
defaultAction

	^ self error: self errorMessage
%

category: 'accessing'
method: RwPerformingUnpackagedEditNotification
errorMessage

   ^self informMessage
%

category: 'accessing'
method: RwPerformingUnpackagedEditNotification
informMessage

   ^informMessage
%

category: 'accessing'
method: RwPerformingUnpackagedEditNotification
informMessage: anObject

   informMessage := anObject
%

category: 'signalling'
method: RwPerformingUnpackagedEditNotification
signal: aMessage

	self informMessage: aMessage.
	^ self signal
%

! Class implementation for 'CypressAbstractPackageFiler'

!		Class methods for 'CypressAbstractPackageFiler'

category: 'instance creation'
classmethod: CypressAbstractPackageFiler
forRepository: aCypressFileSystemRepository

	^self new
		initializeForRepository: aCypressFileSystemRepository;
		yourself.
%

!		Instance methods for 'CypressAbstractPackageFiler'

category: 'private'
method: CypressAbstractPackageFiler
fileUtils

	^CypressFileUtilities current
%

category: 'initializing - private'
method: CypressAbstractPackageFiler
initializeForRepository: aCypressFileSystemRepository

	repository := aCypressFileSystemRepository
%

category: 'accessing'
method: CypressAbstractPackageFiler
packageDirectory

	^packageDirectory
%

category: 'accessing'
method: CypressAbstractPackageFiler
packageDirectory: aDirectory

	packageDirectory := aDirectory
%

category: 'accessing'
method: CypressAbstractPackageFiler
packageStructure

	^packageStructure
%

category: 'accessing'
method: CypressAbstractPackageFiler
packageStructure: aPackageStructure

	packageStructure := aPackageStructure
%

category: 'accessing'
method: CypressAbstractPackageFiler
propertiesFileNameExtension

	^'.ston'
%

category: 'accessing'
method: CypressAbstractPackageFiler
propertiesFileNameExtensions

	^Array with: self propertiesFileNameExtension
%

category: 'accessing'
method: CypressAbstractPackageFiler
repository

	^repository
%

category: 'private'
method: CypressAbstractPackageFiler
string: aString endsWith: subString
	"Answer whether the last characters of aString are the same as subString."

	| expectedStart |
	expectedStart := aString size - subString size + 1 max: 1.
	^expectedStart
		= (aString indexOfSubCollection: subString startingAt: expectedStart)
%

! Class implementation for 'CypressAbstractFileoutWriter'

!		Instance methods for 'CypressAbstractFileoutWriter'

category: 'accessing'
method: CypressAbstractFileoutWriter
classesInDependencyOrder

	^(CypressGsGeneralDependencySorter
		on: self packageStructure classes
		dependsOn: [:candidate | candidate superclassName]
		dependent: [:candidate | candidate className]) inOrder
%

category: 'accessing'
method: CypressAbstractFileoutWriter
classesWithInitializers

	^self classesInDependencyOrder
		select: [:each | each classMethods anySatisfy: [:method | method selector = 'initialize']]
%

category: 'private'
method: CypressAbstractFileoutWriter
determinePackageDirectory

	^self fileUtils ensureDirectoryExists: self repository directoryPath
%

category: 'accessing'
method: CypressAbstractFileoutWriter
extensions

	^self packageStructure extensions
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOut: aString implementationsFrom: someClassStructures on: aStream

	someClassStructures
		do: [:each | self fileOutType: aString implementationOf: each on: aStream]
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOut: aString methods: someMethodStructures on: aStream

	someMethodStructures isEmpty ifTrue: [^self].
	self
		fileOut: aString methodsPreambleFor: someMethodStructures any classStructure on: aStream;
		fileOutMethods: someMethodStructures on: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutClassDeclarationsOn: aStream

	self classesInDependencyOrder
		do: [:classStructure | self fileOutClassDeclaration: classStructure on: aStream]
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutClassesOn: aStream

	self
		fileOutClassesPreambleOn: aStream;
		fileOutClassDeclarationsOn: aStream;
		fileOutClassImplementationsOn: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutClassImplementationsOn: aStream

	self
		fileOut: 'Class Implementation'
		implementationsFrom: self classesInDependencyOrder
		on: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutClassInitializersOn: aStream

	self fileOutClassInitializersPreambleOn: aStream.
	self classesWithInitializers do: [:each | self fileOutClassInitializerFor: each on: aStream].
	self fileOutClassInitializersPostambleOn: aStream.
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutExtensionImplementationsOn: aStream
  | sortedExtensions |
  sortedExtensions := self extensions
    asSortedCollection: [ :a :b | a className <= b className ].
  self
    fileOut: 'Class Extension'
    implementationsFrom: sortedExtensions
    on: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutExtensionsOn: aStream

	self
		fileOutExtensionsPreambleOn: aStream;
		fileOutExtensionImplementationsOn: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutMethods: someMethodStructures on: aStream

	(someMethodStructures
		asSortedCollection: [:a :b | a selector <= b selector])
			do: [:methodStructure | self fileOutMethod: methodStructure on: aStream]
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutPackageOn: aStream

	self
		fileOutPackagePreambleOn: aStream;
		fileOutClassesOn: aStream;
		fileOutExtensionsOn: aStream;
		fileOutClassInitializersOn: aStream;
		fileOutPackagePostambleOn: aStream
%

category: 'writing - private'
method: CypressAbstractFileoutWriter
fileOutType: aString implementationOf: classStructure on: aStream

	self
		fileOutPreambleType: aString
			for: classStructure
			on: aStream;
		fileOut: 'Class'
			methods: classStructure classMethods
			on: aStream;
		fileOut: 'Instance'
			methods: classStructure instanceMethods
			on: aStream
%

category: 'accessing'
method: CypressAbstractFileoutWriter
packageName

	^self packageStructure packageName
%

category: 'accessing'
method: CypressAbstractFileoutWriter
packageNameExtension

	^self subclassResponsibility: #packageNameExtension
%

category: 'writing'
method: CypressAbstractFileoutWriter
writePackageStructure

	CypressFileUtilities current
		writeStreamFor: self packageStructure packageName
				, self packageNameExtension
		in: self packageDirectory
		do: [:fileStream | self fileOutPackageOn: fileStream]
%

category: 'writing'
method: CypressAbstractFileoutWriter
writePackageStructure: aPackageStructure

	self
		packageStructure: aPackageStructure;
		packageDirectory: self determinePackageDirectory;
		writePackageStructure
%

! Class implementation for 'CypressSmalltalkFileoutWriter'

!		Instance methods for 'CypressSmalltalkFileoutWriter'

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOut: aString methodsPreambleFor: classStructure on: aStream

	self
		writeChunk: '" ------------------- ' , aString , ' methods for '
				, classStructure name , '"'
		on: aStream.
	aStream
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutClassDeclaration: classStructure on: aStream
	"This is the structure for VW/Pharo  class definitions. It may or may not be portable
	to all dialects that use chunk-format fileins. It does not attempt to handle VW
	namespaces at this time. Probably should use an XML fileout for that."

	aStream
		nextPutAll: classStructure superclassName;
		nextPutAll: ' subclass: #';
		nextPutAll: classStructure className;
		lf;
		nextPutAll: '	instanceVariableNames:  ''';
		nextPutAll: classStructure instanceVariablesString;
		nextPut: $';
		lf;
		nextPutAll: '	classVariableNames: ''';
		nextPutAll: classStructure classVariablesString;
		nextPut: $';
		lf;
		nextPutAll: '	poolDictionaries: ''';
		nextPutAll: classStructure poolDictionariesString;
		nextPut: $';
		lf;
		nextPutAll: '	category: ''';
		nextPutAll: classStructure category.
	self writeChunk: '''' on: aStream.
	aStream
		lf;
		lf;
		nextPutAll: classStructure className;
		nextPutAll: ' comment:';
		lf.
	self writeChunk: classStructure comment printString on: aStream.
	aStream
		lf;
		lf;
		nextPutAll: classStructure className;
		nextPutAll: ' class instanceVariableNames: ''';
		nextPutAll: classStructure classInstanceVariablesString.
	self writeChunk: '''' on: aStream.
	aStream
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutClassesPreambleOn: aStream

	self writeChunk: '" Class Declarations "' on: aStream.
	aStream
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutClassInitializerFor: classStructure on: aStream

	self writeChunk: classStructure className , ' initialize.' on: aStream.
	aStream lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutClassInitializersPostambleOn: aStream

	aStream
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutClassInitializersPreambleOn: aStream

	self writeChunk: '" Class initializers "' on: aStream.
	aStream
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutExtensionsPreambleOn: aStream

	self writeChunk: '" Class Extensions "' on: aStream.
	aStream
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutMethod: methodStructure on: aStream

	aStream nextPutAll: '!'.
	self
		writeChunk: methodStructure classStructure className
				, (methodStructure isMetaclass
						ifTrue: [' class methodsFor: ']
						ifFalse: [' methodsFor: '])
					, methodStructure category printString
		on: aStream.
	aStream lf.
	self
		writeChunk: methodStructure source on: aStream;
		writeChunk: ' ' on: aStream.
	aStream lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutPackagePostambleOn: aStream

	aStream
		lf;
		lf.
	self writeChunk: '" End of Package: ' , self packageName , '"' on: aStream.
	aStream
		lf;
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutPackagePreambleOn: aStream

	self writeChunk: '" Package: ' , self packageName , '"' on: aStream.
	aStream
		lf;
		lf;
		lf
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
fileOutPreambleType: aString for: classStructure on: aStream

	self writeChunk: '" ' , aString , ' for ' , classStructure name , '"'
		on: aStream.
	aStream
		lf;
		lf
%

category: 'accessing'
method: CypressSmalltalkFileoutWriter
packageNameExtension

	^'.st'
%

category: 'writing - private'
method: CypressSmalltalkFileoutWriter
writeChunk: aString on: aStream

	aString do: 
			[:each |
			aStream nextPut: each.
			each = $! ifTrue: [aStream nextPut: each]].
	aStream nextPut: $!
%

! Class implementation for 'CypressTopazFileoutWriter'

!		Instance methods for 'CypressTopazFileoutWriter'

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOut: aString methodsPreambleFor: classStructure on: aStream

	aStream
		nextPutAll: '! ------------------- ', aString, ' methods for ', classStructure name; lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutClassDeclaration: classStructure on: aStream
  aStream
    nextPutAll: 'doit';
    lf;
    nextPutAll: '(' , classStructure superclassName;
    lf.
  self
    writeClassTypeMessage: classStructure
    on: aStream
    hasInstanceVariables: [ aStream
        nextPutAll:
            '	instVarNames: #( ' , classStructure instanceVariablesString , ' )';
        lf ].
  aStream
    nextPutAll: '	classVars: #( ' , classStructure classVariablesString , ' )';
    lf;
    nextPutAll:
        '	classInstVars: #( ' , classStructure classInstanceVariablesString , ' )';
    lf;
    nextPutAll: '	poolDictionaries: #()';
    lf;
    nextPutAll: '	inDictionary: UserGlobals';
    lf;
    nextPutAll: '	options: #())';
    lf;
    nextPutAll: '		category: ' , classStructure category printString , ';';
    lf;
    nextPutAll: '		comment: ' , classStructure comment printString , ';';
    lf;
    nextPutAll: '		immediateInvariant.';
    lf;
    nextPutAll: 'true.';
    lf;
    nextPutAll: '%';
    lf;
    lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutClassesPreambleOn: aStream

	aStream
		nextPutAll: '! Class Declarations'; lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutClassInitializerFor: classStructure on: aStream

	aStream
		nextPutAll: classStructure className, ' initialize.'; lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutClassInitializersPostambleOn: aStream

	aStream
                nextPutAll: 'true.'; lf;
		nextPutAll: '%'; lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutClassInitializersPreambleOn: aStream

	aStream
		nextPutAll: '! Class initializers '; lf;
		lf;
		nextPutAll: 'doit'; lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutExtensionsPreambleOn: aStream

	aStream
		nextPutAll: '! Class Extensions'; lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutMethod: methodStructure on: aStream

	aStream
		nextPutAll: 'category: ', methodStructure category printString; lf;
		nextPutAll: (methodStructure isMetaclass ifTrue: ['classmethod: '] ifFalse: ['method: ']), methodStructure classStructure className; lf;
		nextPutAll: methodStructure source.
	methodStructure source last = Character lf
		ifFalse: [aStream lf].
	aStream nextPutAll: '%'; lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutPackagePostambleOn: aStream

	aStream
		lf;
		lf;
		nextPutAll: '! End of Package: ', self packageName; lf;
		lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutPackagePreambleOn: aStream

	aStream
		nextPutAll: '! Package: ', self packageName; lf;
		lf;
		lf;
		nextPutAll: '! Remove existing behavior from package ', self packageName; lf;
		nextPutAll: '!!!! This can be cleaned up when some package functionality is moved to the base system.'; lf;
		lf;
		nextPutAll: 'doit'; lf;
		nextPutAll: '| packageName |'; lf;
		nextPutAll: 'packageName := ', self packageName printString, '.'; lf;
		nextPutAll: 'System myUserProfile symbolList do: [:symDict |'; lf;
		nextPutAll: '	symDict do: [:possibleClass |'; lf;
		nextPutAll: '			| toRemove |'; lf;
		nextPutAll: '		possibleClass isBehavior ifTrue: ['; lf;
		nextPutAll: '			{possibleClass. possibleClass class} do: [:aClass |'; lf;
		nextPutAll: '				aClass category = packageName'; lf;
		nextPutAll: '					ifTrue: ['; lf;
		nextPutAll: '							"*anythingbutpackagename[-anything]"'; lf;
		nextPutAll: '						toRemove := aClass categoryNames select: '; lf;
		nextPutAll: '										[:each |'; lf;
		nextPutAll: '										each isEmpty not and: ['; lf;
		nextPutAll: '											(each first = $* and: [(each size = (packageName size + 1) and: [(each findStringNoCase: packageName startingAt: 2) = 2])'; lf;
		nextPutAll: '														or: [each size > (packageName size + 1) and: [(each findStringNoCase: packageName startingAt: 2) = 2 and: [(each at: packageName size + 2) = $-]]]])'; lf;
		nextPutAll: '											or: [each first ~= $*]]]'; lf;
		nextPutAll: '					]'; lf;
		nextPutAll: '					ifFalse: ['; lf;
		nextPutAll: '							"*packagename[-anything]"'; lf;
		nextPutAll: '						toRemove := aClass categoryNames select: '; lf;
		nextPutAll: '										[:each |'; lf;
		nextPutAll: '										each isEmpty not and: ['; lf;
		nextPutAll: '											each first = $* and: [(each size = (packageName size + 1) and: [(each findStringNoCase: packageName startingAt: 2) = 2])'; lf;
		nextPutAll: '														or: [each size > (packageName size + 1) and: [(each findStringNoCase: packageName startingAt: 2) = 2 and: [(each at: packageName size + 2) = $-]]]]]]'; lf;
		nextPutAll: '					].'; lf;
		nextPutAll: '				toRemove do: [:each | aClass removeCategory: each].'; lf;
		nextPutAll: '			]'; lf;
		nextPutAll: '		]'; lf;
		nextPutAll: '	]'; lf;
		nextPutAll: '].'; lf;
                nextPutAll: 'true.'; lf;
		nextPutAll: '%'; lf;
		lf;
		lf
%

category: 'writing - private'
method: CypressTopazFileoutWriter
fileOutPreambleType: aString for: classStructure on: aStream

	aStream
		nextPutAll: '! ', aString, ' for ', classStructure name; lf;
		lf
%

category: 'accessing'
method: CypressTopazFileoutWriter
packageNameExtension

	^'.gs'
%

category: 'writing - private'
method: CypressTopazFileoutWriter
writeClassTypeMessage: classStructure on: aStream hasInstanceVariables: instanceVariableBlock
  | classType classTypeMessage hasInstanceVariables |
  hasInstanceVariables := true.
  classType := classStructure subclassType.
  classType = 'indexableSubclass'
    ifTrue: [ classTypeMessage := 'indexableSubclass: ' ]
    ifFalse: [ classType = 'byteSubclass'
        ifTrue: [ classTypeMessage := 'byteSubclass: '.
          hasInstanceVariables := false ]
        ifFalse: [ classType = ''
            ifTrue: [ classTypeMessage := 'subclass: ' ]
            ifFalse: [ self error: 'unknown subclass type: ' , classType ] ] ].
  aStream
    tab;
    nextPutAll: classTypeMessage , classStructure className asString printString;
    lf.
  hasInstanceVariables
    ifTrue: [ instanceVariableBlock value ]
%

! Class implementation for 'CypressAbstractPackageReader'

!		Instance methods for 'CypressAbstractPackageReader'

category: 'private'
method: CypressAbstractPackageReader
classStructureFrom: classPropertiesDict

	^(CypressClassStructure new)
		packageStructure: self packageStructure;
		isClassExtension: true;
		properties: classPropertiesDict;
		yourself
%

category: 'private'
method: CypressAbstractPackageReader
classStructureFrom: classPropertiesDict comment: classComment

	^(self classStructureFrom: classPropertiesDict)
		isClassExtension: false;
		comment: classComment;
		yourself
%

category: 'reading'
method: CypressAbstractPackageReader
isPropertiesFileDirectoryEntry: entry

	^self propertiesFileNameExtensions
		anySatisfy: [:each | self string: entry endsWith: '/properties' , each]
%

category: 'accessing'
method: CypressAbstractPackageReader
packageExtension

	^self packageStructure
		packageExtensionOr: [self repository packageExtension]
%

category: 'parsing'
method: CypressAbstractPackageReader
parseSelectorFrom: methodString

	| meth |
	^
	[meth := self
				_parseMethod: methodString
				category: #xyzzy
				using: GsSession currentSession symbolList
				environmentId: 0.
	meth class ~~ GsNMethod
		ifTrue: 
			["if error slot is nil, then the method wasn't compiled because of errors"
			(meth at: 2) == nil ifFalse: [^nil].
			meth := meth at: 1].
	meth selector asString]
			on: CompileError
			do: [:ex | ex return: '_____could_not_parse_selector_from_method_source_____']
%

category: 'reading'
method: CypressAbstractPackageReader
readClassCommentFromDirectoryEntries: entries

	self fileUtils readStreamFor: (entries
				detect: [:entry | self string: entry endsWith: '/README.md']
				ifNone: [^''])
		do: [:fileStream | ^fileStream contents]
%

category: 'reading'
method: CypressAbstractPackageReader
readClassPropertiesFromDirectoryEntries: entries

	self fileUtils readStreamFor: (entries
				detect: [:entry | self isPropertiesFileDirectoryEntry: entry]
				ifNone: [^Dictionary new])
		do: [:fileStream | ^CypressJsonParser parseStream: fileStream]
%

category: 'reading'
method: CypressAbstractPackageReader
readClassStructureFromEntry: classEntry

	| classDirectory classPropertiesDict classComment entries classStructure |
	classDirectory := classEntry.
	entries := self fileUtils directoryEntriesFrom: classDirectory.
	classPropertiesDict := self
				readClassPropertiesFromDirectoryEntries: entries.
	classComment := self readClassCommentFromDirectoryEntries: entries.
	classStructure := self classStructureFrom: classPropertiesDict
				comment: classComment.
	self readMethodStructureFor: classStructure in: entries.
	^classStructure
%

category: 'reading'
method: CypressAbstractPackageReader
readCypressFormatMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods

	| notice category source selector |
	(fileStream peekFor: $")
		ifTrue: [fileStream nextLine]
		ifFalse: [self error: 'Method does not have valid Cypress format'].
	(fileStream match: 'notice: ')
		ifTrue: [notice := fileStream nextLine trimSeparators]
		ifFalse: [self error: 'Method does not have valid Cypress format'].
	(fileStream match: 'category: ')
		ifTrue: [category := fileStream nextLine trimSeparators]
		ifFalse: [self error: 'Method does not have valid Cypress format'].
	(fileStream peekFor: $")
		ifTrue: [fileStream nextLine]
		ifFalse: [self error: 'Method does not have valid Cypress format'].
	source := fileStream upToEnd.
	selector := self parseSelectorFrom: source.
	methods at: selector
		put: ((CypressMethodStructure new)
				packageStructure: self packageStructure;
				classStructure: classStructure;
				name: selector;
				isMetaclass: isMeta;
				selector: selector;
				category: category;
				source: source;
				yourself)
%

category: 'reading'
method: CypressAbstractPackageReader
readExtensionClassStructureFromEntry: classEntry

	| classPropertiesDict entries classStructure |
	entries := self fileUtils directoryEntriesFrom: classEntry.
	classPropertiesDict := self
				readClassPropertiesFromDirectoryEntries: entries.
	classStructure := self classStructureFrom: classPropertiesDict.
	self readMethodStructureFor: classStructure in: entries.
	^classStructure
%

category: 'reading'
method: CypressAbstractPackageReader
readFileTreeFormatMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods

	| category source selector |
	category := fileStream nextLine trimSeparators.
	source := fileStream upToEnd.
	selector := self parseSelectorFrom: source.
	methods at: selector
		put: ((CypressMethodStructure new)
				packageStructure: self packageStructure;
				classStructure: classStructure;
				name: selector;
				isMetaclass: isMeta;
				selector: selector;
				category: category;
				source: source;
				yourself)
%

category: 'reading'
method: CypressAbstractPackageReader
readMethodStructureFor: classStructure in: entries

	entries do: 
			[:entry |
			| methods isMeta |
			methods := (isMeta := self string: entry endsWith: '/class')
						ifTrue: [classStructure classMethods]
						ifFalse: [classStructure instanceMethods].
			((self string: entry endsWith: '/instance')
				or: [self string: entry endsWith: '/class'])
					ifTrue: 
						[((self fileUtils directoryEntriesFrom: entry)
							select: [:each | self string: each endsWith: '.st']) do: 
									[:methodEntry |
									self fileUtils readStreamFor: methodEntry
										do: 
											[:fileStream |
											self
												readMethodStructureFrom: fileStream
												intoClassStructure: classStructure
												meta: isMeta
												methods: methods]]]]
%

category: 'reading'
method: CypressAbstractPackageReader
readMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods

	self subclassResponsibility: #readMethodStructureFrom:intoClassStructure:meta:methods:
%

category: 'reading'
method: CypressAbstractPackageReader
readPackageStructure

	(self fileUtils directoryEntriesFrom: self packageDirectory) do: 
			[:entry |
			(self isPropertiesFileDirectoryEntry: entry)
				ifTrue: [self packageStructure properties: (self readPropertiesFile: entry)].
			(self string: entry endsWith: '.class')
				ifTrue: 
					[self packageStructure classes
						add: (self readClassStructureFromEntry: entry)].
			(self string: entry endsWith: '.extension')
				ifTrue: 
					[self packageStructure extensions
						add: (self readExtensionClassStructureFromEntry: entry)]]
%

category: 'reading'
method: CypressAbstractPackageReader
readPackageStructureForPackageNamed: packageName

	| structureName |
	structureName := packageName , self repository packageExtension.
	self
		packageStructure: (CypressPackageStructure named: structureName);
		packageDirectory: (self fileUtils directoryFromPath: structureName
					relativeTo: self repository directoryPath);
		readPackageStructure
%

category: 'reading'
method: CypressAbstractPackageReader
readPropertiesFile: entry

	self fileUtils
		readStreamFor: entry
		do: [:fileStream | ^CypressJsonParser parseStream: fileStream]
%

category: 'parsing'
method: CypressAbstractPackageReader
_parseMethod: source category: cat using: aSymbolList environmentId: anEnvironmentId
	"Compiles the method into disposable dictionaries, if possible.
	 Attempts auto-recompile for undefinedSymbols.
	 Returns the compiled method or signals a CompileError."

	| undefinedSymbolList undefinedSymbols |
	undefinedSymbols := SymbolDictionary new name: #UndefinedSymbols.
	undefinedSymbolList := SymbolList with: undefinedSymbols.
	^
	[UndefinedObject
		compileMethod: source
		dictionaries: aSymbolList
		category: cat
		intoMethodDict: GsMethodDictionary new
		intoCategories: GsMethodDictionary new
		intoPragmas: nil
		environmentId: anEnvironmentId]
			onSynchronous: (Array with: CompileError with: CompileWarning)
			do: (Array with: 
						[:ex |
						| undefSymbol symbols |
						undefSymbol := true.
						symbols := Array new.
						ex errorDetails do: 
								[:errArray |
								(errArray atOrNil: 1) == 1031
									ifTrue: [symbols add: (errArray atOrNil: 5) asSymbol]
									ifFalse: [undefSymbol := false]].
						undefSymbol
							ifTrue: 
								["attempt auto-define of undefined symbols"
								symbols do: [:sym | undefinedSymbols at: sym put: nil].
								
								[^UndefinedObject
									compileMethod: source
									dictionaries: aSymbolList , undefinedSymbolList
									category: cat
									intoMethodDict: GsMethodDictionary new
									intoCategories: GsMethodDictionary new
									intoPragmas: nil
									environmentId: anEnvironmentId]
										onException: CompileError
										do: [:exb | undefSymbol := false]].
						undefSymbol ifFalse: [ex outer]]
					with: [:ex | ex resume])
%

! Class implementation for 'CypressDoNothingPackageReader'

!		Instance methods for 'CypressDoNothingPackageReader'

category: 'reading'
method: CypressDoNothingPackageReader
readPackageStructure
%

! Class implementation for 'CypressFileTreeFormatPackageReader'

!		Instance methods for 'CypressFileTreeFormatPackageReader'

category: 'private'
method: CypressFileTreeFormatPackageReader
classStructureFrom: fileteeClassPropertiesDict comment: classComment
  | classPropertiesDict subclassType filetreeSubclassType |
  classPropertiesDict := fileteeClassPropertiesDict copy.
  filetreeSubclassType := classPropertiesDict at: 'type'.
  filetreeSubclassType = 'normal'
    ifTrue: [ subclassType := '' ]
    ifFalse: [ 
      filetreeSubclassType = 'variable'
        ifTrue: [ subclassType := 'indexableSubclass' ]
        ifFalse: [ 
          filetreeSubclassType = 'bytes'
            ifTrue: [ subclassType := 'byteSubclass' ]
            ifFalse: [ self error: 'unknown subclass type: ' , filetreeSubclassType printString ] ] ].
  classPropertiesDict at: '_gs_subclassType' put: subclassType.
  ^ super classStructureFrom: classPropertiesDict comment: classComment
%

category: 'accessing'
method: CypressFileTreeFormatPackageReader
propertiesFileNameExtension

	^'.json'
%

category: 'accessing'
method: CypressFileTreeFormatPackageReader
propertiesFileNameExtensions

	^Array
		with: super propertiesFileNameExtension
		with: self propertiesFileNameExtension
%

category: 'reading'
method: CypressFileTreeFormatPackageReader
readMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods
	"Strict!"

	self
		readFileTreeFormatMethodStructureFrom: fileStream
		intoClassStructure: classStructure
		meta: isMeta
		methods: methods
%

! Class implementation for 'CypressFlexiblePackageReader'

!		Instance methods for 'CypressFlexiblePackageReader'

category: 'reading'
method: CypressFlexiblePackageReader
isPropertiesFileDirectoryEntry: entry
	"Expect .ston properties file, but tolerate .json if present."

	^(super isPropertiesFileDirectoryEntry: entry)
		or: [self string: entry endsWith: '/properties.json']
%

category: 'reading'
method: CypressFlexiblePackageReader
readMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods
	"If the stream begins with a double quote, process it on the assumption it is a Cypress-format method.
	 Otherwise, treat it as a FileTree-format method."

	fileStream peek = $"
		ifTrue: 
			[self
				readCypressFormatMethodStructureFrom: fileStream
				intoClassStructure: classStructure
				meta: isMeta
				methods: methods]
		ifFalse: 
			[self
				readFileTreeFormatMethodStructureFrom: fileStream
				intoClassStructure: classStructure
				meta: isMeta
				methods: methods]
%

! Class implementation for 'CypressPackageReader'

!		Instance methods for 'CypressPackageReader'

category: 'reading'
method: CypressPackageReader
readMethodStructureFrom: fileStream intoClassStructure: classStructure meta: isMeta methods: methods
	"Strict!"

	self
		readCypressFormatMethodStructureFrom: fileStream
		intoClassStructure: classStructure
		meta: isMeta
		methods: methods
%

! Class implementation for 'CypressAbstractPackageWriter'

!		Class methods for 'CypressAbstractPackageWriter'

category: 'initialization'
classmethod: CypressAbstractPackageWriter
initializeSpecials
	"Valid binarySelector characters  '!' | '%' | '&' | '*' | '+' | ','' | '/' | '<' | '=' | '>' | '?' | '@' | '\' | '~' | '|' | '-'"

	| map |
	map := Dictionary new.
	map
		at: $! put: 'bang';
		at: $% put: 'percent';
		at: $& put: 'and';
		at: $* put: 'star';
		at: $+ put: 'plus';
		at: $, put: 'comma';
		at: $- put: 'minus';
		at: $/ put: 'slash';
		at: $< put: 'less';
		at: $= put: 'equals';
		at: $> put: 'more';
		at: $? put: 'wat';
		at: $@ put: 'at';
		at: $\ put: 'backslash';
		at: $| put: 'pipe';
		at: $~ put: 'tilde'.
	map keys do: [:key | map at: (map at: key) put: key].
	^map
%

category: 'accessing'
classmethod: CypressAbstractPackageWriter
specials

	^specials ifNil: [specials := self initializeSpecials]
%

!		Instance methods for 'CypressAbstractPackageWriter'

category: 'private'
method: CypressAbstractPackageWriter
determinePackageDirectory

	^self fileUtils ensureDirectoryExists: (self fileUtils
				directoryFromPath: self packageStructure name
				relativeTo: self repository directoryPath)
%

category: 'private'
method: CypressAbstractPackageWriter
directoryForDirectoryNamed: directoryNameOrPath

	^directoryNameOrPath = '.'
		ifTrue: [self fileUtils ensureDirectoryExists: self packageDirectory]
		ifFalse: [self subPackageFileDirectoryFor: directoryNameOrPath]
%

category: 'private'
method: CypressAbstractPackageWriter
fileNameForSelector: selector

	^selector last = $:
		ifTrue: [selector copyReplacing: $: with: $.]
		ifFalse: 
			[(selector first isLetter or: [selector first = $_])
				ifTrue: [selector]
				ifFalse: 
					[| specials output |
					specials := self class specials.
					output := WriteStreamPortable on: (String new: 100).
					output nextPut: $^.
					selector do: [:each | output nextPutAll: (specials at: each)]
						separatedBy: [output nextPut: $.].
					output contents]]
%

category: 'writing'
method: CypressAbstractPackageWriter
removeOldReplacingWithNew
  self fileUtils deleteAll: self packageDirectory.
  self writePropertiesFile.
  self writePackageStructure
%

category: 'private'
method: CypressAbstractPackageWriter
subPackageFileDirectoryFor: directoryNameOrPath

	| dir |
	dir := self fileUtils directoryFromPath: directoryNameOrPath
				relativeTo: self packageDirectory.
	self fileUtils ensureDirectoryExists: dir.
	^dir
%

category: 'writing'
method: CypressAbstractPackageWriter
writeClassComment: classStructure on: fileStream

	fileStream
		nextPutAll: (CypressObject normalizeLineEndingsOf: classStructure comment)
%

category: 'writing'
method: CypressAbstractPackageWriter
writeClassStructure: classStructure to: classPath

	self
		writeInDirectoryName: classPath
			fileName: 'README'
			extension: '.md'
			visit: [:fileStream | self writeClassComment: classStructure on: fileStream];
		writeInDirectoryName: classPath
			fileName: 'properties'
			extension: self propertiesFileNameExtension
			visit: [:fileStream | classStructure properties _writeCypressJsonOn: fileStream]
%

category: 'writing'
method: CypressAbstractPackageWriter
writeExtensionClassStructure: classStructure to: classPath

	self
		writeInDirectoryName: classPath
		fileName: 'properties'
		extension: self propertiesFileNameExtension
		visit: 
			[:fileStream |
			(Dictionary with: 'name' -> classStructure className)
				_writeCypressJsonOn: fileStream]
%

category: 'private'
method: CypressAbstractPackageWriter
writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock

	| directory |
	directory := self directoryForDirectoryNamed: directoryNameOrPath.
	self fileUtils
		writeStreamFor: fileName , ext
		in: directory
		do: [:fileStream | visitBlock value: fileStream]
%

category: 'writing'
method: CypressAbstractPackageWriter
writeMethodStructure: methodStructure onStream: fileStream

	self subclassResponsibility: #writeMethodStructure:onStream:
%

category: 'writing'
method: CypressAbstractPackageWriter
writeMethodStructure: methodStructure to: methodPath

	| filename |
	filename := self fileNameForSelector: methodStructure selector.
	self
		writeInDirectoryName: methodPath
		fileName: filename
		extension: '.st'
		visit: [:fileStream | self writeMethodStructure: methodStructure onStream: fileStream]
%

category: 'writing'
method: CypressAbstractPackageWriter
writePackageStructure

	self
		writePackageStructureClasses: self packageStructure classes
			isClassExtension: false;
		writePackageStructureClasses: self packageStructure extensions
			isClassExtension: true
%

category: 'writing'
method: CypressAbstractPackageWriter
writePackageStructure: aPackageStructure

	self
		packageStructure: aPackageStructure;
		packageDirectory: self determinePackageDirectory;
		removeOldReplacingWithNew
%

category: 'writing'
method: CypressAbstractPackageWriter
writePackageStructureClasses: classStructures isClassExtension: isClassExtension

	| classDirExtension |
	classDirExtension := isClassExtension
				ifTrue: ['.extension']
				ifFalse: ['.class'].
	classStructures do: 
			[:classStructure |
			| classPath instanceMethodPath classMethodPath |
			classPath := classStructure className , classDirExtension
						, self fileUtils pathNameDelimiter asString.
			isClassExtension
				ifTrue: [self writeExtensionClassStructure: classStructure to: classPath]
				ifFalse: [self writeClassStructure: classStructure to: classPath].
			instanceMethodPath := classPath , 'instance' , self fileUtils pathNameDelimiter asString.
			classStructure instanceMethods
				do: [:methodStructure | self writeMethodStructure: methodStructure to: instanceMethodPath].
			classMethodPath := classPath , 'class' , self fileUtils pathNameDelimiter asString.
			classStructure classMethods
				do: [:methodStructure | self writeMethodStructure: methodStructure to: classMethodPath]]
%

category: 'writing'
method: CypressAbstractPackageWriter
writePropertiesFile

	self
		writeInDirectoryName: '.'
		fileName: 'properties'
		extension: self propertiesFileNameExtension
		visit: [:fileStream | Dictionary new _writeCypressJsonOn: fileStream]
%

! Class implementation for 'CypressFileTreeFormatPackageWriter'

!		Instance methods for 'CypressFileTreeFormatPackageWriter'

category: 'private'
method: CypressFileTreeFormatPackageWriter
adjustClassPropertiesForFileTree: classPropertyDict
  | props classType |
  props := classPropertyDict copy.
  classType := (props at: '_gs_subclassType' ifAbsent: [  ])
    ifNil: [ 'normal' ]
    ifNotNil: [ :type | 
      props removeKey: '_gs_subclassType'.
      type = 'indexableSubclass'
        ifTrue: [ 'variable' ]
        ifFalse: [ 
          type = 'byteSubclass'
            ifTrue: [ 'bytes' ]
            ifFalse: [ self error: 'unknown subclass type: ' , type ] ] ].
  props at: 'type' put: classType.
  ^ props
%

category: 'accessing'
method: CypressFileTreeFormatPackageWriter
propertiesFileNameExtension
  ^ '.json'
%

category: 'writing'
method: CypressFileTreeFormatPackageWriter
removeOldReplacingWithNew

	self fileUtils deleteAll: self packageDirectory
		rejecting: 
			[:filename |
			"do not delete the monticello.meta directory to preserve existing Monticello meta data.
       Equivalent behavior to MCFileTreeRepository with Metadata property set to false."
			(self string: filename endsWith: 'monticello.meta')
				or: [ (self string: filename endsWith: '.filetree')
					or: [self string: filename endsWith: 'methodProperties.json']]].
	self writePropertiesFile.
	self writePackageStructure
%

category: 'writing'
method: CypressFileTreeFormatPackageWriter
writeClassStructure: classStructure to: classPath

	self
		writeInDirectoryName: classPath
			fileName: 'README'
			extension: '.md'
			visit: [:fileStream | self writeClassComment: classStructure on: fileStream];
		writeInDirectoryName: classPath
			fileName: 'properties'
			extension: self propertiesFileNameExtension
			visit: 
				[:fileStream |
				(self adjustClassPropertiesForFileTree: classStructure properties)
					_writeCypressJsonOn: fileStream]
%

category: 'writing'
method: CypressFileTreeFormatPackageWriter
writeExtensionClassStructure: classStructure to: classPath

	self
		writeInDirectoryName: classPath
		fileName: 'properties'
		extension: self propertiesFileNameExtension
		visit: 
			[:fileStream |
			(Dictionary with: 'name' -> classStructure className)
				_writeCypressJsonOn: fileStream]
%

category: 'writing'
method: CypressFileTreeFormatPackageWriter
writeMethodStructure: methodStructure onStream: fileStream

	fileStream
		nextPutAll: methodStructure category;
		lf;
		nextPutAll: (CypressObject normalizeLineEndingsOf: methodStructure source)
%

category: 'writing'
method: CypressFileTreeFormatPackageWriter
writePropertiesFile

	self
		writeInDirectoryName: '.'
		fileName: 'properties'
		extension: self propertiesFileNameExtension
		visit: [:fileStream | Dictionary new _writeCypressJsonOn: fileStream]
%

! Class implementation for 'CypressPackageWriter'

!		Instance methods for 'CypressPackageWriter'

category: 'accessing - private'
method: CypressPackageWriter
methodNoticeLine

	^self packageStructure properties
		at: 'copyrightLine'
		ifAbsent: [self repository copyrightProperty]
%

category: 'writing'
method: CypressPackageWriter
writeMethodStructure: methodStructure onStream: fileStream

	fileStream
		nextPutAll: '"';
		lf;
		nextPutAll: 'notice: ' , self methodNoticeLine;
		lf;
		nextPutAll: 'category: ' , methodStructure category;
		lf;
		nextPutAll: '"';
		lf;
		nextPutAll: (CypressObject normalizeLineEndingsOf: methodStructure source)
%

category: 'writing'
method: CypressPackageWriter
writePropertiesFile

	self
		writeInDirectoryName: '.'
		fileName: 'properties'
		extension: self propertiesFileNameExtension
		visit: [:fileStream | self repository properties _writeCypressJsonOn: fileStream]
%

! Class implementation for 'CypressStrictFileTreeFormatDoNothingPackageWriter'

!		Instance methods for 'CypressStrictFileTreeFormatDoNothingPackageWriter'

category: 'writing'
method: CypressStrictFileTreeFormatDoNothingPackageWriter
removeOldReplacingWithNew
	"Change nothing, since a Cypress writer has insufficient information
	 for preserving the FileTree details. Strictly read-only."
%

category: 'writing'
method: CypressStrictFileTreeFormatDoNothingPackageWriter
writePropertiesFile
	"Change nothing, since a Cypress writer has insufficient information
	 for preserving the FileTree details. Strictly read-only."
%

! Class implementation for 'TonelCypressWriter'

!		Class methods for 'TonelCypressWriter'

category: 'instance creation'
classmethod: TonelCypressWriter
on: sourceDir
	^ self new
		sourceDir: sourceDir;
		yourself
%

!		Instance methods for 'TonelCypressWriter'

category: 'accessing'
method: TonelCypressWriter
definitions

	^ snapshot definitions
%

category: 'initializing - private'
method: TonelCypressWriter
initializeForRepository: aCypressFileSystemRepository
  repository := aCypressFileSystemRepository.
  self sourceDir: repository directoryPath
%

category: 'private testing'
method: TonelCypressWriter
isClass: aClassDefinition
	^ aClassDefinition class = CypressClassDefinition
%

category: 'private testing'
method: TonelCypressWriter
isTrait: aClassDefinition
	^ false
%

category: 'accessing'
method: TonelCypressWriter
packageDir
	^ packageDir 
		ifNotNil: [ self fileUtils directoryFromPath: packageDir relativeTo: self sourceDir ]
		ifNil: [ self sourceDir  ]
%

category: 'accessing'
method: TonelCypressWriter
sourceDir
	^ sourceDir
%

category: 'accessing'
method: TonelCypressWriter
sourceDir: aFileReference
	sourceDir := aFileReference
%

category: 'private writing'
method: TonelCypressWriter
writeMethodExtensions
	| classesAndMethods |
	classesAndMethods := Dictionary new.
	snapshot definitions 
		select: [ :each | each isMethodDefinition and: [ each isExtensionMethod ] ]
		thenDo: [ :each | 
			(classesAndMethods 
				at: each className
				ifAbsentPut: [ Set new ])
				add: each ].
	classesAndMethods keysAndValuesDo: [ :className :methods | 
		self writer
			writeExtensionMethods: methods 
			className: className ]
		
	
%

category: 'private writing'
method: TonelCypressWriter
writePackage: aPackageName
	"I'm assuming first category is actually the package"
	packageDir := aPackageName.
	(self fileUtils directoryExists: self packageDir) ifTrue: [ 
		self fileUtils deleteAll: self packageDir ].  
	self fileUtils ensureDirectoryExists: self packageDir.
	self writer writePackage: packageDir
%

category: 'private writing'
method: TonelCypressWriter
writePackageFileNamed: packageFileName do: writerBlock

	self fileUtils 
		writeStreamFor: packageFileName
		in: self packageDir 
		do: [ :aStream | writerBlock value: aStream ]
%

category: 'accessing'
method: TonelCypressWriter
writer
  ^ writer
    ifNil: [ 
      writer := TonelWriter new
        packageWriter: self;
        yourself ]
%

category: 'accessing'
method: TonelCypressWriter
writer: aTonelWriter
	writer := aTonelWriter
%

category: 'writing'
method: TonelCypressWriter
writeSnapshot: aSnapshot
  self
    writeSnapshot: aSnapshot
    inPackageNamed: (aSnapshot dynamicInstVarAt: #'packageName')
%

category: 'writing'
method: TonelCypressWriter
writeSnapshot: aSnapshot inPackageNamed: packageName
  snapshot := aSnapshot.	"ensure package dirs exists. 
	 It has to be just one but well..."
  self writePackage: packageName.	"now export classes"
  (self definitions select: [ :each | each isClassDefinition ])
    do: [ :each | self writer writeClass: each ].	"... and method extensions"
  self writeMethodExtensions
%

category: 'writing'
method: TonelCypressWriter
writeVersion: aVersion
	self writeSnapshot: aVersion snapshot
%

! Class implementation for 'TonelCypressReader'

!		Class methods for 'TonelCypressReader'

category: 'definition creation'
classmethod: TonelCypressReader
definitionForType: aString
  aString = TonelWriter classLabel
    ifTrue: [ ^ CypressClassDefinition ].
  aString = TonelWriter extensionLabel
    ifTrue: [ ^ nil ].
  TonelParseError signal: 'Unknown type declaration.'
%

category: 'accessing'
classmethod: TonelCypressReader
definitionOrders
	"Used to sort definitions inside a snapshot"
	^ Dictionary new
		at: CypressMethodDefinition put: 1;
		at: CypressClassDefinition put: 2;
		yourself
%

category: 'definition creation'
classmethod: TonelCypressReader
newClassDefinitionForClassNamed: nameString superclassName: superclassString category: categoryString instVarNames: ivarArray classVarNames: cvarArray poolDictionaryNames: poolArray classInstVarNames: civarArray type: typeSymbol comment: commentString
  ^ CypressClassDefinition
    name: nameString
    superclassName: superclassString
    category: categoryString
    instVarNames: ivarArray
    classInstVarNames: civarArray
    classVarNames: cvarArray
    poolDictionaryNames: poolArray
    comment: commentString
    type: typeSymbol
%

category: 'definition creation'
classmethod: TonelCypressReader
newClassDefinitionFrom: anArray
  | metadata |
  metadata := anArray sixth.
  ^ CypressClassDefinition
    name: (metadata at: #'name')
    superclassName: (metadata at: #'superclass')
    category: (metadata at: #'category')
    instVarNames: (metadata at: #'instvars' ifAbsent: [ #() ])
    classInstVarNames: (metadata at: #'classinstvars' ifAbsent: [ #() ])
    classVarNames: (metadata at: #'classvars' ifAbsent: [ #() ])
    poolDictionaryNames: (metadata at: #'pools' ifAbsent: [ #() ])
    gs_options: (metadata at: #'gs_options' ifAbsent: [ #() ])
    gs_constraints: (metadata at: #'gs_constraints' ifAbsent: [ #() ])
    comment: (anArray second ifNil: [ '' ])
    type: (metadata at: #'type' ifAbsent: [ #'normal' ]) asSymbol
%

category: 'definition creation'
classmethod: TonelCypressReader
newMethodDefinitionForClassNamed: className classIsMeta: meta selector: selector category: category source: source
  ^ CypressMethodDefinition
    className: className
    classIsMeta: meta
    selector: selector
    category: category
    source: source
%

category: 'definition creation'
classmethod: TonelCypressReader
newTypeDefinitionFrom: anArray
  | typeClass |
  typeClass := self definitionForType: anArray fourth.
  typeClass = CypressClassDefinition
    ifTrue: [ ^ self newClassDefinitionFrom: anArray ].
  "is extension, no type"
  ^ nil
%

category: 'reading'
classmethod: TonelCypressReader
on: rootDirectoryPath fileName: packageName
  | reader |
  reader := self new.
  ^ reader
    packageDirectory:
        rootDirectoryPath , reader fileUtils pathNameDelimiter , packageName;
    packageName: packageName;
    yourself
%

!		Instance methods for 'TonelCypressReader'

category: 'private'
method: TonelCypressReader
canBeLoaded: aFileReference
  | fileName |
  fileName := self fileUtils localNameFrom: aFileReference.
  ^ fileName ~= 'package.st' and: [ fileName endsWith: '.st' ]
%

category: 'private'
method: TonelCypressReader
categoriesFrom: aCollection
  ^ ((aCollection select: [ :each | each isClassDefinition ])
    collect: [ :each | each category asSymbol ]) asSet sortWithBlock: [ :a :b | a < b ]
%

category: 'parser support'
method: TonelCypressReader
definitionForType: aString
  ^ self class definitionForType: aString
%

category: 'accessing'
method: TonelCypressReader
definitions
  ^ definitions
%

category: 'accessing'
method: TonelCypressReader
directoryPath
  ^ directoryPath
%

category: 'accessing'
method: TonelCypressReader
directoryPath: aString
  directoryPath := aString
%

category: 'initializing - private'
method: TonelCypressReader
initializeForRepository: aCypressFileSystemRepository
  repository := aCypressFileSystemRepository.
  self directoryPath: repository directoryPath
%

category: 'loading'
method: TonelCypressReader
loadDefinitions
  "load all definitions in the known directories and files."
  | definitionOrders newDefinitions loadable dir |
  definitionOrders := self class definitionOrders.
  loadable := (self fileUtils directoryEntriesFrom: (dir := self packageDirectory))
               select: [ :each | self canBeLoaded: each ].
  loadable isEmpty ifTrue:[ GsFile gciLogServer:'No loadable files found in ' , dir asString ].
  newDefinitions := ( 
    loadable collect: [ :each | 
    GsFile gciLogServer:'Reading ' , each asString .
      self fileUtils
        readStreamFor: each
        do: [ :s | TonelParser parseStream: s forReader: self ] ])
    flattened
    sort: [ :a :b | (definitionOrders at: a class) < (definitionOrders at: b class) ].
  definitions := newDefinitions sort
%

category: 'loading'
method: TonelCypressReader
loadDefinitionsFromFiles: fileNames
  "From the known directories and files, load only those files
   whose file names end with one of the Strings in the Array  fileNames ."
  | definitionOrders newDefinitions loadable dir |
  definitionOrders := self class definitionOrders.
  loadable := (self fileUtils directoryEntriesFrom: (dir := self packageDirectory))
        select: [ :each | (self canBeLoaded: each) and:[ 
                  (fileNames detect:[:n | each endsWith: n] ifNone:[nil]) ~~ nil] ].
  loadable isEmpty ifTrue:[ 
      GsFile gciLogServer: 'None of specified  files found in ' , dir asString ].
  newDefinitions := ( 
    loadable collect: [ :each | 
    GsFile gciLogServer:'Reading ' , each asString .
      self fileUtils
        readStreamFor: each
        do: [ :s | TonelParser parseStream: s forReader: self ] ])
    flattened
    sort: [ :a :b | (definitionOrders at: a class) < (definitionOrders at: b class) ].
  definitions := newDefinitions sort
%

category: 'parser support'
method: TonelCypressReader
newClassDefinitionFrom: anArray
	^self class newClassDefinitionFrom: anArray
%

category: 'parser support'
method: TonelCypressReader
newMethodDefinitionForClassNamed: className classIsMeta: meta selector: selector category: category source: source
  ^ self class
    newMethodDefinitionForClassNamed: className
    classIsMeta: meta
    selector: selector
    category: category
    source: source
%

category: 'parser support'
method: TonelCypressReader
newTraitDefinitionFrom: anArray
	^ self class newTraitDefinitionFrom: anArray
%

category: 'parser support'
method: TonelCypressReader
newTypeDefinitionFrom: anArray
	^ self class newTypeDefinitionFrom: anArray
%

category: 'accessing'
method: TonelCypressReader
packageName

   ^packageName
%

category: 'accessing'
method: TonelCypressReader
packageName: aString
  packageName := aString.
  self
    packageDirectory:
      (self fileUtils directoryFromPath: packageName relativeTo: self directoryPath)
%

category: 'reading'
method: TonelCypressReader
readPackageStructure
  self loadDefinitions.
  ^ packageStructure
    fromSnapshot: definitions;
    yourself
%

! Class implementation for 'CypressAbstractRepository'

!		Class methods for 'CypressAbstractRepository'

category: 'instance creation'
classmethod: CypressAbstractRepository
createOn: aUrl alias: aString
  ^ self onUrl: aUrl alias: aString
%

category: 'accessing'
classmethod: CypressAbstractRepository
defaultCopyrightNotice

	^DefaultCopyrightNotice
%

category: 'accessing'
classmethod: CypressAbstractRepository
defaultCopyrightNotice: aString

	DefaultCopyrightNotice := aString
%

category: 'initializing'
classmethod: CypressAbstractRepository
initialize

	self initializeDefaultCopyrightNotice
%

category: 'initializing'
classmethod: CypressAbstractRepository
initializeDefaultCopyrightNotice

	self defaultCopyrightNotice isNil ifFalse: [^self].
	self defaultCopyrightNotice: 'This work is protected by copyright. All rights reserved.'
%

category: 'instance creation'
classmethod: CypressAbstractRepository
onUrl: aUrl alias: aString

	^(aUrl repositoryClass new)
		initializeUrl: aUrl andAlias: aString;
		yourself
%

!		Instance methods for 'CypressAbstractRepository'

category: 'accessing properties'
method: CypressAbstractRepository
alias

	^properties 
		at: 'alias'
		ifAbsent: ['']
%

category: 'accessing properties'
method: CypressAbstractRepository
alias: aString

	properties 
		at: 'alias'
		put: aString
%

category: 'accessing properties'
method: CypressAbstractRepository
copyrightProperty

	^properties 
		at: '_cypress_copyright'
		ifAbsent: ['']
%

category: 'accessing properties'
method: CypressAbstractRepository
copyrightProperty: aString

	properties 
		at: '_cypress_copyright'
		put: aString
%

category: 'accessing'
method: CypressAbstractRepository
defaultCopyrightNotice

	^self class defaultCopyrightNotice
%

category: 'accessing'
method: CypressAbstractRepository
description

	^self alias
%

category: 'initializing - private'
method: CypressAbstractRepository
initialize

	self initializeDefaultRepositoryProperties.
	readerClass := CypressPackageReader.
	writerClass := CypressPackageWriter.
%

category: 'initializing - private'
method: CypressAbstractRepository
initializeDefaultCopyrightProperty

	self copyrightProperty: self defaultCopyrightNotice
%

category: 'initializing - private'
method: CypressAbstractRepository
initializeDefaultRepositoryProperties

	properties := Dictionary new.
	self initializeDefaultCopyrightProperty
%

category: 'initializing - private'
method: CypressAbstractRepository
initializeUrl: aUrl andAlias: aString

	self
		initialize;
		url: aUrl;
		alias: aString;
		validateUrl
%

category: 'accessing properties'
method: CypressAbstractRepository
packageExtension

	^properties 
		at: 'packageExtension'
		ifAbsent: ['.package']
%

category: 'printing'
method: CypressAbstractRepository
printDetailsOn: aStream

	aStream nextPutAll: self alias
%

category: 'printing'
method: CypressAbstractRepository
printOn: aStream

	aStream
		nextPutAll: self class name;
		nextPutAll: '('.
	self printDetailsOn: aStream.
	aStream nextPutAll: ')'
%

category: 'reading'
method: CypressAbstractRepository
reader

	^readerClass forRepository: self
%

category: 'reading'
method: CypressAbstractRepository
readPackageStructureForPackageNamed: packageName

	^(self reader)
		readPackageStructureForPackageNamed: packageName;
		packageStructure
%

category: 'accessing'
method: CypressAbstractRepository
url

	^url
%

category: 'accessing'
method: CypressAbstractRepository
url: aString

	url := aString
%

category: 'validating - private'
method: CypressAbstractRepository
validateUrl
	"At this level, there is nothing to check.
	 But different URLs denote different kinds of repositories, and
	 each kind of repository may have specific checks."
%

category: 'writing'
method: CypressAbstractRepository
writePackageStructure: aPackageStructure

	^self writer writePackageStructure: aPackageStructure
%

category: 'writing'
method: CypressAbstractRepository
writer

	^writerClass forRepository: self
%

! Class implementation for 'CypressAbstractFileoutRepository'

!		Class methods for 'CypressAbstractFileoutRepository'

category: 'instance creation'
classmethod: CypressAbstractFileoutRepository
on: aDirectory

	^self new
		initializeForDirectory: aDirectory;
		yourself.
%

!		Instance methods for 'CypressAbstractFileoutRepository'

category: 'accessing'
method: CypressAbstractFileoutRepository
description

	| desc |
	desc := super description.
	^desc notEmpty
		ifTrue: [desc]
		ifFalse: [self directoryPath]
%

category: 'accessing'
method: CypressAbstractFileoutRepository
directoryPath

	^directoryPath
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
directoryPath:  aString

	directoryPath := aString
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
ensureDirectoryPathExists

	self fileUtils ensureDirectoryExists: self directoryPath
%

category: 'accessing - private'
method: CypressAbstractFileoutRepository
fileUtils

	^CypressFileUtilities current
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
initializeCreationOn: aUrl alias: aString

	self
		initializeUrl: aUrl andAlias: aString;
		alias: aString
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
initializeForDirectory: aDirectory

	self initialize.
	self directoryPath: aDirectory.
	self directoryPath isEmpty ifTrue: [^self].	"Not really valid; not a very good idea."
	self ensureDirectoryPathExists.
	self initializeReaderAndWriterClasses.
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
initializeReaderAndWriterClasses
  self subclassResponsibility: #'initializeReaderAndWriterClasses'
%

category: 'initializing - private'
method: CypressAbstractFileoutRepository
initializeUrl: aUrl andAlias: aString

	super initializeUrl: aUrl andAlias: aString.
	self directoryPath: self url pathForDirectory.
	self ensureDirectoryPathExists.
	self initializeReaderAndWriterClasses.
%

category: 'printing'
method: CypressAbstractFileoutRepository
printDetailsOn: aStream

	self alias notEmpty
		ifTrue: 
			[aStream
				nextPutAll: self alias;
				nextPutAll: ': '].
	aStream nextPutAll: self url printString
%

category: 'validating - private'
method: CypressAbstractFileoutRepository
validateUrl
	"At this level, there is nothing to check.
	 But different URLs denote different kinds of repositories, and
	 each kind of repository may have specific checks."

	self url fileName isEmpty
		ifFalse: [self error: self printString, ' should not be used with URLs for file names (', self url fileName, ' in ', self url pathForDirectory, ')']
%

! Class implementation for 'CypressSmalltalkRepository'

!		Instance methods for 'CypressSmalltalkRepository'

category: 'initializing - private'
method: CypressSmalltalkRepository
initializeReaderAndWriterClasses

	readerClass := CypressDoNothingPackageReader.
	writerClass := CypressSmalltalkFileoutWriter.
%

! Class implementation for 'CypressTopazRepository'

!		Instance methods for 'CypressTopazRepository'

category: 'initializing - private'
method: CypressTopazRepository
initializeReaderAndWriterClasses

	readerClass := CypressDoNothingPackageReader.
	writerClass := CypressTopazFileoutWriter.
%

! Class implementation for 'CypressDictionaryRepository'

!		Class methods for 'CypressDictionaryRepository'

category: 'instance creation'
classmethod: CypressDictionaryRepository
on: aDictionary
  ^ self new
    initializeForDictionary: aDictionary;
    yourself
%

!		Instance methods for 'CypressDictionaryRepository'

category: 'accessing'
method: CypressDictionaryRepository
dictionary
  ^ dictionary
%

category: 'accessing'
method: CypressDictionaryRepository
dictionary: aDictionary
  dictionary := aDictionary
%

category: 'initializing - private'
method: CypressDictionaryRepository
initialize
  super initialize.
  readerClass := nil.
  writerClass := nil
%

category: 'initializing - private'
method: CypressDictionaryRepository
initializeForDictionary: aDictionary
  self initialize.
  self dictionary: aDictionary
%

category: 'accessing'
method: CypressDictionaryRepository
packageNames
  ^ self dictionary keys
%

category: 'reading'
method: CypressDictionaryRepository
readPackageStructureForPackageNamed: packageName
  ^ (self dictionary at: packageName) packageStructure
%

category: 'writing'
method: CypressDictionaryRepository
writePackageStructure: aPackageStructure
  ^ self dictionary at: aPackageStructure packageName put: aPackageStructure
%

! Class implementation for 'CypressFileSystemRepository'

!		Class methods for 'CypressFileSystemRepository'

category: 'instance creation'
classmethod: CypressFileSystemRepository
on: aDirectory

	^self new
		initializeForDirectory: aDirectory;
		yourself.
%

!		Instance methods for 'CypressFileSystemRepository'

category: 'accessing - properties'
method: CypressFileSystemRepository
codeFormatProperty

	^properties 
		at: '_gs_format'
		ifAbsent: ['Cypress']
%

category: 'updating properties'
method: CypressFileSystemRepository
codeFormatProperty: aString

	self validate: aString isOneOf: #('Cypress' 'FileTree' 'Flexible').
	properties 
		at: '_gs_format'
		put: aString
%

category: 'accessing'
method: CypressFileSystemRepository
description
  | desc |
  desc := super description.
  ^ desc notEmpty
    ifTrue: [ desc ]
    ifFalse: [ self url asString ]
%

category: 'accessing'
method: CypressFileSystemRepository
directoryPath

	^directoryPath
%

category: 'initializing - private'
method: CypressFileSystemRepository
directoryPath: aString
  | delim |
  delim := self fileUtils pathNameDelimiter.
  aString last = delim last
    ifTrue: [ directoryPath := aString ]
    ifFalse: [ directoryPath := aString , delim ]
%

category: 'testing - private'
method: CypressFileSystemRepository
doesRepositoryFileExist: fileName
	"Answer whether the named file exists at the repository level."

	^self fileUtils
		directoryExists: (self fileUtils
				directoryFromPath: fileName
				relativeTo: self directoryPath)
%

category: 'initializing - private'
method: CypressFileSystemRepository
ensureDirectoryPathExists

	self fileUtils ensureDirectoryExists: self directoryPath
%

category: 'accessing - private'
method: CypressFileSystemRepository
fileUtils

	^CypressFileUtilities current
%

category: 'initializing - private'
method: CypressFileSystemRepository
fixupMissingCopyrightProperty

	self copyrightProperty isEmpty ifFalse: [^self].
	self initializeDefaultCopyrightProperty.
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeCreationOn: aUrl alias: aString

	self
		initializeUrl: aUrl andAlias: aString;
		alias: aString;
		writePropertiesFile
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeDefaultRepositoryProperties

	super initializeDefaultRepositoryProperties.
	self
		codeFormatProperty: 'Cypress';
		strictCodeFormat: false.
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeForDirectory: aDirectory

	self initialize.
	self directoryPath: aDirectory.
	self directoryPath isEmpty ifTrue: [^self].	"Not really valid; not a very good idea."
	self ensureDirectoryPathExists.
	self readPropertiesFile.
	self fixupMissingCopyrightProperty.
	self initializeReaderAndWriterClasses.
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeForFileTreeRepository
  self initializeDefaultRepositoryProperties.
  self
    codeFormatProperty: 'FileTree';
    strictCodeFormat: true
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeReaderAndWriterClasses

	self isCodeFormatCypress
		ifTrue: 
			[self isCodeFormatStrict
				ifTrue: 
					[readerClass := CypressPackageReader.
					writerClass := CypressPackageWriter]
				ifFalse: 
					[readerClass := CypressFlexiblePackageReader.
					writerClass := CypressPackageWriter]]
		ifFalse: 
			[self isCodeFormatStrict
				ifTrue: 
					[readerClass := CypressFileTreeFormatPackageReader.
					writerClass := CypressStrictFileTreeFormatDoNothingPackageWriter]
				ifFalse: 
					[readerClass := CypressFlexiblePackageReader.
					writerClass := CypressFileTreeFormatPackageWriter]]
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeRepositoryDirectory
  self directoryPath: self url pathForDirectory.
  self ensureDirectoryPathExists
%

category: 'initializing - private'
method: CypressFileSystemRepository
initializeUrl: aUrl andAlias: aString
  super initializeUrl: aUrl andAlias: aString.
  self initializeRepositoryDirectory.
  self readPropertiesFile.
  self codeFormatProperty: self url codeFormat.
  self strictCodeFormat: self url isStrict.
  self fixupMissingCopyrightProperty.
  self initializeReaderAndWriterClasses
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatCypress

	^self isCodeFormatProperty: 'Cypress'
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatFileTree

	^self isCodeFormatProperty: 'FileTree'
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatFlexiblyCypress

	^self isCodeFormatStrict not and: [self isCodeFormatCypress]
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatFlexiblyFileTree

	^self isCodeFormatStrict not and: [self isCodeFormatFileTree]
%

category: 'testing properties - private'
method: CypressFileSystemRepository
isCodeFormatProperty: aString

	^(properties at: '_gs_format') equalsNoCase: aString
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatStrict

	^(properties 
		at: '_gs_strict'
		ifAbsent: ['']) equalsNoCase: 'true'
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatStrictlyCypress

	^self isCodeFormatStrict and: [self isCodeFormatCypress]
%

category: 'testing properties'
method: CypressFileSystemRepository
isCodeFormatStrictlyFileTree

	^self isCodeFormatStrict and: [self isCodeFormatFileTree]
%

category: 'accessing'
method: CypressFileSystemRepository
packageNames

	| extension extensionSize |
	extension := self packageExtension.
	extensionSize := extension size.
	^(self fileUtils
		directoryEntriesFrom: self directoryPath , '*' , extension) collect: 
				[:each |
				| localName |
				localName := self fileUtils localNameFrom: each.
				localName copyFrom: 1 to: localName size - extensionSize]
%

category: 'printing'
method: CypressFileSystemRepository
printDetailsOn: aStream
  self alias notEmpty
    ifTrue: [ aStream
        nextPutAll: self alias;
        nextPutAll: ': ' ].
  aStream nextPutAll: self url printString
%

category: 'accessing'
method: CypressFileSystemRepository
properties
  ^ properties
%

category: 'reading'
method: CypressFileSystemRepository
readPropertiesFile

	self readPropertiesFile: (#('properties.ston' 'properties.json' '.filetree')
				detect: [:each | self doesRepositoryFileExist: each]
				ifNone: [^self]).
%

category: 'reading'
method: CypressFileSystemRepository
readPropertiesFile: fileName
	"Expect 'properties.ston' for Cypress, but permit 'properties.json' in which case we assume
	 the format should be FileTree.

	 Supported properties are:
		_cypress_copyright	- the (optional, default) copyright notice for the whole repository
		_gs_format			- optional, determines which format will be used for writing packages (and reading, but ...)
							- either Cypress or FileTree (case-insensitive)
		_gs_strict			- optional, determines whether the reader strictly enforces the format
							- either true or false (case-insensitive)
		_gs_fileout			- optional, determines whether to also produce a *.gs fileout when writing a package
							- either true or false (case-insensitive)
	"

	fileName = '.filetree' ifTrue: [^self initializeForFileTreeRepository].
	self fileUtils
		readStreamFor: fileName
		in: self directoryPath
		do: [:fileStream | properties := CypressJsonParser parseStream: fileStream]
%

category: 'updating properties'
method: CypressFileSystemRepository
strictCodeFormat: aBoolean

	self strictCodeFormatProperty: aBoolean printString

%

category: 'updating properties - private'
method: CypressFileSystemRepository
strictCodeFormatProperty: aString

	self validate: aString isOneOf: #('true' 'false').
	properties 
		at: '_gs_strict'
		put: aString
%

category: 'updating properties - private'
method: CypressFileSystemRepository
validate: aString isOneOf: someStrings

	someStrings
		detect: [:each | aString equalsNoCase: each]
		ifNone: [self error: aString printString, ' must be one of ', someStrings printString].
%

category: 'validating - private'
method: CypressFileSystemRepository
validateUrl
	"At this level, there is nothing to check.
	 But different URLs denote different kinds of repositories, and
	 each kind of repository may have specific checks."

	self url fileName isEmpty
		ifFalse: [self error: self printString, ' should not be used with URLs for file names (', self url fileName, ' in ', self url pathForDirectory, ')']
%

category: 'writing'
method: CypressFileSystemRepository
writePropertiesFile

	self writePropertiesFile: (self isCodeFormatFileTree
				ifTrue: ['properties.json']
				ifFalse: ['properties.ston'])
%

category: 'writing'
method: CypressFileSystemRepository
writePropertiesFile: fileName

	self fileUtils
		writeStreamFor: fileName
		in: self directoryPath
		do: [:fileStream | properties _writeCypressJsonOn: fileStream]
%

! Class implementation for 'CypressFileSystemGitRepository'

!		Class methods for 'CypressFileSystemGitRepository'

category: 'accessing'
classmethod: CypressFileSystemGitRepository
gitRepositoryDir
  | path |
  path := (SessionTemps current at: #'Cypress_FileSystem_Git_Repository_Directory' otherwise: nil)
    ifNil: [
      path := (System gemEnvironmentVariable: 'GEMSTONE_GITDIR')
        ifNil: [ 
          CypressFileUtilities current workingDirectory
          , CypressFileUtilities current pathNameDelimiter , 'cypress-git-repos' ].
      SessionTemps current at: #'Cypress_FileSystem_Git_Repository_Directory' put: path ].
  ^path
%

category: 'accessing'
classmethod: CypressFileSystemGitRepository
gitRepositoryDir: directoryPath
  ^ SessionTemps current at: #'Cypress_FileSystem_Git_Repository_Directory' put: directoryPath
%

category: 'git commands'
classmethod: CypressFileSystemGitRepository
performOnServer: commandLine
  | result |
  result := self
    performOnServer: commandLine
    status: [ :performOnServerStatusArray | "Array of 5 elements: 
       raw status Integer, 
       child process status Integer (after WEXITSTATUS macro applied), 
       result String (or nil if operation failed) ,
       error string from script file write, fork, or result file read ,
       errno value, a SmallInteger from file write, fork, or file read"
      (performOnServerStatusArray at: 1) ~~ 0
        ifTrue: [ | message |
          message := 'performOnServer: ' , commandLine printString , ' stdout: '
            , (performOnServerStatusArray at: 3) printString
            , ' failed with status: '
            , (performOnServerStatusArray at: 1) printString , ' errno: '
            , (performOnServerStatusArray at: 5) printString , ' errStr: '
            , (performOnServerStatusArray at: 4) asString.
          self error: message ].
      performOnServerStatusArray at: 3 ].
  Transcript
    cr;
    show: commandLine printString;
    cr;
    show: result.
  ^ result
%

category: 'git commands'
classmethod: CypressFileSystemGitRepository
performOnServer: commandLine status: statusBlock
  | performOnServerStatusArray |
  performOnServerStatusArray := System _performOnServer: commandLine.
  ^ statusBlock value: performOnServerStatusArray
%

category: 'git commands'
classmethod: CypressFileSystemGitRepository
runGitCommand: argsArray in: gitRootPath

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	stream nextPutAll: 'cd ' , gitRootPath , '; git '.
	argsArray do: 
			[:arg |
			stream
				space;
				nextPutAll: arg].
	^self performOnServer: stream contents
%

!		Instance methods for 'CypressFileSystemGitRepository'

category: 'accessing'
method: CypressFileSystemGitRepository
currentBranch
  | result |
  result := self
    gitCommand: #('rev-parse' '--abbrev-ref' 'HEAD')
    in: self directoryPath.
  ^ result trimWhiteSpace
%

category: 'git querying'
method: CypressFileSystemGitRepository
gitCloneRepositoryAndCheckoutIn: aDirectoryName workingDirectory: workingDirectory
  "Do a clone on the remote repository and do a checkout on it to get the right branch. Complement the directory as well with the working directory."

  | gitDir branch |
  gitDir := workingDirectory , self fileUtils pathNameDelimiter
    , (aDirectoryName subStrings: '/') last.
  branch := self projectBranchOrTag.
  (self fileUtils directoryExists: gitDir)
    ifTrue: [ | targetDirBranch |
      self directoryPath: (self repositoryPath isEmpty
            ifTrue: [ gitDir ]
            ifFalse: [ gitDir , self fileUtils pathNameDelimiter , self repositoryPath ]).
      targetDirBranch := self currentBranch.
      targetDirBranch = branch
        ifFalse: [ self error: self class name asString
                ,
                  ' target directory already exists and is on another branch, cancelling clone and repository instanciation : '
                , gitDir ] ]
    ifFalse: [ self gitCommand: #('clone') , {'-b'.
              branch} , {remoteUrl.
              gitDir} in: workingDirectory.
      self directoryPath: (self repositoryPath isEmpty
            ifTrue: [ gitDir ]
            ifFalse: [ gitDir , self fileUtils pathNameDelimiter , self repositoryPath ]) ]
%

category: 'git querying'
method: CypressFileSystemGitRepository
gitCommand: aCommandString in: aDirectory
  ^ self class runGitCommand: aCommandString in: aDirectory
%

category: 'initializing - private'
method: CypressFileSystemGitRepository
initializeRepositoryDirectory
  self remoteUrl: self url httpsAccessString.
  self
    gitCloneRepositoryAndCheckoutIn: self projectPath
    workingDirectory: self class gitRepositoryDir.
  (self isGitRepository: self directoryPath)
    ifFalse: [ self error: 'This url is not a git repository' , self url printString ]
%

category: 'git querying'
method: CypressFileSystemGitRepository
isGitRepository: aDirectory
  "Check that we have a git repository"

  | gitPath |
  gitPath := self gitCommand: #('rev-parse' '--show-toplevel') in: aDirectory.
  (gitPath indexOfSubCollection: 'fatal:' startingAt: 1 ifAbsent: [ 0 ]) = 1
    ifTrue: [ ^ false ].
  ^ true
%

category: 'accessing'
method: CypressFileSystemGitRepository
projectBranchOrTag
  "right now only expect to work with branches"

  ^ self url projectBranchOrTag
%

category: 'accessing'
method: CypressFileSystemGitRepository
projectPath
  ^ self url projectPath
%

category: 'accessing'
method: CypressFileSystemGitRepository
remoteUrl

   ^remoteUrl
%

category: 'accessing'
method: CypressFileSystemGitRepository
remoteUrl: anObject

   remoteUrl := anObject
%

category: 'accessing'
method: CypressFileSystemGitRepository
repositoryPath
  ^ self url repositoryPath
%

category: 'validating - private'
method: CypressFileSystemGitRepository
validateUrl
  "At this level, there is nothing to check.
	 But different URLs denote different kinds of repositories, and
	 each kind of repository may have specific checks."

  (self url projectPath isEmpty or: [ self url projectBranchOrTag isEmpty ])
    ifTrue: [ self error: self printString , ' should not be used with non-git URLs.' ]
%

! Class implementation for 'CypressTonelRepository'

!		Instance methods for 'CypressTonelRepository'

category: 'updating properties'
method: CypressTonelRepository
codeFormatProperty: aString
  (aString equalsNoCase: 'Tonel')
    ifFalse: [ ^ super codeFormatProperty: aString ].
  properties at: '_gs_format' put: aString
%

category: 'initializing - private'
method: CypressTonelRepository
initializeReaderAndWriterClasses
  self isCodeFormatTonel
    ifTrue: [ 
      readerClass := TonelCypressReader.
      writerClass := TonelCypressWriter ]
    ifFalse: [ super initializeReaderAndWriterClasses ]
%

category: 'testing properties'
method: CypressTonelRepository
isCodeFormatTonel

	^self isCodeFormatProperty: 'Tonel'
%

category: 'accessing properties'
method: CypressTonelRepository
packageExtension
  ^ properties at: 'packageExtension' ifAbsent: [ '' ]
%

category: 'reading'
method: CypressTonelRepository
readPackageStructureForPackageNamed: packageName 
  | reader |
  reader := self reader
    packageName: packageName;
    loadDefinitions;
    yourself.
  ^ CypressSnapshot definitions: reader definitions
%

category: 'reading'
method: CypressTonelRepository
readPackageStructureForPackageNamed: packageName  files: fileNames
  "Load only those files whose file names end with one of the Strings
   in the Array fileNames."
  | reader |
  reader := self reader
    packageName: packageName;
    loadDefinitionsFromFiles: fileNames  ;
    yourself.
  ^ CypressSnapshot definitions: reader definitions
%

category: 'reading'
method: CypressTonelRepository
readPropertiesFile
  "noop"

%

category: 'reading'
method: CypressTonelRepository
readPropertiesFile: fileName
  "noop"

%

category: 'writing'
method: CypressTonelRepository
writePackageStructure: aPackageStructure
  ^ self writer
    writeSnapshot: aPackageStructure snapshot
    inPackageNamed: aPackageStructure packageName
%

category: 'writing'
method: CypressTonelRepository
writePropertiesFile: fileName
  "noop"

%

! Class implementation for 'CypressFileUtilities'

!		Class methods for 'CypressFileUtilities'

category: 'accessing'
classmethod: CypressFileUtilities
current

	^Current
%

category: 'utilities'
classmethod: CypressFileUtilities
deleteAll: aDirectory

	self subclassResponsibility: #deleteAll:
%

category: 'utilities'
classmethod: CypressFileUtilities
deleteAll: aDirectory rejecting: rejectBlock
  self subclassResponsibility: #'deleteAll:rejecting:'
%

category: 'utilities'
classmethod: CypressFileUtilities
directoryEntriesFrom: aDirectory

	self subclassResponsibility: #directoryEntriesFrom:
%

category: 'utilities'
classmethod: CypressFileUtilities
directoryExists: aDirectory

	self subclassResponsibility: #directoryExists:
%

category: 'unknown'
classmethod: CypressFileUtilities
directoryFileNamesAndContents: aDirectory

	self subclassResponsibility: #directoryFileNamesAndContents:
%

category: 'utilities'
classmethod: CypressFileUtilities
directoryFromPath: directoryPath relativeTo: aDirectory

	self subclassResponsibility: #directoryFromPath:relativeTo:
%

category: 'utilities'
classmethod: CypressFileUtilities
ensureDirectoryExists: aDirectory

	self subclassResponsibility: #ensureDirectoryExists:
%

category: 'initializating'
classmethod: CypressFileUtilities
install

	Current := self
%

category: 'utilities'
classmethod: CypressFileUtilities
localNameFrom: aDirectory

	self subclassResponsibility: #localNameFrom:
%

category: 'utilities'
classmethod: CypressFileUtilities
pathNameDelimiter

	self subclassResponsibility: #pathNameDelimiter
%

category: 'utilities'
classmethod: CypressFileUtilities
readStreamFor: filePath do: aOneArgBlock

	self subclassResponsibility: #readStreamFor:do:
%

category: 'utilities'
classmethod: CypressFileUtilities
readStreamFor: filePath in: aDirectory do: aOneArgBlock

	self subclassResponsibility: #readStreamFor:in:do:
%

category: 'utilities'
classmethod: CypressFileUtilities
workingDirectory

	self subclassResponsibility: #workingDirectory
%

category: 'utilities'
classmethod: CypressFileUtilities
writeStreamFor: filePath in: aDirectory do: aOneArgBlock

	self subclassResponsibility: #writeStreamFor:in:do:
%

! Class implementation for 'CypressGemStoneDirectoryUtilities'

!		Class methods for 'CypressGemStoneDirectoryUtilities'

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
deleteAll: aDirectory
  "Delete all the files and directories under the named directory.
	 Ensure we don't try to recursively delete . or .."

  self deleteAll: aDirectory rejecting: [ :filename | false ]
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
deleteAll: aDirectory rejecting: rejectBlock
	"Delete all the files and directories under the named directory.
       Reject file and directores in aDirectory that are rejected by rejectBlock.
       The rejectBlock is not used recursively.
       Ensure we don't try to recursively delete . or .."

	| filename isFile |
	(GsFile contentsAndTypesOfDirectory: aDirectory onClient: false)
		doWithIndex: 
			[:each :index |
			index odd
				ifTrue: [filename := each]
				ifFalse: 
					[isFile := each.
					isFile
						ifTrue: 
							[(rejectBlock value: filename)
								ifFalse: 
									[(rejectBlock value: filename) ifFalse: [GsFile removeServerFile: filename]]]
						ifFalse: 
							[(self endsWithSpecial: filename)
								ifFalse: 
									[(rejectBlock value: filename)
										ifFalse: 
											[self deleteAll: filename rejecting: rejectBlock.
											GsFile removeServerDirectory: filename]]]]]
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
directoryEntriesFrom: aDirectory
	"Answer fully qualified paths to the contents of aDirectory."

	^(GsFile contentsOfDirectory: aDirectory onClient: false) ifNil: [#()]
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
directoryExists: aDirectory

	"handle the case where GsFile class>>existsOnServer: returns nil"
	^ (GsFile existsOnServer: aDirectory) == true
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
directoryFileNamesAndContents: aDirectory
	"Walk the directory tree starting at aDirectory and
	 answer a map of the names of the files in the tree to
	 their contents (which work best when text)."

	| map |
	map := Dictionary new.
	self directoryFileNamesAndContents: aDirectory into: map.
	^map.
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
directoryFileNamesAndContents: aDirectory into: aDictionary
	"Walk the directory tree starting at aDirectory and
	 answer a map of the names of the files in the tree to
	 their contents (which work best when text)."

	| filename isFile |
	(GsFile contentsAndTypesOfDirectory: aDirectory onClient: false)
		doWithIndex: 
			[:each :index |
			index odd
				ifTrue: [filename := each]
				ifFalse: 
					[isFile := each.
					isFile
						ifTrue: 
							[| file |
							file := GsFile openReadOnServer: filename.
							file isNil
								ifFalse: 
									[aDictionary at: filename put: file contents.
									file close]]
						ifFalse: 
							[(self endsWithSpecial: filename)
								ifFalse: [self directoryFileNamesAndContents: filename into: aDictionary]]]]
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
directoryFromPath: directoryPath relativeTo: aDirectory

	| delimiter |
	delimiter := self pathNameDelimiter.
	^(aDirectory last = delimiter last
		or: [(directoryPath indexOfSubCollection: delimiter startingAt: 1 ifAbsent: [ 0 ]) = 1])
			ifTrue: [aDirectory , directoryPath]
			ifFalse: [aDirectory , delimiter , directoryPath]
%

category: 'private'
classmethod: CypressGemStoneDirectoryUtilities
endsWithSpecial: filename
	"Answer true if the given filename ends with any of the special sequences
	'/..' '/.' '\..' '\.', false otherwise."

	| filenameSize finalChars |
	filenameSize := filename size.
	finalChars := filename copyFrom: filenameSize - 1 to: filenameSize.
	finalChars = '/.' ifTrue: [^true].
	finalChars = '\.' ifTrue: [^true].
	finalChars := filename copyFrom: filenameSize - 2 to: filenameSize.
	finalChars = '/..' ifTrue: [^true].
	finalChars = '\..' ifTrue: [^true].
	^false
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
ensureDirectoryExists: aDirectory

	| lastSeparator |
	(GsFile existsOnServer: aDirectory) == true ifTrue: [^aDirectory].
	(GsFile createServerDirectory: aDirectory) ifNotNil: [^aDirectory].
	lastSeparator := aDirectory findLastSubString: self pathNameDelimiter startingAt: aDirectory size.
	lastSeparator <= 1 ifTrue: [self error: 'Cannot create directory'].
	self ensureDirectoryExists: (aDirectory copyFrom: 1 to: lastSeparator - 1).
	self ensureDirectoryExists: aDirectory.
%

category: 'initializating'
classmethod: CypressGemStoneDirectoryUtilities
initialize
	"self initialize"

	self install
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
localNameFrom: aDirectory

	| endOfPath |
	endOfPath := aDirectory findLastSubString: self pathNameDelimiter startingAt: aDirectory size.
	^aDirectory copyFrom: endOfPath + 1 to: aDirectory size
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
pathNameDelimiter

	^'/'
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
readStreamFor: filePath do: aOneArgBlock

	| file stream blockResult |
	GsFile serverErrorString.
	file := GsFile openReadOnServer: filePath.
	GsFile serverErrorString ifNotNil: [:errorMessage | self error: errorMessage].
	[stream := ReadStreamPortable on: (String withAll: file contents asByteArray decodeFromUTF8).
	blockResult := aOneArgBlock value: stream] ensure: [file close].
	^ blockResult
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
readStreamFor: filePath in: aDirectory do: aOneArgBlock

	^ self
		readStreamFor: (self directoryFromPath: filePath relativeTo: aDirectory)
		do: aOneArgBlock
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
workingDirectory

	^System gemEnvironmentVariable: 'PWD'
%

category: 'utilities'
classmethod: CypressGemStoneDirectoryUtilities
writeStreamFor: filePath in: aDirectory do: aOneArgBlock

	| file stream |
	GsFile serverErrorString.
	file := GsFile openWriteOnServer: (self directoryFromPath: filePath relativeTo: aDirectory).
	GsFile serverErrorString ifNotNil: [:errorMessage | self error: errorMessage].
	stream := WriteStreamPortable on: String new.
	[aOneArgBlock value: stream] ensure: [file nextPutAll: stream contents encodeAsUTF8; close]
%

! Class implementation for 'CypressGsGeneralDependencySorter'

!		Class methods for 'CypressGsGeneralDependencySorter'

category: 'instance creation'
classmethod: CypressGsGeneralDependencySorter
on: someCandidates dependsOn: aOneArgBlock dependent: anotherOneArgBlock
	"Create an instance of the receiver capable for sorting the dependencies of someCandidates.
	 aOneArgBlock is used to evaluate the key of the object depended on for a candidate.
	 anotherOneArgBlock is used to evaluate the key of the candidate itself."

	^self new
		initializeOn: someCandidates dependsOn: aOneArgBlock dependent: anotherOneArgBlock;
		yourself.
%

!		Instance methods for 'CypressGsGeneralDependencySorter'

category: 'sorting - private'
method: CypressGsGeneralDependencySorter
determineGraphRoots
  ^ dependencyGraphs
    selectAssociations: [ :each | (candidateAliasMap includesKey: each key) not ]
%

category: 'initializing - private'
method: CypressGsGeneralDependencySorter
initializeOn: someCandidates dependsOn: aOneArgBlock dependent: anotherOneArgBlock

	candidates := someCandidates.
	dependsOnConverter := aOneArgBlock.
	dependentConverter := anotherOneArgBlock.
	individualDependencyMap := Dictionary new.
	dependencyGraphs := Dictionary new.
	candidateAliasMap := Dictionary new
%

category: 'sorting'
method: CypressGsGeneralDependencySorter
inOrder
  | sorted sortedRoots |
  sorted := OrderedCollection new.
  self mapCandidatesIntoGraphs.
  sortedRoots := SortedCollection sortBlock: [ :a :b | a key <= b key ].
  self determineGraphRoots associationsDo: [ :assoc | sortedRoots add: assoc ].
  sortedRoots do: [ :assoc | self transcribeGraph: assoc value into: sorted ].
  ^ sorted
%

category: 'sorting - private'
method: CypressGsGeneralDependencySorter
mapCandidatesIntoGraphs

	| dependsOnKey dependentKey |
	candidates do: 
			[:each |
			| individualDependency |
			dependsOnKey := dependsOnConverter value: each.
			dependentKey := dependentConverter value: each.
			candidateAliasMap at: dependentKey put: each.
			individualDependencyMap at: dependsOnKey ifAbsentPut: [Dictionary new].
			individualDependencyMap at: dependentKey ifAbsentPut: [Dictionary new].
			individualDependency := individualDependencyMap
						associationAt: dependsOnKey.
			(dependencyGraphs includesKey: dependsOnKey)
				ifFalse: [dependencyGraphs add: individualDependency].
			individualDependency value
				add: (individualDependencyMap associationAt: dependentKey)]
%

category: 'sorting - private'
method: CypressGsGeneralDependencySorter
transcribeGraph: subtree into: sorted
  (subtree keys asSortedCollection: [ :a :b | a <= b ])
    do: [ :name | | subsubtree |
      subsubtree := subtree at: name.
      sorted add: (candidateAliasMap at: name).
      self transcribeGraph: subsubtree into: sorted ]
%

! Class implementation for 'CypressJsonParser'

!		Class methods for 'CypressJsonParser'

category: 'instance creation'
classmethod: CypressJsonParser
new

	CypressJsonError signal: 'Instantiate the parser with a stream.'
%

category: 'instance creation'
classmethod: CypressJsonParser
on: aStream
	^ self basicNew initializeOn: aStream
%

category: 'accessing'
classmethod: CypressJsonParser
parse: aString
	^ self parseStream: aString readStream
%

category: 'accessing'
classmethod: CypressJsonParser
parseStream: aStream
	^ (self on: aStream) parse
%

!		Instance methods for 'CypressJsonParser'

category: 'adding'
method: CypressJsonParser
addProperty: anAssociation to: anObject
	"Add the property anAssociation described with key and value to anObject. Subclasses might want to refine this implementation."
	
	^ anObject 
		add: anAssociation;
		yourself
%

category: 'adding'
method: CypressJsonParser
addValue: anObject to: aCollection
	"Add anObject to aCollection. Subclasses might want to refine this implementation."

	^ aCollection copyWith: anObject
%

category: 'creating'
method: CypressJsonParser
createArray
	"Create an empty collection. Subclasses might want to refine this implementation."

	^ Array new
%

category: 'creating'
method: CypressJsonParser
createFalse
	"Create the false literal. Subclasses might want to refine this implementation."
	
	^ false
%

category: 'creating'
method: CypressJsonParser
createNull
	"Create the null literal. Subclasses might want to refine this implementation."

	^ nil
%

category: 'creating'
method: CypressJsonParser
createObject
	"Create an empty object. Subclasses might want to refine this implementation."
	
	^ Dictionary new
%

category: 'creating'
method: CypressJsonParser
createProperty: aKey with: aValue
	"Create an empty attribute value pair. Subclasses might want to refine this implementation."
	
	^ aKey -> aValue
%

category: 'creating'
method: CypressJsonParser
createString: aString
	"Create a string literal. Subclasses might want to refine this implementation."

	^ aString
%

category: 'creating'
method: CypressJsonParser
createTrue
	"Create the true literal. Subclasses might want to refine this implementation."

	^ true
%

category: 'private'
method: CypressJsonParser
expect: aString
	"Expects aString and consume input, throw an error otherwise."

	^(self match: aString)
		ifFalse: [CypressJsonError signal: aString , ' expected']
%

category: 'initialization'
method: CypressJsonParser
initializeOn: aStream
	stream := aStream
%

category: 'private'
method: CypressJsonParser
match: aString
	"Tries to match aString, consume input and answer true if successful."
	
	| position |
	position := stream position.
	aString do: [ :each |
		(stream atEnd or: [ stream next ~= each ]) ifTrue: [ 
			stream position: position.
			^ false ] ].
	self whitespace.
	^ true
%

category: 'parsing'
method: CypressJsonParser
parse

	| result |
	result := self
				whitespace;
				parseValue.
	stream atEnd ifFalse: [CypressJsonError signal: 'end of input expected'].
	^result
%

category: 'parsing'
method: CypressJsonParser
parseArray

	| result |
	self expect: '['.
	result := self createArray.
	(self match: ']') ifTrue: [^result].
	[stream atEnd] whileFalse: 
			[result := self addValue: self parseValue to: result.
			(self match: ']') ifTrue: [^result].
			self expect: ','].
	CypressJsonError signal: 'end of array expected'
%

category: 'parsing-internal'
method: CypressJsonParser
parseCharacter
	| char |
	(char := stream next) = $\ 
		ifFalse: [ ^ char ].
	(char := stream next) = $" 
		ifTrue: [ ^ char ].
	char = $\
		ifTrue: [ ^ char ].
	char = $/
		ifTrue: [ ^ char ].
	char = $b
		ifTrue: [ ^ Character backspace ].
	char = $f
		ifTrue: [ ^ Character newPage ].
	char = $n
		ifTrue: [ ^ Character lf ].
	char = $r
		ifTrue: [ ^ Character cr ].
	char = $t
		ifTrue: [ ^ Character tab ].
	char = $u
		ifTrue: [ ^ self parseCharacterHex ].
	CypressJsonError signal: 'invalid escape character \' , (String with: char)
%

category: 'parsing-internal'
method: CypressJsonParser
parseCharacterHex
  | value |
  value := self parseCharacterHexDigit.
  3 timesRepeat: [ value := (value bitShift: 4) + self parseCharacterHexDigit ].
  ^ Character codePoint: value
%

category: 'parsing-internal'
method: CypressJsonParser
parseCharacterHexDigit
    | digit |
    stream atEnd
        ifFalse: [ 
            digit := stream next codePoint.
            (digit between: 48 and: 57)
                ifTrue: [ ^ digit - 48 ].	"$0"	"$9"
            (digit between: 65 and: 70)
                ifTrue: [ ^ digit - 55 ].	"$A"	"$F"
            (digit between: 97 and: 102)
                ifTrue: [ ^ digit - 87 ]	"$a"	"$f" ].
    CypressJsonError signal: 'hex-digit expected'
%

category: 'parsing-internal'
method: CypressJsonParser
parseNumber
	| negated number |
	negated := stream peek = $-.
	negated ifTrue: [ stream next ].
	number := self parseNumberInteger.
	(stream peek = $.) ifTrue: [
		stream next. 
		number := number + self parseNumberFraction ].
	(stream peek = $e or: [ stream peek = $E ]) ifTrue: [
		stream next.
		number := number * self parseNumberExponent ].
	negated ifTrue: [ number := number negated ].
	self whitespace.
	^ number
%

category: 'parsing-internal'
method: CypressJsonParser
parseNumberExponent
    | number negated |
    number := 0.
    negated := stream peek = $-.
    (negated or: [ stream peek = $+ ])
        ifTrue: [ stream next ].
    [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next codePoint - 48) ].
    negated
        ifTrue: [ number := number negated ].
    ^ 10 raisedTo: number
%

category: 'parsing-internal'
method: CypressJsonParser
parseNumberFraction
    | number power |
    number := 0.
    power := 1.0.
    [ stream atEnd not and: [ stream peek isDigit ] ]
        whileTrue: [ 
            number := 10 * number + (stream next codePoint - 48).
            power := power * 10.0 ].
    ^ number / power
%

category: 'parsing-internal'
method: CypressJsonParser
parseNumberInteger
    | number |
    number := 0.
    [ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [ number := 10 * number + (stream next codePoint - 48) ].
    ^ number
%

category: 'parsing'
method: CypressJsonParser
parseObject

	| result |
	self expect: '{'.
	result := self createObject.
	(self match: '}') ifTrue: [^result].
	[stream atEnd] whileFalse: 
			[result := self addProperty: self parseProperty to: result.
			(self match: '}') ifTrue: [^result].
			self expect: ','].
	CypressJsonError signal: 'end of object expected'
%

category: 'parsing-internal'
method: CypressJsonParser
parseProperty
	| name value |
	name := self parseString.
	self expect: ':'.
	value := self parseValue.
	^ self createProperty: name with: value.
%

category: 'parsing-internal'
method: CypressJsonParser
parseString
	| result |
	self expect: '"'.
	result := WriteStreamPortable on: String new.
	[ stream atEnd or: [ stream peek = $" ] ] 
		whileFalse: [ result nextPut: self parseCharacter ].
	^ self expect: '"'; createString: result contents
%

category: 'parsing'
method: CypressJsonParser
parseValue
	| char |
	stream atEnd ifFalse: [ 
		char := stream peek.
		char = ${
			ifTrue: [ ^ self parseObject ].
		char = $[
			ifTrue: [ ^ self parseArray ].
		char = $"
			ifTrue: [ ^ self parseString ].
		(char = $- or: [ char between: $0 and: $9 ])
			ifTrue: [ ^ self parseNumber ].
		(self match: 'true')
			ifTrue: [ ^ self createTrue ].
		(self match: 'false')
			ifTrue: [ ^ self createFalse ].
		(self match: 'null')
			ifTrue: [ ^ self createNull ] ].
	CypressJsonError signal: 'invalid input'
%

category: 'private'
method: CypressJsonParser
whitespace
	"Strip whitespaces from the input stream."

	[ stream atEnd not and: [ stream peek isSeparator ] ]
		whileTrue: [ stream next ]
%

! Class implementation for 'CypressObject'

!		Class methods for 'CypressObject'

category: 'miscellany'
classmethod: CypressObject
collection: aCollection gather: aOneArgBlock
	"Evaluate the block once for each element of aCollection. The block should answer a collection. 
	Answer an Array containing all elements of all the answered collections."

	| result |
	result := Array new.
	aCollection do: [:each | result addAll: (aOneArgBlock value: each)].
	^result
%

category: 'miscellany'
classmethod: CypressObject
elementsIn: sourceCollection butNotIn: exclusionCollection

	| exclusionSet |
	exclusionSet := exclusionCollection asSet.
	^sourceCollection reject: [:each | exclusionSet includes: each]
%

category: 'miscellany'
classmethod: CypressObject
elementsInBoth: collection1 and: collection2
	"Set intersection generalized to any collections."

	| temporarySet |
	temporarySet := collection2 asSet.
	^collection1 select: [:each | temporarySet includes: each]
%

category: 'converting'
classmethod: CypressObject
normalizeLineEndingsOf: aString
	"Answer a copy of aString with the line endings normalized to
	 correspond to the current platform, regardless of how they were
	 saved. For example, Squeak uses CR and would normalize with
	 #withSqueakLineEndings, for example.

	 GemStone Smalltalk uses the Unix line ending of LF."

	| cr lf inPos outPos outString newOutPos indexLF indexCR |
	cr := Character cr.
	indexCR := aString indexOf: cr startingAt: 1.
	indexCR = 0 ifTrue: [^aString].
	lf := Character lf.
	indexLF := aString indexOf: lf startingAt: 1.
	indexLF = 0 ifTrue: [^aString copyReplacing: cr with: lf].
	inPos := outPos := 1.
	outString := String new: aString size.
	
	["check if next CR is before next LF or if there are no more LF"
	(indexLF = 0 or: [indexCR < indexLF])
		ifTrue: 
			[newOutPos := outPos + 1 + indexCR - inPos.
			outString
				replaceFrom: outPos
				to: newOutPos - 2
				with: aString
				startingAt: inPos.
			outString at: newOutPos - 1 put: lf.
			outPos := newOutPos.
			1 + indexCR = indexLF
				ifTrue: 
					["Caught a CR-LF pair"
					inPos := 1 + indexLF.
					indexLF := aString indexOf: lf startingAt: inPos]
				ifFalse: [inPos := 1 + indexCR].
			indexCR := aString indexOf: cr startingAt: inPos]
		ifFalse: 
			[newOutPos := outPos + 1 + indexLF - inPos.
			outString
				replaceFrom: outPos
				to: newOutPos - 1
				with: aString
				startingAt: inPos.
			outPos := newOutPos.
			inPos := 1 + indexLF.
			indexLF := aString indexOf: lf startingAt: inPos].
	indexCR = 0]
			whileFalse.

	"no more CR line endings. copy the rest"
	newOutPos := outPos + (aString size - inPos + 1).
	outString
		replaceFrom: outPos
		to: newOutPos - 1
		with: aString
		startingAt: inPos.
	^outString copyFrom: 1 to: newOutPos - 1
%

!		Instance methods for 'CypressObject'

category: 'accessing'
method: CypressObject
allClasses

	| classes |
	classes := Array new.
	self symbolList
		do: [:dict | classes addAll: (dict select: [:each | each isBehavior])].
	^classes
%

category: 'private'
method: CypressObject
anyElementOf: aCollection ifEmpty: aBlock

	aCollection do: [:each | ^each].
	^aBlock value
%

category: 'accessing'
method: CypressObject
classesInPackageNamed: aString

	| packageName classes |
	packageName := aString asLowercase.
	classes := Array new.
	self symbolList do: 
			[:dict |
			classes
				addAll: (dict select: 
							[:each |
							each isBehavior and: 
									[| candidateName |
									candidateName := each category asLowercase.
									candidateName = packageName
										or: [(candidateName indexOfSubCollection: packageName , '-' startingAt: 1 ifAbsent: [ 0 ]) = 1]]])].
	^classes sortAscending: #('name')
%

category: 'miscellany'
method: CypressObject
collection: aCollection gather: aOneArgBlock
	"Evaluate the block once for each element of aCollection. The block should answer a collection. 
	Answer an Array containing all elements of all the answered collections."

	^self class collection: aCollection gather: aOneArgBlock
%

category: 'initializing'
method: CypressObject
defaultSymbolDictionaryName
  "Name of the SymbolDictionary where new classes should be installed"

  ^ #'UserGlobals'
%

category: 'sorting'
method: CypressObject
determineClassHierarchicalOrder: someClasses
	"Returns an ordered collection of the specified classes such that
	 hierarchical dependencies come first."
	"Not sure whether we ever get non-behaviors. 
	The previous, more complex, version of this method contained this filter."

	| order toBeOrdered processed aClass |
	toBeOrdered := (someClasses select: [:each | each isBehavior])
				asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[(aClass := self anyElementOf: toBeOrdered ifEmpty: [nil]) isNil]
		whileFalse: 
			[self
				orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed].
	^order
%

category: 'miscellany'
method: CypressObject
elementsIn: sourceCollection butNotIn: exclusionCollection

	^self class elementsIn: sourceCollection butNotIn: exclusionCollection
%

category: 'miscellany'
method: CypressObject
elementsInBoth: collection1 and: collection2
	"Set intersection generalized to any collections."

	^self class elementsInBoth: collection1 and: collection2
%

category: 'initializing'
method: CypressObject
initialize
	"Placeholder: #initialize is not defined by Object in GemStone Smalltalk."
%

category: 'converting'
method: CypressObject
normalizeLineEndingsOf: aString
	"Answer a copy of aString with the line endings normalized to
	 correspond to the current platform, regardless of how they were
	 saved. For example, Squeak uses CR and would normalize with
	 #withSqueakLineEndings, for example."

	^self class normalizeLineEndingsOf: aString.
%

category: 'private'
method: CypressObject
orderBySuperclass: aClass from: toBeOrdered into: order ignoring: processed
	"Private. Add to 'order', superclasses first, aClass and any of its superclasses 
	that appear in 'toBeOrdered' but do not appear in 'processed'.
	Remove from 'toBeOrdered' any class added to 'ordered'.
	Any class seen, add to 'processed' whether or not added to 'order'."

	| superclass |
	superclass := aClass superclass.
	superclass isNil | (processed includes: superclass)
		ifFalse: 
			[self
				orderBySuperclass: superclass
				from: toBeOrdered
				into: order
				ignoring: processed].
	processed add: aClass.
	(toBeOrdered includes: aClass)
		ifTrue: 
			[toBeOrdered remove: aClass.
			order add: aClass]
%

category: 'printing'
method: CypressObject
printDetailsOn: aStream
%

category: 'printing'
method: CypressObject
printOn: aStream

	| className |
	className := self class name.
	aStream
		nextPutAll: (className first isVowel ifTrue:[ 'an ' ] ifFalse:[ 'a ' ]);
		nextPutAll: className;
		nextPutAll: '('.
	self printDetailsOn: aStream.
	aStream nextPutAll: ')'.
%

category: 'accessing'
method: CypressObject
resolveGlobalNamed: aString

	^self resolveGlobalNamed: aString
		or: [CypressError signal: 'Could not resolve global named ' , aString printString]
%

category: 'accessing'
method: CypressObject
resolveGlobalNamed: aString or: aBlock

	^((System myUserProfile resolveSymbol: aString) ifNil: [^aBlock value])
		value
%

category: 'converting'
method: CypressObject
stringForVariables: variableList

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	variableList do: [:each | stream nextPutAll: each]
		separatedBy: [stream space].
	^stream contents
%

category: 'accessing'
method: CypressObject
symbolDictionaryForClassNamed: aString
  "Answer the SymbolDictionary containing the named class.
	 If there are multiple answers, answer the first.
	 If there are no answers (i.e., the class does not exist), put it in UserGlobals."

  ^ self
    symbolDictionaryForClassNamed: aString
    or: [ System myUserProfile objectNamed: self defaultSymbolDictionaryName ]
%

category: 'accessing'
method: CypressObject
symbolDictionaryForClassNamed: aString or: aBlock
	"Answer the SymbolDictionary containing the named class.
	 If there are multiple answers, answer the first.
	 If there are no answers (i.e., the class does not exist), answer
	 the result of evaluating aBlock."

	^self symbolList asArray
		detect: [:each | each anySatisfy: [:every | every isBehavior and: [every name asString = aString asString]]]
		ifNone: aBlock
%

category: 'accessing'
method: CypressObject
symbolList
  ^ System myUserProfile symbolList
%

! Class implementation for 'CypressAbstractPackageInformation'

!		Class methods for 'CypressAbstractPackageInformation'

category: 'Instance Creation'
classmethod: CypressAbstractPackageInformation
named: aString

	^self new
		initializeWithName: aString;
		yourself
%

!		Instance methods for 'CypressAbstractPackageInformation'

category: 'Initializing - private'
method: CypressAbstractPackageInformation
initialize
%

category: 'Initializing - private'
method: CypressAbstractPackageInformation
initializeWithName: aString

	self initialize.
	self name: aString
%

category: 'Testing'
method: CypressAbstractPackageInformation
isKnown

	^false
%

category: 'Accessing'
method: CypressAbstractPackageInformation
name

	^name
%

category: 'Updating'
method: CypressAbstractPackageInformation
name: aString

	name := aString
%

category: 'Printing'
method: CypressAbstractPackageInformation
printDetailsOn: aStream

	aStream nextPutAll: self name
%

category: 'Accessing'
method: CypressAbstractPackageInformation
repositories

	^#()
%

! Class implementation for 'CypressConflictingPackageInformation'

!		Class methods for 'CypressConflictingPackageInformation'

category: 'Instance Creation'
classmethod: CypressConflictingPackageInformation
fromUnknown: unknownPackageInformation conflictingWith: knownPackageInformation

	^(self named: unknownPackageInformation name)
		conflictsWith: knownPackageInformation;
		yourself.
%

!		Instance methods for 'CypressConflictingPackageInformation'

category: 'Accessing'
method: CypressConflictingPackageInformation
conflictsWith

	^conflictsWith
%

category: 'Updating'
method: CypressConflictingPackageInformation
conflictsWith: someCypressKnownPackageInformations

	conflictsWith := someCypressKnownPackageInformations
%

! Class implementation for 'CypressEclipsedPackageInformation'

!		Class methods for 'CypressEclipsedPackageInformation'

category: 'Instance Creation'
classmethod: CypressEclipsedPackageInformation
fromUnknown: unknownPackageInformation eclipsedBy: knownPackageInformation

	^(self named: unknownPackageInformation name)
		eclipsedBy: knownPackageInformation;
		yourself.
%

!		Instance methods for 'CypressEclipsedPackageInformation'

category: 'Accessing'
method: CypressEclipsedPackageInformation
eclipsedBy

	^eclipsedBy
%

category: 'Updating'
method: CypressEclipsedPackageInformation
eclipsedBy: aPackageInformation

	eclipsedBy := aPackageInformation
%

! Class implementation for 'CypressKnownPackageInformation'

!		Class methods for 'CypressKnownPackageInformation'

category: 'Instance Creation'
classmethod: CypressKnownPackageInformation
fromUnknown: aPackageInformation

	^self named: aPackageInformation name
%

!		Instance methods for 'CypressKnownPackageInformation'

category: 'Updating'
method: CypressKnownPackageInformation
addRepository: aRepository

	self repositories at: aRepository url put: aRepository.
	self updateDigestsFromImageAndRepository: aRepository.
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
determineDigestFromImage

	^self packageStructure digest
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
determineDigestFromRepository: aRepository

	^ (aRepository readPackageStructureForPackageNamed: self name) digest.
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
digestFor: source

	^self digestFor: source or: [nil]
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
digestFor: source or: aBlock

	^self digests at: source ifAbsent: aBlock
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
digests

	^digests
%

category: 'Initializing - private'
method: CypressKnownPackageInformation
digests: anIdentityDictionary
	"Key: Source of package definitions (#IMAGE or a Repository url)
	 Value: (e.g. MD5) Digest of the package's defintions or an empty string.
	 A nil digest means there are no definitions for the given source."

   digests := anIdentityDictionary
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
imageDigest

	^self digestFor: #IMAGE.
%

category: 'Initializing - private'
method: CypressKnownPackageInformation
initialize

	super initialize.
	self
		repositories: IdentityDictionary new;
		digests: IdentityDictionary new.
%

category: 'Testing'
method: CypressKnownPackageInformation
isKnown

	^true
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
packageStructure

	^CypressPackageStructure
		fromPackage: (CypressPackageDefinition named: self name)
%

category: 'Updating'
method: CypressKnownPackageInformation
removeRepository: aRepository

	self repositories removeKey: aRepository url ifAbsent: [].
	self digests removeKey: aRepository url ifAbsent: [].
	self updateDigestsFromImage.
%

category: 'Accessing'
method: CypressKnownPackageInformation
repositories

	^repositories
%

category: 'Initializing - private'
method: CypressKnownPackageInformation
repositories: anIdentityDictionary
	"Key: Repository url
	 Value: Repository"

	repositories := anIdentityDictionary
%

category: 'Accessing - digests'
method: CypressKnownPackageInformation
repositoryDigests

	^self repositories collect: [:each | self digestFor: each url]
%

category: 'Updating - digests'
method: CypressKnownPackageInformation
updateDigestsFromAllRepositories

	self repositories do: [:each | self updateDigestsFromRepository: each]
%

category: 'Updating - digests'
method: CypressKnownPackageInformation
updateDigestsFromImage

	self digests at: #IMAGE put: self determineDigestFromImage
%

category: 'Updating - digests'
method: CypressKnownPackageInformation
updateDigestsFromImageAndAllRepositories

	self
		updateDigestsFromImage;
		updateDigestsFromAllRepositories
%

category: 'Updating - digests'
method: CypressKnownPackageInformation
updateDigestsFromImageAndRepository: aRepository

	self
		updateDigestsFromImage;
		updateDigestsFromRepository: aRepository
%

category: 'Updating - digests'
method: CypressKnownPackageInformation
updateDigestsFromRepository: aRepository

	self digests at: aRepository url put: (self determineDigestFromRepository: aRepository).
%

category: 'Writing'
method: CypressKnownPackageInformation
writeChangesToAllRepositories

	| imageDigest changedDigests changedRepositories |
	self updateDigestsFromImageAndAllRepositories.
	imageDigest := self imageDigest.
	changedDigests := self repositoryDigests reject: [:each | each = imageDigest].
	changedRepositories := changedDigests keys collect: [:each | self repositories at: each].
	self writePackageToRepositories: changedRepositories.
%

category: 'Writing'
method: CypressKnownPackageInformation
writePackageToRepositories: someRepositories

	| packageStructure |
	packageStructure := self packageStructure.
	^someRepositories
		do: [:each | each writePackageStructure: packageStructure]
%

! Class implementation for 'CypressDefinition'

!		Instance methods for 'CypressDefinition'

category: 'comparing'
method: CypressDefinition
= aDefinition

	^(aDefinition isKindOf: CypressDefinition)
		and: [aDefinition description = self description]
%

category: 'loading'
method: CypressDefinition
actualClass

	self subclassResponsibility: #actualClass
%

category: 'visiting'
method: CypressDefinition
classDefinition: classBlock methodDefinition: methodBlock
	"default is noop"
%

category: 'accessing'
method: CypressDefinition
description
	self subclassResponsibility: #description
%

category: 'accessing'
method: CypressDefinition
details

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	self printDetailsOn: stream.
	^stream contents
%

category: 'comparing'
method: CypressDefinition
hash
    ^ self description hash
%

category: 'testing'
method: CypressDefinition
isSameRevisionAs: aDefinition
	^ self = aDefinition
%

category: 'loading'
method: CypressDefinition
loadClassDefinition
  self loadClassDefinition: self defaultSymbolDictionaryName
%

category: 'loading'
method: CypressDefinition
loadClassDefinition: aDefaultSymbolDictionaryName
  "default is to do nothing"
%

category: 'loading'
method: CypressDefinition
loadMethodDefinition
	"default is to do nothing"
%

category: 'loading'
method: CypressDefinition
postLoad
	"noop"
%

category: 'loading'
method: CypressDefinition
postLoadOver: aDefinition

	self postLoad
%

category: 'dependency'
method: CypressDefinition
provisions
	"Answer list of global names defined by this definition"

	^#()
%

category: 'dependency'
method: CypressDefinition
requirements
	"Answer list of global names required by this definition"

	^#()
%

category: 'loading'
method: CypressDefinition
unloadDefinition

	self subclassResponsibility: #unloadDefinition
%

! Class implementation for 'CypressClassDefinition'

!		Class methods for 'CypressClassDefinition'

category: 'instance creation'
classmethod: CypressClassDefinition
forClass: aClass

	| superclassname |
	superclassname := aClass superclass
				ifNil: ['nil']
				ifNotNil: [:sClass | sClass name].
	^self
		name: aClass name
		superclassName: superclassname
		category: aClass category
		instVarNames: aClass instVarNames
		classInstVarNames: aClass class instVarNames
		classVarNames: aClass classVarNames
		poolDictionaryNames: aClass sharedPools
		comment: aClass rwComment
		subclassType: (self subclassTypeOf: aClass)
%

category: 'private'
classmethod: CypressClassDefinition
subclassTypeOf: aClass
	"Answer a description of the argument to identify whether it is a regular class,
	 a byte subclass, or an indexable subclass."

	^(aClass isBytes and: [aClass superClass isBytes not])
		ifTrue: ['byteSubclass']
		ifFalse: 
			[(aClass isIndexable and: [aClass superClass isIndexable not])
				ifTrue: ['indexableSubclass']
				ifFalse: ['']]
%

!		Instance methods for 'CypressClassDefinition'

category: 'comparing'
method: CypressClassDefinition
= aDefinition
  ^ super = aDefinition
    and: [ 
      superclassName = aDefinition superclassName
        and: [ 
          category = aDefinition category
            and: [ 
              instVarNames = aDefinition instVarNames
                and: [ 
                  classInstVarNames = aDefinition classInstVarNames
                    and: [ 
                      classVarNames asSortedCollection = aDefinition classVarNames asSortedCollection
                        and: [ 
                          poolDictionaryNames = aDefinition poolDictionaryNames
                            and: [ comment = aDefinition comment ] ] ] ] ] ] ]
%

category: 'loading'
method: CypressClassDefinition
actualClass

	^self resolveGlobalNamed: self name
%

category: 'loading'
method: CypressClassDefinition
actualClassOrNil

	^self resolveGlobalNamed: self name or: [nil]
%

category: 'converting'
method: CypressClassDefinition
asCypressClassDefinition

	^self
%

category: 'accessing'
method: CypressClassDefinition
category

	^category
%

category: 'visiting'
method: CypressClassDefinition
classDefinition: classBlock methodDefinition: methodBlock

	classBlock value: self
%

category: 'accessing'
method: CypressClassDefinition
classDefinitionCreationString

	| stream symbolDict |
	stream := WriteStreamPortable on: (String new: 100).
	stream
		nextPutAll: '(CypressClassDefinition';
		lf;
		tab;
		nextPutAll: 'name: ' , self className printString;
		lf;
		tab;
		nextPutAll: 'superclassName: ' , self superclassName printString;
		lf;
		tab;
		nextPutAll: 'category: ' , self category printString;
		lf;
		tab;
		nextPutAll: 'instVarNames: #(' , self instanceVariablesString , ')';
		lf;
		tab;
		nextPutAll: 'classInstVarNames: #(' , self classInstanceVariablesString
					, ')';
		lf;
		tab;
		nextPutAll: 'classVarNames: #(' , self classVariablesString , ')';
		lf;
		tab;
		nextPutAll: 'poolDictionaryNames: #(' , self poolDictionariesString , ')';
		lf;
		tab;
		nextPutAll: 'comment: ' , self comment printString;
		lf;
		tab;
		nextPutAll: 'subclassType: ' , self subclassType printString , ')';
		lf;
		tab;
		tab;
		yourself.
	symbolDict := self symbolDictionaryForClassNamed: self className.
	self actualClassOrNil isNil
		ifTrue: 
			[stream
				nextPutAll: 'loadClassDefinition.';
				yourself]
		ifFalse: 
			[stream
				nextPutAll: 'loadClassDefinition: ' , symbolDict name asString printString
							, '.';
				yourself].
	^stream contents
%

category: 'private'
method: CypressClassDefinition
classInstanceVariablesString
  ^ self stringForVariables: self classInstVarNames
%

category: 'accessing'
method: CypressClassDefinition
classInstVarNames
  ^ classInstVarNames
%

category: 'accessing'
method: CypressClassDefinition
className

	^self name
%

category: 'loading'
method: CypressClassDefinition
classNeedingMigration: aClass
  "right now we will create classes without doing a migration ..."

  
%

category: 'private'
method: CypressClassDefinition
classVariablesString
  ^ self stringForVariables: self classVarNames asSortedCollection
%

category: 'accessing'
method: CypressClassDefinition
classVarNames
  ^ classVarNames sort
%

category: 'accessing'
method: CypressClassDefinition
comment

	^comment
%

category: 'loading'
method: CypressClassDefinition
createOrReviseByteClass
	"To be resolved:
		- the question of an 'environment' in which to create the class.
		- the question of which SymbolDictionary in which to create the class.
	 These are perhaps the same question."

	| superClass |
	superClass := self resolveGlobalNamed: self superclassName.
	^(superClass
		byteSubclass: self name
		classVars: (self classVarNames collect: [:each | each asSymbol])
		classInstVars: (self classInstVarNames collect: [:each | each asSymbol])
		poolDictionaries: self poolDictionaryList
		inDictionary: (self symbolDictionaryForClassNamed: self name)
		options: #())
			category: category;
			comment: self comment
%

category: 'loading'
method: CypressClassDefinition
createOrReviseIndexableClass
	"To be resolved:
		- the question of an 'environment' in which to create the class.
		- the question of which SymbolDictionary in which to create the class.
	 These are perhaps the same question."

	| superClass |
	superClass := self resolveGlobalNamed: self superclassName.
	^(superClass
		indexableSubclass: self name
		instVarNames: (self instVarNames collect: [:each | each asSymbol])
		classVars: (self classVarNames collect: [:each | each asSymbol])
		classInstVars: (self classInstVarNames collect: [:each | each asSymbol])
		poolDictionaries: self poolDictionaryList
		inDictionary: (self symbolDictionaryForClassNamed: self name)
		options: #())
			category: category;
			comment: self comment
%

category: 'loading'
method: CypressClassDefinition
createOrReviseRegularClass
	"To be resolved:
		- the question of an 'environment' in which to create the class.
		- the question of which SymbolDictionary in which to create the class.
	 These are perhaps the same question."

	| superClass |
	superClass := self resolveGlobalNamed: self superclassName.
	^(superClass
		subclass: self name
		instVarNames: (self instVarNames collect: [:each | each asSymbol])
		classVars: (self classVarNames collect: [:each | each asSymbol])
		classInstVars: (self classInstVarNames collect: [:each | each asSymbol])
		poolDictionaries: self poolDictionaryList
		inDictionary: (self symbolDictionaryForClassNamed: self name)
		options: #())
			category: category;
			comment: self comment
%

category: 'accessing'
method: CypressClassDefinition
defaultSymbolDictionaryName
  ^ defaultSymbolDictionaryName ifNil: [ super defaultSymbolDictionaryName ]
%

category: 'accessing'
method: CypressClassDefinition
defaultSymbolDictionaryName: aSymbol
  defaultSymbolDictionaryName := aSymbol
%

category: 'accessing'
method: CypressClassDefinition
description

	^ Array with: name
%

category: 'loading'
method: CypressClassDefinition
failedCompiledMethods: someCompiledMethods

	someCompiledMethods isEmpty ifTrue: [^self].
	self halt: 'not implemented yet'
%

category: 'accessing'
method: CypressClassDefinition
gs_constraints

	^gs_constraints ifNil: [ gs_constraints := #() ]
%

category: 'accessing'
method: CypressClassDefinition
gs_constraints: aCollection

	gs_constraints := aCollection
%

category: 'accessing'
method: CypressClassDefinition
gs_options

	^gs_options ifNil: [ gs_options := #() ]
%

category: 'accessing'
method: CypressClassDefinition
gs_options: aCollection

	gs_options := aCollection
%

category: 'comparing'
method: CypressClassDefinition
hash

	| hash |
	hash := name hash.
	hash := superclassName hash bitOr: hash.
	hash := (category ifNil: ['']) hash bitOr: hash.
	instVarNames , classInstVarNames, classVarNames, poolDictionaryNames
		do: [:vName | hash := vName hash bitOr: hash].
	^hash
%

category: 'private'
method: CypressClassDefinition
instanceVariablesString
    ^ self stringForVariables: self instVarNames
%

category: 'accessing'
method: CypressClassDefinition
instVarNames
  ^ instVarNames
%

category: 'loading'
method: CypressClassDefinition
loadClassDefinition
  "Create a new version of the defined class. If the class already exists,
	 copy the behaviors and state from the old version."

  ^ self loadClassDefinition: self defaultSymbolDictionaryName
%

category: 'loading'
method: CypressClassDefinition
loadClassDefinition: aDefaultSymbolDictionaryName
	"Create a new version of the defined class. If the class already exists,
	 copy the behaviors and state from the old version."

	| newClass oldClass |
        self defaultSymbolDictionaryName: aDefaultSymbolDictionaryName.
	oldClass := self actualClassOrNil.
	newClass := self createOrReviseClass.
	(oldClass isNil or: [newClass == oldClass]) ifTrue: [^self].
	self classNeedingMigration: newClass.
	self
		recompileWithSubclassesFrom: oldClass
		to: newClass
		symbolList: System myUserProfile symbolList.
%

category: 'accessing'
method: CypressClassDefinition
name

	^name
%

category: 'initialization'
method: CypressClassDefinition
name: aClassName superclassName: aSuperclassName category: aCategory instVarNames: someInstanceVariableNames classInstVarNames: someClassInstanceVariableNames classVarNames: someClassVariableNames poolDictionaryNames: somePoolDictionaryNames comment: aComment subclassType: aSubclassType

	name := aClassName.
	superclassName := aSuperclassName.
	category := aCategory.
	instVarNames := someInstanceVariableNames.
	classInstVarNames := someClassInstanceVariableNames.
	classVarNames := someClassVariableNames.
	poolDictionaryNames := somePoolDictionaryNames.
	comment := aComment.
	subclassType := aSubclassType asString
%

category: 'initialization'
method: CypressClassDefinition
name: aClassName superclassName: aSuperclassName category: aCategory instVarNames: someInstanceVariableNames 
	classInstVarNames: someClassInstanceVariableNames classVarNames: someClassVariableNames 
	poolDictionaryNames: somePoolDictionaryNames gs_options: someGs_options gs_constraints: someGs_constraints
	comment: aComment subclassType: aSubclassType

	name := aClassName.
	superclassName := aSuperclassName.
	category := aCategory.
	instVarNames := someInstanceVariableNames.
	classInstVarNames := someClassInstanceVariableNames.
	classVarNames := someClassVariableNames.
	poolDictionaryNames := somePoolDictionaryNames.
	gs_options := someGs_options.
	gs_constraints := someGs_constraints.
	comment := aComment.
	subclassType := aSubclassType asString
%

category: 'loading'
method: CypressClassDefinition
poolDictionariesForNames: pdNames
  | ar existingDict symList sharedPool |
  ar := Array new.
  symList := System myUserProfile symbolList.
  pdNames
    do: [ :poolName | 
      existingDict := symList objectNamed: poolName.
      existingDict
        ifNil: [ 
          | pool |
          pool := SymbolDictionary new.
          pool name: poolName asSymbol.
          ar add: pool ]
        ifNotNil: [ 
          (existingDict isKindOf: SymbolDictionary)
            ifTrue: [ ar add: existingDict ]
            ifFalse: [ 
              sharedPool ifNil: [ sharedPool := symList objectNamed: #'SharedPool' ].
              ((existingDict isKindOf: Class)
                and: [ existingDict isSubclassOf: sharedPool ])
                ifTrue: [ 
                  | cvars pName |
                  ar add: (cvars := existingDict _createClassVarsDict).
                  pName := poolName asSymbol.	"only change dictionary name if needed , to avoid SecurityError"
                  cvars name ~~ pName
                    ifTrue: [ cvars name: pName ] ] ] ] ].
  ^ ar
%

category: 'private'
method: CypressClassDefinition
poolDictionariesString
  ^ self stringForVariables: self poolDictionaryNames
%

category: 'loading'
method: CypressClassDefinition
poolDictionaryList

  ^ self poolDictionariesForNames: self poolDictionaryNames
%

category: 'accessing'
method: CypressClassDefinition
poolDictionaryNames

	^poolDictionaryNames
%

category: 'printString'
method: CypressClassDefinition
printDetailsOn: aStream

	aStream nextPutAll: self name
%

category: 'dependency'
method: CypressClassDefinition
provisions
	"Answer list of global names defined by this definition"

	^{ self name }
%

category: 'loading'
method: CypressClassDefinition
recompileWithSubclassesFrom: oldClass to: newClass symbolList: aSymbolList

	| olds news removedClassVariables removedSharedPools organizer subclasses newSubclass |
	olds := oldClass _classVars ifNil: [#()] ifNotNil: [:vars | vars keys].
	news := newClass _classVars ifNil: [#()] ifNotNil: [:vars | vars keys].
	removedClassVariables := self elementsIn: olds butNotIn: news.
	removedSharedPools := self elementsIn: oldClass sharedPools
				butNotIn: newClass sharedPools.
	self failedCompiledMethods: (newClass
				_copyMethodsAndVariablesFrom: oldClass
				except: 
					{$V.
					removedClassVariables.
					$P.
					removedSharedPools}
				dictionaries: aSymbolList).
	organizer := ClassOrganizer new.
	subclasses := organizer subclassesOf: oldClass.


	"Do this -after- #subclassesOf:, which has the side effect of replacing the new
	  class with the old class in the organizer"
	organizer addClass: newClass.

	"Iterate over all the first-level subclasses of the old class to create new subclasses"
	subclasses do: 
			[:oldSubclass |
			newSubclass := 
					[oldSubclass definition evaluateInContext: nil symbolList: aSymbolList]
							on: Error
							do: [:ex | ex return: nil].
			(newSubclass notNil and: [newSubclass ~~ oldSubclass])
				ifTrue: 
					[self
						classNeedingMigration: newSubclass;
						recompileWithSubclassesFrom: oldSubclass
							to: newSubclass
							symbolList: aSymbolList]]
%

category: 'dependency'
method: CypressClassDefinition
requirements
	"Answer list of global names required by this definition"

  self superclassName = 'nil'
    ifTrue: [ ^ #() ].
  ^{self superclassName}
%

category: 'accessing'
method: CypressClassDefinition
subclassType

	^subclassType
%

category: 'accessing'
method: CypressClassDefinition
superclassName

	^superclassName
%

category: 'loading'
method: CypressClassDefinition
unloadDefinition
	"GemStone could hold multiple definitions of the same class name.
	 Ignore aliased references.
	 Unload only the first one resolved.
	 It is an error if there is not at least one SymbolDictionary holding a
	 class with that name."

	| dictionarySymbolPair |
	dictionarySymbolPair := ((System myUserProfile symbolList
				dictionariesAndSymbolsOf: self actualClass)
					select: [:each | each last = self name asSymbol]) first.
	dictionarySymbolPair first removeKey: dictionarySymbolPair last
%

! Class implementation for 'CypressMethodDefinition'

!		Class methods for 'CypressMethodDefinition'

category: 'instance creation'
classmethod: CypressMethodDefinition
className: aName classIsMeta: isMetaclass selector: aSelector category: aCategory source: aSource

	^self new
		className: aName asString
		classIsMeta: isMetaclass
		selector: aSelector asString
		category: aCategory asString
		source: (self normalizeLineEndingsOf: aSource)
%

category: 'instance creation'
classmethod: CypressMethodDefinition
forMethod: aGsNMethod

	| behavior selector |
	behavior := aGsNMethod inClass.
	selector := aGsNMethod selector.
	^self new
		className: behavior theNonMetaClass name asString
		classIsMeta: behavior isMeta
		selector: selector asString
		category: (behavior categoryOfSelector: selector) asString
		source: (self normalizeLineEndingsOf: aGsNMethod sourceString asString)
%

!		Instance methods for 'CypressMethodDefinition'

category: 'comparing'
method: CypressMethodDefinition
= aDefinition
    ^ super = aDefinition
        and: [ aDefinition source = self source
                and: [ aDefinition category = self category ] ]
%

category: 'loading'
method: CypressMethodDefinition
actualClass

  ^ self theNonMetaClass
    ifNotNil: [:cls |
      self classIsMeta
        ifTrue: [ cls class ]
        ifFalse: [ cls  ] ].
%

category: 'converting'
method: CypressMethodDefinition
asCypressMethodDefinition

	^self
%

category: 'accessing'
method: CypressMethodDefinition
category

	^category
%

category: 'visiting'
method: CypressMethodDefinition
classDefinition: classBlock methodDefinition: methodBlock

	methodBlock value: self
%

category: 'accessing'
method: CypressMethodDefinition
classIsMeta

	^classIsMeta
%

category: 'accessing'
method: CypressMethodDefinition
className

	^className
%

category: 'initialization'
method: CypressMethodDefinition
className: aName classIsMeta: isMetaclass selector: aSelector category: aCategory source: aSource

	className := aName.
	classIsMeta := isMetaclass.
	selector := aSelector.
	category := aCategory.
	source := self normalizeLineEndingsOf: aSource
%

category: 'accessing'
method: CypressMethodDefinition
description
	^ Array	
		with: className
		with: selector
		with: classIsMeta
%

category: 'comparing'
method: CypressMethodDefinition
hash

	| hash |
	hash := classIsMeta asString hash.
	hash := source hash bitOr: hash.
	hash := category hash bitOr: hash.
	hash := className hash bitOr: hash.
	^hash
%

category: 'visiting'
method: CypressMethodDefinition
instanceMethod: instanceBlock classMethod: classBlock

	^(self classIsMeta
		ifTrue: [ classBlock ]
		ifFalse: [ instanceBlock ]) value: self
%

category: 'testing'
method: CypressMethodDefinition
isInitializer
	^ self selector = 'initialize' and: [self classIsMeta]
%

category: 'loading'
method: CypressMethodDefinition
loadMethodDefinition

	self actualClass
		compileMethod: self source
		dictionaries: System myUserProfile symbolList
		category: self category
		environmentId: 0
%

category: 'loading'
method: CypressMethodDefinition
postLoadOver: aDefinition

	super postLoadOver: aDefinition.
	(self isInitializer
		and: [ aDefinition isNil or: [ self source ~= aDefinition source ]]) 
			ifTrue: [ self theNonMetaClass initialize ].
%

category: 'printing'
method: CypressMethodDefinition
printDetailsOn: aStream

	aStream
		nextPutAll: self className;
		nextPutAll: (self classIsMeta ifTrue: [' class'] ifFalse: ['']);
		nextPutAll: '>>';
		nextPutAll: self selector.
%

category: 'dependency'
method: CypressMethodDefinition
requirements
	"Answer list of global names required by this definition"

	^{self className}
%

category: 'accessing'
method: CypressMethodDefinition
selector

	^selector
%

category: 'accessing'
method: CypressMethodDefinition
source

	^source
%

category: 'loading'
method: CypressMethodDefinition
theNonMetaClass

	^self resolveGlobalNamed: self className or: []
%

category: 'loading'
method: CypressMethodDefinition
unloadDefinition

  self actualClass ifNotNil: [:cl | cl removeSelector: self selector asSymbol ].
%

! Class implementation for 'RwCypressMethodDefinition'

!		Instance methods for 'RwCypressMethodDefinition'

category: 'accessing'
method: RwCypressMethodDefinition
isExtensionMethod

	^ isExtensionMethod ifNil: [ isExtensionMethod := false ]
%

category: 'accessing'
method: RwCypressMethodDefinition
isExtensionMethod: anObject

   isExtensionMethod := anObject
%

! Class implementation for 'CypressDefinitionIndex'

!		Class methods for 'CypressDefinitionIndex'

category: 'instance creation'
classmethod: CypressDefinitionIndex
definitions: aCollection
	^ self new addAll: aCollection
%

!		Instance methods for 'CypressDefinitionIndex'

category: 'adding'
method: CypressDefinitionIndex
add: aDefinition
	^ self definitionMap at: aDefinition description put: aDefinition
%

category: 'adding'
method: CypressDefinitionIndex
addAll: aCollection
	aCollection do: [:ea | self add: ea]
%

category: 'querying'
method: CypressDefinitionIndex
definitionLike: aDefinition ifPresent: foundBlock ifAbsent: errorBlock
	| definition |
	definition := self definitionMap at: aDefinition description ifAbsent: [].
	^ definition
		ifNil: errorBlock
		ifNotNil: [foundBlock value: definition]
%

category: 'accessing'
method: CypressDefinitionIndex
definitionMap
	definitionMap ifNil: [ definitionMap := Dictionary new ].
	^ definitionMap
%

category: 'accessing'
method: CypressDefinitionIndex
definitions
	^self definitionMap values
%

category: 'removing'
method: CypressDefinitionIndex
remove: aDefinition
	self definitionMap removeKey: aDefinition description ifAbsent: []
%

! Class implementation for 'CypressDependencySorter'

!		Instance methods for 'CypressDependencySorter'

category: 'building'
method: CypressDependencySorter
add: aPatchOperation
	| requirements |
	requirements := self unresolvedRequirementsFor: aPatchOperation.
	requirements isEmpty
		ifTrue: [self addToOrder: aPatchOperation]
		ifFalse: [self addRequirements: requirements for: aPatchOperation].
	^ aPatchOperation
%

category: 'building'
method: CypressDependencySorter
addAll: aCollection
	aCollection do: [:aPatchOperation | self add: aPatchOperation ]
%

category: 'private'
method: CypressDependencySorter
addExternalProvisions: aCollection

	(self elementsInBoth: aCollection and: self externalRequirements)
		do: [:globalName | self addProvision: globalName]
%

category: 'private'
method: CypressDependencySorter
addProvision: aGlobalName
	| newlySatisfied |
	self provided add: aGlobalName.
	newlySatisfied := self required removeKey: aGlobalName ifAbsent: [#()].
	self addAll: newlySatisfied.
%

category: 'private'
method: CypressDependencySorter
addRequirement: globalName for: aPatchOperation
	(self itemsRequiring: globalName) add: aPatchOperation
%

category: 'private'
method: CypressDependencySorter
addRequirements: aCollection for: aPatchOperation
	aCollection do: [:globalName | self addRequirement: globalName for: aPatchOperation]
%

category: 'private'
method: CypressDependencySorter
addToOrder: aPatchOperation
	self orderedItems add: aPatchOperation.
	aPatchOperation provisions do: [:globalName | self addProvision: globalName ].
%

category: 'accessing'
method: CypressDependencySorter
externalRequirements

	| unloaded providedByUnloaded |
	unloaded := self itemsWithMissingRequirements.
	providedByUnloaded := (self collection: unloaded
				gather: [:e | e provisions]) asSet.
	^self required keys
		reject: [:globalName | providedByUnloaded includes: globalName]
%

category: 'private'
method: CypressDependencySorter
itemsRequiring: globalName
	^ self required at: globalName ifAbsentPut: [Set new]
%

category: 'accessing'
method: CypressDependencySorter
itemsWithMissingRequirements
	| patchOperations |
	patchOperations := Set new.
	self required values do: [:aSetOfPatchOperations | patchOperations addAll: aSetOfPatchOperations ].
	^ patchOperations
%

category: 'accessing'
method: CypressDependencySorter
orderedItems
	"ordered list of patch operations"

	orderedItems ifNil: [ orderedItems := OrderedCollection new ].
	^orderedItems
%

category: 'accessing'
method: CypressDependencySorter
provided
	"set of global names provided by definitions already loaded"

	provided ifNil: [ provided := Set new ].
	^provided
%

category: 'accessing'
method: CypressDependencySorter
required
	"dictionary of required global name mapped to list of definitions that require the global"

	required ifNil: [ required := Dictionary new ].
	^required
%

category: 'private'
method: CypressDependencySorter
unresolvedRequirementsFor: aPatchOperation
	"Answer a list of global names that are required by <aPatchOperation>, but not 
	 provided by patchOperations that have already been processed"

	^self elementsIn: aPatchOperation requirements butNotIn: self provided
%

! Class implementation for 'CypressEnvironmentDependencySorter'

!		Instance methods for 'CypressEnvironmentDependencySorter'

category: 'building'
method: CypressEnvironmentDependencySorter
add: aPatchOperation
  | requirements |
  requirements := self unresolvedRequirementsFor: aPatchOperation.
  requirements removeIfPresent: 'nil'.
  requirements removeIfPresent: nil.
  requirements isEmpty
    ifTrue: [ self addToOrder: aPatchOperation ]
    ifFalse: [ self addRequirements: requirements for: aPatchOperation ].
  ^ aPatchOperation
%

! Class implementation for 'CypressLoader'

!		Class methods for 'CypressLoader'

category: 'accessing'
classmethod: CypressLoader
defaultSymbolDictionaryName
  "Name of the SymbolDictionary where new classes should be installed"

  ^ (SessionTemps current 
      at: #'Cypress_Loader_Default_Symbol_Dictionary_Name' 
      ifAbsent: [] ) 
        ifNil: [
          System myUserProfile userId = 'SystemUser'
          ifTrue: [ #Globals ]
          ifFalse: [ #'UserGlobals' ] ]
%

category: 'accessing'
classmethod: CypressLoader
defaultSymbolDictionaryName: aSymbol
  SessionTemps current 
      at: #'Cypress_Loader_Default_Symbol_Dictionary_Name'
      put: aSymbol
%

category: 'unloading'
classmethod: CypressLoader
unloadSnapshot: aSnapshot
  ^ self new
    unloadSnapshot: aSnapshot;
    load
%

category: 'loading'
classmethod: CypressLoader
updatePackage: aPackage defaultSymbolDictionaryName: defaultSymbolDictionaryName withSnapshot: aSnapshot
  "Answer the loader used to apply the update."

  ^ self new
    defaultSymbolDictionaryName: defaultSymbolDictionaryName;
    updatePackage: aPackage withSnapshot: aSnapshot;
    load
%

category: 'loading'
classmethod: CypressLoader
updatePackage: aPackage withSnapshot: aSnapshot
  "Answer the loader used to apply the update."

  ^ self
    updatePackage: aPackage
    defaultSymbolDictionaryName: nil
    withSnapshot: aSnapshot
%

!		Instance methods for 'CypressLoader'

category: 'updating'
method: CypressLoader
addFailedPatchOperation: aPatchOperation

	self errors add: aPatchOperation
%

category: 'accessing'
method: CypressLoader
additions

	additions ifNil: [ additions := OrderedCollection new ].
	^additions
%

category: 'loading'
method: CypressLoader
analyze
  self
    analyzeRemovalOfAdditions;
    analyzeAdditions;
    analyzeRemovals
%

category: 'loading'
method: CypressLoader
analyzeAdditions

	| sorter |
	sorter := CypressDependencySorter new 
		addAll: self additions;
		addExternalProvisions: self provisions;
		yourself.
	additions := sorter orderedItems.
	requirements := sorter externalRequirements.
	unloadable := sorter required.
%

category: 'loading'
method: CypressLoader
analyzeRemovalOfAdditions
  "if there is an addition and a removal for the same definition, the addition wins ... needed when loading multiple packages and a defintion has been moved from one package to another --- see atomic loads for Metacello"

  | index |
  index := CypressDefinitionIndex
    definitions: (self additions collect: [ :each | each definition ]).
  self removals
    removeAllSuchThat: [ :removal | 
      (index
        definitionLike: removal definition
        ifPresent: [ :additionDefinition | self obsoletions at: additionDefinition description put: removal definition ]
        ifAbsent: [  ]) notNil ]
%

category: 'loading'
method: CypressLoader
analyzeRemovals

	| sorter |
	sorter := CypressDependencySorter new 
		addAll: self removals;
		yourself.
	removals := sorter orderedItems reverse.
%

category: 'applying'
method: CypressLoader
applyAddition: aCypressPatchOperation

	self additions add: aCypressPatchOperation
%

category: 'applying'
method: CypressLoader
applyModification: aCypressPatchOperation
  self additions add: aCypressPatchOperation.
  self obsoletions
    at: aCypressPatchOperation modification description
    put: aCypressPatchOperation obsoletion
%

category: 'applying'
method: CypressLoader
applyRemoval: aCypressPatchOperation

	self removals add: aCypressPatchOperation
%

category: 'loading'
method: CypressLoader
attemptInitialLoad
  ^ self attemptInitialLoad: true
%

category: 'loading'
method: CypressLoader
attemptInitialLoad: doUnloads

	self
		resetErrors;
		notifyOnFailedPatchOperations;
		loadAdditions: self additions .
  doUnloads ifTrue:[ self unloadRemovals: self removals].
%

category: 'accessing'
method: CypressLoader
defaultSymbolDictionaryName
  ^ defaultSymbolDictionaryName ifNil: [ self class defaultSymbolDictionaryName ]
%

category: 'accessing'
method: CypressLoader
defaultSymbolDictionaryName: aSymbol
  defaultSymbolDictionaryName := aSymbol
%

category: 'loading'
method: CypressLoader
errorOnFailedPatchOperations

	exceptionClass := CypressLoaderError.
%

category: 'accessing'
method: CypressLoader
errors
	errors ifNil: [self resetErrors].
	^errors
%

category: 'loading'
method: CypressLoader
handleCompileError: aCompileError from: aPatchOperation

	| undefinedSymbolErrors otherErrors |
	undefinedSymbolErrors := aCompileError errorDetails
				select: [:each | each first = 1031].
	otherErrors := aCompileError errorDetails
				reject: [:each | each first = 1031].
	undefinedSymbolErrors do: [:each | self requirements add: each last].
	aCompileError pass
%

category: 'loading'
method: CypressLoader
handlePatchOperation: aPatchOperation failure: anException
	"Signal the loader exception appropriate to the current phase.
	 Note that a handler may suppress the #addFailedPatchOperation: by
	 sending #return or #return: to the resignaled exception. Otherwise,
	 resumption from a resumable resignalled exception will continue through
	 this method."

	(exceptionClass patchOperation: aPatchOperation exception: anException) signal.
	self addFailedPatchOperation: aPatchOperation.
%

category: 'loading'
method: CypressLoader
load
  ^self load: true
%

category: 'loading'
method: CypressLoader
load: doUnloads
	self analyze .
  doUnloads ifTrue:[ self reportUnloadableDefinitions ].
	self attemptInitialLoad: doUnloads  ;
		retryFailedLoads;
		postLoad.
%

category: 'loading'
method: CypressLoader
loadAdditions: somePatchOperations
	"Load class definitions first, then method definitions."

	somePatchOperations
		do: [:each | self loadClassDefinition: each];
		do: [:each | self loadMethodDefinition: each].
%

category: 'operations'
method: CypressLoader
loadClassDefinition: aPatchOperation

	[ aPatchOperation loadClassDefinition: self defaultSymbolDictionaryName ]
		on: Error
		do: [:ex | self handlePatchOperation: aPatchOperation failure: ex].
%

category: 'operations'
method: CypressLoader
loadMethodDefinition: aPatchOperation

	
	[[aPatchOperation loadMethodDefinition]
		on: CompileError
		do: [:ex | self handleCompileError: ex from: aPatchOperation]]
			on: Error
			do: [:ex | self handlePatchOperation: aPatchOperation failure: ex]
%

category: 'accessing'
method: CypressLoader
methodAdditions

	^#()
%

category: 'loading'
method: CypressLoader
notifyOnFailedPatchOperations

	exceptionClass := CypressLoaderErrorNotification.
%

category: 'accessing'
method: CypressLoader
obsoletions
  obsoletions ifNil: [ obsoletions := Dictionary new ].
  ^ obsoletions
%

category: 'loading'
method: CypressLoader
postLoad
	"This is where the obsoletion is taken into account ..."

	self additions do: [:each | self postLoad: each].
%

category: 'operations'
method: CypressLoader
postLoad: aPatchOperation

	[aPatchOperation postLoadDefinition]
		on: Error
		do: [:ex | self handlePatchOperation: aPatchOperation failure: ex].
%

category: 'accessing'
method: CypressLoader
provisions
	^ provisions ifNil: [provisions := (self allClasses collect: [:cl | cl name asString]) asSet ]
%

category: 'accessing'
method: CypressLoader
removals

	removals ifNil: [ removals := OrderedCollection new ].
	^removals
%

category: 'loading'
method: CypressLoader
reportUnloadableDefinitions

	self unloadable isEmpty ifTrue: [^self].
	(CypressLoaderMissingClasses missingRequirementsMap: unloadable) signal.
%

category: 'accessing'
method: CypressLoader
requirements

	^requirements
%

category: 'loading'
method: CypressLoader
resetErrors

	errors := OrderedCollection new.
%

category: 'loading'
method: CypressLoader
retryFailedLoads
	"In case any of the failed loads were resolved by subsequent
	 patch operations after the initial attempt or by editting of the
	 failed patch operations by exception handling during the notification
	 phase (initial attempt)."

	| failed |
	failed := self errors.
	self
		resetErrors;
		errorOnFailedPatchOperations;
		loadAdditions: (self elementsInBoth: self additions and: failed);
		unloadRemovals: (self elementsInBoth: self removals and: failed)
%

category: 'accessing'
method: CypressLoader
unloadable

	unloadable ifNil: [ unloadable := OrderedCollection new ].
	^unloadable
%

category: 'operations'
method: CypressLoader
unloadDefinition: aPatchOperation

	[aPatchOperation unloadDefinition]
		on: Error
		do: [:ex | self handlePatchOperation: aPatchOperation failure: ex].
%

category: 'loading'
method: CypressLoader
unloadRemovals: somePatchOperations
	"Removals need to be done after adding classes and methods."

	somePatchOperations
		do: [:each | self unloadDefinition: each].
%

category: 'unloading'
method: CypressLoader
unloadSnapshot: aSnapshot
  |  patch |
  patch := CypressSnapshot empty patchRelativeToBase: aSnapshot.
  patch applyTo: self
%

category: 'loading'
method: CypressLoader
updatePackage: aPackage withSnapshot: aSnapshot

	| patch snapshot |
	snapshot := aPackage snapshot.
	patch := aSnapshot patchRelativeToBase: snapshot.
	patch applyTo: self.
	snapshot definitions do: [:ea | self provisions addAll: ea provisions]
%

! Class implementation for 'CypressEnvironmentLoader'

!		Instance methods for 'CypressEnvironmentLoader'

category: 'accessing'
method: CypressEnvironmentLoader
allClasses
  | classes |
  classes := Array new.
  self defaultSymbolList
    do: [ :dict | classes addAll: (dict select: [ :each | each isBehavior ]) ].
  ^ classes
%

category: 'loading'
method: CypressEnvironmentLoader
analyzeAdditions
  | sorter |
  sorter := CypressEnvironmentDependencySorter new
    addAll: self additions;
    addExternalProvisions: self provisions;
    yourself.
  additions := sorter orderedItems.
  requirements := sorter externalRequirements.
  unloadable := sorter required
%

category: 'loading'
method: CypressEnvironmentLoader
analyzeRemovals
  | sorter |
  sorter := CypressEnvironmentDependencySorter new
    addAll: self removals;
    yourself.
  removals := sorter orderedItems reverse
%

category: 'accessing'
method: CypressEnvironmentLoader
compilationSymbolList
  ^ compilationSymbolList
    ifNil: [ compilationSymbolList := self defaultSymbolList ]
%

category: 'accessing'
method: CypressEnvironmentLoader
compilationSymbolList: anObject

   compilationSymbolList := anObject
%

category: 'accessing'
method: CypressEnvironmentLoader
defaultEnvironmentId
  ^ defaultEnvironmentId ifNil: [ defaultEnvironmentId := 0 ]
%

category: 'accessing'
method: CypressEnvironmentLoader
defaultEnvironmentId: anObject

   defaultEnvironmentId := anObject
%

category: 'accessing'
method: CypressEnvironmentLoader
defaultSymbolList
  ^ System myUserProfile symbolList
%

category: 'operations'
method: CypressEnvironmentLoader
loadClassDefinition: aPatchOperation
  [ 
  aPatchOperation
    loadClassDefinition: self defaultSymbolDictionaryName
    environmentLoader: self ]
    on: Error
    do: [ :ex | self handlePatchOperation: aPatchOperation failure: ex ]
%

category: 'operations'
method: CypressEnvironmentLoader
loadMethodDefinition: aPatchOperation
  [ 
  [ 
  aPatchOperation
    loadMethodDefinition: self lookupSymbolList
    environmentLoader: self ]
    on: CompileError
    do: [ :ex | self handleCompileError: ex from: aPatchOperation ] ]
    on: Error
    do: [ :ex | self handlePatchOperation: aPatchOperation failure: ex ]
%

category: 'accessing'
method: CypressEnvironmentLoader
lookupSymbolList
  ^ lookupSymbolList ifNil: [ lookupSymbolList := self defaultSymbolList ]
%

category: 'accessing'
method: CypressEnvironmentLoader
lookupSymbolList: anObject

   lookupSymbolList := anObject
%

category: 'operations'
method: CypressEnvironmentLoader
postLoad: aPatchOperation
  [ 
  aPatchOperation
    postLoadDefinition: lookupSymbolList
    environmentId: self defaultEnvironmentId ]
    on: Error
    do: [ :ex | self handlePatchOperation: aPatchOperation failure: ex ]
%

! Class implementation for 'CypressPackageDefinition'

!		Class methods for 'CypressPackageDefinition'

category: 'instance creation'
classmethod: CypressPackageDefinition
named: aString

	^self new
		name: aString;
		yourself.
%

!		Instance methods for 'CypressPackageDefinition'

category: 'comparing'
method: CypressPackageDefinition
= other
	^ other species = self species and: [other name sameAs: name]
%

category: 'snapshotting'
method: CypressPackageDefinition
addClass: aClass toDefinitions: definitions

	definitions add: (CypressClassDefinition forClass: aClass)
%

category: 'snapshotting'
method: CypressPackageDefinition
addExtensionMethodsFromClass: aClass toMap: classMap

	| defs map |
	defs := classMap at: aClass theNonMetaClass
				ifAbsent: [OrderedCollection new].
	map := Dictionary new.
	aClass categorysDo: 
			[:category :selectors |
			(category asLowercase
				indexOfSubCollection: '*' , self basePackageName asLowercase startingAt: 1 ifAbsent: [ 0 ]) = 1
				ifTrue: [map at: category put: selectors asSortedCollection]].
	map keys asSortedCollection do: 
			[:category |
			(map at: category) do: 
					[:selector |
					defs add: (CypressMethodDefinition
								forMethod: (aClass compiledMethodAt: selector))]].
	defs notEmpty ifTrue: [classMap at: aClass theNonMetaClass put: defs]
%

category: 'snapshotting'
method: CypressPackageDefinition
addMethodsFromClass: aClass toDefinitions: definitions
	"Add only those methods which are not extensions from other packages."

	(((aClass methodDictForEnv: 0)
		reject: [:each | (each inClass categoryOfSelector: each selector) first = $*])
			asSortedCollection: [:a :b | a selector <= b selector])
			do: [:method | definitions add: (CypressMethodDefinition forMethod: method)]
%

category: 'accessing'
method: CypressPackageDefinition
basePackageName
  "package name may have a platform/branch extension, when comparing against category/protocol names, extension is ignored"

  | nm index |
  nm := self name.
  index := nm indexOfSubCollection: '.' startingAt: 1.
  index = 0
    ifTrue: [ ^ nm ].
  ^ nm copyFrom: 1 to: index - 1
%

category: 'accessing'
method: CypressPackageDefinition
classes
  ^ self classesInPackageNamed: self basePackageName
%

category: 'comparing'
method: CypressPackageDefinition
hash
  ^ name hash
%

category: 'accessing'
method: CypressPackageDefinition
name
	^ name
%

category: 'accessing'
method: CypressPackageDefinition
name: aString
	name := aString
%

category: 'printing'
method: CypressPackageDefinition
printDetailsOn: aStream

	aStream nextPutAll: name
%

category: 'snapshotting'
method: CypressPackageDefinition
snapshot

	| classDefinitions methodDefinitions classMap |
	classDefinitions := OrderedCollection new.
	methodDefinitions := OrderedCollection new.
	(self determineClassHierarchicalOrder: self classes) do: 
			[:cls |
			self
				addClass: cls toDefinitions: classDefinitions;
				addMethodsFromClass: cls toDefinitions: methodDefinitions;
				addMethodsFromClass: cls class toDefinitions: methodDefinitions].
	classMap := Dictionary new.
	self allClasses do: 
			[:each |
			self
				addExtensionMethodsFromClass: each toMap: classMap;
				addExtensionMethodsFromClass: each class toMap: classMap].
	(self determineClassHierarchicalOrder: classMap keys)
		do: [:aClass | methodDefinitions addAll: (classMap at: aClass)].
	^CypressSnapshot definitions: classDefinitions, methodDefinitions
%

! Class implementation for 'CypressEnvironmentPackageDefinition'

!		Instance methods for 'CypressEnvironmentPackageDefinition'

category: 'accessing'
method: CypressEnvironmentPackageDefinition
lookupSymbolList

   ^lookupSymbolList
%

category: 'accessing'
method: CypressEnvironmentPackageDefinition
lookupSymbolList: anObject

   lookupSymbolList := anObject
%

category: 'accessing'
method: CypressEnvironmentPackageDefinition
symbolList
  lookupSymbolList ifNil: [ ^ super symbolList ].
  ^ self lookupSymbolList
%

! Class implementation for 'CypressPackageInformation'

!		Class methods for 'CypressPackageInformation'

category: 'instance creation'
classmethod: CypressPackageInformation
named: aString repository: aCypressRepository
	"Answer an instance of the receiver representing the named package.
	 If the package was saved in a Repository, load up the saved details."

	^self new
		initializeFromName: aString andRepository: aCypressRepository;
		yourself
%

category: 'instance creation'
classmethod: CypressPackageInformation
new

	^super new
		initialize;
		yourself
%

!		Instance methods for 'CypressPackageInformation'

category: 'updating - type'
method: CypressPackageInformation
beConflictedWith: somePackageNames
	"Be designated as representing the prefix of one or more Known Package names."

	type := 'Conflicted Name'.
	competingPackageNames := somePackageNames sortAscending.
	advice := 'Conflicts with the packages named ', self competingPackageNamesString
%

category: 'updating - type'
method: CypressPackageInformation
beKnown
	"Be known to represent a real package."

	type := 'Known Package'.
	advice := ''.
	competingPackageNames := #()
%

category: 'updating - type'
method: CypressPackageInformation
beQualifiedNameOf: somePackageNames
	"Be designated as qualifying a Known Package name and therefore not eligible as a package name."

	type := 'Qualified Name'.
	competingPackageNames := somePackageNames sortAscending.
	advice := 'Qualifies the package named ', self competingPackageNamesString
%

category: 'updating - type'
method: CypressPackageInformation
beUnknown
	"Be designated as possibly representing a package, but not known to do so."

	type := 'Unknown'.
	advice := ''.
	competingPackageNames := #()
%

category: 'accessing'
method: CypressPackageInformation
changesCount

	^changesCount
%

category: 'accessing'
method: CypressPackageInformation
changesCount: anInteger

	changesCount := anInteger
%

category: 'accessing'
method: CypressPackageInformation
changesStatus

	^self hasChanges
		ifTrue: [' (' , self changesCount printString , ')']
		ifFalse: ['']
%

category: 'accessing'
method: CypressPackageInformation
classCount

	^self imageCounts first
%

category: 'accessing'
method: CypressPackageInformation
competingPackageNames

	^competingPackageNames
%

category: 'accessing'
method: CypressPackageInformation
competingPackageNamesString

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	self competingPackageNames
		do: [:each | stream nextPutAll: each printString]
		separatedBy: [stream nextPutAll: ', '].
	^stream contents
%

category: 'accessing'
method: CypressPackageInformation
description

	self isKnown ifTrue: [^self savedLocation].
	self isUnknown ifTrue: [^' <unknown>'].
	^' <', advice, '>'
%

category: 'accessing'
method: CypressPackageInformation
determinedChangesCount

	| notInImage notInSaved |
	notInImage := self savedDefinitions
				reject: [:each | self imageDefinitions includes: each].
	notInSaved := self imageDefinitions
		reject: [:each | self savedDefinitions includes: each].
	^notInImage size + notInSaved size
%

category: 'testing'
method: CypressPackageInformation
hasChanges

	^self changesCount > 0
%

category: 'accessing'
method: CypressPackageInformation
imageCounts

	^imageCounts
%

category: 'accessing'
method: CypressPackageInformation
imageCounts: someIntegers
	"A pair: the number of classes and number of methods"

	imageCounts := someIntegers
%

category: 'accessing'
method: CypressPackageInformation
imageDefinitionCounts

	| classCount methodCount |
	classCount := methodCount := 0.
	self imageDefinitions do: 
			[:each |
			each classDefinition: [:classDefinition | classCount := classCount + 1]
				methodDefinition: [:methodDefinition | methodCount := methodCount + 1]].
	^Array with: classCount with: methodCount
%

category: 'accessing'
method: CypressPackageInformation
imageDefinitions

	^imageDefinitions
%

category: 'accessing'
method: CypressPackageInformation
imageDefinitions: someCypressDefinitions

	imageDefinitions := someCypressDefinitions
%

category: 'accessing'
method: CypressPackageInformation
imageDefinitionsStatus

	^self classCount printString , '/' , self methodCount printString
%

category: 'initializing'
method: CypressPackageInformation
initialize

	self
		beUnknown;
		name: '';
		imageDefinitions: #();
		savedDefinitions: #();
		savedLocation: '';
		repositoryDescription: '';
		imageCounts: #(0 0);
		changesCount: 0
%

category: 'initializing'
method: CypressPackageInformation
initializeFromName: aString andRepository: aCypressRepositoryOrNil

	self name: aString.
	aCypressRepositoryOrNil isNil ifTrue: [^self].
	self updateKnownPackageRepository: aCypressRepositoryOrNil
%

category: 'testing - type'
method: CypressPackageInformation
isConflicted

	^type = 'Conflicted Name'
%

category: 'testing - type'
method: CypressPackageInformation
isKnown

	^type = 'Known Package'
%

category: 'testing - type'
method: CypressPackageInformation
isQualifiedName

	^type = 'Qualified Name'
%

category: 'testing - type'
method: CypressPackageInformation
isUnknown

	^type = 'Unknown'
%

category: 'accessing'
method: CypressPackageInformation
methodCount

	^self imageCounts last
%

category: 'accessing'
method: CypressPackageInformation
name

	^name
%

category: 'accessing'
method: CypressPackageInformation
name: aString

	name := aString
%

category: 'printing'
method: CypressPackageInformation
printDetailsOn: aStream

	aStream
		nextPutAll: self name;
		nextPutAll: ' - ';
		nextPutAll: self description
%

category: 'updating'
method: CypressPackageInformation
readDefinitionsFromRepository

	^(self repository reader readPackageStructureForPackageNamed: self name)
		packageStructure snapshot
		definitions
%

category: 'updating'
method: CypressPackageInformation
refresh

	self isKnown ifFalse: [^self].
	self
		updateImageDefinitions;
		updateSavedDefinitions;
		updateChangesCount.
%

category: 'accessing'
method: CypressPackageInformation
repository

	^repository
%

category: 'accessing'
method: CypressPackageInformation
repository: aCypressFileSystemRepository

	repository := aCypressFileSystemRepository
%

category: 'unknown'
method: CypressPackageInformation
repositoryDescription

	^repositoryDescription
%

category: 'unknown'
method: CypressPackageInformation
repositoryDescription: aString

	repositoryDescription := aString
%

category: 'accessing'
method: CypressPackageInformation
savedDefinitions

	^savedDefinitions
%

category: 'accessing'
method: CypressPackageInformation
savedDefinitions: someCypressDefinitions

	savedDefinitions := someCypressDefinitions
%

category: 'accessing'
method: CypressPackageInformation
savedLocation

	^savedLocation
%

category: 'accessing'
method: CypressPackageInformation
savedLocation: aDirectory

	savedLocation := aDirectory
%

category: 'accessing'
method: CypressPackageInformation
status

	| changes |
	(changes := self changesStatus) isEmpty ifTrue: [^self imageDefinitionsStatus].
	^self imageDefinitionsStatus, changes
%

category: 'updating'
method: CypressPackageInformation
updateChangesCount
	"Must be applied after the image definitions and saved definitions are updated."

	self changesCount: self determinedChangesCount
%

category: 'updating'
method: CypressPackageInformation
updateImageDefinitions

	self
		imageDefinitions: (CypressPackageDefinition named: self name) snapshot
					definitions;
		imageCounts: self imageDefinitionCounts
%

category: 'updating'
method: CypressPackageInformation
updateKnownPackageRepository: aCypressRepository
	"Update the receiver to reflect it being a known package."

	self
		beKnown;
		updateRepository: aCypressRepository;
		refresh.
%

category: 'updating'
method: CypressPackageInformation
updateRepository: aCypressRepository

	self
		repository: aCypressRepository;
		repositoryDescription: self repository description;
		savedLocation: self repository directoryPath
%

category: 'updating'
method: CypressPackageInformation
updateSavedDefinitions

	self savedDefinitions: self readDefinitionsFromRepository
%

! Class implementation for 'CypressPatch'

!		Class methods for 'CypressPatch'

category: 'instance creation'
classmethod: CypressPatch
fromBase: baseSnapshot toTarget: targetSnapshot
	^ (self new)
		fromBase: baseSnapshot
		toTarget: targetSnapshot
%

!		Instance methods for 'CypressPatch'

category: 'applying'
method: CypressPatch
applyTo: aCypressLoader
	operations do: [:ea | ea applyTo: aCypressLoader].
%

category: 'initialization'
method: CypressPatch
fromBase: baseSnapshot toTarget: targetSnapshot
	| base target |	
	operations := OrderedCollection new.
	base := CypressDefinitionIndex definitions: baseSnapshot definitions.
	target := CypressDefinitionIndex definitions: targetSnapshot definitions.
	
	target definitions do:
		[:t |
		base
			definitionLike: t
			ifPresent: [:b | (b isSameRevisionAs: t) ifFalse: [operations add: (CypressModification of: b to: t)]]
			ifAbsent: [operations add: (CypressAddition of: t)]].
		
	base definitions do:
		[:b |
		target
			definitionLike: b
			ifPresent: [:t | ]
			ifAbsent: [operations add: (CypressRemoval of: b)]]
%

category: 'accessing'
method: CypressPatch
operations

	^operations
%

! Class implementation for 'CypressPatchOperation'

!		Instance methods for 'CypressPatchOperation'

category: 'comparing'
method: CypressPatchOperation
= aPatchOperation
	^aPatchOperation isKindOf: self class
%

category: 'applying'
method: CypressPatchOperation
applyTo: aCypressLoader

	self subclassResponsibility: #applyTo:
%

category: 'accessing'
method: CypressPatchOperation
definition
  "answer the primary definition associated with the operation"

  self subclassResponsibility: #'definition'
%

category: 'accessing'
method: CypressPatchOperation
description

	self subclassResponsibility: #description
%

category: 'comparing'
method: CypressPatchOperation
hash
    ^ self description hash
%

category: 'loading'
method: CypressPatchOperation
loadClassDefinition
  self loadClassDefinition: self defaultSymbolDictionaryName
%

category: 'loading'
method: CypressPatchOperation
loadClassDefinition: aDefaultSymbolDictionaryName
  self subclassResponsibility: #'loadClassDefinition'
%

category: 'loading'
method: CypressPatchOperation
loadMethodDefinition

	self subclassResponsibility: #loadMethodDefinition
%

category: 'loading'
method: CypressPatchOperation
postLoadDefinition

	self subclassResponsibility: #postLoadDefinition
%

category: 'printing'
method: CypressPatchOperation
printDetailsOn: aStream

	aStream nextPutAll: self description.
%

category: 'dependency'
method: CypressPatchOperation
provisions
	"Answer list of global names defined by this definition"

	self subclassResponsibility: #provisions
%

category: 'dependency'
method: CypressPatchOperation
requirements
	"Answer list of global names required by this definition"

	self subclassResponsibility: #requirements
%

category: 'loading'
method: CypressPatchOperation
unloadDefinition

	CypressError signal: 'inappropriate to send #unloadDefinition to an addition or modification operation'
%

! Class implementation for 'CypressAddition'

!		Class methods for 'CypressAddition'

category: 'instance creation'
classmethod: CypressAddition
of: aDefinition
	^ self new definition: aDefinition
%

!		Instance methods for 'CypressAddition'

category: 'comparing'
method: CypressAddition
= aPatchOperation
	^(super = aPatchOperation) and: [self definition = aPatchOperation definition]
%

category: 'applying'
method: CypressAddition
applyTo: aCypressLoader

	aCypressLoader applyAddition: self
%

category: 'accessing'
method: CypressAddition
definition

	^definition
%

category: 'initialization'
method: CypressAddition
definition: aDefinition

	definition := aDefinition
%

category: 'accessing'
method: CypressAddition
description
    ^ 'add: ' , self definition printString
%

category: 'comparing'
method: CypressAddition
hash
  ^ super hash bitXor: definition hash
%

category: 'loading'
method: CypressAddition
loadClassDefinition: aDefaultSymbolDictionaryName
  self definition loadClassDefinition: aDefaultSymbolDictionaryName
%

category: 'loading'
method: CypressAddition
loadMethodDefinition
  self definition loadMethodDefinition
%

category: 'loading'
method: CypressAddition
postLoadDefinition
	self definition postLoadOver: nil
%

category: 'dependency'
method: CypressAddition
provisions
	"Answer list of global names defined by this definition"

	^self definition provisions
%

category: 'dependency'
method: CypressAddition
requirements
	"Answer list of global names required by this definition"

	^self definition requirements
%

! Class implementation for 'CypressModification'

!		Class methods for 'CypressModification'

category: 'instance creation'
classmethod: CypressModification
of: base to: target
	^ self new base: base target: target
%

!		Instance methods for 'CypressModification'

category: 'initialization'
method: CypressModification
= aPatchOperation
	^(super = aPatchOperation) and: [self obsoletion = aPatchOperation obsoletion and: [ self modification = aPatchOperation modification]]
%

category: 'applying'
method: CypressModification
applyTo: aCypressLoader

	aCypressLoader applyModification: self
%

category: 'initialization'
method: CypressModification
base: base target: target

	obsoletion := base.
	modification := target.
%

category: 'accessing'
method: CypressModification
definition
  "answer the primary definition associated with the operation"

  ^ self modification
%

category: 'accessing'
method: CypressModification
description
    ^ 'modify from: ' , self obsoletion printString , ' to: ' , self modification printString
%

category: 'comparing'
method: CypressModification
hash
  ^ (super hash bitXor: modification hash) bitXor: obsoletion hash
%

category: 'loading'
method: CypressModification
loadClassDefinition: aDefaultSymbolDictionaryName
  self modification loadClassDefinition: aDefaultSymbolDictionaryName
%

category: 'loading'
method: CypressModification
loadMethodDefinition

	self modification loadMethodDefinition.
%

category: 'accessing'
method: CypressModification
modification

	^modification
%

category: 'accessing'
method: CypressModification
obsoletion

	^obsoletion
%

category: 'loading'
method: CypressModification
postLoadDefinition
	self modification postLoadOver: self obsoletion
%

category: 'dependency'
method: CypressModification
provisions
	"Answer list of global names defined by this definition"

	^self modification provisions
%

category: 'dependency'
method: CypressModification
requirements
	"Answer list of global names required by this definition"

	^self modification requirements
%

! Class implementation for 'CypressRemoval'

!		Class methods for 'CypressRemoval'

category: 'instance creation'
classmethod: CypressRemoval
of: aDefinition
	^ self new definition: aDefinition
%

!		Instance methods for 'CypressRemoval'

category: 'comparing'
method: CypressRemoval
= aPatchOperation
	^(super = aPatchOperation) and: [self definition = aPatchOperation definition]
%

category: 'applying'
method: CypressRemoval
applyTo: aCypressLoader

	aCypressLoader applyRemoval: self
%

category: 'accessing'
method: CypressRemoval
definition

	^definition
%

category: 'initialization'
method: CypressRemoval
definition: aDefinition

	definition := aDefinition
%

category: 'accessing'
method: CypressRemoval
description

	^'remove: ', self definition printString
%

category: 'comparing'
method: CypressRemoval
hash
  ^ super hash bitXor: definition hash
%

category: 'loading'
method: CypressRemoval
loadClassDefinition: aDefaultSymbolDictionaryName
  CypressError
    signal: 'inappropriate to send #loadClassDefinition to a removal operation'
%

category: 'loading'
method: CypressRemoval
loadMethodDefinition
	
	CypressError signal: 'inappropriate to send #loadMethodDefinition to a removal operation'
%

category: 'loading'
method: CypressRemoval
postLoadDefinition
	
	CypressError signal: 'inappropriate to send #postLoadDefinition to a removal operation'
%

category: 'dependency'
method: CypressRemoval
provisions
	"Answer list of global names defined by this definition"

	^#()
%

category: 'dependency'
method: CypressRemoval
requirements
	"Answer list of global names required by this definition"

	^#()
%

category: 'loading'
method: CypressRemoval
unloadDefinition

	self definition unloadDefinition.
%

! Class implementation for 'CypressSnapshot'

!		Class methods for 'CypressSnapshot'

category: 'instance creation'
classmethod: CypressSnapshot
definitions: aDefinitions

	^(self new) definitions: aDefinitions
%

category: 'instance creation'
classmethod: CypressSnapshot
empty

  ^self definitions: #()
%

!		Instance methods for 'CypressSnapshot'

category: 'comparing'
method: CypressSnapshot
= other
	^ definitions asArray = other definitions asArray
%

category: 'enumerating'
method: CypressSnapshot
classDefinitions: classBlock methodDefinitions: methodBlock

	self definitions do: [:definition |
		definition classDefinition: classBlock methodDefinition: methodBlock]
%

category: 'accessing'
method: CypressSnapshot
definitions

	^definitions
%

category: 'accessing'
method: CypressSnapshot
definitions: aDefinitions

	definitions := aDefinitions
%

category: 'comparing'
method: CypressSnapshot
hash
  ^ definitions asArray hash
%

category: 'patching'
method: CypressSnapshot
patchRelativeToBase: aSnapshot
	^ CypressPatch fromBase: aSnapshot toTarget: self
%

category: 'unloading'
method: CypressSnapshot
unload

  ^CypressLoader unloadSnapshot: self
%

category: 'loading'
method: CypressSnapshot
updatePackage: aPackage
  "Answer the loader used to apply the update."

  ^ self updatePackage: aPackage defaultSymbolDictionaryName: nil
%

category: 'loading'
method: CypressSnapshot
updatePackage: aPackage defaultSymbolDictionaryName: defaultSymbolDictionaryName
  "Answer the loader used to apply the update."

  ^ CypressLoader
    updatePackage: aPackage
    defaultSymbolDictionaryName: defaultSymbolDictionaryName
    withSnapshot: self
%

! Class implementation for 'CypressStructure'

!		Class methods for 'CypressStructure'

category: 'instance creation'
classmethod: CypressStructure
named: aString

	^(self new)
		name: aString;
		yourself
%

!		Instance methods for 'CypressStructure'

category: 'accessing'
method: CypressStructure
name

	^name
%

category: 'accessing'
method: CypressStructure
name: aString 

	name := aString
%

category: 'accessing'
method: CypressStructure
packageStructure
	^packageStructure
%

category: 'accessing'
method: CypressStructure
packageStructure: aCypressPackageStructure
	packageStructure := aCypressPackageStructure
%

category: 'printing'
method: CypressStructure
printDetailsOn: aStream

	aStream nextPutAll: self name.
%

category: 'accessing'
method: CypressStructure
properties

	properties ifNil: [ properties := Dictionary new ].
	^properties
%

category: 'accessing'
method: CypressStructure
properties: aDictionary

	properties := aDictionary
%

! Class implementation for 'CypressClassStructure'

!		Class methods for 'CypressClassStructure'

category: 'instance creation'
classmethod: CypressClassStructure
fromClassDefinition: classDefinition

	^self new
		fromClassDefinition: classDefinition;
		yourself
%

!		Instance methods for 'CypressClassStructure'

category: 'converting'
method: CypressClassStructure
asCypressClassDefinition

	self isClassExtension ifTrue: [^CypressError signal: 'Extensions cannot have class definitions'].
	^CypressClassDefinition
		name: self className
		superclassName: self superclassName
		category: self category
		instVarNames: self instanceVariableNames
		classInstVarNames: self classInstanceVariableNames
		classVarNames: self classVariableNames
		poolDictionaryNames: self poolDictionaryNames
		gs_options: self gs_options
		gs_constraints: self gs_constraints
		comment: self comment
		subclassType: self subclassType
%

category: 'accessing'
method: CypressClassStructure
category

	^self properties
		at: 'category'
		ifAbsent: [self packageStructure packageName]
%

category: 'accessing'
method: CypressClassStructure
category: aString

	^self properties at: 'category' put: aString
%

category: 'accessing'
method: CypressClassStructure
classInstanceVariableNames

	^self properties at: 'classinstvars' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
classInstanceVariableNames: someStrings

	^self properties at: 'classinstvars' put: someStrings
%

category: 'converting'
method: CypressClassStructure
classInstanceVariablesString
  ^ self stringForVariables: self classInstanceVariableNames
%

category: 'querying'
method: CypressClassStructure
classMethodNamed: methodName

	^self classMethods
		at: methodName
		ifAbsentPut: [CypressMethodStructure named: methodName]
%

category: 'accessing'
method: CypressClassStructure
classMethods

	classMethods ifNil: [ classMethods := Dictionary new ].
	^classMethods
%

category: 'accessing'
method: CypressClassStructure
className

	^self name
%

category: 'accessing'
method: CypressClassStructure
classVariableNames

	^self properties at: 'classvars' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
classVariableNames: someStrings

	^self properties at: 'classvars' put: someStrings
%

category: 'converting'
method: CypressClassStructure
classVariablesString
  ^ self stringForVariables: self classVariableNames asSortedCollection
%

category: 'accessing'
method: CypressClassStructure
comment

	comment ifNil: [ comment := '' ].
	^comment
%

category: 'accessing'
method: CypressClassStructure
comment: aString

	comment := aString
%

category: 'initialization'
method: CypressClassStructure
fromClassDefinition: classDefinition

	self
		isClassExtension: false;
		name: classDefinition name;
		category: classDefinition category;
		comment: classDefinition comment;
		superclassName: classDefinition superclassName;
		instanceVariableNames: classDefinition instVarNames;
		classInstanceVariableNames: classDefinition classInstVarNames;
		classVariableNames: classDefinition classVarNames;
		poolDictionaryNames: classDefinition poolDictionaryNames;
		subclassType: classDefinition subclassType;
		gs_options: classDefinition gs_options;
		gs_constraints: classDefinition gs_constraints
%

category: 'accessing'
method: CypressClassStructure
gs_constraints

	^self properties at: 'gs_constraints' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
gs_constraints: anConstraintsArray

	^self properties at: 'gs_constraints' put: anConstraintsArray
%

category: 'accessing'
method: CypressClassStructure
gs_options

	^self properties at: 'gs_options' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
gs_options: anOptionsArray

	^self properties at: 'gs_options' put: anOptionsArray
%

category: 'querying'
method: CypressClassStructure
instanceMethodNamed: methodName

	^self instanceMethods
		at: methodName 
		ifAbsentPut: [CypressMethodStructure named: methodName]
%

category: 'accessing'
method: CypressClassStructure
instanceMethods

	instanceMethods ifNil: [ instanceMethods := Dictionary new ].
	^instanceMethods
%

category: 'accessing'
method: CypressClassStructure
instanceVariableNames

	^self properties at: 'instvars' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
instanceVariableNames: someStrings

	^self properties at: 'instvars' put: someStrings
%

category: 'converting'
method: CypressClassStructure
instanceVariablesString

	^self stringForVariables: self instanceVariableNames
%

category: 'accessing'
method: CypressClassStructure
isClassExtension

        isClassExtension ifNil: [ isClassExtension := true ].
        ^isClassExtension
%

category: 'accessing'
method: CypressClassStructure
isClassExtension: aBoolean

	isClassExtension := aBoolean
%

category: 'accessing'
method: CypressClassStructure
name

	^self properties at: 'name'
%

category: 'accessing'
method: CypressClassStructure
name: aString

	self properties at: 'name' put: aString
%

category: 'converting'
method: CypressClassStructure
poolDictionariesString
  ^ self stringForVariables: self poolDictionaryNames
%

category: 'accessing'
method: CypressClassStructure
poolDictionaryNames

	^self properties at: 'pools' ifAbsent: [#()]
%

category: 'accessing'
method: CypressClassStructure
poolDictionaryNames: someStrings

	^self properties at: 'pools' put: someStrings
%

category: 'accessing'
method: CypressClassStructure
subclassType

	^self properties at: '_gs_subclassType' ifAbsent: ['']
%

category: 'accessing'
method: CypressClassStructure
subclassType: aString

	aString isEmpty
		ifTrue: [self properties removeKey: '_gs_subclassType' ifAbsent: []]
		ifFalse: [self properties at: '_gs_subclassType' put: aString]
%

category: 'accessing'
method: CypressClassStructure
superclassName

	^self properties at: 'super'
%

category: 'accessing'
method: CypressClassStructure
superclassName: aString

	^self properties at: 'super' put: aString
%

! Class implementation for 'CypressMethodStructure'

!		Class methods for 'CypressMethodStructure'

category: 'instance creation'
classmethod: CypressMethodStructure
fromMethodDefinition: methodDefinition

	^self new
		fromMethodDefinition: methodDefinition;
		yourself
%

!		Instance methods for 'CypressMethodStructure'

category: 'converting'
method: CypressMethodStructure
asCypressMethodDefinition
	"Try to coerce Unicode source to simple Strings when possible."

	^CypressMethodDefinition 
        	className: self classStructure className
		classIsMeta: self isMetaclass
		selector: self selector
		category: self category
		source: self source asString
%

category: 'accessing'
method: CypressMethodStructure
category

	^self properties at: 'category'
%

category: 'accessing'
method: CypressMethodStructure
category: aString

	self properties at: 'category' put: aString
%

category: 'accessing'
method: CypressMethodStructure
classStructure
	^classStructure
%

category: 'accessing'
method: CypressMethodStructure
classStructure: aCypressClassStructure
	classStructure := aCypressClassStructure
%

category: 'initialization'
method: CypressMethodStructure
fromMethodDefinition: methodDefinition

	self isMetaclass: methodDefinition classIsMeta.
	self selector: methodDefinition selector.
	self category: methodDefinition category.
	self source: methodDefinition source.
%

category: 'accessing'
method: CypressMethodStructure
isMetaclass

	isMetaclass ifNil: [ isMetaclass := false ].
	^isMetaclass
%

category: 'accessing'
method: CypressMethodStructure
isMetaclass: aBoolean
	isMetaclass := aBoolean
%

category: 'accessing'
method: CypressMethodStructure
selector

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	self name
		do: [:chara | stream nextPut: (chara = $. ifTrue: [$:] ifFalse: [chara])].
	^stream contents
%

category: 'accessing'
method: CypressMethodStructure
selector: aString

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	aString
		do: [:chara | stream nextPut: (chara = $: ifTrue: [$.] ifFalse: [chara])].
	name := stream contents
%

category: 'accessing'
method: CypressMethodStructure
source

	^source
%

category: 'accessing'
method: CypressMethodStructure
source: aString

	source := aString
%

! Class implementation for 'RwCypressMethodStructure'

!		Instance methods for 'RwCypressMethodStructure'

category: 'converting'
method: RwCypressMethodStructure
asCypressMethodDefinition

	"Try to coerce Unicode source to simple Strings when possible."

	^ RwCypressMethodDefinition
		className: self classStructure className
		classIsMeta: self isMetaclass
		selector: self selector
		category: self category
		source: self source asString
%

category: 'initialization'
method: RwCypressMethodStructure
fromRwClassMethodDefinition: methodDefinition
  self isMetaclass: true.
  self fromRwMethodDefinition: methodDefinition
%

category: 'initialization'
method: RwCypressMethodStructure
fromRwInstanceMethodDefinition: methodDefinition
  self isMetaclass: false.
  self fromRwMethodDefinition: methodDefinition
%

category: 'initialization'
method: RwCypressMethodStructure
fromRwMethodDefinition: methodDefinition
  self selector: methodDefinition selector asString.
  self category: (methodDefinition properties at: 'protocol').
  self source: methodDefinition source
%

! Class implementation for 'CypressPackageStructure'

!		Class methods for 'CypressPackageStructure'

category: 'instance creation'
classmethod: CypressPackageStructure
fromPackage: aCypressPackageDefinition

	^(self new) 
		fromPackage: aCypressPackageDefinition;
		yourself
%

category: 'instance creation'
classmethod: CypressPackageStructure
name: aPackageNameString from: classDefinitions classMap: classMap
  ^ self new
    name: aPackageNameString from: classDefinitions classMap: classMap;
    yourself
%

!		Instance methods for 'CypressPackageStructure'

category: 'accessing'
method: CypressPackageStructure
classes

	classes ifNil: [ classes := OrderedCollection new ].
	^classes
%

category: 'accessing'
method: CypressPackageStructure
extensions

	extensions ifNil: [ extensions := OrderedCollection new ].
	^extensions
%

category: 'initialization'
method: CypressPackageStructure
fromPackage: aCypressPackageDefinition
  | snapshot classMap classDefinitions |
  snapshot := aCypressPackageDefinition snapshot.
  classDefinitions := OrderedCollection new.
  classMap := Dictionary new.
  snapshot definitions
    do: [ :definition | 
      definition
        classDefinition: [ :classDefinition | classDefinitions add: classDefinition ]
        methodDefinition: [ :methodDefinition | 
          (classMap at: methodDefinition className ifAbsentPut: [ Set new ])
            add: methodDefinition ] ].
  self
    name: aCypressPackageDefinition name , self packageExtension
    from: classDefinitions
    classMap: classMap
%

category: 'initialization'
method: CypressPackageStructure
name: aString from: classDefinitions classMap: classMap

	| classStructure |
	name := aString.
	properties := Dictionary new.
	classDefinitions do: [:classDefinition |
		classStructure := (CypressClassStructure fromClassDefinition: classDefinition)
			packageStructure: self.
		(classMap removeKey: classDefinition className ifAbsent: [#()]) do: [:methodDefinition | | methodStructure |
			methodStructure := (CypressMethodStructure fromMethodDefinition: methodDefinition)
				packageStructure: self;
				classStructure: classStructure.
			(methodDefinition
				instanceMethod: [:instanceMethod | classStructure instanceMethods ] 
				classMethod: [:classMethod | classStructure classMethods ])
					at: methodDefinition selector
					put: methodStructure ].
		self classes add: classStructure ].
	classMap keysAndValuesDo: [:className :methods |
		classStructure := (CypressClassStructure named: className)
			isClassExtension: true;
			packageStructure: self.
		methods do: [:methodDefinition | | methodStructure |
			methodStructure := (CypressMethodStructure fromMethodDefinition: methodDefinition)
				packageStructure: self;
				classStructure: classStructure.
			(methodDefinition
				instanceMethod: [:instanceMethod | classStructure instanceMethods ] 
				classMethod: [:classMethod | classStructure classMethods ])
					at: methodDefinition selector
					put: methodStructure ].
		self extensions add: classStructure ].
%

category: 'accessing'
method: CypressPackageStructure
packageExtension

	^self packageExtensionOr: ['.package' ]
%

category: 'accessing'
method: CypressPackageStructure
packageExtensionOr: aBlock

	^self properties at: 'extension' ifAbsent: aBlock
%

category: 'accessing'
method: CypressPackageStructure
packageName

	| extension extensionSize stopIndex |
	extension := self packageExtension.
	extensionSize := extension size.
	stopIndex :=  extensionSize < self name size
		ifTrue: [
			self name
					indexOfSubCollection: extension
					startingAt: self name size - extensionSize + 1
					ifAbsent: [ self name size + 1 ] ]
		ifFalse: [  self name size + 1 ].
	^self name copyFrom: 1 to: stopIndex - 1
%

category: 'accessing'
method: CypressPackageStructure
packageStructure
	^self
%

category: 'snapshotting'
method: CypressPackageStructure
snapshot
	| definitions |
	definitions := OrderedCollection new.
	self classes do: [:classStructure |
        	definitions add: classStructure asCypressClassDefinition.
                (classStructure instanceMethods asSortedCollection: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ].
                (classStructure classMethods asSortedCollection: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ]].
	self extensions do: [:classStructure |
                (classStructure instanceMethods asSortedCollection: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ].
                (classStructure classMethods asSortedCollection: [:a :b | a selector <= b selector]) do: [:methodStructure |
			definitions add: methodStructure asCypressMethodDefinition ]].
	^ CypressSnapshot definitions: definitions
%

! Class implementation for 'RwCypressPackageStructure'

!		Instance methods for 'RwCypressPackageStructure'

category: 'initialization'
method: RwCypressPackageStructure
fromPackage: aRwPackageDefinition

	| classStructure |
	aRwPackageDefinition classDefinitions
		do: [ :classDefinition | 
			classStructure := (CypressClassStructure fromClassDefinition: classDefinition)
				packageStructure: self.
			classDefinition instanceMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwInstanceMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure instanceMethods
						at: methodDefinition selector
						put: methodStructure ].
			classDefinition classMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwClassMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure classMethods
						at: methodDefinition selector
						put: methodStructure ].
			self classes add: classStructure ].
	aRwPackageDefinition classExtensions
		do: [ :extensionDefinition | 
			classStructure := (CypressClassStructure named: extensionDefinition name)
				isClassExtension: true;
				packageStructure: self.
			extensionDefinition instanceMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwInstanceMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure instanceMethods
						at: methodDefinition selector
						put: methodStructure ].
			extensionDefinition classMethodDefinitions
				do: [ :methodDefinition | 
					| methodStructure |
					methodStructure := RwCypressMethodStructure new
						fromRwClassMethodDefinition: methodDefinition;
						packageStructure: self;
						classStructure: classStructure.
					classStructure classMethods
						at: methodDefinition selector
						put: methodStructure ].
			self extensions add: classStructure ].
	name := aRwPackageDefinition key , self packageExtension.
	properties := Dictionary new
%

category: 'initialization'
method: RwCypressPackageStructure
fromSnapshot: snapshot
  | classMap classDefinitions |
  classDefinitions := OrderedCollection new.
  classMap := Dictionary new.
  snapshot
    do: [ :definition | 
      definition
        classDefinition: [ :classDefinition | classDefinitions add: classDefinition ]
        methodDefinition: [ :methodDefinition | 
          (classMap at: methodDefinition className ifAbsentPut: [ Set new ])
            add: methodDefinition ] ].
  self name: self name from: classDefinitions classMap: classMap
%

category: 'snapshotting'
method: RwCypressPackageStructure
rwSnapshot

	| rwPackageDefinition |
	rwPackageDefinition := RwPackageDefinition new
		properties:
			(Dictionary new
				at: 'name' put: self packageName;
				yourself).
	self classes
		do: [ :classStructure | 
			| rwClassDef |
			rwClassDef := RwClassDefinition fromCypressClassStructure: classStructure.
			rwPackageDefinition addClassDefinition: rwClassDef ].
	self extensions
		do: [ :classStructure | 
			| rwClassExtensionDef |
			rwClassExtensionDef := RwClassExtensionDefinition
				newForClassNamed: classStructure className.
			(classStructure instanceMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					rwClassExtensionDef
						addInstanceMethodDefinition:
							(RwMethodDefinition fromCypressMethod: methodStructure) ].
			(classStructure classMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					rwClassExtensionDef
						addClassMethodDefinition:
							(RwMethodDefinition fromCypressMethod: methodStructure) ].
			rwPackageDefinition addClassExtension: rwClassExtensionDef ].
	^ rwPackageDefinition
%

category: 'snapshotting'
method: RwCypressPackageStructure
snapshot

	| definitions |
	definitions := OrderedCollection new.
	self classes
		do: [ :classStructure | 
			definitions add: classStructure asCypressClassDefinition.
			(classStructure instanceMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | definitions add: methodStructure asCypressMethodDefinition ].
			(classStructure classMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | definitions add: methodStructure asCypressMethodDefinition ] ].
	self extensions
		do: [ :classStructure | 
			(classStructure instanceMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					| mdef |
					mdef := methodStructure asCypressMethodDefinition.
					mdef isExtensionMethod: true.
					definitions add: mdef ].
			(classStructure classMethods
				asSortedCollection: [ :a :b | a selector <= b selector ])
				do: [ :methodStructure | 
					| mdef |
					mdef := methodStructure asCypressMethodDefinition.
					mdef isExtensionMethod: true.
					definitions add: mdef ] ].
	^ CypressSnapshot definitions: definitions
%

! Class implementation for 'CypressPackageComparator'

!		Class methods for 'CypressPackageComparator'

category: 'instance creation'
classmethod: CypressPackageComparator
comparingPackageNamed: packageName fromDirectory: aDirectory

	^(self new)
		comparingPackageNamed: packageName fromDirectory: aDirectory;
		yourself
%

category: 'instance creation'
classmethod: CypressPackageComparator
new

	^super new
		initialize;
		yourself
%

!		Instance methods for 'CypressPackageComparator'

category: 'comparing - private'
method: CypressPackageComparator
add: aDefinition to: aDictionary

	aDefinition
		classDefinition: [:classDefinition | self addClassDefinition: classDefinition to: aDictionary]
		methodDefinition: [:methodDefinition | self addMethodDefinition: methodDefinition to: aDictionary]
%

category: 'comparing - private'
method: CypressPackageComparator
addClassDefinition: classDefinition to: aDictionary

	(aDictionary at: classDefinition className ifAbsentPut: [Dictionary new])
		at: 'class category' put: classDefinition category;
		at: 'class comment' put: classDefinition comment;
		at: 'class definition' put: classDefinition classDefinitionString.
%

category: 'comparing - private'
method: CypressPackageComparator
addMethodDefinition: methodDefinition to: aDictionary

	((aDictionary at: methodDefinition className ifAbsentPut: [Dictionary new])
		at: (methodDefinition classIsMeta
				ifTrue: ['class methods']
				ifFalse: ['instance methods'])
		ifAbsentPut: [Dictionary new]) at: methodDefinition selector
			put: methodDefinition category -> methodDefinition source
%

category: 'comparing - private'
method: CypressPackageComparator
applyAddition: aCypressAddition

	self add: aCypressAddition definition to: self currentAdditions
%

category: 'comparing - private'
method: CypressPackageComparator
applyModification: aCypressModification

	self
		add: aCypressModification modification to: self currentAdditions;
		add: aCypressModification obsoletion to: self currentRemovals.
%

category: 'comparing - private'
method: CypressPackageComparator
applyRemoval: aCypressRemoval

	self add: aCypressRemoval definition to: self currentRemovals.
%

category: 'comparing'
method: CypressPackageComparator
compare

	diskSnapshots keys do: [:packageName |
		self resetCurrentForPackage: packageName.
		self currentPatchOperations do: [:each | each applyTo: self].
	].
	self resetCurrentForPackage: nil.
%

category: 'initializing'
method: CypressPackageComparator
comparingPackages: someNames fromDirectory: aDirectory

	(directoryPackageMap at: aDirectory ifAbsentPut: [OrderedCollection new])
		addAll: someNames.
	someNames do: 
			[:packageName |
			| reader modTime modTimestamp |
			reader := (CypressFileSystemRepository on: aDirectory) reader
						readPackageStructureForPackageNamed: packageName.
			diskSnapshots at: packageName put: reader packageStructure snapshot.
			modTime := System
						performOnServer: 'stat --printf=%y ' , reader packageDirectory.
			modTimestamp := (modTime indexOfSubCollection: 'stat:' startingAt: 1 ifAbsent: [ 0 ]) = 1
						ifTrue: [nil]
						ifFalse: [self dateAndTimeFromUnixFormatString: modTime].
			diskTimestamps at: packageName put: modTimestamp.
			imageSnapshots at: packageName
				put: (CypressPackageDefinition named: packageName) snapshot]
%

category: 'comparing - private'
method: CypressPackageComparator
currentAdditions

	currentAdditions ifNil: [self updateCurrentAdditionsAndRemovals].
	^currentAdditions
%

category: 'comparing - private'
method: CypressPackageComparator
currentDiskSnapshot

	^diskSnapshots at: currentPackageName
%

category: 'comparing - private'
method: CypressPackageComparator
currentImageSnapshot

	^imageSnapshots at: currentPackageName
%

category: 'comparing - private'
method: CypressPackageComparator
currentPatchOperations

	^(CypressPatch fromBase: self currentDiskSnapshot toTarget: self currentImageSnapshot) operations.
%

category: 'comparing - private'
method: CypressPackageComparator
currentRemovals

	currentRemovals ifNil: [self updateCurrentAdditionsAndRemovals].
	^currentRemovals
%

category: 'initializing - private'
method: CypressPackageComparator
dateAndTimeFromUnixFormatString: aString
	"YYYY-MM-DDTHH:MM:SS +HHMM
	 Examples:
		| string |
		string := '2013-06-20 14:47:55.40271592140198 -0700'.
		(DateAndTimeANSI fromUnixFormatString: string) printString = '2013-06-20T14:47:55.40271592140198-07:00'.
	"

	| stream sign positionBias |
	stream := ReadStreamPortable on: aString.
	sign := aString at: aString size - 4.
	positionBias := stream class isLegacyStreamImplementation
				ifTrue: [1]
				ifFalse: [0].
	^DateAndTime
		year: (stream next: 4) asNumber
		month: (stream
				next;
				next: 2) asNumber
		day: (stream
				next;
				next: 2) asNumber
		hour: (stream
				next;
				next: 2) asNumber
		minute: (stream
				next;
				next: 2) asNumber
		second: (stream
				next;
				next: aString size - 6 - stream position + positionBias) asNumber
		offset: (Duration
				days: 0
				hours: (stream
						next;
						next;
						next: 2) asNumber
						* (sign == $- ifTrue: [-1] ifFalse: [1])
				minutes: (stream next: 2) asNumber
				seconds: 0)
%

category: 'comparing'
method: CypressPackageComparator
getDifferences

	self compare.
	^self snapshotDifferences
%

category: 'initializing - private'
method: CypressPackageComparator
initialize

	directoryPackageMap := Dictionary new.
	diskTimestamps := Dictionary new.
	diskSnapshots := Dictionary new.
	imageSnapshots := Dictionary new.
	snapshotDifferences := Dictionary new
		at: 'newer' put: (Dictionary with: 'Finished at' -> DateAndTime now);
		at: 'older' put: (Dictionary with: 'Finished at' -> DateAndTime now);
		yourself.
%

category: 'comparing - private'
method: CypressPackageComparator
resetCurrentForPackage: aStringOrNil

	currentPackageName := aStringOrNil.
	currentAdditions := nil.
	currentRemovals := nil.
%

category: 'accessing'
method: CypressPackageComparator
snapshotDifferences

	^snapshotDifferences
%

category: 'comparing - private'
method: CypressPackageComparator
updateCurrentAdditionsAndRemovals

	| oldTimestamp |
	currentAdditions := (snapshotDifferences at: 'newer')
				at: currentPackageName
				ifAbsentPut: [Dictionary new].
	oldTimestamp := (diskTimestamps at: currentPackageName) ifNil: [^self].
	currentRemovals := (snapshotDifferences at: 'older')
				at: currentPackageName
				ifAbsentPut: [Dictionary with: 'Timestamp' -> oldTimestamp printString].
%

! Class implementation for 'CypressPackageManager'

!		Class methods for 'CypressPackageManager'

category: 'instance creation'
classmethod: CypressPackageManager
new

	^super new
		initialize;
		yourself
%

category: 'accessing'
classmethod: CypressPackageManager
packageNamePermutationsFor: aString
	"Answer the variations on possible package names from the specified string.
	 Each hyphen may possibly separate the package name from a suffix."

	| names |
	names := OrderedCollection new.
	aString doWithIndex: 
			[:each :index |
			(each = $- and: [index > 1])
				ifTrue: [names add: (aString copyFrom: 1 to: index - 1)]].
	aString last ~= $- ifTrue: [names add: aString].
	^names
%

category: 'accessing'
classmethod: CypressPackageManager
potentialPackageNames
	"Answer a list of 'package names' from classes and methods.
	 The class category is the package name, if the class is in a package at all.
	 The method category begins with an asterisk (*) before the package name,
	 but can be continued with other details (e.g., *PackageName-accessing).
	 This version does NOT recognize method category suffixes."

	| classCategories methodCategories |
	classCategories := Set new.
	methodCategories := Set new.
	System myUserProfile symbolList do: 
			[:dict |
			dict do: 
					[:aClass |
					aClass isBehavior and: 
							[classCategories addAll: (self packageNamePermutationsFor: aClass category).
							aClass categorysDo: 
									[:cat :method |
									cat first = $*
										ifTrue: 
											[methodCategories
												addAll: (self packageNamePermutationsFor: (cat copyFrom: 2 to: cat size))]].
							false]]].
	^(Set new)
		addAll: classCategories;
		addAll: methodCategories;
		removeIfPresent: 'User Classes';
		removeIfPresent: 'Kernel';
		sortAscending
%

!		Instance methods for 'CypressPackageManager'

category: 'comparing'
method: CypressPackageManager
compareDefinitionsFromConflictedPackageInformation: aCypressPackageInformation

	| badDefinitions expectedDefinitions |
	badDefinitions := (CypressPackageStructure
				fromPackage: (CypressPackageDefinition
						named: aCypressPackageInformation name))
					snapshot definitions
				asSet.
	expectedDefinitions := OrderedCollection new.
	aCypressPackageInformation competingPackageNames do: 
			[:each |
			expectedDefinitions
				addAll: (CypressPackageStructure
						fromPackage: (CypressPackageDefinition named: each)) snapshot
						definitions].
	expectedDefinitions do: [:each | badDefinitions remove: each ifAbsent: []].
	^(badDefinitions collect: [:each | each printString]) sortAscending
%

category: 'comparing'
method: CypressPackageManager
comparePackageFrom: aCypressPackageInformation

	^self comparePackagesFrom: (Array with: aCypressPackageInformation)
%

category: 'updating - private'
method: CypressPackageManager
determineKnownPackages

	^(packageInformationList select: [:each | each repository notNil])
		inject: Dictionary new
		into: 
			[:dict :each |
			dict
				at: each name put: each savedLocation;
				yourself]
%

category: 'initializing - private'
method: CypressPackageManager
initialize

	self refreshPackageInformation.
%

category: 'initializing - private'
method: CypressPackageManager
initializeConflictingPackageNames

	| conflictingPackages |
	conflictingPackages := Dictionary new.
	packageInformationList do: 
			[:each |
			conflictingPackages at: each
				put: (knownPackages keys select: 
							[:knownName |
							knownName ~= each name
								and: [(knownName indexOfSubCollection: each name , '-' startingAt: 1 ifAbsent: [ 0 ]) = 1]])].
	conflictingPackages := conflictingPackages reject: [:each | each isEmpty].
	conflictingPackages
		keysAndValuesDo: [:package :conflicts | package beConflictedWith: conflicts]
%

category: 'initializing - private'
method: CypressPackageManager
initializeKnownPackages

	knownPackages := (System myUserProfile objectNamed: #KnownCypressPackages)
				ifNil: [Dictionary new]
%

category: 'initializing - private'
method: CypressPackageManager
initializeKnownRepositories

	knownRepositories := Dictionary new.
	knownPackages asSet
		do: [:each | self repositoryOn: each]
%

category: 'initializing - private'
method: CypressPackageManager
initializePackageInformationList

	| allInterestingNames |
	allInterestingNames := Set new
		addAll: self potentialPackageNames;
		addAll: knownPackages keys;
		sortAscending.
	packageInformationList := allInterestingNames collect: 
					[:each |
					| directory repo |
					directory := knownPackages at: each ifAbsent: [nil].
					repo := directory ifNotNil: [self repositoryOn: directory].
					CypressPackageInformation named: each repository: repo]
%

category: 'initializing - private'
method: CypressPackageManager
initializeQualifiedPackageNames

	| qualifiedPackages |
	qualifiedPackages := Dictionary new.
	packageInformationList do: 
			[:each |
			qualifiedPackages at: each
				put: (knownPackages keys select: 
							[:knownName |
							knownName ~= each name
								and: [(each name indexOfSubCollection: knownName , '-' startingAt: 1 ifAbsent: [ 0 ]) = 1]])].
	qualifiedPackages := qualifiedPackages reject: [:each | each isEmpty].
	qualifiedPackages
		keysAndValuesDo: [:package :baseNames | package beQualifiedNameOf: baseNames]
%

category: 'updating'
method: CypressPackageManager
loadPackageFrom: aCypressPackageInformation

	| summary loader |
	loader := (CypressSnapshot definitions: aCypressPackageInformation savedDefinitions)
				updatePackage: (CypressPackageDefinition named: aCypressPackageInformation name).
	summary := Dictionary new.

	loader unloadable notEmpty
		ifTrue: [summary at: 'Unloadable' put: (loader unloadable collect: [:each | each printString])].
	loader errors notEmpty
		ifTrue: [summary at: 'Errors' put: (loader errors collect: [:each | each printString])].
	loader requirements notEmpty
		ifTrue: [summary at: 'Missing Requirements' put: loader requirements asArray].

	^summary
%

category: 'updating'
method: CypressPackageManager
lookForLoadedPackagesIn: aDirectory
	"Update any of the packages in the image which have a Cypress file out in
	 the specified directory to reflect the path where the package has theoretically
	 been saved."

	self lookForLoadedPackagesInRepository: (self repositoryOn: aDirectory).
	^nil
%

category: 'updating'
method: CypressPackageManager
lookForLoadedPackagesInRepository: aCypressRepository
	"Update any of the packages in the image which have a Cypress file out in
	 the specified directory to reflect the path where the package has theoretically
	 been saved."

	| packageNames |
	packageNames := aCypressRepository packageNames.
	(self packageInformationList
		select: [:each | packageNames includes: each name])
			do: [:each | each updateKnownPackageRepository: aCypressRepository].
	self saveKnownPackages.
	^nil
%

category: 'updating'
method: CypressPackageManager
lookForUnloadedPackagesIn: aDirectory
	"Load any package names from aDirectory as known packages.
	 This does not load the package contents."

	self lookForUnloadedPackagesInRepository: (self repositoryOn: aDirectory).
	^nil
%

category: 'updating'
method: CypressPackageManager
lookForUnloadedPackagesInRepository: aCypressRepository
	"Add known packages for any Cypress file outs in the specified directory."

	| packageNames existingPackageNames |
	packageNames := aCypressRepository packageNames.
	(self packageInformationList
		select: [:each | packageNames includes: each name])
			do: [:each | each updateKnownPackageRepository: aCypressRepository].
	existingPackageNames := self packageInformationList
				collect: [:each | each name].
	(packageNames reject: [:each | existingPackageNames includes: each])
		do: 
			[:each |
			self packageInformationList
				add: (CypressPackageInformation named: each repository: aCypressRepository)].
	self saveKnownPackages.
	^nil
%

category: 'accessing'
method: CypressPackageManager
packageInformationList

	^packageInformationList
%

category: 'accessing'
method: CypressPackageManager
potentialPackageNames

	^self class potentialPackageNames
%

category: 'accessing'
method: CypressPackageManager
refreshedPackageInformationList

	self refreshPackageInformation.
	^self packageInformationList.
%

category: 'updating'
method: CypressPackageManager
refreshPackageInformation

	self
		initializeKnownPackages;
		initializeKnownRepositories;
		initializePackageInformationList;
		initializeConflictingPackageNames;
		initializeQualifiedPackageNames
%

category: 'initializing - private'
method: CypressPackageManager
repositoryOn: aDirectory

	^knownRepositories
		at: aDirectory
		ifAbsentPut: [CypressFileSystemRepository on: aDirectory].
%

category: 'updating - private'
method: CypressPackageManager
saveKnownPackages

	self updateKnownPackages.
	((System myUserProfile resolveSymbol: #KnownCypressPackages)
		ifNil: 
			[(System myUserProfile objectNamed: #UserGlobals)
				addAssociation: #KnownCypressPackages -> Dictionary new])
			value: knownPackages
%

category: 'updating - private'
method: CypressPackageManager
updateKnownPackages

	knownPackages := self determineKnownPackages
%

category: 'updating'
method: CypressPackageManager
updateSavedLocation: aDirectory for: aCypressPackageInformation
	"Update the specified package to reflect the path and repository where the
	 package should be saved."

	aCypressPackageInformation
		updateKnownPackageRepository: (self repositoryOn: aDirectory).
	self saveKnownPackages.
	^nil
%

category: 'writing - private'
method: CypressPackageManager
writeCypressPackageToDiskFrom: aCypressPackageInformation

	| packageStructure |
	packageStructure := CypressPackageStructure
				fromPackage: (CypressPackageDefinition
						named: aCypressPackageInformation name).
	aCypressPackageInformation repository writer
		writePackageStructure: packageStructure
%

category: 'writing'
method: CypressPackageManager
writePackagesToDiskFrom: someCypressPackageInformations

	| packageStructure |
	^someCypressPackageInformations do: 
			[:each |
			packageStructure := CypressPackageStructure
						fromPackage: (CypressPackageDefinition named: each name).
			each repository writer writePackageStructure: packageStructure.
			each refresh.
			self saveKnownPackages]
%

category: 'writing - private'
method: CypressPackageManager
writePackageStructure: packageStructure to: aCypressRepository

	aCypressRepository writer writePackageStructure: packageStructure
%

category: 'writing'
method: CypressPackageManager
writePackageToDiskFrom: aCypressPackageInformation

	^self writePackagesToDiskFrom: (Array with: aCypressPackageInformation)
%

! Class implementation for 'CypressPackageManager2'

!		Class methods for 'CypressPackageManager2'

category: 'Instance Creation'
classmethod: CypressPackageManager2
create

	^self new
		initializeFromImage;
		yourself.
%

category: 'Initializing'
classmethod: CypressPackageManager2
initialize

	self savedPackageManagers: IdentityDictionary new
%

category: 'Accessing'
classmethod: CypressPackageManager2
named: aKey
	"Answer the Package Manager previously saved under aKey.
	 It is an error if there was not one saved under that key."

	^self
		named: aKey
		or: [self error: 'No previously saved Package Manager under the key ', aKey printString]
%

category: 'Accessing'
classmethod: CypressPackageManager2
named: aKey or: aBlock
	"Answer the Package Manager previously saved under aKey.
	 Answer the result of evaluating aBlock, if there was not one saved under that key."

	^self savedPackageManagers at: aKey ifAbsent: aBlock
%

category: 'Instance Creation'
classmethod: CypressPackageManager2
new

	^super new
		initialize;
		yourself.
%

category: 'Accessing - private'
classmethod: CypressPackageManager2
packageNamePermutationsFor: aString
	"Answer the variations on possible package names from the specified string.
	 Each hyphen may possibly separate the package name from a suffix."

	| names |
	names := OrderedCollection new.
	aString doWithIndex: 
			[:each :index |
			(each = $- and: [index > 1])
				ifTrue: [names add: (aString copyFrom: 1 to: index - 1)]].
	aString last ~= $- ifTrue: [names add: aString].
	^names
%

category: 'Accessing - private'
classmethod: CypressPackageManager2
potentialPackageNames
	"Answer a list of 'package names' from classes and methods.
	 The class category is the package name, if the class is in a package at all.
	 The method category begins with an asterisk (*) before the package name,
	 but can be continued with other details (e.g., *PackageName-accessing).
	 This version does NOT recognize method category suffixes."

	| classCategories methodCategories |
	classCategories := Set new.
	methodCategories := Set new.
	System myUserProfile symbolList do: 
			[:dict |
			dict do: 
					[:aClass |
					aClass isBehavior and: 
							[classCategories addAll: (self packageNamePermutationsFor: aClass category).
							aClass categorysDo: 
									[:cat :method |
									cat first = $*
										ifTrue: 
											[methodCategories
												addAll: (self packageNamePermutationsFor: (cat copyFrom: 2 to: cat size))]].
							false]]].
	^(Set new)
		addAll: classCategories;
		addAll: methodCategories;
		removeIfPresent: 'User Classes';
		removeIfPresent: 'Kernel';
		sortAscending
%

category: 'Updating'
classmethod: CypressPackageManager2
removePackageManagerSavedAs: aKey
	"Remove the Package Manager previously saved under aKey, if there was one.
	 Answer it or nil if there was not one saved under that key."

	^self savedPackageManagers removeKey: aKey ifAbsent: []
%

category: 'Accessing'
classmethod: CypressPackageManager2
savedPackageManagers

	^SavedPackageManagers
%

category: 'Initializing - private'
classmethod: CypressPackageManager2
savedPackageManagers: anIdentityDictionary

	SavedPackageManagers := anIdentityDictionary
%

!		Instance methods for 'CypressPackageManager2'

category: 'Updating'
method: CypressPackageManager2
addRepository: aRepository to: aKnownPackageInformation

	aKnownPackageInformation addRepository: aRepository.
%

category: 'Updating'
method: CypressPackageManager2
addUnknownPackageNamed: aString

	self packageInformationList
		at: aString
		put: (CypressUnknownPackageInformation named: aString).
%

category: 'Querying'
method: CypressPackageManager2
allResolvedPackageReferences
  | resolved |
  resolved := OrderedCollection new.
  self knownRepositories
    keysAndValuesDo: [ :repoUrl :repo | 
      repo packageNames
        do: [ :packageName | resolved add: (CypressResolvedReference name: packageName repository: repo) ] ].
  ^ resolved asSortedCollection asArray
%

category: 'Updating'
method: CypressPackageManager2
assignRepository: aRepository to: aPackageInformation

	self assignRepository: aRepository toAll: (Array with: aPackageInformation)
%

category: 'Updating'
method: CypressPackageManager2
assignRepository: aRepository toAll: somePackageInformations
	"Assign to those having no repository information and add to those with.
	 Those without a repository need to be converted to Known Package Information instances."

	self knownRepositories at: aRepository url put: aRepository.
	(somePackageInformations reject: [:each | each isKnown])
		do: [:each | self addRepository: aRepository to: (self convertToKnown: each)].
	(somePackageInformations select: [:each | each isKnown])
		do: [:each | self addRepository: aRepository to: each].
%

category: 'Updating'
method: CypressPackageManager2
convert: anUnknownPackageInformation toConflictingWith: aKnownPackageInformation

	| conflicting |
	conflicting := CypressConflictingPackageInformation
				fromUnknown: anUnknownPackageInformation
				conflictingWith: aKnownPackageInformation.
	self replace: anUnknownPackageInformation with: conflicting.
	^conflicting
%

category: 'Updating'
method: CypressPackageManager2
convert: anUnknownPackageInformation toEclipsedBy: aKnownPackageInformation

	| eclipsed |
	eclipsed := CypressEclipsedPackageInformation
				fromUnknown: anUnknownPackageInformation
				eclipsedBy: aKnownPackageInformation.
	self replace: anUnknownPackageInformation with: eclipsed.
	^eclipsed
%

category: 'Updating'
method: CypressPackageManager2
convertToKnown: aPackageInformation

	| known |
	known := CypressKnownPackageInformation fromUnknown: aPackageInformation.
	self replace: aPackageInformation with: known.
	(self findPackagesEclipsedBy: known) do: [:each | self convert: each toEclipsedBy: known].
	(self findPackagesConflictingWith: known) do: [:each | self convert: each toConflictingWith: known].
	^known.
%

category: 'Updating'
method: CypressPackageManager2
createRepositoryNamed: aName under: aDirectory alias: aString schema: schemaName

	^CypressFileSystemRepository createOn: (CypressUrl
				absoluteFromText: schemaName
						, (CypressFileUtilities current directoryFromPath: aName
								relativeTo: aDirectory)
							, '/')
		alias: aString
%

category: 'Accessing - private'
method: CypressPackageManager2
findPackagesConflictingWith: aKnownPackageInformation

	^self packageInformationList select: 
			[:each |
			aKnownPackageInformation name ~= each name and: 
					[(aKnownPackageInformation name indexOfSubCollection: each name , '-' startingAt: 1 ifAbsent: [ 0 ]) = 1]]
%

category: 'Accessing - private'
method: CypressPackageManager2
findPackagesEclipsedBy: aKnownPackageInformation

	^self packageInformationList select: 
			[:each |
			aKnownPackageInformation name ~= each name and: 
					[(each name indexOfSubCollection: aKnownPackageInformation name , '-' startingAt: 1 ifAbsent: [ 0 ]) = 1]]
%

category: 'Initializing - private'
method: CypressPackageManager2
initialize

	self
		knownRepositories: Dictionary new;
		packageInformationList: Dictionary new
%

category: 'Initializing - private'
method: CypressPackageManager2
initializeFromImage

	self initializePackageInformationList.
%

category: 'Initializing - private'
method: CypressPackageManager2
initializePackageInformationList

	self
		packageInformationList: (self potentialPackageNames
				inject: Dictionary new
				into: 
					[:dict :each |
					dict
						at: each put: (CypressUnknownPackageInformation named: each);
						yourself])
%

category: 'Accessing'
method: CypressPackageManager2
knownRepositories

	^knownRepositories
%

category: 'Updating'
method: CypressPackageManager2
knownRepositories: someNamedRepositories

	knownRepositories := someNamedRepositories
%

category: 'Loading'
method: CypressPackageManager2
loadPackageFrom: aKnownPackageInformation defaultSymbolDictionaryName: defaultSymbolDictionaryNameOrNil inRepository: aRepository
  | snapshot summary loader |
  snapshot := (aRepository
    readPackageStructureForPackageNamed: aKnownPackageInformation name) snapshot.
  loader := snapshot
    updatePackage:
      (CypressPackageDefinition named: aKnownPackageInformation name)
    defaultSymbolDictionaryName: defaultSymbolDictionaryNameOrNil.
  summary := Dictionary new.
  loader unloadable notEmpty
    ifTrue: [ 
      summary
        at: 'Unloadable'
        put: (loader unloadable collect: [ :each | each printString ]) ].
  loader errors notEmpty
    ifTrue: [ summary at: 'Errors' put: (loader errors collect: [ :each | each printString ]) ].
  loader requirements notEmpty
    ifTrue: [ summary at: 'Missing Requirements' put: loader requirements asArray ].
  ^ summary
%

category: 'Loading'
method: CypressPackageManager2
loadPackageFrom: aKnownPackageInformation inRepository: aRepository
  ^ self
    loadPackageFrom: aKnownPackageInformation
    defaultSymbolDictionaryName: nil
    inRepository: aRepository
%

category: 'Updating'
method: CypressPackageManager2
lookForPackagesInRepository: aRepository
	"Find the packages in the repository and update the list
	 of package information accordingly."

	| packageNames inImage exImage |
	packageNames := aRepository packageNames.
	inImage := self packageInformationList asArray select: [:each | packageNames includes: each name].
	exImage := packageNames reject: [:each | self packageInformationList anySatisfy: [:info | info name = each]].
	exImage := exImage collect: [:each | CypressUnknownPackageInformation named: each].

	self assignRepository: aRepository toAll: inImage, exImage
%

category: 'Accessing'
method: CypressPackageManager2
packageInformationList

	^packageInformationList
%

category: 'Updating'
method: CypressPackageManager2
packageInformationList: someNamedPackageInformations

	packageInformationList := someNamedPackageInformations
%

category: 'Accessing'
method: CypressPackageManager2
packageInformationNamed: aString

	^self packageInformationNamed: aString
		or: [self error: 'No package information for ' , aString printString]
%

category: 'Accessing'
method: CypressPackageManager2
packageInformationNamed: aString or: aBlock

	^self packageInformationList
		at: aString
		ifAbsent: aBlock.
%

category: 'Accessing - private'
method: CypressPackageManager2
potentialPackageNames

	^self class potentialPackageNames
%

category: 'Updating'
method: CypressPackageManager2
replace: oldPackageInformation with: newPackageInformation

	self packageInformationList
		at: oldPackageInformation name
		put: newPackageInformation.
%

category: 'Initializing - private'
method: CypressPackageManager2
repositoryOn: url alias: aString
	"Answer a repository instance for the specified URL.
	 The characteristics will come from the properties file at the URL location,
	 or will default according to the schema, if there is no properties file."

	^self knownRepositories
		at: url
		ifAbsentPut: [CypressAbstractRepository onUrl: url alias: aString].
%

category: 'Updating'
method: CypressPackageManager2
saveAs: aKey
	"Save the receiver in the class' collection of named managers
	 under the specified key.
	 It will quietly replace anything already under that key."


	self savedPackageManagers at: aKey put: self.
%

category: 'Accessing - private'
method: CypressPackageManager2
savedPackageManagers

	^self class savedPackageManagers
%

category: 'Writing'
method: CypressPackageManager2
writeChangesToAllRepositoriesFor: aPackageInformation

	aPackageInformation writeChangesToAllRepositories.
%

! Class implementation for 'CypressPackageManager3'

!		Class methods for 'CypressPackageManager3'

category: 'testing'
classmethod: CypressPackageManager3
isPackageLoaded: aPackageName

  ^ (CypressPackageDefinition named: aPackageName) snapshot definitions isEmpty not
%

category: 'instance creation'
classmethod: CypressPackageManager3
new
  ^self basicNew initialize
%

!		Instance methods for 'CypressPackageManager3'

category: 'Updating'
method: CypressPackageManager3
addRepository: aRepository
  self knownRepositories at: aRepository url asString put: aRepository
%

category: 'Updating'
method: CypressPackageManager3
addResolvedReference: resolvedReference
  self resolvedPackageReferences add: resolvedReference
%

category: 'Querying'
method: CypressPackageManager3
allResolvedPackageReferences
  | resolved |
  resolved := OrderedCollection new.
  self knownRepositories
    keysAndValuesDo: [ :repoUrl :repo | 
      repo packageNames
        do: [ :packageName | resolved add: (CypressResolvedReference name: packageName repository: repo) ] ].
  ^ resolved asSortedCollection asArray
%

category: 'initialization'
method: CypressPackageManager3
defaultSymbolDictionaryName

  ^defaultSymbolDictionaryName
%

category: 'initialization'
method: CypressPackageManager3
defaultSymbolDictionaryName: aStringOrNil

  defaultSymbolDictionaryName := aStringOrNil
%

category: 'Updating'
method: CypressPackageManager3
initialize
  self
    knownRepositories: Dictionary new;
    resolvedPackageReferences: OrderedCollection new;
    yourself
%

category: 'Accessing'
method: CypressPackageManager3
knownRepositories

   ^knownRepositories
%

category: 'Accessing'
method: CypressPackageManager3
knownRepositories: anObject

   knownRepositories := anObject
%

category: 'loading'
method: CypressPackageManager3
loadResolvedReference: resolvedReference
  | cypressLoader package repository snapshot |
  cypressLoader := CypressLoader new.
  cypressLoader defaultSymbolDictionaryName: self defaultSymbolDictionaryName.
  package := resolvedReference packageDefinition.
  repository := resolvedReference repository.
  snapshot := (repository
    readPackageStructureForPackageNamed: resolvedReference name) snapshot.
  cypressLoader updatePackage: package withSnapshot: snapshot.
  cypressLoader load.
  cypressLoader unloadable notEmpty
    ifTrue: [ self error: 'Unloadable definitions' ].
  cypressLoader errors notEmpty
    ifTrue: [ self error: 'Load errors' ].
  cypressLoader requirements notEmpty
    ifTrue: [ self error: 'Missing Requirements' ]
%

category: 'loading'
method: CypressPackageManager3
loadResolvedReferences
  | cypressLoader |
  cypressLoader := CypressLoader new.
  cypressLoader defaultSymbolDictionaryName: self defaultSymbolDictionaryName.
  self resolvedPackageReferences
    do: [ :resolvedReference | | package repository snapshot |
      package := resolvedReference packageDefinition.
      repository := resolvedReference repository.
      snapshot := (repository
        readPackageStructureForPackageNamed: resolvedReference name) snapshot.
      cypressLoader updatePackage: package withSnapshot: snapshot ].
  cypressLoader load.
  cypressLoader unloadable notEmpty
    ifTrue: [ self error: 'Unloadable definitions' ].
  cypressLoader errors notEmpty
    ifTrue: [ self error: 'Load errors' ].
  cypressLoader requirements notEmpty
    ifTrue: [ self error: 'Missing Requirements' ]
%

category: 'Accessing'
method: CypressPackageManager3
resolvedPackageReferences
  ^ resolvedPackageReferences
%

category: 'Accessing'
method: CypressPackageManager3
resolvedPackageReferences: anObject
  resolvedPackageReferences := anObject
%

category: 'Unloading'
method: CypressPackageManager3
unloadPackage: aPackage

  | loader summary |
  loader := (CypressPackageDefinition named: aPackage name) snapshot
              unload.
  summary := Dictionary new.
  loader unloadable notEmpty
    ifTrue: [ 
      summary
        at: 'Unloadable'
        put: (loader unloadable collect: [ :each | each printString ]) ].
  loader errors notEmpty
    ifTrue: [ summary at: 'Errors' put: (loader errors collect: [ :each | each printString ]) ].
  loader requirements notEmpty
    ifTrue: [ summary at: 'Missing Requirements' put: loader requirements asArray ].
  ^ summary
%

category: 'Unloading'
method: CypressPackageManager3
unloadPackageNamed: aPackageName
  ^ self unloadPackage: (CypressPackageDefinition named: aPackageName)
%

! Class implementation for 'CypressEnvironmentPackageManager'

!		Instance methods for 'CypressEnvironmentPackageManager'

category: 'accessing'
method: CypressEnvironmentPackageManager
compilationSymbolList
  ^ compilationSymbolList
    ifNil: [ compilationSymbolList := self defaultSymbolList ]
%

category: 'accessing'
method: CypressEnvironmentPackageManager
compilationSymbolList: anObject

   compilationSymbolList := anObject
%

category: 'accessing'
method: CypressEnvironmentPackageManager
defaultEnvironmentId

   ^defaultEnvironmentId
%

category: 'accessing'
method: CypressEnvironmentPackageManager
defaultEnvironmentId: anObject

   defaultEnvironmentId := anObject
%

category: 'accessing'
method: CypressEnvironmentPackageManager
defaultSymbolList

   ^defaultSymbolList
%

category: 'accessing'
method: CypressEnvironmentPackageManager
defaultSymbolList: anObject

   defaultSymbolList := anObject
%

category: 'loading'
method: CypressEnvironmentPackageManager
loadResolvedReferences
  | cypressLoader |
  cypressLoader := CypressEnvironmentLoader new.
  cypressLoader
    defaultSymbolDictionaryName: self defaultSymbolDictionaryName;
    compilationSymbolList: self compilationSymbolList;
    lookupSymbolList: self lookupSymbolList;
    defaultEnvironmentId: self defaultEnvironmentId.
  self resolvedPackageReferences
    do: [ :resolvedReference | 
      | package repository snapshot |
      package := resolvedReference packageDefinition.
      repository := resolvedReference repository.
      snapshot := (repository
        readPackageStructureForPackageNamed: resolvedReference name) snapshot.
      cypressLoader updatePackage: package withSnapshot: snapshot ].
  cypressLoader load.
  cypressLoader unloadable notEmpty
    ifTrue: [ self error: 'Unloadable definitions' ].
  cypressLoader errors notEmpty
    ifTrue: [ self error: 'Load errors' ].
  cypressLoader requirements notEmpty
    ifTrue: [ self error: 'Missing Requirements' ]
%

category: 'loading'
method: CypressEnvironmentPackageManager
loadResolvedReferences: fileNames
  | cypressLoader doUnloads |
  cypressLoader := CypressEnvironmentLoader new.
  cypressLoader
    defaultSymbolDictionaryName: self defaultSymbolDictionaryName;
    compilationSymbolList: self compilationSymbolList;
    lookupSymbolList: self lookupSymbolList;
    defaultEnvironmentId: self defaultEnvironmentId.
  self resolvedPackageReferences
    do: [ :resolvedReference | 
      | package repository snapshot |
      package := resolvedReference packageDefinition.
      repository := resolvedReference repository.
      snapshot := (repository
        readPackageStructureForPackageNamed: resolvedReference name
        files: fileNames ) snapshot.
      cypressLoader updatePackage: package withSnapshot: snapshot ].
  doUnloads := false .
  cypressLoader load: doUnloads .
  doUnloads ifTrue:[ cypressLoader unloadable notEmpty
      ifTrue: [ self error: 'Unloadable definitions' ]].
  cypressLoader errors notEmpty
    ifTrue: [ self error: 'Load errors' ].
  doUnloads ifTrue:[ cypressLoader requirements notEmpty
      ifTrue: [ self error: 'Missing Requirements' ]].
%

category: 'accessing'
method: CypressEnvironmentPackageManager
lookupSymbolList
  ^ lookupSymbolList ifNil: [ lookupSymbolList := self defaultSymbolList ]
%

category: 'accessing'
method: CypressEnvironmentPackageManager
lookupSymbolList: anObject

   lookupSymbolList := anObject
%

! Class implementation for 'CypressPackageStringComparator'

!		Class methods for 'CypressPackageStringComparator'

category: 'instance creation'
classmethod: CypressPackageStringComparator
comparingPackageNamed: packageName fromDirectory: aDirectory

	^(self new)
		comparingPackageNamed: packageName fromDirectory: aDirectory;
		yourself
%

category: 'instance creation'
classmethod: CypressPackageStringComparator
forCypress

	^(self new)
		comparingPackages: #('Cypress-Definitions' 'Cypress-Mocks' 'Cypress-Structure' 'Cypress-Tests' 'Cypress-GemStoneFileServer' 'Cypress-Comparison')
			fromDirectory: '/opt/git/CypressReferenceImplementation/';
		yourself
%

category: 'instance creation'
classmethod: CypressPackageStringComparator
new

	^super new
		initialize;
		yourself
%

!		Instance methods for 'CypressPackageStringComparator'

category: 'comparing - private'
method: CypressPackageStringComparator
addAddition: aCypressModification to: aCollection
  aCypressModification definition
    classDefinition: [ :classDefinition | self addClassAddition: aCypressModification to: aCollection ]
    methodDefinition: [ :methodDefinition | self addMethodAddition: aCypressModification to: aCollection ]
%

category: 'comparing - private'
method: CypressPackageStringComparator
addClassAddition: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification definition details).
      #'addition'.
      #'class'.
      (aCypressModification definition classDefinitionString)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addClassModification: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification modification details).
      #'modification'.
      #'class'.
      (aCypressModification obsoletion classDefinitionString).
      (aCypressModification modification classDefinitionString)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addClassRemoval: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification definition details).
      #'removal'.
      #'class'.
      (aCypressModification definition classDefinitionString)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addMethodAddition: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification definition details).
      #'addition'.
      #'method'.
      (aCypressModification definition source)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addMethodModification: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification modification details).
      #'modification'.
      #'method'.
      (aCypressModification obsoletion source).
      (aCypressModification modification source)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addMethodRemoval: aCypressModification to: aCollection
  aCollection
    add:
      {(aCypressModification definition details).
      #'removal'.
      #'method'.
      (aCypressModification definition source)}
%

category: 'comparing - private'
method: CypressPackageStringComparator
addModification: aCypressModification to: aCollection
  aCypressModification modification
    classDefinition: [ :classDefinition | self addClassModification: aCypressModification to: aCollection ]
    methodDefinition: [ :methodDefinition | self addMethodModification: aCypressModification to: aCollection ]
%

category: 'comparing - private'
method: CypressPackageStringComparator
addRemoval: aCypressModification to: aCollection
  aCypressModification definition
    classDefinition: [ :classDefinition | self addClassRemoval: aCypressModification to: aCollection ]
    methodDefinition: [ :methodDefinition | self addMethodRemoval: aCypressModification to: aCollection ]
%

category: 'comparing - private'
method: CypressPackageStringComparator
applyAddition: aCypressAddition
  self addAddition: aCypressAddition to: self currentOperations
%

category: 'comparing - private'
method: CypressPackageStringComparator
applyModification: aCypressModification
  self addModification: aCypressModification to: self currentOperations
%

category: 'comparing - private'
method: CypressPackageStringComparator
applyRemoval: aCypressRemoval
  self addRemoval: aCypressRemoval to: self currentOperations
%

category: 'comparing'
method: CypressPackageStringComparator
compare

	diskSnapshots keys do: [:packageName |
		self resetCurrentForPackage: packageName.
		self currentPatchOperations do: [:each | each applyTo: self].
	].
	self resetCurrentForPackage: nil.
%

category: 'initializing'
method: CypressPackageStringComparator
comparingPackages: someNames fromDirectory: aDirectory
  (directoryPackageMap at: aDirectory ifAbsentPut: [ OrderedCollection new ])
    addAll: someNames.
  someNames
    do: [ :packageName | 
      | reader |
      reader := (CypressFileSystemRepository on: aDirectory) reader
        readPackageStructureForPackageNamed: packageName.
      diskSnapshots at: packageName put: reader packageStructure snapshot.
      imageSnapshots
        at: packageName
        put: (CypressPackageDefinition named: packageName) snapshot ]
%

category: 'comparing - private'
method: CypressPackageStringComparator
currentDiskSnapshot

	^diskSnapshots at: currentPackageName
%

category: 'comparing - private'
method: CypressPackageStringComparator
currentImageSnapshot

	^imageSnapshots at: currentPackageName
%

category: 'comparing - private'
method: CypressPackageStringComparator
currentOperations
  (self dynamicInstVarAt: #'currentOperations')
    ifNil: [ self updateCurrentOperations ].
  ^ self dynamicInstVarAt: #'currentOperations'
%

category: 'comparing - private'
method: CypressPackageStringComparator
currentOperations: aDictionary
  self dynamicInstVarAt: #'currentOperations' put: aDictionary
%

category: 'comparing - private'
method: CypressPackageStringComparator
currentPatchOperations

	^(CypressPatch fromBase: self currentDiskSnapshot toTarget: self currentImageSnapshot) operations.
%

category: 'comparing'
method: CypressPackageStringComparator
getDifferences

	self compare.
	^self snapshotDifferences
%

category: 'initializing - private'
method: CypressPackageStringComparator
initialize
  directoryPackageMap := Dictionary new.
  diskTimestamps := Dictionary new.
  diskSnapshots := Dictionary new.
  imageSnapshots := Dictionary new.
  snapshotDifferences := Dictionary new
    at: 'operations' put: Dictionary new;
    yourself
%

category: 'comparing - private'
method: CypressPackageStringComparator
resetCurrentForPackage: aStringOrNil
  currentPackageName := aStringOrNil.
  self currentOperations: nil
%

category: 'accessing'
method: CypressPackageStringComparator
snapshotDifferences

	^snapshotDifferences
%

category: 'comparing - private'
method: CypressPackageStringComparator
updateCurrentOperations
  self
    currentOperations:
      ((snapshotDifferences at: 'operations')
        at: currentPackageName
        ifAbsentPut: [ OrderedCollection new ])
%

! Class implementation for 'CypressReference'

!		Class methods for 'CypressReference'

category: 'instance creation'
classmethod: CypressReference
name: aString
  ^ self basicNew initializeName: aString
%

category: 'instance creation'
classmethod: CypressReference
new
  self error: 'Use #name: to initialize the receiver.'
%

!		Instance methods for 'CypressReference'

category: 'comparing'
method: CypressReference
= aReference
	^ self class = aReference class and: [ self name = aReference name ]
%

category: 'comparing'
method: CypressReference
hash
	^ self name hash
%

category: 'initialization'
method: CypressReference
initializeName: aString
	name := aString
%

category: 'private'
method: CypressReference
matches: aResolvedReference
  "Answer true if the receiver matches aResolvedReference."

  self subclassResponsibility: #'matches:'
%

category: 'accessing'
method: CypressReference
name
	"Answer the name of this reference."
	
	^ name
%

category: 'accessing'
method: CypressReference
packageName
  "Answer the package name."

  self subclassResponsibility: #'packageName'
%

category: 'printing'
method: CypressReference
printOn: aStream
  aStream
    nextPutAll: self class name;
    nextPutAll: ' name: ';
    print: self name
%

category: 'querying'
method: CypressReference
resolveAllWith: aPackageManager
  "Answer a sorted collection of all resolved references within aGofer."

  ^ aPackageManager allResolvedPackageReferences
    select: [ :each | self matches: each ]
%

! Class implementation for 'CypressPackageReference'

!		Instance methods for 'CypressPackageReference'

category: 'accessing'
method: CypressPackageReference
branch
	"Answer the branch of the receiver."
	
	^ branch
%

category: 'initialization'
method: CypressPackageReference
initializeName: aString
	super initializeName: aString.
	self parseName: aString
%

category: 'private'
method: CypressPackageReference
matches: aResolvedReference
  ^ self name = aResolvedReference name
%

category: 'accessing'
method: CypressPackageReference
packageDefinition
  "For in-image packages, only the base package name is used (no branch)"

  ^ CypressPackageDefinition named: self packageName
%

category: 'accessing'
method: CypressPackageReference
packageName
  "Answer the package of the receiver."

  ^ package
%

category: 'initialization'
method: CypressPackageReference
parseName: aString
  | basicName index |
  basicName := aString.
  index := basicName indexOfSubCollection: '.' startingAt: 1.
  index = 0
    ifTrue: [ 
      package := basicName.
      branch := '' ]
    ifFalse: [ 
      package := basicName copyFrom: 1 to: index - 1.
      branch := basicName copyFrom: index to: basicName size ]
%

! Class implementation for 'CypressResolvedReference'

!		Class methods for 'CypressResolvedReference'

category: 'instance creation'
classmethod: CypressResolvedReference
name: aString repository: aRepository
	^ self basicNew initializeName: aString repository: aRepository
%

!		Instance methods for 'CypressResolvedReference'

category: 'comparing'
method: CypressResolvedReference
<= aResolvedReference
  ^ self name <= aResolvedReference name
%

category: 'initialization'
method: CypressResolvedReference
initializeName: aString repository: aRepository
	self initializeName: aString.
	repository := aRepository
%

category: 'accessing'
method: CypressResolvedReference
repository
	"Answer the repository of the receiver."
	
	^ repository
%

! Class implementation for 'CypressUrl'

!		Class methods for 'CypressUrl'

category: 'instance creation'
classmethod: CypressUrl
absoluteFromFileNameOrUrlString: aString
	"Return a URL from and handle Strings without schemes
	as local relative FileUrls instead of defaulting to a HttpUrl
	as absoluteFromText: does."

	^(CypressUrl schemeNameForString: aString)
		ifNil: [CypressFileUrl workingDirectory newFromRelativeText: aString]
		ifNotNil: [CypressUrl absoluteFromText: aString]
%

category: 'instance creation'
classmethod: CypressUrl
absoluteFromText: aString
	"Return a URL from a string and handle
	a String without a scheme as a HttpUrl."

	"CypressUrl absoluteFromText: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'" 
	"CypressUrl absoluteFromText: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"
	"CypressUrl absoluteFromText: 'telnet:chaos.resnet.gatech.edu'"
	"CypressUrl absoluteFromText: 'file:/etc/passwd'"

	| remainder index scheme fragment newUrl |
	"trim surrounding whitespace"
	remainder := aString trimSeparators.

	"extract the fragment, if any"
	index := remainder indexOf: $#.
	index > 0 ifTrue: [
		fragment := remainder copyFrom: index + 1 to: remainder size.
		remainder := remainder copyFrom: 1 to: index - 1].

	"choose class based on the scheme name, and let that class do the bulk of the parsing"
	scheme := self schemeNameForString: remainder.
	newUrl := (self urlClassForScheme: scheme) new privateInitializeFromText: remainder.
	newUrl privateFragment: fragment.
	^newUrl
%

category: 'parsing'
classmethod: CypressUrl
combine: baseURL withRelative: relURL 
	"Take two URL as string form, combine them and return the corresponding URL in string form"

	^((self absoluteFromText: baseURL) newFromRelativeText: relURL) asString
%

category: 'instance creation'
classmethod: CypressUrl
for: aString
	"Return a URL from a string and handle
	a String without a scheme as a HttpUrl."

	^self absoluteFromText: aString
%

category: 'encoding'
classmethod: CypressUrl
isCharacterSafeForHttp: aChar
	"Answer whether a character is 'safe', or needs to be escaped when used, eg, in a URL."

	^aChar codePoint < 128
		and: [aChar isAlphaNumeric or: ['.-_' includes: aChar]]
%

category: 'constants'
classmethod: CypressUrl
schemeName
	"When searching for a class to handle a particular scheme, make sure that Url classes never match by default. This is so that abstract Url classes e.g. HierarchicalUrl can be iterated over, but will not be selected"

	^ nil.
%

category: 'parsing'
classmethod: CypressUrl
schemeNameForString: aString
	"Get the scheme name from a string, or return nil if it's not specified. 
	Used in internal parsing routines - an outsider may as well use asUrl. 
	Return scheme in lowercases."
	
	"Url schemeNameForString: 'http://www.yahoo.com'"
	"Url schemeNameForString: '/etc/passwed'"
	"Url schemeNameForString: '/etc/testing:1.2.3'"

	| index schemeName |
	index := aString indexOf: $: ifAbsent: [^ nil].
	schemeName := aString copyFrom: 1 to: index - 1.
	(schemeName allSatisfy: [:each | each isLetter]) ifFalse: [^ nil].
	^ schemeName asLowercase
%

category: 'parsing'
classmethod: CypressUrl
urlClassForScheme: scheme

	| allSubclasses |
	allSubclasses := self userId = System myUserProfile userId
		ifTrue: [ ClassOrganizer new allSubclassesOf: self ]
		ifFalse: [ (ClassOrganizer newWithRoot: self forUserId: self userId) allSubclassesOf: self ].
	^allSubclasses detect: [:urlClass | urlClass schemeName = scheme]
		ifNone: [CypressGenericUrl]
%

category: 'encoding'
classmethod: CypressUrl
writeWithHttpEscapes: aCollection on: aStream
	"Write the given string or Utf8 on the stream with 'dangerous' characters 
	escaped to their %XX form, for use in HTTP transactions.
	Note that Utf8s containing code points over 128 will not work properly here."

	aCollection do: 
			[:each |
			| char |
			char := each asCharacter.
			(self isCharacterSafeForHttp: char)
				ifTrue: [aStream nextPut: char]
				ifFalse: 
					[| int |
					aStream nextPut: $%.
					int := each asInteger.
					int // 16 printOn: aStream base: 16 showRadix: false.
					int \\ 16 printOn: aStream base: 16 showRadix: false]]
%

!		Instance methods for 'CypressUrl'

category: 'downloading'
method: CypressUrl
activate
	"spawn an external handler for this URL"
	
%

category: 'converting'
method: CypressUrl
asString

	^self printString
%

category: 'converting'
method: CypressUrl
asURI
	^self asString asURI
%

category: 'converting'
method: CypressUrl
asUrl
	^self
%

category: 'converting'
method: CypressUrl
asUrlRelativeTo: aUrl
	^self
%

category: 'accessing'
method: CypressUrl
authority
	^''
%

category: 'encoding'
method: CypressUrl
decodeHttpEscapesOf: aString
	"decode string including %XX form
	 (adapted from Pharo 2.0)"

	| unescaped pos sourceSize |
	unescaped := ReadWriteStreamPortable on: String new.
	pos := 1.
	sourceSize := aString size.
	[pos > sourceSize] whileFalse: 
			[| char |
			char := aString at: pos.
			(char = $% and: [pos + 2 <= sourceSize])
				ifTrue: 
					[| asciiVal |
					asciiVal := ((aString at: pos + 1) asUppercase digitValueInRadix: 16) * 16
								+ ((aString at: pos + 2) asUppercase digitValueInRadix: 16).
					asciiVal > 255 ifTrue: [^aString].
					unescaped nextPut: (Character withValue: asciiVal).
					pos := pos + 3]
				ifFalse: 
					[char = $+
						ifTrue: [unescaped nextPut: Character space]
						ifFalse: [unescaped nextPut: char].
					pos := pos + 1]].
	^unescaped contents
%

category: 'converting'
method: CypressUrl
downloadUrl
	^self asString
%

category: 'fragment'
method: CypressUrl
fragment
	^fragment
%

category: 'downloading'
method: CypressUrl
hasContents
	"whether this URL can download contents to be displayed; if not, it fundamentally requires an outside application to deal with it.  For example, mailto: and telnet: urls"
	^false
%

category: 'parsing'
method: CypressUrl
newFromRelativeText: aString
	"return a URL relative to the current one, given by aString.  For instance, if self is 'http://host/dir/file', and aString is '/dir2/file2', then the return will be a Url for 'http://host/dir2/file2'"

	"if the scheme is the same, or not specified, then use the same class"

	| newSchemeName remainder fragmentStart newFragment newUrl bare |

	bare := aString trimSeparators.
	newSchemeName := CypressUrl schemeNameForString: bare.
	(newSchemeName notNil and: [ newSchemeName ~= self schemeName ]) ifTrue: [
		"different scheme -- start from scratch"
		^CypressUrl absoluteFromText: aString ].

	remainder := bare.

	"remove the fragment, if any"
	fragmentStart := remainder indexOf: $#.
	fragmentStart > 0 ifTrue: [
		newFragment := remainder copyFrom: fragmentStart+1 to: remainder size. 
		remainder := remainder copyFrom: 1 to: fragmentStart-1].

	"remove the scheme name"
	newSchemeName ifNotNil: [
		remainder := remainder copyFrom: (newSchemeName size + 2) to: remainder size ].

	"create and initialize the new url"
	newUrl := self class new privateInitializeFromText: remainder  relativeTo: self.


	"set the fragment"
	newUrl privateFragment: newFragment.


	^newUrl
%

category: 'printing'
method: CypressUrl
printOn: aStream

	^self subclassResponsibility: #printOn:
%

category: 'fragment'
method: CypressUrl
privateFragment: aString
	fragment := aString
%

category: 'parsing'
method: CypressUrl
privateInitializeFromText: aString

	^self subclassResponsibility: #privateInitializeFromText:
%

category: 'parsing'
method: CypressUrl
privateInitializeFromText: aString relativeTo: aUrl
	"initialize from the given string, as a relative URL.  aString will have had the scheme name removed, if it was present to begin with.  If it was, then the scheme name was the same as the receiver's scheme name"

	"by default, just do regular initialization"
	^self privateInitializeFromText: aString
%

category: 'classification'
method: CypressUrl
scheme
	"return a string with the scheme of this URL.  For instance, HTTP"

	^self subclassResponsibility: #scheme
%

category: 'classification'
method: CypressUrl
schemeName
	"return a lowercase string with the scheme of this URL.  For instance, 'http'"

	^self subclassResponsibility: #schemeName
%

category: 'fragment'
method: CypressUrl
withFragment: newFragment
	"return a URL which is the same except that it has a different fragment"
	^self copy privateFragment: newFragment; yourself
%

category: 'fragment'
method: CypressUrl
withoutFragment
	"return a URL which is identical to the receiver except that it has no fragment associated with it"
	^self withFragment: nil
%

category: 'encoding'
method: CypressUrl
writeWithHttpEscapes: aCollection on: aStream

	self class writeWithHttpEscapes: aCollection on: aStream
%

! Class implementation for 'CypressFileUrl'

!		Class methods for 'CypressFileUrl'

category: 'instance creation'
classmethod: CypressFileUrl
absoluteFromText: aString
	"Method that can be called explicitly to create a FileUrl."

	^self new privateInitializeFromText: aString
%

category: 'instance creation'
classmethod: CypressFileUrl
host: aHost pathParts: aCollectionOfPathParts isAbsolute: aBoolean
	"Create a FileUrl."

	^self new host: aHost pathParts: aCollectionOfPathParts isAbsolute: aBoolean
%

category: 'instance creation'
classmethod: CypressFileUrl
pathParts: aCollectionOfPathParts
	"Create a FileUrl."

	^self host: nil pathParts: aCollectionOfPathParts isAbsolute: true
%

category: 'instance creation'
classmethod: CypressFileUrl
pathParts: aCollectionOfPathParts isAbsolute: aBoolean
	"Create a FileUrl."

	^self host: nil pathParts: aCollectionOfPathParts isAbsolute: aBoolean
%

category: 'constants'
classmethod: CypressFileUrl
schemeName
	^'file'
%

category: 'instance creation'
classmethod: CypressFileUrl
workingDirectory

	^self absoluteFromText: CypressFileUtilities current workingDirectory
%

!		Instance methods for 'CypressFileUrl'

category: 'downloading'
method: CypressFileUrl
default
	"Answer a new URL with the receiver's path relative to the current working directory."
	
	self privateInitializeFromText: self pathString relativeTo: self class workingDirectory.
%

category: 'accessing'
method: CypressFileUrl
fileName
	"Return the last part of the path,
	most often a filename but can also be a directory."

	^self path last
%

category: 'testing'
method: CypressFileUrl
firstPartIsDriveLetter
	"Return true if the first part of the path is a letter
	followed by a $: like 'C:' "
	
	| firstPart |
	path isEmpty ifTrue: [^false].
	firstPart := path first.
	^firstPart size = 2 and: [
		firstPart first isLetter
			and: [firstPart last = $:]]
%

category: 'downloading'
method: CypressFileUrl
hasContents
	^true
%

category: 'accessing'
method: CypressFileUrl
host
	"Return the host name, either 'localhost', '', or a fully qualified domain name."
	
	^host ifNil: ['']
%

category: 'accessing'
method: CypressFileUrl
host: hostName
	"Set the host name, either 'localhost', '', or a fully qualified domain name."
	
	host := hostName
%

category: 'private-initialization'
method: CypressFileUrl
host: aHostString pathParts: aCollection isAbsolute: aBoolean

	host := aHostString.
	path := aCollection.
	isAbsolute := aBoolean
%

category: 'private-initialization'
method: CypressFileUrl
initializeFromPathString: aPathString
	"<aPathString> is a file path as a String.
	We construct a path collection using various heuristics."

	| pathString hasDriveLetter |
	pathString := aPathString.
	pathString isEmpty ifTrue: [pathString := '/'].
	"Copy without empty string preceeding first / or between duplicated /s."
	path := ((pathString subStrings: '/') copyWithout: '')
				collect: [:token | self decodeHttpEscapesOf: token].

	"A path like 'C:' refers in practice to 'c:/'"
	(pathString last = $/
		or: [(hasDriveLetter := self firstPartIsDriveLetter) and: [path size = 1]])
			ifTrue: [path add: ''].

	"Decide if we are absolute by checking for leading $/ or
	beginning with drive letter. Smarts for other OSes?"
	self isAbsolute: ((pathString at: 1) = $/
				or: [hasDriveLetter ifNil: [self firstPartIsDriveLetter]])
%

category: 'accessing'
method: CypressFileUrl
isAbsolute
	"Should the path be considered absolute to
	the filesystem instead of relative to the default directory?"
 
	^isAbsolute
%

category: 'accessing'
method: CypressFileUrl
isAbsolute: aBoolean
	"Set if the path should be considered absolute to
	the filesystem instead of relative to the default directory."

	isAbsolute := aBoolean
%

category: 'accessing'
method: CypressFileUrl
path
	"Return an ordered collection of the path elements."
	
	^path
%

category: 'accessing'
method: CypressFileUrl
path: aCollection
	"Set the collection of path elements."

	path := aCollection
%

category: 'paths'
method: CypressFileUrl
pathDirString
	"Path to directory as url, using slash as delimiter.
	Filename is left out."

	| s |
	s := WriteStreamPortable on: (String new: 100).
	isAbsolute ifTrue: [s nextPut: $/].
	1 to: self path size - 1
		do: 
			[:ii |
			s
				nextPutAll: (path at: ii);
				nextPut: $/].
	^s contents
%

category: 'paths'
method: CypressFileUrl
pathForDirectory
	"Path using local file system's pathname delimiter.
	DOS paths with drive letters should not
	be prepended with a delimiter even though
	they are absolute. Filename is left out."

	| delimiter s |
	delimiter := CypressFileUtilities current pathNameDelimiter.
	s := WriteStreamPortable on: (String new: 100).
	(self isAbsolute and: [self firstPartIsDriveLetter not])
		ifTrue: [s nextPutAll: delimiter].
	1 to: self path size - 1
		do: 
			[:ii |
			s
				nextPutAll: (path at: ii);
				nextPutAll: delimiter].
	^s contents
%

category: 'paths'
method: CypressFileUrl
pathForFile
  ^ self pathString
%

category: 'private-initialization'
method: CypressFileUrl
pathParts: aCollection isAbsolute: aBoolean

	^self host: nil pathParts: aCollection isAbsolute: aBoolean
%

category: 'paths'
method: CypressFileUrl
pathString
	"Path as it appears in a URL with $/ as delimiter."

	| s first |
	s := WriteStreamPortable on: (String new: 100).

	"isAbsolute ifTrue:[ s nextPut: $/ ]."
	first := true.
	self path do: 
			[:p |
			first ifFalse: [s nextPut: $/].
			first := false.
			self writeWithHttpEscapes: p on: s].
	^s contents
%

category: 'copying'
method: CypressFileUrl
postCopy
	"Be sure not to share the path with the copy."

	super postCopy.
	path := path copy
%

category: 'printing'
method: CypressFileUrl
printOn: aStream
	"Return the FileUrl according to RFC3986
		'file:'['//'<host>]<path>#<fragment>
	Note that <host> being '' is equivalent to 'localhost' and is not printed."

	aStream
		nextPutAll: self schemeName;
		nextPut: $:.

	"File URLs with hosts (which are fairly useless) cannot be relative."
	host isEmpty
		ifFalse: 
			[isAbsolute
				ifFalse: 
					[aStream nextPutAll: '<ErroneousURL>'.
					^nil].
			aStream
				nextPutAll: '//';
				nextPutAll: host].
	isAbsolute ifTrue: [aStream nextPut: $/].
	aStream nextPutAll: self pathString.
	fragment
		ifNotNil: 
			[aStream nextPut: $#.
			self writeWithHttpEscapes: fragment on: aStream]
%

category: 'private-initialization'
method: CypressFileUrl
privateInitializeFromText: aString
	"Calculate host and path from a file URL in String format.
	Some malformed formats are allowed and interpreted by guessing."

	| schemeName pathString bare i |
	bare := aString trimSeparators.
	schemeName := CypressUrl schemeNameForString: bare.
	(schemeName isNil or: [schemeName ~= self schemeName])
		ifTrue: 
			[host := ''.
			pathString := bare]
		ifFalse: 
			["First remove schemeName and colon"
			bare := bare copyFrom: schemeName size + 2 to: bare size.
			"A proper file URL then has two slashes before host,
			A malformed URL is interpreted as using syntax file:<path>."
			(bare indexOfSubCollection: '//' startingAt: 1 ifAbsent: [ 0 ]) = 1
				ifTrue: 
					[i := bare indexOf: $/ startingAt: 3.
					i = 0
						ifTrue: 
							[host := bare copyFrom: 3 to: bare size.
							pathString := '']
						ifFalse: 
							[host := bare copyFrom: 3 to: i - 1.
							pathString := bare copyFrom: host size + 3 to: bare size]]
				ifFalse: 
					[host := ''.
					pathString := bare]].
	self initializeFromPathString: pathString
%

category: 'private-initialization'
method: CypressFileUrl
privateInitializeFromText: pathString relativeTo: aUrl
	"<pathString> should be a filesystem path.
	This url is adjusted to be aUrl + the path."

	| newPath |
	self host: aUrl host.
	self initializeFromPathString: pathString.
	self isAbsolute: aUrl isAbsolute.
	newPath := aUrl path copy.
	newPath removeLast.	"empty string that says its a directory"
	path do: 
			[:token |
			(token ~= '..' and: [token ~= '.'])
				ifTrue: [newPath addLast: (self decodeHttpEscapesOf: token)].
			token = '..'
				ifTrue: 
					[newPath isEmpty
						ifFalse: [newPath last = '..' ifFalse: [newPath removeLast]]]
			"token = '.' do nothing"].
	path := newPath
%

category: 'classification'
method: CypressFileUrl
scheme
	^self class schemeName
%

category: 'classification'
method: CypressFileUrl
schemeName
	^self class schemeName
%

! Class implementation for 'CypressAbstractFileUrl'

!		Class methods for 'CypressAbstractFileUrl'

category: 'instance creation'
classmethod: CypressAbstractFileUrl
absoluteFromText: aString
	"Return a URL from a string and handle
	a String without a scheme as a FileUrl."

	"Url absoluteFromText: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'" 
	"Url absoluteFromText: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"
	"Url absoluteFromText: 'telnet:chaos.resnet.gatech.edu'"
	"Url absoluteFromText: 'file:/etc/passwd'"

	| remainder index scheme fragment newUrl |
	"trim surrounding whitespace"
	remainder := aString trimSeparators.

	"extract the fragment, if any"
	index := remainder indexOf: $#.
	index > 0 ifTrue: [
		fragment := remainder copyFrom: index + 1 to: remainder size.
		remainder := remainder copyFrom: 1 to: index - 1].

	"choose class based on the scheme name, and let that class do the bulk of the parsing"
	scheme := self schemeNameForString: remainder.
	newUrl := (self urlClassForScheme: scheme) new privateInitializeFromText: remainder.
	newUrl privateFragment: fragment.
	^newUrl
%

category: 'parsing'
classmethod: CypressAbstractFileUrl
urlClassForScheme: scheme

	scheme isNil ifTrue: [^CypressFileUrl].
	^super urlClassForScheme: scheme
%

!		Instance methods for 'CypressAbstractFileUrl'

category: 'accessing'
method: CypressAbstractFileUrl
codeFormat

	^self subclassResponsibility: #codeFormat.
%

category: 'private'
method: CypressAbstractFileUrl
fileUtils
  ^ CypressFileUtilities current
%

category: 'testing'
method: CypressAbstractFileUrl
isStrict

	^self subclassResponsibility: #isStrict.
%

category: 'accessing'
method: CypressAbstractFileUrl
repositoryClass

	^CypressFileSystemRepository
%

! Class implementation for 'CypressCypressFileUrl'

!		Class methods for 'CypressCypressFileUrl'

category: 'constants'
classmethod: CypressCypressFileUrl
schemeName

	^'cypress'
%

!		Instance methods for 'CypressCypressFileUrl'

category: 'accessing'
method: CypressCypressFileUrl
codeFormat

	^'Cypress'
%

category: 'testing'
method: CypressCypressFileUrl
isStrict

	^true
%

! Class implementation for 'CypressFileTreeFormatFileUrl'

!		Class methods for 'CypressFileTreeFormatFileUrl'

category: 'constants'
classmethod: CypressFileTreeFormatFileUrl
schemeName

	^'cypressft'
%

!		Instance methods for 'CypressFileTreeFormatFileUrl'

category: 'accessing'
method: CypressFileTreeFormatFileUrl
codeFormat

	^'FileTree'
%

category: 'testing'
method: CypressFileTreeFormatFileUrl
isStrict

	^false
%

! Class implementation for 'CypressFileTreeReadOnlyFileUrl'

!		Class methods for 'CypressFileTreeReadOnlyFileUrl'

category: 'constants'
classmethod: CypressFileTreeReadOnlyFileUrl
schemeName

	^'cypressfiletree'
%

!		Instance methods for 'CypressFileTreeReadOnlyFileUrl'

category: 'accessing'
method: CypressFileTreeReadOnlyFileUrl
codeFormat

	^'FileTree'
%

category: 'testing'
method: CypressFileTreeReadOnlyFileUrl
isStrict

	^true
%

! Class implementation for 'CypressGitFileUrl'

!		Class methods for 'CypressGitFileUrl'

category: 'constants'
classmethod: CypressGitFileUrl
schemeName
  "A gitcypress url with a host is the target for a remote. All other parameters are optional.
	Parameters are:
		dir : the directory inside the repository where the target MC packages are.
		branch : the git branch to fetch.
		protocol: the user name part to add to the ssh Url, default to git, but can also be https (which implies read only access).
		readOnly : is the repository read only? If present, reduce the history to a minimum (and change the GUI).
	Alternative url syntax:
		gitcypress://github.com/dalehenrich/filetree:pharo5.0_dev/repository
	with:
		host : github.com
		project : dalehenrich/filetree
		branch : pharo5.0_dev
		dir : repository
"

  ^ 'gitcypress'
%

!		Instance methods for 'CypressGitFileUrl'

category: 'accessing'
method: CypressGitFileUrl
codeFormat

	^'Cypress'
%

category: 'printing'
method: CypressGitFileUrl
httpsAccessString
  ^ 'https://' , self host , self projectPath , '.git'
%

category: 'private-initialization'
method: CypressGitFileUrl
initializeFromPathString: aPathString
  | projectDelim repoDelimIndex branchOrTagDelimIndex |
  projectBranchOrTag := repositoryPath := nil.
  projectDelim := aPathString indexOf: $/ startingAt: 2.
  repoDelimIndex := aPathString indexOf: $/ startingAt: projectDelim + 1.
  (branchOrTagDelimIndex := aPathString indexOf: $:) == 0
    ifTrue: [ repoDelimIndex == 0
        ifTrue: [ self projectPath: aPathString ]
        ifFalse: [ self projectPath: (aPathString copyFrom: 1 to: repoDelimIndex - 1).
          self
            repositoryPath:
              (aPathString copyFrom: repoDelimIndex + 1 to: aPathString size) ] ]
    ifFalse: [ self projectPath: (aPathString copyFrom: 1 to: branchOrTagDelimIndex - 1).
      repoDelimIndex == 0
        ifTrue: [ projectBranchOrTag := aPathString
            copyFrom: branchOrTagDelimIndex + 1
            to: aPathString size ]
        ifFalse: [ self projectPath: (aPathString copyFrom: 1 to: branchOrTagDelimIndex - 1).
          self parseBranchOrTagField: [ :pv :rp | projectBranchOrTag := pv.
              self repositoryPath: rp ] pathString: aPathString
          branchOrTagDelimIndex: branchOrTagDelimIndex ] ]
%

category: 'testing'
method: CypressGitFileUrl
isStrict

	^true
%

category: 'private-initialization'
method: CypressGitFileUrl
parseBranchOrTagField: parseBlock pathString: aPathString branchOrTagDelimIndex: branchOrTagDelimIndex
  | strm done escaped repoDelimIndex |
  strm := WriteStream on: String new.
  repoDelimIndex := branchOrTagDelimIndex + 1.
  escaped := done := false.
  [ done ] whileFalse: [ | char |
      repoDelimIndex > aPathString size
        ifTrue: [ done := true ]
        ifFalse: [ char := aPathString at: repoDelimIndex.
          char == $\
            ifTrue: [ escaped
                ifTrue: [ "$\ not legal in branch name ... literally ignored"
                  escaped := false ]
                ifFalse: [ escaped := true ] ]
            ifFalse: [ char == $/
                ifTrue: [ escaped
                    ifFalse: [ done := true ] ].
              done
                ifFalse: [ strm nextPut: char ].
              escaped := false ].
          repoDelimIndex := repoDelimIndex + 1 ] ].
  repoDelimIndex := repoDelimIndex - 1.
  parseBlock
    value: strm contents
    value: (aPathString copyFrom: repoDelimIndex + 1 to: aPathString size)
%

category: 'printing'
method: CypressGitFileUrl
printOn: aStream

	aStream nextPutAll: self schemeName , '://' , self host.
	aStream
		nextPutAll: self projectPath;
		nextPut: $:.
	self projectBranchOrTag do: 
			[:char |
			char = $/ ifTrue: [aStream nextPut: $\].
			aStream nextPut: char].
	aStream
		nextPut: $/;
		nextPutAll: self repositoryPath
%

category: 'accessing'
method: CypressGitFileUrl
projectBranchOrTag
  ^ projectBranchOrTag ifNil: [ 'master' ]
%

category: 'accessing'
method: CypressGitFileUrl
projectBranchOrTag: anObject

   projectBranchOrTag := anObject
%

category: 'accessing'
method: CypressGitFileUrl
projectPath

   ^projectPath
%

category: 'accessing'
method: CypressGitFileUrl
projectPath: aString
  aString last = self fileUtils pathNameDelimiter last
    ifTrue: [ projectPath := aString copyFrom: 1 to: aString size - 1 ]
    ifFalse: [ projectPath := aString ]
%

category: 'accessing'
method: CypressGitFileUrl
repositoryClass
  ^ CypressFileSystemGitRepository
%

category: 'accessing'
method: CypressGitFileUrl
repositoryPath
  ^ repositoryPath ifNil: [ '' ]
%

category: 'accessing'
method: CypressGitFileUrl
repositoryPath: aString
  (aString size > 0
    and: [ aString last = self fileUtils pathNameDelimiter last ])
    ifTrue: [ repositoryPath := aString copyFrom: 1 to: aString size - 1 ]
    ifFalse: [ repositoryPath := aString ]
%

! Class implementation for 'CypressGitFileTreeUrl'

!		Class methods for 'CypressGitFileTreeUrl'

category: 'constants'
classmethod: CypressGitFileTreeUrl
schemeName
  "A gitfiletree url with a host is the target for a remote. All other parameters are optional.
	Parameters are:
		dir : the directory inside the repository where the target MC packages are.
		branch : the git branch to fetch.
		protocol: the user name part to add to the ssh Url, default to git, but can also be https (which implies read only access).
		readOnly : is the repository read only? If present, reduce the history to a minimum (and change the GUI).
	Alternative url syntax:
		gitfiletree://github.com/dalehenrich/filetree:pharo5.0_dev/repository
	with:
		host : github.com
		project : dalehenrich/filetree
		branch : pharo5.0_dev
		dir : repository
"

  ^ 'gitfiletree'
%

!		Instance methods for 'CypressGitFileTreeUrl'

category: 'accessing'
method: CypressGitFileTreeUrl
codeFormat

	^'FileTree'
%

category: 'testing'
method: CypressGitFileTreeUrl
isStrict

	^false
%

! Class implementation for 'CypressLaxFileUrl'

!		Class methods for 'CypressLaxFileUrl'

category: 'constants'
classmethod: CypressLaxFileUrl
schemeName

	^'cypresslax'
%

!		Instance methods for 'CypressLaxFileUrl'

category: 'accessing'
method: CypressLaxFileUrl
codeFormat

	^'Cypress'
%

category: 'testing'
method: CypressLaxFileUrl
isStrict

	^false
%

! Class implementation for 'CypressSmalltalkUrl'

!		Class methods for 'CypressSmalltalkUrl'

category: 'constants'
classmethod: CypressSmalltalkUrl
schemeName

	^'chunk'
%

!		Instance methods for 'CypressSmalltalkUrl'

category: 'accessing'
method: CypressSmalltalkUrl
codeFormat

	^'Chunk'
%

category: 'testing'
method: CypressSmalltalkUrl
isStrict

	^true
%

category: 'accessing'
method: CypressSmalltalkUrl
repositoryClass

	^CypressSmalltalkRepository
%

! Class implementation for 'CypressTonelFileUrl'

!		Class methods for 'CypressTonelFileUrl'

category: 'constants'
classmethod: CypressTonelFileUrl
schemeName
  ^ 'tonel'
%

!		Instance methods for 'CypressTonelFileUrl'

category: 'accessing'
method: CypressTonelFileUrl
codeFormat
  ^ 'Tonel'
%

category: 'testing'
method: CypressTonelFileUrl
isStrict
  ^ true
%

category: 'accessing'
method: CypressTonelFileUrl
repositoryClass

	^CypressTonelRepository
%

! Class implementation for 'CypressTopazUrl'

!		Class methods for 'CypressTopazUrl'

category: 'constants'
classmethod: CypressTopazUrl
schemeName

	^'topaz'
%

!		Instance methods for 'CypressTopazUrl'

category: 'accessing'
method: CypressTopazUrl
codeFormat

	^'Topaz'
%

category: 'testing'
method: CypressTopazUrl
isStrict

	^true
%

category: 'accessing'
method: CypressTopazUrl
repositoryClass

	^CypressTopazRepository
%

! Class implementation for 'CypressGenericUrl'

!		Class methods for 'CypressGenericUrl'

category: 'parsing'
classmethod: CypressGenericUrl
absoluteFromText: aString

	| schemeName locator |
	schemeName := CypressUrl schemeNameForString: aString.
	schemeName ifNil: [^self schemeName: 'xnoscheme' locator: aString].
	locator := aString copyFrom: schemeName size + 2 to: aString size.
	^self schemeName: schemeName locator: locator
%

category: 'instance creation'
classmethod: CypressGenericUrl
schemeName: schemeName  locator: locator
	^self new schemeName: schemeName  locator: locator
%

!		Instance methods for 'CypressGenericUrl'

category: 'access'
method: CypressGenericUrl
locator
	^locator
%

category: 'printing'
method: CypressGenericUrl
printOn: aStream
	
	self schemeName ifNotNil: [
		aStream nextPutAll: self schemeName; nextPut: $:].
	
	aStream nextPutAll: self locator.

	self fragment ifNotNil: [
		aStream nextPut: $#; nextPutAll: self fragment].
%

category: 'parsing'
method: CypressGenericUrl
privateInitializeFromText: aString

	schemeName := CypressUrl schemeNameForString: aString.
	locator := schemeName
				ifNil: [aString]
				ifNotNil: [aString copyFrom: schemeName size + 2 to: aString size]
%

category: 'parsing'
method: CypressGenericUrl
privateInitializeFromText: aString relativeTo: aUrl
	schemeName := aUrl schemeName.
	locator := aString.
%

category: 'classification'
method: CypressGenericUrl
scheme
	^ self schemeName.
%

category: 'access'
method: CypressGenericUrl
schemeName
	^schemeName
%

category: 'private'
method: CypressGenericUrl
schemeName: schemeName0  locator: locator0
	schemeName := schemeName0.
	locator := locator0.
%

! Class implementation for 'CypressBrowserUrl'

!		Class methods for 'CypressBrowserUrl'

category: 'constants'
classmethod: CypressBrowserUrl
schemeName

	^'browser'
%

!		Instance methods for 'CypressBrowserUrl'

category: 'downloading'
method: CypressBrowserUrl
hasContents

	^true
%

! Class implementation for 'CypressMailtoUrl'

!		Class methods for 'CypressMailtoUrl'

category: 'constants'
classmethod: CypressMailtoUrl
schemeName

	^ 'mailto'
%

! Class implementation for 'CypressHierarchicalUrl'

!		Class methods for 'CypressHierarchicalUrl'

category: 'instance creation'
classmethod: CypressHierarchicalUrl
schemeName: schemeName  authority: authority  path: path  query: query
	^self new schemeName: schemeName  authority: authority  path: path  query: query
%

!		Instance methods for 'CypressHierarchicalUrl'

category: 'access'
method: CypressHierarchicalUrl
authority
	^authority
%

category: 'access'
method: CypressHierarchicalUrl
fileName
	"Return the last part of the path,
	most often a filename but does not need to be."

	^self path last
%

category: 'printing'
method: CypressHierarchicalUrl
fullPath

	| ans |
	ans := WriteStreamPortable on: String new.
	path do: 
			[:pathElem |
			ans nextPut: $/.
			self writeWithHttpEscapes: pathElem on: ans].
	self query isNil
		ifFalse: 
			[ans nextPut: $?.
			ans nextPutAll: self query].
	self fragment isNil
		ifFalse: 
			[ans nextPut: $#.
			self writeWithHttpEscapes: self fragment on: ans].
	^ans contents
%

category: 'downloading'
method: CypressHierarchicalUrl
hasContents
	"most of these do...."
	^true
%

category: 'access'
method: CypressHierarchicalUrl
isAbsolute
	
	path size > 0 ifFalse: [^ false].
	(path at: 1) size > 0 ifFalse: [^ false].
	^ ((path at: 1) at: 1) ~~ $.
%

category: 'access'
method: CypressHierarchicalUrl
password
	"http://user:pword@foo.com' asUrl password"
	^password
%

category: 'access'
method: CypressHierarchicalUrl
path
	"return a collection of the decoded path elements, as strings"
	^path
%

category: 'access'
method: CypressHierarchicalUrl
path: aCollection
	"Set the collection of path elements."

	path := aCollection
%

category: 'access'
method: CypressHierarchicalUrl
port
	^port
%

category: 'copying'
method: CypressHierarchicalUrl
postCopy
	"Be sure not to share the path with the copy"

	super postCopy.
	path := path copy
%

category: 'printing'
method: CypressHierarchicalUrl
printOn: aStream

	aStream nextPutAll: self schemeName.
	aStream nextPutAll: '://'.
	self username
		ifNotNil: 
			[self writeWithHttpEscapes: self username on: aStream.
			self password
				ifNotNil: 
					[aStream nextPutAll: ':'.
					self writeWithHttpEscapes: self password on: aStream].
			aStream nextPutAll: '@'].
	aStream nextPutAll: self authority.
	port
		ifNotNil: 
			[aStream
				nextPut: $:;
				nextPutAll: port printString].
	path do: 
			[:pathElem |
			aStream nextPut: $/.
			self writeWithHttpEscapes: pathElem on: aStream].
	self query isNil
		ifFalse: 
			[aStream nextPut: $?.
			aStream nextPutAll: self query].
	self fragment isNil
		ifFalse: 
			[aStream nextPut: $#.
			self writeWithHttpEscapes: self fragment on: aStream]
%

category: 'parsing'
method: CypressHierarchicalUrl
privateInitializeFromText: aString
	| remainder ind specifiedSchemeName |
	remainder := aString.
	schemeName
		ifNil: 
			[specifiedSchemeName := CypressUrl schemeNameForString: remainder.
			specifiedSchemeName
				ifNotNil: 
					[schemeName := specifiedSchemeName.
					remainder := remainder copyFrom: schemeName size + 2 to: remainder size].
			schemeName
				ifNil: 
					["assume HTTP"
					schemeName := 'http']].

	"remove leading // if it's there"
	(remainder indexOfSubCollection: '//' startingAt: 1 ifAbsent: [ 0 ]) = 1
		ifTrue: [remainder := remainder copyFrom: 3 to: remainder size].

	"get the query"
	ind := remainder indexOf: $?.
	ind > 0
		ifTrue: 
			[query := remainder copyFrom: ind + 1 to: remainder size.
			remainder := remainder copyFrom: 1 to: ind - 1].

	"get the authority"
	ind := remainder indexOf: $/.
	ind > 0
		ifTrue: 
			[ind = 1
				ifTrue: [authority := '']
				ifFalse: 
					[authority := remainder copyFrom: 1 to: ind - 1.
					remainder := remainder copyFrom: ind + 1 to: remainder size]]
		ifFalse: 
			[authority := remainder.
			remainder := ''].

	"extract the username+password"
	ind := authority indexOf: $@.
	ind > 0
		ifTrue: 
			[username := authority copyFrom: 1 to: ind - 1.
			authority := authority copyFrom: ind + 1 to: authority size.
			ind := username indexOf: $:.
			ind > 0
				ifTrue: 
					[password := (self
								decodeHttpEscapesOf: (username copyFrom: ind + 1 to: username size))
									asByteArray decodeFromUTF8
								asString.
					username := username copyFrom: 1 to: ind - 1]
				ifFalse: [password := nil].
			username := (self decodeHttpEscapesOf: username) asByteArray
						decodeFromUTF8 asString].

	"Extract the port"
	(authority includes: $:)
		ifTrue: 
			[| lastColonIndex portString |
			lastColonIndex := authority findLast: [:c | c = $:].
			portString := authority copyFrom: lastColonIndex + 1 to: authority size.
			(portString size > 0) 
				ifTrue: [ 
					(portString allSatisfy: [:each | each isDigit])
						ifTrue: 
							[port := Integer fromString: portString.
							port > 65535 ifTrue: [self error: 'Invalid port number']]
						ifFalse: [self error: 'Invalid port number']].
			authority := authority copyFrom: 1 to: lastColonIndex - 1].

	"get the path"
	path := self privateParsePath: remainder relativeTo: #()
%

category: 'parsing'
method: CypressHierarchicalUrl
privateInitializeFromText: aString relativeTo: aUrl

	| remainder ind basePath |
	remainder := aString.
	"set the scheme"
	schemeName := aUrl schemeName.

	"a leading // means the authority is specified, meaning it is absolute"
	(remainder indexOfSubCollection: '//' startingAt: 1 ifAbsent: [ 0 ]) = 1
		ifTrue: [^self privateInitializeFromText: aString].

	"otherwise, use the same authority"
	authority := aUrl authority.
	port := aUrl port.
	username := aUrl username.
	password := aUrl password.

	"get the query"
	ind := remainder indexOf: $?.
	ind > 0
		ifTrue: 
			[query := remainder copyFrom: ind + 1 to: remainder size.
			remainder := remainder copyFrom: 1 to: ind - 1].

	"get the path"
	(remainder indexOfSubCollection: '/' startingAt: 1 ifAbsent: [ 0 ]) = 1
		ifTrue: [basePath := #()]
		ifFalse: [basePath := aUrl path].
	path := self privateParsePath: remainder relativeTo: basePath
%

category: 'parsing'
method: CypressHierarchicalUrl
privateParsePath: remainder relativeTo: basePath

	| nextTok s parsedPath |
	s := remainder readStream.
	parsedPath := OrderedCollection new.
	parsedPath addAll: basePath.
	parsedPath isEmpty ifFalse: [parsedPath removeLast].
	
	[s peek = $/ ifTrue: [s next].
	nextTok := WriteStreamPortable on: String new.
	[s atEnd or: [s peek = $/]] whileFalse: [nextTok nextPut: s next].
	nextTok := self decodeHttpEscapesOf: nextTok contents.
	nextTok = '..'
		ifTrue: [parsedPath size > 0 ifTrue: [parsedPath removeLast]]
		ifFalse: [nextTok ~= '.' ifTrue: [parsedPath add: nextTok]].
	s atEnd]
			whileFalse.
	parsedPath isEmpty ifTrue: [parsedPath add: ''].
	^parsedPath
%

category: 'access'
method: CypressHierarchicalUrl
query
	"return the query, the part after any ?.  Any %XY's have already been decoded.  If there wasno query part, nil is returned (it is possible to also have an empty query"
	^query 
%

category: 'classification'
method: CypressHierarchicalUrl
scheme
	^ self schemeName.
%

category: 'access'
method: CypressHierarchicalUrl
schemeName
	^schemeName
%

category: 'private'
method: CypressHierarchicalUrl
schemeName: schemeName0  authority: authority0  path: path0  query: query0
	"initialize a new instance"
	schemeName := schemeName0.
	authority := authority0.
	path := path0.
	query := query0.
%

category: 'access'
method: CypressHierarchicalUrl
username
	"http://user:pword@foo.com' asUrl username"
	^username
%

! Class implementation for 'CypressFtpUrl'

!		Class methods for 'CypressFtpUrl'

category: 'constants'
classmethod: CypressFtpUrl
schemeName

	^ 'ftp'.
%

! Class implementation for 'CypressHttpUrl'

!		Class methods for 'CypressHttpUrl'

category: 'constants'
classmethod: CypressHttpUrl
schemeName

	^ 'http'.
%

! Class implementation for 'CypressHttpsUrl'

!		Class methods for 'CypressHttpsUrl'

category: 'constants'
classmethod: CypressHttpsUrl
schemeName

	^ 'https'.
%

! Class implementation for 'CypressVersionReference'

!		Class methods for 'CypressVersionReference'

category: 'instance creation'
classmethod: CypressVersionReference
name: aString

	^(self basicNew)
		initializeName: aString;
		yourself
%

category: 'instance creation'
classmethod: CypressVersionReference
new

	self error: 'Use #name: to initialize the receiver.'
%

!		Instance methods for 'CypressVersionReference'

category: 'comparing'
method: CypressVersionReference
= aReference

	^self class = aReference class
		and: [self name = aReference name]
%

category: 'accessing'
method: CypressVersionReference
author
	"Answer the author of the receiver."
	
	^ author
%

category: 'accessing'
method: CypressVersionReference
branch
	"Answer the branch of the receiver."
	
	^ branch
%

category: 'comparing'
method: CypressVersionReference
hash

	^self name hash
%

category: 'initialization'
method: CypressVersionReference
initializeName: aString

	name := aString.
	self parseName: aString
%

category: 'private'
method: CypressVersionReference
matches: aResolvedReference
	^ self name = aResolvedReference name
%

category: 'accessing'
method: CypressVersionReference
name
	"Answer the name of this reference."
	
	^ name
%

category: 'accessing'
method: CypressVersionReference
packageName
	"Answer the package of the receiver."

	^ package
%

category: 'initialization'
method: CypressVersionReference
parseName: aString

	| basicName lastDotIndex packageDotIndex lastMinusIndex |
	basicName := (aString isEmpty
				or: [aString last isDigit or: [(aString includes: $() not]])
					ifTrue: [aString]
					ifFalse: 
						["up to last (, but not if there's a . after it"
						| parenIndex dotIndex |
						parenIndex := 0.
						dotIndex := 0.
						aString size to: 1
							by: -1
							do: 
								[:i |
								| c |
								c := aString at: i.
								(c = $. and: [dotIndex = 0])
									ifTrue: 
										[dotIndex := i.
										parenIndex := 0].
								(c = $( and: [parenIndex = 0]) ifTrue: [parenIndex := i]].
						aString copyFrom: 1 to: parenIndex - 1].
	lastMinusIndex := 0.
	lastDotIndex := 0.
	basicName size to: 1
		by: -1
		do: 
			[:i |
			| c |
			c := basicName at: i.
			(c = $- and: [lastMinusIndex = 0]) ifTrue: [lastMinusIndex := i].
			(c = $. and: [lastDotIndex = 0]) ifTrue: [lastDotIndex := i]].
	lastMinusIndex = 0 ifTrue: [lastMinusIndex := basicName size + 1].
	package := basicName copyFrom: 1 to: lastMinusIndex - 1.
	branch := ''.
	packageDotIndex := package indexOf: $..
	packageDotIndex > 0
		ifTrue: 
			[branch := package copyFrom: packageDotIndex + 1 to: package size.
			package := package copyFrom: 1 to: packageDotIndex - 1].
	author := lastMinusIndex = 0
				ifTrue: ['']
				ifFalse: 
					[lastDotIndex < lastMinusIndex ifTrue: [lastDotIndex := basicName size + 1].
					basicName copyFrom: lastMinusIndex + 1 to: lastDotIndex - 1].

	"if basicName is of the form anything-something.number, you'll get number.
If it contains no hyphen, or no period after the last hyphen, you get nothing"
	versionNumber := (basicName indexOf: $-) = 0
				ifTrue: [0]
				ifFalse: 
					[| index lastIndex char |
					index := lastIndex := basicName size.
					char := basicName at: index.
					[char = $. | (char = $-)] whileFalse: 
							[index := index - 1.
							char := basicName at: index].
					char = $-
						ifTrue: [0	"No period after last hyphen."]
						ifFalse: 
							[| numberString |
							numberString := basicName copyFrom: index + 1 to: lastIndex.
							(numberString notEmpty
								and: [numberString allSatisfy: [:each | each isDigit]])
									ifTrue: [numberString asInteger]
									ifFalse: [0]]]
%

category: 'printing'
method: CypressVersionReference
printOn: aStream

	super printOn: aStream.
	aStream nextPutAll: ' name: '.
	self name printOn: aStream
%

category: 'accessing'
method: CypressVersionReference
versionNumber
	"Answer the version of the receiver."

	^ versionNumber
%

! Class implementation for 'GsInteraction'

!		Instance methods for 'GsInteraction'

category: 'accessing'
method: GsInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      nil ] ].
  ^ defaultActionBlock
%

category: 'accessing'
method: GsInteraction
defaultActionBlock: anObject

   "Modify the value of the instance variable 'defaultActionBlock'."
   defaultActionBlock := anObject
%

category: 'interacting'
method: GsInteraction
defaultActionFor: anInteractionRequest
  ^ self defaultActionBlock value: anInteractionRequest
%

category: 'interacting'
method: GsInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithInspect:
     interactWithMultiLineText:
     interactWithText:
  "

  self subclassResponsibility
%

category: 'printing'
method: GsInteraction
printLabel
  ^ ''
%

category: 'printing'
method: GsInteraction
printOn: aStream
  aStream nextPutAll: self class name asString , '(' , self printLabel , ')'
%

category: 'interacting'
method: GsInteraction
signal
  ^ GsInteractionRequest signal: self
%

! Class implementation for 'GsChoiceInteraction'

!		Class methods for 'GsChoiceInteraction'

category: 'instance creation'
classmethod: GsChoiceInteraction
labels: anArray
	^ self
		prompt: nil
		labels: anArray
		values: anArray
		lines: #()
%

category: 'instance creation'
classmethod: GsChoiceInteraction
labels: labelArray lines: lineArray
	^ self
		prompt: nil
		labels: labelArray
		values: labelArray
		lines: lineArray
%

category: 'instance creation'
classmethod: GsChoiceInteraction
prompt: aString labels: labelArray values: valueArray
	^ self
		prompt: aString
		labels: labelArray
		 values: valueArray
		lines: #()
%

category: 'instance creation'
classmethod: GsChoiceInteraction
prompt: aString labels: labelArray values: valueArray lines: lineArray
  ^ self new
    prompt: aString;
    labels: labelArray;
    values: valueArray;
    lines: lineArray;
    yourself
%

!		Instance methods for 'GsChoiceInteraction'

category: 'interacting'
method: GsChoiceInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithChoice: self
%

category: 'accessing'
method: GsChoiceInteraction
labels

   "Return the value of the instance variable 'labels'."
   ^labels
%

category: 'accessing'
method: GsChoiceInteraction
labels: anObject

   "Modify the value of the instance variable 'labels'."
   labels := anObject
%

category: 'accessing'
method: GsChoiceInteraction
lines

   "Return the value of the instance variable 'lines'."
   ^lines
%

category: 'accessing'
method: GsChoiceInteraction
lines: anObject

   "Modify the value of the instance variable 'lines'."
   lines := anObject
%

category: 'printing'
method: GsChoiceInteraction
printLabel
  ^ self prompt
%

category: 'accessing'
method: GsChoiceInteraction
prompt

   "Return the value of the instance variable 'prompt'."
   ^prompt
%

category: 'accessing'
method: GsChoiceInteraction
prompt: aString
  prompt := aString copyWrappedTo: 80
%

category: 'choice'
method: GsChoiceInteraction
select: anIndex
  ^ self values at: anIndex
%

category: 'choice'
method: GsChoiceInteraction
select: anIndex for: anInteractionRequest
  anInteractionRequest response: (self values at: anIndex)
%

category: 'accessing'
method: GsChoiceInteraction
values

   "Return the value of the instance variable 'values'."
   ^values
%

category: 'accessing'
method: GsChoiceInteraction
values: anObject

   "Modify the value of the instance variable 'values'."
   values := anObject
%

! Class implementation for 'GsConfirmInteraction'

!		Class methods for 'GsConfirmInteraction'

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt
  ^ self prompt: prompt confirm: 'Ok'
%

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt confirm: confirm
  ^ self prompt: prompt confirm: confirm cancel: 'Cancel'
%

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt confirm: confirm cancel: cancel
  ^ self new
    prompt: prompt;
    confirm: confirm;
    cancel: cancel
%

category: 'instance creation'
classmethod: GsConfirmInteraction
prompt: prompt confirm: confirm cancel: cancel abort: abort
  "on confirm return true, on cancel return false on abort return nil"

  ^ self new
    prompt: prompt;
    confirm: confirm;
    cancel: cancel;
    abort: abort
%

!		Instance methods for 'GsConfirmInteraction'

category: 'accessing'
method: GsConfirmInteraction
abort
  ^ abort
%

category: 'accessing'
method: GsConfirmInteraction
abort: anObject
  abort := anObject
%

category: 'confirm'
method: GsConfirmInteraction
abortFor: anInteractionRequest
  anInteractionRequest response: self abortResponse
%

category: 'confirm'
method: GsConfirmInteraction
abortResponse
  ^ nil
%

category: 'accessing'
method: GsConfirmInteraction
cancel
  ^ cancel
%

category: 'accessing'
method: GsConfirmInteraction
cancel: anObject
	cancel := anObject
%

category: 'confirm'
method: GsConfirmInteraction
cancelFor: anInteractionRequest
  anInteractionRequest response: self cancelResponse
%

category: 'confirm'
method: GsConfirmInteraction
cancelResponse
  ^ false
%

category: 'accessing'
method: GsConfirmInteraction
confirm
	^ confirm
%

category: 'accessing'
method: GsConfirmInteraction
confirm: anObject
	confirm := anObject
%

category: 'accessing'
method: GsConfirmInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      self cancelResponse ] ].
  ^ defaultActionBlock
%

category: 'interacting'
method: GsConfirmInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithConfirm: self
%

category: 'confirm'
method: GsConfirmInteraction
ok
  ^ true
%

category: 'confirm'
method: GsConfirmInteraction
okFor: anInteractionRequest
  anInteractionRequest response: self okResponse
%

category: 'confirm'
method: GsConfirmInteraction
okResponse
  ^ true
%

category: 'printing'
method: GsConfirmInteraction
printLabel
  ^ self prompt
%

category: 'accessing'
method: GsConfirmInteraction
prompt
	^ prompt
%

category: 'accessing'
method: GsConfirmInteraction
prompt: aString
  prompt := aString copyWrappedTo: 80
%

! Class implementation for 'GsNotifyInteraction'

!		Instance methods for 'GsNotifyInteraction'

category: 'accessing'
method: GsNotifyInteraction
defaultActionBlock
  "notify answers ok by default, while confirm answers fals by default"

  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      self okResponse ] ].
  ^ defaultActionBlock
%

! Class implementation for 'GsInformInteraction'

!		Class methods for 'GsInformInteraction'

category: 'instance creation'
classmethod: GsInformInteraction
message: aString
  ^ self new
    message: aString;
    yourself
%

!		Instance methods for 'GsInformInteraction'

category: 'interacting'
method: GsInformInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithInform: self
%

category: 'accessing'
method: GsInformInteraction
message

   "Return the value of the instance variable 'message'."
   ^message
%

category: 'accessing'
method: GsInformInteraction
message: aString
  message := aString copyWrappedTo: 80
%

category: 'printing'
method: GsInformInteraction
printLabel
  ^ self message
%

! Class implementation for 'GsInspectInteraction'

!		Class methods for 'GsInspectInteraction'

category: 'instance creation'
classmethod: GsInspectInteraction
theObject: anObject
  ^ self new
    theObject: anObject;
    yourself
%

!		Instance methods for 'GsInspectInteraction'

category: 'accessing'
method: GsInspectInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      self theObject ] ].
  ^ defaultActionBlock
%

category: 'interacting'
method: GsInspectInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithInspect:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithInspect: self
%

category: 'printing'
method: GsInspectInteraction
printLabel
  ^ self theObject printString
%

category: 'accessing'
method: GsInspectInteraction
theObject

   "Return the value of the instance variable 'theObject'."
   ^theObject
%

category: 'accessing'
method: GsInspectInteraction
theObject: anObject

   "Modify the value of the instance variable 'theObject'."
   theObject := anObject
%

! Class implementation for 'GsExploreInteraction'

!		Instance methods for 'GsExploreInteraction'

category: 'interacting'
method: GsExploreInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithInspect:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithExplore: self
%

! Class implementation for 'GsTextInteraction'

!		Class methods for 'GsTextInteraction'

category: 'instance creation'
classmethod: GsTextInteraction
prompt: aString
  ^ self prompt: aString template: ''
%

category: 'instance creation'
classmethod: GsTextInteraction
prompt: promptString template: templateString
  ^ self new
    prompt: promptString;
    template: templateString;
    yourself
%

category: 'instance creation'
classmethod: GsTextInteraction
requestPassword: aString
  ^ self new
    requestPassword: aString;
    yourself
%

!		Instance methods for 'GsTextInteraction'

category: 'accessing'
method: GsTextInteraction
defaultActionBlock
  defaultActionBlock
    ifNil: [ 
      ^ [ :interactionRequest | 
      Transcript cr; show: self printString.
      '' ] ].
  ^ defaultActionBlock
%

category: 'interacting'
method: GsTextInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithText: self
%

category: 'printing'
method: GsTextInteraction
printLabel
  ^ self prompt
%

category: 'accessing'
method: GsTextInteraction
prompt

   "Return the value of the instance variable 'prompt'."
   ^prompt
%

category: 'accessing'
method: GsTextInteraction
prompt: aString
  prompt := aString copyWrappedTo: 80
%

category: 'accessing'
method: GsTextInteraction
requestPassword

   requestPassword ifNil: [ requestPassword := false ].
   ^requestPassword
%

category: 'accessing'
method: GsTextInteraction
requestPassword: aString

   prompt := aString.
   requestPassword := true
%

category: 'accessing'
method: GsTextInteraction
template
  template ifNil: [ template := '' ].
  ^ template
%

category: 'accessing'
method: GsTextInteraction
template: anObject

   "Modify the value of the instance variable 'template'."
   template := anObject
%

! Class implementation for 'GsMultiLineTextInteraction'

!		Instance methods for 'GsMultiLineTextInteraction'

category: 'interacting'
method: GsMultiLineTextInteraction
interactWith: anObject
  "opportunity for double dispatch:

     interactWithChoice:
     interactWithConfirm:
     interactWithInform:
     interactWithMultiLineText:
     interactWithText:
  "

  ^ anObject interactWithMultiLineText: self
%

! Class implementation for 'GsInteractionHandler'

!		Instance methods for 'GsInteractionHandler'

category: 'accessing'
method: GsInteractionHandler
choiceBlock
  choiceBlock ifNil: [ ^ self defaultBlock ].
  ^ choiceBlock
%

category: 'accessing'
method: GsInteractionHandler
choiceBlock: anObject

   "Modify the value of the instance variable 'choiceBlock'."
   choiceBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
confirmBlock
  confirmBlock ifNil: [ ^ self defaultBlock ].
  ^ confirmBlock
%

category: 'accessing'
method: GsInteractionHandler
confirmBlock: anObject

   "Modify the value of the instance variable 'confirmBlock'."
   confirmBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
defaultBlock
  defaultBlock
    ifNil: [ 
      defaultBlock := [ :interaction | 
      self
        error:
          'No handler defined for ' , interaction class name asString , ' interaction.' ] ].
  ^ defaultBlock
%

category: 'accessing'
method: GsInteractionHandler
defaultBlock: anObject

   "Modify the value of the instance variable 'defaultBlock'."
   defaultBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
informBlock
  informBlock ifNil: [ ^ self defaultBlock ].
  ^ informBlock
%

category: 'accessing'
method: GsInteractionHandler
informBlock: anObject

   "Modify the value of the instance variable 'informBlock'."
   informBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
inspectBlock
  inspectBlock ifNil: [ ^ self defaultBlock ].
  ^ inspectBlock
%

category: 'accessing'
method: GsInteractionHandler
inspectBlock: anObject

   "Modify the value of the instance variable 'inspectBlock'."
   inspectBlock := anObject
%

category: 'interactions'
method: GsInteractionHandler
interactWithChoice: interaction
  ^ self choiceBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithConfirm: interaction
  ^ self confirmBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithExplore: interaction
  ^ self interactWithInspect: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithInform: interaction
  ^ self informBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithInspect: interaction
  ^ self inspectBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithMultiLineText: interaction
  ^ self multiLineTextBlock value: interaction
%

category: 'interactions'
method: GsInteractionHandler
interactWithText: interaction
  ^ self textBlock value: interaction
%

category: 'accessing'
method: GsInteractionHandler
multiLineTextBlock
  multiLineTextBlock ifNil: [ ^ self defaultBlock ].
  ^ multiLineTextBlock
%

category: 'accessing'
method: GsInteractionHandler
multiLineTextBlock: anObject

   "Modify the value of the instance variable 'multiLineTextBlock'."
   multiLineTextBlock := anObject
%

category: 'accessing'
method: GsInteractionHandler
textBlock
  textBlock ifNil: [ ^ self defaultBlock ].
  ^ textBlock
%

category: 'accessing'
method: GsInteractionHandler
textBlock: anObject

   "Modify the value of the instance variable 'textBlock'."
   textBlock := anObject
%

! Class implementation for 'GsTonelOrderedDictionary'

!		Class methods for 'GsTonelOrderedDictionary'

category: 'instance creation'
classmethod: GsTonelOrderedDictionary
new
	^ self new: 3
%

category: 'instance creation'
classmethod: GsTonelOrderedDictionary
new: anInteger
	^ self basicNew initialize: anInteger; yourself
%

category: 'instance creation'
classmethod: GsTonelOrderedDictionary
withAll: aDictionary
	^ (self new: aDictionary size)
		addAll: aDictionary;
		yourself
%

!		Instance methods for 'GsTonelOrderedDictionary'

category: 'accessing'
method: GsTonelOrderedDictionary
add: anAssociation
	self at: anAssociation key put: anAssociation value.
	^ anAssociation
%

category: 'adding'
method: GsTonelOrderedDictionary
addAll: aDictionary
	aDictionary keysAndValuesDo: [ :key :value | self at: key put: value ].
	^ aDictionary
%

category: 'accessing'
method: GsTonelOrderedDictionary
associations
	"Answer a Collection containing the receiver's associations."

	| result |
	result := WriteStream on: (Array new: self size).
	self associationsDo: [ :assoc | result nextPut: assoc ].
	^ result contents
%

category: 'enumerating'
method: GsTonelOrderedDictionary
associationsDo: aBlock
	self keysAndValuesDo: [ :key :value | aBlock value: key -> value ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
at: aKey
	"Answer the value associated with aKey. Raise an exception, if no such key is defined."

	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
at: aKey ifAbsent: aBlock
	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index ]
		ifTrue: [ aBlock value ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
at: aKey ifAbsentPut: aBlock
	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index ]
		ifTrue: [ self privateAt: aKey put: aBlock value ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
at: aKey ifPresent: aBlock
	"Lookup aKey in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0 ifFalse: [ aBlock value: (values at: index) ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
at: aKey put: aValue
	"Set the value of aKey to be aValue."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index put: aValue ]
		ifTrue: [ self privateAt: aKey put: aValue ]
%

category: 'enumerating'
method: GsTonelOrderedDictionary
do: aBlock
	1 to: size do: [ :index | aBlock value: (values at: index) ]
%

category: 'private'
method: GsTonelOrderedDictionary
errorKeyNotFound
	self error: 'Key not found'
%

category: 'private'
method: GsTonelOrderedDictionary
findIndexFor: aKey
	1 to: size do: [ :index |
		(keys at: index) = aKey
			ifTrue: [ ^ index ] ].
	^ 0
%

category: 'private'
method: GsTonelOrderedDictionary
grow
	| newKeys newValues |
	newKeys := Array new: 2 * size.
	newValues := Array new: 2 * size.
	1 to: size do: [ :index |
		newKeys at: index put: (keys at: index).
		newValues at: index put: (values at: index) ].
	keys := newKeys.
	values := newValues
%

category: 'testing'
method: GsTonelOrderedDictionary
includesKey: aKey
	"Answer whether the receiver has a key equal to aKey."

	^ (self findIndexFor: aKey) ~= 0
%

category: 'initialization'
method: GsTonelOrderedDictionary
initialize: anInteger
  size := 0.
  keys := Array new: anInteger.
  values := Array new: anInteger
%

category: 'testing'
method: GsTonelOrderedDictionary
isCollection
	^ true
%

category: 'testing'
method: GsTonelOrderedDictionary
isEmpty
	^ size = 0
%

category: 'enumerating'
method: GsTonelOrderedDictionary
keys
	^ keys copyFrom: 1 to: size
%

category: 'enumerating'
method: GsTonelOrderedDictionary
keysAndValuesDo: aBlock
	1 to: size do: [ :index | aBlock value: (keys at: index) value: (values at: index) ]
%

category: 'enumerating'
method: GsTonelOrderedDictionary
keysDo: aBlock
	1 to: size do: [ :each | aBlock value: (keys at: each) ]
%

category: 'copying'
method: GsTonelOrderedDictionary
postCopy
	super postCopy.
	keys := keys copy.
	values := values copy
%

category: 'printing'
method: GsTonelOrderedDictionary
printOn: aStream
	super printOn: aStream.
	
	aStream nextPut: $(.
	self size <= 100
		ifTrue: [
			| first |
			first := true.
			self keysAndValuesDo: [ :key :value |
				"keysAndValuesDo:separatedBy: would be nice"
				first
					ifTrue: [ first := false ]
					ifFalse: [ aStream space ].
				aStream
					print: key;
					nextPutAll: '->';				
					print: value ] ]
		ifFalse: [
			aStream
				nextPutAll: 'size ';
				print: self size ].
	aStream nextPut: $)	
%

category: 'private'
method: GsTonelOrderedDictionary
privateAt: aKey put: aValue
	size = keys size ifTrue: [ self grow ].
	keys at: (size := size + 1) put: aKey.
	^ values at: size put: aValue
%

category: 'private'
method: GsTonelOrderedDictionary
removeIndex: index
	| value |
	value := values at: index.
	index to: size - 1 do:
			[ :i | 
			keys at: i put: (keys at: i + 1).
			values at: i put: (values at: i + 1) ].
	keys at: size put: nil.
	values at: size put: nil.
	size := size - 1.
	^ value
%

category: 'accessing'
method: GsTonelOrderedDictionary
removeKey: aKey
	"Remove aKey from the receiver, raise an exception if the element is missing."

	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]
%

category: 'accessing'
method: GsTonelOrderedDictionary
removeKey: aKey ifAbsent: aBlock
	"Remove aKey from the receiver, evaluate aBlock if the element is missing."

	| index |
	index := self findIndexFor: aKey.
	index = 0 ifTrue: [ ^ aBlock value ].
	^ self removeIndex: index
%

category: 'accessing'
method: GsTonelOrderedDictionary
size
	^ size
%

category: 'ston'
method: GsTonelOrderedDictionary
stonOn: stonWriter
	"Instances of STON mapClass will be encoded directly, without a class tag.
	Other (sub)classes will be encoded with a class tag and will use a map representation. "
	
    stonWriter encodeMap: self
%

category: 'enumerating'
method: GsTonelOrderedDictionary
values
	^ values copyFrom: 1 to: size
%

! Class implementation for 'JadeServer'

!		Class methods for 'JadeServer'

category: 'jadeite server'
classmethod: JadeServer
theJadeiteServer
  ^ SessionTemps current
    at: #'jadeiteServer'
    ifAbsentPut: [ 
      | jadeServerClass |
      jadeServerClass := (System _gemVersion beginsWith: '3.2')
        ifTrue: [ Rowan jadeServerClassNamed: #'JadeServer64bit32' ]
        ifFalse: [ Rowan jadeServerClassNamed: #'JadeServer64bit35' ].
      jadeServerClass new
        initialize;
        yourself ]
%

!		Instance methods for 'JadeServer'

category: 'category'
method: JadeServer
abort

	classOrganizers := Array new: 4.
	System abortTransaction.
%

category: 'category'
method: JadeServer
addAccessorsFor: aString inBehavior: aBehavior

	aBehavior compileAccessingMethodsFor: (Array with: aString asSymbol).

%

category: 'category'
method: JadeServer
addCategory: aString to: aClass 

	aClass addCategory: aString.

%

category: 'category'
method: JadeServer
addGroup: aString toUser: aUserProfile

	aUserProfile addGroup: aString.

%

category: 'category'
method: JadeServer
addMethodCategoryNamesToMethodFilters

	classList do: [:each | methodFilters addAll: each categoryNames].

%

category: 'category'
method: JadeServer
addMissingAccessorsFor: aClass

	aClass compileMissingAccessingMethods.

%

category: 'category'
method: JadeServer
addPrivilege: aString toUser: aUserProfile

	aUserProfile addPrivilege: aString.

%

category: 'category'
method: JadeServer
addProcess: aProcess to: aStream withStatus: aString scheduler: aScheduler

	| x |
	aStream lf
"1"	nextPutAll: aString; tab;
"2"	nextPutAll: aProcess asOop printString; tab;
"3"	nextPutAll: aProcess priority printString; tab;
"4"	nextPutAll: (aProcess createdByApplication ifTrue: ['Y'] ifFalse: ['']); tab; 
"5"	nextPutAll: ((x := aProcess stackId) == -1 	ifTrue: [''] ifFalse: [x printString]); tab;
"6"	nextPutAll: ((x := aProcess waitingOn) 	isNil ifTrue: [''] ifFalse: [x asOop printString]); tab;
"7"	nextPutAll: ((x := aProcess _signalTime) 	isNil ifTrue: [''] ifFalse: [(x - aScheduler _now) printString]); tab;
"8"	nextPutAll: (aProcess isPartialContinuation	ifTrue: ['partial'] ifFalse: [aProcess isContinuation ifTrue: ['full'] ifFalse: ['']]); tab;
"9"	"type: forked or main"
"10"	"live or terminated"
	yourself.

%

category: 'category'
method: JadeServer
addSessionWithId: anInteger toStream: aStream

	| array gsSession timeGmt x |
	array := System descriptionOfSession: anInteger.
	array size: 20.
	gsSession := GsSession sessionWithSerialNumber: (array at: 9).
	timeGmt := System timeGmt.
	aStream
		nextPutAll: '<session oop=';
		nextPutAll: (self oopOf: gsSession) printString printString;
		nextPutAll: ' name=';
		nextPutAll: (array at: 1) userId printString;
		nextPutAll: ' process=';
		nextPutAll: (array at: 2) printString printString;
		nextPutAll: ' host=';
		nextPutAll: (array at: 3) printString;
		nextPutAll: ' primitive=';
		nextPutAll: (array at: 4) printString printString;
		nextPutAll: ' viewAge=';
		nextPutAll: (timeGmt - (array at: 5)) printString printString;
		nextPutAll: ' state=';
		nextPutAll: (array at: 6) printString printString;
		nextPutAll: ' transaction=';
		nextPutAll: (array at: 7) printString printString;
		nextPutAll: ' hasOldestCR=';
		nextPutAll: (array at: 8) printString printString;
		nextPutAll: ' serial=';
		nextPutAll: (array at: 9) printString printString;
		nextPutAll: ' id=';
		nextPutAll: (array at: 10) printString printString;
		nextPutAll: ' ip=';
		nextPutAll: (array at: 11) printString;
		nextPutAll: ' priority=';
		nextPutAll: ((x := array at: 12) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' hostId=';
		nextPutAll: ((x := array at: 13)  isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' quietTime=';
		nextPutAll: ((x := array at: 14) isNil ifTrue: [''] ifFalse: [(timeGmt - x)  printString]) printString;
		nextPutAll: ' lifeTime=';
		nextPutAll: ((x := array at: 15) isNil ifTrue: [''] ifFalse: [(timeGmt - x)  printString]) printString;
		nextPutAll: ' backlog=';
		nextPutAll: ((x := array at: 16) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' description=';
		nextPutAll: ((x := array at: 17) isNil ifTrue: [''] ifFalse: [x]) printString;
		nextPutAll: ' objects=';
		nextPutAll: ((x := array at: 18) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' pages=';
		nextPutAll: ((x := array at: 19) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' voteState=';
		nextPutAll: ((x := array at: 20) isNil ifTrue: [''] ifFalse: [x printString]) printString;
		nextPutAll: ' />';
		yourself.

%

category: 'category'
method: JadeServer
addUser: aUserProfile toStream: aStream

	(self oopOf: aUserProfile) printOn: aStream.
	aStream tab; nextPutAll: aUserProfile userId.
	aStream tab; nextPutAll: (aUserProfile lastLoginTime asStringUsingFormat: #(1 2 3 $  2 1 $: true true true false)).
	aStream tab. aUserProfile loginsAllowedBeforeExpiration printOn: aStream.
	aStream tab. aUserProfile isDisabled printOn: aStream.
	aStream tab. aUserProfile activeUserIdLimit printOn: aStream.
	aStream tab.	"; nextPutAll: aUserProfile nativeLanguage asString."
	aStream tab. aUserProfile reasonForDisabledAccount printOn: aStream.
	aStream tab; nextPutAll: (aUserProfile lastPasswordChange asStringUsingFormat: #(1 2 3 $  2 1 $: true true true false)).
	aStream tab. aUserProfile passwordNeverExpires printOn: aStream.
	aStream lf.

%

category: 'category'
method: JadeServer
allGroups

	| allGroups myGroups stream |
	allGroups := AllGroups keys asSortedCollection.
	myGroups := (AllUsers userWithId: 'GcUser') groups.
	stream := WriteStream on: String new.
	allGroups do: [:each | 
		stream nextPutAll: each; tab.
		(myGroups includes: each) printOn: stream.
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
allSessions

	| list stream |
	stream := WriteStream on: String new.
	stream nextPutAll: '<?xml version=''1.0'' ?><sessions>'.
	list := System currentSessionNames subStrings: Character lf.
	list := list reject: [:each | each isEmpty].
	list := list collect: [:each | (each subStrings at: 3) asNumber].
	list do: [:each | 
		self
			addSessionWithId: each
			toStream: stream.
	].
	^stream 
		nextPutAll: '</sessions>';
		contents.

%

category: 'category'
method: JadeServer
allUsersPasswordLimits

	| stream |
	stream := WriteStream on: String new.
	AllUsers disallowUsedPasswords printOn: stream. stream tab.
	AllUsers minPasswordSize printOn: stream. stream tab.
	AllUsers maxPasswordSize printOn: stream. stream tab.
	AllUsers maxRepeatingChars printOn: stream. stream tab.
	AllUsers maxConsecutiveChars printOn: stream. stream tab.
	AllUsers maxCharsOfSameType printOn: stream. stream tab.
	AllUsers staleAccountAgeLimit printOn: stream. stream tab.
	AllUsers passwordAgeLimit printOn: stream. stream lf.
	AllUsers disallowedPasswords do: [:each | 
		stream nextPutAll: each; tab.
	].
	stream lf. AllUsers passwordAgeWarning printOn: stream. stream lf.
	^stream contents.

%

category: 'category'
method: JadeServer
asAsciiString: aString

	^String withAll: (aString asArray collect: [:char | 
		((32 <= char asciiValue and: [char asciiValue <= 127]) or: [char isSeparator])
			ifTrue: [char]
			ifFalse: [$?].
	]).

%

category: 'category'
method: JadeServer
assignClass: aClass toCategory: aString

	aClass thisClass category: aString.

%

category: 'category'
method: JadeServer
asString: anObject

	(anObject isKindOf: String) ifTrue: [^anObject].
	Exception
		category: nil
		number: nil
		do: [:ex :cat :num :args | 
			^'<<printString error: ' , ex printString , '>>'.
		].
	^anObject printString.

%

category: 'category'
method: JadeServer
authorInitials: aString

	| packagePolicy |
	(packagePolicy := self gsPackagePolicy) isNil ifTrue: [^self].
	packagePolicy authorInitials: aString.

%

category: 'jadeite'
method: JadeServer
autoCommitIfRequired
	| commitResult |
	Rowan serviceClass autoCommit == true ifTrue:[
		commitResult := System commitTransaction.
		RowanAutoCommitService new autoCommit:  
			(commitResult 
				ifTrue:[true] 
				ifFalse:[#failed])].
%

category: 'category'
method: JadeServer
beginTransaction

	classOrganizers := Array new: 4.
	System beginTransaction.

%

category: 'category'
method: JadeServer
behaviorFor: selector in: aClass

	| behavior |
	behavior := aClass.
	[
		behavior notNil.
	] whileTrue: [
		(behavior includesSelector: selector) ifTrue: [^behavior].
		behavior := behavior superclass.
	].
	self error: 'Method not found in class or in any superclass'.

%

category: 'category'
method: JadeServer
categoryListFor: aSymbolDictionary

	| categories stream |
	categories := Set new.
	aSymbolDictionary do: [:each | 
		each isBehavior ifTrue: [
			categories add: each category.
		].
	].
	categories copy do: [:each | 
		1 to: each size do: [:i | 
			(each at: i) = $- ifTrue: [
				| string |
				string := each copyFrom: 1 to: i - 1.
				(categories includes: string) ifFalse: [
					categories add: string.
					self _addToPureExportSet: string.
				].
			].
		].
	].
	stream := WriteStream on: String new.
	categories asSortedCollection do: [:each | 
		(self oopOf: each) printOn: stream.
		stream tab; nextPutAll: each; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
categoryOfMethod: aMethod

	| selector |
	(selector := aMethod selector) isNil ifTrue: [^''].
	^self _behavior: aMethod inClass categoryOfSelector: selector.

%

category: 'category'
method: JadeServer
class: aClass includesSelector: aSelector

	^aClass includesSelector: aSelector asSymbol.

%

category: 'category'
method: JadeServer
classesForUser: aUserProfile

	| stream |
	stream := WriteStream on: String new.
	aUserProfile symbolList do: [:eachDict |
		eachDict keysAndValuesDo: [:key :value |
			value isBehavior ifTrue: [
				stream nextPutAll: key; space; nextPutAll: value category asString; tab.
			].
		].
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
classListFor: aDictionary category: aString

	| visibleClasses allClasses stream queue |
	visibleClasses := aDictionary asArray select: [:each | 
		each isBehavior and: [aString isNil or: [
			| category |
			(category := each category) notNil and: [
			category = aString or: [
			category matchPattern: (Array with: aString with: $*)]]]]].
	allClasses := visibleClasses asIdentitySet.
	queue := visibleClasses asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| parent |
		parent := queue removeFirst superclass.
		(parent notNil and: [(allClasses includes: parent) not]) ifTrue: [
			queue add: parent.
			allClasses add: parent.
		].
	].
	stream := WriteStream on: String new.
	allClasses do: [:each |
		self
			_addClass: each 
			toStream: stream 
			isVisible: (visibleClasses includes: each)
			fromDictionary: aDictionary.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
classOrganizer

	^ClassOrganizer new

%

category: 'category'
method: JadeServer
clearBreakAtStepPoint: anInteger inMethod: aGsMethod

	aGsMethod clearBreakAtStepPoint: anInteger.

%

category: 'category'
method: JadeServer
commentFor: aClass

	| description |
	(Class canUnderstand: #'classComment') ifTrue: [
		^aClass classComment.
	].
	(description := aClass description) isNil ifTrue: [^nil].
	(description class name = #'GsClassDocumentation') ifTrue: [^description detailsAboutClass].
	^description printString.

%

category: 'category'
method: JadeServer
commit

	classOrganizers := Array new: 4.
	^System commitTransaction.

%

category: 'category'
method: JadeServer
compile: aString frame: anInteger process: aGsProcess
	"Compile method from within debugger"

	| oldMethod aBehavior selector category result |
	oldMethod := aGsProcess localMethodAt: anInteger.
	result := self recompile: oldMethod withSource: aString.
	(result isKindOf: Boolean) ifTrue: [^result].
	aBehavior := oldMethod inClass.
	selector := oldMethod selector.
	selector isNil ifTrue: [^result].
	category := self _behavior: aBehavior categoryOfSelector: selector.
	result := [[ aBehavior rwCompileMethod: aString category: category ]
							on: RwExecuteClassInitializeMethodsAfterLoadNotification
							do: [:ex | ex resume: false ]] 
								on: RwPerformingUnpackagedEditNotification
								do: [:ex | ex resume ].

					
	^result
%

category: 'category'
method: JadeServer
compiledMethodAt: aSymbol inClass: aClass

	^aClass compiledMethodAt: aSymbol.

%

category: 'category'
method: JadeServer
compileMethod: methodString behavior: aBehavior symbolList: aSymbolList inCategory: categorySymbol
	"Returns aGsNMethod (if successful) -> anArrayOfErrorsOrWarnings"

	| result |
	"Method is in GsFoundation, but not in GsBase"
	result := (aBehavior class canUnderstand: #'compileMethod:category:using:environmentId:') ifTrue: [
		[
			aBehavior		"returns self or signals a CompileError"
				compileMethod: methodString
				category: categorySymbol
				using: aSymbolList
				environmentId: 0.
			nil.
		] on: (self objectInBaseNamed: #'UndefinedSymbolNotification') do: [:ex | 
			ex resume: false.
		].
	] ifFalse: [(aBehavior class canUnderstand: #'compileMethod:category:using:') ifTrue: [
		[
			aBehavior		"returns self or signals a CompileError"
				compileMethod: methodString
				category: categorySymbol
				using: aSymbolList.
			nil.
		] on: (self objectInBaseNamed: #'UndefinedSymbolNotification') do: [:ex | 
			ex resume: false.
		].
	] ifFalse: [
		aBehavior		"returns nil or an Array of error descriptions"
			compileMethod: methodString
			dictionaries: aSymbolList
			category: categorySymbol.
	]].
	result notNil ifTrue: [
		^nil -> result.
	].
	(aBehavior class canUnderstand: #_primitiveCompileMethod:symbolList:category:oldLitVars:intoMethodDict:intoCategories:intoPragmas:) ifTrue: [
		result := aBehavior 
			_primitiveCompileMethod: methodString
			symbolList: aSymbolList
			category: categorySymbol
			oldLitVars: nil
			intoMethodDict: GsMethodDictionary new 
			intoCategories: GsMethodDictionary new
			intoPragmas: nil.
	] ifFalse: [
		(aBehavior class canUnderstand: #_primitiveCompileMethod:symbolList:category:obsoleteClassNames:oldLitVars:) ifTrue: [
			result := aBehavior 
				_primitiveCompileMethod: methodString
				symbolList: aSymbolList
				category: categorySymbol
				obsoleteClassNames: nil
				oldLitVars: nil.
		] ifFalse: [
			result := aBehavior 
				_primitiveCompileMethod: methodString
				symbolList: aSymbolList
				category: categorySymbol
				oldLitVars: nil
				intoMethodDict: GsMethodDictionary new 
				intoCategories: GsMethodDictionary new.
		].
	].
	(result isKindOf: Array) ifTrue: [
		"in 2.3.x: (Array with: compiledMethod with: errors with: warnings)"
		(result at: 2) notNil ifTrue: [^nil -> (result at: 2)].
		^(result at: 1) -> (result at: 3)
	].
	^result -> nil.

%

category: 'category'
method: JadeServer
compileMethod: methodString behavior: aBehavior user: aUserProfileOrNil inCategory: categoryString
	"answers a String:
		OOP of new method <TAB> selector of new method (or empty if compile failed)
		ERROR: [details] (repeat line for each error)
		[warnings] (if no errors)"

	| userProfile result gsMethod stream errDict errorList warnings |

	userProfile := aUserProfileOrNil isNil
		ifTrue: [System myUserProfile]
		ifFalse: [aUserProfileOrNil].
	result := self 		"key: GsNMethod value: ((Array withAll: errors) or aStringOfWarnings)"
		compileMethod: methodString 
		behavior: aBehavior 
		symbolList: userProfile symbolList 
		inCategory: categoryString asSymbol.
	(gsMethod := result key) isNil ifTrue: [
		errorList := result value.
		warnings := ''.
	] ifFalse: [
		errorList := #().
		warnings := result value.
	].
	stream := WriteStream on: String new.
	gsMethod notNil ifTrue: [
		stream 
			nextPutAll: gsMethod asOop printString;
			tab;
			nextPutAll: gsMethod selector;
			yourself.
	].
	errDict := GemStoneError at: System myUserProfile nativeLanguage.
	errorList do: [:each |
		stream lf; 
			nextPutAll: 'ERROR:'; tab;
			nextPutAll: (each at: 1) printString; tab;
			nextPutAll: (each at: 2) printString; tab;
			yourself.
		(each size >= 3 and: [(each at: 3) notNil]) ifTrue: [
			stream nextPutAll: (each at: 3); tab.
		] ifFalse: [
			(each at: 1) > errDict size ifTrue: [
				stream nextPutAll: '(unknown error number)'; tab.
			] ifFalse: [
				stream nextPutAll: (errDict at: (each at: 1)) asString; tab.
			].
		].
	].
	warnings isNil ifTrue: [warnings := ''].
	stream lf; nextPutAll: warnings.
	^stream contents.

%

category: 'category'
method: JadeServer
contents
	"WriteStream method to identify things that have not yet been flushed to the output. We have flushed everything!"

	^''.

%

category: 'category'
method: JadeServer
cr

	self nextPut: Character cr.

%

category: 'category'
method: JadeServer
currentUserMayEditMethod: aMethod

	^true
%

category: 'category'
method: JadeServer
debugString: aString fromContext: anObject environment: anInteger
	anInteger == 0 ifFalse: [self error: 'Only environment 0 is supported in this version!'].
	^(RowanDebuggerService new debugStringFrom: aString)
		evaluateInContext: anObject 
		symbolList: GsSession currentSession symbolList.
%

category: 'category'
method: JadeServer
debugTestNamed: testName of: testCaseClassName
	"Open a Debugger for the TestCase class named <testCaseClassName> in the test named <testName>"

	^(self objectNamed: testCaseClassName) debug: testName asSymbol
%

category: 'category'
method: JadeServer
defectiveTestsIn: aClass

	| testClass results stream |
	testClass := aClass thisClass.
	results := testClass suite run.
	stream := WriteStream on: String new.
	stream nextPutAll: results printString; lf.
	results defects asSet do: [:each | 
		| selector class |
		selector := each selector asSymbol.
		class := each class whichClassIncludesSelector: selector.
		stream nextPutAll: class name , ' debug: ' , each selector printString; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
definitionOfClass: aClass
	^aClass definition.
%

category: 'category'
method: JadeServer
definitionOfClass: aClass forUser: aUserProfile

			| stream |
			stream := WriteStream on: String new.
"1"		aClass superclass printOn: stream.
			stream 
"2"			lf; nextPutAll: (self subclassSelectorForClass: aClass);
"3"			lf; nextPutAll: aClass name;
"4"			lf; nextPutAll: (self dictionaryForClass: aClass forUser: aUserProfile);
				yourself.
"5"		stream lf. aClass instancesInvariant printOn: stream.
"6"		stream lf. aClass isModifiable printOn: stream.
"7"		stream lf. ((aClass class canUnderstand: #'instancesDbTransient') and: [aClass instancesDbTransient]) printOn: stream.
"8"		stream lf. ((aClass class canUnderstand: #'instancesNonPersistent') and: [aClass instancesNonPersistent]) printOn: stream.
			stream lf.
		aClass instVarNames do: [:each |
				stream 
"9.*.1"		nextPutAll: each; 
					space;
"9.*.2"		nextPutAll: (aClass constraintOfInstVar: each) name;
					tab.
			].
			stream lf.
			aClass class instVarNames do: [:each | 
"10.*"		stream nextPutAll: each; tab.
			].
			stream lf.
			aClass classVarNames asSortedCollection do: [:each | 
"11.*"		stream nextPutAll: each; tab.
			].
			stream lf.
			aClass sharedPools asSortedCollection do: [:each | 
"12.*"		stream nextPutAll: (self nameForSharedPool: each forUser: aUserProfile); tab.
			].
			^stream 
"13"		lf; nextPutAll: aClass userId;
"14"		lf; nextPutAll: (aClass timeStamp asStringUsingFormat: #(3 2 1 $- 1 1 $: true true false));
				lf; 
				contents.

%

category: 'category'
method: JadeServer
delay

	(Delay forMilliseconds: 10) wait.

%

category: 'category'
method: JadeServer
describeMethod: aMethod
	"Provide info needed to create a GsMethod in Jade client"

	writeStream := WriteStream on: String new.
	self _describeMethod: (self homeMethodFor: aMethod).
	^writeStream contents

%

category: 'category'
method: JadeServer
descriptionOfConfigOption: aString

	| dict key string |
	dict := self systemConfigAsDictionary.
	(string := dict at: aString ifAbsent: [nil]) notNil ifTrue: [^string].	string := aString asUppercase.
	dict keys do: [:each1 | 
		key := (each1 reject: [:each2 | each2 = $_]) asUppercase.
		key = string ifTrue: [^dict at: each1].
	].
	^''
%

category: 'category'
method: JadeServer
descriptionOfErrorNumber: anInteger

	| array stream |
	array := GemStoneError at: #'English'.
	anInteger <= 0 ifTrue: [^'Invalid number!'].
	array size < anInteger ifTrue: [^'Invalid number!'].
	stream := WriteStream on: String new.
	array := array at: anInteger.
	array isNil ifTrue: [^'No entry in GemStoneError for #' , anInteger printString , '!'].
	(array isKindOf: String) ifTrue: [array := Array with: array].
	array do: [:each | 
		(each isKindOf: Integer) ifTrue: [
			stream space; nextPut: $%.
			each printOn: stream.
		] ifFalse: [
			stream nextPutAll: each.
		].
	].
	^stream contents.

%

category: 'category'
method: JadeServer
dictionaryAndSymbolOf: aClass

	^self symbolList dictionaryAndSymbolOf: aClass.

%

category: 'category'
method: JadeServer
dictionaryAndSymbolOf: aClass forUser: aUserProfile

	^aUserProfile symbolList dictionaryAndSymbolOf: aClass.

%

category: 'category'
method: JadeServer
dictionaryForClass: aClass forUser: aUserProfile

	| anArray |
	anArray := self dictionaryAndSymbolOf: aClass forUser: aUserProfile.
	anArray isNil ifTrue: [^''].
	anArray := self dictionaryAndSymbolOf: (anArray at: 1) forUser: aUserProfile.
	anArray isNil ifTrue: [^''].
	^(anArray at: 2)

%

category: 'category'
method: JadeServer
dictionaryListFor: aUserProfile

	| symbolList list stream |
	symbolList := aUserProfile symbolList.
	list := symbolList namesReport subStrings: Character lf.
	list := list reject: [:each | each isEmpty].
	list := list collect: [:each | each subStrings].
	stream := WriteStream on: String new.
	list do: [:each | 
		(self oopOf: (symbolList at: (each at: 1) asNumber)) printOn: stream.
		stream tab; nextPutAll: (each at: 2); lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
does: newClass replace: oldClass

	^newClass name = oldClass name.

%

category: 'category'
method: JadeServer
environment
	"Ignored prior to 3.x"

	^0
%

category: 'category'
method: JadeServer
environment: anInteger
	"Ignored prior to 3.x"
%

category: 'category'
method: JadeServer
environmentForMethod: aGsNMethod

	^0
%

category: 'category'
method: JadeServer
environmentSuperClassFor: aBehavior

	^aBehavior superclass
%

category: 'category'
method: JadeServer
errorListFor: aCollection

	| stream |
	aCollection class name == #'ErrorDescription' ifTrue: [^''].
	stream := WriteStream on: String new.
	aCollection do: [:each | 
		stream
			nextPutAll: (each at: 1) printString; tab;
			nextPutAll: (each at: 2) printString; tab;
			nextPutAll: ((2 < each size and: [(each at: 3) notNil]) ifTrue: [(each at: 3)] ifFalse: [(GemStoneError at: #English) at: (each at: 1)]); tab;
			lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
executeString: aString fromContext: anObject environment: anInteger

	anInteger == 0 ifFalse: [self error: 'Only environment 0 is supported in this version!'].
	^aString
		evaluateInContext: anObject 
		symbolList: GsSession currentSession symbolList. 
%

category: 'category'
method: JadeServer
fileInClass: aString

	| list className index dictionaryName dictionary oldClass oldString |
	list := aString subStrings.
	className := list at: 3.
	className first = $' ifFalse: [self error: 'Class name ' , className printString , ' expected to begin and end with a quote!'].
	className last = $' ifFalse: [self error: 'Class name ' , className printString , ' expected to begin and end with a quote!'].
	className := className copyFrom: 2 to: className size - 1.
	index := list indexOf: 'inDictionary:'.
	dictionaryName := list at: index + 1.
	dictionary := self objectNamed: dictionaryName.
	oldClass := dictionary at: className ifAbsent: [nil].
	oldClass notNil ifTrue: [
		oldString := (oldClass _modifiableDefinitionInDictionary: dictionary named: dictionaryName) , '.'.
	].
	oldString = aString ifFalse: [aString evaluate].

%

category: 'category'
method: JadeServer
fileOutForClass: aClass

	^aClass thisClass fileOutClass.
 
%

category: 'category'
method: JadeServer
gemLogPath

	^''

%

category: 'category'
method: JadeServer
getMethodsNamesOf: classNamed
	"NO SENDERS"
	"Answer a collection with selectors of GemStone/s class name <className>"

	^(self objectNamed: classNamed) selectors asSortedCollection

%

category: 'category'
method: JadeServer
getPackagesNamesOfAll: classesNameCollection
	"NO SENDERS"
	"Answer aDictionary where each key is a class name and the value is the package that own the class"
	| classesPackages |

	classesPackages := Dictionary new.

	classesNameCollection do: [:eachClassName | | packageName |
		packageName := self getPackageNameOf: eachClassName.
		classesPackages at: eachClassName put: packageName].

	^classesPackages
%

category: 'category'
method: JadeServer
getPackagesNamesWithTestClasses
	"Answer a collection with all package names that contain at least one Test class (subclass of TestCase)"

	| comma packageOrganizer packageOrganizerClass packagesNames stream testCaseClass |
	testCaseClass := self objectInBaseNamed: #'TestCase'.
	testCaseClass isNil ifTrue: [^''].
	packageOrganizerClass := self objectInBaseNamed: #'PackageOrganizer'.
	packageOrganizerClass isNil ifTrue: [^'<All>'].
	packageOrganizer := packageOrganizerClass default.
	packagesNames := Set new.
	testCaseClass allSubclasses do: [:each | 
		| package |
		package := packageOrganizer packageOfClass: each ifNone: [nil].
		package notNil ifTrue: [packagesNames add: package packageName].
	].
	comma := ''.
	stream := WriteStream on: String new.
	packagesNames asSortedCollection do: [:each | stream nextPutAll: comma; nextPutAll: each. comma := ','].
	^stream contents
%

category: 'category'
method: JadeServer
getSubclassesNamesOf: classNamed 
	"NO SENDERS"
	"Answer a collection with all subclasses of GemStone/S class named <classNamed>"

	^((self objectNamed: classNamed) allSubclasses collect: [:each | each name]) asSortedCollection
%

category: 'category'
method: JadeServer
getTestCaseClassesNamesOf: packageName
	"Answer a collection with all test classes of the GemStone/S package named <packageNamed>"

	| classes comma stream |
	packageName isEmpty ifTrue: [^''].
	classes := (self objectInBaseNamed: #'TestCase') allSubclasses.
	packageName = '<All>' ifFalse: [
		| packageInfo packageOrganizer |
		packageOrganizer := (self objectInBaseNamed: #'PackageOrganizer') default.
		packageInfo := packageOrganizer packageNamed: packageName ifAbsent: [^''].
		packageInfo classes isEmpty ifTrue: [^''].
		classes := packageInfo classes select: [:each | classes includes: each].
	].
	stream := WriteStream on: String new.
	comma := ''.
	classes do: [:each | stream nextPutAll: comma; nextPutAll: each name. comma := ','].
	^stream contents
%

category: 'category'
method: JadeServer
getTestMethodsNamesOf: classNamed 
	"Answer a collection with all test selectors of the GemStone/S class named <classNamed>"

	| class comma stream testSelectors gsClass |
	stream := WriteStream on: String new.
	gsClass := self objectNamed: classNamed.
	gsClass isNil ifTrue: [^''].
	(class := self objectNamed: #'TestCase') isNil ifTrue: [^''].
	(gsClass isSubclassOf: class) ifFalse: [^''].
	testSelectors :=  gsClass testSelectors asSortedCollection.
	testSelectors isEmpty ifTrue: [^''].
	comma := ''.
	 testSelectors do: [:each | stream nextPutAll: comma; nextPutAll: each. comma := ','].
	^stream contents
%

category: 'category'
method: JadeServer
globalsFor: aSymbolDictionary

	| stream |
	stream := WriteStream on: String new.
	aSymbolDictionary keysAndValuesDo: [:eachKey :eachValue | 
		eachValue isBehavior ifFalse: [
			| data |
			data := (self _oopAndStringFor: eachValue) value.
			data size > 200 ifTrue: [data := data copyFrom: 1 to: 200].
			data := String withAll: (data asArray collect: [:each | (each >= Character space and: [each <= $~]) ifTrue: [each] ifFalse: [$?]]).
			stream
	"1"		nextPutAll: (self oopOf: eachValue) printString; tab;
	"2"		nextPutAll: eachKey; tab;
	"3"		nextPutAll: eachValue class name; tab;
	"4"		nextPutAll: data; tab;
				lf;
				yourself.
		].
	].
	^stream contents.

%

category: 'category'
method: JadeServer
groupListFor: aUserProfile

	| allGroups myGroups stream |
	allGroups := AllGroups keys asSortedCollection.
	myGroups := aUserProfile groups.
	stream := WriteStream on: String new.
	allGroups do: [:each | 
		stream nextPutAll: each; tab.
		(myGroups includes: each) printOn: stream.
		stream lf.
	].
	^stream contents.

%

category: 'jadeite'
method: JadeServer
gsInteractionInformFailureHandler
  self interactionHandlerActive
    ifFalse: [ 
      ^ GsInteractionHandler new
        defaultBlock: [ :ignored | self assert: false description: 'expected a confirmation' ];
        confirmBlock: [ :interaction | interaction ok ];
        informBlock: [ :interaction |  ];
        inspectBlock: [ :interaction |  ];
        yourself ].
  ^ GsInteractionHandler new
    confirmBlock: [ :interaction | 
          | exception answer |
          exception := ClientForwarderSend new
            receiver: self
            clientObj: 1
            selector: #'confirmMessageBox:'
            args: (Array with: interaction prompt).
          answer := exception defaultAction.	"expect printString of answer back. Jadeite has limited ability to convert client objects to oops"
          answer evaluate ];
    informBlock: [ :interaction | 
          | exception |
          exception := ClientForwarderSend new
            receiver: self
            clientObj: 1
            selector: #'informMessageBox:'
            args: (Array with: interaction message).
          exception defaultAction.
          nil ];
    inspectBlock: [ :interaction | 
          | exception |
          exception := ClientForwarderSend new
            receiver: self
            clientObj: 1
            selector: #'inspectServerObject:'
            args: (Array with: interaction theObject asOop).
          exception defaultAction.
          interaction theObject ]
%

category: 'category'
method: JadeServer
gsPackagePolicy

	| class |
	class := self gsPackagePolicyClass.
	class isNil ifTrue: [^nil].
	^class current.

%

category: 'category'
method: JadeServer
gsPackagePolicyClass

	^self objectInBaseNamed: #'GsPackagePolicy'.

%

category: 'category'
method: JadeServer
historyOf: aClass

	| history |
	(history := aClass classHistory) isNil ifTrue: [
		history := Array with: aClass.
	].
	^history.

%

category: 'category'
method: JadeServer
homeMethodFor: aGsMethod

	^aGsMethod
%

category: 'category'
method: JadeServer
implementorsOf: anObject

	| symbol |
	symbol := (anObject isKindOf: String)
		ifTrue: [anObject asSymbol]
		ifFalse: [anObject selector].
	^self streamOfMethods: (self classOrganizer implementorsOf: symbol).

%

category: 'category'
method: JadeServer
implementorsOf: aGsMethod startingAt: aClass

	| selector myClass list |
	selector := aGsMethod selector.
	myClass := aClass.
	list := OrderedCollection new.
	[
		(myClass includesSelector: selector) ifTrue: [list add: myClass].
		(myClass := myClass superclass) notNil.
	] whileTrue: [].
	^self stringForClassList: list.

%

category: 'category'
method: JadeServer
initialize
	"#installTranscript is run from the Jadeite
	client post login method only. This avoids
	setting up ClientForwarder sends in a topaz
	session"

	classOrganizers := Array new: 4.
	self 
		registerOBNotifications;
		yourself.
%

category: 'category'
method: JadeServer
inspect: anObject

	| stream string |
	(stream := WriteStream on: String new)
		nextPutAll: anObject class name; tab;
		yourself.
	(self oopOf: anObject) printOn: stream.
	stream lf.
	(anObject isKindOf: Dictionary superclass) ifTrue: [^self inspectDictionary: anObject on: stream].
	self inspectNamedInstanceVariablesOf: anObject on: stream.
	anObject class format > 0 ifTrue: [
		1 to: (anObject _basicSize min: 200) do: [:i | 
			i printOn: stream.
			stream tab.
			self print: (self oopOf: (anObject _at: i)) on: stream.
			stream lf.
		].
	].
	(string := anObject printString) size > 5000 ifTrue: [string := (string copyFrom: 1 to: 5000) , '...'].
	string class == String ifFalse: [
		string := String withAll: (string collect: [:each | (32 <= each asciiValue and: [each asciiValue <= 255]) ifTrue: [each] ifFalse: [$?]]).
	].
	^stream 
		nextPutAll: string; 
		contents.
%

category: 'category'
method: JadeServer
inspectDictionary: aDictionary on: aStream

	| keys keyDict |
	keys := self keysForDictionary: aDictionary.
	keyDict := Dictionary new.
	keys do: [:each | 
		| key |
		key := each printString , '~' , (self oopOf: each) printString.
		key := key collect: [:char | char asciiValue < 32 ifTrue: [$?] ifFalse: [char]].
		keyDict
			at: key
			put: each.
	].
	keys size printOn: aStream.
	aStream lf.
	keyDict keys asSortedCollection do: [:each | 
		| index keyString key value valueString |
		index := each findLast: [:char | char = $~].
		keyString := each copyFrom: 1 to: index - 1.
		keyString charSize = 1 ifFalse:[
			keyString := '<<unprintable key. charSize > 1>>']. 
		key := keyDict at: each.
		value := aDictionary at: key. 
		valueString := (self printStringOf: value to: 10).
		valueString charSize = 1 ifFalse:[
			valueString := '<<unprintable value. charSize > 1>>']. 
		aStream nextPutAll: keyString , '->' , valueString; tab.
		self print: (self oopOf: value) on: aStream.
		aStream lf.
	].
	^aStream 
		lf; 
		contents.
%

category: 'category'
method: JadeServer
inspectNamedInstanceVariablesOf: anObject on: aStream

	| list size |
	list := anObject class allInstVarNames.
	size := list size.
	anObject class format > 0 ifTrue: [
		size := size + (anObject _basicSize min: 200).
	].
	size printOn: aStream.
	aStream lf.
	1 to: list size do: [:i | 
		aStream nextPutAll: (list at: i); tab.
		self print: (self oopOf: (anObject instVarAt: i)) on: aStream.
		aStream lf.
	].

%

category: 'category'
method: JadeServer
installTranscript

	| transcript |
	transcript := self objectInBaseNamed: #'Transcript'.

	"If no Transcript object, then install me!"
	(transcript == nil or: [transcript class name == self class name]) ifTrue: [
		UserGlobals at: #'Transcript' put: self.
		System commitTransaction.
		^self.
	].
	
	"Transcript object from Seaside"
	transcript class name = 'TranscriptProxy class' ifTrue: [
		| clientForwarder |
		clientForwarder := ClientForwarder new.
		clientForwarder	clientObject: 2.
		transcript registerTranscriptClientForwarder: clientForwarder.
		^self.
	].

%

category: 'jadeite'
method: JadeServer
interactionHandlerActive
  ^ SessionTemps current at: #'rowanServiceInteractionActive' ifAbsent: [ true ]
%

category: 'category'
method: JadeServer
is32Bit

	^false.

%

category: 'category'
method: JadeServer
isClientForwarder: anObject

	^anObject _class name == #'ClientForwarder'.

%

category: 'category'
method: JadeServer
isPackagePolicyEnabled

	^self gsPackagePolicy notNil
%

category: 'category'
method: JadeServer
isResumableCategory: category number: number context: context

	| exceptionA receiver |
	category == GemStoneError ifTrue: [
		^number // 1000 = 2 or: [number // 1000 = 6].
	].
	(exceptionA := Globals at: #ExceptionA ifAbsent: [nil]) isNil ifTrue: [
		^true.
	].
	receiver := (context _frameContentsAt: 1) at: 8.
	(receiver isKindOf: exceptionA) ifTrue: [
		^receiver isResumable.
	].
	^true.

%

category: 'category'
method: JadeServer
keysForDictionary: aDictionary 

	^aDictionary keys.

%

category: 'category'
method: JadeServer
makeListener

	^nil.

%

category: 'category'
method: JadeServer
mcAddHttpRepository: aString

	| list repositoryClass repository group |
	list := aString subStrings: (Character codePoint: 255).
	(repositoryClass := self mcHttpRepositoryClass) isNil ifTrue: [self error: 'MCHttpRepository not found!'].
	repository := repositoryClass
		location: (list at: 1)
		user: (list at: 2)
		password: (list at: 3).
	(group := self mcRepositoryGroup) isNil ifTrue: [self error: 'MCRepositoryGroup not found!'].
	group addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcAddPackage: aString

	self mcWorkingCopyClass forPackage: (self mcPackageClass named: aString).

%

category: 'category'
method: JadeServer
mcAddRepository: aRepository toPackage: aMCWorkingCopy

	aMCWorkingCopy repositoryGroup addRepository: aRepository.

%

category: 'category'
method: JadeServer
mcAllFileNamesIn: anMCRepository

	| stream |
	stream := WriteStream on: String new.
	anMCRepository allFileNames do: [:each | 
		stream nextPutAll: each; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcAllVersionInfoNamesIn: anMCRepository

	| stream |
	stream := WriteStream on: String new.
	anMCRepository allVersionInfos do: [:each | 
		stream nextPutAll: each name; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcAllVersionNamesInDict: anMCRepository

	| stream list |
	stream := WriteStream on: String new.
	list := anMCRepository dictionary values.
	list := list asSortedCollection: [:a :b | 
		a package name < b package name or: [
		a package name = b package name and: [
		a info date > b info date or: [
		a info date = b info date and: [
		a info time > b info time
	]]]]].
	stream := WriteStream on: String new.
	list do: [:each | 
		stream nextPutAll: each info name; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcClassesInCategory: aString package: aMCWorkingCopy

	| visibleClasses allClasses stream queue |
	visibleClasses := aString isNil ifTrue: [
		aMCWorkingCopy packageInfo classes.
	] ifFalse: [
		aMCWorkingCopy packageInfo classes select: [:each | 
			each _classCategory notNil and: [
			each _classCategory = aString or: [
			aString notNil and: [each _classCategory matchPattern: (Array with: aString with: $*)]]]]
	].
	allClasses := visibleClasses asIdentitySet.
	queue := visibleClasses asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| parent |
		parent := queue removeFirst superclass.
		(parent notNil and: [(allClasses includes: parent) not]) ifTrue: [
			queue add: parent.
			allClasses add: parent.
		].
	].
	stream := WriteStream on: String new.
	allClasses do: [:each |
		self
			_addClass: each 
			toStream: stream 
			isVisible: (visibleClasses includes: each)
			fromDictionary: nil.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcCreationTemplateFor: anMCRepository

	^anMCRepository asCreationTemplate.

%

category: 'category'
method: JadeServer
mcHttpRepository

	^self objectInBaseNamed: #'MCHttpRepository'.

%

category: 'category'
method: JadeServer
mcHttpRepository: aRepository user: userString password: passwordString

	aRepository
		user: userString;
		password: passwordString;
		yourself.

%

category: 'category'
method: JadeServer
mcHttpRepositoryClass

	^self objectInBaseNamed: #'MCHttpRepository'.

%

category: 'category'
method: JadeServer
mcInitials: aString
	"Do initial setup and return useful information"

	| mcPlatformSupport packagePolicyEnabledFlag string x |
	string := 'Jade-' , GsSession currentSession serialNumber printString , '-' , System myUserProfile userId.
	[
		self mcInitialsA: string.
	] whileFalse: [	"Keep shortening it till it fits!"
		string := string copyFrom: 1 to: string size - 1.
	].
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	mcPlatformSupport notNil ifTrue: [mcPlatformSupport setAuthorInitials: aString].
	packagePolicyEnabledFlag := (x := self objectInBaseNamed: #'GsPackagePolicy') isNil ifTrue: ['0'] ifFalse: [x current enabled ifTrue: ['1'] ifFalse: ['0']].
	^System session printString , Character space asString , 
		(GsSession serialOfSession: System session) printString , Character space asString , 
		packagePolicyEnabledFlag

%

category: 'category'
method: JadeServer
mcInitialsA: aString
	"Subclasses provide error handling, typically means string is too long"

	System _cacheName: aString.

%

category: 'category'
method: JadeServer
mcLoadedVersionNames

	| mcWorkingCopyClass stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	stream := WriteStream on: String new.
	mcWorkingCopyClass allManagers do: [:each | 
		| packageOrVersion |
		packageOrVersion := each ancestors
			detect: [:ignored | true]
			ifNone: [each package].
		packageOrVersion := packageOrVersion notNil
			ifTrue: [packageOrVersion name]
			ifFalse: [''].
		stream
			nextPutAll: packageOrVersion; tab;
			nextPut: (each modified ifTrue: [$Y] ifFalse: [$N]); tab;
			nextPutAll: each package name;
			lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcNewDirectoryRepository: aString

	| mcRepositoryClass fileDirectoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCDirectoryRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	(fileDirectoryClass := self objectInBaseNamed: #'FileDirectory') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcNewFileTreeRepository: aString

	| mcRepositoryClass fileDirectoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCFileTreeRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	(fileDirectoryClass := self objectInBaseNamed: #'ServerFileDirectory') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcNewGitHubRepository: aString

	| mcRepositoryClass repository |
	(mcRepositoryClass := self objectInBaseNamed: #'MCGitHubRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcRepositoryClass location: aString.
	self mcRepositoryGroup addRepository: repository.
	^mcRepositoryClass
%

category: 'category'
method: JadeServer
mcNewServerDirectoryRepository: aString

	| mcDirectoryRepositoryClass fileDirectoryClass repository |
	(mcDirectoryRepositoryClass := self objectInBaseNamed: #'MCServerDirectoryRepository') isNil ifTrue: [self error: 'Monticello not available!'].
	(fileDirectoryClass := self objectInBaseNamed: #'ServerFileDirectory') isNil ifTrue: [self error: 'Monticello not available!'].
	repository := mcDirectoryRepositoryClass new directory: (fileDirectoryClass on: aString).
	self mcRepositoryGroup addRepository: repository.
	^repository
%

category: 'category'
method: JadeServer
mcPackageClass

	^self objectInBaseNamed: #'MCPackage'.

%

category: 'category'
method: JadeServer
mcPatchFrom: aString1 to: aString2 inDictionaryRepository: aDictionaryRepository

	| index name leftSnapshot rightSnapshot patch |
	index := aString2 findLast: [:each | each = $-].
	name := aString2 copyFrom: 1 to: index - 1.
	(name includes: $.) ifTrue: [name := (name subStrings: $.) first].
	leftSnapshot := aString1 isNil ifTrue: [
		(self mcWorkingCopyClass allManagers detect: [:each | each package name = name]) package snapshot.
	] ifFalse: [
		(aDictionaryRepository versionFromVersionNamed: aString1) snapshot.
	].
	rightSnapshot := (aDictionaryRepository versionFromVersionNamed: aString2) snapshot.
	patch := rightSnapshot patchRelativeToBase: leftSnapshot.
	^self 
		_mcDescriptionOfPatch: patch
		baseName: aString1
		alternateName: aString2.

%

category: 'category'
method: JadeServer
mcPatchFrom: aString1 to: aString2 inFileBasedRepository: aFileRepository

	| index name leftSnapshot rightSnapshot patch |
	index := aString2 findLast: [:each | each = $-].
	name := aString2 copyFrom: 1 to: index - 1.
	(name includes: $.) ifTrue: [name := (name subStrings: $.) first].
	leftSnapshot := aString1 isNil ifTrue: [
		(self mcWorkingCopyClass allManagers detect: [:each | each package name = name]) package snapshot.
	] ifFalse: [
		(aFileRepository versionFromFileNamed: aString1) snapshot.
	].
	rightSnapshot := (aFileRepository versionFromFileNamed: aString2) snapshot.
	patch := rightSnapshot patchRelativeToBase: leftSnapshot.
	^self 
		_mcDescriptionOfPatch: patch
		baseName: aString1
		alternateName: aString2.

%

category: 'category'
method: JadeServer
mcputDefinition: aDefinition on: aStream

	| mcOrganizationDefinitionClass mcClassDefinitionClass mcMethodDefinitionClass |
	(mcOrganizationDefinitionClass := self objectInBaseNamed: 'MCOrganizationDefinition') isNil ifTrue: [^nil].
	(mcClassDefinitionClass := self objectInBaseNamed: 'MCClassDefinitionClass') isNil ifTrue: [^nil].
	(mcMethodDefinitionClass := self objectInBaseNamed: 'MCMethodDefinition') isNil ifTrue: [^nil].

	self _addToPureExportSet: aDefinition.
		aStream nextPutAll: (self oopOf: aDefinition) printString; tab;
			nextPutAll: aDefinition class name; tab.
			
		aDefinition class == mcOrganizationDefinitionClass ifTrue: [
			aDefinition categories do: [:eachCategory | 
				aStream nextPutAll: eachCategory; space]
		] ifFalse: [	aDefinition class == mcClassDefinitionClass ifTrue: [
			aStream
				nextPutAll: aDefinition className; tab;
				nextPutAll: aDefinition superclassName; tab;
				nextPutAll: aDefinition category; tab;
				nextPutAll: aDefinition type; tab;
				yourself.
		] ifFalse: [aDefinition class == mcMethodDefinitionClass ifTrue: [
			aStream
				nextPutAll: aDefinition classIsMeta printString; tab;
				nextPutAll: aDefinition category; tab;
				nextPutAll: aDefinition selector; tab;
				nextPutAll: aDefinition className; tab;
				nextPutAll: aDefinition timeStamp printString; tab]]].
	
	^aStream.
	
%

category: 'category'
method: JadeServer
mcRemovePackage: anMCWorkingCopy

	anMCWorkingCopy unregister.

%

category: 'category'
method: JadeServer
mcRemoveRepository: aRepository

	| repositoryClass group |
	(repositoryClass := self mcHttpRepositoryClass) isNil ifTrue: [self error: 'MCHttpRepository not found!'].
	(group := self mcRepositoryGroup) isNil ifTrue: [self error: 'MCRepositoryGroup not found!'].
	group removeRepository: aRepository.

%

category: 'category'
method: JadeServer
mcRemoveRepository: aRepository toPackage: aMCWorkingCopy

	aMCWorkingCopy repositoryGroup removeRepository: aRepository.

%

category: 'category'
method: JadeServer
mcRepositoryFrom: aRepository

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aRepository) printOn: stream.
	stream 
		tab;
		nextPutAll: aRepository description;
		tab;
		nextPutAll: aRepository class name;
		tab.
	^stream contents.

%

category: 'category'
method: JadeServer
mcRepositoryGroup

	| groupClass |
	(groupClass := self objectInBaseNamed: 'MCRepositoryGroup') isNil ifTrue: [^nil].
	^groupClass default.

%

category: 'category'
method: JadeServer
mcRepositoryList

	| group stream |
	(group := self mcRepositoryGroup) isNil ifTrue: [^nil].
	stream := WriteStream on: String new.
	group repositories do: [:each | 
		stream nextPutAll: (self mcRepositoryFrom: each).
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
mcStore: aMCWorkingCopy name: nameString message: messageString repository: aRepository 

	| version |
	version := (aMCWorkingCopy needsSaving not and: [aMCWorkingCopy currentVersionInfo name = nameString]) ifTrue: [
		(self objectInBaseNamed: #'MCVersion')
			package: aMCWorkingCopy package
			info: aMCWorkingCopy currentVersionInfo.
	] ifFalse: [
		aMCWorkingCopy
			newVersionWithName: nameString
			message: messageString.
	].
	aRepository storeVersion: version.
	(self objectInBaseNamed: #'MCCacheRepository') default storeVersion: version.

%

category: 'category'
method: JadeServer
mcTopazFrom: aString inDictionaryRepository: aDictionaryRepository

	| snapshot stream |
	snapshot := (aDictionaryRepository versionFromVersionNamed: aString) snapshot.
	stream := (WriteStream on: String new)
		nextPutAll: '! ' , aString , ' in ' , aDictionaryRepository printString; lf;
		yourself.
	self
		_mcTopazFrom: snapshot
		on: stream.
	^stream contents.


%

category: 'category'
method: JadeServer
mcTopazFrom: aString inFileRepository: aFileRepository

	| snapshot stream |
	snapshot := (aFileRepository versionFromFileNamed: aString) snapshot.
	stream := (WriteStream on: String new)
		nextPutAll: '! ' , aString , ' in ' , aFileRepository printString; lf;
		yourself.
	self
		_mcTopazFrom: snapshot
		on: stream.
	^stream contents.


%

category: 'category'
method: JadeServer
mcUniqueVersionNameFor: anMCWorkingCopy

	^anMCWorkingCopy uniqueVersionName.

%

category: 'category'
method: JadeServer
mcUserAndPasswordInHTTP: anMCHttpRepository

	^anMCHttpRepository user , Character tab asString , anMCHttpRepository password.

%

category: 'category'
method: JadeServer
mcVersionInfoFrom: aVersionInfo

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aVersionInfo) printOn: stream.
	stream 
		lf; nextPutAll: aVersionInfo name; 
		lf; nextPutAll: aVersionInfo date yyyymmdd;
		lf.
	aVersionInfo time printOn: stream.
	stream 
		lf; nextPutAll: aVersionInfo author; 
		lf; nextPutAll: aVersionInfo id asString;
		lf.
	aVersionInfo ancestors do: [:each | 
		stream nextPutAll: each name; tab.
	].
	stream lf.
	aVersionInfo stepChildren do: [:each | 
		stream nextPutAll: each name; tab.
	].
	stream lf.
	stream nextPutAll: aVersionInfo message.
	^stream contents.

%

category: 'category'
method: JadeServer
mcVersionInfoFromDictionaryPackageNamed: aString in: anMCDictionaryRepository

	| versionInfo |
	(versionInfo := anMCDictionaryRepository versionInfoFromVersionNamed: aString) isNil ifTrue: [^''].
	^self mcVersionInfoFrom: versionInfo.

%

category: 'category'
method: JadeServer
mcVersionInfoFromFileNamed: aString in: anMCFileBasedRepository

	| versionInfo |
	(versionInfo := anMCFileBasedRepository versionInfoFromFileNamed: aString) isNil ifTrue: [^''].
	^self mcVersionInfoFrom: versionInfo.

%

category: 'category'
method: JadeServer
mcVersionLoad: aString fromDictionary: anMCDictionaryRepository autoMigrate: aBoolean

	| version package workingCopy mcPlatformSupport autoMigrate |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCDictionaryRepository versionFromVersionNamed: aString.
	version load.
	package := version package.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	workingCopy repositoryGroup addRepository: anMCDictionaryRepository.
	mcPlatformSupport autoMigrate: autoMigrate.

%

category: 'category'
method: JadeServer
mcVersionLoad: aString fromFile: anMCFileBasedRepository autoMigrate: aBoolean

	| version package workingCopy mcPlatformSupport autoMigrate |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCFileBasedRepository loadVersionFromFileNamed: aString.
	version load.
	package := version package.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	workingCopy repositoryGroup addRepository: anMCFileBasedRepository.
	mcPlatformSupport autoMigrate: autoMigrate.

%

category: 'category'
method: JadeServer
mcVersionMerge: aString from: anMCFileBasedRepository autoMigrate: aBoolean

	| version mcPlatformSupport autoMigrate workingCopy |
	mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport'.
	autoMigrate := mcPlatformSupport autoMigrate.
	mcPlatformSupport autoMigrate: aBoolean.
	version := anMCFileBasedRepository loadVersionFromFileNamed: aString.
	workingCopy := self mcWorkingCopyClass forPackage: version package.
	[
		[
			workingCopy merge: version.
		] on: (self objectInBaseNamed: #'MCNoChangesException') do: [:ex | 
			ex return.
		].
	] on: (self objectInBaseNamed: #'MCMergeResolutionRequest') do: [:ex | 
self halt.
		ex merger conflicts do: [:each | each chooseRemote].
		ex merger load.
		workingCopy 
			merged: version;
			modified: true;
			yourself.
		"ex resume: true."
		ex return.
	].


%

category: 'category'
method: JadeServer
mcVersionNameAndMessageFrom: aMCWorkingCopy

	(aMCWorkingCopy needsSaving or: [aMCWorkingCopy ancestors isEmpty]) ifTrue: [
		^'<new>	<new>'.
	].
	^aMCWorkingCopy currentVersionInfo name , Character tab asString , aMCWorkingCopy currentVersionInfo message.

%

category: 'category'
method: JadeServer
mcwcbWorkingCopies

	| mcWorkingCopyClass list stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	list := mcWorkingCopyClass allManagers.
	list := list asSortedCollection: [:a :b | a package name <= b package name].
	stream := WriteStream on: String new.
	list do: [:each |
		self saveWorkingCopy: each to: stream.
		stream lf].
	^stream contents
%

category: 'category'
method: JadeServer
mcWorkingCopyClass

	^self objectInBaseNamed: #'MCWorkingCopy'.

%

category: 'category'
method: JadeServer
mcWorkingCopyNamed: aString

	| mcWorkingCopyClass workingCopy stream |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^nil].
	workingCopy := mcWorkingCopyClass allManagers 
		detect: [:each | each package name = aString]
		ifNone: [^nil].
	stream := WriteStream on: String new.
	self 
		saveWorkingCopy: workingCopy 
		to: stream.
	^stream contents.

%

category: 'category'
method: JadeServer
methodsContaining: aString

	^self streamOfMethods: (self classOrganizer substringSearch: aString) first.

%

category: 'category'
method: JadeServer
methodsFor: childClass upTo: parentClass filter: aString isVariables: aBoolean 

	| filterList answerList aClass stream selectors |
	filterList := (aString subStrings: Character tab) reject: [:each | each isEmpty].
	aBoolean ifTrue: [filterList := (filterList collect: [:each | each asSymbol]) asIdentitySet].
	aClass := childClass.
	answerList := IdentitySet new.
	selectors := IdentitySet new.
	[
		| methods |
		methods := self 
			_methodsFor: aClass
			filter: filterList
			isVariables: aBoolean.
		methods do: [:each | 
			(selectors includes: each selector) ifFalse: [
				answerList add: each.
				selectors add: each selector.
			].
		].
		aClass = parentClass.
	] whileFalse: [
		aClass := aClass superclass.
	].
	stream := WriteStream on: String new.
	answerList do: [:each | self _addMethod: each toStream: stream].
	^stream contents
%

category: 'category'
method: JadeServer
methodSignatureForSelector: aSymbol

	^aSymbol.

%

category: 'category'
method: JadeServer
millisecondsElapsedTime: aBlock

	^Time millisecondsElapsedTime: aBlock.

%

category: 'category'
method: JadeServer
moveClassesInDictionary: sourceDictionary category: aString to: destinationDictionary

	sourceDictionary copy keysAndValuesDo: [:eachKey :eachValue | 
		(eachValue isBehavior and: [eachValue category = aString]) ifTrue: [
			sourceDictionary removeKey: eachKey.
			destinationDictionary
				at: eachKey
				put: eachValue.
		].
	].

%

category: 'category'
method: JadeServer
moveDictionary: source toBefore: target forUser: aUserProfile

	| list |
	list := aUserProfile symbolList.
	list remove: source.
	target notNil ifTrue: [
		list
			add: source 
			before: target.
	] ifFalse: [
		list addLast: source.
	].


%

category: 'category'
method: JadeServer
moveMethod: aGsMethod toCategory: aString
	aGsMethod inClass
		rwMoveMethod: aGsMethod selector
		toCategory: aString.

%

category: 'category'
method: JadeServer
mySessionInfo

	| dict stream |
	stream := WriteStream on: String new.
	stream nextPutAll: self gemLogPath; cr.
	dict := System gemVersionReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	dict := System gemConfigurationReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	^stream contents
%

category: 'category'
method: JadeServer
nameForSharedPool: anObject forUser: aUserProfile

	| anArray dict sharedPoolClass |
	anArray := self dictionaryAndSymbolOf: anObject forUser: aUserProfile.
	anArray notNil ifTrue: [^anArray at: 2].
	(dict := aUserProfile objectNamed: anObject name) isNil ifTrue: [^'???'].
	(sharedPoolClass := self objectNamed: 'SharedPool') isNil ifTrue: [^'???'].
	((dict isKindOf: Class) and: [dict isSubclassOf: sharedPoolClass]) ifTrue: [^anObject name , ' _classVars'].
	^'???'.

%

category: 'category'
method: JadeServer
nameOfFirstDictionaryReferencing: aGlobal

	| list |
	list := self symbolList dictionaryAndSymbolOf: aGlobal.
	list isNil ifTrue: [^''].
	^list first name
%

category: 'category'
method: JadeServer
newUser: aString

	| userProfile stream |
	userProfile := UserProfile 
		newWithUserId: aString
		password: 'swordfish'
		privileges: #()
		inGroups: #().
	stream := WriteStream on: String new.
	self
		addUser: userProfile 
		toStream: stream.
	^stream contents.

%

category: 'category'
method: JadeServer
nextLine

	^readStream upTo: Character lf.

%

category: 'category'
method: JadeServer
nextLineAsList

	^(self nextLine subStrings: Character tab) reject: [:each | each isEmpty].

%

category: 'category'
method: JadeServer
nextPut: aCharacter

	self nextPutAll: aCharacter asString.

%

category: 'category'
method: JadeServer
nextPutAll: anObject

	| string args |
	string := self asString: anObject.
	args := Array
		with: self
		with: 1
		with: #'nextPutAll:'
		with: (Array with: string).
	System
		signal: 2336
		args: args
		signalDictionary: GemStoneError.

%

category: 'category'
method: JadeServer
obConfirmationRequest: anOBConfirmationRequest

	^String new 
		addAll: anOBConfirmationRequest cancelChoice;
		add: Character lf;
		addAll: anOBConfirmationRequest okChoice;
		add: Character lf;
		addAll: anOBConfirmationRequest prompt;
		yourself.

%

category: 'category'
method: JadeServer
obInformRequest: anOBInformRequest

	^anOBInformRequest message
%

category: 'category'
method: JadeServer
objectForOop: anInteger

	self subclassResponsibility.
%

category: 'category'
method: JadeServer
objectInBaseNamed: aString

	^[(SymbolList withAll: self class sharedPools) objectNamed: aString asSymbol] on: Error do: [:ex | ex return: nil].

%

category: 'category'
method: JadeServer
objectNamed: aString

	^System myUserProfile objectNamed: aString asSymbol.

%

category: 'category'
method: JadeServer
objectSecurityPolicyFor: anObject

	^anObject segment.

%

category: 'category'
method: JadeServer
obTextRequest: anOBTextRequest

	| prompt template |
	prompt := anOBTextRequest prompt.
	template := anOBTextRequest template.
	^String new 
		addAll: prompt size printString;
		add: Character lf;
		addAll: prompt;
		addAll: template;
		yourself.

%

category: 'category'
method: JadeServer
oopOf: anObject

	^anObject asOop.

%

category: 'category'
method: JadeServer
packagePolicy: aPackagePolicy includesSelector: aSymbol forClass: aClass

	^aPackagePolicy notNil and: [aPackagePolicy includesSelector: aSymbol for: aClass].

%

category: 'category'
method: JadeServer
postSaveClass: aGsClass activities: aString 

	| gsClass copyMethods migrateInstances recompileSubclasses removeFromClassHistory symbolList list index key oldClass newClass oldNewList stream |
	gsClass := (self historyOf: aGsClass) last.
	list := aString subStrings: Character tab.
	list := list collect: [:each | each = 'true'].
	symbolList := self symbolList.
	copyMethods := list at: 1.
	recompileSubclasses := list at: 2.
	migrateInstances := list at: 3.
	removeFromClassHistory := list at: 4.
	oldNewList := OrderedCollection new.
	stream := WriteStream on: String new.
	oldClass := (self historyOf: gsClass) asArray reverse at: 2.
	oldNewList add: oldClass -> gsClass.
	recompileSubclasses ifTrue: [
		(self classOrganizer allSubclassesOf: oldClass) do: [:each | 
			gsClass := GsSession currentSession execute: each definition.
			oldNewList add: each -> gsClass.
		].
	].
	copyMethods ifTrue: [
		oldNewList do: [:eachAssoc | 
			oldClass := eachAssoc key.
			newClass := eachAssoc value.
			index := symbolList findFirst: [:eachDict | eachDict includes: newClass].
			index = 0 ifTrue: [self error: 'Where did the class go?'].
			key := (symbolList at: index) keyAtValue: newClass.
			list := newClass copyMethodsFrom: oldClass dictionaries: symbolList.
			list do: [:eachMethod | 
				stream
					nextPutAll: 'method'; tab;
					nextPutAll: index printString; tab;
					nextPutAll: key; tab;
					nextPutAll: eachMethod selector; lf;
					yourself]]].
	migrateInstances ifTrue: [
		System commitTransaction ifFalse: [self error: 'commit failed!'].
		oldNewList do: [:eachAssoc | 
			oldClass := eachAssoc key.
			newClass := eachAssoc value.
			list := oldClass migrateInstancesTo: newClass.
			list do: [:each | 
				each notEmpty ifTrue: [
					stream
						nextPutAll: 'migrate'; tab;
						nextPutAll: newClass name; tab;
						nextPutAll: each size printString; lf;
						yourself.
				].
			].
		].
	].
	removeFromClassHistory ifTrue: [
		oldNewList do: [:eachAssoc | 
			newClass := eachAssoc value.
			((self historyOf: newClass) asArray copyFrom: 1 to: (self historyOf: newClass) size - 1) do: [:each | 
				(self historyOf: newClass) removeVersion: each.
			].
		].
	].
	^stream contents.

%

category: 'category'
method: JadeServer
print: anObject on: aStream
	"convert multi-byte strings to single-byte"

	| string |
	string := self printStringOf: anObject.
	string class == String ifFalse: [
		string := String withAll: (string collect: [:each | (32 <= each asciiValue and: [each asciiValue <= 255]) ifTrue: [each] ifFalse: [$?]]).
	].
	aStream nextPutAll: string.

%

category: 'category'
method: JadeServer
printStringOf: anObject

	^anObject printString.
%

category: 'category'
method: JadeServer
printStringOf: anObject to: anInteger

	| string |
	(string := self printStringOf: anObject) size > anInteger ifTrue: [string := (string copyFrom: 1 to: anInteger) , '...'].
	string := String withAll: (string collect: [:each | (32 <= each asciiValue and: [each asciiValue <= 255]) ifTrue: [each] ifFalse: [$?]]).
	^string.
%

category: 'category'
method: JadeServer
privilegeListFor: aUserProfile

	| allPrivileges myPrivileges stream |
	allPrivileges := (aUserProfile class instVarAt: 6) at: #'PrivilegeNames'.
	myPrivileges := aUserProfile privileges.
	stream := WriteStream on: String new.
	allPrivileges do: [:each | 
		stream nextPutAll: each; tab.
		(myPrivileges includes: each) printOn: stream.
		stream lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
processes

	| scheduler stream |
	scheduler := ProcessorScheduler scheduler.
	stream := (WriteStream on: String new)
		nextPutAll: 'highestPriority'; 			space; nextPutAll: scheduler highestPriority 			printString; tab;
		nextPutAll: 'highIOPriority'; 			space; nextPutAll: scheduler highIOPriority 			printString; tab;
		nextPutAll: 'lowestPriority'; 			space; nextPutAll: scheduler lowestPriority 				printString; tab;
		nextPutAll: 'lowIOPriority'; 				space; nextPutAll: scheduler lowIOPriority 				printString; tab;
		nextPutAll: 'systemBackgroundPriority'; 	space; nextPutAll: scheduler systemBackgroundPriority 	printString; tab;
		nextPutAll: 'timingPriority'; 			space; nextPutAll: scheduler timingPriority 			printString; tab;
		nextPutAll: 'userBackgroundPriority'; 		space; nextPutAll: scheduler userBackgroundPriority 		printString; tab;
		nextPutAll: 'userInterruptPriority'; 		space; nextPutAll: scheduler userInterruptPriority 		printString; tab;
		nextPutAll: 'userSchedulingPriority'; 		space; nextPutAll: scheduler userSchedulingPriority 		printString; tab;
		yourself.
	scheduler readyProcesses 		do: [:each | self addProcess: each to: stream withStatus: 'ready'		scheduler: scheduler].
	scheduler suspendedProcesses 	do: [:each | self addProcess: each to: stream withStatus: 'suspended'	scheduler: scheduler].
	self waitingProcesses			do: [:each | self addProcess: each to: stream withStatus: 'waiting'	scheduler: scheduler].
	^stream contents.


%

category: 'category'
method: JadeServer
referencesToObject: anObject

	^self streamOfMethods: (self classOrganizer referencesToObject: anObject).

%

category: 'category'
method: JadeServer
registerOBNotifications

	| platform clientForwarder |
	(platform := self objectInBaseNamed: #'OBGemStonePlatform') isNil ifTrue: [^self].
	clientForwarder := ClientForwarder new.
	clientForwarder	clientObject: 1.
	self
		registerOBNotificationsForPlatform: platform 
		clientForwarder: clientForwarder.

%

category: 'category'
method: JadeServer
registerOBNotificationsForPlatform: platform clientForwarder: clientForwarder

	platform 
		registerBrowseClientForwarder: clientForwarder;
		registerChoiceClientForwarder: clientForwarder;
		registerCloseClientForwarder: clientForwarder;
		registerConfirmationClientForwarder: clientForwarder;
		registerInformClientForwarder: clientForwarder;
		registerMultiLineTextClientForwarder: clientForwarder;
		registerTextClientForwarder: clientForwarder;
		yourself.

%

category: 'category'
method: JadeServer
removeCategory: aString fromBehavior: aBehavior

	aBehavior rwRemoveCategory: aString.

%

category: 'category'
method: JadeServer
removeClass: aClass from: aDictionary

	| key |
	key := aDictionary
		keyAtValue: aClass
		ifAbsent: [^false].
	aDictionary removeKey: key.
	^true.

%

category: 'category'
method: JadeServer
removeDictionary: aDictionary fromUser: aUserProfile

	| symbolList index |
	symbolList := aUserProfile symbolList.
	index := symbolList indexOf: aDictionary.
	aUserProfile removeDictionaryAt: index.

%

category: 'category'
method: JadeServer
removeGroup: aString fromUser: aUserProfile

	aUserProfile removeGroup: aString.

%

category: 'category'
method: JadeServer
removeKey: aString fromSymbolDictionary: aSymbolDictionary

	aSymbolDictionary removeKey: aString asSymbol.


%

category: 'category'
method: JadeServer
removeMethod: aGsMethod

	aGsMethod inClass removeSelector: aGsMethod selector.

%

category: 'category'
method: JadeServer
removePriorVersionsOf: aClass

	[
		1 < (self historyOf: aClass) size.
	] whileTrue: [
		(self historyOf: aClass) removeVersion: (self historyOf: aClass) first.
	].

%

category: 'category'
method: JadeServer
removePrivilege: aString fromUser: aUserProfile

	aUserProfile deletePrivilege: aString.

%

category: 'category'
method: JadeServer
renameCategory: oldString to: newString inBehavior: aBehavior

	aBehavior
		renameCategory: oldString asSymbol
		to: newString.

%

category: 'category'
method: JadeServer
reset
	"WriteStream protocol"
%

category: 'category'
method: JadeServer
runAsTest: aGsMethod

	aGsMethod inClass debug: aGsMethod selector.
	^true.

%

category: 'category'
method: JadeServer
runTestNamed: testName in: gsClass
	"The receiver run the test named <testName> of GemStone/S class named <gsClass>"
	| testResult |

	testResult := (self objectNamed: gsClass) run: testName asSymbol.

	^testResult errorCount printString, ',' ,testResult failureCount printString, ',', testResult passedCount printString
%

category: 'category'
method: JadeServer
runTestsNamed: testCollection in: gsClass
	"NO SENDERS"
	"The receiver run the all test of the collection <testCollection> of GemStone/S class named <gsClass>"
	| testResult |

	testResult := ((self objectNamed: gsClass) buildSuiteFromMethods: testCollection) run.

"	stream := WriteStream on: String new.
	testResult failures do: [:each | stream nextPutAll: ',', 'F_', each selector].
	testResult errors do: [:each | stream nextPutAll: ',', 'E_', each selector].
	testResult passed do: [:each | stream nextPutAll: ',', 'P_', each selector].

	^stream contents"

	^testResult printString
%

category: 'category'
method: JadeServer
saveWorkingCopy: wc to: stream

	self _addToPureExportSet: wc.
	stream
		nextPutAll: (self oopOf: wc) printString; tab;
		nextPutAll: wc package name; tab;
		nextPutAll: wc modified printString; tab;
		nextPutAll: wc ancestors size printString; tab;
		yourself.
	wc ancestors do: [:ancestor |
		self _addToPureExportSet: ancestor.
		(self oopOf: ancestor) printOn: stream.
		stream tab.
	].
	stream nextPutAll: wc repositoryGroup repositories size printString; tab.
	wc repositoryGroup repositories do: [:repository |
		self _addToPureExportSet: repository.
		(self oopOf: repository) printOn: stream.
		stream tab.
	].

%

category: 'category'
method: JadeServer
sbAddDictionary: anOrderedCollection

	| currentName newName symbolList index |
	symbolList := self symbolList.
	newName := anOrderedCollection removeFirst.
	anOrderedCollection notEmpty ifTrue: [
		currentName := anOrderedCollection removeFirst asSymbol.
		index := symbolList findFirst: [:each | each name = currentName].
	] ifFalse: [
		index := symbolList size + 1.
	].
	symbolList
		createDictionaryNamed: newName
		at: index.
	selections at: #'dictionary' put: newName.
	self systemBrowserUpdate.
%

category: 'category'
method: JadeServer
sbAddMethodCategory: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) addCategory: anOrderedCollection first.
	selections at: #'methodCategory' put: anOrderedCollection first.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbAddMissingAccessors: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) compileMissingAccessingMethods.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbAddNameOf: aClass

	writeStream nextPutAll: aClass name.
	1 < (self historyOf: aClass) size ifTrue: [
		writeStream nextPutAll: ' ('.
		((self historyOf: aClass) indexOf: aClass) printOn: writeStream.
		writeStream nextPut: $/.
		(self historyOf: aClass) size printOn: writeStream.
		writeStream nextPut: $).
	].
	writeStream tab.

%

category: 'category'
method: JadeServer
sbAddPackage: anOrderedCollection
	| string service |
	string := anOrderedCollection removeFirst.
	selections at: #package put: string.
	service := Rowan packageServiceClass forPackageNamed: string.
	service createPackage.
	self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbAddRepository: list

	| description repository packages |
	description := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = description].
	packages := self mcWorkingCopyClass allManagers select: [:each | list includes: each package name].
	packages do: [:each | each repositoryGroup addRepository: repository].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbBreak: anOrderedCollection

	| myClass gsMethod stepPoint |
	myClass := self sbClassFrom: anOrderedCollection.
	gsMethod := self compiledMethodAt: anOrderedCollection removeFirst asSymbol inClass: myClass.
	stepPoint := anOrderedCollection removeFirst asNumber.
	anOrderedCollection removeFirst = 'set' ifTrue: [
		gsMethod setBreakAtStepPoint: stepPoint.
	] ifFalse: [
		gsMethod clearBreakAtStepPoint: stepPoint.
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbBrowseClassReferences: anOrderedCollection

	| class |
	class := (self sbClassFrom: anOrderedCollection) thisClass.
	writeStream 
		nextPutAll: 'browseClassReferences'; lf;
		nextPutAll: (self referencesToObject: class); 
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseGlobalReferences: anOrderedCollection

	| global |
	global := self objectForOop: anOrderedCollection removeFirst asNumber.
	writeStream 
		nextPutAll: 'browseGlobalReferences'; lf;
		nextPutAll: (self referencesToObject: global); 
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseImplementors: anOrderedCollection

	writeStream 
		nextPutAll: 'browseImplementors'; lf;
		nextPutAll: (self implementorsOf: anOrderedCollection removeFirst);
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseMethodHistory: anOrderedCollection

	| behavior selector historyClass historyList |
	historyClass := self objectInBaseNamed: #'MethodVersionHistory'.
	historyClass isNil ifTrue: [^self].
	behavior := self sbClassFrom: anOrderedCollection.
	selector := anOrderedCollection removeFirst asSymbol.
	historyList := historyClass uniqueInstance 
		versionsOfMethod: selector 
		in: behavior.
	writeStream nextPutAll: 'browseMethodHistory'; nextPut: Character lf.
	historyList do: [:each | " behavior selector changeStamp category source"
		writeStream
			nextPutAll: each category; tab;
			nextPutAll: each changeStamp; tab;
			nextPutAll: each source;
			nextPut: Character lf;
			nextPut: $%;
			nextPut: Character lf;
			yourself.
	].

%

category: 'category'
method: JadeServer
sbBrowseMethodsContaining: anOrderedCollection

	writeStream 
		nextPutAll: 'browseMethodsContaining'; lf;
		nextPutAll: (self methodsContaining: anOrderedCollection removeFirst);
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseMethodsWithPragma: anOrderedCollection

	writeStream 
		nextPutAll: 'browseMethodsWithPragma'; lf;
		yourself.

%

category: 'category'
method: JadeServer
sbBrowseSenders: anOrderedCollection

	writeStream 
		nextPutAll: 'browseSenders'; lf;
		nextPutAll: (self sendersOf: anOrderedCollection removeFirst);
		yourself.

%

category: 'category'
method: JadeServer
sbChangeClassName: aList

	| oldName class newName changedIn |
	oldName := aList removeFirst asSymbol.
	class := self objectForOop: aList removeFirst asNumber.
	class name == oldName ifFalse: [self error: 'Current name is ' , class name printString].
	newName := aList removeFirst asSymbol.
	class changeNameTo: newName.
	changedIn := OrderedCollection new.
	self symbolList do: [:each | 
		(each includes: class) ifTrue: [
			(each at: oldName ifAbsent: [nil]) == class ifFalse: [self error: 'Class not at name!'].
			(each includesKey: newName) ifTrue: [self error: 'Key already in use!'].
			each
				removeKey: oldName;
				at: newName put: class;
				yourself.
			changedIn add: each.
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbChangesInPackage: anOrderedCollection
	"where anOrderedCollection is {packageName, projectName}"

	| patch string packageName url |
	packageName := anOrderedCollection removeFirst.
	url := anOrderedCollection removeFirst.
	patch := Rowan packageTools diff patchForPackageName: packageName.
	string := self
				_mcDescriptionOfPatch: patch
				baseName: 'closest ancestor'
				alternateName: nil.
	writeStream
		nextPutAll: 'changesInPackage';
		lf;
		nextPutAll: string;
		yourself

%

category: 'category'
method: JadeServer
sbCheckUniqueClassName: aList

	| oldName class newName |
	oldName := aList removeFirst asSymbol.
	class := self objectForOop: aList removeFirst asNumber.
	class name == oldName ifFalse: [
		writeStream nextPutAll: 'Current name is ' , class name printString. 
		^self.
	].
	newName := aList removeFirst asSymbol.
	self symbolList do: [:each | 
		((each includes: class) and: [each includesKey: newName]) ifTrue: [
			writeStream nextPutAll: 'Dictionary '.
			each name printOn: writeStream.
			writeStream nextPutAll: ' already has a global with name '.
			newName printOn: writeStream.
			^self.
		].
	].
	
%

category: 'category'
method: JadeServer
sbClass: aList

	| string newClass mcWorkingCopyClass packages dictName |
	string := aList first.
	newClass := string evaluate.
	self classOrganizer update.
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [
		packages := Array with: nil.
	] ifFalse: [
		packages := mcWorkingCopyClass allManagers collect: [:each | each package name].
		packages := packages select: [:each | (newClass category copyFrom: 1 to: (newClass category size min: each size)) = each].
		packages isEmpty ifTrue: [
			packages := Array with: nil.
		].
	].
	dictName := (newClass class canUnderstand: #'symbolDictionaryName')
		ifTrue: [newClass symbolDictionaryName]
		ifFalse: [
			| array |
			array := self dictionaryAndSymbolOf: newClass.
			array isNil
				ifTrue: ['UserGlobals']
				ifFalse: [array first name]].
	selections 
		at: #'package' 		put: packages first;
		at: #'dictionary' 		put: dictName asString;
		at: #'category' 		put: newClass category;
		at: #'className'	put: newClass name;
		at: #'class'				put: newClass;
		yourself.
	selectedClass := newClass.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbClassCategory: aList

	| category classes |
	category := aList removeFirst.
	category := category copyFrom: 1 to: category size - 1.
	classes := aList removeFirst subStrings reject: [:each | each isEmpty].
	classes := classes collect: [:each | self objectNamed: each asSymbol].
	classes := classes collect: [:each | each thisClass].
	classes do: [:each | each category: category].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbClassComment: anOrderedCollection

	| class doc txt |
	class := (self sbClassFrom: anOrderedCollection) thisClass.
	doc := (self objectInBaseNamed: #'GsClassDocumentation') newForClass: self.
	txt := (self objectInBaseNamed: #'GsDocText') new details: self sbNextParagraph trimSeparators.
	doc documentClassWith: txt.
	class rwComment: doc.
	self systemBrowserUpdate.
%

category: 'category'
method: JadeServer
sbClassesToDictionary: anOrderedCollection

	| action targetName target sourceNames sources classNames |
	action := anOrderedCollection removeFirst.
	targetName := anOrderedCollection removeFirst asSymbol.
	target := self symbolList detect: [:each | each name = targetName].
	sourceNames := self nextLineAsList collect: [:each | each asSymbol].
	sources := sourceNames collect: [:eachName | self symbolList detect: [:eachDictionary | eachDictionary name = eachName]].
	classNames := self nextLineAsList collect: [:each | each asSymbol].
	classNames do: [:eachName | 
		| source class |
		source := sources detect: [:eachDict | 
			class := eachDict detect: [:eachGlobal | eachGlobal isBehavior and: [eachGlobal name = eachName]] ifNone: [nil].
			class notNil.
		].
		target at: class name put: class.
		action = 'move' ifTrue: [source removeKey: class name].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbClassFrom: anOrderedCollection

	| selectedClassName selectedClassOop set myClass |
	selectedClassName := (anOrderedCollection removeFirst subStrings: Character space) first.
	selectedClassOop := anOrderedCollection removeFirst asNumber.
	set := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal |
			eachGlobal isBehavior ifTrue: [
				set addAll: (self historyOf: eachGlobal).
			].
		].
	].
	myClass := set detect: [:each | (self oopOf: each) = selectedClassOop].
	myClass name asString = selectedClassName ifFalse: [self error: 'Class not found!'].
	anOrderedCollection removeFirst = 'classTab' ifTrue: [myClass := myClass class].
	^myClass.

%

category: 'category'
method: JadeServer
sbClassTemplate
	| def service classInfoUpdate |
	service := Rowan classServiceClass forClassNamed: 'Object'.
	def := service classCreationTemplate.
	classInfoUpdate := RowanClassInfoUpdate new.
	classInfoUpdate 
		oop: 0;
		template: def.
	classInfoUpdate writeInfoOn: writeStream

%

category: 'category'
method: JadeServer
sbComparePackages: anOrderedCollection

	| current ancestor repository patch string |
	current := self mcWorkingCopyClass forPackage: (self mcPackageClass named: anOrderedCollection removeFirst).
	ancestor := anOrderedCollection removeFirst.
	repository := anOrderedCollection removeFirst.
	repository := current repositoryGroup repositories detect: [:each | each description = repository].
	ancestor := repository class name = #'MCDictionaryRepository'
		ifTrue: [repository versionFromVersionNamed: ancestor]
		ifFalse: [repository versionFromFileNamed: ancestor , '.mcz'].
	patch := current package snapshot patchRelativeToBase: ancestor snapshot.
	string := self 
		_mcDescriptionOfPatch: patch
		baseName: ancestor info name
		alternateName: nil.
	writeStream 
		nextPutAll: 'comparePackages'; lf;
		nextPutAll: string;
		yourself.

%

category: 'category'
method: JadeServer
sbCopyMethodsFor: newClass

	| history oldClass symbolList |
	newClass isMeta ifFalse: [self sbCopyMethodsFor: newClass class].
	history := self historyOf: newClass thisClass.
	oldClass := history at: history size - 1.
	newClass isMeta ifTrue: [oldClass := oldClass class].
	symbolList := self symbolList.
	oldClass selectors do: [:each | 
		| source category errors |
		source := (self compiledMethodAt: each inClass: oldClass) sourceString.
		category := self _behavior: oldClass categoryOfSelector: each.
		errors := newClass 
			compileMethod: source
			dictionaries: symbolList
			category: category.
		errors notNil ifTrue: [
			writeStream
				nextPutAll: 'compileError'; lf;
				nextPutAll: newClass name; tab;
				nextPutAll: category; lf;
				nextPutAll: source; lf;
				nextPut: $%; lf;
				yourself.
			newClass removeSelector: each ifAbsent: [].
		].
	].

%

category: 'category'
method: JadeServer
sbFileOutClass: anOrderedCollection

	writeStream nextPutAll: (self sbClassFrom: anOrderedCollection) thisClass fileOutClass.

%

category: 'category'
method: JadeServer
sbFileOutDictionary: anOrderedCollection

	| dictionary |
	dictionary := self objectNamed: anOrderedCollection first.
	writeStream nextPutAll: '! ------- Create dictionary if it is not present
run
| aSymbol names userProfile |
aSymbol := ' , dictionary name printString , '.
userProfile := System myUserProfile.
names := userProfile symbolList names.
(names includes: aSymbol) ifFalse: [
	| symbolDictionary |
	symbolDictionary := SymbolDictionary new name: aSymbol; yourself.
	userProfile insertDictionary: symbolDictionary at: names size + 1.
].
' , '%
'.
	self classOrganizer
		fileOutClassesAndMethodsInDictionary: dictionary
		on: writeStream.

%

category: 'category'
method: JadeServer
sbFileOutMethod: anOrderedCollection

	| aClass |
	aClass := (self sbClassFrom: anOrderedCollection) thisClass.
	writeStream nextPutAll: aClass fileOutMethod: anOrderedCollection removeFirst.

%

category: 'category'
method: JadeServer
sbFindClass

	| classToPackageMap |
	classToPackageMap := self sbFindClassPackageMap.
	self symbolList do: [:eachDict | 
		| name |
		name := eachDict name.
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				| category |
				category := eachGlobal category.
				category isNil ifTrue: [category := ''].
"1"			self sbAddNameOf: eachGlobal.
				writeStream
"2"				nextPutAll: name; tab;
"3"				nextPutAll: category; tab;		"Class category"
"4"				nextPutAll: (classToPackageMap at: eachGlobal ifAbsent: ['']); tab;		"Package name if available"
					lf.
			].
		].
	].

%

category: 'category'
method: JadeServer
sbFindClassPackageMap

	| systemOrganizerClass mcWorkingCopyClass dictionary packageInfoList |
	dictionary := Dictionary new.
	(systemOrganizerClass := self objectInBaseNamed: #'SystemOrganizer') isNil ifTrue: [^dictionary].
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^dictionary].
	packageInfoList := mcWorkingCopyClass allManagers collect: [:each | each packageInfo].
	systemOrganizerClass new categoryDict keysAndValuesDo: [:catName :classes |
		| symbol packageInfo |
		symbol := catName asSymbol.
		packageInfo := packageInfoList detect: [:each | each includesSystemCategory: symbol] ifNone: [nil].
		packageInfo notNil ifTrue: [
			| name |
			name := packageInfo name.
			classes do: [:each | dictionary at: each put: name].
		].
	].
	^dictionary.

%

category: 'category'
method: JadeServer
sbFindSelectors: anOrderedCollection

	| allSymbols pattern |
	pattern := (anOrderedCollection collect: [:each | each = '*' ifTrue: [$*] ifFalse: [each]]) asArray.
	allSymbols := ((AllUsers userWithId: #SymbolUser ifAbsent: [AllUsers userWithId: #DataCurator]) resolveSymbol: #AllSymbols) value.
	allSymbols := allSymbols select: [:each |each asUppercase matchPattern: pattern].
	allSymbols := allSymbols select: [:each | (self classOrganizer implementorsOf: each) notEmpty].
	allSymbols := allSymbols asSortedCollection.
	allSymbols do: [:each | writeStream nextPutAll: each; nextPut: Character lf; yourself].

%

category: 'category'
method: JadeServer
sbInstVarsOldParent: oldParent newParent: newParent oldChild: oldChild

	| added removed newList used missing |
	added := newParent allInstVarNames asIdentitySet - oldParent allInstVarNames asIdentitySet.
	removed := oldParent allInstVarNames asIdentitySet - newParent allInstVarNames asIdentitySet.
	newList := oldChild instVarNames.
	used := IdentitySet new.
	(oldChild class canUnderstand: #'_methodDict') ifTrue: [
		oldChild _methodDict do: [:each | used addAll: each instVarsAccessed].
	].
	(oldChild class canUnderstand: #'persistentMethodDictsDo:') ifTrue: [
		oldChild persistentMethodDictsDo: [:eachDict | 
			eachDict do: [:eachMethod | 
				used addAll: eachMethod instVarsAccessed.
			].
		].
	].
	used := used * removed.	"Only interested in things that have been removed."
	missing := (used - newList asIdentitySet) asSortedCollection asArray.
	newList := newList , missing.
	newList := newList reject: [:each | added includes: each].
	^newList.

%

category: 'category'
method: JadeServer
sbListMethodPragmas
	"none before 3x"

%

category: 'category'
method: JadeServer
sbLoadLatestVersionOfConfiguration: anOrderedCollection

	anOrderedCollection do: [:each | 
		(self objectNamed: each) project latestVersion load.
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbMethodCategory: anOrderedCollection
	| behavior category |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection removeFirst.
	anOrderedCollection do: [:each | behavior rwMoveMethod: each asSymbol toCategory: category].
	self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbMethodClass: anOrderedCollection
	"Drag/drop method onto class"

	| sourceBehavior action targetName set target |
	sourceBehavior := self sbClassFrom: anOrderedCollection.
	action := anOrderedCollection removeFirst.
	targetName := anOrderedCollection removeFirst asSymbol.
	set := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			(eachGlobal isBehavior and: [eachGlobal name = targetName]) ifTrue: [set add: eachGlobal].
		].
	].
	1 < set size ifTrue: [self error: 'Target name is ambiguous!'].
	1 = set size ifFalse: [self error: 'Target not found!'].
	target := set asArray first.
	sourceBehavior isMeta ifTrue: [target := target class].
	anOrderedCollection do: [:each | 
		| gsMethod result |
		gsMethod := self compiledMethodAt: each asSymbol inClass: sourceBehavior.
		result := self		"key: GsNMethod value: (Array withAll: errors and warnings)"
				compileMethod: gsMethod sourceString
				behavior: target
				symbolList: self symbolList 
				inCategory: (self _behavior: sourceBehavior categoryOfSelector: gsMethod selector).
		(result key notNil and: [action = 'move']) ifTrue: [
			sourceBehavior removeSelector: gsMethod selector.
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbMigrateAll: aClass

	| mcPlatformSupport classes instances |
	((mcPlatformSupport := self objectInBaseNamed: #'MCPlatformSupport') notNil and: [mcPlatformSupport autoMigrate]) ifTrue: [^self].
	System commitTransaction ifFalse: [self error: 'commit failed!'].
	classes := (ClassOrganizer new allSubclassesOf: aClass) 
		inject: (IdentitySet withAll: (self historyOf: aClass))
		into: [:set :each | set addAll: (self historyOf: each); yourself].
	classes := classes asArray.
	instances := (self objectInBaseNamed: #'SystemRepository') listInstances: classes.
	1 to: classes size do: [:i | 
		| class |
		class := classes at: i.
		class 
			migrateInstances: (instances at: i) 
			to: (self historyOf: class) last.
		System commitTransaction ifFalse: [self error: 'commit failed!'].
	].

%

category: 'category'
method: JadeServer
sbNextParagraph

	| stream |
	stream := WriteStream on: String new.
	[
		readStream peek = $%.
	] whileFalse: [
		stream nextPutAll: self nextLine; lf.
	].
	self nextLine.
	^stream contents.

%

category: 'category'
method: JadeServer
sbObjectLog: anOrderedCollection

	| command priorities class log debuggerLogEntryClass | 
	(class := self objectInBaseNamed: #'ObjectLogEntry') isNil ifTrue: [^self].
	debuggerLogEntryClass := self objectInBaseNamed: #'DebuggerLogEntry'.
	(command := anOrderedCollection removeFirst) = 'delete' ifTrue: [
		anOrderedCollection do: [:each | 			| oop entry |
			oop := each asNumber.			entry := class objectLog detect: [:each2 | (self oopOf: each2) = oop] ifNone: [nil].			entry notNil ifTrue: [class objectLog remove: entry].
		].
		^self systemBrowserCommand.
	].
	writeStream nextPutAll: 'objectLog'; lf.
	priorities := anOrderedCollection removeFirst asArray collect: [:each | each asString asNumber].
	log := class objectLog select: [:each | priorities includes: each priority].
	log reverseDo: [:each | 
		| labelString objectString |
		objectString := String withAll: (each objectString asArray collect: [:char | 
			char asciiValue < 32 ifTrue: [Character space] ifFalse: [
			127 < char asciiValue ifTrue: [$?] ifFalse: [char]]]).
		500 < objectString size ifTrue: [objectString := (objectString copyFrom: 1 to: 500) , '...'].
		each label = each object printString ifTrue: [
			labelString := ''.
		] ifFalse: [
			labelString := String withAll: (each labelString asArray collect: [:char | 
				char asciiValue < 32 ifTrue: [Character space] ifFalse: [
				127 < char asciiValue ifTrue: [$?] ifFalse: [char]]]).
			500 < labelString size ifTrue: [labelString := (labelString copyFrom: 1 to: 500) , '...'].
		].
"1"	(self oopOf: each) printOn: writeStream.
"2"	writeStream tab; nextPutAll: each class name; tab.
"3"	each pid printOn: writeStream. 
		writeStream tab.
"4"	each stamp rounded printOn: writeStream.
"5"	writeStream tab; nextPutAll: labelString; tab.
"6"	each priority printOn: writeStream.
		writeStream tab.
"7"	each tag printOn: writeStream.
"8"	writeStream tab; nextPutAll: objectString; tab.
		(debuggerLogEntryClass notNil and: [each isKindOf: debuggerLogEntryClass]) ifTrue: [
"9"		(self oopOf: each continuation) printOn: writeStream.
		] ifFalse: [
			writeStream nextPutAll: '0'.
		].
		writeStream lf.
	].

%

category: 'category'
method: JadeServer
sbPostSaveClass: anOrderedCollection
	"this has been Rowanized"

	self systemBrowserUpdate 
%

category: 'category'
method: JadeServer
sbReadMethodFilter

	| pieces |
	pieces := self nextLine subStrings: Character tab.
	methodFilterType := pieces at: 1.
	methodCommandResult type: methodFilterType.
	methodCommandResult writeTypeTo: writeStream

%

category: 'category'
method: JadeServer
sbRecompileSubclassesOf: newClass andCopyMethods: aBoolean

	| history oldClass symbolList list |
	history := self historyOf: newClass thisClass.
	oldClass := history at: history size - 1.
	symbolList := self symbolList.
	list := self classOrganizer subclassesOf: oldClass.
	list do: [:oldSubclass |
		| instVars classInstVars definition string newSubclass i j |
		instVars := self sbInstVarsOldParent: oldClass newParent: newClass oldChild: oldSubclass.
		classInstVars := self sbInstVarsOldParent: oldClass class newParent: newClass class oldChild: oldSubclass class.

		definition := oldSubclass definition.
		0 < (i := definition findString: 'instVarNames:' startingAt: 1) ifTrue: [
			j := definition indexOf: Character lf startingAt: i.
			string := String withAll: 'instVarNames: #('.
			instVars do: [:each | string addAll: each; add: Character space].
			string add: $).
			definition := (definition copyFrom: 1 to: i - 1) , string , (definition copyFrom: j to: definition size).
		].
		0 < (i := definition findString: 'classInstVars:' startingAt: 1) ifTrue: [
			j := definition indexOf: Character lf startingAt: i.
			string := String withAll: 'classInstVars: #('.
			classInstVars do: [:each | string addAll: each; add: Character space].
			string add: $).
			definition := (definition copyFrom: 1 to: i - 1) , string , (definition copyFrom: j to: definition size).
		].
		newSubclass := definition evaluate.
		aBoolean ifTrue: [self sbCopyMethodsFor: newSubclass].
		self classOrganizer update.
	].

%

category: 'category'
method: JadeServer
sbRemoveClasses
	| containers classNames |
	self nextLine = 'packageList'. "ignore this" 
	containers := self nextLineAsList.
	classNames := (self nextLineAsList reject: [:each | each isEmpty])
				collect: [:each | (each subStrings: Character space) first asSymbol].
	containers do: 
			[:packageName |
			classNames
				do: [:className | (Rowan packageServiceClass forPackageNamed: packageName) removeClassNamed: className]].
	^self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbRemoveDictionaries: anOrderedCollection

	anOrderedCollection do: [:each | 
		self symbolList removeDictionaryNamed: each asSymbol.
	].
	self systemBrowserUpdate.
%

category: 'category'
method: JadeServer
sbRemoveGlobals

	| symbolList dictionaries globals |
	symbolList := self symbolList.
	dictionaries := self nextLineAsList collect: [:each | each asSymbol].
	dictionaries := dictionaries collect: [:eachName | symbolList detect: [:eachDict | eachDict name = eachName]].
	globals := self nextLineAsList collect: [:each | each asSymbol].
	dictionaries do: [:eachDict | 
		globals do: [:eachKey | 
			eachDict removeKey: eachKey ifAbsent: [].
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRemoveHistory: aClass

	(ClassOrganizer new allSubclassesOf: aClass) asArray , (Array with: aClass) do: [:eachNewClass | 
		(self historyOf: eachNewClass) asArray do: [:eachClass | 
			eachClass ~~ eachNewClass ifTrue: [
				(self historyOf: eachNewClass) removeVersion: eachClass.
			].
		].
	].

%

category: 'category'
method: JadeServer
sbRemoveKey: aSymbol fromDictionary: aDictionary

	aDictionary removeKey: aSymbol.

%

category: 'category'
method: JadeServer
sbRemoveMethodCategories: anOrderedCollection

	| behavior |
	behavior := self sbClassFrom: anOrderedCollection.
	anOrderedCollection do: [:each | behavior rwRemoveCategory: each].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRemoveMethods: anOrderedCollection
	| behavior classEntity  notRemoved|
	behavior := self sbClassFrom: anOrderedCollection.
	classEntity := Rowan classServiceClass forClassNamed: behavior name meta: behavior isMeta.
	notRemoved := Array new. 
	anOrderedCollection do: [:each | classEntity removeSelector: each asSymbol ifAbsent: [notRemoved add: each]].
	self systemBrowserUpdate.
	notRemoved isEmpty ifFalse:[self error: 'The following selectors were not removed. Possibly in a superclass? ', notRemoved printString].
%

category: 'category'
method: JadeServer
sbRemovePriorVersions

	| isPackages containers classNames |
	isPackages := self nextLine = 'packageList'.
	containers := self nextLineAsList.
	classNames := (self nextLineAsList reject: [:each | each isEmpty]) collect: [:each | (each subStrings: Character space) first asSymbol].
	self symbolList do: [:eachDictionary | 
		| dictionaryName |
		dictionaryName := eachDictionary name asString.
		classNames do: [:eachName |
			| class flag |
			(class := eachDictionary at: eachName ifAbsent: [nil]) notNil ifTrue: [
				isPackages ifTrue: [
					flag := false.
					containers do: [:each | flag := flag or: [(class category copyFrom: 1 to: (class category size min: each size)) = each]].
				] ifFalse: [
					flag := containers includes: dictionaryName.
				].
				flag ifTrue: [
					| classHistory |
					classHistory := self historyOf: class.
					classHistory size - 1 timesRepeat: [
						classHistory removeVersion: classHistory first.
					].
				].
			].
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRemoveRepository: list

	| description repository packages |
	description := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = description].
	packages := self mcWorkingCopyClass allManagers select: [:each | list includes: each package name].
	packages do: [:each | each repositoryGroup removeRepository: repository].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRevertClass

	| isPackages container className |
	isPackages := self nextLine = 'packageList'.
	container := self nextLine trimSeparators.
	className := self nextLine trimSeparators.
	self symbolList do: [:eachDictionary | 
		| dictionaryName class flag |
		dictionaryName := eachDictionary name asString.
		(class := eachDictionary at: className ifAbsent: [nil]) notNil ifTrue: [
			isPackages ifTrue: [
				flag := (class category copyFrom: 1 to: (class category size min: container size)) = container.
			] ifFalse: [
				flag := container = dictionaryName.
			].
			flag ifTrue: [
				| history |
				history := class classHistory.
				(class == history last and: [1 < history size]) ifFalse: [self error: 'Unexpected class history!'].
				history removeVersion: class.
				class := history last.
				eachDictionary at: class name put: class.
			].
		].
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbRunClassTests: aString

	| behavior |
	behavior := self sbClassFrom: (aString subStrings: Character tab).
	^self defectiveTestsIn: behavior.

%

category: 'category'
method: JadeServer
sbRunMethodTests: aString

	| list class |
	list := aString subStrings: Character tab.
	class := (self sbClassFrom: list) thisClass.
	list do: [:each | class debug: each asSymbol].
	^true.

%

category: 'category'
method: JadeServer
sbSaveMethod: anOrderedCollection
	"Save in method editor"

	| behavior category string association gsMethod |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection notEmpty ifTrue: [anOrderedCollection removeFirst] ifFalse: ['other'].
	string := self sbNextParagraph.
	association := self		"key: GsNMethod value: (Array withAll: errors and warnings)"
		compileMethod: string 
		behavior: behavior 
		symbolList: self symbolList 
		inCategory: category asSymbol.
	(gsMethod := association key) isNil ifTrue: [
		System
			signal: 1001 
			args: (Array with: association value)
			signalDictionary: GemStoneError.
	].
	selections 
		at: #'methodCategory' 	put: (self _behavior: gsMethod inClass categoryOfSelector: gsMethod selector) asString;
		at: #'method'					put: gsMethod selector asString;
		at: #'methodWarnings'	put: association value;
		yourself.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbSavePackage: list

	| packageName package repositoryDescription repository versionName httpUser httpPassword comment |
	packageName := list removeFirst.
	package := self mcWorkingCopyClass allManagers detect: [:each | each package name = packageName].
	repositoryDescription := list removeFirst.
	repository := self mcRepositoryGroup repositories detect: [:each | each description = repositoryDescription].
	versionName := list removeFirst.
	list notEmpty ifTrue: [httpUser := list removeFirst].
	list notEmpty ifTrue: [httpPassword := list removeFirst].
	comment := self sbNextParagraph.
	[
		comment notEmpty and: [comment last asciiValue <= 32].
	] whileTrue: [
		comment := comment copyFrom: 1 to: comment size - 1.
	].
	(repository class name = #'MCHttpRepository') ifTrue: [
		repository
			user: httpUser;
			password: httpPassword;
			yourself.
	].
	self 
		mcStore: package 
		name: versionName 
		message: comment 
		repository: repository.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbSetHomeDictionary: list

	| name dictionary packagePolicy |
	name := list removeFirst asSymbol.
	dictionary := self symbolList detect: [:each | each name = name].
	(packagePolicy := self gsPackagePolicy) notNil ifTrue: [
		packagePolicy homeSymbolDict: dictionary.
	].
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer
sbUniqueVersionName: aList

	| packageName package |
	packageName := aList removeFirst.
	package := self mcWorkingCopyClass allManagers detect: [:each | each package name = packageName].
	writeStream
		nextPutAll: 'uniqueVersionName'; lf;
		nextPutAll: package uniqueVersionName;
		yourself.


%

category: 'category'
method: JadeServer
sbUnloadPackage: anOrderedCollection
	| service |
	service := Rowan packageServiceClass forPackageNamed: anOrderedCollection removeFirst.
	service deletePackage.
	self systemBrowserUpdate
%

category: 'category'
method: JadeServer
sbUpdateClassCategories

	| categories selection override categoryUpdate |
	categoryUpdate := RowanClassCategoryUpdate new. 
	categories := Set new.
	classList do: [:each | categories add: each category].
	categoryUpdate categories addAll: categories asSortedCollection.
	categoryUpdate writeCategoriesTo: writeStream.
	selection := self nextLine.
	categoryUpdate selection: selection. 
	(override := selections at: #'category' ifAbsent: [nil]) notNil ifTrue: [selection := override , '-'].
	selection := 1 < selection size 
		ifTrue: [selection copyFrom: 1 to: selection size - 1]
		ifFalse: [''].
	selection notEmpty ifTrue: [
		categories := categories select: [:each | (each copyFrom: 1 to: (each size min: selection size)) = selection].
		categories isEmpty ifTrue: [selection := ''].
		categories notEmpty ifTrue: [
			classList := classList select: [:each | categories includes: each category].
		].
	].
	categoryUpdate writeSelectionTo: writeStream.


%

category: 'category'
method: JadeServer
sbUpdateClasses

	| tabName |
	tabName := self nextLine.
	writeStream nextPutAll: tabName; lf.
	tabName = 'classList' ifTrue: [^self sbUpdateClassList].
	tabName = 'classHierarchy' ifTrue: [^self sbUpdateClassHierarchy].
	self error: 'Unexpected token!'.

%

category: 'category'
method: JadeServer
sbUpdateClassHierarchy

	| currentSelection currentClass  override classHierarchyUpdate |
	
	classHierarchyUpdate := RowanClassHierarchyUpdate new. 
	classList do: [:each | 
		classHierarchyUpdate addHierarchyFor: each
	].
	classHierarchyUpdate writeHierarchyTo: writeStream. 
	"now figure out which class to select"
	currentSelection := self nextLineAsList.
	(override := selections at: #'className' ifAbsent: [nil]) notNil ifTrue: [currentSelection := Array with: override].
	currentSelection isEmpty ifTrue: [
		selectedClass := nil.
	] ifFalse: [
		(currentClass := selections at: #'class' ifAbsent: [nil]) isNil ifTrue: [
			| className |
			className := (currentSelection last subStrings: Character space) first asSymbol.
			selectedClass := classHierarchyUpdate allClasses detect: [:each | each name = className] ifNone:[].
		] ifFalse: [
			selectedClass := nil.
			[
				selectedClass isNil and: [currentClass notNil].
			] whileTrue: [
				selectedClass := classHierarchyUpdate allClasses detect: [:each | each = currentClass] ifNone:[].
				currentClass := currentClass superclass.
			].
		].
	].
	classHierarchyUpdate addSelectionHierarchyFor: selectedClass.
	classHierarchyUpdate writeSelectionHierarchyTo: writeStream.
	classHierarchyUpdate writeTestCaseInfoTo: writeStream.



%

category: 'category'
method: JadeServer
sbUpdateClassInfo
	| classInfoUpdate |
	selectedClass isNil ifTrue: [
		^self sbClassTemplate. 
].
	classInfoUpdate := RowanClassInfoUpdate new. 
	classInfoUpdate oop: (self oopOf: selectedClass).
	classInfoUpdate template: (Rowan classServiceClass forClassNamed: selectedClass name)
							classCreationTemplate.
	classInfoUpdate category: ((classInfoUpdate template includesString: 'category: ''')
					ifFalse: [' category: ' , selectedClass category printString]).
	classInfoUpdate comment: selectedClass comment. 
	classInfoUpdate writeInfoOn: writeStream.
%

category: 'category'
method: JadeServer
sbUpdateClassList

	| mySelections override classesUpdate |
	classesUpdate := RowanClassesUpdate new. 
	(classList asSortedCollection: [:a :b | a name <= b name]) do: [:eachClass | 
		classesUpdate classNames add: eachClass name. 
	].
	classesUpdate writeClassesTo: writeStream. 
	mySelections := self nextLineAsList collect: [:each | (each subStrings: Character space) first asSymbol].
	(override := selections at: #'className' ifAbsent: [nil]) notNil ifTrue: [mySelections := Array with: override].
	mySelections := classList select: [:eachClass | mySelections includes: eachClass name].
	mySelections do: [:eachClass | 
		classesUpdate selections add: eachClass asString].
	classesUpdate writeSelectionsTo: writeStream. 
	classesUpdate writeTestCaseInfoTo: writeStream. 
	selectedClass := mySelections size = 1
		ifTrue: [mySelections first]
		ifFalse: [nil].

%

category: 'category'
method: JadeServer
sbUpdateDictionaries

	| override packagePolicy home symbolList oldSelections newSelections fullList globals dictionaryUpdate globalsUpdate |
	dictionaryUpdate := RowanDictionaryUpdate new. 
	oldSelections := self nextLineAsList.
	(override := selections at: #'dictionary' ifAbsent: [nil]) notNil ifTrue: [oldSelections := Array with: override].
	symbolList := self symbolList.
	(packagePolicy := self gsPackagePolicy) notNil  ifTrue: [
		home := packagePolicy homeSymbolDict.
	].
	fullList := symbolList collect: [:each | 
		| hvName | 
		hvName := (each == home ifTrue: ['H'] ifFalse: ['V']) , each name.
		dictionaryUpdate dictionaries add: hvName.
		hvName.
		].
	dictionaryUpdate writeDictionariesTo: writeStream.
	fullList := fullList collect: [:each | each copyFrom: 2 to: each size].
	newSelections := oldSelections select: [:each | fullList includes: each].
	globals := Dictionary new.
	newSelections do: [:eachName | 
		| symbolDictionary globalKeyPrefix |
		globalKeyPrefix := 1 < newSelections size ifTrue: [eachName , '.'] ifFalse: [''].
		dictionaryUpdate selections add: eachName asString.
		symbolDictionary := symbolList at: (fullList indexOf: eachName).
		symbolDictionary keys asSortedCollection do: [:eachKey |
			| eachGlobal |
			eachGlobal := symbolDictionary at: eachKey.
			(eachGlobal isBehavior and: [eachGlobal name == eachKey])
				ifTrue: [classList add: eachGlobal]
				ifFalse: [globals at: globalKeyPrefix , eachKey put: (symbolDictionary associationAt: eachKey)].
		].
	].
	dictionaryUpdate writeSelectionsTo: writeStream. 
	globalsUpdate := RowanGlobalsUpdate new. 
	globals keys asSortedCollection do: [:eachKey | 
		| eachAssociation eachValue string globalsArray |
		eachAssociation := globals at: eachKey.
		eachValue := eachAssociation value.
		string := self asString: eachValue.
		100 < string size ifTrue: [string := string copyFrom: 1 to: 100].
		string := string collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$.] ifFalse: [char]].
		string := String withAll: string asArray.
		globalsArray := Array new. 
		globalsArray add: eachKey;
						add: eachValue _class name;
						add: string;
						add: (self oopOf: eachValue) printString;
						add: (self oopOf: eachAssociation) printString.
		globalsUpdate globals add: globalsArray. 
	].
	globalsUpdate writeGlobalsTo: writeStream. 
	


%

category: 'category'
method: JadeServer
sbUpdateMethod

	| classes method names selection aSymbol |

	aSymbol := methodCommandResult selectedSelectors first. 

	"Inherited implimentors"
	classes := self sbUpdateMethodInheritedImplementationsOf: aSymbol.
	names := classes collect: [:each | each name asString].
	methodCommandResult inheritedClasses: names. 
	methodCommandResult writeInheritedClassesTo: writeStream.  "Line 1"

	"Which inherited implementation is selected?"
	selection := self nextLine.
	(names includes: selection) ifFalse: [selection := names last].
	methodCommandResult inheritedClass: selection.
	methodCommandResult writeInheritedClassTo: writeStream.	"Line 2"

	method := self compiledMethodAt: aSymbol inClass: (classes detect: [:each | each name asString = selection]).
	self _describeMethod: method.

%

category: 'category'
method: JadeServer
sbUpdateMethodBreakPointsFor: aMethod
	"Answers an Array of step points"

	^aMethod _stepPointsFromBreakIpOffsets: aMethod _breakpointIpOffsets.		"at least as far back as 32-bit 6.3.0 and 64-bit 2.3.0, but not in 64-bit 3.0"

%

category: 'category'
method: JadeServer
sbUpdateMethodCategories

	methodCommandResult classNamesFrom: classList. 
	methodCommandResult updateMethodCategories; 
		writeMethodCategoriesTo: writeStream. 
	methodCommandResult updateMethodFilterSelections: self nextLineAsList 
			hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodCommandResult selectionNames.
	methodCommandResult writeSelectionsTo: writeStream.
%

category: 'category'
method: JadeServer
sbUpdateMethodFilter
	
	selectedClass isNil ifTrue: [^self].
	methodFilterType = 'categoryList' ifTrue: [^self sbUpdateMethodCategories].
	methodFilterType = 'variableList' ifTrue: [^self sbUpdateMethodVariables].
	methodFilterType = 'pragmaList' ifTrue: [^self sbUpdateMethodPragmas].
	self error: 'Unexpected token!'.

%

category: 'category'
method: JadeServer
sbUpdateMethodFilterSelections

	| mySelections override |
	mySelections := self nextLineAsList.
	(override := selections at: #'methodCategory' ifAbsent: [nil]) notNil ifTrue: [mySelections := Array with: override].
	mySelections := methodFilters select: [:each | mySelections includes: each asString].
	mySelections notEmpty ifTrue: [methodFilters := mySelections].
	self writeList: mySelections.

%

category: 'category'
method: JadeServer
sbUpdateMethodInheritedImplementationsOf: aSymbol

	| classes currentClass |
	classes := OrderedCollection new.
	currentClass := classList last.
	[
		currentClass notNil.
	] whileTrue: [
		(self class: currentClass includesSelector: aSymbol) ifTrue: [classes add: currentClass].
		currentClass := currentClass superclass.
	].
	^classes reverse.

%

category: 'category'
method: JadeServer
sbUpdateMethodPragmas

	self sbUpdateMethodFilterSelections.

%

category: 'category'
method: JadeServer
sbUpdateMethods

	| selectors |
	selectedClass isNil ifTrue: [^self].
	methodFilterType = 'categoryList' ifTrue: [selectors := self sbUpdateMethodsByCategories] ifFalse: [
	methodFilterType = 'variableList' ifTrue: [selectors := self sbUpdateMethodsByVariables] ifFalse: [
	methodFilterType = 'pragmaList' ifTrue: [selectors := self sbUpdateMethodsByPragmas] ifFalse: [
		self error: 'Unrecognized methodFilterType: ' , methodFilterType printString]]].
	methodCommandResult selectors: selectors asSortedCollection asArray.
	methodCommandResult updateMethodsInfo.
	methodCommandResult writeMethodsTo: writeStream. 
	self sbUpdateMethodSelections

%

category: 'category'
method: JadeServer
sbUpdateMethodsByCategories

	| selectors |
	selectors := IdentitySet new.
	classList do: [:eachClass |
		eachClass selectors do: [:eachSelector |
			( methodFilters includes: (self _behavior: eachClass categoryOfSelector: eachSelector)) ifTrue: [selectors add: eachSelector].
		].
	].
	^selectors.

%

category: 'category'
method: JadeServer
sbUpdateMethodsByPragmas
	"none before 3.x"

	^#()
%

category: 'category'
method: JadeServer
sbUpdateMethodsByVariables

	| selectors filters |
	selectors := IdentitySet new.
	filters := IdentitySet withAll: (methodFilters select: [:each | each isSymbol]).
	selectedClass selectors do: [:eachSelector | 
		| gsMethod |
		gsMethod := self compiledMethodAt: eachSelector inClass: selectedClass.
		(gsMethod instVarsAccessed * filters) notEmpty ifTrue: [selectors add: eachSelector].
	].
	^selectors.

%

category: 'category'
method: JadeServer
sbUpdateMethodSelections

	| priorSelections override newSelections aList |
	aList := methodCommandResult selectors asArray. 
	priorSelections := self nextLineAsList.
	(override := selections at: #'method' ifAbsent: [nil]) notNil ifTrue: [priorSelections := Array with: override].
	newSelections := aList select: [:each | priorSelections includes: each asString].
	methodCommandResult selectedSelectors: newSelections. 
	methodCommandResult writeSelectedSelectorsTo: writeStream.
	newSelections size = 1 ifTrue: [self sbUpdateMethod].


%

category: 'category'
method: JadeServer
sbUpdateMethodStepPointsFor: aMethod
	"Answers an Array of Associations (offset -> selector) indexed by step point"

	| offsets selectors |
	offsets := (self homeMethodFor: aMethod)  _sourceOffsets.
	selectors := Array new.
	1 to: offsets size do: [:i | 		"exists as far back as 32-bit 6.3.0"
		| offset ip association |
		offset := offsets at: i.
		ip := (aMethod _ipForStepPoint: i) + 2.		"dropped in 64-bit 3.0"
		association := offset -> ''.
		ip <= aMethod size ifTrue: [
			| literal |
			((literal := aMethod at: ip) isKindOf: Symbol) ifTrue: [
				association value: literal.
			].
		].
		selectors add: association.
	].
	^selectors.

%

category: 'category'
method: JadeServer
sbUpdateMethodVariables

	methodCommandResult classNamesFrom: classList. 
	methodCommandResult updateMethodVariables. 
	methodCommandResult writeMethodFiltersTo: writeStream. 
	methodCommandResult updateMethodFilterSelections: self nextLineAsList 
		hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodCommandResult selectionNames.
	methodCommandResult writeSelectionsTo: writeStream. 


%

category: 'category'
method: JadeServer
sbUpdatePackage: aString
	| package workingCopy list index |
	self mcPackageClass isNil
		ifTrue: 
			[writeStream
				nextPut: $%;
				lf.
			writeStream
				nextPut: $%;
				lf.
			^self ].
	package := self mcPackageClass named: aString.
	workingCopy := self mcWorkingCopyClass forPackage: package.
	list := workingCopy ancestors collect: [:each | 0 -> each].
	index := 1.
	[list size < 4 and: [index <= list size]] whileTrue: 
			[| assoc |
			assoc := list at: index.
			assoc value ancestors do: [:parent | list add: assoc key + 1 -> parent].
			index := index + 1].
	list do: 
			[:each |
			| date time |
			date := each value date isNil
						ifTrue: ['']
						ifFalse: [each value date asStringUsingFormat: #(3 2 1 $- 1 1)].
			time := each value time isNil
						ifTrue: ['']
						ifFalse: [each value time asStringUsingFormat: #($: true false)].
			writeStream
				nextPutAll: each key printString;
				tab;
				nextPutAll: each value name;
				tab;
				nextPutAll: date;
				nextPut: $T;
				nextPutAll: time;
				tab;
				nextPutAll: (each value message
							collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$.] ifFalse: [char]]);
				lf].
	writeStream
		nextPut: $%;
		lf.
	workingCopy repositoryGroup repositories do: 
			[:each |
			writeStream
				nextPutAll: each class name;
				tab;
				nextPutAll: each description;
				tab;
				yourself.
			each class name = #MCHttpRepository
				ifTrue: 
					[writeStream
						nextPutAll: each user;
						tab;
						nextPutAll: each password;
						yourself]
				ifFalse: 
					[writeStream
						tab;
						tab].
			writeStream lf].
	writeStream
		nextPut: $%;
		lf
%

category: 'category'
method: JadeServer
sbUpdatePackages
	| override modifiedList oldSelections newSelections fullList packagesUpdate |
	
	packagesUpdate := RowanPackageUpdate new. 
	oldSelections := self nextLineAsList.
	(override := selections at: #package ifAbsent: [nil]) notNil
		ifTrue: [oldSelections := Array with: override].
	fullList := Rowan serviceClass new rowanLoadedPackageNames subStrings: Character lf.
	fullList := fullList reject: [:each | each isEmpty].
	fullList := fullList asSortedCollection asArray.
	fullList := fullList collect: [:each | each subStrings: Character tab].
	fullList := fullList reject: [:each | each isEmpty].
	modifiedList := (fullList select: [:each | (each at: 2) = 'Y']) collect: [:each | each at: 3].
	fullList := fullList collect: [:each | each at: 3].
	packagesUpdate modifiedPackages addAll: modifiedList. 
	packagesUpdate packages addAll: (fullList collect: [:packageName | RowanPackageService forPackageNamed: packageName]) . 
	packagesUpdate writePackagesTo: writeStream. 
	packagesUpdate writeModifiedPackagesTo: writeStream. 
	newSelections := oldSelections select: [:each | fullList includes: each].
	(newSelections isEmpty and: [oldSelections size = 1])
		ifTrue: 
			[newSelections := fullList
						select: [:each | (oldSelections first copyFrom: 1 to: (oldSelections first size min: each size)) = each]].
	newSelections do: 
			[:each |
			| service |
			packagesUpdate selections add: each asString. 
			service := Rowan packageServiceClass forPackageNamed: each.
			classList addAll: service loadedClassHandles].
	packagesUpdate writeSelectionsTo: writeStream.
	newSelections size = 1 ifTrue: [self sbUpdatePackage: newSelections first]

%

category: 'category'
method: JadeServer
sbUpdatePackagesOrDictionaries

	| selectedTab |
	selectedTab := self nextLine.
	"Removed for Rowan which may not have Monticello loaded, but have a package tab"
	"(self mcWorkingCopyClass isNil or: [self gsPackagePolicy isNil]) ifTrue: [selectedTab := 'dictionaryList']." 
	writeStream nextPutAll: selectedTab; lf.
	classList := OrderedCollection new.
	selectedTab = 'dictionaryList' ifTrue: [^self sbUpdateDictionaries].
	selectedTab = 'packageList' ifTrue: [^self sbUpdatePackages].
	selectedTab = 'projectList' ifTrue:[
		self sbUpdatePackages. 
		^self updateProjects].
	self error: 'unexpected token'.

%

category: 'category'
method: JadeServer
sbUpdateSuperclass

	| class tabName selected index superclassUpdate |

	superclassUpdate := RowanSuperclassUpdate new.
	tabName := self nextLine. 
	(#('default' 'instanceTab' 'classTab') includes: tabName) ifFalse: [self error: 'Unexpected token!'].
	tabName = 'default' ifTrue: [
		tabName := (selectedClass notNil and: [selectedClass selectors isEmpty and: [selectedClass class selectors notEmpty]]) 
			ifTrue: ['classTab']
			ifFalse: ['instanceTab'].
	]. 
	superclassUpdate tabName: tabName. 
	superclassUpdate writeTabNameTo: writeStream.
	selectedClass notNil ifTrue: [
		selectedClass := tabName = 'instanceTab'
			ifTrue: [selectedClass]
			ifFalse: [selectedClass class].
	].
	class := selectedClass.
	classList := OrderedCollection new.
	[
		class notNil.
	] whileTrue: [
		classList add: class.
		superclassUpdate classNames add: class name asString. 
		class := self environmentSuperClassFor: class.
	].
	superclassUpdate writeClassesTo: writeStream.
	classList := classList reverse.
	selected := self nextLine.
	index := classList findFirst: [:each | each name asString = selected].
	index = 0 ifTrue: [index := classList size].
	0 < index ifTrue: [classList := classList copyFrom: index to: classList size].
	classList notEmpty ifTrue: [
		selectedClass := classList first.
		superclassUpdate selections add: selectedClass asString.
	].
	superclassUpdate writeSelectionsTo: writeStream.
%

category: 'category'
method: JadeServer
selectedClassOverridesSelector: aSymbol

	^selectedClass superclass notNil and: [selectedClass superclass canUnderstand: aSymbol].

%

category: 'category'
method: JadeServer
selectorsMatching: aString

	| user stream list |
	list := (aString subStrings: $*) asOrderedCollection collect: [:each | each asUppercase].
	list size - 1 to: 1 do: [:i | list add: $* afterIndex: i].
	aString last = $* ifTrue: [list addLast: $*].
	stream := WriteStream on: String new.
	user := AllUsers 
		userWithId: #SymbolUser 
		ifAbsent: [AllUsers userWithId: #DataCurator].
	list := list asArray.
	list := (user resolveSymbol: #AllSymbols) value select: [:each |each asUppercase matchPattern: list].
	list := list select: [:each | (self classOrganizer implementorsOf: each) notEmpty].
	list := list asSortedCollection.
	list do: [:each | stream nextPutAll: each; nextPut: Character lf; yourself].
	^stream contents.

%

category: 'category'
method: JadeServer
sendersOf: anObject

	| symbol |
	symbol := (anObject isKindOf: String)
		ifTrue: [anObject asSymbol]
		ifFalse: [anObject selector].
	^self streamOfMethods: (self classOrganizer sendersOf: symbol) first.

%

category: 'category'
method: JadeServer
sendSigAbortToSession: anInteger

	System sendSigAbortToSession: anInteger negated.

%

category: 'category'
method: JadeServer
sendSigUsr1ToSession: anInteger

	| description command result |
	description := System descriptionOfSession: anInteger.
	command := 'kill -usr1 ' , (description at: 2) printString.
	result := System performOnServer: command.
	result trimSeparators notEmpty ifTrue: [self error: result trimSeparators].

%

category: 'category'
method: JadeServer
setBreakAtStepPoint: anInteger inMethod: aGsMethod

	aGsMethod setBreakAtStepPoint: anInteger.

%

category: 'category'
method: JadeServer
show: anObject

	self nextPutAll: anObject printString.

%

category: 'category'
method: JadeServer
sleepAndCommit

	[
		System commitTransaction.
	] whileTrue: [
		(Delay forSeconds: 30) wait.
	].

%

category: 'category'
method: JadeServer
sourceFor: anObject in: aClass

	| behavior selector packageName category mcTimestamp dict source |
	selector := (anObject isKindOf: String) 
		ifTrue: [anObject asSymbol]
		ifFalse: [anObject selector].
	behavior := self
		behaviorFor: selector 
		in: aClass.
	category := self _behavior: behavior categoryOfSelector: selector.
	packageName := category first = $*
		ifTrue: [self _packageNameFor: category]
		ifFalse: [behavior thisClass _classCategory].
	packageName isNil ifTrue: [packageName := ''].
	mcTimestamp := ''.
	dict := behavior extraDict.
	dict notNil ifTrue: [
		dict := dict at: #'GSMethodStampDict' ifAbsent: [nil].
		dict notNil ifTrue: [
			mcTimestamp := dict
				at: selector
				ifAbsent: [''].
		].
	].
	source := behavior sourceCodeAt: selector.
	^(WriteStream on: String new)
		nextPutAll: packageName; tab;
		nextPutAll: category; tab;
		nextPutAll: mcTimestamp; lf;
		nextPutAll: source;
		contents.

%

category: 'category'
method: JadeServer
sourceForProcess: gsProcess frame: level

	self subclassResponsibility
%

category: 'category'
method: JadeServer
stackForProcess: aGsProcess

	| array stream |
	Exception
		category: nil
		number: nil
		do: [:ex :cat :num :args | nil].
	array := aGsProcess _reportOfSize: 5000.
	stream := WriteStream on: String new.
	array do: [:each | 
		stream nextPutAll: each; lf.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
step: aGsProcess inFrame: anInteger

	aGsProcess _stepOverInFrame: anInteger.

%

category: 'category'
method: JadeServer
stepPointsFor: aGsMethod in: aClass

	| behavior method source breakStepPoints stepPoint stream |
	behavior := self
		behaviorFor: aGsMethod selector
		in: aClass.
	source := behavior sourceCodeAt: aGsMethod selector.
	method := self compiledMethodAt: aGsMethod selector inClass: behavior.
	stream := WriteStream on: String new.
	breakStepPoints := (aGsMethod class canUnderstand: #'_breakpointIpOffsets')
		ifTrue: [aGsMethod _stepPointsFromBreakIpOffsets: aGsMethod _breakpointIpOffsets]
		ifFalse: [#()].
	stepPoint := 0.
	method _sourceOffsets do: [:each | 
		stepPoint := stepPoint + 1.
		(breakStepPoints includes: stepPoint) ifTrue: [stream nextPut: $B].
		each printOn: stream.
		stream nextPut: Character space.
	].
	stream lf; 
		nextPutAll: (self stringOfLineNumbersWithBreaksIn: method); lf;
		nextPutAll: source;
		yourself.
	^stream contents.

%

category: 'category'
method: JadeServer
stoneInfo

	| dict stream |
	stream := (WriteStream on: String new)
		nextPutAll: self streamType; tab;
		nextPutAll: self stringType; tab;
		cr;
		yourself.
	dict := System stoneVersionReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	dict := System stoneConfigurationReport.
	dict keys asSortedCollection do: [:each | 
		stream nextPutAll: each; tab; nextPutAll: (dict at: each) asString; cr.
	].
	stream nextPut: $%; cr.
	^stream contents
%

category: 'category'
method: JadeServer
stopSession: anInteger

	System stopSession: anInteger.

%

category: 'category'
method: JadeServer
streamOfMethods: aList

	| stream |
	stream := WriteStream on: String new.
	aList do: [:each | 
		self
			_addMethod: each 
			toStream: stream.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
streamType

	^'Legacy'
%

category: 'category'
method: JadeServer
stringForClassList: aList

	| stream |
	stream := WriteStream on: String new.
	aList do: [:each | 
		self 
			_addClass: each 
			toStream: stream.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
stringOfLineNumbersWithBreaksIn: aGsMethod

	| stepPoints offsets lines stream |
	stepPoints := (aGsMethod class canUnderstand: #'_breakpointIpOffsets')
		ifTrue: [aGsMethod _stepPointsFromBreakIpOffsets: aGsMethod _breakpointIpOffsets]
		ifFalse: [#()].
	offsets := stepPoints collect: [:each | aGsMethod _sourceOffsetsAt: each].
	lines := offsets collect: [:each | 
		((aGsMethod sourceString copyFrom: 1 to: each) select: [:char | char = Character lf]) size + 1.
	].
	stream := WriteStream on: String new.
	lines do: [:each | each printOn: stream. stream space].
	^stream contents.

%

category: 'category'
method: JadeServer
stringType

	^'String'
%

category: 'category'
method: JadeServer
subclassSelectorForClass: aClass

	(aClass isBytes and: [aClass superclass notNil and: [aClass superclass isBytes not]]) ifTrue: [
		^'byteSubclass:'.
	].
	(aClass isIndexable and: [aClass superclass notNil and: [aClass superclass isIndexable not]]) ifTrue: [
		^'indexableSubclass:'.
	].
	((aClass class canUnderstand: #'isTransientDB') and: [aClass isTransientDB]) ifTrue: [
		^'transientSubclass:'.
	].
	^'subclass:'.

%

category: 'category'
method: JadeServer
superclassesOf: aClass isMeta: aBoolean

	| myClass list |
	myClass := aBoolean ifTrue: [aClass class] ifFalse: [aClass].
	list := myClass _allSuperList , (Array with: myClass).
	^self stringForClassList: list.

%

category: 'category'
method: JadeServer
symbolList

	^Rowan image symbolList
%

category: 'category'
method: JadeServer
systemBrowser: aString
	^self copy systemBrowserA: aString.

%

category: 'category'
method: JadeServer
systemBrowserA: aString

	| time |
	time := self millisecondsElapsedTime: [
		selections := Dictionary new.
		readStream := ReadStream on: aString.
		writeStream := WriteStream on: String new.
		writeStream lf.
		self environment: (readStream upTo: Character space) asNumber.
		self systemBrowserCommand.
	].
	^time printString , writeStream contents.

%

category: 'category'
method: JadeServer
systemBrowserCommand

	| list command |
	list := self nextLineAsList asOrderedCollection.
	command := list removeFirst.
	command = 'addDictionary'				ifTrue: [^self sbAddDictionary: list].
	command = 'addMethodCategory' 		ifTrue: [^self sbAddMethodCategory: list].
	command = 'addMissingAccessors'		ifTrue: [^self sbAddMissingAccessors: list].
	command = 'addPackage' 				ifTrue: [^self sbAddPackage: list].
	command = 'addRepository'			ifTrue: [^self sbAddRepository: list].

	command = 'break' 					ifTrue: [^self sbBreak: list].
	command = 'browseClassReferences'		ifTrue: [^self sbBrowseClassReferences: list].
	command = 'browseGlobalReferences'		ifTrue: [^self sbBrowseGlobalReferences: list].
	command = 'browseImplementors'		ifTrue: [^self sbBrowseImplementors: list].
	command = 'browseMethodHistory'		ifTrue: [^self sbBrowseMethodHistory: list].
	command = 'browseMethodsContaining'	ifTrue: [^self sbBrowseMethodsContaining: list].
	command = 'browseMethodsWithPragma'	ifTrue: [^self sbBrowseMethodsWithPragma: list].
	command = 'browseSenders'			ifTrue: [^self sbBrowseSenders: list].

	command = 'changeClassName'			ifTrue: [^self sbChangeClassName: list].
	command = 'changesInPackage'			ifTrue: [^self sbChangesInPackage: list].
	command = 'checkUniqueClassName'		ifTrue: [^self sbCheckUniqueClassName: list].
	command = 'class' 					ifTrue: [^self sbClass: list].
	command = 'classCategory'				ifTrue: [^self sbClassCategory: list].
	command = 'classComment'			ifTrue: [^self sbClassComment: list].
	command = 'classesToDictionary'		ifTrue: [^self sbClassesToDictionary: list].
	command = 'comparePackages'			ifTrue: [^self sbComparePackages: list].

	command = 'fileOutClass'				ifTrue: [^self sbFileOutClass: list].
	command = 'fileOutDictionary'			ifTrue: [^self sbFileOutDictionary: list].
	command = 'fileOutMethod'			ifTrue: [^self sbFileOutMethod: list].
	command = 'findClass' 				ifTrue: [^self sbFindClass].
	command = 'findSelectors'				ifTrue: [^self sbFindSelectors: list].


	command = 'listMethodPragmas'			ifTrue: [^self sbListMethodPragmas: list].
	command = 'loadLatestVersion'			ifTrue: [^self sbLoadLatestVersionOfConfiguration: list].

	command = 'method' 					ifTrue: [^self sbSaveMethod: list].
	command = 'methodCategory'			ifTrue: [^self sbMethodCategory: list].
	command = 'methodClass'				ifTrue: [^self sbMethodClass: list].

	command = 'objectLog'				ifTrue: [^self sbObjectLog: list].

	command = 'postSaveClass'			ifTrue: [^self sbPostSaveClass: list].

	command = 'removeClasses'			ifTrue: [^self sbRemoveClasses].
	command = 'removeDictionaries'			ifTrue: [^self sbRemoveDictionaries: list].
	command = 'removeGlobals'			ifTrue: [^self sbRemoveGlobals].
	command = 'removeMethodCategories' 	ifTrue: [^self sbRemoveMethodCategories: list].
	command = 'removeMethods'			ifTrue: [^self sbRemoveMethods: list].
	command = 'removePriorVersions'		ifTrue: [^self sbRemovePriorVersions].
	command = 'removeRepository'			ifTrue: [^self sbRemoveRepository: list].
	command = 'revertClass'				ifTrue: [^self sbRevertClass].

	command = 'savePackage'				ifTrue: [^self sbSavePackage: list].
	command = 'setHomeDictionary'			ifTrue: [^self sbSetHomeDictionary: list].

	command = 'uniqueVersionName'		ifTrue: [^self sbUniqueVersionName: list].
	command = 'unloadPackage'			ifTrue: [^self sbUnloadPackage: list].
	command = 'update' 					ifTrue: [^self systemBrowserUpdate].

	self error: 'Unknown command: ' , command printString.

%

category: 'category'
method: JadeServer
systemBrowserSTON: aString
	^self copy systemBrowserSTONA: aString.

%

category: 'category'
method: JadeServer
systemBrowserSTONA: aString

	| time |
	time := self millisecondsElapsedTime: [
		selections := Dictionary new.
		readStream := ReadStream on: aString.
		writeStream := WriteStream on: String new.
		writeStream lf.
		self environment: (readStream upTo: Character space) asNumber.
		self systemBrowserCommand.
	].
	^STON toString: RowanCommandResult results

%

category: 'jadeite'
method: JadeServer
systemBrowserUpdate

	RowanCommandResult initializeResults. 
	writeStream nextPutAll: 'update'; lf.
	self 
		sbUpdatePackagesOrDictionaries;
		sbUpdateClassCategories;
		sbUpdateClasses;
		sbUpdateClassInfo; 
		sbUpdateSuperclass. 
		methodCommandResult := RowanMethodsUpdate new. 
		self sbReadMethodFilter.
		selectedClass isNil ifFalse:[
			methodCommandResult selectedClass: selectedClass name.
			self
				sbUpdateMethodFilter;
				sbUpdateMethods]
%

category: 'category'
method: JadeServer
systemConfigAsDictionary

	| char dict i line list stream |
	list := Array new.
	stream := GsFile openReadOnServer: '$GEMSTONE/data/system.conf'.
	[
		[
			line := stream nextLine reject: [:each | each == Character cr or: [each == Character lf]].
			(2 < line size and: [(line copyFrom: 1 to: 2) = '#=']) ifTrue: [
				list add: (WriteStream on: String new).
			] ifFalse: [
				list last nextPutAll: line; cr.
			].
			stream atEnd not.
		] whileTrue: [].
	] ensure: [
		stream close.
	].
	list := list copyFrom: 3 to: list size.
	list := list collect: [:each | each contents].
	dict := Dictionary new.
	list do: [:each | 
		line := (ReadStream on: each) nextLine.
		line = '# End of Default GemStone Configuration Options' ifTrue: [^dict].
		(line copyFrom: 1 to: 2) = '# ' ifFalse: [line error: 'Unrecognized config file format!'].
		i := 3.
		[
			i <= line size and: [(char := line at: i) == $_ or: [char isAlphaNumeric]].
		] whileTrue: [
			i := i + 1.
		].
		dict at: (line copyFrom: 3 to: i - 1) put: each.
	].
	self error: 'End of file not recognized!'.
%

category: 'category'
method: JadeServer
terminate: aGsProcess

	aGsProcess isNil ifTrue: [^self].
	aGsProcess terminate.
	(Delay forMilliseconds: 10) wait.	"allow forked processes to finish"

%

category: 'jadeite'
method: JadeServer
updateFromSton: stonString
  | services organizer resultString |
  Rowan commandResultClass initializeResults.
  services := STON fromString: stonString.
  organizer := ClassOrganizer new.
  [ 
  services
    do: [ :service | 
      service organizer: organizer.
      service updateType: nil.	"Update type is only for returned commands"
      service command ifNil: [ service command: #'update' ].
      service servicePerform: service command withArguments: service commandArgs ] ]
    on: GsInteractionRequest
    do: [ :ex | 
      ex
        response:
          (ex interaction interactWith: self gsInteractionInformFailureHandler) ].
  self autoCommitIfRequired.
  Rowan loggingServiceClass current logSentServices.
  resultString := STON toString: Rowan commandResultClass results.
  ^ resultString
%

category: 'category'
method: JadeServer
updateProjects
	
	| update |
	update := RowanProjectsUpdate new. 
	RowanProjectService new projects do:[:service | 
		service isDirty ifTrue:[
			update modifiedProjects add: service name]. 
			update projects add: service].
%

category: 'category'
method: JadeServer
userList

	| list me stream |
	list := (AllUsers asSortedCollection: [:a :b | a userId <= b userId]) asOrderedCollection.
	me := System myUserProfile.
	list
		remove: me;
		addFirst: me;
		yourself.
	stream := WriteStream on: String new.
	list do: [:each | 
		self
			addUser: each 
			toStream: stream.
	].
	^stream contents.

%

category: 'category'
method: JadeServer
waitingProcesses

	^ProcessorScheduler scheduler waitingProcesses

%

category: 'category'
method: JadeServer
writeList: aList

	aList do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.

%

category: 'category'
method: JadeServer
_addClass: each toStream: stream 

	self
		_addClass: each 
		toStream: stream 
		isVisible: true
		fromDictionary: nil.

%

category: 'category'
method: JadeServer
_addClass: aClass toStream: aStream isVisible: aBoolean fromDictionary: aDictionary
	"1. OOP; 2. key; 3. category; 4. dictionary name; 5. superclass OOP; 6. children; 7. Visible/Inherited; 8. Class History; 9. isTestCase"

	| testCaseClass history |
"1"	(self oopOf: aClass) printOn: aStream.
"2"	aStream tab; nextPutAll: (aDictionary  isNil ifTrue: [aClass name] ifFalse: [aDictionary keyAtValue: aClass ifAbsent: [aClass name]]); tab.
"3"	aClass category notNil ifTrue: [aStream nextPutAll: aClass category].
"4"	aStream tab; nextPutAll: (aDictionary isNil ifTrue: ['?'] ifFalse: [aDictionary name]).
"5"	aStream tab. (self oopOf: aClass superclass) printOn: aStream.
	aStream 
"6"		tab; "let client build children list"
"7"		tab; nextPut: (aBoolean ifTrue: [$V] ifFalse: [$I]);
		tab.
	(history := self historyOf: aClass) isNil ifTrue: [history := Array with: aClass].
"8"	(history indexOf: aClass) printOn: aStream.
	aStream nextPut: $/.
	history size printOn: aStream.
	aStream tab.
	testCaseClass := Globals
		at: #'TestCase'
		ifAbsent: [nil].
"9"	(testCaseClass notNil and: [aClass isSubclassOf: testCaseClass]) printOn: aStream.
	aStream lf.

%

category: 'category'
method: JadeServer
_addMethod: aGsMethod toStream: aStream
	"See GsMethod2>>initialize:"

	| inClass testCaseClass |
	inClass := aGsMethod inClass.
"1"	(self oopOf: aGsMethod) printOn: aStream.
	aStream 
"2"		tab; nextPutAll: aGsMethod selector; 
"3"		tab; nextPutAll: (self _behavior: inClass categoryOfSelector: aGsMethod selector);
		tab.

	"Class"
"4"	(self oopOf: inClass) printOn: aStream.
"5"	aStream tab; nextPutAll: inClass name; tab.
"6"	inClass category notNil ifTrue: [aStream nextPutAll: inClass category].
"7"	aStream tab; nextPutAll: (self nameOfFirstDictionaryReferencing: inClass thisClass); tab.

	"SUnit Test Method"
	testCaseClass := Globals
		at: #'TestCase'
		ifAbsent: [nil].
"8"	((testCaseClass notNil and: [inClass isSubclassOf: testCaseClass]) and: [inClass testSelectors includes: aGsMethod selector]) printOn: aStream.
	aStream lf.

%

category: 'category'
method: JadeServer
_addToPureExportSet: anObject

	System 
		_add: anObject 
		toGciSet: 39.  "PureExportSet"

%

category: 'category'
method: JadeServer
_allSelectors

	| allSelectors |
	allSelectors := IdentitySet new.
	self classOrganizer classes do: [:each | 
		allSelectors addAll: each selectors; addAll: each class selectors.
	].
	^allSelectors
%

category: 'category'
method: JadeServer
_behavior: aBehavior categoryOfSelector: aSymbol

	^aBehavior categoryOfSelector: aSymbol
%

category: 'category'
method: JadeServer
_describeMCAddition: anMCAddition on: aStream

	aStream 
		nextPut: $A; tab;
		nextPutAll: (self oopOf: anMCAddition) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCAddition definition 
		on: aStream.

%

category: 'category'
method: JadeServer
_describeMCClassDefinition: anMCClassDefinition on: aStream

	| string |
	string := anMCClassDefinition definitionString collect: [:char |
		char = Character lf
			ifTrue: [Character cr]
			ifFalse: [char].
	].
	aStream
		nextPut: $C; tab;
		nextPutAll: string; lf;
		yourself.

%

category: 'category'
method: JadeServer
_describeMCDefinition: anMCDefinition on: aStream

	anMCDefinition isMethodDefinition ifTrue: [
		self 
			_describeMCMethodDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	anMCDefinition isOrganizationDefinition ifTrue: [
		self 
			_describeMCOrganizationDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	anMCDefinition isClassDefinition ifTrue: [
		self 
			_describeMCClassDefinition: anMCDefinition 
			on: aStream.
		^self.
	].
	self halt.

%

category: 'category'
method: JadeServer
_describeMCMethodDefinition: anMCMethodDefinition on: aStream
	| unicodeFreeSource |
	unicodeFreeSource := RowanMethodService removeUnicodeFromSource: anMCMethodDefinition source.
	aStream
		nextPut: $M; tab;
		nextPutAll: anMCMethodDefinition timeStamp; tab;
		nextPutAll: anMCMethodDefinition className; tab;
		nextPutAll: anMCMethodDefinition classIsMeta printString; tab;
		nextPutAll: anMCMethodDefinition category; tab;
		nextPutAll: anMCMethodDefinition selector; tab;
		nextPutAll: unicodeFreeSource size printString; tab;
		nextPutAll: unicodeFreeSource; lf.
%

category: 'category'
method: JadeServer
_describeMCModification: anMCModification on: aStream

	aStream nextPut: $M; tab;
		nextPutAll: (self oopOf: anMCModification) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCModification obsoletion 
		on: aStream.
	self 
		_describeMCDefinition: anMCModification modification 
		on: aStream.

%

category: 'category'
method: JadeServer
_describeMCOrganizationDefinition: anMCOrganizationDefinition on: aStream

	aStream
		nextPut: $O; tab;
		yourself.
	anMCOrganizationDefinition categories do: [:each | 
		aStream nextPutAll: each; tab.
	].
	aStream lf.

%

category: 'category'
method: JadeServer
_describeMCRemoval: anMCRemoval on: aStream

	aStream nextPut: $R; tab;
		nextPutAll: (self oopOf: anMCRemoval) printString; tab;
		yourself.
	self 
		_describeMCDefinition: anMCRemoval definition 
		on: aStream.

%

category: 'category'
method: JadeServer
_describeMethod: aMethod
	"Provide info needed to create a GsMethod in Jade client"
	"Nice to add packageName and mcTimestamp"

	| allSelectors class list oldGsMethod string methodUpdate |

	methodUpdate := methodCommandResult isNil ifTrue:[RowanMethodUpdate new]
		ifFalse:[methodCommandResult methods detect:[:update | update selector = aMethod selector]].
	self environment: (self environmentForMethod: aMethod).
		
	methodUpdate 	"Line 1 for GsMethod (line 3 for JadeSystemBrowserPresenter)"
"1"		classOop: (class := aMethod inClass) asOop;
"2"		className: class printString;
"3"		methodOop: aMethod asOop;
"4"		selector: aMethod selector;
"5"		category: (self categoryOfMethod: aMethod);
"6"		isReadOnly: (self currentUserMayEditMethod: aMethod);
			source: (RowanMethodService removeUnicodeFromSource: aMethod sourceString).

	"unimplemented selectors"			"https://github.com/jgfoster/Jade/issues/117"
	((aMethod class includesSelector: #'_selectorPool') and: [aMethod class includesSelector: #'_sourceOffsetOfFirstSendOf:']) ifTrue: [
		allSelectors := self _allSelectors.
		(aMethod _selectorPool reject: [:each | allSelectors includes: each]) do: [:each | 
			methodUpdate firstSendOffsets at: (aMethod _sourceOffsetOfFirstSendOf: each) put: each.
		].
	].

	"Array of Associations (offset -> selector) indexed by step points"
	list := self sbUpdateMethodStepPointsFor: aMethod.
	list do:[:each | methodUpdate stepPoints at: each key printString put: each value].

	"breaks"
	methodUpdate breakPoints: (self sbUpdateMethodBreakPointsFor: aMethod).

	"original method"
	oldGsMethod := (aMethod inClass class canUnderstand: #'persistentMethodDictForEnv:')
		ifTrue: [(aMethod inClass persistentMethodDictForEnv: 0) at: aMethod selector ifAbsent: [aMethod]]
		ifFalse: [(aMethod inClass class canUnderstand: #'_rawMethodDict')
			ifTrue: [aMethod inClass _rawMethodDict at: aMethod selector ifAbsent: [aMethod]]
			ifFalse: [aMethod]].
	aMethod ~~ oldGsMethod ifTrue: [
		methodUpdate originalMethodSource: oldGsMethod sourceString.
	].

	"method compile warnings"
	string := selections isNil 
		ifTrue: ['']
		ifFalse: [selections at: #'methodWarnings' ifAbsent: ['']].
	string isNil ifTrue: [string := ''].
	methodUpdate compilationWarnings: string.
	methodUpdate writeMethodTo: writeStream.
%

category: 'category'
method: JadeServer
_mcDescriptionOfPatch: aPatch baseName: aString1 alternateName: aString2

	| stream |
	stream := WriteStream on: String new.
	(self oopOf: aPatch) printOn: stream.
	stream 
		tab; nextPutAll: (aString1 isNil ifTrue: ['loaded'] ifFalse: [aString1]);
		nextPutAll: ' vs. ';
		nextPutAll: (aString2 isNil ifTrue: ['loaded'] ifFalse: [aString2]);
		lf.
	aPatch operations do: [:each | 
		each isAddition 		ifTrue: [self _describeMCAddition: 		each on: stream].
		each isModification 	ifTrue: [self _describeMCModification: 	each on: stream].
		each isRemoval 		ifTrue: [self _describeMCRemoval: 		each on: stream].
	].
	^stream contents.


%

category: 'category'
method: JadeServer
_mcTopazFrom: aSnapshot on: aStream

	| classes dict parents methods queue |
	classes := aSnapshot definitions select: [:each | each isClassDefinition].
	dict := Dictionary new.
	classes do: [:each | 
		| parent myself |
		parent := dict 
			at: each superclassName 
			ifAbsentPut: [nil -> Set new].
		myself := dict
			at: each className
			ifAbsentPut: [nil -> Set new].
		myself key: each.
		parent value add: myself.
	].
	dict := dict reject: [:each | each key isNil].
	parents := dict keys.
	dict copy do: [:each | 
		(parents includes: each key superclassName) ifTrue: [
			dict removeKey: each key className.
		].
	].
	queue := (dict asSortedCollection: [:a :b | a key <= b key]) asOrderedCollection.
	[
		queue notEmpty.
	] whileTrue: [
		| assoc children def |
		assoc := queue removeFirst.
		children := (assoc value asSortedCollection: [:a :b | a key <= b key]) asOrderedCollection.
		queue := children , queue.
		def := assoc key.
		aStream 
			nextPutAll: '! - ' , def className; lf;
			nextPutAll: '! - ' , def commentStamp; lf;
			nextPutAll: 'run'; lf;
			nextPutAll: '(' , def superclassName; lf;
			tab; nextPutAll: 'subclass: ' , def className printString; lf;
			tab; nextPutAll: 'instVarNames: #(' , def instanceVariablesString , ')'; lf;
			tab; nextPutAll: 'classVars: #(' , def classVariablesString , ')'; lf;
			tab; nextPutAll: 'classInstVars: #(' , def classInstanceVariablesString , ')'; lf;
			tab; nextPutAll: 'poolDictionaries: #(' , def sharedPoolsString , ')'; lf;
			tab; nextPutAll: 'inDictionary: UserGlobals'; lf;
			tab; nextPutAll: 'instancesInvariant: false'; lf;
			tab; nextPutAll: 'isModifiable: false)'; lf;
			tab; nextPutAll: 'category: ' , def category printString , '.'; lf;
			nextPutAll: 'true.'; lf;
			nextPut: $%; lf;
			yourself.
	].
	methods := aSnapshot definitions select: [:each | each isMethodDefinition].
	methods := methods asSortedCollection.
	classes asSortedCollection do: [:eachClass | 
		| localMethods |
		localMethods := methods select: [:eachMethod | eachClass className = eachMethod className].
		methods removeAll: localMethods.
		aStream
			lf; nextPutAll: '! - *** - ' , eachClass className; lf;
			nextPutAll: 'removeAllClassMethods ' , eachClass className; lf;
			nextPutAll: 'removeAllMethods ' , eachClass className; lf;
			yourself.
		localMethods do: [:eachMethod | 
			| source |
			source := eachMethod source copyReplaceAll: Character cr asString with: Character lf asString.
			aStream
				nextPutAll: 'category: ''' , eachMethod category , ''''; lf;
				nextPutAll: '! - ' , eachMethod timeStamp; lf;
				nextPutAll: (eachMethod classIsMeta ifTrue: ['classMethod: '] ifFalse: ['method: ']) , eachMethod className; lf;
				nextPutAll: source; lf;
				nextPut: $%; lf;
				yourself.
		].
	].
	aStream lf; nextPutAll: '! - *** - loose methods (where class is expected to be already defined)'; lf; lf.
	methods isEmpty ifTrue: [aStream nextPutAll: '! - (none)'; lf; lf].

	methods do: [:eachMethod | 
		| source |
		source := eachMethod source copyReplaceAll: Character cr asString with: Character lf asString.
		aStream
			nextPutAll: 'category: ''' , eachMethod category , ''''; lf;
			nextPutAll: '! - ' , eachMethod timeStamp; lf;
			nextPutAll: (eachMethod classIsMeta ifTrue: ['classMethod: '] ifFalse: ['method: ']) , eachMethod className; lf;
			nextPutAll: source; lf;
			nextPut: $%; lf;
			yourself.
	].

	aStream lf; nextPutAll: '! - *** - class initialization'; lf.
	methods isEmpty ifTrue: [aStream nextPutAll: '! - (none)'; lf; lf].
	classes do: [:each | 
		aStream nextPutAll: 'send ' , each className , ' initialize'; lf.
	].


%

category: 'category'
method: JadeServer
_methodsFor: aClass categories: aList

	| methods |
	methods := IdentitySet new.
	aList do: [:eachCategory | 
		(aClass _includesCategory: eachCategory) ifTrue: [
			(aClass selectorsIn: eachCategory) do: [:eachSelector |
				methods add: (self compiledMethodAt: eachSelector inClass: aClass).
			].
		].
	].
	^methods.


%

category: 'category'
method: JadeServer
_methodsFor: aClass filter: aList isVariables: aBoolean

	^aBoolean 
		ifTrue:	[self _methodsFor: aClass variables: 	aList]
		ifFalse:	[self _methodsFor: aClass categories: aList].

%

category: 'category'
method: JadeServer
_methodsFor: aClass variables: aList

	| methods |
	aList isEmpty ifTrue: [^aClass selectors collect: [:each | self compiledMethodAt: each inClass: aClass]].
	methods := IdentitySet new.
	aClass selectors do: [:each | 
		| method intersect |
		method := self compiledMethodAt: each inClass: aClass.
		intersect := method instVarsAccessed * aList.
		intersect notEmpty ifTrue: [methods add: method].
	].
	^methods.

%

category: 'category'
method: JadeServer
_oopAndStringFor: anObject

	^(self oopOf: anObject) -> anObject printString.

%

category: 'category'
method: JadeServer
_packageNameFor: aCategoryName

	| string mcWorkingCopyClass list |
	(mcWorkingCopyClass := self mcWorkingCopyClass) isNil ifTrue: [^''].
	string := aCategoryName asUppercase copyFrom: 2 to: aCategoryName size.
	list := mcWorkingCopyClass allManagers collect: [:each | each packageName].
	list := list select: [:each | (string copyFrom: 1 to: (string size min: each size)) = each asUppercase].
	list isEmpty ifTrue: [^''].
	list size = 1 ifTrue: [^list first].
	^(list asSortedCollection: [:a :b | a size <= b size]) last.

%

category: 'category'
method: JadeServer
_sourceForProcess: gsProcess frame: level

	| frame homeMethod stepPoint keys values gsMethod receiver |
	writeStream := WriteStream on: String new.
	(frame := gsProcess _frameContentsAt: level) isNil ifTrue: [^'No frame found for level ' , level printString].
	gsMethod := frame at: 1.
	stepPoint := self 
		_stepPointFromProcess: gsProcess 
		frame: frame 
		method: gsMethod
		level: level.
	writeStream
		nextPutAll: '<?xml version=''1.0'' ?><frame oop=';
		nextPutAll: (self oopOf: frame) printString printString;
		nextPutAll: ' ipOffset=';
		nextPutAll: (frame at: 2) printString printString;
		nextPutAll: ' frameOffset=';
		nextPutAll: ((frame at: 3) isNil ifTrue: [''] ifFalse: [(frame at: 3) printString]) printString;
		nextPutAll: ' stepPoint=';
		nextPutAll: stepPoint printString printString;
		nextPutAll: '>'; lf;
		yourself.
	receiver := frame at: 10.
	values := OrderedCollection new.
	(self isClientForwarder: receiver) ifTrue: [
		keys := OrderedCollection with: 'clientObject'.
		values add: receiver clientObject.
		receiver := '[aClientForwarder(' , (self oopOf: receiver) printString , ')]'.
	] ifFalse: [
		((receiver isKindOf: BlockClosure) or: [receiver isKindOf: Class]) ifTrue: [
			keys := OrderedCollection new.
		] ifFalse: [
			keys := receiver class allInstVarNames asOrderedCollection collect: [:each | '-' , each].
			1 to: keys size do: [:i |
				values add: (receiver instVarAt: i).
			].
		].
	].
	keys addFirst: #'receiver'.
	values addFirst: receiver.
	keys addAll: (frame at: 9).
	keys := keys reject: [:each | each first == $.].
	values addAll: (frame size >= 11
		ifTrue: [frame copyFrom: 11 to: frame size]
		ifFalse: [#()]).
	1 to: (keys size min: values size) do: [:i | | oop assoc key value |
		key := keys at: i.
		value := values at: i.
		assoc := self _oopAndStringFor: value.
		oop := assoc key.
		value := assoc value.
		value size > 500 ifTrue: [value := (value copyFrom: 1 to: 500) , '...'].
		value := value collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$?] ifFalse: [char]].
		writeStream
			nextPutAll: '<var oop=';
			nextPutAll: oop asString printString;
			nextPutAll: ' name=';
			nextPutAll: key asString printString;
			nextPutAll: ' ><';
			nextPutAll: '![';
			nextPutAll: 'CDATA';
			nextPutAll: '[';
			nextPutAll: value;
			nextPutAll: ']';
			nextPutAll: ']';
			nextPutAll: '></var>'; lf;
			yourself.
	].
	homeMethod := self homeMethodFor: gsMethod.
	writeStream 
		nextPutAll: '<source';
		nextPutAll: ' ><';
		nextPutAll: '![';
		nextPutAll: 'CDATA';
		nextPutAll: '[';
		yourself.
	self _describeMethod: homeMethod.
	writeStream
		nextPutAll: ']';
		nextPutAll: ']';
		nextPutAll: '></source>';
		nextPutAll: '</frame>'; lf;
		yourself.
	^self asAsciiString: writeStream contents.

%

category: 'category'
method: JadeServer
_stepPointFromProcess: gsProcess frame: aFrame method: gsMethod level: anInteger

	self subclassResponsibility.
%

category: 'category'
method: JadeServer
_stepPointsForBreaksInMethod: gsMethod

	^gsMethod _stepPointsFromBreakIpOffsets: gsMethod _breakpointIpOffsets
%

category: 'category'
method: JadeServer
_trimStackOf: aGsProcess toLevel: anInteger

	aGsProcess _trimStackToLevel: anInteger.
	^aGsProcess.

%

! Class implementation for 'JadeServer64bit'

!		Instance methods for 'JadeServer64bit'

category: 'category'
method: JadeServer64bit
addSessionWithId: anInteger toStream: aStream

	[
		super
			addSessionWithId: anInteger
			toStream: aStream.
	] on: Error do: [:ex | 
		ex resume: '?????'.
	].

%

category: 'category'
method: JadeServer64bit
addUser: aUserProfile toStream: aStream

	[
		super
			addUser: aUserProfile 
			toStream: aStream.
	] on: Error do: [:ex | 
		aStream lf.
		ex return.
	].

%

category: 'category'
method: JadeServer64bit
asString: anObject

	^[
		super asString: anObject.
	] on: Error do: [:ex | 
		ex return: '???'.
	].

%

category: 'category'
method: JadeServer64bit
homeMethodFor: aGsMethod

	^[aGsMethod homeMethod] on: Error do: [:ex | ex return: aGsMethod]
%

category: 'category'
method: JadeServer64bit
installTranscript

	[
		super installTranscript.
	] on: Error do: [:ex | 
		ex return.
	].

%

category: 'category'
method: JadeServer64bit
mcInitialsA: aString

	^[
		super mcInitialsA: aString.
		true.
	] on: Error do: [:ex | 
		ex return: false.
	].

%

category: 'category'
method: JadeServer64bit
metacelloConfigurations

	| list |
	list := Array new.
	Rowan image symbolList do: [:eachSymbolList | 
		eachSymbolList do: [:eachGlobal | 
			(eachGlobal isBehavior and: [
			(eachGlobal class includesSelector: #'isMetacelloConfig') and: [
			eachGlobal isMetacelloConfig]]) ifTrue: [list add: eachGlobal].
		].
	].
	^list
%

category: 'category'
method: JadeServer64bit
objectForOop: anInteger

	^Object _objectForOop: anInteger.

%

category: 'category'
method: JadeServer64bit
recompile: aMethod withSource: aString
	| behavior |
	behavior := aMethod inClass.
	[[ behavior rwCompileMethod: aString
				category: (self _behavior: behavior categoryOfSelector: aMethod selector) ]
					on: RwExecuteClassInitializeMethodsAfterLoadNotification
					do: [:ex | ex resume: false ]]
								on: RwPerformingUnpackagedEditNotification
								do: [:ex | ex resume ].
			Rowan serviceClass rowanFixMe.	"need to handle compile errors"
			^true
%

category: 'category'
method: JadeServer64bit
sbRemoveKey: aSymbol fromDictionary: aDictionary

	| aClass array |
	aClass := aDictionary at: aSymbol.
	array := self dictionaryAndSymbolOf: aClass.
	((array at: 1) == aDictionary and: [
		(array at: 2) == aSymbol and: [
		(Class canUnderstand: #'removeFromSystem') and: [	"mark package as modified"
		aClass removeFromSystem]]]) ifFalse: [
			aDictionary removeKey: aSymbol.
		].
%

category: 'category'
method: JadeServer64bit
sourceForProcess: gsProcess frame: level

	^[
		self
			_sourceForProcess: gsProcess 
			frame: level.
	] on: Error do: [:ex | 
			ex return: (self asAsciiString: ('?????' , ex description , Character cr asString , (GsProcess stackReportToLevel: 50))).
	].

%

category: 'category'
method: JadeServer64bit
streamType

	| isLegacy type |
	type := Globals at: #'PositionableStream_position' ifAbsent: [#'Legacy'].
	(Globals includesKey: #'PositionableStreamLegacy') ifFalse: [^type].
	isLegacy := PositionableStream isLegacyStreamImplementation.
	(type = #'Legacy') == isLegacy ifTrue: [^type].
	self error: 'Inconsistent PositionableStream configuration'.

%

category: 'category'
method: JadeServer64bit
stringType

	^(Globals at: #StringConfiguration ifAbsent: [String]) name

%

category: 'category'
method: JadeServer64bit
systemBrowser: aString

	[
		^super systemBrowser: aString.
	] on: Error do: [:ex |
		readStream := nil.
		ex pass.
	].

%

category: 'category'
method: JadeServer64bit
systemBrowserSTON: aString

	[
		^super systemBrowserSTON: aString.
	] on: Error do: [:ex |
		readStream := nil.
		ex pass.
	].

%

category: 'category'
method: JadeServer64bit
_oopAndStringFor: anObject

	^[
		super _oopAndStringFor: anObject.
	] on: Error do: [:ex | 
		ex return: 0 -> ('<ERROR IN #printString for ' , anObject class name , '>').
	].

%

category: 'category'
method: JadeServer64bit
_stepPointFromProcess: gsProcess frame: aFrame method: gsMethod level: anInteger

	^gsProcess _stepPointAt: anInteger

%

category: 'category'
method: JadeServer64bit
_trimStackOf: aGsProcess toLevel: anInteger

	^[
		super
			_trimStackOf: aGsProcess 
			toLevel: anInteger.
	] on: Error do: [:ex | 
		self 
			_trimStackOf: aGsProcess 
			toLevel: anInteger - 1.
		ex return.
	].

%

! Class implementation for 'JadeServer64bit24'

!		Instance methods for 'JadeServer64bit24'

category: 'category'
method: JadeServer64bit24
inspect: anObject

	^(self isClientForwarder: anObject)
		ifTrue: [self inspectClientForwarder: anObject]
		ifFalse: [super inspect: anObject].

%

category: 'category'
method: JadeServer64bit24
inspectClientForwarder: anObject

	| stream |
	(stream := WriteStream on: String new)
		nextPutAll: 'ClientForwarder'; tab;
		yourself.
	(self oopOf: anObject) printOn: stream.
	stream lf;
		nextPut: $1; lf;
		nextPutAll: 'clientObject'; tab;
		yourself.
	self print: (self oopOf: anObject clientObject) on: stream.
	stream lf; nextPutAll: (self printStringOf: anObject).
	^stream contents.

%

category: 'category'
method: JadeServer64bit24
isClientForwarder: anObject

	^(Reflection classOf: anObject) name == #'ClientForwarder' 

%

category: 'category'
method: JadeServer64bit24
oopOf: anObject

	^Reflection oopOf: anObject.

%

category: 'category'
method: JadeServer64bit24
printStringOf: anObject

	^(self isClientForwarder: anObject)
		ifFalse: [anObject printString]
		ifTrue: ['aClientForwarder(' , anObject clientObject printString , ')'].

%

category: 'category'
method: JadeServer64bit24
registerOBNotificationsForPlatform: platform clientForwarder: clientForwarder

	super
		registerOBNotificationsForPlatform: platform 
		clientForwarder: clientForwarder.
	platform 
		registerMultipleChoiceClientForwarder: clientForwarder;
		yourself.

%

! Class implementation for 'JadeServer64bit3x'

!		Instance methods for 'JadeServer64bit3x'

category: 'category'
method: JadeServer64bit3x
addMethodCategoryNamesToMethodFilters

	classList do: [:each | 
		each 
			env: environment 
			categorysDo:[ :categName :selectors | methodFilters add: categName ].
	].

%

category: 'category'
method: JadeServer64bit3x
addProcess: aProcess to: aStream withStatus: aString scheduler: aScheduler

	| instVarNumber modeInfo modeInfo_forked modeInfo_terminated |
	super addProcess: aProcess to: aStream withStatus: aString scheduler: aScheduler.
	(instVarNumber := GsProcess instVarNames indexOf: #'modeInfo') == 0 ifTrue: [^self].
	modeInfo := aProcess instVarAt: instVarNumber.
	(modeInfo_forked := GsProcess _classVars at: #'ModeInfo_forked' ifAbsent: [nil]) ifNil: [^self].
	(modeInfo_terminated := GsProcess _classVars at: #'ModeInfo_terminated' ifAbsent: [nil]) ifNil: [^self].
	aStream
"9"		nextPutAll: (0 < (modeInfo bitAnd: modeInfo_forked) ifTrue: ['forked'] ifFalse: ['main']); tab;
"10"		nextPutAll: (0 < (modeInfo bitAnd: modeInfo_terminated) ifTrue: ['terminated'] ifFalse: ['']); tab;
		yourself.

%

category: 'category'
method: JadeServer64bit3x
asString: anObject

	(anObject isKindOf: String) ifTrue: [^anObject].
	(anObject _class name == #'ClientForwarder') ifTrue: [^'aClientForwarder(' , (self asString: anObject clientObject) , ')'].
	^[
		anObject printString.
	] on: Error , Admonition do: [:ex | 
		ex return: '<<printString error: ' , ex description , '>>'.
	].

%

category: 'category'
method: JadeServer64bit3x
categoryOfMethod: aMethod

	| category selector |
	(selector := aMethod selector) isNil ifTrue: [^''].
	category := self _behavior: aMethod inClass categoryOfSelector: aMethod selector.
	category ifNil: [category := #'other'].
	^category.

%

category: 'category'
method: JadeServer64bit3x
class: aClass includesSelector: aSelector

	^aClass includesSelector: aSelector asSymbol environmentId: environment.

%

category: 'category'
method: JadeServer64bit3x
compiledMethodAt: aSymbol inClass: aClass

	| method | 
	method := aClass compiledMethodAt: aSymbol environmentId: environment.
	method ifNil: [self error: 'Lookup failed for selector ' , aSymbol , ' inClass ' , aClass name , ' in environment ' , environment printString].
	^method.
%

category: 'category'
method: JadeServer64bit3x
compileMethod: methodString behavior: aBehavior symbolList: aSymbolList inCategory: categorySymbol
	"returns (nil -> anArrayOfErrors) or (aGsNMethod -> compilerWarnings) or (aGsNMethod -> nil)"

	| method warnings | 

	[[ 
			[[ method := aBehavior rwCompileMethod: methodString category: categorySymbol ]
					on: RwExecuteClassInitializeMethodsAfterLoadNotification
					do: [:ex | ex resume: false ]]
						on: RwPerformingUnpackagedEditNotification
						do: [:ex | ex resume ].
		] on: CompileError do: [:ex |
		^nil -> (ex gsArguments at: 1)
	]] on: CompileWarning do: [:ex |
		warnings := ex gsArguments at: 1.
		ex resume.
	].
	^[	
		(self compiledMethodAt: method key selector inClass: aBehavior) -> warnings.
	] on: Error do: [:ex | 
		ex return: method -> warnings.
	].
%

category: 'category'
method: JadeServer64bit3x
debugString: aString fromContext: anObject environment: anInteger

	[
		^super debugString: aString fromContext: anObject environment: anInteger.
	] on: CompileWarning do: [:ex | 
		ex resume.
	].

%

category: 'category'
method: JadeServer64bit3x
describeMethod: aMethod
	"Provide info needed to create a GsMethod in Jade client"

	(aMethod class name == #'GsNMethod') ifFalse: [self error: 'Expected a GsNMethod but got ' , aMethod class name].
	^super describeMethod: aMethod
%

category: 'category'
method: JadeServer64bit3x
environment

	^environment
%

category: 'category'
method: JadeServer64bit3x
environment: anInteger

	environment := anInteger.

%

category: 'category'
method: JadeServer64bit3x
environmentForMethod: aGsNMethod

	^aGsNMethod environmentId
%

category: 'category'
method: JadeServer64bit3x
executeString: aString fromContext: anObject environment: anInteger

	[
		^super executeString: aString fromContext: anObject environment: anInteger.
	] on: CompileWarning do: [:ex | 
		ex resume.
	].

%

category: 'category'
method: JadeServer64bit3x
homeMethodFor: aGsMethod

	| result |
	result := super homeMethodFor: aGsMethod.
	(result class name == #'GsNMethod') ifFalse: [self error: 'Expected a GsNMethod but got ' , result class name].
	^result
%

category: 'category'
method: JadeServer64bit3x
initialize

	super initialize.
	environment := 0.

%

category: 'category'
method: JadeServer64bit3x
inspect: anObject
	| dynamic dynamicSize indexedSize instVarNames namedSize stream string isRcBag |
	(self isClientForwarder: anObject) ifTrue: [^self inspectClientForwarder: anObject].
	(stream := WriteStream on: String new)
		nextPutAll: anObject class name; tab;
		yourself.
	(self oopOf: anObject) printOn: stream.
	stream lf.
	(anObject isKindOf: Dictionary superclass) ifTrue: [^self inspectDictionary: anObject on: stream].
	instVarNames := anObject class allInstVarNames.
	namedSize := instVarNames size.
	dynamic := anObject dynamicInstanceVariables.
	dynamicSize := dynamic size.
	isRcBag := anObject class name == #RcIdentityBag.
	indexedSize := (anObject class isNsc or: [anObject class isIndexable]) ifFalse: [
		0.
	] ifTrue: [
		isRcBag ifTrue: [ anObject size min: 200] ifFalse: [(anObject _primitiveSize - namedSize)  min: 200].
	].
	
	namedSize + dynamicSize + indexedSize printOn: stream.
	stream lf.
	1 to: instVarNames size do: [:i | 
		stream nextPutAll: (instVarNames at: i); tab.
		self print: (self oopOf: (anObject instVarAt: i)) on: stream.
		stream lf.
	].
	1 to: dynamicSize do: [:i | 
		stream nextPutAll: (dynamic at: i); tab.
		self print: (self oopOf: (anObject dynamicInstVarAt: (dynamic at: i))) on: stream.
		stream lf.
	].
	isRcBag
		ifTrue: [ |aBag |
			aBag := anObject _asIdentityBag.
			1 to: indexedSize do: [:i | 
				i printOn: stream.
				stream tab.
				self print: (self oopOf: (aBag _at: i )) on: stream.
				stream lf]]
		ifFalse: [
			1 to: indexedSize do: [:i | 
				i printOn: stream.
				stream tab.
				self print: (self oopOf: (anObject _primitiveAt: i + namedSize)) on: stream.
				stream lf] ].

	(string := anObject printString) size > 100000 ifTrue: [string := (string copyFrom: 1 to: 100000) , '...'].
	string class == String ifFalse: [
		string := String withAll: (string collect: [:each | (32 <= each codePoint and: [each codePoint <= 255]) ifTrue: [each] ifFalse: [$?]]).
	].
	^stream 
		nextPutAll: string; 
		contents.
%

category: 'category'
method: JadeServer64bit3x
inspectNamedInstanceVariablesOf: anObject on: aStream

	| list dynamic size |
	list := anObject class allInstVarNames.
	dynamic := anObject dynamicInstanceVariables.
	size := list size + dynamic size.
	anObject class format > 0 ifTrue: [
		size := size + (anObject _basicSize min: 200).
	].
	size printOn: aStream.
	aStream lf.
	1 to: list size do: [:i | 
		aStream nextPutAll: (list at: i); tab.
		self print: (self oopOf: (anObject instVarAt: i)) on: aStream.
		aStream lf.
	].
	1 to: dynamic size do: [:i | 
		aStream nextPutAll: (dynamic at: i); tab.
		self print: (self oopOf: (anObject dynamicInstVarAt: (dynamic at: i))) on: aStream.
		aStream lf.
	].

%

category: 'transcript'
method: JadeServer64bit3x
installTranscript

	Transcript class name == #'TranscriptStreamPortable' ifFalse: [^self].
	SessionTemps current at: #'TranscriptStream_SessionStream' put: self.
%

category: 'category'
method: JadeServer64bit3x
keysForDictionary: aDictionary 
	"RubyHash does not implement #'keys' or #'keysDo:'!"

	| keys |
	(aDictionary isKindOf: RubyHash) ifFalse: [^super keysForDictionary: aDictionary].
	keys := Set new.
	aDictionary keysAndValuesDo: [:eachKey :eachValue | keys add: eachKey].
	^keys.

%

category: 'category'
method: JadeServer64bit3x
methodSignatureForSelector: aSymbol
	"Ruby bridge methods can have some strange selectors!"

	| class comma i j method source |
	environment ~~ 1 ifTrue: [^aSymbol].
	class := selectedClass whichClassIncludesSelector: aSymbol environmentId: environment.
	method := class compiledMethodAt: aSymbol environmentId: environment.
	source := (method sourceString subStrings: Character lf) first trimBlanks.
	(4 < source size and: [(source copyFrom: 1 to: 4) = 'def ']) ifTrue: [
		source := source copyFrom: 5 to: source size.
		(source includes: $#) ifTrue: [source := (source copyFrom: 1 to: (source indexOf: $#) - 1) trimBlanks].
		^source.
	].
	(i := aSymbol indexOf: $#) == 0 ifTrue: [^aSymbol].
	source := aSymbol copyFrom: 1 to: i - 1.
	(aSymbol copyFrom: i to: aSymbol size) = '#0__' ifTrue: [^source].
	comma := ''.
	source add: $(.
	j := (aSymbol at: i + 1) asString asNumber.
	1 to: j do: [:k | 
		source 
			add: comma;
			add: 'arg'.
		1 < j ifTrue: [source add: k printString].
		comma := $,.
	].
	(aSymbol at: i + 2) == $* ifTrue: [
		source 
			add: comma;
			add: (0 == j ifTrue: ['args'] ifFalse: ['rest']).
		comma := $,.
	].
	aSymbol last == $& ifTrue: [
		source
			add: comma;
			add: '&block'.
	].
	source add: $).
	^source.

%

category: 'category'
method: JadeServer64bit3x
nameOfFirstDictionaryReferencing: aGlobal

	| list |
	list := self symbolList dictionariesAndSymbolsOf: aGlobal.
	list isEmpty ifTrue: [^''].
	^list first first name
%

category: 'category'
method: JadeServer64bit3x
nextPutAll: anObject

	| exception |
	exception := ClientForwarderSend new 
		receiver: self 
		clientObj: 2
		selector:#'nextPutAll:'
		args: (Array with: (self asString: anObject)).
	exception defaultAction.  "return error direct to GCI"
%

category: 'category'
method: JadeServer64bit3x
objectSecurityPolicyFor: anObject

	^anObject objectSecurityPolicy.

%

category: 'category'
method: JadeServer64bit3x
packagePolicy: aPackagePolicy includesSelector: aSymbol forClass: aClass

	| dict |
	^aPackagePolicy notNil and: [
		(dict := aClass transientMethodDictForEnv: environment) notNil and: [
			dict keys includes: aSymbol.		"includesKey: requires protected mode!"
		].
	].

%

category: 'category'
method: JadeServer64bit3x
sbBrowseMethodsWithPragma: anOrderedCollection

	| methods symbol |
	symbol := anOrderedCollection removeFirst asSymbol.
	methods := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				(Array with: eachGlobal class with: eachGlobal) do: [:eachBehavior | 
					(eachBehavior methodDictForEnv: environment) do: [:eachMethod | 
						(eachMethod pragmas anySatisfy: [:eachPragma | symbol == eachPragma keyword]) ifTrue: [methods add: eachMethod].
					].
				].
			].
		].
	].
	writeStream 
		nextPutAll: 'browseMethodsWithPragma'; lf;
		nextPutAll: (self streamOfMethods: methods);
		yourself.

%

category: 'category'
method: JadeServer64bit3x
sbClassComment: anOrderedCollection

	(self sbClassFrom: anOrderedCollection) thisClass rwComment: self sbNextParagraph trimSeparators.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer64bit3x
sbFileOutMethod: anOrderedCollection

	| aClass |
	aClass := self sbClassFrom: anOrderedCollection.
	writeStream nextPutAll: (aClass fileOutMethod: anOrderedCollection removeFirst asSymbol environmentId: environment).


%

category: 'category'
method: JadeServer64bit3x
sbListMethodPragmas: aList

	| pragmas |
	pragmas := IdentitySet new.
	self symbolList do: [:eachDict | 
		eachDict do: [:eachGlobal | 
			eachGlobal isBehavior ifTrue: [
				(Array with: eachGlobal with: eachGlobal class) do: [:eachBehavior | 
					(eachBehavior methodDictForEnv: environment) do: [:eachMethod | 
						pragmas addAll: (eachMethod pragmas collect: [:eachPragma | eachPragma keyword]).
					].
				].
			].
		].
	].
	pragmas asSortedCollection do: [:each | writeStream nextPutAll: each; tab].
	^pragmas
%

category: 'category'
method: JadeServer64bit3x
sbMethod: anOrderedCollection

	| behavior category string gsMethod |
	behavior := self sbClassFrom: anOrderedCollection.
	category := anOrderedCollection notEmpty ifTrue: [anOrderedCollection removeFirst] ifFalse: ['other'].
	string := self sbNextParagraph.
	gsMethod := behavior
		compileMethod: string 
		dictionaries: self symbolList 
		category: category asSymbol 
		environmentId: environment.
	selections 
		at: #'methodCategory' 	put: (self _behavior: gsMethod inClass categoryOfSelector: gsMethod selector) asString;
		at: #'method'			put: gsMethod selector asString;
		yourself.
	self systemBrowserUpdate.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodBreakPointsFor: aMethod
	"Answers an Array of step points"

	| list array |
	(array := aMethod _allBreakpoints) isNil ifTrue: [^#()].      "{ breakpointNumber1 . method . ipOffset1 . ... }"
	list := Array new.
	1 to: array size by: 3 do:[:k |
		list add: (aMethod
			_stepPointForMeth: (array at: k + 1)
			ip: (array at: k + 2)).
	].
	^list.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodPragmas

	selectedClass notNil ifTrue:[
		methodCommandResult selections add: selectedClass asString].
	methodCommandResult updateMethodPragmas.
	methodCommandResult writeMethodFiltersTo: writeStream. 
	methodCommandResult updateMethodFilterSelections: self nextLineAsList 
		hasCategoryOverride: (selections at: #'methodCategory' ifAbsent: [nil]).
	methodFilters := methodCommandResult selectionNames.
	methodCommandResult writeSelectionsTo: writeStream. 


%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodsByCategories

	| selectors |
	selectors := IdentitySet new.
	classList do: [:eachClass |
		(eachClass selectorsForEnvironment: environment) do: [:eachSelector |
			(methodFilters isEmpty or: [
				| category |
				category := eachClass categoryOfSelector: eachSelector environmentId: environment.
				(category isNil and: [ methodFilters includes: #'other']) or: [ methodFilters includes: category asSymbol]]) ifTrue: [
				| method |
				method := eachClass compiledMethodAt: eachSelector environmentId: environment.
				method isRubyBridgeMethod ifFalse: [
					selectors add: eachSelector.
				].
			].
		].
	].
	^selectors.
%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodsByPragmas

	| selectors |
	selectors := IdentitySet new.
	methodFilters isEmpty ifTrue: [^#()].
	(selectedClass selectorsForEnvironment: environment) do: [:eachSelector | 
		| gsMethod |
		gsMethod := selectedClass compiledMethodAt: eachSelector environmentId: environment.
		gsMethod pragmas do: [:eachPragma | 
			( methodFilters includes: eachPragma keyword) ifTrue: [selectors add: eachSelector].
		].
	].
	^selectors.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodsByVariables

	| selectors filters |
	selectors := IdentitySet new.
	filters := IdentitySet withAll: (methodFilters select: [:each | each isSymbol]).
	(selectedClass selectorsForEnvironment: environment) do: [:eachSelector | 
		| gsMethod |
		gsMethod := selectedClass compiledMethodAt: eachSelector environmentId: environment.
		(gsMethod instVarsAccessed * filters) notEmpty ifTrue: [selectors add: eachSelector].
	].
	^selectors.

%

category: 'category'
method: JadeServer64bit3x
sbUpdateMethodStepPointsFor: aMethod
	"Answers an Array of Associations (offset -> selector) indexed by step point"

	|  selectors list |
	(selectors := aMethod _allDebugInfo: 10) ifNil: [^#()].
	list := (self homeMethodFor: aMethod)  _sourceOffsets.
	list := list collect: [:each | 		"exists as far back as 32-bit 6.3.0"
		| index selector |
		selector := ''.
		index := selectors indexOf: each.
		0 < index ifTrue: [selector := selectors at: index + 1].
		each -> selector.
	].
	^list.


%

category: 'category'
method: JadeServer64bit3x
selectedClassOverridesSelector: aSymbol

	^selectedClass superclass notNil and: [(selectedClass superclass whichClassIncludesSelector: aSymbol environmentId: environment) ~~ nil].

%

category: 'transcript'
method: JadeServer64bit3x
uninstallTranscript

	Transcript class name == #'TranscriptStreamPortable' ifFalse: [^self].
	SessionTemps current at: #'TranscriptStream_SessionStream' put: nil.
%

category: 'category'
method: JadeServer64bit3x
_allSelectors

	| allSelectors |
	allSelectors := IdentitySet new.
	self classOrganizer classes do: [:each | 
		allSelectors addAll: (each selectorsForEnvironment: environment); addAll: (each class selectorsForEnvironment: environment).
	].
	^allSelectors
%

category: 'category'
method: JadeServer64bit3x
_behavior: aBehavior categoryOfSelector: aSymbol

	^aBehavior categoryOfSelector: aSymbol environmentId: environment
%

category: 'category'
method: JadeServer64bit3x
_describeMethod: aMethod

	(aMethod class name == #'GsNMethod') ifFalse: [self error: 'Expected a GsNMethod but got ' , aMethod class name].
	^super _describeMethod: aMethod
%

category: 'category'
method: JadeServer64bit3x
_methodsFor: aClass categories: aList

	| methods |
	methods := IdentitySet new.
	aList do: [:eachCategory | 
		(aClass includesCategory: eachCategory) ifTrue: [
			(aClass selectorsIn: eachCategory) do: [:eachSelector |
				methods add: (self compiledMethodAt: eachSelector inClass: aClass).
			].
		].
	].
	^methods.


%

category: 'category'
method: JadeServer64bit3x
_stepPointsForBreaksInMethod: gsMethod
	"Presumably there is a way to do this, just not the same as 32-bit and 64-bit 2.x"

	^#()
%

! Class implementation for 'JadeServer64bit32'

!		Instance methods for 'JadeServer64bit32'

category: 'category'
method: JadeServer64bit32
dictionaryAndSymbolOf: aClass

	| array |
	array := self symbolList dictionariesAndSymbolsOf: aClass.
	^array isEmpty
		ifTrue: [nil]
		ifFalse: [array first].

%

category: 'category'
method: JadeServer64bit32
dictionaryAndSymbolOf: aClass forUser: aUserProfile

	| array |
	array := aUserProfile symbolList dictionariesAndSymbolsOf: aClass.
	^array isEmpty
		ifTrue: [nil]
		ifFalse: [array first].

%

category: 'category'
method: JadeServer64bit32
gsPackagePolicy

	| class |
	class := self gsPackagePolicyClass.
	class isNil ifTrue: [^nil].
	class enabled ifFalse: [^nil].
	^class current

%

category: 'category'
method: JadeServer64bit32
stepThrough: aGsProcess inFrame: anInteger
  aGsProcess _stepThrough
%

! Class implementation for 'JadeServer64bit35'

!		Instance methods for 'JadeServer64bit35'

category: 'other'
method: JadeServer64bit35
stepThrough: aGsProcess inFrame: anInteger
  aGsProcess stepThroughFromLevel: anInteger
%

! Class implementation for 'RBParser'

!		Class methods for 'RBParser'

category: 'instance creation'
classmethod: RBParser
new

	^self basicNew initialize
%

category: 'accessing'
classmethod: RBParser
parseExpression: aString 
	^self parseExpression: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseExpression: aString onError: aBlock 
	| node parser |
	parser := self new.
	parser errorBlock: aBlock.
	parser initializeParserWith: aString.
	node := parser parseExpression: aString.
	^(node statements size == 1 and: [node temporaries isEmpty]) 
		ifTrue: [node statements first]
		ifFalse: [node]
%

category: 'accessing'
classmethod: RBParser
parseMethod: aString 
	^self parseMethod: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseMethod: aString onError: aBlock 
	| parser |
	parser := self new.
	parser errorBlock: aBlock.
	parser initializeParserWith: aString.
	^parser parseMethod: aString
%

category: 'parsing'
classmethod: RBParser
parseMethodPattern: aString 
	| parser |
	parser := self new.
	parser errorBlock: [:error :position | ^nil].
	parser initializeParserWith: aString.
	^parser parseMessagePattern selector
%

category: 'accessing'
classmethod: RBParser
parseRewriteExpression: aString 
	^self parseRewriteExpression: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseRewriteExpression: aString onError: aBlock 
	^RBPatternParser parseExpression: aString onError: aBlock
%

category: 'accessing'
classmethod: RBParser
parseRewriteMethod: aString 
	^self parseRewriteMethod: aString onError: nil
%

category: 'accessing'
classmethod: RBParser
parseRewriteMethod: aString onError: aBlock 
	^RBPatternParser parseMethod: aString onError: aBlock
%

!		Instance methods for 'RBParser'

category: 'private'
method: RBParser
addCommentsTo: aNode
	aNode comments: aNode comments , comments.
	comments := OrderedCollection new
%

category: 'private-classes'
method: RBParser
arrayNodeClass
	^ RBArrayNode
%

category: 'private-classes'
method: RBParser
assignmentNodeClass
	^ RBAssignmentNode
%

category: 'testing'
method: RBParser
atEnd
	^currentToken class == RBToken
%

category: 'private-classes'
method: RBParser
blockNodeClass
	^ RBBlockNode
%

category: 'private-classes'
method: RBParser
cascadeNodeClass
	^ RBCascadeNode
%

category: 'error handling'
method: RBParser
errorBlock
	^errorBlock isNil ifTrue: [[:message :position | ]] ifFalse: [errorBlock]
%

category: 'accessing'
method: RBParser
errorBlock: aBlock 
	errorBlock := aBlock.
	scanner notNil ifTrue: [scanner errorBlock: aBlock]
%

category: 'error handling'
method: RBParser
errorPosition
	^currentToken start
%

category: 'initialize-release'
method: RBParser
initialize
	comments := OrderedCollection new
%

category: 'accessing'
method: RBParser
initializeParserWith: aString 
	source := aString.
	self scanner: (self scannerClass on: aString readStreamPortable
				errorBlock: self errorBlock)
%

category: 'private-classes'
method: RBParser
literalArrayNodeClass
	^ RBLiteralArrayNode
%

category: 'private-classes'
method: RBParser
literalNodeClass
	^ RBLiteralNode
%

category: 'private-classes'
method: RBParser
messageNodeClass
	^ RBMessageNode
%

category: 'private-classes'
method: RBParser
methodNodeClass
	^ RBMethodNode
%

category: 'private'
method: RBParser
nextToken
	^nextToken isNil ifTrue: [nextToken := scanner next] ifFalse: [nextToken]
%

category: 'private-parsing'
method: RBParser
parseArgs
	| args |
	args := OrderedCollection new.
	[currentToken isIdentifier] whileTrue: [args add: self parseVariableNode].
	^args
%

category: 'private-parsing'
method: RBParser
parseArray
  | position node |
  position := currentToken start.
  self step.
  (currentToken isSpecial and: [ currentToken value = $: ])
    ifTrue: [ ^self parseQueryBlock: position ].
  node := self arrayNodeClass new.
  node left: position.
  self parseStatementList: false into: node.
  (currentToken isSpecial and: [ currentToken value = $} ])
    ifFalse: [ self parserError: 'expected }' ].
  node right: currentToken start.
  self step.
  ^ node
%

category: 'private-parsing'
method: RBParser
parseAssignment
	"Need one token lookahead to see if we have a ':='. This method could 
	make it possible to assign the literals true, false and nil."

	| node position |
	(currentToken isIdentifier and: [self nextToken isAssignment]) 
		ifFalse: [^self parseCascadeMessage].
	node := self parseVariableNode.
	position := currentToken start.
	self step.
	^self assignmentNodeClass 
		variable: node
		value: self parseAssignment
		position: position
%

category: 'private-parsing'
method: RBParser
parseBinaryMessage
	| node |
	node := self parseUnaryMessage.
	
	[currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].
	currentToken isBinary] 
			whileTrue: [node := self parseBinaryMessageWith: node].
	^node
%

category: 'private-parsing'
method: RBParser
parseBinaryMessageWith: aNode 
	| binaryToken |
	binaryToken := currentToken.
	self step.
	^self messageNodeClass 
		receiver: aNode
		selectorParts: (Array with: binaryToken)
		arguments: (Array with: self parseUnaryMessage)
%

category: 'private-parsing'
method: RBParser
parseBinaryPattern
	| binaryToken node args |
	currentToken isBinary
		ifFalse: [self parserError: 'Message pattern expected'].
	binaryToken := currentToken.
	self step.
	args := Array with: self parseVariableNode.
	node := self methodNodeClass
		selectorParts: (Array with: binaryToken)
		arguments: args.
	node comments: node comments , args last comments.
	args last comments: nil.
	^node
%

category: 'private-parsing'
method: RBParser
parseBinaryPragma
	| binaryToken |
	currentToken isBinary 
		ifFalse: [ self parserError: 'Message pattern expected' ].
	binaryToken := currentToken.
	self step.
	^ self pragmaNodeClass
		selectorParts: (Array with: binaryToken)
		arguments: (Array with: self parsePragmaLiteral)
%

category: 'private-parsing'
method: RBParser
parseBlock
	| position node |
	position := currentToken start.
	self step.
	node := self blockNodeClass new. 
	self parseBlockArgsInto: node.
	node left: position.
	node body: (self parseStatements: false).
	(currentToken isSpecial and: [currentToken value = $]])
		ifFalse: [self parserError: ''']'' expected'].
	node right: currentToken start.
	self step.
	^node
%

category: 'private-parsing'
method: RBParser
parseBlockArgsInto: node 
	| verticalBar args colons |
	args := OrderedCollection new: 2.
	colons := OrderedCollection new: 2.
	verticalBar := false.
	[currentToken isSpecial and: [currentToken value = $:]] whileTrue: 
			[colons add: currentToken start.
			self step.	":"
			verticalBar := true.
			args add: self parseVariableNode].
	verticalBar 
		ifTrue: 
			[currentToken isBinary 
				ifTrue: 
					[node bar: currentToken start.
					currentToken value = #| 
						ifTrue: [self step]
						ifFalse: 
							[currentToken value = #'||' 
								ifTrue: 
									["Hack the current token to be the start 
									of temps bar"

									currentToken
										value: #|;
										start: currentToken start + 1]
								ifFalse: [self parserError: '''|'' expected']]]
				ifFalse: 
					[(currentToken isSpecial and: [currentToken value = $]]) 
						ifFalse: [self parserError: '''|'' expected']]].
	node
		arguments: args;
		colons: colons.
	^node
%

category: 'private-parsing'
method: RBParser
parseCascadeMessage
	| node receiver messages semicolons |
	node := self parseKeywordMessage.
	(currentToken isSpecial 
		and: [currentToken value = $; and: [node isMessage]]) ifFalse: [^node].
	receiver := node receiver.
	messages := OrderedCollection new: 3.
	semicolons := OrderedCollection new: 3.
	messages add: node.
	[currentToken isSpecial and: [currentToken value = $;]] whileTrue: 
			[semicolons add: currentToken start.
			self step.
			messages add: (currentToken isIdentifier 
						ifTrue: [self parseUnaryMessageWith: receiver]
						ifFalse: 
							[currentToken isKeyword 
								ifTrue: [self parseKeywordMessageWith: receiver]
								ifFalse: 
									[| temp |
									currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].
									currentToken isBinary ifFalse: [self parserError: 'Message expected'].
									temp := self parseBinaryMessageWith: receiver.
									temp == receiver ifTrue: [self parserError: 'Message expected'].
									temp]])].
	^self cascadeNodeClass messages: messages semicolons: semicolons
%

category: 'accessing'
method: RBParser
parseExpression: aString 
	| node |
	node := self parseStatements: false.
	(RBMethodNode selector: #noMethod body: node) source: aString.	"Make the sequence node have a method node as its parent"
	self atEnd ifFalse: [self parserError: 'Unknown input at end'].
	^node
%

category: 'private-parsing'
method: RBParser
parseKeywordMessage
	^self parseKeywordMessageWith: self parseBinaryMessage
%

category: 'private-parsing'
method: RBParser
parseKeywordMessageWith: node 
	| args isKeyword keywords |
	args := OrderedCollection new: 3.
	keywords := OrderedCollection new: 3.
	isKeyword := false.
	[currentToken isKeyword] whileTrue: 
			[keywords add: currentToken.
			self step.
			args add: self parseBinaryMessage.
			isKeyword := true].
	^isKeyword 
		ifTrue: 
			[self messageNodeClass 
				receiver: node
				selectorParts: keywords
				arguments: args]
		ifFalse: [node]
%

category: 'private-parsing'
method: RBParser
parseKeywordPattern
	| keywords args node |
	keywords := OrderedCollection new.
	args := OrderedCollection new.
	[currentToken isKeyword]
		whileTrue:
			[keywords add: currentToken.
			self step.
			args add: self parseVariableNode].
	node := self methodNodeClass
		selectorParts: keywords
		arguments: args.
	node comments: (node comments, args last comments).
	args last comments: nil.
	^node
%

category: 'private-parsing'
method: RBParser
parseKeywordPragma
	| keywords arguments |
	keywords := OrderedCollection new: 2.
	arguments := OrderedCollection new: 2.
	[ currentToken isKeyword ] whileTrue: [
		keywords addLast: currentToken.
		self step.
		arguments addLast: self parsePragmaLiteral ].
	^ self pragmaNodeClass selectorParts: keywords arguments: arguments
%

category: 'private-parsing'
method: RBParser
parseLiteralArray
	| stream start stop |
	start := currentToken start.
	stream := WriteStreamPortable on: Array new.
	self step.
	[self atEnd or: [currentToken isSpecial and: [currentToken value = $)]]] 
		whileFalse: [stream nextPut: self parseLiteralArrayObject].
	(currentToken isSpecial and: [currentToken value = $)]) 
		ifFalse: [self parserError: ''')'' expected'].
	stop := currentToken stop.
	self step.
	^self literalArrayNodeClass 
		startPosition: start
		contents: stream contents
		stopPosition: stop
		isByteArray: false
%

category: 'private-parsing'
method: RBParser
parseLiteralArrayObject
	currentToken isSpecial 
		ifTrue: 
			[currentToken value = $( ifTrue: [^self parseLiteralArray].
			"currentToken value == $[ ifTrue: [^self parseLiteralByteArray]"].
	currentToken isLiteralArrayToken 
		ifTrue: 
			[^currentToken isForByteArray 
				ifTrue: [self parseLiteralByteArray]
				ifFalse: [self parseLiteralArray]].
	currentToken isLiteralToken ifFalse: [self patchLiteralArrayToken].
	^self parsePrimitiveLiteral
%

category: 'private-parsing'
method: RBParser
parseLiteralByteArray
	| stream start stop |
	start := currentToken start.
	stream := WriteStreamPortable on: Array new.
	self step.
	[self atEnd or: [currentToken isSpecial and: [currentToken value = $]]]] 
		whileFalse: [stream nextPut: self parseLiteralByteArrayObject].
	(currentToken isSpecial and: [currentToken value = $]]) 
		ifFalse: [self parserError: ''']'' expected'].
	stop := currentToken stop.
	self step.
	^self literalArrayNodeClass 
		startPosition: start
		contents: stream contents
		stopPosition: stop
		isByteArray: true
%

category: 'private-parsing'
method: RBParser
parseLiteralByteArrayObject
	(currentToken isLiteralToken and: 
			[currentToken value _isInteger and: [currentToken value between: 0 and: 255]]) 
		ifFalse: [self parserError: 'Expecting 8-bit integer'].
	^self parsePrimitiveLiteral
%

category: 'private-parsing'
method: RBParser
parseMessagePattern
	currentToken isLiteralToken ifTrue: [self patchLiteralMessage].
	^currentToken isIdentifier 
		ifTrue: [self parseUnaryPattern]
		ifFalse: 
			[currentToken isKeyword 
				ifTrue: [self parseKeywordPattern]
				ifFalse: [self parseBinaryPattern]]
%

category: 'private-parsing'
method: RBParser
parseMethod
	| methodNode | 
	methodNode := self parseMessagePattern.
	self parsePragmas.
	self addCommentsTo: methodNode.
	methodNode body: (self parseStatements: true).
	pragmas isNil
		ifFalse: [ methodNode pragmas: pragmas ].
	^methodNode
%

category: 'accessing'
method: RBParser
parseMethod: aString 
	| node |
	node := self parseMethod.
	self atEnd ifFalse: [self parserError: 'Unknown input at end'].
	node source: aString.
	^node
%

category: 'private-parsing'
method: RBParser
parseNegatedNumber
	| token |
	(self nextToken isLiteral not or: [ self nextToken realValue isNumber not ])
		ifTrue: [ self parserError: 'only numbers may be negated' ].
	token := RBLiteralToken value: self nextToken realValue negated start: currentToken start stop: nextToken stop.
	self step; step.
	^ self literalNodeClass literalToken: token
%

category: 'private-parsing'
method: RBParser
parseParenthesizedExpression
	| leftParen node |
	leftParen := currentToken start.
	self step.
	node := self parseAssignment.
	^(currentToken isSpecial and: [currentToken value = $)])
		ifTrue: 
			[node addParenthesis: (leftParen to: currentToken start).
			self step.
			node]
		ifFalse: [self parserError: ''')'' expected']
%

category: 'private-parsing'
method: RBParser
parsePragma
  ^ currentToken isIdentifier
    ifTrue: [ 
      currentToken value = 'protected'
        ifTrue: [ self parseProtectedPragma ]
        ifFalse: [ self parseUnaryPragma ] ]
    ifFalse: [ 
      currentToken isKeyword
        ifTrue: [ self parseKeywordPragma ]
        ifFalse: [ self parseBinaryPragma ] ]
%

category: 'private-parsing'
method: RBParser
parsePragmaLiteral
	^ self parseLiteralArrayObject
%

category: 'private-parsing'
method: RBParser
parsePragmas
	| pragma start |
	[ currentToken isBinary and: [ currentToken value = #< ] ] whileTrue: [
		start := currentToken start.
		self step.
		pragma := self parsePragma.
		(currentToken isBinary and: [ currentToken value = #> ]) 
			ifFalse: [ self parserError: '''>'' expected' ].
		pragma left: start; right: currentToken start.
		pragmas isNil
			ifTrue: [ pragmas := OrderedCollection new ].
		pragmas addLast: pragma.
		self step ]
%

category: 'private-parsing'
method: RBParser
parsePrimitiveIdentifier
	| token node |
	token := currentToken.
	self step.
	node := self variableNodeClass identifierToken: token.
	self addCommentsTo: node.
	^node
%

category: 'private-parsing'
method: RBParser
parsePrimitiveLiteral
	| token |
	token := currentToken.
	self step.
	^self literalNodeClass literalToken: token
%

category: 'private-parsing'
method: RBParser
parsePrimitiveObject
	currentToken isIdentifier ifTrue: [^self parsePrimitiveIdentifier].
	(currentToken isLiteralToken and: [currentToken isMultiKeyword not]) 
		ifTrue: [^self parsePrimitiveLiteral].
	currentToken isLiteralArrayToken 
		ifTrue: 
			[^currentToken isForByteArray 
				ifTrue: [self parseLiteralByteArray]
				ifFalse: [self parseLiteralArray]].
	currentToken isSpecial 
		ifTrue: 
			[currentToken value = $[ ifTrue: [^self parseBlock].
			currentToken value = $( ifTrue: [^self parseParenthesizedExpression].
			currentToken value = ${ ifTrue: [^self parseArray]].
	(currentToken isBinary and: [ currentToken value = #- ]) 
		ifTrue: [ ^self parseNegatedNumber ].
	self parserError: 'Variable expected'
%

category: 'private-parsing'
method: RBParser
parseProtectedPragma
  "encoutered 'protected' as first token in pragma"

  self step.
  currentToken isKeyword
    ifFalse: [ ^ self pragmaNodeClass selectorParts: (Array with: 'protected') arguments: #() ].
  ^ self parseKeywordPragma
    isProtected: true;
    yourself
%

category: 'private-parsing'
method: RBParser
parseQueryBlock: startPosition
  | position node |
  position := startPosition.
  node := self queryBlockNodeClass new.
  self parseBlockArgsInto: node.
  node left: position.
  node body: (self parseStatements: false).
  (currentToken isSpecial and: [ currentToken value = $} ])
    ifFalse: [ self parserError: '''}'' expected' ].
  node right: currentToken start.
  self step.
  ^ node
%

category: 'error handling'
method: RBParser
parserError: aString 
	"Evaluate the block. If it returns raise an error"

	self errorBlock value: aString value: self errorPosition.
	self error: aString
%

category: 'private-parsing'
method: RBParser
parseStatementList: pragmaBoolean into: sequenceNode 
	| statements return periods returnPosition node |
	return := false.
	statements := OrderedCollection new.
	periods := OrderedCollection new.
	self addCommentsTo: sequenceNode.
	pragmaBoolean ifTrue: [self parsePragmas].
	[currentToken isSpecial and: [currentToken value = $.]] whileTrue: 
		[periods add: currentToken start.
		self step].
	[self atEnd 
		or: [currentToken isSpecial and: ['])}' includes: currentToken value]]] 
			whileFalse: 
				[return ifTrue: [self parserError: 'End of statement list encounted'].
				(currentToken isSpecial and: [currentToken value = $^]) 
					ifTrue: 
						[returnPosition := currentToken start.
						self step.
						node := self returnNodeClass return: returnPosition
									value: self parseAssignment.
						statements add: node.
						return := true]
					ifFalse: 
						[node := self parseAssignment.
						statements add: node].
				(currentToken isSpecial and: [currentToken value = $.]) 
					ifTrue: 
						[periods add: currentToken start.
						self step.
						self addCommentsTo: node]
					ifFalse: [return := true].
				[currentToken isSpecial and: [currentToken value = $.]] whileTrue: 
					[periods add: currentToken start.
					self step]].
	statements notEmpty ifTrue: [self addCommentsTo: statements last].
	sequenceNode
		statements: statements;
		periods: periods.
	^sequenceNode
%

category: 'private-parsing'
method: RBParser
parseStatements: pragmaBoolean 
	| args leftBar rightBar |
	args := #().
	leftBar := rightBar := nil.
	currentToken isBinary 
		ifTrue: 
			[currentToken value = #| 
				ifTrue: 
					[leftBar := currentToken start.
					self step.
					args := self parseArgs.
					(currentToken isBinary and: [currentToken value = #|]) 
						ifFalse: [self parserError: '''|'' expected'].
					rightBar := currentToken start.
					self step]
				ifFalse: 
					[currentToken value = #'||' 
						ifTrue: 
							[rightBar := (leftBar := currentToken start) + 1.
							self step]]].
	^self parseStatementList: pragmaBoolean
		into: (self sequenceNodeClass 
				leftBar: leftBar
				temporaries: args
				rightBar: rightBar)
%

category: 'private-parsing'
method: RBParser
parseUnaryMessage
	| node |
	node := self parsePrimitiveObject.
	self addCommentsTo: node.
	[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].
	currentToken isIdentifier] 
			whileTrue: [node := self parseUnaryMessageWith: node].
	self addCommentsTo: node.
	^node
%

category: 'private-parsing'
method: RBParser
parseUnaryMessageWith: aNode 
	| selector |
	selector := currentToken.
	self step.
	^self messageNodeClass 
		receiver: aNode
		selectorParts: (Array with: selector)
		arguments: #()
%

category: 'private-parsing'
method: RBParser
parseUnaryPattern
	| selector |
	selector := currentToken.
	self step.
	^self methodNodeClass selectorParts: (Array with: selector) arguments: #()
%

category: 'private-parsing'
method: RBParser
parseUnaryPragma
	| selector |
	selector := currentToken.
	self step.
	^ self pragmaNodeClass selectorParts: (Array with: selector) arguments: #()
%

category: 'private-parsing'
method: RBParser
parseVariableNode
	currentToken isIdentifier 
		ifFalse: [self parserError: 'Variable name expected'].
	^self parsePrimitiveIdentifier
%

category: 'private'
method: RBParser
patchLiteralArrayToken
	(currentToken isIdentifier and: 
			[self nextToken isAssignment 
				and: [currentToken stop + 1 = self nextToken start]]) 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: (currentToken value , ':') asSymbol
						start: currentToken start
						stop: self nextToken start.
			nextToken := RBLiteralToken 
						value: #=
						start: nextToken stop
						stop: nextToken stop.
			^self].
	currentToken isAssignment 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: #':'
						start: currentToken start
						stop: currentToken start.
			nextToken := RBLiteralToken 
						value: #=
						start: currentToken stop
						stop: currentToken stop.
			^self].
	currentToken isSpecial 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: (String with: currentToken value) asSymbol
						start: currentToken start
						stop: currentToken stop.
			^self].
	(currentToken isIdentifier and: [currentToken value includes: $.]) 
		ifTrue: 
			[currentToken := RBLiteralToken 
						value: currentToken value
						start: currentToken start
						stop: currentToken stop.
			^self].
	(currentToken isIdentifier 
		or: [currentToken isBinary or: [currentToken isKeyword]]) 
			ifFalse: [^self parserError: 'Invalid token'].
	currentToken := RBLiteralToken 
				value: currentToken value asSymbol
				start: currentToken start
				stop: currentToken stop
%

category: 'private'
method: RBParser
patchLiteralMessage
	currentToken value == true 
		ifTrue: 
			[^currentToken := RBIdentifierToken value: 'true' start: currentToken start].
	currentToken value == false 
		ifTrue: 
			[^currentToken := RBIdentifierToken value: 'false' start: currentToken start].
	currentToken value == nil 
		ifTrue: 
			[^currentToken := RBIdentifierToken value: 'nil' start: currentToken start]
%

category: 'private'
method: RBParser
patchNegativeLiteral
	"Handle the special negative number case for binary message sends."

	currentToken value isNumber 
		ifFalse: [^self].
	currentToken value <= 0 ifFalse: [^self].
	currentToken value = 0 
		ifTrue: 
			[(source notNil and: 
					[source notEmpty 
						and: [(source at: (currentToken start min: source size)) = $-]]) 
				ifFalse: [^self]].
	nextToken := currentToken.
	currentToken := RBBinarySelectorToken value: #- start: nextToken start.
	nextToken value: nextToken value negated.
	(nextToken isKindOf: RBNumberLiteralToken) 
		ifTrue: 
			[nextToken source: (nextToken source copyFrom: 2 to: nextToken source size)].
	nextToken start: nextToken start + 1
%

category: 'private-classes'
method: RBParser
pragmaNodeClass
	^ RBPragmaNode
%

category: 'private-classes'
method: RBParser
queryBlockNodeClass
  ^ RBQueryBlockNode
%

category: 'private-classes'
method: RBParser
returnNodeClass
	^ RBReturnNode
%

category: 'initialize-release'
method: RBParser
scanner: aScanner 
	scanner := aScanner.
	pragmas := nil.
	self initialize.
	self step
%

category: 'accessing'
method: RBParser
scannerClass
	^RBScanner
%

category: 'private-classes'
method: RBParser
sequenceNodeClass
	^ RBSequenceNode
%

category: 'private'
method: RBParser
step
	(currentToken notNil and: [currentToken comments notNil]) 
		ifTrue: [comments addAll: currentToken comments].
	nextToken notNil 
		ifTrue: 
			[currentToken := nextToken.
			nextToken := nil]
		ifFalse: [currentToken := scanner next]
%

category: 'private-classes'
method: RBParser
variableNodeClass
	^ RBVariableNode
%

! Class implementation for 'RBPatternParser'

!		Instance methods for 'RBPatternParser'

category: 'private-classes'
method: RBPatternParser
messageNodeClass
	^RBPatternMessageNode
%

category: 'private-classes'
method: RBPatternParser
methodNodeClass
	^RBPatternMethodNode
%

category: 'private-parsing'
method: RBPatternParser
parseLiteralByteArrayObject
	| node |
	(currentToken isIdentifier and: [currentToken isPatternVariable]) 
		ifTrue: 
			[node := self variableNodeClass identifierToken: currentToken.
			node isLiteralNode 
				ifTrue: 
					[self step.
					^node]].
	^super parseLiteralByteArrayObject
%

category: 'private-parsing'
method: RBPatternParser
parsePatternBlock: aClass 
	| position node |
	position := currentToken start.
	self step.
	node := self parseBlockArgsInto: aClass new.
	node left: position.
	node body: (self parseStatements: false).
	(currentToken isSpecial and: [currentToken value = $}]) 
		ifFalse: [self parserError: '''}'' expected'].
	node right: currentToken start.
	self step.
	^node
%

category: 'private-parsing'
method: RBPatternParser
parsePragmaLiteral
  | node |
  currentToken isPatternBlock
    ifTrue: [ ^ self parsePatternBlock: RBPatternBlockNode ].
  (currentToken isIdentifier and: [ currentToken isPatternVariable ])
    ifTrue: [ 
      node := self variableNodeClass identifierToken: currentToken.
      node isLiteralNode
        ifFalse: [ self error: 'Literal pattern expected' ].
      self step.
      currentToken isPatternBlock
        ifTrue: [ 
          node := (self parsePatternBlock: RBPatternWrapperBlockNode)
            wrappedNode: node;
            yourself ].
      ^ node ].
  ^ super parsePragmaLiteral
%

category: 'private-parsing'
method: RBPatternParser
parsePrimitiveLiteral
	| node |
	(currentToken isIdentifier and: [currentToken isPatternVariable]) 
		ifTrue: 
			[node := self variableNodeClass identifierToken: currentToken.
			node isLiteralNode 
				ifTrue: 
					[self step.
					^node].
			currentToken := RBLiteralToken 
						value: currentToken value asSymbol
						start: currentToken start
						stop: currentToken stop].
	^super parsePrimitiveLiteral
%

category: 'private-parsing'
method: RBPatternParser
parsePrimitiveObject
	currentToken isPatternBlock 
		ifTrue: [^self parsePatternBlock: RBPatternBlockNode].
	^super parsePrimitiveObject
%

category: 'private-parsing'
method: RBPatternParser
parseUnaryMessage
	| node |
	node := self parsePrimitiveObject.
	self addCommentsTo: node.
	
	[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].
	currentToken isPatternBlock 
		ifTrue: 
			[node := (self parsePatternBlock: RBPatternWrapperBlockNode)
						wrappedNode: node;
						yourself].
	currentToken isIdentifier] 
			whileTrue: [node := self parseUnaryMessageWith: node].
	self addCommentsTo: node.
	^node
%

category: 'private'
method: RBPatternParser
patchLiteralArrayToken
	(currentToken isIdentifier and: [currentToken isPatternVariable]) 
		ifTrue: [^self].
	super patchLiteralArrayToken
%

category: 'private-classes'
method: RBPatternParser
pragmaNodeClass
	^RBPatternPragmaNode
%

category: 'accessing'
method: RBPatternParser
scannerClass
	^RBPatternScanner
%

category: 'private-classes'
method: RBPatternParser
variableNodeClass
	^RBPatternVariableNode
%

! Class implementation for 'RBParseTreeRule'

!		Class methods for 'RBParseTreeRule'

category: 'instance creation'
classmethod: RBParseTreeRule
methodSearch: aString 
	^(self new)
		methodSearchString: aString;
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeRule
new

	^self basicNew initialize
%

category: 'instance creation'
classmethod: RBParseTreeRule
search: aString 
	^(self new)
		searchString: aString;
		yourself
%

!		Instance methods for 'RBParseTreeRule'

category: 'matching'
method: RBParseTreeRule
canMatch: aProgramNode 
	^true
%

category: 'private'
method: RBParseTreeRule
context
	^owner context
%

category: 'matching'
method: RBParseTreeRule
foundMatchFor: aProgramNode
	^aProgramNode
%

category: 'initialize-release'
method: RBParseTreeRule
initialize
%

category: 'initialize-release'
method: RBParseTreeRule
methodSearchString: aString 
	searchTree := RBParser parseRewriteMethod: aString
%

category: 'initialize-release'
method: RBParseTreeRule
owner: aParseTreeSearcher
	owner := aParseTreeSearcher
%

category: 'matching'
method: RBParseTreeRule
performOn: aProgramNode 
	self context empty.
	^((searchTree match: aProgramNode inContext: self context) 
		and: [self canMatch: aProgramNode]) 
			ifTrue: 
				[owner recusivelySearchInContext.
				self foundMatchFor: aProgramNode]
			ifFalse: [nil]
%

category: 'initialize-release'
method: RBParseTreeRule
searchString: aString 
	searchTree := RBParser parseRewriteExpression: aString
%

category: 'accessing'
method: RBParseTreeRule
sentMessages
	^searchTree sentMessages
%

! Class implementation for 'RBReplaceRule'

!		Instance methods for 'RBReplaceRule'

category: 'matching'
method: RBReplaceRule
canMatch: aProgramNode 
	^verificationBlock value: aProgramNode
%

category: 'matching'
method: RBReplaceRule
foundMatchFor: aProgramNode 
	self subclassResponsibility
%

category: 'initialize-release'
method: RBReplaceRule
initialize
	super initialize.
	verificationBlock := [:aNode | true]
%

category: 'matching'
method: RBReplaceRule
replace: aProgramNode with: newNode 
	aProgramNode replaceMethodSource: newNode
%

! Class implementation for 'RBBlockReplaceRule'

!		Class methods for 'RBBlockReplaceRule'

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchFor: searchString replaceWith: replaceBlock 
	^self new searchFor: searchString replaceWith: replaceBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchFor: searchString replaceWith: replaceBlock when: aBlock 
	^self new 
		searchFor: searchString
		replaceWith: replaceBlock
		when: aBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForMethod: searchString replaceWith: replaceBlock 
	^self new searchForMethod: searchString replaceWith: replaceBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForMethod: searchString replaceWith: replaceBlock when: aBlock 
	^self new 
		searchForMethod: searchString
		replaceWith: replaceBlock
		when: aBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceBlock 
	^self new searchForTree: aRBProgramNode replaceWith: replaceBlock
%

category: 'instance creation'
classmethod: RBBlockReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceBlock when: aBlock 
	^self new 
		searchForTree: aRBProgramNode
		replaceWith: replaceBlock
		when: aBlock
%

!		Instance methods for 'RBBlockReplaceRule'

category: 'matching'
method: RBBlockReplaceRule
foundMatchFor: aProgramNode 
	| newNode |
	newNode := replaceBlock value: aProgramNode.
	aProgramNode replaceMethodSource: newNode.
	^newNode
%

category: 'initialize-release'
method: RBBlockReplaceRule
initialize
	super initialize.
	replaceBlock := [:aNode | aNode]
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchFor: searchString replaceWith: aBlock 
	self searchString: searchString.
	replaceBlock := aBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchFor: searchString replaceWith: replBlock when: verifyBlock 
	self searchFor: searchString replaceWith: replBlock.
	verificationBlock := verifyBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForMethod: searchString replaceWith: aBlock 
	self methodSearchString: searchString.
	replaceBlock := aBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForMethod: searchString replaceWith: replBlock when: verifyBlock 
	self searchForMethod: searchString replaceWith: replBlock.
	verificationBlock := verifyBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForTree: aBRProgramNode replaceWith: aBlock 
	searchTree := aBRProgramNode.
	replaceBlock := aBlock
%

category: 'initialize-release'
method: RBBlockReplaceRule
searchForTree: aBRProgramNode replaceWith: replBlock when: verifyBlock 
	self searchForTree: aBRProgramNode replaceWith: replBlock.
	verificationBlock := verifyBlock
%

! Class implementation for 'RBStringReplaceRule'

!		Class methods for 'RBStringReplaceRule'

category: 'instance creation'
classmethod: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString 
	^self new searchFor: searchString replaceWith: replaceString
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString when: aBlock 
	^self new 
		searchFor: searchString
		replaceWith: replaceString
		when: aBlock
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString 
	^(self new)
		searchForMethod: searchString replaceWith: replaceString;
		yourself
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString when: aBlock 
	^self new 
		searchForMethod: searchString
		replaceWith: replaceString
		when: aBlock
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceString 
	^self new searchForTree: aRBProgramNode replaceWith: replaceString
%

category: 'instance creation'
classmethod: RBStringReplaceRule
searchForTree: aRBProgramNode replaceWith: replaceString when: aBlock 
	^self new 
		searchForTree: aRBProgramNode
		replaceWith: replaceString
		when: aBlock
%

!		Instance methods for 'RBStringReplaceRule'

category: 'matching'
method: RBStringReplaceRule
foundMatchFor: aProgramNode 
	| newNode |
	newNode := replaceTree copyInContext: self context.
	aProgramNode replaceMethodSource: newNode.
	newNode copyCommentsFrom: aProgramNode.
	^newNode
%

category: 'initialize-release'
method: RBStringReplaceRule
methodReplaceString: replaceString 
	replaceTree := RBParser parseRewriteMethod: replaceString
%

category: 'initialize-release'
method: RBStringReplaceRule
replaceString: replaceString 
	replaceTree := RBParser parseRewriteExpression: replaceString.
	searchTree isSequence = replaceTree isSequence 
		ifFalse: 
			[searchTree isSequence 
				ifTrue: [replaceTree := RBSequenceNode statements: (Array with: replaceTree)]
				ifFalse: [searchTree := RBSequenceNode statements: (Array with: searchTree)]]
%

category: 'initialize-release'
method: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString 
	self searchString: searchString.
	self replaceString: replaceString
%

category: 'initialize-release'
method: RBStringReplaceRule
searchFor: searchString replaceWith: replaceString when: aBlock 
	self searchFor: searchString replaceWith: replaceString.
	verificationBlock := aBlock
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString 
	self methodSearchString: searchString.
	self methodReplaceString: replaceString
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForMethod: searchString replaceWith: replaceString when: aBlock 
	self searchForMethod: searchString replaceWith: replaceString.
	verificationBlock := aBlock
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForTree: aBRProgramNode replaceWith: replaceNode 
	searchTree := aBRProgramNode.
	replaceTree := replaceNode
%

category: 'initialize-release'
method: RBStringReplaceRule
searchForTree: aBRProgramNode replaceWith: replaceString when: aBlock 
	self searchForTree: aBRProgramNode replaceWith: replaceString.
	verificationBlock := aBlock
%

! Class implementation for 'RBSearchRule'

!		Class methods for 'RBSearchRule'

category: 'instance creation'
classmethod: RBSearchRule
searchFor: aString thenDo: aBlock 
	^self new searchFor: aString thenDo: aBlock
%

category: 'instance creation'
classmethod: RBSearchRule
searchForMethod: aString thenDo: aBlock 
	^self new searchForMethod: aString thenDo: aBlock
%

category: 'instance creation'
classmethod: RBSearchRule
searchForTree: aBRProgramNode thenDo: aBlock 
	^self new searchForTree: aBRProgramNode thenDo: aBlock
%

!		Instance methods for 'RBSearchRule'

category: 'testing'
method: RBSearchRule
canMatch: aProgramNode 
	owner answer: (answerBlock value: aProgramNode value: owner answer).
	^true
%

category: 'initialize-release'
method: RBSearchRule
searchFor: aString thenDo: aBlock 
	self searchString: aString.
	answerBlock := aBlock
%

category: 'initialize-release'
method: RBSearchRule
searchForMethod: aString thenDo: aBlock 
	self methodSearchString: aString.
	answerBlock := aBlock
%

category: 'initialize-release'
method: RBSearchRule
searchForTree: aBRProgramNode thenDo: aBlock 
	searchTree := aBRProgramNode.
	answerBlock := aBlock
%

! Class implementation for 'RBProgramNode'

!		Class methods for 'RBProgramNode'

category: 'accessing'
classmethod: RBProgramNode
formatterClass
  ^ FormatterClass isNil
    ifTrue: [ RBConfigurableFormatter ]
    ifFalse: [ ^ Rowan globalNamed: FormatterClass name ]
%

category: 'accessing'
classmethod: RBProgramNode
formatterClass: aClass 
	FormatterClass := aClass
%

category: 'instance creation'
classmethod: RBProgramNode
new

	^self basicNew initialize
%

category: 'accessing'
classmethod: RBProgramNode
optimizedSelectors
	^ #( and: caseOf: caseOf:otherwise: ifFalse: ifFalse:ifTrue: ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: ifTrue: ifTrue:ifFalse: or: to:by:do: to:do: whileFalse whileFalse: whileTrue whileTrue: )
%

!		Instance methods for 'RBProgramNode'

category: 'visitor'
method: RBProgramNode
acceptVisitor: aProgramNodeVisitor 
	self subclassResponsibility
%

category: 'replacing'
method: RBProgramNode
addReplacement: aStringReplacement
	parent isNil ifTrue: [^self].
	parent addReplacement: aStringReplacement
%

category: 'accessing'
method: RBProgramNode
allArgumentVariables
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allArgumentVariables;
				yourself]
%

category: 'iterating'
method: RBProgramNode
allChildren
	| children |
	children := OrderedCollection new.
	self nodesDo: [ :each | children addLast: each ].
	^ children
%

category: 'accessing'
method: RBProgramNode
allDefinedVariables
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allDefinedVariables;
				yourself]
%

category: 'accessing'
method: RBProgramNode
allTemporaryVariables
	| children |
	children := self children.
	children isEmpty ifTrue: [^#()].
	^children inject: OrderedCollection new
		into: 
			[:vars :each | 
			vars
				addAll: each allTemporaryVariables;
				yourself]
%

category: 'accessing'
method: RBProgramNode
asReturn
	"Change the current node to a return node."

	parent isNil 
		ifTrue: [self error: 'Cannot change to a return without a parent node.'].
	parent isSequence 
		ifFalse: [self error: 'Parent node must be a sequence node.'].
	(parent isLast: self) ifFalse: [self error: 'Return node must be last.'].
	^parent addReturn
%

category: 'testing'
method: RBProgramNode
assigns: aVariableName 
	^self children anySatisfy: [:each | each assigns: aVariableName]
%

category: 'querying'
method: RBProgramNode
bestNodeFor: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	selectedChildren := self children 
				select: [:each | each intersectsInterval: anInterval].
	^selectedChildren size == 1 
		ifTrue: [selectedChildren first bestNodeFor: anInterval]
		ifFalse: [self]
%

category: 'accessing'
method: RBProgramNode
blockVariables
	^parent isNil ifTrue: [#()] ifFalse: [parent blockVariables]
%

category: 'testing-matching'
method: RBProgramNode
canMatchMethod: aCompiledMethod 
	^self sentMessages allSatisfy: 
			[:each | 
			(self class optimizedSelectors includes: each) 
				or: [aCompiledMethod refersToLiteral: each]]
%

category: 'meta variable-accessing'
method: RBProgramNode
cascadeListCharacter
	^$;
%

category: 'accessing'
method: RBProgramNode
children
	^#()
%

category: 'replacing'
method: RBProgramNode
clearReplacements
	parent isNil ifTrue: [^self].
	parent clearReplacements
%

category: 'enumeration'
method: RBProgramNode
collect: aBlock 
	"Hacked to fit collection protocols"

	^aBlock value: self
%

category: 'accessing'
method: RBProgramNode
comments
	"Answer the comments of the receiving parse tree node as intervals of starting and ending indices."
	
	^ comments isNil ifTrue: [ #() ] ifFalse: [ comments ]
%

category: 'accessing'
method: RBProgramNode
comments: aCollection
	comments := aCollection
%

category: 'testing'
method: RBProgramNode
containedBy: anInterval 
	^anInterval first <= self start and: [anInterval last >= self stop]
%

category: 'testing'
method: RBProgramNode
containsReturn
	^self children anySatisfy: [:each | each containsReturn]
%

category: 'copying'
method: RBProgramNode
copyCommentsFrom: aNode 
	"Add all comments from aNode to us. If we already have the comment, then don't add it."

	| newComments |
	newComments := OrderedCollection new.
	aNode nodesDo: [:each | newComments addAll: each comments].
	self nodesDo: 
			[:each | 
			each comments do: [:comment | newComments remove: comment ifAbsent: []]].
	newComments isEmpty ifTrue: [^self].
	newComments := newComments asSortedCollection: [:a :b | a first < b first].
	self comments: newComments
%

category: 'matching'
method: RBProgramNode
copyInContext: aDictionary
	^ self copy
%

category: 'matching'
method: RBProgramNode
copyList: matchNodes inContext: aDictionary 
	| newNodes |
	newNodes := OrderedCollection new.
	matchNodes do: 
			[:each | 
			| object |
			object := each copyInContext: aDictionary.
			newNodes addAll: object].
	^newNodes
%

category: 'testing'
method: RBProgramNode
defines: aName
	^false
%

category: 'testing'
method: RBProgramNode
directlyUses: aNode
	^true
%

category: 'enumeration'
method: RBProgramNode
do: aBlock 
	"Hacked to fit collection protocols"

	aBlock value: self
%

category: 'comparing'
method: RBProgramNode
equalTo: aNode exceptForVariables: variableNameCollection 
	| dictionary |
	dictionary := Dictionary new.
	(self equalTo: aNode withMapping: dictionary) ifFalse: [^false].
	dictionary keysAndValuesDo: 
			[:key :value | 
			(key = value or: [variableNameCollection includes: key]) ifFalse: [^false]].
	^true
%

category: 'comparing'
method: RBProgramNode
equalTo: aNode withMapping: aDictionary 
	^self = aNode
%

category: 'testing'
method: RBProgramNode
evaluatedFirst: aNode 
	self children do: 
			[:each | 
			each == aNode ifTrue: [^true].
			each isImmediateNode ifFalse: [^false]].
	^false
%

category: 'accessing'
method: RBProgramNode
formattedCode
	^ self formatterClass new format: self
%

category: 'accessing'
method: RBProgramNode
formatterClass
	^ self class formatterClass
%

category: 'comparing'
method: RBProgramNode
hashForCollection: aCollection
	^ aCollection isEmpty ifTrue: [ 0 ] ifFalse: [ aCollection first hash ]
%

category: 'testing'
method: RBProgramNode
hasMultipleReturns
	| count |
	count := 0.
	self nodesDo: [:each | each isReturn ifTrue: [count := count + 1]].
	^count > 1
%

category: 'properties'
method: RBProgramNode
hasProperty: aKey
	"Test if the property aKey is present."
	
	^ properties notNil and: [ properties includesKey: aKey ]
%

category: 'initialize release'
method: RBProgramNode
initialize
%

category: 'testing'
method: RBProgramNode
intersectsInterval: anInterval 
	^(anInterval first between: self start and: self stop) 
		or: [self start between: anInterval first and: anInterval last]
%

category: 'testing'
method: RBProgramNode
isArray
	^ false
%

category: 'testing'
method: RBProgramNode
isAssignment
	^false
%

category: 'testing'
method: RBProgramNode
isBlock
	^false
%

category: 'testing'
method: RBProgramNode
isCascade
	^false
%

category: 'testing'
method: RBProgramNode
isDirectlyUsed
	"This node is directly used as an argument, receiver, or part of an assignment."

	^parent isNil ifTrue: [false] ifFalse: [parent directlyUses: self]
%

category: 'testing'
method: RBProgramNode
isEvaluatedFirst
	"Return true if we are the first thing evaluated in this statement."

	^parent isNil or: [parent isSequence or: [parent evaluatedFirst: self]]
%

category: 'deprecated'
method: RBProgramNode
isImmediate
	^self isImmediateNode
%

category: 'testing'
method: RBProgramNode
isImmediateNode
	^false
%

category: 'testing'
method: RBProgramNode
isLast: aNode 
	| children |
	children := self children.
	^children notEmpty and: [children last == aNode]
%

category: 'testing-matching'
method: RBProgramNode
isList
	^false
%

category: 'deprecated'
method: RBProgramNode
isLiteral
	^self isLiteralNode
%

category: 'testing'
method: RBProgramNode
isLiteralArray
	^false
%

category: 'testing'
method: RBProgramNode
isLiteralNode
	^false
%

category: 'testing'
method: RBProgramNode
isMessage
	^false
%

category: 'testing'
method: RBProgramNode
isMethod
	^false
%

category: 'testing-matching'
method: RBProgramNode
isPatternNode
	^false
%

category: 'testing'
method: RBProgramNode
isPragma
	^false
%

category: 'testing'
method: RBProgramNode
isReturn
	^false
%

category: 'testing'
method: RBProgramNode
isSequence
	^false
%

category: 'testing'
method: RBProgramNode
isUsed
	"Answer true if this node could be used as part of another expression. For example, you could use the 
	result of this node as a receiver of a message, an argument, the right part of an assignment, or the 
	return value of a block. This differs from isDirectlyUsed in that it is conservative since it also includes 
	return values of blocks."

	^parent isNil ifTrue: [false] ifFalse: [parent uses: self]
%

category: 'testing'
method: RBProgramNode
isValue
	^false
%

category: 'testing'
method: RBProgramNode
isVariable
	^false
%

category: 'testing'
method: RBProgramNode
lastIsReturn
	^self isReturn
%

category: 'meta variable-accessing'
method: RBProgramNode
listCharacter
	^$@
%

category: 'meta variable-accessing'
method: RBProgramNode
literalCharacter
	^$#
%

category: 'accessing'
method: RBProgramNode
mappingFor: aNode
	| method |
	method := self methodNode.
	method isNil ifTrue: [^aNode].
	^method mappingFor: aNode
%

category: 'matching'
method: RBProgramNode
match: aNode inContext: aDictionary 
	^ self = aNode
%

category: 'matching'
method: RBProgramNode
matchList: matchNodes against: programNodes inContext: aDictionary 
	^self
		matchList: matchNodes
		index: 1
		against: programNodes
		index: 1
		inContext: aDictionary
%

category: 'matching'
method: RBProgramNode
matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 
	| node currentIndex currentDictionary nodes |
	matchNodes size < matchIndex ifTrue: [^programNodes size < programIndex].
	node := matchNodes at: matchIndex.
	node isList 
		ifTrue: 
			[currentIndex := programIndex - 1.
			
			[currentDictionary := aDictionary copy.
			programNodes size < currentIndex or: 
					[nodes := programNodes copyFrom: programIndex to: currentIndex.
					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 
							[(self 
								matchList: matchNodes
								index: matchIndex + 1
								against: programNodes
								index: currentIndex + 1
								inContext: currentDictionary) 
									ifTrue: 
										[currentDictionary 
											keysAndValuesDo: [:key :value | aDictionary at: key put: value].
										^true].
							false]]] 
					whileFalse: [currentIndex := currentIndex + 1].
			^false].
	programNodes size < programIndex ifTrue: [^false].
	(node match: (programNodes at: programIndex) inContext: aDictionary) 
		ifFalse: [^false].
	^self 
		matchList: matchNodes
		index: matchIndex + 1
		against: programNodes
		index: programIndex + 1
		inContext: aDictionary
%

category: 'accessing'
method: RBProgramNode
methodComments
	^self comments
%

category: 'accessing'
method: RBProgramNode
methodNode
	^parent isNil ifTrue: [nil] ifFalse: [parent methodNode]
%

category: 'accessing'
method: RBProgramNode
newSource
	^self formattedCode
%

category: 'iterating'
method: RBProgramNode
nodesDo: aBlock 
	aBlock value: self.
	self children do: [ :each | each nodesDo: aBlock ]
%

category: 'accessing'
method: RBProgramNode
parent
	^parent
%

category: 'accessing'
method: RBProgramNode
parent: aRBProgramNode 
	parent := aRBProgramNode
%

category: 'accessing'
method: RBProgramNode
parents
	^ parent isNil
		ifTrue: [ OrderedCollection with: self ]
		ifFalse: [ 
			parent parents
				addLast: self;
				yourself ]
%

category: 'copying'
method: RBProgramNode
postCopy
	super postCopy.
	properties := properties copy
%

category: 'accessing'
method: RBProgramNode
precedence
	^6
%

category: 'printing'
method: RBProgramNode
printOn: aStream 
	aStream
		nextPutAll: self class name;
		nextPut: $(;
		nextPutAll: self formattedCode;
		nextPut: $)
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey
	"Answer the property value associated with aKey."
	
	^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey ifAbsent: aBlock
	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."
	
	^ properties isNil
		ifTrue: [ aBlock value ]
		ifFalse: [ properties at: aKey ifAbsent: aBlock ]
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey ifAbsentPut: aBlock
	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."
	
	^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]
%

category: 'properties'
method: RBProgramNode
propertyAt: aKey put: anObject
	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."

	^ (properties ifNil: [ properties := RBSmallDictionary new: 1 ])
		at: aKey put: anObject
%

category: 'testing-matching'
method: RBProgramNode
recurseInto
	^false
%

category: 'meta variable-accessing'
method: RBProgramNode
recurseIntoCharacter
	^$`
%

category: 'testing'
method: RBProgramNode
references: aVariableName 
	^self children anySatisfy: [:each | each references: aVariableName]
%

category: 'replacing'
method: RBProgramNode
removeDeadCode
	self children do: [:each | each removeDeadCode]
%

category: 'properties'
method: RBProgramNode
removeProperty: aKey
	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."
	
	^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ].
%

category: 'properties'
method: RBProgramNode
removeProperty: aKey ifAbsent: aBlock
	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."
	
	| answer |
	properties isNil ifTrue: [ ^ aBlock value ].
	answer := properties removeKey: aKey ifAbsent: aBlock.
	properties isEmpty ifTrue: [ properties := nil ].
	^ answer
%

category: 'replacing'
method: RBProgramNode
replaceMethodSource: aNode 
	"We are being replaced with aNode -- if possible try to perform an in place edit of the source."

	| method |
	method := self methodNode.
	method notNil ifTrue: [method map: self to: aNode].
	aNode parent: self parent.
	[self replaceSourceWith: aNode] on: Error
		do: 
			[:ex | 
			self clearReplacements.
			ex return]
%

category: 'replacing'
method: RBProgramNode
replaceNode: aNode withNode: anotherNode 
	self error: 'I don''t store other nodes'
%

category: 'private-replacing'
method: RBProgramNode
replaceSourceFrom: aNode
	self == aNode
		ifFalse: [ self clearReplacements ]
%

category: 'private-replacing'
method: RBProgramNode
replaceSourceWith: aNode 
	aNode replaceSourceFrom: self
%

category: 'replacing'
method: RBProgramNode
replaceWith: aNode 
	parent isNil ifTrue: [self error: 'This node doesn''t have a parent'].
	self replaceMethodSource: aNode.
	parent replaceNode: self withNode: aNode
%

category: 'querying'
method: RBProgramNode
selfMessages
	| searcher |
	searcher := RBParseTreeSearcher new.
	searcher matches: 'self `@msg: ``@args'
		do: 
			[:aNode :answer | 
			answer
				add: aNode selector;
				yourself].
	^searcher executeTree: self initialAnswer: Set new
%

category: 'accessing'
method: RBProgramNode
sentMessages
	^ self children
		inject: Set new
		into: [ :messages :each | 
			messages
				addAll: each sentMessages;
				yourself ]
%

category: 'enumeration'
method: RBProgramNode
size
	"Hacked to fit collection protocols"

	^1
%

category: 'accessing'
method: RBProgramNode
source
	^parent notNil ifTrue: [parent source] ifFalse: [nil]
%

category: 'accessing'
method: RBProgramNode
sourceInterval
	^self start to: self stop
%

category: 'accessing'
method: RBProgramNode
start
	self subclassResponsibility
%

category: 'meta variable-accessing'
method: RBProgramNode
statementCharacter
	^$.
%

category: 'accessing'
method: RBProgramNode
statementComments
	| statementComments |
	statementComments := OrderedCollection withAll: self comments.
	self children do: [:each | statementComments addAll: each statementComments].
	^statementComments asSortedCollection: [:a :b | a first < b first]
%

category: 'querying'
method: RBProgramNode
statementNode
	"Return your topmost node that is contained by a sequence node."

	(parent isNil or: [parent isSequence]) ifTrue: [^self].
	^parent statementNode
%

category: 'accessing'
method: RBProgramNode
stop
	self subclassResponsibility
%

category: 'querying'
method: RBProgramNode
superMessages
	| searcher |
	searcher := RBParseTreeSearcher new.
	searcher matches: 'super `@msg: ``@args'
		do: 
			[:aNode :answer | 
			answer
				add: aNode selector;
				yourself].
	^searcher executeTree: self initialAnswer: Set new
%

category: 'accessing'
method: RBProgramNode
temporaryVariables
	^parent isNil ifTrue: [#()] ifFalse: [parent temporaryVariables]
%

category: 'testing'
method: RBProgramNode
uses: aNode
	^true
%

category: 'querying'
method: RBProgramNode
whichNodeIsContainedBy: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	selectedChildren := self children 
				select: [:each | each intersectsInterval: anInterval].
	^selectedChildren size == 1 
		ifTrue: [selectedChildren first whichNodeIsContainedBy: anInterval]
		ifFalse: [nil]
%

category: 'querying'
method: RBProgramNode
whoDefines: aName 
	^(self defines: aName) 
		ifTrue: [self]
		ifFalse: [parent notNil ifTrue: [parent whoDefines: aName] ifFalse: [nil]]
%

! Class implementation for 'RBMethodNode'

!		Class methods for 'RBMethodNode'

category: 'instance creation'
classmethod: RBMethodNode
selector: aSymbol arguments: variableNodes body: aSequenceNode 
	^(self new)
		arguments: variableNodes;
		selector: aSymbol;
		body: aSequenceNode;
		yourself
%

category: 'instance creation'
classmethod: RBMethodNode
selector: aSymbol body: aSequenceNode 
	^self 
		selector: aSymbol
		arguments: #()
		body: aSequenceNode
%

category: 'instance creation'
classmethod: RBMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	^(self new)
		selectorParts: tokenCollection arguments: variableNodes;
		yourself
%

!		Instance methods for 'RBMethodNode'

category: 'comparing'
method: RBMethodNode
= anObject 
	self == anObject ifTrue: [ ^ true ].
	self class = anObject class ifFalse: [ ^ false ].
	(self selector = anObject selector
		and: [ self pragmas size = anObject pragmas size
		and: [ self body = anObject body ] ])
			ifFalse: [ ^ false ].
	self arguments with: anObject arguments do: [ :first :second |
		first = second 
			ifFalse: [ ^ false ] ].
	self pragmas with: anObject pragmas do: [ :first :second |
		first = second 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'visitor'
method: RBMethodNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptMethodNode: self
%

category: 'accessing'
method: RBMethodNode
addNode: aNode
	^ body addNode: aNode
%

category: 'replacing'
method: RBMethodNode
addReplacement: aStringReplacement 
	replacements isNil ifTrue: [^self].
	replacements add: aStringReplacement
%

category: 'accessing'
method: RBMethodNode
addReturn
	^ body addReturn
%

category: 'accessing'
method: RBMethodNode
addSelfReturn
	^ body addSelfReturn
%

category: 'accessing'
method: RBMethodNode
allArgumentVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allArgumentVariables;
		yourself
%

category: 'accessing'
method: RBMethodNode
allDefinedVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allDefinedVariables;
		yourself
%

category: 'accessing'
method: RBMethodNode
argumentNames
	^self arguments collect: [:each | each name]
%

category: 'accessing'
method: RBMethodNode
arguments
	^arguments
%

category: 'accessing'
method: RBMethodNode
arguments: variableNodes 
	arguments := variableNodes.
	arguments do: [:each | each parent: self]
%

category: 'accessing'
method: RBMethodNode
body
	^body
%

category: 'accessing'
method: RBMethodNode
body: stmtsNode 
	body := stmtsNode.
	body parent: self
%

category: 'private'
method: RBMethodNode
buildSelector
	| selectorStream |
	selectorStream := WriteStreamPortable on: String new.
	selectorParts do: [:each | selectorStream nextPutAll: each value].
	^selectorStream contents asSymbol
%

category: 'private-replacing'
method: RBMethodNode
changeSourceSelectors: oldSelectorParts arguments: oldArguments
	"If this is the same number of arguments, we try a one to one replacement of selector parts and arguments. If this is not the case try to rewrite the signature as a whole, what unfortunately drops the comments within the signature."
	
	[ (oldSelectorParts size = selectorParts size and: [ oldArguments size = arguments size ])
		ifTrue: [
			oldSelectorParts with: selectorParts do: [ :old :new | 
				self addReplacement: (RBStringReplacement 
					replaceFrom: old start
					to: old stop
					with: new value) ].
			oldArguments with: arguments do: [ :old :new | 
				self addReplacement: (RBStringReplacement 
					replaceFrom: old start
					to: old stop
					with: new name) ] ]
		ifFalse: [
			self addReplacement: (RBStringReplacement
				replaceFrom: oldSelectorParts first start
				to: (oldArguments notEmpty
					ifTrue: [ oldArguments last stop ]
					ifFalse: [ oldSelectorParts last stop ])
				with: (String streamContents: [ :stream |
					selectorParts keysAndValuesDo: [ :index :part |
						index = 1 ifFalse: [ stream space ].
						stream nextPutAll: part value.
						index <= arguments size
							ifTrue: [ stream space; nextPutAll: (arguments at: index) name ] ] ])) ] ]
		on: Error
		do: [ :ex | ex return ]
%

category: 'accessing'
method: RBMethodNode
children
	^ OrderedCollection new
		addAll: self arguments;
		addAll: self pragmas;
		add: self body;
		yourself
%

category: 'replacing'
method: RBMethodNode
clearReplacements
	replacements := nil
%

category: 'matching'
method: RBMethodNode
copyInContext: aDictionary
	^ self class new
		selectorParts: (self selectorParts collect: [ :each | each copy removePositions ]);
		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);
		pragmas: (self pragmas isEmpty
			ifTrue: [ aDictionary at: '-pragmas-' ifAbsent: [ #() ] ]
			ifFalse: [ self copyList: self pragmas inContext: aDictionary ]);
		body: (self body copyInContext: aDictionary);
		source: (aDictionary at: '-source-' ifAbsentPut: [ self source ]);
		yourself
%

category: 'testing'
method: RBMethodNode
defines: aName 
	^arguments anySatisfy: [:each | each name = aName]
%

category: 'comparing'
method: RBMethodNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [ ^ false ].
	(self selector = anObject selector
		and: [ self pragmas size = anObject pragmas size
		and: [ self body equalTo: anObject body withMapping: aDictionary ] ]) 
			ifFalse: [ ^ false ].
	self arguments with: anObject arguments do: [ :first :second |
		(first equalTo: second	withMapping: aDictionary)
			ifFalse: [ ^ false ].
		aDictionary removeKey: first name ].
	self pragmas with: anObject pragmas do: [ :first :second |
		(first equalTo: second	withMapping: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'comparing'
method: RBMethodNode
hash
	^ ((self selector hash bitXor: (self hashForCollection: self arguments)) bitXor: (self hashForCollection: self pragmas)) bitXor: self body hash
%

category: 'initialize-release'
method: RBMethodNode
initialize
	replacements := SortedCollection sortBlock: 
					[:a :b | 
					a startPosition < b startPosition 
						or: [a startPosition = b startPosition and: [a stopPosition < b stopPosition]]].
	nodeReplacements := IdentityDictionary new
%

category: 'testing'
method: RBMethodNode
isLast: aNode 
	^body isLast: aNode
%

category: 'testing'
method: RBMethodNode
isMethod
	^true
%

category: 'testing'
method: RBMethodNode
isPrimitive
	^ self pragmas anySatisfy: [ :each | each isPrimitive ]
%

category: 'testing'
method: RBMethodNode
lastIsReturn
	^body lastIsReturn
%

category: 'replacing'
method: RBMethodNode
map: oldNode to: newNode 
	nodeReplacements at: oldNode put: newNode
%

category: 'replacing'
method: RBMethodNode
mappingFor: oldNode 
	^nodeReplacements at: oldNode ifAbsent: [oldNode]
%

category: 'matching'
method: RBMethodNode
match: aNode inContext: aDictionary 
	self class = aNode class ifFalse: [ ^ false ].
	aDictionary at: '-source-' put: aNode source.
	self selector = aNode selector ifFalse: [ ^ false ].
	^ (self matchList: arguments against: aNode arguments inContext: aDictionary)
		and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)
		and: [ body match: aNode body inContext: aDictionary ] ]
%

category: 'matching'
method: RBMethodNode
matchPragmas: matchNodes against: pragmaNodes inContext: aDictionary
	matchNodes isEmpty ifTrue: [ 
		aDictionary at: '-pragmas-' put: pragmaNodes.
		^ true ].
	^ matchNodes allSatisfy: [ :matchNode |
		pragmaNodes anySatisfy: [ :pragmaNode |
			matchNode match: pragmaNode inContext: aDictionary ] ]
%

category: 'accessing'
method: RBMethodNode
methodComments
	| methodComments |
	methodComments := OrderedCollection withAll: self comments.
	arguments do: [:each | methodComments addAll: each comments].
	^methodComments asSortedCollection: [:a :b | a first < b first]
%

category: 'accessing'
method: RBMethodNode
methodNode
	^self
%

category: 'accessing'
method: RBMethodNode
newSource
	replacements isNil ifTrue: [^self formattedCode].
	^[self reformatSource] on: Error do: [:ex | ex return: self formattedCode]
%

category: 'accessing'
method: RBMethodNode
numArgs
	^self selector numArgs
%

category: 'copying'
method: RBMethodNode
postCopy
	super postCopy.
	self arguments: (self arguments collect: [ :each | each copy ]).
	self pragmas: (self pragmas collect: [ :each | each copy ]).
	self body: self body copy
%

category: 'accessing'
method: RBMethodNode
pragmas
	^ pragmas ifNil: [ #() ]
%

category: 'accessing'
method: RBMethodNode
pragmas: aCollection
	pragmas := aCollection.
	pragmas do: [ :each | each parent: self ]
%

category: 'accessing'
method: RBMethodNode
primitiveSources
	^ self pragmas collect: [ :each | self source copyFrom: each first to: each last ]
%

category: 'printing'
method: RBMethodNode
printOn: aStream 
	aStream nextPutAll: self formattedCode
%

category: 'testing'
method: RBMethodNode
references: aVariableName 
	^body references: aVariableName
%

category: 'private'
method: RBMethodNode
reformatSource
	| stream newSource newTree |
	stream := WriteStreamPortable on: String new.
	stream
		nextPutAll: (source
			copyFrom: (replacements
				inject: 1
				into: [ :sum :each | 
					stream
						nextPutAll: (source copyFrom: sum to: each startPosition - 1);
						nextPutAll: (each string).
					each stopPosition + 1 ])
			to: source size).
	newSource := stream contents.
	newTree := RBParser 
		parseMethod: newSource 
		onError: [ :msg :pos | ^ self formattedCode ].
	self = newTree
		ifFalse: [ ^ self formattedCode ].
	^ newSource
%

category: 'accessing'
method: RBMethodNode
renameSelector: newSelector andArguments: varNodeCollection 
	| oldSelectorParts oldArguments |
	oldSelectorParts := selectorParts.
	oldArguments := arguments.
	self
		arguments: varNodeCollection;
		selector: newSelector.
	self changeSourceSelectors: oldSelectorParts arguments: oldArguments
%

category: 'replacing'
method: RBMethodNode
replaceNode: aNode withNode: anotherNode 
	aNode == body ifTrue: [self body: anotherNode].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'accessing'
method: RBMethodNode
selector
	^selector isNil
		ifTrue: [selector := self buildSelector]
		ifFalse: [selector]
%

category: 'accessing'
method: RBMethodNode
selector: aSelector 
	| keywords numArgs |
	keywords := aSelector keywords.
	numArgs := aSelector numArgs.
	numArgs == arguments size 
		ifFalse: 
			[self 
				error: 'Attempting to assign selector with wrong number of arguments.'].
	selectorParts := numArgs == 0 
				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]
				ifFalse: 
					[keywords first last = $: 
						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]
						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].
	selector := aSelector asSymbol
%

category: 'private'
method: RBMethodNode
selectorParts
	^selectorParts
%

category: 'private'
method: RBMethodNode
selectorParts: tokenCollection 
	selectorParts := tokenCollection
%

category: 'initialize-release'
method: RBMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	selectorParts := tokenCollection.
	self arguments: variableNodes
%

category: 'accessing'
method: RBMethodNode
source
	^source
%

category: 'accessing'
method: RBMethodNode
source: anObject
	source := anObject
%

category: 'accessing'
method: RBMethodNode
start
	^1
%

category: 'accessing'
method: RBMethodNode
stop
	^source size
%

category: 'testing'
method: RBMethodNode
uses: aNode 
	^body == aNode and: [aNode lastIsReturn]
%

! Class implementation for 'RBPatternMethodNode'

!		Class methods for 'RBPatternMethodNode'

category: 'instance creation'
classmethod: RBPatternMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	^(tokenCollection anySatisfy: [:each | each isPatternVariable]) 
		ifTrue: [super selectorParts: tokenCollection arguments: variableNodes]
		ifFalse: 
			[RBMethodNode selectorParts: tokenCollection arguments: variableNodes]
%

!		Instance methods for 'RBPatternMethodNode'

category: 'matching'
method: RBPatternMethodNode
copyInContext: aDictionary 
	| selectors |
	selectors := self isSelectorList 
		ifTrue: [ (aDictionary at: selectorParts first value) keywords ]
		ifFalse: [ self selectorParts collect: [ :each | aDictionary at: each value ] ].
	^ RBMethodNode new
		selectorParts: (selectors collect: [ :each | 
			(each last = $: ifTrue: [ RBKeywordToken ] ifFalse: [ RBIdentifierToken ]) 
				value: each start: nil ]);
		arguments: (self copyList: self arguments inContext: aDictionary);
		pragmas: (self pragmas isEmpty
			ifTrue: [ aDictionary at: '-pragmas-' ifAbsent: [ #() ] ]
			ifFalse: [ self copyList: self pragmas inContext: aDictionary ]);
		body: (self body copyInContext: aDictionary);
		source: (aDictionary at: '-source-');
		yourself
%

category: 'testing-matching'
method: RBPatternMethodNode
isPatternNode
	^true
%

category: 'testing'
method: RBPatternMethodNode
isSelectorList
	^isList
%

category: 'matching'
method: RBPatternMethodNode
match: aNode inContext: aDictionary 
	aNode class = self matchingClass 
		ifFalse: [ ^ false ].
	aDictionary at: '-source-' put: aNode source.
	self isSelectorList ifTrue: [
		^ (aDictionary at: selectorParts first value ifAbsentPut: [ aNode selector ]) = aNode selector
			and: [ (aDictionary at: arguments first ifAbsentPut: [ aNode arguments ]) = aNode arguments
			and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)
			and: [ body match: aNode body inContext: aDictionary ] ] ] ].
	^(self matchArgumentsAgainst: aNode inContext: aDictionary) 
		and: [ (self matchPragmas: self pragmas against: aNode pragmas inContext: aDictionary)
		and: [ body match: aNode body inContext: aDictionary ] ]
%

category: 'matching'
method: RBPatternMethodNode
matchArgumentsAgainst: aNode inContext: aDictionary 
	self arguments size = aNode arguments size
		ifFalse: [ ^ false ].
	(self matchSelectorAgainst: aNode inContext: aDictionary) 
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'private'
method: RBPatternMethodNode
matchingClass
	^RBMethodNode
%

category: 'matching'
method: RBPatternMethodNode
matchSelectorAgainst: aNode inContext: aDictionary 
	self selectorParts with: aNode selectorParts do: [ :first :second |
		| keyword |
		keyword := aDictionary
			at: first value
			ifAbsentPut: [ 
				first isPatternVariable 
					ifTrue: [ second value ]
					ifFalse: [ first value ] ].
		keyword = second value 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'initialize-release'
method: RBPatternMethodNode
selectorParts: tokenCollection arguments: variableNodes 
	super selectorParts: tokenCollection arguments: variableNodes.
	isList := (tokenCollection first value at: 2) == self listCharacter
%

! Class implementation for 'RBPragmaNode'

!		Class methods for 'RBPragmaNode'

category: 'instance creation'
classmethod: RBPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	^ self new selectorParts: keywordTokens arguments: valueNodes
%

!		Instance methods for 'RBPragmaNode'

category: 'comparing'
method: RBPragmaNode
= anObject
  self == anObject
    ifTrue: [ ^ true ].
  self class = anObject class
    ifFalse: [ ^ false ].
  self selector = anObject selector
    ifFalse: [ ^ false ].
  1 to: self arguments size do: [ :i | 
    (self arguments at: i) = (anObject arguments at: i)
      ifFalse: [ ^ false ] ].
  self isProtected == anObject isProtected
    ifFalse: [ ^ false ].
  ^ true
%

category: 'visitor'
method: RBPragmaNode
acceptVisitor: aProgramNodeVisitor 
	^ aProgramNodeVisitor acceptPragmaNode: self
%

category: 'accessing'
method: RBPragmaNode
arguments
	^ arguments ifNil: [ #() ]
%

category: 'accessing'
method: RBPragmaNode
arguments: aLiteralCollection 
	arguments := aLiteralCollection.
	arguments do: [ :each | each parent: self ]
%

category: 'private'
method: RBPragmaNode
buildSelector
	| selectorStream |
	selectorStream := WriteStreamPortable on: String new.
	selectorParts do: [ :each | selectorStream nextPutAll: each value ].
	^ selectorStream contents asSymbol
%

category: 'accessing'
method: RBPragmaNode
children
	^ self arguments
%

category: 'matching'
method: RBPragmaNode
copyInContext: aDictionary 
	^ self class new
		selectorParts: (self selectorParts collect: [ :each | each copy removePositions ]);
		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);
		yourself
%

category: 'comparing'
method: RBPragmaNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [ ^ false ].
	self selector = anObject selector ifFalse: [ ^ false ].
	self arguments with: anObject arguments do: [ :first :second |
		(first equalTo: second withMapping: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'comparing'
method: RBPragmaNode
hash
	^ self selector hash bitXor: (self hashForCollection: self arguments)
%

category: 'testing'
method: RBPragmaNode
isBinary
	^ (self isUnary or: [self isKeyword]) not
%

category: 'testing'
method: RBPragmaNode
isKeyword
	^ selectorParts first value last = $:
%

category: 'testing'
method: RBPragmaNode
isPragma
	^ true
%

category: 'testing'
method: RBPragmaNode
isPrimitive
	^ #(primitive: primitive:error: primitive:error:module: primitive:module: primitive:module:error:) includes: self selector
%

category: 'testing'
method: RBPragmaNode
isProtected
  isProtected ifNil: [ ^ false ].
  ^ isProtected
%

category: 'testing'
method: RBPragmaNode
isProtected: aBool
  isProtected := aBool
%

category: 'testing'
method: RBPragmaNode
isProtectedPrimitive
  ^ self isProtected and: [ self isPrimitive ]
%

category: 'testing'
method: RBPragmaNode
isUnary
	^ arguments isEmpty
%

category: 'accessing-token'
method: RBPragmaNode
left
	^ left
%

category: 'accessing-token'
method: RBPragmaNode
left: anInteger
	left := anInteger
%

category: 'matching'
method: RBPragmaNode
match: aNode inContext: aDictionary 
	aNode class = self class
		ifFalse: [ ^ false ].
	self selector = aNode selector
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary)
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'accessing'
method: RBPragmaNode
numArgs
	^ self selector numArgs
%

category: 'copying'
method: RBPragmaNode
postCopy
	super postCopy.
	self arguments: (self arguments collect: [ :each | each copy ])
%

category: 'replacing'
method: RBPragmaNode
replaceNode: aNode withNode: anotherNode 
	self arguments: (arguments collect: [ :each | 
		each == aNode 
			ifTrue: [ anotherNode ]
			ifFalse: [ each ] ])
%

category: 'accessing-token'
method: RBPragmaNode
right
	^ right
%

category: 'accessing-token'
method: RBPragmaNode
right: anInteger
	right := anInteger
%

category: 'accessing'
method: RBPragmaNode
selector
	^ selector ifNil: [ selector := self buildSelector ]
%

category: 'accessing'
method: RBPragmaNode
selector: aSelector 
	| keywords numArgs |
	keywords := aSelector keywords.
	numArgs := aSelector numArgs.
	numArgs == arguments size 
		ifFalse: 
			[self 
				error: 'Attempting to assign selector with wrong number of arguments.'].
	selectorParts := numArgs == 0 
				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]
				ifFalse: 
					[keywords first last = $: 
						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]
						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].
	selector := aSelector asSymbol
%

category: 'private'
method: RBPragmaNode
selectorParts
	^ selectorParts
%

category: 'private'
method: RBPragmaNode
selectorParts: tokenCollection 
	selectorParts := tokenCollection
%

category: 'initialization'
method: RBPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	self selectorParts: keywordTokens.
	self arguments: valueNodes
%

category: 'accessing'
method: RBPragmaNode
sentMessages
	^ super sentMessages
		add: self selector;
		yourself
%

category: 'accessing'
method: RBPragmaNode
start
	^ left
%

category: 'accessing'
method: RBPragmaNode
stop
	^ right
%

! Class implementation for 'RBPatternPragmaNode'

!		Class methods for 'RBPatternPragmaNode'

category: 'instance creation'
classmethod: RBPatternPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	^ (keywordTokens anySatisfy: [ :each | each isPatternVariable ]) 
		ifTrue: [ super selectorParts: keywordTokens arguments: valueNodes ]
		ifFalse: [ RBPragmaNode selectorParts: keywordTokens arguments: valueNodes ]
%

!		Instance methods for 'RBPatternPragmaNode'

category: 'matching'
method: RBPatternPragmaNode
copyInContext: aDictionary 
	| selectors |
	selectors := self isSelectorList 
		ifTrue: [ (aDictionary at: selectorParts first value) keywords ]
		ifFalse: [ self selectorParts collect: [ :each | aDictionary at: each value ] ].
	^ RBPragmaNode new
		selectorParts: (selectors collect: [ :each | 
			(each last = $: ifTrue: [ RBKeywordToken ] ifFalse: [ RBIdentifierToken ]) 
				value: each start: nil ]);
		arguments: (self copyList: self arguments inContext: aDictionary);
		yourself
%

category: 'testing-matching'
method: RBPatternPragmaNode
isPatternNode
	^ true
%

category: 'testing-matching'
method: RBPatternPragmaNode
isSelectorList
	^ isList
%

category: 'matching'
method: RBPatternPragmaNode
match: aNode inContext: aDictionary
	aNode class = self matchingClass
		ifFalse: [ ^ false ].
	self isSelectorList ifTrue: [
		^ (aDictionary at: selectorParts first value ifAbsentPut: [ aNode selector ]) = aNode selector
			and: [ (aDictionary at: arguments first ifAbsentPut: [ aNode arguments ]) = aNode arguments ] ].
	^ self matchArgumentsAgainst: aNode inContext: aDictionary
%

category: 'matching'
method: RBPatternPragmaNode
matchArgumentsAgainst: aNode inContext: aDictionary 
	self arguments size = aNode arguments size
		ifFalse: [ ^ false ].
	(self matchSelectorAgainst: aNode inContext: aDictionary) 
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'private'
method: RBPatternPragmaNode
matchingClass
	^ RBPragmaNode
%

category: 'matching'
method: RBPatternPragmaNode
matchSelectorAgainst: aNode inContext: aDictionary 
	self selectorParts with: aNode selectorParts do: [ :first :second |
		| keyword |
		keyword := aDictionary
			at: first value
			ifAbsentPut: [ 
				first isPatternVariable 
					ifTrue: [ second value ]
					ifFalse: [ first value ] ].
		keyword = second value 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'initialization'
method: RBPatternPragmaNode
selectorParts: keywordTokens arguments: valueNodes 
	super selectorParts: keywordTokens arguments: valueNodes.
	isList := (keywordTokens first value at: 2) == self listCharacter
%

category: 'accessing'
method: RBPatternPragmaNode
sentMessages
	^ super sentMessages
		remove: self selector ifAbsent: [ ];
		yourself
%

! Class implementation for 'RBReturnNode'

!		Class methods for 'RBReturnNode'

category: 'instance creation'
classmethod: RBReturnNode
return: returnInteger value: aValueNode 
	^self new return: returnInteger value: aValueNode
%

category: 'instance creation'
classmethod: RBReturnNode
value: aNode
	^self return: nil value: aNode
%

!		Instance methods for 'RBReturnNode'

category: 'comparing'
method: RBReturnNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	^self value = anObject value
%

category: 'visitor'
method: RBReturnNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptReturnNode: self
%

category: 'accessing'
method: RBReturnNode
children
	^Array with: value
%

category: 'testing'
method: RBReturnNode
containsReturn
	^true
%

category: 'matching'
method: RBReturnNode
copyInContext: aDictionary 
	^ self class new
		value: (self value copyInContext: aDictionary);
		yourself
%

category: 'comparing'
method: RBReturnNode
equalTo: anObject withMapping: aDictionary 
	^self class = anObject class 
		and: [self value equalTo: anObject value withMapping: aDictionary]
%

category: 'comparing'
method: RBReturnNode
hash
	^self value hash
%

category: 'testing'
method: RBReturnNode
isReturn
	^true
%

category: 'matching'
method: RBReturnNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^value match: aNode value inContext: aDictionary
%

category: 'copying'
method: RBReturnNode
postCopy
	super postCopy.
	self value: self value copy
%

category: 'replacing'
method: RBReturnNode
replaceNode: aNode withNode: anotherNode 
	value == aNode ifTrue: [self value: anotherNode]
%

category: 'accessing-token'
method: RBReturnNode
return
	^ return
%

category: 'accessing-token'
method: RBReturnNode
return: anInteger
	return := anInteger
%

category: 'initialize-release'
method: RBReturnNode
return: returnInteger value: aValueNode 
	return := returnInteger.
	self value: aValueNode
%

category: 'accessing'
method: RBReturnNode
start
	^return
%

category: 'accessing'
method: RBReturnNode
stop
	^value stop
%

category: 'accessing'
method: RBReturnNode
value
	^value
%

category: 'accessing'
method: RBReturnNode
value: valueNode 
	value := valueNode.
	value parent: self
%

! Class implementation for 'RBSequenceNode'

!		Class methods for 'RBSequenceNode'

category: 'instance creation'
classmethod: RBSequenceNode
leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 
	^(self new)
		leftBar: leftInteger
			temporaries: variableNodes
			rightBar: rightInteger;
		yourself
%

category: 'instance creation'
classmethod: RBSequenceNode
statements: statementNodes 
	^self temporaries: #() statements: statementNodes
%

category: 'instance creation'
classmethod: RBSequenceNode
temporaries: variableNodes statements: statementNodes 
	^(self new)
		temporaries: variableNodes;
		statements: statementNodes;
		yourself
%

!		Instance methods for 'RBSequenceNode'

category: 'comparing'
method: RBSequenceNode
= anObject 
	"Can't send = to the temporaries and statements collection since they might change from arrays to OCs"

	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	self temporaries size = anObject temporaries size ifFalse: [^false].
	1 to: self temporaries size
		do: 
			[:i | 
			(self temporaries at: i) = (anObject temporaries at: i) ifFalse: [^false]].
	self statements size = anObject statements size ifFalse: [^false].
	1 to: self statements size
		do: [:i | (self statements at: i) = (anObject statements at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBSequenceNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptSequenceNode: self
%

category: 'adding nodes'
method: RBSequenceNode
addNode: aNode
	aNode parent: self.
	(statements notEmpty and: [ statements last isReturn ])
		ifTrue: [ self error: 'Cannot add statement after return node' ].
	statements := statements asOrderedCollection
		add: aNode;
		yourself.
	^ aNode
%

category: 'adding nodes'
method: RBSequenceNode
addNode: aNode before: anotherNode
	| index |
	index := self indexOfNode: anotherNode.
	index = 0
		ifTrue: [ ^ self addNode: aNode ].
	statements := statements asOrderedCollection
		add: aNode beforeIndex: index;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBSequenceNode
addNodeFirst: aNode
	aNode parent: self.
	statements := statements asOrderedCollection
		addFirst: aNode;
		yourself.
	^ aNode
%

category: 'adding nodes'
method: RBSequenceNode
addNodes: aCollection
	aCollection do: [ :each | each parent: self ].
	(statements notEmpty and: [ statements last isReturn ])
		ifTrue: [ self error: 'Cannot add statement after return node' ].
	statements := statements asOrderedCollection
		addAll: aCollection;
		yourself.
	^ aCollection
%

category: 'adding nodes'
method: RBSequenceNode
addNodes: aCollection before: anotherNode
	aCollection do: [ :each | self addNode: each before: anotherNode ].
	^ aCollection
%

category: 'adding nodes'
method: RBSequenceNode
addNodesFirst: aCollection
	aCollection do: [ :each | each parent: self ].
	statements := statements asOrderedCollection
		addAllFirst: aCollection;
		yourself.
	^ aCollection
%

category: 'accessing'
method: RBSequenceNode
addReturn
	| node |
	statements isEmpty
		ifTrue: [ ^ nil ].
	statements last isReturn
		ifTrue: [ ^ statements last ].
	node := RBReturnNode value: statements last.
	statements at: statements size put: node.
	node parent: self.
	^ node
%

category: 'adding nodes'
method: RBSequenceNode
addSelfReturn
	| node |
	self lastIsReturn
		ifTrue: [ ^ self statements last ].
	node := RBReturnNode value: (RBVariableNode named: 'self').
	^ self addNode: node
%

category: 'adding nodes'
method: RBSequenceNode
addTemporariesNamed: aCollection
	^ aCollection collect: [ :each | self addTemporaryNamed: each ]
%

category: 'adding nodes'
method: RBSequenceNode
addTemporaryNamed: aString 
	| variableNode |
	variableNode := RBVariableNode named: aString.
	variableNode parent: self.
	temporaries := temporaries copyWith: variableNode.
	^ variableNode
%

category: 'accessing'
method: RBSequenceNode
allDefinedVariables
	^(self temporaryNames asOrderedCollection)
		addAll: super allDefinedVariables;
		yourself
%

category: 'accessing'
method: RBSequenceNode
allTemporaryVariables
	^(self temporaryNames asOrderedCollection)
		addAll: super allTemporaryVariables;
		yourself
%

category: 'querying'
method: RBSequenceNode
bestNodeFor: anInterval 
	| node |
	node := super bestNodeFor: anInterval.
	node == self 
		ifTrue: 
			[(temporaries isEmpty and: [statements size == 1]) 
				ifTrue: [^statements first]].
	^node
%

category: 'accessing'
method: RBSequenceNode
children
	^(OrderedCollection new)
		addAll: self temporaries;
		addAll: self statements;
		yourself
%

category: 'matching'
method: RBSequenceNode
copyInContext: aDictionary 
	^ self class new
		temporaries: (self copyList: self temporaries inContext: aDictionary);
		statements: (self copyList: self statements inContext: aDictionary);
		yourself
%

category: 'testing'
method: RBSequenceNode
defines: aName 
	^temporaries anySatisfy: [:each | each name = aName]
%

category: 'testing'
method: RBSequenceNode
directlyUses: aNode 
	^false
%

category: 'comparing'
method: RBSequenceNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self statements size = anObject statements size ifFalse: [^false].
	1 to: self statements size
		do: 
			[:i | 
			((self statements at: i) equalTo: (anObject statements at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	aDictionary values asSet size = aDictionary size ifFalse: [^false].	"Not a one-to-one mapping"
	self temporaries
		do: [:each | aDictionary removeKey: each name ifAbsent: []].
	^true
%

category: 'comparing'
method: RBSequenceNode
hash
	^ (self hashForCollection: self temporaries) bitXor: (self hashForCollection: self statements)
%

category: 'private'
method: RBSequenceNode
indexOfNode: aNode 
	"Try to find the node by first looking for ==, and then for ="

	^(1 to: statements size) detect: [:each | (statements at: each) == aNode]
		ifNone: [statements indexOf: aNode]
%

category: 'initialize-release'
method: RBSequenceNode
initialize
	super initialize.
	periods := statements := temporaries := #()
%

category: 'testing'
method: RBSequenceNode
isLast: aNode 
	| last |
	statements isEmpty ifTrue: [^false].
	last := statements last.
	^last == aNode or: 
			[last isMessage and: 
					[(#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: last selector) 
						and: [last arguments anySatisfy: [:each | each isLast: aNode]]]]
%

category: 'testing'
method: RBSequenceNode
isSequence
	^true
%

category: 'testing'
method: RBSequenceNode
lastIsReturn
	^statements notEmpty and: [statements last lastIsReturn]
%

category: 'accessing-token'
method: RBSequenceNode
leftBar
	^ leftBar
%

category: 'accessing-token'
method: RBSequenceNode
leftBar: anInteger
	leftBar := anInteger
%

category: 'initialize-release'
method: RBSequenceNode
leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 
	leftBar := leftInteger.
	self temporaries: variableNodes.
	rightBar := rightInteger
%

category: 'matching'
method: RBSequenceNode
match: aNode inContext: aDictionary 
	self class = aNode class ifFalse: [^false].
	^(self 
		matchList: temporaries
		against: aNode temporaries
		inContext: aDictionary) and: 
				[self 
					matchList: statements
					against: aNode statements
					inContext: aDictionary]
%

category: 'accessing'
method: RBSequenceNode
methodComments
	| methodComments |
	methodComments := OrderedCollection withAll: self comments.
	temporaries do: [:each | methodComments addAll: each comments].
	(parent notNil and: [parent isBlock]) 
		ifTrue: [parent arguments do: [:each | methodComments addAll: each comments]].
	^methodComments asSortedCollection: [:a :b | a first < b first]
%

category: 'accessing-token'
method: RBSequenceNode
periods
	^ periods
%

category: 'accessing-token'
method: RBSequenceNode
periods: anArray
	periods := anArray
%

category: 'copying'
method: RBSequenceNode
postCopy
	super postCopy.
	self temporaries: (self temporaries collect: [ :each | each copy ]).
	self statements: (self statements collect: [ :each | each copy ])
%

category: 'testing'
method: RBSequenceNode
references: aVariableName 
	^statements anySatisfy: [:each | each references: aVariableName]
%

category: 'replacing'
method: RBSequenceNode
removeDeadCode
	(self isUsed ifTrue: [statements size - 1] ifFalse: [statements size]) 
		to: 1
		by: -1
		do: 
			[:i | 
			(statements at: i) isImmediateNode 
				ifTrue: 
					[self clearReplacements.
					statements removeAtIndex: i]].
	super removeDeadCode
%

category: 'replacing'
method: RBSequenceNode
removeNode: aNode
	self replaceNode: aNode withNodes: #()
%

category: 'accessing'
method: RBSequenceNode
removeTemporaryNamed: aName 
	temporaries := temporaries reject: [:each | each name = aName]
%

category: 'replacing'
method: RBSequenceNode
replaceNode: aNode withNode: anotherNode 
	self statements: (statements 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).
	self temporaries: (temporaries 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'replacing'
method: RBSequenceNode
replaceNode: aNode withNodes: aCollection 
	| index newStatements |
	self clearReplacements.
	index := self indexOfNode: aNode.
	newStatements := OrderedCollection new: statements size + aCollection size.
	1 to: index - 1 do: [:i | newStatements add: (statements at: i)].
	newStatements addAll: aCollection.
	index + 1 to: statements size
		do: [:i | newStatements add: (statements at: i)].
	aCollection do: [:each | each parent: self].
	statements := newStatements
%

category: 'accessing-token'
method: RBSequenceNode
rightBar
	^ rightBar
%

category: 'accessing-token'
method: RBSequenceNode
rightBar: anInteger
	rightBar := anInteger
%

category: 'accessing'
method: RBSequenceNode
start
	^leftBar isNil 
		ifTrue: [statements isEmpty ifTrue: [1] ifFalse: [statements first start]]
		ifFalse: [leftBar]
%

category: 'accessing'
method: RBSequenceNode
statements
	^statements
%

category: 'accessing'
method: RBSequenceNode
statements: stmtCollection 
	statements := stmtCollection.
	statements do: [:each | each parent: self]
%

category: 'accessing'
method: RBSequenceNode
stop
	^(periods isEmpty ifTrue: [0] ifFalse: [periods last]) 
		max: (statements isEmpty ifTrue: [0] ifFalse: [statements last stop])
%

category: 'accessing'
method: RBSequenceNode
temporaries
	^temporaries
%

category: 'accessing'
method: RBSequenceNode
temporaries: tempCollection 
	temporaries := tempCollection.
	temporaries do: [:each | each parent: self]
%

category: 'accessing'
method: RBSequenceNode
temporaryNames
	^temporaries collect: [:each | each name]
%

category: 'accessing'
method: RBSequenceNode
temporaryVariables
	^(super temporaryVariables asOrderedCollection)
		addAll: self temporaryNames;
		yourself
%

category: 'testing'
method: RBSequenceNode
uses: aNode 
	statements isEmpty ifTrue: [^false].
	aNode == statements last ifFalse: [^false].
	^self isUsed
%

category: 'querying'
method: RBSequenceNode
whichNodeIsContainedBy: anInterval 
	| node |
	node := super whichNodeIsContainedBy: anInterval.
	node == self 
		ifTrue: 
			[(temporaries isEmpty and: [statements size == 1]) 
				ifTrue: [^statements first]].
	^node
%

! Class implementation for 'RBValueNode'

!		Instance methods for 'RBValueNode'

category: 'accessing'
method: RBValueNode
addParenthesis: anInterval 
	parentheses isNil ifTrue: [parentheses := OrderedCollection new: 1].
	parentheses add: anInterval
%

category: 'testing'
method: RBValueNode
containedBy: anInterval 
	^anInterval first <= self startWithoutParentheses 
		and: [anInterval last >= self stopWithoutParentheses]
%

category: 'testing'
method: RBValueNode
hasParentheses
	^self parentheses notEmpty
%

category: 'testing'
method: RBValueNode
isValue
	^true
%

category: 'testing'
method: RBValueNode
needsParenthesis
	^self subclassResponsibility
%

category: 'accessing'
method: RBValueNode
parentheses
	^parentheses isNil ifTrue: [#()] ifFalse: [parentheses]
%

category: 'accessing'
method: RBValueNode
start
	^parentheses isNil 
		ifTrue: [self startWithoutParentheses]
		ifFalse: [parentheses last first]
%

category: 'accessing'
method: RBValueNode
startWithoutParentheses
	^self subclassResponsibility
%

category: 'accessing'
method: RBValueNode
stop
	^parentheses isNil
		ifTrue: [self stopWithoutParentheses]
		ifFalse: [parentheses last last]
%

category: 'accessing'
method: RBValueNode
stopWithoutParentheses
	^self subclassResponsibility
%

! Class implementation for 'RBArrayNode'

!		Class methods for 'RBArrayNode'

category: 'instance creation'
classmethod: RBArrayNode
statements: statements
	^ self new statements: statements
%

!		Instance methods for 'RBArrayNode'

category: 'comparing'
method: RBArrayNode
= anObject 
	self == anObject ifTrue: [ ^ true ].
	self class = anObject class ifFalse: [ ^ false ].
	self statements size = anObject statements size ifFalse: [ ^ false ].
	1 to: self statements size do: [ :i | 
		(self statements at: i) = (anObject statements at: i) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'visitor'
method: RBArrayNode
acceptVisitor: aProgramNodeVisitor
	^ aProgramNodeVisitor acceptArrayNode: self
%

category: 'adding nodes'
method: RBArrayNode
addNode: aNode
	statements := statements asOrderedCollection
		add: aNode;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBArrayNode
addNode: aNode before: anotherNode 
	| index |
	aNode isReturn 
		ifTrue: [ self error: 'Cannot add return node' ].
	index := self indexOfNode: anotherNode.
	index = 0 ifTrue: [ ^ self addNode: aNode ].
	statements := statements asOrderedCollection
		add: aNode beforeIndex: index;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBArrayNode
addNodeFirst: aNode
	statements := statements asOrderedCollection
		addFirst: aNode;
		yourself.
	aNode parent: self.
	^ aNode
%

category: 'adding nodes'
method: RBArrayNode
addNodes: aCollection
	statements := statements asOrderedCollection
		addAll: aCollection;
		yourself.
	aCollection do: [ :each | each parent: self ].
	^ aCollection
%

category: 'adding nodes'
method: RBArrayNode
addNodes: aCollection before: anotherNode 
	aCollection do: [ :each | self addNode: each before: anotherNode ].
	^ aCollection
%

category: 'adding nodes'
method: RBArrayNode
addNodesFirst: aCollection
	statements := statements asOrderedCollection
		addAllFirst: aCollection;
		yourself.
	aCollection do: [ :each | each parent: self ].
	^ aCollection
%

category: 'accessing'
method: RBArrayNode
children
	^ self statements
%

category: 'matching'
method: RBArrayNode
copyInContext: aDictionary 
	^ self class statements: (self copyList: self statements inContext: aDictionary)
%

category: 'comparing'
method: RBArrayNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class 
		ifFalse: [ ^ false ].
	self statements size = anObject statements size 
		ifFalse: [ ^ false ].
	self statements with: anObject statements do: [ :first :second |
		(first equalTo: second withMapping: aDictionary)
			ifFalse: [ ^ false ] ].
	aDictionary values asSet size = aDictionary size 
		ifFalse: [ ^ false ].
	^ true
%

category: 'comparing'
method: RBArrayNode
hash
	^ self hashForCollection: self statements
%

category: 'private'
method: RBArrayNode
indexOfNode: aNode 
	"Try to find the node by first looking for ==, and then for ="

	^ (1 to: statements size) 
		detect: [ :each | (statements at: each) == aNode ]
		ifNone: [ statements indexOf: aNode ]
%

category: 'initialize-release'
method: RBArrayNode
initialize
	super initialize.
	statements := periods := #()
%

category: 'testing'
method: RBArrayNode
isArray
	^ true
%

category: 'testing'
method: RBArrayNode
lastIsReturn
	statements isEmpty ifTrue:[ ^false ].
	^statements last lastIsReturn
%

category: 'accessing-token'
method: RBArrayNode
left
	^ left
%

category: 'accessing-token'
method: RBArrayNode
left: anInteger
	left := anInteger
%

category: 'matching'
method: RBArrayNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [ ^ false ].
	^ self matchList: statements against: aNode statements inContext: aDictionary
%

category: 'testing'
method: RBArrayNode
needsParenthesis
	^ false
%

category: 'accessing-token'
method: RBArrayNode
periods
	^ periods
%

category: 'accessing-token'
method: RBArrayNode
periods: anArray
	periods := anArray
%

category: 'copying'
method: RBArrayNode
postCopy
	super postCopy.
	self statements: (self statements collect: [ :each | each copy ])
%

category: 'accessing'
method: RBArrayNode
precedence
	^0
%

category: 'testing'
method: RBArrayNode
references: aVariableName 
	^ statements anySatisfy: [ :each | each references: aVariableName ]
%

category: 'replacing'
method: RBArrayNode
replaceNode: oldNode  withNode: newNode
	self statements: (statements collect: [ :statement |
		statement == oldNode 
			ifTrue: [ newNode ]
			ifFalse: [ statement ] ])
%

category: 'accessing-token'
method: RBArrayNode
right
	^ right
%

category: 'accessing-token'
method: RBArrayNode
right: anInteger
	right := anInteger
%

category: 'accessing'
method: RBArrayNode
startWithoutParentheses 
	^ left
%

category: 'accessing'
method: RBArrayNode
statementComments
	^self comments
%

category: 'accessing'
method: RBArrayNode
statements
	^statements
%

category: 'accessing'
method: RBArrayNode
statements: statements0 
	statements := statements0.
	statements do: [:statement | statement parent: self]
%

category: 'accessing'
method: RBArrayNode
stopWithoutParentheses 
	^ right
%

category: 'testing'
method: RBArrayNode
uses: aNode 
	^ (statements anySatisfy: [ :each | each == aNode ]) or: [ self isUsed ]
%

! Class implementation for 'RBAssignmentNode'

!		Class methods for 'RBAssignmentNode'

category: 'instance creation'
classmethod: RBAssignmentNode
variable: aVariableNode value: aValueNode 
	^self 
		variable: aVariableNode
		value: aValueNode
		position: nil
%

category: 'instance creation'
classmethod: RBAssignmentNode
variable: aVariableNode value: aValueNode position: anInteger 
	^(self new)
		variable: aVariableNode
			value: aValueNode
			position: anInteger;
		yourself
%

!		Instance methods for 'RBAssignmentNode'

category: 'comparing'
method: RBAssignmentNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	^self variable = anObject variable and: [self value = anObject value]
%

category: 'visitor'
method: RBAssignmentNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptAssignmentNode: self
%

category: 'accessing-token'
method: RBAssignmentNode
assignment
	^ assignment
%

category: 'accessing-token'
method: RBAssignmentNode
assignment: anInteger
	assignment := anInteger
%

category: 'accessing'
method: RBAssignmentNode
assignmentOperator
	^ (self assignmentPosition notNil and: [ self source notNil and: [ (self source at: self assignmentPosition ifAbsent: [ nil ]) = $_ ] ])
		ifTrue: [ '_' ]
		ifFalse: [ ':=' ]
%

category: 'accessing'
method: RBAssignmentNode
assignmentPosition
	^ assignment
%

category: 'testing'
method: RBAssignmentNode
assigns: aVariableName 
	^variable name = aVariableName or: [value assigns: aVariableName]
%

category: 'querying'
method: RBAssignmentNode
bestNodeFor: anInterval 
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	assignment isNil ifTrue: [^super bestNodeFor: anInterval].
	((anInterval first between: assignment and: assignment + 1) 
		or: [assignment between: anInterval first and: anInterval last]) 
			ifTrue: [^self].
	self children do: 
			[:each | 
			| node |
			node := each bestNodeFor: anInterval.
			node notNil ifTrue: [^node]]
%

category: 'accessing'
method: RBAssignmentNode
children
	^Array with: value with: variable
%

category: 'matching'
method: RBAssignmentNode
copyInContext: aDictionary 
	^ self class new
		variable: (self variable copyInContext: aDictionary);
		value: (self value copyInContext: aDictionary);
		yourself
%

category: 'testing'
method: RBAssignmentNode
directlyUses: aNode 
	^aNode = value ifTrue: [true] ifFalse: [self isDirectlyUsed]
%

category: 'comparing'
method: RBAssignmentNode
equalTo: anObject withMapping: aDictionary 
	^self class = anObject class and: 
			[(self variable equalTo: anObject variable withMapping: aDictionary) 
				and: [self value equalTo: anObject value withMapping: aDictionary]]
%

category: 'comparing'
method: RBAssignmentNode
hash
	^self variable hash bitXor: self value hash
%

category: 'testing'
method: RBAssignmentNode
isAssignment
	^true
%

category: 'matching'
method: RBAssignmentNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^(variable match: aNode variable inContext: aDictionary)
		and: [value match: aNode value inContext: aDictionary]
%

category: 'testing'
method: RBAssignmentNode
needsParenthesis
	^parent isNil 
		ifTrue: [false]
		ifFalse: [self precedence > parent precedence]
%

category: 'copying'
method: RBAssignmentNode
postCopy
	super postCopy.
	self variable: self variable copy.
	self value: self value copy
%

category: 'accessing'
method: RBAssignmentNode
precedence
	^5
%

category: 'replacing'
method: RBAssignmentNode
replaceNode: aNode withNode: anotherNode 
	value == aNode ifTrue: [self value: anotherNode].
	variable == aNode ifTrue: [self variable: anotherNode]
%

category: 'replacing'
method: RBAssignmentNode
replaceSourceWith: aNode 
	"Check if we need to convert the assignment. Also check if we are being replaced with a setter message send. If so, create the replacements to edit the original source."

	(aNode isAssignment and: [ aNode assignmentOperator ~= self assignmentOperator ]) ifTrue: [
		self addReplacement: (RBStringReplacement 
			replaceFrom: self assignmentPosition
			to: self assignmentPosition + self assignmentOperator size - 1
			with: aNode assignmentOperator).
		(aNode variable = variable and: [ aNode value = value ])
			ifTrue: [ ^ self ] ].
	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].
	aNode receiver isVariable ifFalse: [^super replaceSourceWith: aNode].
	aNode numArgs = 1 ifFalse: [^super replaceSourceWith: aNode].
	(self mappingFor: self value) = aNode arguments first 
		ifFalse: [^super replaceSourceWith: aNode].
	(self value hasParentheses not 
		and: [aNode arguments first precedence >= aNode precedence]) 
			ifTrue: 
				[self
					addReplacement: (RBStringReplacement 
								replaceFrom: self value start
								to: self value start - 1
								with: '(');
					addReplacement: (RBStringReplacement 
								replaceFrom: self value stop + 1
								to: self value stop
								with: ')')].
	self addReplacement: (RBStringReplacement 
				replaceFrom: self variable start
				to: self assignmentPosition + 1
				with: aNode receiver name , ' ' , aNode selector)
%

category: 'accessing'
method: RBAssignmentNode
startWithoutParentheses
	^variable start
%

category: 'accessing'
method: RBAssignmentNode
stopWithoutParentheses
	^value stop
%

category: 'testing'
method: RBAssignmentNode
uses: aNode 
	^aNode = value ifTrue: [true] ifFalse: [self isUsed]
%

category: 'accessing'
method: RBAssignmentNode
value
	^value
%

category: 'accessing'
method: RBAssignmentNode
value: aValueNode 
	value := aValueNode.
	value parent: self
%

category: 'accessing'
method: RBAssignmentNode
variable
	^variable
%

category: 'accessing'
method: RBAssignmentNode
variable: varNode 
	variable := varNode.
	variable parent: self
%

category: 'initialize-release'
method: RBAssignmentNode
variable: aVariableNode value: aValueNode position: anInteger 
	self variable: aVariableNode.
	self value: aValueNode.
	assignment := anInteger
%

! Class implementation for 'RBBlockNode'

!		Class methods for 'RBBlockNode'

category: 'instance creation'
classmethod: RBBlockNode
arguments: argNodes body: sequenceNode 
	^(self new)
		arguments: argNodes;
		body: sequenceNode;
		yourself
%

category: 'instance creation'
classmethod: RBBlockNode
body: sequenceNode 
	^self arguments: #() body: sequenceNode
%

!		Instance methods for 'RBBlockNode'

category: 'comparing'
method: RBBlockNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	self body = anObject body ifFalse: [^false].
	self arguments size = anObject arguments size ifFalse: [^false].
	1 to: self arguments size
		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBBlockNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptBlockNode: self
%

category: 'accessing'
method: RBBlockNode
allArgumentVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allArgumentVariables;
		yourself
%

category: 'accessing'
method: RBBlockNode
allDefinedVariables
	^(self argumentNames asOrderedCollection)
		addAll: super allDefinedVariables;
		yourself
%

category: 'accessing'
method: RBBlockNode
argumentNames
	^self arguments collect: [:each | each name]
%

category: 'accessing'
method: RBBlockNode
arguments
	^arguments
%

category: 'accessing'
method: RBBlockNode
arguments: argCollection 
	arguments := argCollection.
	arguments do: [:each | each parent: self]
%

category: 'accessing-token'
method: RBBlockNode
bar
	^ bar
%

category: 'accessing-token'
method: RBBlockNode
bar: anInteger
	bar := anInteger
%

category: 'accessing'
method: RBBlockNode
blockVariables
	| vars |
	vars := super blockVariables asOrderedCollection.
	vars addAll: self argumentNames.
	^vars
%

category: 'accessing'
method: RBBlockNode
body
	^body
%

category: 'accessing'
method: RBBlockNode
body: stmtsNode 
	body := stmtsNode.
	body parent: self
%

category: 'accessing'
method: RBBlockNode
children
	^self arguments copyWith: self body
%

category: 'accessing-token'
method: RBBlockNode
colons
	^ colons
%

category: 'accessing-token'
method: RBBlockNode
colons: anArray 
	colons := anArray
%

category: 'matching'
method: RBBlockNode
copyInContext: aDictionary 
	^ self class new
		arguments: (self copyList: self arguments inContext: aDictionary);
		body: (self body copyInContext: aDictionary);
		yourself
%

category: 'testing'
method: RBBlockNode
defines: aName 
	^arguments anySatisfy: [:each | each name = aName]
%

category: 'testing'
method: RBBlockNode
directlyUses: aNode 
	^false
%

category: 'comparing'
method: RBBlockNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self arguments size = anObject arguments size ifFalse: [^false].
	1 to: self arguments size
		do: 
			[:i | 
			((self arguments at: i) equalTo: (anObject arguments at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	(self body equalTo: anObject body withMapping: aDictionary)
		ifFalse: [^false].
	self arguments do: [:each | aDictionary removeKey: each name].
	^true
%

category: 'comparing'
method: RBBlockNode
hash
	^ (self hashForCollection: self arguments) bitXor: self body hash
%

category: 'testing'
method: RBBlockNode
isBlock
	^true
%

category: 'testing'
method: RBBlockNode
isImmediateNode
	^true
%

category: 'testing'
method: RBBlockNode
isLast: aNode 
	^body isLast: aNode
%

category: 'accessing-token'
method: RBBlockNode
left
	^ left
%

category: 'accessing-token'
method: RBBlockNode
left: anInteger
	left := anInteger
%

category: 'matching'
method: RBBlockNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^(self 
		matchList: arguments
		against: aNode arguments
		inContext: aDictionary) 
			and: [body match: aNode body inContext: aDictionary]
%

category: 'testing'
method: RBBlockNode
needsParenthesis
	^false
%

category: 'copying'
method: RBBlockNode
postCopy
	super postCopy.
	self arguments: (self arguments collect: [ :each | each copy ]).
	self body: self body copy
%

category: 'accessing'
method: RBBlockNode
precedence
	^0
%

category: 'testing'
method: RBBlockNode
references: aVariableName 
	^body references: aVariableName
%

category: 'replacing'
method: RBBlockNode
replaceNode: aNode withNode: anotherNode 
	body == aNode ifTrue: [self body: anotherNode].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'accessing-token'
method: RBBlockNode
right
	^ right
%

category: 'accessing-token'
method: RBBlockNode
right: anInteger
	right := anInteger
%

category: 'accessing'
method: RBBlockNode
startWithoutParentheses
	^left
%

category: 'accessing'
method: RBBlockNode
statementComments
	^self comments
%

category: 'accessing'
method: RBBlockNode
stopWithoutParentheses
	^right
%

category: 'testing'
method: RBBlockNode
uses: aNode 
	aNode = body ifFalse: [^false].
	^parent isMessage 
		ifTrue: 
			[(#(#ifTrue:ifFalse: #ifTrue: #ifFalse: #ifFalse:ifTrue:) 
				includes: parent selector) not 
				or: [parent isUsed]]
		ifFalse: [self isUsed]
%

! Class implementation for 'RBPatternBlockNode'

!		Instance methods for 'RBPatternBlockNode'

category: 'visitor'
method: RBPatternBlockNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptPatternBlockNode: self
%

category: 'matching'
method: RBPatternBlockNode
addArgumentWithNameBasedOn: aString to: aRBBlockNode 
	| name index vars |
	name := aString.
	vars := aRBBlockNode allDefinedVariables.
	index := 0.
	[vars includes: name] whileTrue: 
			[index := index + 1.
			name := name , index printString].
	aRBBlockNode 
		arguments: (aRBBlockNode arguments copyWith: (RBVariableNode named: name))
%

category: 'matching'
method: RBPatternBlockNode
constructLookupNodeFor: aString in: aRBBlockNode 
	| argumentNode |
	argumentNode := RBLiteralNode literalToken: (RBLiteralToken 
						value: aString
						start: nil
						stop: nil).
	^RBMessageNode 
		receiver: (RBVariableNode named: 'self')
		selector: #lookupMatchFor:in:
		arguments: (Array with: argumentNode with: aRBBlockNode arguments last)
%

category: 'matching'
method: RBPatternBlockNode
copyInContext: aDictionary 
	^ self replacingBlock value: aDictionary
%

category: 'matching'
method: RBPatternBlockNode
createBlockFor: aRBBlockNode
  | source |
  self replacePatternNodesIn: aRBBlockNode.
  source := aRBBlockNode formattedCode.
  ^ (source
    _compileInContext: self
    symbolList: GsSession currentSession symbolList
    oldLitVars: nil
    environmentId: 0) _executeInContext: self
%

category: 'matching'
method: RBPatternBlockNode
createMatchingBlock
	| newBlock |
	self arguments size > 2 
		ifTrue: 
			[self 
				error: 'Search blocks can only contain arguments for the node and matching dictionary'].
	newBlock := RBBlockNode arguments: arguments body: body.
	newBlock arguments isEmpty 
		ifTrue: [self addArgumentWithNameBasedOn: 'aNode' to: newBlock].
	newBlock arguments size = 1 
		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].
	^self createBlockFor: newBlock
%

category: 'matching'
method: RBPatternBlockNode
createReplacingBlock
	| newBlock |
	self arguments size > 1 
		ifTrue: 
			[self 
				error: 'Replace blocks can only contain an argument for the matching dictionary'].
	newBlock := RBBlockNode arguments: arguments body: body.
	self arguments isEmpty 
		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].
	^self createBlockFor: newBlock
%

category: 'matching'
method: RBPatternBlockNode
lookupMatchFor: aString in: aDictionary 
	^aDictionary at: aString
		ifAbsent: 
			[| variableNode |
			variableNode := RBPatternVariableNode named: aString.
			aDictionary at: variableNode ifAbsent: [nil]]
%

category: 'matching'
method: RBPatternBlockNode
match: aNode inContext: aDictionary 
	^self matchingBlock value: aNode value: aDictionary
%

category: 'matching'
method: RBPatternBlockNode
matchingBlock
	^valueBlock isNil 
		ifTrue: [valueBlock := self createMatchingBlock]
		ifFalse: [valueBlock]
%

category: 'matching'
method: RBPatternBlockNode
replacePatternNodesIn: aRBBlockNode 
	aRBBlockNode body nodesDo: 
			[:each | 
			(each isVariable and: [each isPatternNode]) 
				ifTrue: 
					[each 
						replaceWith: (self constructLookupNodeFor: each name in: aRBBlockNode)]]
%

category: 'matching'
method: RBPatternBlockNode
replacingBlock
	^valueBlock isNil 
		ifTrue: [valueBlock := self createReplacingBlock]
		ifFalse: [valueBlock]
%

category: 'accessing'
method: RBPatternBlockNode
sentMessages
	^ OrderedCollection new
%

! Class implementation for 'RBPatternWrapperBlockNode'

!		Instance methods for 'RBPatternWrapperBlockNode'

category: 'visitor'
method: RBPatternWrapperBlockNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptPatternWrapperBlockNode: self
%

category: 'matching'
method: RBPatternWrapperBlockNode
copyInContext: aDictionary 
	"I don't know what this would mean, so ignore it."

	^ wrappedNode copyInContext: aDictionary
%

category: 'matching'
method: RBPatternWrapperBlockNode
match: aNode inContext: aDictionary 
	(wrappedNode match: aNode inContext: aDictionary) ifFalse: [^false].
	^super match: aNode inContext: aDictionary
%

category: 'accessing'
method: RBPatternWrapperBlockNode
precedence
	^1
%

category: 'accessing'
method: RBPatternWrapperBlockNode
wrappedNode
	^wrappedNode
%

category: 'accessing'
method: RBPatternWrapperBlockNode
wrappedNode: aRBProgramNode 
	wrappedNode := aRBProgramNode.
	aRBProgramNode parent: self
%

! Class implementation for 'RBQueryBlockNode'

!		Instance methods for 'RBQueryBlockNode'

category: 'visitor'
method: RBQueryBlockNode
acceptVisitor: aProgramNodeVisitor
  ^ aProgramNodeVisitor acceptQueryBlockNode: self
%

! Class implementation for 'RBCascadeNode'

!		Class methods for 'RBCascadeNode'

category: 'instance creation'
classmethod: RBCascadeNode
messages: messageNodes 
	^self new messages: messageNodes
%

category: 'instance creation'
classmethod: RBCascadeNode
messages: messageNodes semicolons: integerCollection 
	^self new messages: messageNodes semicolons: integerCollection
%

!		Instance methods for 'RBCascadeNode'

category: 'comparing'
method: RBCascadeNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	self messages size = anObject messages size ifFalse: [^false].
	1 to: self messages size
		do: [:i | (self messages at: i) = (anObject messages at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBCascadeNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptCascadeNode: self
%

category: 'querying'
method: RBCascadeNode
bestNodeFor: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	messages 
		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].
	selectedChildren := (messages 
				collect: [:each | each bestNodeFor: anInterval]) 
					reject: [:each | each isNil].
	^selectedChildren detect: [:each | true] ifNone: [nil]
%

category: 'accessing'
method: RBCascadeNode
children
	^self messages
%

category: 'matching'
method: RBCascadeNode
copyInContext: aDictionary 
	^ self class new
		messages: (self copyList: self messages inContext: aDictionary);
		yourself
%

category: 'testing'
method: RBCascadeNode
directlyUses: aNode 
	^messages last = aNode and: [self isDirectlyUsed]
%

category: 'comparing'
method: RBCascadeNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self messages size = anObject messages size ifFalse: [^false].
	1 to: self messages size
		do: 
			[:i | 
			((self messages at: i) equalTo: (anObject messages at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true
%

category: 'comparing'
method: RBCascadeNode
hash
	^ self hashForCollection: self messages
%

category: 'testing'
method: RBCascadeNode
isCascade
	^true
%

category: 'matching'
method: RBCascadeNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	^self 
		matchList: messages
		against: aNode messages
		inContext: aDictionary
%

category: 'accessing'
method: RBCascadeNode
messages
	^messages
%

category: 'accessing'
method: RBCascadeNode
messages: messageNodeCollection 
	messages := messageNodeCollection.
	messages do: [:each | each parent: self]
%

category: 'initialize-release'
method: RBCascadeNode
messages: messageNodes semicolons: integerCollection 
	self messages: messageNodes.
	semicolons := integerCollection
%

category: 'testing'
method: RBCascadeNode
needsParenthesis
	^parent isNil 
		ifTrue: [false]
		ifFalse: [self precedence > parent precedence]
%

category: 'copying'
method: RBCascadeNode
postCopy
	super postCopy.
	self messages: (self messages collect: [ :each | each copy ])
%

category: 'accessing'
method: RBCascadeNode
precedence
	^4
%

category: 'accessing'
method: RBCascadeNode
receiver
	^self messages first receiver
%

category: 'replacing'
method: RBCascadeNode
replaceNode: aNode withNode: anotherNode 
	self messages: (messages 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'accessing-token'
method: RBCascadeNode
semicolons
	^ semicolons
%

category: 'accessing-token'
method: RBCascadeNode
semicolons: anArray
	semicolons := anArray
%

category: 'accessing'
method: RBCascadeNode
startWithoutParentheses
	^messages first start
%

category: 'accessing'
method: RBCascadeNode
statementComments
	| statementComments |
	statementComments := OrderedCollection withAll: self comments.
	statementComments addAll: messages first receiver statementComments.
	messages do: 
			[:each | 
			each arguments 
				do: [:arg | statementComments addAll: arg statementComments]].
	^statementComments asSortedCollection: [:a :b | a first < b first]
%

category: 'accessing'
method: RBCascadeNode
stopWithoutParentheses
	^messages last stop
%

category: 'testing'
method: RBCascadeNode
uses: aNode 
	^messages last = aNode and: [self isUsed]
%

category: 'querying'
method: RBCascadeNode
whichNodeIsContainedBy: anInterval 
	| selectedChildren |
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	messages 
		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].
	selectedChildren := (messages 
				collect: [:each | each whichNodeIsContainedBy: anInterval]) 
					reject: [:each | each isNil].
	^selectedChildren detect: [:each | true] ifNone: [nil]
%

! Class implementation for 'RBLiteralNode'

!		Class methods for 'RBLiteralNode'

category: 'instance creation'
classmethod: RBLiteralNode
literalToken: aLiteralToken 
	^(aLiteralToken realValue class == Array 
		or: [aLiteralToken realValue class == ByteArray]) 
			ifTrue: 
				[RBLiteralArrayNode 
					startPosition: aLiteralToken start
					contents: (aLiteralToken value asArray 
							collect: [:each | RBLiteralNode literalToken: each])
					stopPosition: aLiteralToken stop
					isByteArray: aLiteralToken value class ~~ Array]
			ifFalse: [RBLiteralValueNode literalToken: aLiteralToken]
%

category: 'instance creation'
classmethod: RBLiteralNode
value: aValue 
	^((aValue class == Array or: [aValue class == ByteArray]) 
		ifTrue: [RBLiteralArrayNode]
		ifFalse: [RBLiteralValueNode]) value: aValue
%

!		Instance methods for 'RBLiteralNode'

category: 'comparing'
method: RBLiteralNode
= anObject 
	self == anObject ifTrue: [^true].
	^self class = anObject class
%

category: 'comparing'
method: RBLiteralNode
hash
	^self value hash
%

category: 'testing'
method: RBLiteralNode
isImmediateNode
	^true
%

category: 'testing'
method: RBLiteralNode
isLiteralNode
	^true
%

category: 'testing'
method: RBLiteralNode
needsParenthesis
	^false
%

category: 'accessing'
method: RBLiteralNode
precedence
	^0
%

category: 'private-replacing'
method: RBLiteralNode
replaceSourceFrom: aNode 
	self addReplacement: (RBStringReplacement 
				replaceFrom: aNode start
				to: aNode stop
				with: self formattedCode)
%

category: 'private-replacing'
method: RBLiteralNode
replaceSourceWith: aNode 
	self addReplacement: (RBStringReplacement 
				replaceFrom: self start
				to: self stop
				with: aNode formattedCode)
%

category: 'accessing'
method: RBLiteralNode
value
	^self subclassResponsibility
%

! Class implementation for 'RBLiteralArrayNode'

!		Class methods for 'RBLiteralArrayNode'

category: 'instance creation'
classmethod: RBLiteralArrayNode
startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 
	^(self new)
		startPosition: startInteger
			contents: anArray
			stopPosition: stopInteger
			isByteArray: aBoolean;
		yourself
%

category: 'instance creation'
classmethod: RBLiteralArrayNode
value: aValue 
	^(self new)
		startPosition: nil
			contents: (aValue asArray collect: [:each | RBLiteralNode value: each])
			stopPosition: nil
			isByteArray: aValue class ~~ Array;
		yourself
%

!		Instance methods for 'RBLiteralArrayNode'

category: 'comparing'
method: RBLiteralArrayNode
= anObject 
	super = anObject ifFalse: [^false].
	self isForByteArray = anObject isForByteArray ifFalse: [^false].
	self contents size = anObject contents size ifFalse: [^false].
	1 to: self contents size
		do: [:i | (self contents at: i) = (anObject contents at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBLiteralArrayNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptLiteralArrayNode: self
%

category: 'accessing'
method: RBLiteralArrayNode
children
	^contents
%

category: 'accessing'
method: RBLiteralArrayNode
contents
	^contents
%

category: 'initialize-release'
method: RBLiteralArrayNode
contents: aRBLiteralNodeCollection 
	contents := aRBLiteralNodeCollection.
	contents do: [:each | each parent: self]
%

category: 'matching'
method: RBLiteralArrayNode
copyInContext: aDictionary 
	^ self class 
		startPosition: nil
		contents: (self copyList: self contents inContext: aDictionary)
		stopPosition: nil
		isByteArray: isByteArray
%

category: 'comparing'
method: RBLiteralArrayNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	self isForByteArray = anObject isForByteArray ifFalse: [^false].
	self contents size = anObject contents size ifFalse: [^false].
	1 to: self contents size
		do: 
			[:i | 
			((self contents at: i) equalTo: (anObject contents at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true
%

category: 'testing'
method: RBLiteralArrayNode
isForByteArray
	^isByteArray
%

category: 'testing'
method: RBLiteralArrayNode
isLiteralArray
	^true
%

category: 'matching'
method: RBLiteralArrayNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	self isForByteArray = aNode isForByteArray ifFalse: [^false].
	^self 
		matchList: contents
		against: aNode contents
		inContext: aDictionary
%

category: 'copying'
method: RBLiteralArrayNode
postCopy
	super postCopy.
	self contents: (self contents collect: [ :each | each copy ])
%

category: 'replacing'
method: RBLiteralArrayNode
replaceNode: aNode withNode: anotherNode 
	self contents: (contents 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'private-replacing'
method: RBLiteralArrayNode
replaceSourceWith: aNode 
	(self class = aNode class and: 
			[self isForByteArray = aNode isForByteArray 
				and: [self contents size = aNode contents size]]) 
		ifFalse: [^super replaceSourceWith: aNode].
	1 to: self contents size
		do: 
			[:i | 
			(self contents at: i) = (aNode contents at: i) 
				ifFalse: [(self contents at: i) replaceSourceWith: (aNode contents at: i)]]
%

category: 'initialize-release'
method: RBLiteralArrayNode
startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 
	start := startInteger.
	self contents: anArray.
	stop := stopInteger.
	isByteArray := aBoolean
%

category: 'accessing'
method: RBLiteralArrayNode
startWithoutParentheses
	^start
%

category: 'accessing'
method: RBLiteralArrayNode
stopWithoutParentheses
	^stop
%

category: 'accessing'
method: RBLiteralArrayNode
value
	| array |
	array := (isByteArray ifTrue: [ByteArray] ifFalse: [Array]) 
				new: contents size.
	1 to: contents size
		do: [:each | array at: each put: (contents at: each) value].
	^array
%

! Class implementation for 'RBLiteralValueNode'

!		Class methods for 'RBLiteralValueNode'

category: 'instance creation'
classmethod: RBLiteralValueNode
literalToken: aLiteralToken 
	^(self new)
		literalToken: aLiteralToken;
		yourself
%

category: 'instance creation'
classmethod: RBLiteralValueNode
value: aValue 
	^self literalToken: (RBLiteralToken value: aValue)
%

!		Instance methods for 'RBLiteralValueNode'

category: 'comparing'
method: RBLiteralValueNode
= anObject 
	^ super = anObject 
		and: [ self value = anObject value 
		and: [ self value species = anObject value species ] ]
%

category: 'visitor'
method: RBLiteralValueNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptLiteralNode: self
%

category: 'matching'
method: RBLiteralValueNode
copyInContext: aDictionary
	^ self class literalToken: self token copy removePositions
%

category: 'initialize-release'
method: RBLiteralValueNode
literalToken: aLiteralToken 
	token := aLiteralToken
%

category: 'accessing'
method: RBLiteralValueNode
startWithoutParentheses
	^token start
%

category: 'accessing'
method: RBLiteralValueNode
stopWithoutParentheses
	^token stop
%

category: 'accessing'
method: RBLiteralValueNode
token
	^token
%

category: 'accessing'
method: RBLiteralValueNode
value
	^token realValue
%

! Class implementation for 'RBMessageNode'

!		Class methods for 'RBMessageNode'

category: 'instance creation'
classmethod: RBMessageNode
receiver: aValueNode selector: aSymbol 
	^self 
		receiver: aValueNode
		selector: aSymbol
		arguments: #()
%

category: 'instance creation'
classmethod: RBMessageNode
receiver: aValueNode selector: aSymbol arguments: valueNodes 
	^(self new)
		receiver: aValueNode;
		arguments: valueNodes;
		selector: aSymbol;
		yourself
%

category: 'instance creation'
classmethod: RBMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	^(self new)
		receiver: aValueNode
			selectorParts: keywordTokens
			arguments: valueNodes;
		yourself
%

!		Instance methods for 'RBMessageNode'

category: 'comparing'
method: RBMessageNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	(self receiver = anObject receiver 
		and: [self selector = anObject selector]) ifFalse: [^false].
	1 to: self arguments size
		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].
	^true
%

category: 'visitor'
method: RBMessageNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptMessageNode: self
%

category: 'accessing'
method: RBMessageNode
arguments
	^arguments isNil ifTrue: [#()] ifFalse: [arguments]
%

category: 'accessing'
method: RBMessageNode
arguments: argCollection 
	arguments := argCollection.
	arguments do: [:each | each parent: self]
%

category: 'querying'
method: RBMessageNode
bestNodeFor: anInterval 
	(self intersectsInterval: anInterval) ifFalse: [^nil].
	(self containedBy: anInterval) ifTrue: [^self].
	selectorParts do: 
			[:each | 
			((anInterval first between: each start and: each stop) 
				or: [each start between: anInterval first and: anInterval last]) 
					ifTrue: [^self]].
	self children do: 
			[:each | 
			| node |
			node := each bestNodeFor: anInterval.
			node notNil ifTrue: [^node]]
%

category: 'private'
method: RBMessageNode
buildSelector
	| selectorStream |
	selectorStream := WriteStreamPortable on: String new.
	selectorParts do: [ :each | selectorStream nextPutAll: each value ].
	^ selectorStream contents asSymbol
%

category: 'accessing'
method: RBMessageNode
children
	^(OrderedCollection with: self receiver)
		addAll: self arguments;
		yourself
%

category: 'matching'
method: RBMessageNode
copyInContext: aDictionary 
	^ self class new
		receiver: (self receiver copyInContext: aDictionary);
		selectorParts: (self selectorParts collect: [ :each | each copy removePositions ]);
		arguments: (self arguments collect: [ :each | each copyInContext: aDictionary ]);
		yourself
%

category: 'comparing'
method: RBMessageNode
equalTo: anObject withMapping: aDictionary 
	self class = anObject class ifFalse: [^false].
	((self receiver equalTo: anObject receiver withMapping: aDictionary)
		and: [self selector = anObject selector]) ifFalse: [^false].
	1 to: self arguments size
		do: 
			[:i | 
			((self arguments at: i) equalTo: (anObject arguments at: i)
				withMapping: aDictionary) ifFalse: [^false]].
	^true
%

category: 'comparing'
method: RBMessageNode
hash
	^ (self receiver hash bitXor: self selector hash) bitXor: (self hashForCollection: self arguments)
%

category: 'testing'
method: RBMessageNode
isBinary
	^(self isUnary or: [self isKeyword]) not
%

category: 'testing'
method: RBMessageNode
isCascaded
	^parent notNil and: [parent isCascade]
%

category: 'private-replacing'
method: RBMessageNode
isContainmentReplacement: aNode 
	^(self mappingFor: self receiver) = aNode 
		or: [self arguments anySatisfy: [:each | (self mappingFor: each) = aNode]]
%

category: 'testing'
method: RBMessageNode
isFirstCascaded
	^self isCascaded and: [parent messages first == self]
%

category: 'testing'
method: RBMessageNode
isKeyword
	^selectorParts first value last = $:
%

category: 'testing'
method: RBMessageNode
isMessage
	^true
%

category: 'testing'
method: RBMessageNode
isSelfSend
	^ self receiver isVariable and: [ self receiver name = 'self' ]
%

category: 'testing'
method: RBMessageNode
isSuperSend
	^ self receiver isVariable and: [ self receiver name = 'super' ]
%

category: 'testing'
method: RBMessageNode
isUnary
	^arguments isEmpty
%

category: 'testing'
method: RBMessageNode
lastIsReturn
	^ (#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifNil:ifNotNil: #ifNotNil:ifNil:) includes: self selector)
		and: [ arguments first isBlock and: [ arguments first body lastIsReturn 
		and: [ arguments last isBlock and: [ arguments last body lastIsReturn ] ] ] ]
%

category: 'matching'
method: RBMessageNode
match: aNode inContext: aDictionary 
	aNode class = self class ifFalse: [^false].
	self selector = aNode selector ifFalse: [^false].
	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].
	1 to: arguments size
		do: 
			[:i | 
			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary)
				ifFalse: [^false]].
	^true
%

category: 'testing'
method: RBMessageNode
needsParenthesis
	^parent isNil 
		ifTrue: [false]
		ifFalse: 
			[self precedence > parent precedence 
				or: [self precedence = parent precedence and: [self isUnary not]]]
%

category: 'accessing'
method: RBMessageNode
numArgs
	^self selector numArgs
%

category: 'copying'
method: RBMessageNode
postCopy
	super postCopy.
	self receiver: self receiver copy.
	self arguments: (self arguments collect: [ :each | each copy ])
%

category: 'accessing'
method: RBMessageNode
precedence
	^self isUnary 
		ifTrue: [1]
		ifFalse: [self isKeyword ifTrue: [3] ifFalse: [2]]
%

category: 'accessing'
method: RBMessageNode
receiver
	^receiver
%

category: 'accessing'
method: RBMessageNode
receiver: aValueNode 
	receiver := aValueNode.
	receiver parent: self
%

category: 'initialize-release'
method: RBMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	self receiver: aValueNode.
	selectorParts := keywordTokens.
	self arguments: valueNodes
%

category: 'accessing'
method: RBMessageNode
renameSelector: newSelector andArguments: varNodeCollection 
	self
		arguments: varNodeCollection;
		selector: newSelector
%

category: 'private-replacing'
method: RBMessageNode
replaceContainmentSourceWith: aNode 
	| originalNode needsParenthesis |
	needsParenthesis := aNode hasParentheses not and: [aNode needsParenthesis].
	originalNode := (self mappingFor: self receiver) = aNode 
				ifTrue: [self receiver]
				ifFalse: [self arguments detect: [:each | (self mappingFor: each) = aNode]].
	self
		addReplacement: (RBStringReplacement 
					replaceFrom: self start
					to: originalNode start - 1
					with: (needsParenthesis ifTrue: ['('] ifFalse: ['']));
		addReplacement: (RBStringReplacement 
					replaceFrom: originalNode stop + 1
					to: self stop
					with: (needsParenthesis ifTrue: [')'] ifFalse: ['']))
%

category: 'replacing'
method: RBMessageNode
replaceNode: aNode withNode: anotherNode 
	"If we're inside a cascade node and are changing the receiver, change all the receivers"

	receiver == aNode 
		ifTrue: 
			[self receiver: anotherNode.
			(parent notNil and: [parent isCascade]) 
				ifTrue: [parent messages do: [:each | each receiver: anotherNode]]].
	self arguments: (arguments 
				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])
%

category: 'private-replacing'
method: RBMessageNode
replaceSourceWith: aNode 
	(self isContainmentReplacement: aNode) 
		ifTrue: [^self replaceContainmentSourceWith: aNode].
	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].
	^self replaceSourceWithMessageNode: aNode
%

category: 'private-replacing'
method: RBMessageNode
replaceSourceWithMessageNode: aNode 
	| isBinaryToKeyword |
	self numArgs = aNode numArgs ifFalse: [^super replaceSourceWith: aNode].
	self arguments with: aNode arguments
		do: [:old :new | (self mappingFor: old) = new ifFalse: [^super replaceSourceWith: aNode]].
	(self mappingFor: self receiver) = aNode receiver 
		ifFalse:
			[(self receiver isVariable and: [aNode receiver isVariable])
				ifFalse:
					[^super replaceSourceWith: aNode].
			self addReplacement:
				(RBStringReplacement
					replaceFrom: self receiver start
					to: self receiver stop
					with: aNode receiver name)].
	(isBinaryToKeyword := self isBinary and: [aNode isKeyword]) 
		ifTrue: 
			[(self hasParentheses not and: [self parent precedence <= aNode precedence]) 
				ifTrue: 
					[self
						addReplacement: (RBStringReplacement 
									replaceFrom: self start
									to: self start - 1
									with: '(');
						addReplacement: (RBStringReplacement 
									replaceFrom: self stop + 1
									to: self stop
									with: ')')]].
	self selectorParts with: aNode selectorParts
		do: 
			[:old :new | 
			old value ~= new value 
				ifTrue: 
					[self addReplacement: (RBStringReplacement 
								replaceFrom: old start
								to: old stop
								with: ((isBinaryToKeyword 
										and: [(self source at: old start - 1) isSqueakSeparator not]) 
											ifTrue: [' ' , new value]
											ifFalse: [new value]))]]
%

category: 'accessing'
method: RBMessageNode
selector
	^selector isNil
		ifTrue: [selector := self buildSelector]
		ifFalse: [selector]
%

category: 'accessing'
method: RBMessageNode
selector: aSelector 
	| keywords numArgs |
	keywords := aSelector keywords.
	numArgs := aSelector numArgs.
	numArgs == arguments size 
		ifFalse: 
			[self 
				error: 'Attempting to assign selector with wrong number of arguments.'].
	selectorParts := numArgs == 0 
				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]
				ifFalse: 
					[keywords first last = $: 
						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]
						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].
	selector := aSelector asSymbol
%

category: 'private'
method: RBMessageNode
selectorParts
	^ selectorParts
%

category: 'private'
method: RBMessageNode
selectorParts: tokenCollection 
	selectorParts := tokenCollection
%

category: 'accessing'
method: RBMessageNode
sentMessages
	^ super sentMessages
		add: self selector;
		yourself
%

category: 'accessing'
method: RBMessageNode
startWithoutParentheses
	^receiver start
%

category: 'accessing'
method: RBMessageNode
stopWithoutParentheses
	^arguments isEmpty 
		ifTrue: [selectorParts first stop]
		ifFalse: [arguments last stop]
%

! Class implementation for 'RBPatternMessageNode'

!		Class methods for 'RBPatternMessageNode'

category: 'instance creation'
classmethod: RBPatternMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	^(keywordTokens anySatisfy: [:each | each isPatternVariable]) 
		ifTrue: 
			[super 
				receiver: aValueNode
				selectorParts: keywordTokens
				arguments: valueNodes]
		ifFalse: 
			[RBMessageNode 
				receiver: aValueNode
				selectorParts: keywordTokens
				arguments: valueNodes]
%

!		Instance methods for 'RBPatternMessageNode'

category: 'matching'
method: RBPatternMessageNode
copyInContext: aDictionary 
	| selectors |
	self isList 
		ifTrue: [ ^ aDictionary at: self ].
	selectors := self isSelectorList 
		ifTrue: [ (aDictionary at: selectorParts first value) keywords ]
		ifFalse: [ self selectorParts collect: [ :each | aDictionary at: each value ] ].
	^ RBMessageNode new
		receiver: (self receiver copyInContext: aDictionary);
		selectorParts: (selectors collect: [ :each | 
			(each last = $: ifTrue: [ RBKeywordToken ] ifFalse: [ RBIdentifierToken ]) 
				value: each start: nil ]);
		arguments: (self copyList: self arguments inContext: aDictionary);
		yourself
%

category: 'testing-matching'
method: RBPatternMessageNode
isList
	^isCascadeList and: [parent notNil and: [parent isCascade]]
%

category: 'testing-matching'
method: RBPatternMessageNode
isPatternNode
	^true
%

category: 'testing-matching'
method: RBPatternMessageNode
isSelectorList
	^isList
%

category: 'matching'
method: RBPatternMessageNode
match: aNode inContext: aDictionary 
	aNode class == self matchingClass ifFalse: [^false].
	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].
	self isSelectorList 
		ifTrue: 
			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector]) 
				== aNode selector and: 
						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments]) 
							= aNode arguments]].
	^self matchArgumentsAgainst: aNode inContext: aDictionary
%

category: 'matching'
method: RBPatternMessageNode
matchArgumentsAgainst: aNode inContext: aDictionary 
	self arguments size = aNode arguments size
		ifFalse: [ ^ false ].
	(self matchSelectorAgainst: aNode inContext: aDictionary) 
		ifFalse: [ ^ false ].
	self arguments with: aNode arguments do: [ :first :second |
		(first match: second inContext: aDictionary) 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'private'
method: RBPatternMessageNode
matchingClass
	^RBMessageNode
%

category: 'matching'
method: RBPatternMessageNode
matchSelectorAgainst: aNode inContext: aDictionary 
	self selectorParts with: aNode selectorParts do: [ :first :second |
		| keyword |
		keyword := aDictionary
			at: first value
			ifAbsentPut: [ 
				first isPatternVariable 
					ifTrue: [ second value ]
					ifFalse: [ first value ] ].
		keyword = second value 
			ifFalse: [ ^ false ] ].
	^ true
%

category: 'initialize-release'
method: RBPatternMessageNode
receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 
	| message |
	super 
		receiver: aValueNode
		selectorParts: keywordTokens
		arguments: valueNodes.
	isCascadeList := isList := false.
	message := keywordTokens first value.
	2 to: message size
		do: 
			[:i | 
			| character |
			character := message at: i.
			character == self listCharacter 
				ifTrue: [isList := true]
				ifFalse: 
					[character == self cascadeListCharacter 
						ifTrue: [isCascadeList := true]
						ifFalse: [^self]]]
%

category: 'accessing'
method: RBPatternMessageNode
sentMessages
	^ super sentMessages
		remove: self selector ifAbsent: [ ];
		yourself
%

! Class implementation for 'RBVariableNode'

!		Class methods for 'RBVariableNode'

category: 'instance creation'
classmethod: RBVariableNode
identifierToken: anIdentifierToken 
	^(self new)
		identifierToken: anIdentifierToken;
		yourself
%

category: 'instance creation'
classmethod: RBVariableNode
named: aString 
	^self identifierToken: (RBIdentifierToken value: aString start: 0)
%

!		Instance methods for 'RBVariableNode'

category: 'comparing'
method: RBVariableNode
= anObject 
	self == anObject ifTrue: [^true].
	self class = anObject class ifFalse: [^false].
	^self name = anObject name
%

category: 'visitor'
method: RBVariableNode
acceptVisitor: aProgramNodeVisitor 
	^aProgramNodeVisitor acceptVariableNode: self
%

category: 'matching'
method: RBVariableNode
copyInContext: aDictionary 
	^ self class identifierToken: token copy removePositions
%

category: 'comparing'
method: RBVariableNode
equalTo: anObject withMapping: aDictionary 
	^self class = anObject class and: 
			[(aDictionary at: self name ifAbsentPut: [anObject name]) = anObject name]
%

category: 'comparing'
method: RBVariableNode
hash
	^self name hash
%

category: 'initialize-release'
method: RBVariableNode
identifierToken: anIdentifierToken 
	token := anIdentifierToken
%

category: 'testing'
method: RBVariableNode
isImmediateNode
	^true
%

category: 'testing'
method: RBVariableNode
isRead
	^ self isWrite not and: [ self isUsed ]
%

category: 'testing'
method: RBVariableNode
isVariable
	^true
%

category: 'testing'
method: RBVariableNode
isWrite
	^ self parent notNil and: [ self parent isAssignment and: [ self parent variable == self ] ]
%

category: 'accessing'
method: RBVariableNode
name
	^token value
%

category: 'testing'
method: RBVariableNode
needsParenthesis
	^false
%

category: 'accessing'
method: RBVariableNode
precedence
	^0
%

category: 'testing'
method: RBVariableNode
references: aVariableName 
	^self name = aVariableName
%

category: 'replacing'
method: RBVariableNode
replaceSourceFrom: aNode 
	self addReplacement: (RBStringReplacement 
				replaceFrom: aNode start
				to: aNode stop
				with: self name)
%

category: 'replacing'
method: RBVariableNode
replaceSourceWith: aNode
	self addReplacement: (RBStringReplacement 
				replaceFrom: self start
				to: self stop
				with: aNode formattedCode)
%

category: 'accessing'
method: RBVariableNode
startWithoutParentheses
	^token start
%

category: 'accessing'
method: RBVariableNode
stopWithoutParentheses
	^token stop
%

category: 'accessing'
method: RBVariableNode
token
	^ token
%

! Class implementation for 'RBPatternVariableNode'

!		Class methods for 'RBPatternVariableNode'

category: 'instance creation'
classmethod: RBPatternVariableNode
identifierToken: anIdentifierToken 
	^anIdentifierToken isPatternVariable 
		ifTrue: [super identifierToken: anIdentifierToken]
		ifFalse: [RBVariableNode identifierToken: anIdentifierToken]
%

!		Instance methods for 'RBPatternVariableNode'

category: 'matching'
method: RBPatternVariableNode
copyInContext: aDictionary 
	^ (aDictionary at: self) copy
%

category: 'initialize-release'
method: RBPatternVariableNode
identifierToken: anIdentifierToken 
	super identifierToken: anIdentifierToken.
	self initializePatternVariables
%

category: 'initialize-release'
method: RBPatternVariableNode
initializePatternVariables
	| name |
	name := self name.
	isAnything := isList := isLiteral := isStatement := recurseInto := false.
	2 to: name size
		do: 
			[:i | 
			| character |
			character := name at: i.
			character == self listCharacter 
				ifTrue: [isAnything := isList := true]
				ifFalse: 
					[character == self literalCharacter 
						ifTrue: [isLiteral := true]
						ifFalse: 
							[character == self statementCharacter 
								ifTrue: [isStatement := true]
								ifFalse: 
									[character == self recurseIntoCharacter 
										ifTrue: [recurseInto := true]
										ifFalse: [^self]]]]]
%

category: 'testing-matching'
method: RBPatternVariableNode
isAnything
	^isAnything
%

category: 'testing-matching'
method: RBPatternVariableNode
isList
	^isList
%

category: 'testing-matching'
method: RBPatternVariableNode
isLiteralNode
	^isLiteral
%

category: 'testing-matching'
method: RBPatternVariableNode
isPatternNode
	^true
%

category: 'testing-matching'
method: RBPatternVariableNode
isStatement
	^isStatement
%

category: 'matching'
method: RBPatternVariableNode
match: aNode inContext: aDictionary 
	self isAnything 
		ifTrue: [^(aDictionary at: self ifAbsentPut: [aNode]) = aNode].
	self isLiteralNode ifTrue: [^self matchLiteral: aNode inContext: aDictionary].
	self isStatement 
		ifTrue: [^self matchStatement: aNode inContext: aDictionary].
	aNode class == self matchingClass ifFalse: [^false].
	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode
%

category: 'private'
method: RBPatternVariableNode
matchingClass
	^RBVariableNode
%

category: 'matching'
method: RBPatternVariableNode
matchLiteral: aNode inContext: aDictionary 
	^aNode isLiteralNode
		and: [(aDictionary at: self ifAbsentPut: [aNode]) = aNode]
%

category: 'matching'
method: RBPatternVariableNode
matchStatement: aNode inContext: aDictionary 
	(aNode parent notNil and: [aNode parent isSequence]) ifFalse: [^false].
	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode
%

category: 'accessing'
method: RBPatternVariableNode
parent: aBRProgramNode 
	"Fix the case where '``@node' should match a single node, not a sequence node."

	super parent: aBRProgramNode.
	parent isSequence 
		ifTrue: 
			[(self isStatement or: [parent temporaries includes: self]) 
				ifFalse: [isList := false]]
%

category: 'testing-matching'
method: RBPatternVariableNode
recurseInto
	^recurseInto
%

! Class implementation for 'RBProgramNodeVisitor'

!		Class methods for 'RBProgramNodeVisitor'

category: 'instance creation'
classmethod: RBProgramNodeVisitor
new

	^self basicNew initialize
%

!		Instance methods for 'RBProgramNodeVisitor'

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptArrayNode: anArrayNode 
	anArrayNode children do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptAssignmentNode: anAssignmentNode 
	self visitNode: anAssignmentNode variable.
	self visitNode: anAssignmentNode value
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptBlockNode: aBlockNode 
	self visitArguments: aBlockNode arguments.
	self visitNode: aBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptCascadeNode: aCascadeNode 
	aCascadeNode messages do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptLiteralArrayNode: aRBLiteralArrayNode 
	aRBLiteralArrayNode contents do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptLiteralNode: aLiteralNode
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptMessageNode: aMessageNode 
	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 
		ifTrue: [self visitNode: aMessageNode receiver].
	aMessageNode arguments do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptMethodNode: aMethodNode 
	self visitArguments: aMethodNode arguments.
	aMethodNode pragmas
		do: [ :each | self visitNode: each ].
	self visitNode: aMethodNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptPatternBlockNode: aRBPatternBlockNode 
	self visitArguments: aRBPatternBlockNode arguments.
	self visitNode: aRBPatternBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	self visitArguments: aRBPatternWrapperBlockNode arguments.
	self visitNode: aRBPatternWrapperBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptPragmaNode: aPragmaNode
	aPragmaNode arguments do: [ :each | self visitNode: each ]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptQueryBlockNode: aBlockNode
  self visitArguments: aBlockNode arguments.
  self visitNode: aBlockNode body
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptReturnNode: aReturnNode 
	self visitNode: aReturnNode value
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptSequenceNode: aSequenceNode 
	self visitArguments: aSequenceNode temporaries.
	aSequenceNode statements do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBProgramNodeVisitor
acceptVariableNode: aVariableNode
%

category: 'initialize release'
method: RBProgramNodeVisitor
initialize
%

category: 'visiting'
method: RBProgramNodeVisitor
visitArgument: each 
	"Here to allow subclasses to detect arguments or temporaries."

	^self visitNode: each
%

category: 'visiting'
method: RBProgramNodeVisitor
visitArguments: aNodeCollection 
	^aNodeCollection do: [:each | self visitArgument: each]
%

category: 'visiting'
method: RBProgramNodeVisitor
visitNode: aNode 
	^aNode acceptVisitor: self
%

! Class implementation for 'RBConfigurableFormatter'

!		Class methods for 'RBConfigurableFormatter'

category: 'accessing'
classmethod: RBConfigurableFormatter
cascadedMessageInsideParentheses
	^ CascadedMessageInsideParentheses
%

category: 'accessing'
classmethod: RBConfigurableFormatter
cascadedMessageInsideParentheses: aBoolean
	CascadedMessageInsideParentheses := aBoolean
%

category: 'public'
classmethod: RBConfigurableFormatter
format: aParseTree 
	^self format: aParseTree withIndents: 0
%

category: 'public'
classmethod: RBConfigurableFormatter
format: aParseTree withIndents: anInteger 
	^ self new
		indent: anInteger;
		format: aParseTree
%

category: 'accessing'
classmethod: RBConfigurableFormatter
formatCommentWithStatements
	^ FormatCommentWithStatements
%

category: 'accessing'
classmethod: RBConfigurableFormatter
formatCommentWithStatements: aBoolean
	FormatCommentWithStatements := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentsForKeywords
	^ IndentsForKeywords
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentsForKeywords: anInteger
	IndentsForKeywords := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentString
	^ IndentString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
indentString: aString
	IndentString := aString
%

category: 'initialization'
classmethod: RBConfigurableFormatter
initialize
  InQueryBlock := false.
  CascadedMessageInsideParentheses := false.
  FormatCommentWithStatements := true.
  IndentString := '  '.
  IndentsForKeywords := 1.
  KeepBlockInMessage := true.
  LineUpBlockBrackets := false.
  MaxLineLength := 80.
  MethodSignatureOnMultipleLines := false.
  MinimumNewLinesBetweenStatements := 1.
  MultiLineMessages := #(#'ifTrue:ifFalse:' #'ifFalse:ifTrue:' #'ifTrue:' #'ifFalse:' #'on:do:' #'ensure:' #'ifCurtailed:').
  NewLineAfterCascade := true.
  NewLineBeforeFirstCascade := true.
  NewLineBeforeFirstKeyword := false.
  NewLinesAfterMethodComment := 2.
  NewLinesAfterMethodPattern := 1.
  NewLinesAfterTemporaries := 1.
  NumberOfArgumentsForMultiLine := 4.
  OneLineMessages := #(#'to:' #'to:do:' #'to:by:' #'to:by:do:').
  PeriodsAtEndOfBlock := false.
  PeriodsAtEndOfMethod := false.
  RetainBlankLinesBetweenStatements := false.
  StringFollowingReturn := ' '.
  StringInsideBlocks := ' '.
  StringInsideParentheses := ''.
  TraditionalBinaryPrecedence := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).
  UseTraditionalBinaryPrecedenceForParentheses := true
%

category: 'accessing'
classmethod: RBConfigurableFormatter
keepBlockInMessage
	^ KeepBlockInMessage
%

category: 'accessing'
classmethod: RBConfigurableFormatter
keepBlockInMessage: aBoolean
	KeepBlockInMessage := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
lineUpBlockBrackets
	^ LineUpBlockBrackets
%

category: 'accessing'
classmethod: RBConfigurableFormatter
lineUpBlockBrackets: aBoolean
	LineUpBlockBrackets := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
maxLineLength
	^ MaxLineLength
%

category: 'accessing'
classmethod: RBConfigurableFormatter
maxLineLength: anInteger
	MaxLineLength := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
methodSignatureOnMultipleLines
	^ MethodSignatureOnMultipleLines
%

category: 'accessing'
classmethod: RBConfigurableFormatter
methodSignatureOnMultipleLines: aBoolean
	MethodSignatureOnMultipleLines := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
minimumNewLinesBetweenStatements
	^ MinimumNewLinesBetweenStatements
%

category: 'accessing'
classmethod: RBConfigurableFormatter
minimumNewLinesBetweenStatements: anInteger
	MinimumNewLinesBetweenStatements := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineAfterCascade
	^ NewLineAfterCascade
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineAfterCascade: aBoolean
	NewLineAfterCascade := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstCascade
	^ NewLineBeforeFirstCascade
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstCascade: aBoolean
	NewLineBeforeFirstCascade := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstKeyword
	^ NewLineBeforeFirstKeyword
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLineBeforeFirstKeyword: aBoolean
	NewLineBeforeFirstKeyword := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodComment
	^ NewLinesAfterMethodComment
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodComment: anInteger
	NewLinesAfterMethodComment := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodPattern
	^ NewLinesAfterMethodPattern
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterMethodPattern: anInteger
	NewLinesAfterMethodPattern := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterTemporaries
	^ NewLinesAfterTemporaries
%

category: 'accessing'
classmethod: RBConfigurableFormatter
newLinesAfterTemporaries: anInteger
	NewLinesAfterTemporaries := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
numberOfArgumentsForMultiLine
	^ NumberOfArgumentsForMultiLine
%

category: 'accessing'
classmethod: RBConfigurableFormatter
numberOfArgumentsForMultiLine: anInteger
	NumberOfArgumentsForMultiLine := anInteger
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAsTerminators
	^ PeriodsAtEndOfBlock and: [ PeriodsAtEndOfMethod ]
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAsTerminators: aBoolean
	PeriodsAtEndOfBlock := aBoolean.
	PeriodsAtEndOfMethod := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfBlock
	^ PeriodsAtEndOfBlock
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfBlock: aBoolean
	PeriodsAtEndOfBlock := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfMethod
	^ PeriodsAtEndOfMethod
%

category: 'accessing'
classmethod: RBConfigurableFormatter
periodsAtEndOfMethod: aBoolean
	PeriodsAtEndOfMethod := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
retainBlankLinesBetweenStatements
	^ RetainBlankLinesBetweenStatements
%

category: 'accessing'
classmethod: RBConfigurableFormatter
retainBlankLinesBetweenStatements: aBoolean
	RetainBlankLinesBetweenStatements := aBoolean
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringFollowingReturn
	^ StringFollowingReturn
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringFollowingReturn: aString
	StringFollowingReturn := aString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideBlocks
	^ StringInsideBlocks
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideBlocks: aString
	StringInsideBlocks := aString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideParentheses
	^ StringInsideParentheses
%

category: 'accessing'
classmethod: RBConfigurableFormatter
stringInsideParentheses: aString
	StringInsideParentheses := aString
%

category: 'accessing'
classmethod: RBConfigurableFormatter
useTraditionalBinaryPrecedenceForParentheses
	^ UseTraditionalBinaryPrecedenceForParentheses
%

category: 'accessing'
classmethod: RBConfigurableFormatter
useTraditionalBinaryPrecedenceForParentheses: aBoolean
	UseTraditionalBinaryPrecedenceForParentheses := aBoolean
%

!		Instance methods for 'RBConfigurableFormatter'

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptArrayNode: anArrayNode
	self bracketWith: '{}' around: [ self formatArray: anArrayNode ]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptAssignmentNode: anAssignmentNode 
	self visitNode: anAssignmentNode variable.
	codeStream space; nextPutAll: anAssignmentNode assignmentOperator; space.
	self visitNode: anAssignmentNode value
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptBlockNode: aBlockNode
	self bracketWith: '[]' around: [self formatBlock: aBlockNode]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptCascadeNode: aCascadeNode 
	self visitNode: aCascadeNode receiver.
	self indentAround: 
			[NewLineBeforeFirstCascade ifTrue: [self newLine] ifFalse: [self space].
			aCascadeNode messages do: 
					[:each | 
					self indentAround: 
							[self 
								formatSelectorAndArguments: each
								firstSeparator: []
								restSeparator: ((self isMultiLineMessage: each) 
										ifTrue: [[self newLine]]
										ifFalse: [[self space]])]]
				separatedBy: 
					[codeStream nextPut: $;.
					NewLineAfterCascade ifTrue: [self newLine] ifFalse: [self space]]]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptLiteralArrayNode: aRBArrayLiteralNode 
	| brackets |
	codeStream nextPut: $#.
	brackets := aRBArrayLiteralNode isForByteArray 
				ifTrue: ['[]']
				ifFalse: ['()'].
	self bracketWith: brackets
		around: 
			[aRBArrayLiteralNode contents do: [:each | self visitNode: each]
				separatedBy: [self space]]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptLiteralNode: aLiteralNode 
	self writeString: aLiteralNode token rbStoreString
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptMessageNode: aMessageNode 
	self visitNode: aMessageNode receiver.
	self formatSelectorAndArguments: aMessageNode
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptMethodNode: aMethodNode 
	self formatMethodPatternFor: aMethodNode.
	self formatMethodBodyFor: aMethodNode
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptPatternBlockNode: aRBPatternBlockNode 
	codeStream nextPut: $`.
	self 
		bracketWith: '{}' 
		around: [self formatBlock: aRBPatternBlockNode]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	codeStream nextPut: $`.
	self 
		bracketWith: '{}' 
		around: [self formatBlock: aRBPatternWrapperBlockNode]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptPragmaNode: aPragmaNode
  codeStream nextPut: $<.
  aPragmaNode isProtected
    ifTrue: [ codeStream nextPutAll: 'protected ' ].
  self
    formatSelectorAndArguments: aPragmaNode
    firstSeparator: [ 
      aPragmaNode selector isInfix
        ifTrue: [ self space ] ]
    restSeparator: [ self space ].
  codeStream nextPut: $>
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptQueryBlockNode: aBlockNode
  self
    bracketWith: '{}'
    around: [ 
      [ 
      "query blocks are not nested"
      InQueryBlock := true.
      self formatBlock: aBlockNode ]
        ensure: [ InQueryBlock := false ] ]
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptReturnNode: aReturnNode 
	codeStream
		nextPut: $^;
		nextPutAll: StringFollowingReturn.
	self visitNode: aReturnNode value
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptSequenceNode: aSequenceNode 
	self formatTemporariesFor: aSequenceNode.
	self formatSequenceCommentsFor: aSequenceNode.
	self formatSequenceNodeStatementsFor: aSequenceNode
%

category: 'visitor-double dispatching'
method: RBConfigurableFormatter
acceptVariableNode: aVariableNode 
	codeStream nextPutAll: aVariableNode name
%

category: 'private'
method: RBConfigurableFormatter
addNewLinesBeforeStatementStartingAt: anInteger 
	| newLines |
	newLines := MinimumNewLinesBetweenStatements 
				max: (RetainBlankLinesBetweenStatements 
						ifTrue: [self newLinesBeforeStartingAt: anInteger]
						ifFalse: [0]).
	newLines = 0 ifTrue: [self space] ifFalse: [self newLines: newLines]
%

category: 'private'
method: RBConfigurableFormatter
bracketWith: bracketString around: aBlock 
	bracketString isEmpty ifTrue: [^aBlock value].
	codeStream nextPut: bracketString first.
	^aBlock ensure: [codeStream nextPut: bracketString last]
%

category: 'private'
method: RBConfigurableFormatter
currentLineLength
	^codeStream position - lineStart
%

category: 'public interface'
method: RBConfigurableFormatter
format: aParseTree 
	originalSource := aParseTree source.
	self visitNode: aParseTree.
	^codeStream contents
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatArray: anArrayNode
	self formatSequenceCommentsFor: anArrayNode.
	self formatSequenceNodeStatementsFor: anArrayNode
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatBlock: aBlockNode
	(LineUpBlockBrackets and: [ self willBeMultiline: aBlockNode body ])
		ifTrue: [ self newLine ]
		ifFalse: [ codeStream nextPutAll: StringInsideBlocks ].
	self formatBlockArgumentsFor: aBlockNode.
	(self willBeMultiline: aBlockNode body)
		ifTrue: [ self newLine ].
	self visitNode: aBlockNode body.
	(LineUpBlockBrackets and: [ self willBeMultiline: aBlockNode body ])
		ifTrue: [ self newLine ]
		ifFalse: [ codeStream nextPutAll: StringInsideBlocks ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatBlockArgumentsFor: aBlockNode
	aBlockNode arguments isEmpty
		ifTrue: [ ^ self ].
	aBlockNode arguments
		do: [ :each | 
			codeStream nextPut: $:.
			self visitNode: each.
			FormatCommentWithStatements
				ifTrue: [ self formatCommentsFor: each ].
			self space ].
	codeStream nextPutAll: '| '
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatCommentsFor: aNode 
	originalSource isNil ifTrue: [^self].
	aNode comments do: 
			[:each | 
			codeStream
				space;
				nextPutAll: (originalSource copyFrom: each first to: each last)]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatMethodBodyFor: aMethodNode 
	self
		indentAround: 
			[self newLines: NewLinesAfterMethodPattern.
			self formatMethodCommentFor: aMethodNode.
			self formatPragmasFor: aMethodNode.
			self visitNode: aMethodNode body]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatMethodCommentFor: aMethodNode
	originalSource isNil ifTrue: [^self].
	(FormatCommentWithStatements
		ifTrue: [aMethodNode methodComments]
		ifFalse: [aMethodNode comments])
		do:
			[:each | 
			codeStream
				nextPutAll:
					(originalSource
						copyFrom: each first
						to: each last).
			self newLines: NewLinesAfterMethodComment]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatMethodPatternFor: aMethodNode 
	aMethodNode arguments isEmpty
		ifTrue: [codeStream nextPutAll: aMethodNode selector]
		ifFalse: 
			[self
				with: aMethodNode selectorParts
				and: aMethodNode arguments
				do: 
					[:key :arg | 
					codeStream nextPutAll: key value.
					self space.
					self visitNode: arg]
				separatedBy: 
					[MethodSignatureOnMultipleLines
						ifTrue: [self newLine]
						ifFalse: [self space]]]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatPragmasFor: aMethodNode
	aMethodNode pragmas do: [ :each | self visitNode: each; newLine ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSelectorAndArguments: aMessageNode
	| newLineBetweenArguments |
	newLineBetweenArguments := self isMultiLineMessage: aMessageNode.
	self
		indent:
			(newLineBetweenArguments
				ifTrue: [ IndentsForKeywords ]
				ifFalse: [ 0 ])
		around: [ 
			self
				formatSelectorAndArguments: aMessageNode
				firstSeparator:
					((newLineBetweenArguments or: [ NewLineBeforeFirstKeyword ])
						ifTrue: [ [ self newLine ] ]
						ifFalse: [ [ self space ] ])
				restSeparator:
					(newLineBetweenArguments
						ifTrue: [ [ self newLine ] ]
						ifFalse: [ [ self space ] ]) ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSelectorAndArguments: aMessageNode firstSeparator: firstBlock restSeparator: restBlock
	| separatorBlock |
	separatorBlock := firstBlock.
	aMessageNode isUnary
		ifTrue: [ 
			(self isLineTooLong: aMessageNode selector)
				ifTrue: [ self newLine ]
				ifFalse: [ separatorBlock value ].
			codeStream nextPutAll: aMessageNode selector ]
		ifFalse: [ 
			aMessageNode selectorParts
				with: aMessageNode arguments
				do: [ :selector :argument | 
					(self isLineTooLong: selector value)
						ifTrue: [ self newLine ]
						ifFalse: [ separatorBlock value ].
					separatorBlock := restBlock.
					self
						indentAround: [ 
							codeStream nextPutAll: selector value.
							(KeepBlockInMessage and: [ argument isBlock ])
								ifTrue: [ 
									self
										space;
										visitNode: argument ]
								ifFalse: [ 
									((self willBeMultiline: argument) or: [ self isLineTooLong: (self formattedSourceFor: argument) ])
										ifTrue: [ self newLine ]
										ifFalse: [ self space ].
									self visitNode: argument ] ] ] ]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSequenceCommentsFor: aSequenceNode
	originalSource isNil ifTrue: [^self].
	aSequenceNode comments
		do:
			[:each | 
			codeStream
				nextPutAll:
					(originalSource
						copyFrom: each first
						to: each last).
			self newLine]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatSequenceNodeStatementsFor: aSequenceNode 
	| statements |
	statements := aSequenceNode statements.
	statements isEmpty ifTrue: [^self].
	1 to: statements size
		do: 
			[:i | 
			self visitNode: (statements at: i).
			(i < statements size or: 
					[| parent |
					(parent := aSequenceNode parent) ifNil: [self class periodsAsTerminators]
						ifNotNil: 
							[ 
							parent isBlock 
								ifTrue: [self class periodsAtEndOfBlock]
								ifFalse: [self class periodsAtEndOfMethod]]]) 
				ifTrue: [codeStream nextPut: $.].
			self formatStatementCommentsFor: (statements at: i).
			i < statements size 
				ifTrue: 
					[self addNewLinesBeforeStatementStartingAt: (statements at: i + 1) start]]
%

category: 'private-formatting'
method: RBConfigurableFormatter
formatStatementCommentsFor: aStatementNode
	originalSource isNil ifTrue: [^self].
	FormatCommentWithStatements ifFalse: [^self].
	aStatementNode statementComments
		do:
			[:each | 
			codeStream
				tab;
				nextPutAll:
						(originalSource
								copyFrom: each first
								to: each last)]
%

category: 'private'
method: RBConfigurableFormatter
formattedSourceFor: aNode 
	^lookaheadCode at: aNode
		ifAbsentPut: [self class format: aNode withIndents: indent]
%

category: 'private'
method: RBConfigurableFormatter
formatTemporariesFor: aSequenceNode
	aSequenceNode temporaries isEmpty ifTrue: [^self].
	self
		bracketWith: '|'
		around:
			[self space.
			aSequenceNode temporaries
				do:
					[:each | 
					self visitNode: each.
					FormatCommentWithStatements ifTrue: [self formatCommentsFor: each].
					self space]].
	self newLines: NewLinesAfterTemporaries
%

category: 'initialize-release'
method: RBConfigurableFormatter
indent: anInteger
	indent := anInteger
%

category: 'private'
method: RBConfigurableFormatter
indent: anInteger around: aBlock 
	indent := indent + anInteger.
	^aBlock ensure: [indent := indent - anInteger]
%

category: 'private'
method: RBConfigurableFormatter
indentAround: aBlock 
	self indent: 1 around: aBlock
%

category: 'initialize-release'
method: RBConfigurableFormatter
initialize
	super initialize.
	lineStart := 0.
	indent := 0.
	lookaheadCode := IdentityDictionary new.
	codeStream := WriteStreamPortable on: String new
%

category: 'private'
method: RBConfigurableFormatter
isLineTooLong: aString 
	^ self currentLineLength + (aString indexOf: Character lf ifAbsent: [ aString size ]) >= MaxLineLength
%

category: 'private-formatting'
method: RBConfigurableFormatter
isMultiLineMessage: aMessageNode
	| messageStream |
	(MultiLineMessages includes: aMessageNode selector)
		ifTrue: [ ^ true ].
	(OneLineMessages includes: aMessageNode selector)
		ifTrue: [ ^ false ].
	(NumberOfArgumentsForMultiLine <= aMessageNode arguments size)
		ifTrue: [ ^ true ].
	(aMessageNode arguments 
		anySatisfy: [ :each | self indent: IndentsForKeywords + 1 around: [ self willBeMultiline: each ] ]) 
		ifTrue: [ ^ true ].
	aMessageNode isUnary
		ifTrue: [ ^ self isLineTooLong: aMessageNode selector ].
	messageStream := WriteStreamPortable on: String new.
	self  with: aMessageNode selectorParts and: aMessageNode arguments 
		do: [ :sel :arg | messageStream nextPutAll: sel value; space; nextPutAll: (self formattedSourceFor: arg) ]
		separatedBy: [ messageStream space ].
	^ self isLineTooLong: messageStream contents
%

category: 'private'
method: RBConfigurableFormatter
needsParenthesisFor: aNode
  | parent grandparent |
  aNode isValue
    ifFalse: [ ^ false ].
  parent := aNode parent ifNil: [ ^ false ].
  (CascadedMessageInsideParentheses
    and: [ aNode isMessage and: [ parent isMessage and: [ parent receiver == aNode ] ] ])
    ifTrue: [ 
      grandparent := parent parent.
      (grandparent notNil and: [ grandparent isCascade ])
        ifTrue: [ ^ true ] ].
  InQueryBlock
    ifTrue: [ 
      aNode isVariable
        ifTrue: [ 
          (aNode token isPath
            and: [ 
              parent isMessage
                and: [ parent receiver == aNode and: [ aNode parent selector == #'&' ] ] ])
            ifTrue: [ ^ true ] ] ].
  aNode precedence < parent precedence
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ parent isAssignment ])
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ aNode isCascade ])
    ifTrue: [ ^ true ].
  aNode precedence = 0
    ifTrue: [ ^ false ].
  aNode isMessage
    ifFalse: [ ^ true ].
  aNode precedence = parent precedence
    ifFalse: [ ^ true ].
  aNode isUnary
    ifTrue: [ ^ false ].
  aNode isKeyword
    ifTrue: [ ^ true ].
  parent receiver == aNode
    ifFalse: [ ^ true ].
  InQueryBlock
    ifTrue: [ ^ aNode receiver isMessage not and: [ aNode selector ~~ #'&' ] ].
  ^ UseTraditionalBinaryPrecedenceForParentheses
    and: [ self precedenceOf: parent selector greaterThan: aNode selector ]
%

category: 'private'
method: RBConfigurableFormatter
newLine
	self newLines: 1
%

category: 'private'
method: RBConfigurableFormatter
newLines: anInteger 
	anInteger + IndentString size = 0 ifTrue: [codeStream space].
	anInteger timesRepeat: [codeStream lf].
	lineStart := codeStream position.
	indent timesRepeat: [codeStream nextPutAll: IndentString]
%

category: 'private'
method: RBConfigurableFormatter
newLinesBeforeStartingAt: anIndex 
	| count cr lf index char |
	(anIndex isNil or: [anIndex > originalSource size]) ifTrue: [^0].
	cr := Character value: 13.
	lf := Character value: 10.
	count := 0.
	index := anIndex - 1.
	[index > 0 and: [(char := originalSource at: index) isSqueakSeparator]] 
		whileTrue: 
			[char == lf 
				ifTrue: 
					[count := count + 1.
					(originalSource at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].
			char == cr ifTrue: [count := count + 1].
			index := index - 1].
	^count
%

category: 'private'
method: RBConfigurableFormatter
precedenceOf: parentSelector greaterThan: childSelector 
	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 
	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"

	| childIndex parentIndex |
	childIndex := 0.
	parentIndex := 0.
	1 to: TraditionalBinaryPrecedence size
		do: 
			[:i | 
			((TraditionalBinaryPrecedence at: i) includes: parentSelector first) 
				ifTrue: [parentIndex := i].
			((TraditionalBinaryPrecedence at: i) includes: childSelector first) 
				ifTrue: [childIndex := i]].
	^childIndex < parentIndex
%

category: 'private'
method: RBConfigurableFormatter
space
	codeStream space
%

category: 'visiting'
method: RBConfigurableFormatter
visitNode: aNode
	| needsParenthesis |
	(lookaheadCode includesKey: aNode)
		ifTrue: [^self writeString: (lookaheadCode at: aNode)].
	needsParenthesis := self needsParenthesisFor: aNode.
	self
		bracketWith:
			(needsParenthesis
				ifTrue: ['()']
				ifFalse: [''])
		around:
			[needsParenthesis ifTrue: [codeStream nextPutAll: StringInsideParentheses].
			super visitNode: aNode.
			(FormatCommentWithStatements or: [aNode isMethod or: [aNode isSequence]])
				ifFalse: [self formatCommentsFor: aNode].
			needsParenthesis
				ifTrue: [codeStream nextPutAll: StringInsideParentheses]]
%

category: 'private'
method: RBConfigurableFormatter
willBeMultiline: aNode 
	^(self formattedSourceFor: aNode) includes: Character lf
%

category: 'utility'
method: RBConfigurableFormatter
with: firstCollection and: secondCollection do: aBlock separatedBy: separatorBlock 
	firstCollection isEmpty ifTrue: [^self].
	aBlock
		value: firstCollection first
		value: secondCollection first.
	2
		to: firstCollection size
		do: 
			[:i | 
			separatorBlock value.
			aBlock
				value: (firstCollection at: i)
				value: (secondCollection at: i)]
%

category: 'private'
method: RBConfigurableFormatter
writeString: aString 
	| index |
	index := aString lastIndexOf: Character lf startingAt: aString size ifAbsent: [0].
	codeStream nextPutAll: aString.
	index > 0 
		ifTrue: [lineStart := codeStream position - (aString size - index)]
%

! Class implementation for 'RBFormatter'

!		Instance methods for 'RBFormatter'

category: 'visitor-double dispatching'
method: RBFormatter
acceptArrayNode: anArrayNode
	codeStream nextPut: ${.
	anArrayNode statements isEmpty ifFalse: [
		anArrayNode statements size > 1
			ifTrue: [
				self indent: 1 while: [
					self indent.
					self formatStatementsFor: anArrayNode ].
				self indent ]
			ifFalse: [ self formatStatementsFor: anArrayNode ] ].
	codeStream nextPut: $}
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptAssignmentNode: anAssignmentNode 
	self indent: 2
		while: 
			[self visitNode: anAssignmentNode variable.
			codeStream space; nextPutAll: anAssignmentNode assignmentOperator; space.
			self visitNode: anAssignmentNode value]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptBlockNode: aBlockNode 
	self 
		acceptBlockNode: aBlockNode
		startBlockString: '['
		endBlockString: ']'
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString 
	| seqNode multiline formattedBody formatter |
	seqNode := aBlockNode body.
	formatter := (self copy)
				lineStart: 0;
				yourself.
	formattedBody := formatter format: seqNode.
	multiline := self lineLength + formattedBody size > self maxLineSize 
				or: [formatter isMultiLine].
	multiline ifTrue: [self indent].
	codeStream nextPutAll: startBlockString.
	aBlockNode arguments do: 
			[:each | 
			codeStream nextPut: $:.
			self visitNode: each.
			codeStream nextPut: $ ].
	aBlockNode arguments notEmpty 
		ifTrue: 
			[codeStream nextPutAll: '| '.
			multiline ifTrue: [self indent]].
	codeStream
		nextPutAll: formattedBody;
		nextPutAll: endBlockString
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptCascadeNode: aCascadeNode 
	| messages |
	messages := aCascadeNode messages.
	self visitNode: messages first receiver.
	self indentWhile: 
			[self 
				for: messages
				do: 
					[:each | 
					self
						indent;
						indentWhile: [self formatMessage: each cascade: true]]
				separatedBy: [codeStream nextPut: $;]]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptLiteralArrayNode: aRBArrayLiteralNode 
	codeStream nextPutAll: (aRBArrayLiteralNode isForByteArray 
				ifTrue: ['#[']
				ifFalse: ['#(']).
	self 
		for: aRBArrayLiteralNode contents
		do: [:each | self visitNode: each]
		separatedBy: [codeStream nextPut: $ ].
	codeStream 
		nextPut: (aRBArrayLiteralNode isForByteArray ifTrue: [$]] ifFalse: [$)])
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptLiteralNode: aLiteralNode 
	aLiteralNode token rbStoreOn: codeStream
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptMessageNode: aMessageNode 
	| newFormatter code |
	newFormatter := self copy.
	code := newFormatter format: aMessageNode receiver.
	codeStream nextPutAll: code.
	codeStream nextPut: $ .
	newFormatter isMultiLine
		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].
	self indent: (newFormatter isMultiLine ifTrue: [2] ifFalse: [1])
		while: [self formatMessage: aMessageNode cascade: false]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptMethodNode: aMethodNode 
	self formatMethodPatternFor: aMethodNode.
	self indentWhile: [
		self formatMethodCommentFor: aMethodNode indentBefore: true.
		self indent.
		self formatPragmasFor: aMethodNode.
		aMethodNode body statements notEmpty 
			ifTrue: [ self visitNode: aMethodNode body ] ]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptPatternBlockNode: aRBPatternBlockNode 
	self 
		acceptBlockNode: aRBPatternBlockNode
		startBlockString: '`{'
		endBlockString: '}'
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 
	self visitNode: aRBPatternWrapperBlockNode wrappedNode.
	self 
		acceptBlockNode: aRBPatternWrapperBlockNode
		startBlockString: '`{'
		endBlockString: '}'
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptPragmaNode: aPragmaNode
  codeStream nextPut: $<.
  aPragmaNode isProtected
    ifTrue: [ codeStream nextPutAll: 'protected ' ].
  aPragmaNode selector isInfix
    ifTrue: [ codeStream nextPut: $  ].
  self formatMessage: aPragmaNode cascade: false.
  codeStream nextPut: $>
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptQueryBlockNode: aBlockNode
  [ 
  inQueryBlock := true.
  self
    acceptQueryBlockNode: aBlockNode
    startBlockString: '{'
    endBlockString: '}' ]
    ensure: [ inQueryBlock := false ]
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptQueryBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString
  | seqNode multiline formattedBody formatter |
  seqNode := aBlockNode body.
  formatter := self copy
    lineStart: 0;
    yourself.
  formattedBody := formatter format: seqNode.
  multiline := self lineLength + formattedBody size > self maxLineSize
    or: [ formatter isMultiLine ].
  multiline
    ifTrue: [ self indent ].
  codeStream nextPutAll: startBlockString.
  aBlockNode arguments
    do: [ :each | 
      codeStream nextPut: $:.
      self visitNode: each.
      codeStream nextPut: $  ].
  aBlockNode arguments notEmpty
    ifTrue: [ 
      codeStream nextPutAll: '| '.
      multiline
        ifTrue: [ self indent ] ].
  codeStream
    nextPutAll: formattedBody;
    nextPutAll: endBlockString
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptReturnNode: aReturnNode 
	codeStream nextPut: $^.
	self visitNode: aReturnNode value
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptSequenceNode: aSequenceNode 
	self formatMethodCommentFor: aSequenceNode indentBefore: false.
	self formatTemporariesFor: aSequenceNode.
	self formatStatementsFor: aSequenceNode
%

category: 'visitor-double dispatching'
method: RBFormatter
acceptVariableNode: aVariableNode 
	codeStream nextPutAll: aVariableNode name
%

category: 'accessing'
method: RBFormatter
firstLineLength
	^firstLineLength isNil
		ifTrue: [codeStream position]
		ifFalse: [firstLineLength]
%

category: 'private'
method: RBFormatter
for: aValue do: doBlock separatedBy: separatorBlock 
	"This is implemented here since IBM Smalltalk doesn't implement a do:separatedBy: method"

	aValue isEmpty ifTrue: [^self].
	1 to: aValue size - 1
		do: 
			[:i | 
			doBlock value: (aValue at: i).
			separatorBlock value].
	doBlock value: aValue last
%

category: 'accessing'
method: RBFormatter
format: aNode 
	self visitNode: aNode.
	^codeStream contents
%

category: 'private-formatting'
method: RBFormatter
formatMessage: aMessageNode cascade: cascadeBoolean 
	| selectorParts arguments multiLine formattedArgs indentFirst firstArgLength length |
	selectorParts := aMessageNode selectorParts.
	arguments := aMessageNode arguments.
	formattedArgs := OrderedCollection new.
	multiLine := aMessageNode selector numArgs > self maximumArgumentsPerLine.
	length := aMessageNode selector size + arguments size + 1.
	firstArgLength := 0.
	self indentWhile: 
			[1 to: arguments size
				do: 
					[:i | 
					| formatter string |
					formatter := (self copy)
								lineStart: (selectorParts at: i) length negated;
								yourself.
					string := formatter format: (arguments at: i).
					formattedArgs add: string.
					i == 1 ifTrue: [firstArgLength := formatter firstLineLength].
					length := length + string size.
					multiLine := multiLine or: [formatter isMultiLine]]].
	multiLine := multiLine or: [length + self lineLength > self maxLineSize].
	indentFirst := cascadeBoolean not and: 
					[multiLine and: 
							[(self startMessageSendOnNewLine: aMessageNode) or: 
									[self lineLength + selectorParts first length + 2 + firstArgLength 
										> self maxLineSize]]].
	indentFirst ifTrue: [self indent].
	self 
		formatMessageSelector: selectorParts
		withArguments: formattedArgs
		multiline: multiLine
%

category: 'private-formatting'
method: RBFormatter
formatMessageSelector: selectorParts withArguments: formattedArgs multiline: multiLine 
	formattedArgs isEmpty 
		ifTrue: [codeStream nextPutAll: selectorParts first value]
		ifFalse: 
			[1 to: formattedArgs size
				do: 
					[:i | 
					(i ~= 1 and: [ multiLine not ])
						ifTrue: [codeStream nextPut: $ ].
					codeStream 
						nextPutAll: (selectorParts at: i) value;
						nextPut: $ ;
						nextPutAll: (formattedArgs at: i).
					(multiLine and: [i < formattedArgs size]) ifTrue: [self indent]]]
%

category: 'private-formatting'
method: RBFormatter
formatMethodCommentFor: aNode indentBefore: aBoolean 
	| source |
	source := aNode source.
	source isNil ifTrue: [^self].
	aNode methodComments do: 
			[:each | 
			aBoolean ifTrue: [self indent].
			codeStream
				nextPutAll: (aNode source copyFrom: each first to: each last);
				lf.
			aBoolean ifFalse: [self indent]]
%

category: 'private-formatting'
method: RBFormatter
formatMethodPatternFor: aMethodNode 
	| selectorParts arguments |
	selectorParts := aMethodNode selectorParts.
	arguments := aMethodNode arguments.
	arguments isEmpty 
		ifTrue: [codeStream nextPutAll: selectorParts first value]
		ifFalse: 
			[selectorParts with: arguments
				do: 
					[:selector :arg | 
					codeStream
						nextPutAll: selector value;
						nextPut: $ .
					self visitArgument: arg.
					codeStream nextPut: $ ]]
%

category: 'private-formatting'
method: RBFormatter
formatPragmasFor: aNode
	aNode pragmas do: [ :each | self visitNode: each; indent ]
%

category: 'private-formatting'
method: RBFormatter
formatStatementCommentFor: aNode 
	| source |
	source := aNode source.
	source isNil ifTrue: [^self].
	aNode statementComments do: 
			[:each | 
			| crs |
			crs := self newLinesFor: source startingAt: each first.
			(crs - 1 max: 0) timesRepeat: [codeStream lf].
			crs == 0 ifTrue: [codeStream tab] ifFalse: [self indent].
			codeStream nextPutAll: (source copyFrom: each first to: each last)]
%

category: 'private-formatting'
method: RBFormatter
formatStatementsFor: aSequenceNode 
	| statements |
	statements := aSequenceNode statements.
	statements isEmpty ifTrue: [^self].
	1 to: statements size - 1
		do: 
			[:i | 
			self visitNode: (statements at: i).
			codeStream nextPut: $..
			self formatStatementCommentFor: (statements at: i).
			self indent].
	self visitNode: statements last.
	self formatStatementCommentFor: statements last
%

category: 'private-formatting'
method: RBFormatter
formatTemporariesFor: aSequenceNode 
	| temps |
	temps := aSequenceNode temporaries.
	temps isEmpty ifTrue: [^self].
	codeStream nextPutAll: '| '.
	temps do: 
			[:each | 
			self visitArgument: each.
			codeStream nextPut: $ ].
	codeStream nextPut: $|.
	self indent
%

category: 'private'
method: RBFormatter
indent
	firstLineLength isNil ifTrue: [firstLineLength := codeStream position].
	codeStream lf.
	tabs timesRepeat: [codeStream tab].
	lineStart := codeStream position
%

category: 'private'
method: RBFormatter
indent: anInteger while: aBlock 
	tabs := tabs + anInteger.
	aBlock value.
	tabs := tabs - anInteger
%

category: 'private'
method: RBFormatter
indentWhile: aBlock 
	self indent: 1 while: aBlock
%

category: 'initialize-release'
method: RBFormatter
initialize
  super initialize.
  codeStream := WriteStreamPortable on: String new.
  tabs := 0.
  lineStart := 0.
  inQueryBlock := false
%

category: 'accessing'
method: RBFormatter
isMultiLine
	^firstLineLength notNil
%

category: 'accessing'
method: RBFormatter
lastLineLength
	^codeStream position - (lineStart max: 0)
%

category: 'private'
method: RBFormatter
lineLength
	^codeStream position - lineStart
%

category: 'private'
method: RBFormatter
lineStart: aPosition 
	lineStart := aPosition
%

category: 'private'
method: RBFormatter
maximumArgumentsPerLine
	^2
%

category: 'private'
method: RBFormatter
maxLineSize
	^75
%

category: 'private'
method: RBFormatter
needsParenthesisFor: aNode
  | parent grandparent |
  aNode isValue
    ifFalse: [ ^ false ].
  parent := aNode parent ifNil: [ ^ false ].
  (aNode isMessage and: [ parent isMessage and: [ parent receiver == aNode ] ])
    ifTrue: [ 
      grandparent := parent parent.
      (grandparent notNil and: [ grandparent isCascade ])
        ifTrue: [ ^ true ] ].
  inQueryBlock
    ifTrue: [ 
      aNode isLiteralNode
        ifTrue: [ 
          (parent isMessage
            and: [ parent receiver == aNode and: [ aNode parent selector == #'&' ] ])
            ifTrue: [ ^ true ] ].
      aNode isVariable
        ifTrue: [ 
          (aNode token isPath
            and: [ 
              parent isMessage
                and: [ parent receiver == aNode and: [ aNode parent selector == #'&' ] ] ])
            ifTrue: [ ^ true ] ] ].
  aNode precedence < parent precedence
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ parent isAssignment ])
    ifTrue: [ ^ false ].
  (aNode isAssignment and: [ aNode isCascade ])
    ifTrue: [ ^ true ].
  aNode precedence = 0
    ifTrue: [ ^ false ].
  aNode isMessage
    ifFalse: [ ^ true ].
  aNode precedence = parent precedence
    ifFalse: [ ^ true ].
  aNode isUnary
    ifTrue: [ ^ false ].
  aNode isKeyword
    ifTrue: [ ^ true ].
  parent receiver == aNode
    ifFalse: [ ^ true ].
  inQueryBlock
    ifTrue: [ ^ aNode receiver isMessage not and: [ aNode selector ~~ #'&' ] ].
  ^ self precedenceOf: parent selector greaterThan: aNode selector
%

category: 'private-formatting'
method: RBFormatter
newLinesFor: aString startingAt: anIndex 
	| count cr lf index char |
	cr := Character codePoint: 13.
	lf := Character codePoint: 10.
	count := 0.
	index := anIndex - 1.
	[index > 0 and: 
			[char := aString at: index.
			char isSeparator]] 
		whileTrue: 
			[char == lf 
				ifTrue: 
					[count := count + 1.
					(aString at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].
			char == cr ifTrue: [count := count + 1].
			index := index - 1].
	^count
%

category: 'copying'
method: RBFormatter
postCopy
	super postCopy.
	lineStart := self lineLength negated.
	codeStream := WriteStreamPortable on: String new.
	firstLineLength := nil
%

category: 'private'
method: RBFormatter
precedenceOf: parentSelector greaterThan: childSelector 
	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 
	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"

	| childIndex parentIndex operators |
	operators := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).
	childIndex := 0.
	parentIndex := 0.
	1 to: operators size
		do: 
			[:i | 
			((operators at: i) includes: parentSelector first) 
				ifTrue: [parentIndex := i].
			((operators at: i) includes: childSelector first) 
				ifTrue: [childIndex := i]].
	^childIndex < parentIndex
%

category: 'private'
method: RBFormatter
selectorsToLeaveOnLine
	^#(#to:do: #to:by: #to:by:do:)
%

category: 'private'
method: RBFormatter
selectorsToStartOnNewLine
	^#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse:)
%

category: 'testing'
method: RBFormatter
startMessageSendOnNewLine: aMessageNode 
	(self selectorsToStartOnNewLine includes: aMessageNode selector) 
		ifTrue: [^true].
	(self selectorsToLeaveOnLine includes: aMessageNode selector) 
		ifTrue: [^false].
	^aMessageNode selector numArgs > self maximumArgumentsPerLine
%

category: 'visiting'
method: RBFormatter
visitNode: aNode
  | parenthesis |
  parenthesis := self needsParenthesisFor: aNode.
  parenthesis
    ifTrue: [ codeStream nextPut: $( ].
  aNode acceptVisitor: self.
  parenthesis
    ifTrue: [ codeStream nextPut: $) ]
%

! Class implementation for 'RBParseTreeSearcher'

!		Class methods for 'RBParseTreeSearcher'

category: 'private'
classmethod: RBParseTreeSearcher
buildSelectorString: aSelector 
	| stream keywords |
	aSelector numArgs = 0 ifTrue: [^aSelector].
	stream := WriteStreamPortable on: String new.
	keywords := aSelector keywords.
	1 to: keywords size
		do: 
			[:i | 
			stream
				nextPutAll: (keywords at: i);
				nextPutAll: ' ``@arg';
				nextPutAll: i printString;
				nextPut: $ ].
	^stream contents
%

category: 'private'
classmethod: RBParseTreeSearcher
buildSelectorTree: aSelector 
	aSelector isEmpty ifTrue: [^nil].
	^RBParser parseRewriteExpression: '``@receiver ' 
				, (self buildSelectorString: aSelector)
		onError: [:err :pos | ^nil]
%

category: 'private'
classmethod: RBParseTreeSearcher
buildTree: aString method: aBoolean 
	^aBoolean 
		ifTrue: [RBParser parseRewriteMethod: aString]
		ifFalse: [RBParser parseRewriteExpression: aString]
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
getterMethod: aVarName 
	^(self new)
		matchesMethod: '`method ^' , aVarName do: [:aNode :ans | aNode selector];
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
justSendsSuper
	^ self new
		matchesAnyMethodOf: #(
			'`@method: `@args ^ super `@method: `@args' 
			'`@method: `@args super `@method: `@args')
		do: [ :node :answer | true ];
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
returnSetterMethod: aVarName 
	^(self new)
		matchesMethod: '`method: `Arg ^' , aVarName , ' := `Arg'
			do: [:aNode :ans | aNode selector];
		yourself
%

category: 'instance creation'
classmethod: RBParseTreeSearcher
setterMethod: aVarName 
	^(self new)
		matchesAnyMethodOf: (Array with: '`method: `Arg ' , aVarName , ' := `Arg'
					with: '`method: `Arg ^' , aVarName , ' := `Arg')
			do: [:aNode :ans | aNode selector];
		yourself
%

category: 'accessing'
classmethod: RBParseTreeSearcher
treeMatching: aString in: aParseTree 
	(self new)
		matches: aString do: [:aNode :answer | ^aNode];
		executeTree: aParseTree.
	^nil
%

category: 'accessing'
classmethod: RBParseTreeSearcher
treeMatchingStatements: aString in: aParseTree 
	| notifier tree |
	notifier := self new.
	tree := RBParser parseExpression: aString.
	tree isSequence 
		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].
	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).
	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').
	tree lastIsReturn 
		ifFalse: [tree addNode: (RBPatternVariableNode named: '`@.S2')].
	notifier matchesTree: tree
		do: [:aNode :answer | ^RBParser parseExpression: aString].
	notifier executeTree: aParseTree.
	^nil
%

!		Instance methods for 'RBParseTreeSearcher'

category: 'accessing'
method: RBParseTreeSearcher
addArgumentRule: aParseTreeRule 
	argumentSearches add: aParseTreeRule.
	aParseTreeRule owner: self
%

category: 'accessing'
method: RBParseTreeSearcher
addArgumentRules: ruleCollection 
	ruleCollection do: [:each | self addArgumentRule: each]
%

category: 'accessing'
method: RBParseTreeSearcher
addRule: aParseTreeRule 
	searches add: aParseTreeRule.
	aParseTreeRule owner: self
%

category: 'accessing'
method: RBParseTreeSearcher
addRules: ruleCollection 
	ruleCollection do: [:each | self addRule: each]
%

category: 'accessing'
method: RBParseTreeSearcher
answer
	^answer
%

category: 'initialize-release'
method: RBParseTreeSearcher
answer: anObject
	answer := anObject
%

category: 'testing'
method: RBParseTreeSearcher
canMatchMethod: aCompiledMethod
	| actualMessages |
	self messages isEmpty
		ifTrue: [ ^ true ].
	actualMessages := aCompiledMethod messages.
	^ self messages 
		anySatisfy: [ :each | actualMessages includes: each ]
%

category: 'accessing'
method: RBParseTreeSearcher
context
	^context
%

category: 'accessing'
method: RBParseTreeSearcher
executeMethod: aParseTree initialAnswer: anObject 
	answer := anObject.
	searches detect: [:each | (each performOn: aParseTree) notNil] ifNone: [].
	^answer
%

category: 'accessing'
method: RBParseTreeSearcher
executeTree: aParseTree 
	"Save our current context, in case someone is performing another search inside a match."

	| oldContext |
	oldContext := context.
	context := RBSmallDictionary new.
	self visitNode: aParseTree.
	context := oldContext.
	^answer
%

category: 'accessing'
method: RBParseTreeSearcher
executeTree: aParseTree initialAnswer: aValue 
	answer := aValue.
	^self executeTree: aParseTree
%

category: 'private'
method: RBParseTreeSearcher
foundMatch
%

category: 'testing'
method: RBParseTreeSearcher
hasRules
	^searches notEmpty
%

category: 'initialize-release'
method: RBParseTreeSearcher
initialize
	super initialize.
	context := RBSmallDictionary new.
	searches := OrderedCollection new.
	argumentSearches := OrderedCollection new: 0.
	answer := nil
%

category: 'private'
method: RBParseTreeSearcher
lookForMoreMatchesInContext: oldContext 
	oldContext keysAndValuesDo: 
			[:key :value | 
			(key isString not and: [key recurseInto]) 
				ifTrue: [value do: [:each | self visitNode: each]]]
%

category: 'searching'
method: RBParseTreeSearcher
matches: aString do: aBlock 
	self addRule: (RBSearchRule searchFor: aString thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyArgumentOf: stringCollection do: aBlock 
	stringCollection do: [:each | self matchesArgument: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyMethodOf: aStringCollection do: aBlock 
	aStringCollection do: [:each | self matchesMethod: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyOf: aStringCollection do: aBlock 
	aStringCollection do: [:each | self matches: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesAnyTreeOf: treeCollection do: aBlock 
	treeCollection do: [:each | self matchesTree: each do: aBlock]
%

category: 'searching'
method: RBParseTreeSearcher
matchesArgument: aString do: aBlock 
	self addArgumentRule: (RBSearchRule searchFor: aString thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesArgumentTree: aBRProgramNode do: aBlock 
	self 
		addArgumentRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesMethod: aString do: aBlock 
	self addRule: (RBSearchRule searchForMethod: aString thenDo: aBlock)
%

category: 'searching'
method: RBParseTreeSearcher
matchesTree: aBRProgramNode do: aBlock 
	self addRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)
%

category: 'accessing'
method: RBParseTreeSearcher
messages
	messages notNil ifTrue: [^messages].
	argumentSearches notEmpty ifTrue: [^messages := #()].
	messages := Set new.
	searches do: 
			[:each | 
			| searchMessages |
			searchMessages := each sentMessages.
			RBProgramNode optimizedSelectors 
				do: [:sel | searchMessages remove: sel ifAbsent: []].
			searchMessages isEmpty ifTrue: [^messages := #()].
			messages addAll: searchMessages].
	^messages := messages asArray
%

category: 'private'
method: RBParseTreeSearcher
performSearches: aSearchCollection on: aNode 
	| value |
	1 to: aSearchCollection size
		do: 
			[:i | 
			value := (aSearchCollection at: i) performOn: aNode.
			value notNil 
				ifTrue: 
					[self foundMatch.
					^value]].
	^nil
%

category: 'private'
method: RBParseTreeSearcher
recusivelySearchInContext
	"We need to save the matched context since the other searches might overwrite it."

	| oldContext |
	oldContext := context.
	context := RBSmallDictionary new.
	self lookForMoreMatchesInContext: oldContext.
	context := oldContext
%

category: 'visiting'
method: RBParseTreeSearcher
visitArgument: aNode 
	| value |
	value := self performSearches: argumentSearches on: aNode.
	^value isNil 
		ifTrue: 
			[aNode acceptVisitor: self.
			aNode]
		ifFalse: [value]
%

category: 'visiting'
method: RBParseTreeSearcher
visitNode: aNode 
	| value |
	value := self performSearches: searches on: aNode.
	^value isNil 
		ifTrue: 
			[aNode acceptVisitor: self.
			aNode]
		ifFalse: [value]
%

! Class implementation for 'RBParseTreeRewriter'

!		Class methods for 'RBParseTreeRewriter'

category: 'instance creation'
classmethod: RBParseTreeRewriter
removeTemporaryNamed: aName 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule replace: '| `@temps1 ' , aName , ' `@temps2 | ``@.Statements'
		with: '| `@temps1  `@temps2 | ``@.Statements'.
	^rewriteRule
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
rename: varName to: newVarName 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule
		replace: varName with: newVarName;
		replaceArgument: varName with: newVarName.
	^rewriteRule
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
rename: varName to: newVarName handler: aBlock 
	"Rename varName to newVarName, evaluating aBlock if there is a 
	temporary variable with the same name as newVarName. This 
	does not change temporary variables with varName."

	| rewriteRule |
	rewriteRule := self new.
	rewriteRule
		replace: varName with: newVarName;
		replaceArgument: newVarName
			withValueFrom: 
				[:aNode | 
				aBlock value.
				aNode].
	^rewriteRule
%

category: 'accessing'
classmethod: RBParseTreeRewriter
replace: code with: newCode in: aParseTree 
	^(self 
		replace: code
		with: newCode
		method: false)
		executeTree: aParseTree;
		tree
%

category: 'accessing'
classmethod: RBParseTreeRewriter
replace: code with: newCode in: aParseTree onInterval: anInterval 
	| rewriteRule |
	rewriteRule := self new.
	^rewriteRule
		replace: code
			with: newCode
			when: [:aNode | aNode intersectsInterval: anInterval];
		executeTree: aParseTree;
		tree
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
replace: code with: newCode method: aBoolean 
	| rewriteRule |
	rewriteRule := self new.
	aBoolean 
		ifTrue: [rewriteRule replaceMethod: code with: newCode]
		ifFalse: [rewriteRule replace: code with: newCode].
	^rewriteRule
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
replaceLiteral: literal with: newLiteral 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule replaceTree: (RBLiteralNode value: literal)
		withTree: (RBLiteralNode value: newLiteral).
	^rewriteRule
%

category: 'accessing'
classmethod: RBParseTreeRewriter
replaceStatements: code with: newCode in: aParseTree onInterval: anInterval 
	| tree replaceStmt |
	tree := self buildTree: code method: false.
	tree isSequence 
		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].
	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).
	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').
	tree lastIsReturn 
		ifTrue: [replaceStmt := '| `@temps | `@.S1. ^' , newCode]
		ifFalse: 
			[tree addNode: (RBPatternVariableNode named: '`@.S2').
			replaceStmt := '| `@temps | `@.S1. ' , newCode , '. `@.S2'].
	^self 
		replace: tree formattedCode
		with: replaceStmt
		in: aParseTree
		onInterval: anInterval
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
variable: aVarName getter: getMethod setter: setMethod 
	^self 
		variable: aVarName
		getter: getMethod
		setter: setMethod
		receiver: 'self'
%

category: 'instance creation'
classmethod: RBParseTreeRewriter
variable: aVarName getter: getMethod setter: setMethod receiver: aString 
	| rewriteRule |
	rewriteRule := self new.
	rewriteRule
		replace: aVarName , ' := ``@object'
			with: aString , ' ' , setMethod , ' ``@object';
		replace: aVarName with: aString , ' ' , getMethod.
	^rewriteRule
%

!		Instance methods for 'RBParseTreeRewriter'

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptArrayNode: anArrayNode
	anArrayNode statements: (anArrayNode statements 
				collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptAssignmentNode: anAssignmentNode 
	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).
	anAssignmentNode value: (self visitNode: anAssignmentNode value)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptBlockNode: aBlockNode 
	aBlockNode arguments: (self visitArguments: aBlockNode arguments).
	aBlockNode body: (self visitNode: aBlockNode body)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptCascadeNode: aCascadeNode 
	| newMessages notFound |
	newMessages := OrderedCollection new: aCascadeNode messages size.
	notFound := OrderedCollection new: aCascadeNode messages size.
	aCascadeNode messages do: 
			[:each | 
			| newNode |
			newNode := self performSearches: searches on: each.
			newNode isNil 
				ifTrue: 
					[newNode := each.
					notFound add: newNode].
			newNode isMessage 
				ifTrue: [newMessages add: newNode]
				ifFalse: 
					[newNode isCascade 
						ifTrue: [newMessages addAll: newNode messages]
						ifFalse: 
							[Transcript
								show: 'Cannot replace message node inside of cascaded node with non-message node.';
								cr.
							newMessages add: each]]].
	notFound size = aCascadeNode messages size 
		ifTrue: 
			[| receiver |
			receiver := self visitNode: aCascadeNode messages first receiver.
			newMessages do: [:each | each receiver: receiver]].
	notFound 
		do: [:each | each arguments: (each arguments collect: [:arg | self visitNode: arg])].
	aCascadeNode messages: newMessages
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptLiteralArrayNode: aRBArrayLiteralNode 
	aRBArrayLiteralNode contents: (aRBArrayLiteralNode contents 
				collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptMessageNode: aMessageNode 
	aMessageNode receiver: (self visitNode: aMessageNode receiver).
	aMessageNode 
		arguments: (aMessageNode arguments collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptMethodNode: aMethodNode 
	aMethodNode arguments: (self visitArguments: aMethodNode arguments).
	aMethodNode pragmas: (aMethodNode pragmas 
		collect: [:each | self visitNode: each]).
	aMethodNode body: (self visitNode: aMethodNode body)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptPragmaNode: aPragmaNode 
	aPragmaNode arguments: (aPragmaNode arguments collect: [:each | self visitNode: each])
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptReturnNode: aReturnNode 
	aReturnNode value: (self visitNode: aReturnNode value)
%

category: 'visitor-double dispatching'
method: RBParseTreeRewriter
acceptSequenceNode: aSequenceNode 
	aSequenceNode 
		temporaries: (self visitArguments: aSequenceNode temporaries).
	aSequenceNode statements: (aSequenceNode statements 
				collect: [:each | self visitNode: each])
%

category: 'accessing'
method: RBParseTreeRewriter
executeTree: aParseTree 
	| oldContext |
	oldContext := context.
	context := RBSmallDictionary new.
	answer := false.
	tree := self visitNode: aParseTree.
	context := oldContext.
	^answer
%

category: 'private'
method: RBParseTreeRewriter
foundMatch
	answer := true
%

category: 'private'
method: RBParseTreeRewriter
lookForMoreMatchesInContext: oldContext 
	oldContext keysAndValuesDo: 
			[:key :value | 
			(key isString not and: [key recurseInto]) 
				ifTrue: 
					[oldContext at: key put: (value collect: [:each | self visitNode: each])]]
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString with: replaceString 
	self addRule: (RBStringReplaceRule searchFor: searchString
				replaceWith: replaceString)
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString with: replaceString when: aBlock 
	self addRule: (RBStringReplaceRule 
				searchFor: searchString
				replaceWith: replaceString
				when: aBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString withValueFrom: replaceBlock 
	self addRule: (RBBlockReplaceRule searchFor: searchString
				replaceWith: replaceBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replace: searchString withValueFrom: replaceBlock when: conditionBlock 
	self addRule: (RBBlockReplaceRule 
				searchFor: searchString
				replaceWith: replaceBlock
				when: conditionBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString with: replaceString 
	self addArgumentRule: (RBStringReplaceRule searchFor: searchString
				replaceWith: replaceString)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString with: replaceString when: aBlock 
	self addArgumentRule: (RBStringReplaceRule 
				searchFor: searchString
				replaceWith: replaceString
				when: aBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString withValueFrom: replaceBlock 
	self addArgumentRule: (RBBlockReplaceRule searchFor: searchString
				replaceWith: replaceBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceArgument: searchString withValueFrom: replaceBlock when: conditionBlock 
	self addArgumentRule: (RBBlockReplaceRule 
				searchFor: searchString
				replaceWith: replaceBlock
				when: conditionBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString with: replaceString 
	self addRule: (RBStringReplaceRule searchForMethod: searchString
				replaceWith: replaceString)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString with: replaceString when: aBlock 
	self addRule: (RBStringReplaceRule 
				searchForMethod: searchString
				replaceWith: replaceString
				when: aBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString withValueFrom: replaceBlock 
	self addRule: (RBBlockReplaceRule searchForMethod: searchString
				replaceWith: replaceBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceMethod: searchString withValueFrom: replaceBlock when: conditionBlock 
	self addRule: (RBBlockReplaceRule 
				searchForMethod: searchString
				replaceWith: replaceBlock
				when: conditionBlock)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceTree: searchTree withTree: replaceTree 
	self addRule: (RBStringReplaceRule searchForTree: searchTree
				replaceWith: replaceTree)
%

category: 'replacing'
method: RBParseTreeRewriter
replaceTree: searchTree withTree: replaceTree when: aBlock 
	self addRule: (RBStringReplaceRule 
				searchForTree: searchTree
				replaceWith: replaceTree
				when: aBlock)
%

category: 'accessing'
method: RBParseTreeRewriter
tree
	^tree
%

category: 'visiting'
method: RBParseTreeRewriter
visitArguments: aNodeCollection 
	^aNodeCollection collect: [:each | self visitArgument: each]
%

! Class implementation for 'RBReadBeforeWrittenTester'

!		Class methods for 'RBReadBeforeWrittenTester'

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
isVariable: aString readBeforeWrittenIn: aBRProgramNode 
	^(self isVariable: aString writtenBeforeReadIn: aBRProgramNode) not
%

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
isVariable: aString writtenBeforeReadIn: aBRProgramNode 
	^(self readBeforeWritten: (Array with: aString) in: aBRProgramNode) 
		isEmpty
%

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
readBeforeWritten: varNames in: aParseTree 
	^(self new)
		checkNewTemps: false;
		initializeVars: varNames;
		executeTree: aParseTree;
		read
%

category: 'accessing'
classmethod: RBReadBeforeWrittenTester
variablesReadBeforeWrittenIn: aParseTree 
	^(self new)
		executeTree: aParseTree;
		read
%

!		Instance methods for 'RBReadBeforeWrittenTester'

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptAssignmentNode: anAssignmentNode 
	self visitNode: anAssignmentNode value.
	self variableWritten: anAssignmentNode
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptBlockNode: aBlockNode 
	self processBlock: aBlockNode
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptMessageNode: aMessageNode 
	((#(#whileTrue: #whileFalse: #whileTrue #whileFalse) 
		includes: aMessageNode selector) and: [aMessageNode receiver isBlock]) 
		ifTrue: [self executeTree: aMessageNode receiver body]
		ifFalse: 
			[(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 
				ifTrue: [self visitNode: aMessageNode receiver]].
	((#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aMessageNode selector) 
		and: [aMessageNode arguments allSatisfy: [:each | each isBlock]]) 
			ifTrue: [^self processIfTrueIfFalse: aMessageNode].
	aMessageNode arguments do: [:each | self visitNode: each]
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptSequenceNode: aSequenceNode 
	self processStatementNode: aSequenceNode
%

category: 'visitor-double dispatching'
method: RBReadBeforeWrittenTester
acceptVariableNode: aVariableNode 
	self variableRead: aVariableNode
%

category: 'initialize-release'
method: RBReadBeforeWrittenTester
checkNewTemps: aBoolean 
	checkNewTemps := aBoolean
%

category: 'private'
method: RBReadBeforeWrittenTester
copyDictionary: aDictionary 
	"We could send aDictionary the copy message, but that doesn't copy the associations."

	| newDictionary |
	newDictionary := Dictionary new: aDictionary size.
	aDictionary keysAndValuesDo: [ :key :value | newDictionary at: key put: value ].
	^ newDictionary
%

category: 'private'
method: RBReadBeforeWrittenTester
createScope
	scopeStack add: (self copyDictionary: scopeStack last)
%

category: 'private'
method: RBReadBeforeWrittenTester
currentScope
	^scopeStack last
%

category: 'accessing'
method: RBReadBeforeWrittenTester
executeTree: aParseTree 
	^self visitNode: aParseTree
%

category: 'initialize-release'
method: RBReadBeforeWrittenTester
initialize
	super initialize.
	scopeStack := OrderedCollection with: Dictionary new.
	read := Set new.
	checkNewTemps := true
%

category: 'initialize-release'
method: RBReadBeforeWrittenTester
initializeVars: varNames 
	varNames do: [:each | self currentScope at: each put: nil]
%

category: 'private'
method: RBReadBeforeWrittenTester
processBlock: aNode 
	| newScope |
	self createScope.
	self executeTree: aNode body.
	newScope := self removeScope.
	newScope keysAndValuesDo: 
			[:key :value | 
			(value == true and: [(self currentScope at: key) isNil]) 
				ifTrue: [self currentScope at: key put: value]]
%

category: 'private'
method: RBReadBeforeWrittenTester
processIfTrueIfFalse: aNode 
	| trueScope falseScope |
	self createScope.
	self executeTree: aNode arguments first body.
	trueScope := self removeScope.
	self createScope.
	self executeTree: aNode arguments last body.
	falseScope := self removeScope.
	self currentScope keysAndValuesDo: 
			[:key :value | 
			value isNil 
				ifTrue: 
					[(trueScope at: key) == (falseScope at: key) 
						ifTrue: [self currentScope at: key put: (trueScope at: key)]
						ifFalse: 
							[((trueScope at: key) == true or: [(falseScope at: key) == true]) 
								ifTrue: [self currentScope at: key put: true]]]]
%

category: 'private'
method: RBReadBeforeWrittenTester
processStatementNode: aNode 
	| temps |
	(checkNewTemps not or: [aNode temporaries isEmpty]) 
		ifTrue: 
			[aNode statements do: [:each | self executeTree: each].
			^self].
	self createScope.
	temps := aNode temporaries collect: [:each | each name].
	self initializeVars: temps.
	aNode statements do: [:each | self executeTree: each].
	self removeScope keysAndValuesDo: 
			[:key :value | 
			(temps includes: key) 
				ifTrue: [value == true ifTrue: [read add: key]]
				ifFalse: 
					[(self currentScope at: key) isNil 
						ifTrue: [self currentScope at: key put: value]]]
%

category: 'accessing'
method: RBReadBeforeWrittenTester
read
	self currentScope
		keysAndValuesDo: [:key :value | value == true ifTrue: [read add: key]].
	^read
%

category: 'private'
method: RBReadBeforeWrittenTester
removeScope
	^scopeStack removeLast
%

category: 'private'
method: RBReadBeforeWrittenTester
variableRead: aNode 
	(self currentScope includesKey: aNode name) 
		ifTrue: 
			[(self currentScope at: aNode name) isNil 
				ifTrue: [self currentScope at: aNode name put: true]]
%

category: 'private'
method: RBReadBeforeWrittenTester
variableWritten: aNode 
	(self currentScope includesKey: aNode variable name) 
		ifTrue: 
			[(self currentScope at: aNode variable name) isNil 
				ifTrue: [self currentScope at: aNode variable name put: false]]
%

! Class implementation for 'RBScanner'

!		Class methods for 'RBScanner'

category: 'accessing'
classmethod: RBScanner
classificationTable
	classificationTable isNil 
		ifTrue: [ self initializeClassificationTable ].
	^ classificationTable
%

category: 'class initialization'
classmethod: RBScanner
initialize
	self initializeClassificationTable
%

category: 'class initialization'
classmethod: RBScanner
initializeChars: characters to: aSymbol 
	characters do: [:c | classificationTable at: c asInteger put: aSymbol]
%

category: 'class initialization'
classmethod: RBScanner
initializeClassificationTable
  PatternVariableCharacter := $`.
  classificationTable := Array new: 255.
  self
    initializeChars: (((0 to: 255) collect: [ :v | Character codePoint: v ]) select: [ :each | each isLetter ])
    to: #'alphabetic'.
  self initializeUnderscore.
  self initializeChars: '01234567890' to: #'digit'.
  self initializeChars: '!%&*+,-/<=>?@\~|' to: #'binary'.
  classificationTable at: 177 put: #'binary'.	"plus-or-minus"
  classificationTable at: 183 put: #'binary'.	"centered dot"
  classificationTable at: 215 put: #'binary'.	"times"
  classificationTable at: 247 put: #'binary'.	"divide"
  self initializeChars: '().:;[]{}^' to: #'special'.
  self
    initializeChars:
      (((1 to: 255) collect: [ :v | Character codePoint: v ]) select: [ :each | each isSeparator ])
    to: #'separator'
%

category: 'class initialization'
classmethod: RBScanner
initializeUnderscore
  self classificationTable
    at: $_ asInteger
    put: #'alphabetic' 
"
      ((Scanner isLiteralSymbol: '_')
        ifTrue: [ #'alphabetic' ]
        ifFalse: [ #'special' ])
"
%

category: 'testing'
classmethod: RBScanner
isSelector: aSymbol 
	| scanner token |
	scanner := self basicNew.
	scanner on: aSymbol asString readStreamPortable.
	scanner step.
	token := scanner scanAnySymbol.
	token isLiteralToken ifFalse: [^false].
	token value isEmpty ifTrue: [^false].
	^scanner atEnd
%

category: 'testing'
classmethod: RBScanner
isVariable: aString 
	| scanner token |
	scanner := self on: aString readStreamPortable errorBlock: [:s :p | ^false].
	token := scanner next.
	token isIdentifier ifFalse: [^false].
	(token start = 1 and: [token stop = aString size]) ifFalse: [^false].
	^(aString includes: $.) not
%

category: 'instance creation'
classmethod: RBScanner
new
  ^ super new
%

category: 'instance creation'
classmethod: RBScanner
on: aStream 
	| str |
	str := self new on: aStream.
	str
		step;
		stripSeparators.
	^str
%

category: 'instance creation'
classmethod: RBScanner
on: aStream errorBlock: aBlock 
	| str |
	str := self new on: aStream.
	str
		errorBlock: aBlock;
		step;
		stripSeparators.
	^str
%

category: 'accessing'
classmethod: RBScanner
patternVariableCharacter
	^ PatternVariableCharacter
%

!		Instance methods for 'RBScanner'

category: 'testing'
method: RBScanner
atEnd
	^characterType = #eof
%

category: 'private'
method: RBScanner
classify: aCharacter 
	| index |
	aCharacter isNil ifTrue: [^nil].
	index := aCharacter asInteger.
	index == 0 ifTrue: [^#separator].
	index > 255 
		ifTrue: 
			[^aCharacter isLetter 
				ifTrue: [#alphabetic]
				ifFalse: [aCharacter isSqueakSeparator ifTrue: [#separator] ifFalse: [nil]]].
	^classificationTable at: index
%

category: 'accessing'
method: RBScanner
contents
	| contentsStream |
	contentsStream := WriteStreamPortable on: String new.
	[ self atEnd ]
		whileFalse: [ contentsStream nextPut: self next ].
	^ contentsStream contents
%

category: 'error handling'
method: RBScanner
errorBlock
	^errorBlock isNil ifTrue: [[:message :position | ]] ifFalse: [errorBlock]
%

category: 'accessing'
method: RBScanner
errorBlock: aBlock 
	errorBlock := aBlock
%

category: 'error handling'
method: RBScanner
errorPosition
	^stream position
%

category: 'accessing'
method: RBScanner
flush
%

category: 'accessing'
method: RBScanner
getComments
	| oldComments |
	comments isEmpty ifTrue: [^nil].
	oldComments := comments.
	comments := OrderedCollection new: 1.
	^oldComments
%

category: 'testing'
method: RBScanner
isReadable
	^true
%

category: 'testing'
method: RBScanner
isWritable
	^false
%

category: 'accessing'
method: RBScanner
next
	| token |
	buffer reset.
	tokenStart := stream position.
	token := characterType = #eof 
				ifTrue: 
					[RBToken start: tokenStart + 1	"The EOF token should occur after the end of input"]
				ifFalse: [self scanToken].
	self stripSeparators.
	token comments: self getComments.
	^token
%

category: 'accessing'
method: RBScanner
nextPut: anObject 
	"Provide an error notification that the receiver does not
	implement this message."

	self shouldNotImplement
%

category: 'initialize-release'
method: RBScanner
on: aStream 
	buffer := WriteStreamPortable on: String new.
	stream := aStream.
	classificationTable := self class classificationTable.
	comments := OrderedCollection new
%

category: 'private'
method: RBScanner
previousStepPosition
	^characterType = #eof 
		ifTrue: [stream position]
		ifFalse: [stream position - 1]
%

category: 'private-scanning'
method: RBScanner
scanAnySymbol
	characterType = #alphabetic ifTrue: [^self scanSymbol].
	characterType = #binary ifTrue: [^self scanBinary: RBLiteralToken].
	^RBToken new
%

category: 'private-scanning'
method: RBScanner
scanBinary: aClass 
	| val |
	buffer nextPut: currentCharacter.
	self step.
	[ characterType = #binary ] whileTrue: 
		[ buffer nextPut: currentCharacter.
		self step ].
	val := buffer contents.
	val := val asSymbol.
	^aClass value: val start: tokenStart
%

category: 'private-scanning'
method: RBScanner
scanIdentifierOrKeyword
  | name |
  self scanName.
  [ 
  currentCharacter = $.
    and: [ 'abcdefghijklmnopqrstuvwxyz*|#' includes: stream peek ] ]
    whileTrue: [ 
      buffer nextPut: currentCharacter.
      self step.
      self scanPathName.
      name := buffer contents.
      ^ RBPathToken value: name start: tokenStart ].
  (currentCharacter = $: and: [ stream peek ~= $= ])
    ifTrue: [ ^ self scanKeyword ].
  name := buffer contents.
  name = '_'
    ifTrue: [ ^ RBShortAssignmentToken start: tokenStart ].
  name = 'true'
    ifTrue: [ ^ RBLiteralToken value: true start: tokenStart stop: self previousStepPosition ].
  name = 'false'
    ifTrue: [ ^ RBLiteralToken value: false start: tokenStart stop: self previousStepPosition ].
  name = 'nil'
    ifTrue: [ ^ RBLiteralToken value: nil start: tokenStart stop: self previousStepPosition ].
  ^ RBIdentifierToken value: name start: tokenStart
%

category: 'private-scanning'
method: RBScanner
scanKeyword
	| outputPosition inputPosition name |
	[currentCharacter = $:] whileTrue: 
			[buffer nextPut: currentCharacter.
			outputPosition := buffer position.
			inputPosition := stream position.
			self step.	":"
			[characterType = #alphabetic] whileTrue: [self scanName]].
	buffer position: outputPosition.
	stream position: inputPosition.
	self step.
	name := buffer contents.
	^(name occurrencesOf: $:) == 1 
		ifTrue: [RBKeywordToken value: name start: tokenStart]
		ifFalse: 
			[RBMultiKeywordLiteralToken 
				value: name asSymbol
				start: tokenStart
				stop: tokenStart + name size - 1]
%

category: 'private-scanning'
method: RBScanner
scanLiteral
	self step.
	self stripSeparators.
	characterType = #alphabetic 
		ifTrue: [ ^ self scanSymbol ].
	characterType = #binary 
		ifTrue: [ ^ (self scanBinary: RBLiteralToken) stop: self previousStepPosition ].
	currentCharacter = $' 
		ifTrue: [ ^ self scanStringSymbol ].
	(currentCharacter = $( or: [ currentCharacter = $[ ]) 
		ifTrue: [ ^ self scanLiteralArrayToken].
	"Accept some strange literals like '#1', '# species' and '##species:'"
	characterType = #digit
		ifTrue: [ ^ self scanNumber ].
	currentCharacter = $#
		ifTrue: [ ^ self scanLiteral ].
	self scannerError: 'Expecting a literal type'
%

category: 'private-scanning'
method: RBScanner
scanLiteralArrayToken
	| token |
	token := RBLiteralArrayToken 
				value: (String with: $# with: currentCharacter)
				start: tokenStart.
	self step.
	^token
%

category: 'private-scanning'
method: RBScanner
scanLiteralCharacter
	| token |
	self step.	"$"
	token := RBLiteralToken 
				value: currentCharacter
				start: tokenStart
				stop: stream position.
	self step.	"char"
	^token
%

category: 'private-scanning'
method: RBScanner
scanLiteralString
	self step.
	
	[currentCharacter isNil 
		ifTrue: [self scannerError: 'Unmatched '' in string literal.'].
	currentCharacter = $' and: [self step ~= $']] 
			whileFalse: 
				[buffer nextPut: currentCharacter.
				self step].
	^RBLiteralToken 
		value: buffer contents
		start: tokenStart
		stop: self previousStepPosition
%

category: 'private-scanning'
method: RBScanner
scanName
	[characterType = #alphabetic or: [characterType = #digit]] whileTrue: 
			[buffer nextPut: currentCharacter.
			self step]
%

category: 'error handling'
method: RBScanner
scannerError: aString 
	"Evaluate the block. If it returns raise an error"

	self errorBlock value: aString value: self errorPosition.
	self error: aString
%

category: 'private-scanning'
method: RBScanner
scanNumber
	| start number stop string |
	start := stream position.
	stream position: start - 1.
	number := Number rwFromStream: stream.
	stop := stream position.
	stream position: start - 1.
	string := stream next: stop - start + 1.
	stream position: stop.
	self step.
	^RBNumberLiteralToken 
		value: number
		start: start
		stop: stop
		source: string
%

category: 'private-scanning'
method: RBScanner
scanPathName
  [ 
  (characterType = #'alphabetic' or: [ characterType = #'digit' ])
    or: [ 
      ((currentCharacter = $. or: [ currentCharacter = $| ])
        and: [ 'abcdefghijklmnopqrstuvwxyz' includes: stream peek ])
        or: [ 
          (currentCharacter = $. and: [ stream peek = $* ])
            or: [ currentCharacter = $* and: [ stream peek = $. ] ] ] ] ]
    whileTrue: [ 
      buffer nextPut: currentCharacter.
      self step ]
%

category: 'private-scanning'
method: RBScanner
scanPatternVariable
	buffer nextPut: currentCharacter.
	self step.
	currentCharacter = ${ 
		ifTrue: 
			[self step.
			^RBPatternBlockToken value: '`{' start: tokenStart].
	[characterType = #alphabetic] whileFalse: 
			[characterType = #eof 
				ifTrue: [self scannerError: 'Meta variable expected'].
			buffer nextPut: currentCharacter.
			self step].
	^self scanIdentifierOrKeyword
%

category: 'private-scanning'
method: RBScanner
scanSpecialCharacter
	| character |
	currentCharacter = $: 
		ifTrue: 
			[self step.
			^currentCharacter = $= 
				ifTrue: 
					[self step.
					RBAssignmentToken start: tokenStart]
				ifFalse: [RBSpecialCharacterToken value: $: start: tokenStart]].
	currentCharacter = $_ ifTrue:
		[ self step.  ^RBShortAssignmentToken start: tokenStart ].
	character := currentCharacter.
	self step.
	^RBSpecialCharacterToken value: character start: tokenStart
%

category: 'private-scanning'
method: RBScanner
scanStringSymbol
	| literalToken |
	literalToken := self scanLiteralString.
	literalToken value: literalToken value asSymbol.
	^literalToken
%

category: 'private-scanning'
method: RBScanner
scanSymbol
	[ characterType = #alphabetic or: [ currentCharacter = $: ] ] whileTrue: [
		self scanName.
		currentCharacter = $: ifTrue: [
			buffer nextPut: $:.
			self step ] ].
	^ RBLiteralToken 
		value: buffer contents asSymbol
		start: tokenStart
		stop: self previousStepPosition
%

category: 'accessing'
method: RBScanner
scanToken
	"fast-n-ugly. Don't write stuff like this. Has been found to cause cancer in laboratory rats. Basically a 
	case statement. Didn't use Dictionary because lookup is pretty slow."

	characterType = #alphabetic ifTrue: [^self scanIdentifierOrKeyword].
	(characterType = #digit 
		or: [currentCharacter = $- and: [(self classify: stream peek) = #digit]]) 
			ifTrue: [^self scanNumber].
	characterType = #binary ifTrue: [^self scanBinary: RBBinarySelectorToken].
	characterType = #special ifTrue: [^self scanSpecialCharacter].
	currentCharacter = $' ifTrue: [^self scanLiteralString].
	currentCharacter = $# ifTrue: [^self scanLiteral].
	currentCharacter = $$ ifTrue: [^self scanLiteralCharacter].
	^self scannerError: 'Unknown character'
%

category: 'private'
method: RBScanner
step
	stream atEnd 
		ifTrue: 
			[characterType := #eof.
			^currentCharacter := nil].
	currentCharacter := stream next.
	characterType := self classify: currentCharacter.
	^currentCharacter
%

category: 'private-scanning'
method: RBScanner
stripComment
	| start stop |
	start := stream position.
	[self step = $"] whileFalse: 
			[characterType = #eof
				ifTrue: [self scannerError: 'Unmatched " in comment.']].
	stop := stream position.
	self step.
	comments add: (start to: stop)
%

category: 'private-scanning'
method: RBScanner
stripSeparators
	
	[[characterType = #separator] whileTrue: [self step].
	currentCharacter = $"] 
			whileTrue: [self stripComment]
%

! Class implementation for 'RBPatternScanner'

!		Class methods for 'RBPatternScanner'

category: 'class initialization'
classmethod: RBPatternScanner
initialize
  "force initialization on load"

  "self initialize"

  super initialize
%

!		Instance methods for 'RBPatternScanner'

category: 'accessing'
method: RBPatternScanner
scanToken
	currentCharacter = PatternVariableCharacter 
		ifTrue: [^self scanPatternVariable].
	currentCharacter = $} ifTrue: [^self scanSpecialCharacter].
	^super scanToken
%

! Class implementation for 'RBSmallDictionary'

!		Class methods for 'RBSmallDictionary'

category: 'instance creation'
classmethod: RBSmallDictionary
new
	^ self new: 2
%

category: 'instance creation'
classmethod: RBSmallDictionary
new: anInteger 
	^ self basicNew initialize: anInteger
%

!		Instance methods for 'RBSmallDictionary'

category: 'accessing'
method: RBSmallDictionary
at: aKey
	"Answer the value associated with aKey. Raise an exception, if no such key is defined."

	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]
%

category: 'accessing'
method: RBSmallDictionary
at: aKey ifAbsent: aBlock
	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index ]
		ifTrue: [ aBlock value ]
%

category: 'accessing'
method: RBSmallDictionary
at: aKey ifAbsentPut: aBlock
	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index ]
		ifTrue: [ self privateAt: aKey put: aBlock value ]
%

category: 'accessing'
method: RBSmallDictionary
at: aKey put: aValue
	"Set the value of aKey to be aValue."

	| index |
	index := self findIndexFor: aKey.
	^ index = 0
		ifFalse: [ values at: index put: aValue ]
		ifTrue: [ self privateAt: aKey put: aValue ]
%

category: 'accessing'
method: RBSmallDictionary
empty
	tally := 0
%

category: 'private'
method: RBSmallDictionary
errorKeyNotFound
	self error: 'Key not found'
%

category: 'private'
method: RBSmallDictionary
findIndexFor: aKey
	1 to: tally do: [ :index |
		(keys at: index) = aKey
			ifTrue: [ ^ index ] ].
	^ 0
%

category: 'private'
method: RBSmallDictionary
grow
	| newKeys newValues |
	newKeys := Array new: 2 * tally.
	newValues := Array new: 2 * tally.
	1 to: tally do: [ :index |
		newKeys at: index put: (keys at: index).
		newValues at: index put: (values at: index) ].
	keys := newKeys.
	values := newValues
%

category: 'testing'
method: RBSmallDictionary
includesKey: aKey
	"Answer whether the receiver has a key equal to aKey."

	^ (self findIndexFor: aKey) ~= 0
%

category: 'initialization'
method: RBSmallDictionary
initialize: anInteger
	tally := 0.
	keys := Array new: anInteger.
	values := Array new: anInteger
%

category: 'testing'
method: RBSmallDictionary
isEmpty
	^ tally = 0
%

category: 'accessing'
method: RBSmallDictionary
keys
	^ keys copyFrom: 1 to: tally
%

category: 'enumerating'
method: RBSmallDictionary
keysAndValuesDo: aBlock
	1 to: tally do: [ :index | aBlock value: (keys at: index) value: (values at: index) ]
%

category: 'enumerating'
method: RBSmallDictionary
keysDo: aBlock
	1 to: tally do: [ :each | aBlock value: (keys at: each) ]
%

category: 'copying'
method: RBSmallDictionary
postCopy
	super postCopy.
	keys := keys copy.
	values := values copy
%

category: 'private'
method: RBSmallDictionary
privateAt: aKey put: aValue
	tally = keys size ifTrue: [ self grow ].
	keys at: (tally := tally + 1) put: aKey.
	^ values at: tally put: aValue
%

category: 'removing'
method: RBSmallDictionary
removeKey: aKey
	"Remove aKey from the receiver, raise an exception if the element is missing."

	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]
%

category: 'removing'
method: RBSmallDictionary
removeKey: aKey ifAbsent: aBlock
	"Remove aKey from the receiver, evaluate aBlock if the element is missing."

	| index value |
	index := self findIndexFor: aKey.
	index = 0 ifTrue: [ ^ aBlock value ].
	value := values at: index.
	index to: tally - 1 do: [ :i |
		keys at: i put: (keys at: i + 1).
		values at: i put: (values at: i + 1) ].
	keys at: tally put: nil.
	values at: tally put: nil.
	tally := tally - 1.
	^ value
%

category: 'accessing'
method: RBSmallDictionary
size
	^ tally
%

category: 'accessing'
method: RBSmallDictionary
values
	^ values copyFrom: 1 to: tally
%

category: 'enumerating'
method: RBSmallDictionary
valuesDo: aBlock
	1 to: tally do: [ :index | aBlock value: (values at: index) ]
%

! Class implementation for 'RBStringReplacement'

!		Class methods for 'RBStringReplacement'

category: 'instance creation'
classmethod: RBStringReplacement
replaceFrom: startInteger to: stopInteger with: aString 
	^(self new)
		startPosition: startInteger;
		stopPosition: stopInteger;
		string: aString;
		yourself
%

!		Instance methods for 'RBStringReplacement'

category: 'accessing'
method: RBStringReplacement
startPosition
	^startPosition
%

category: 'initialize-release'
method: RBStringReplacement
startPosition: anInteger 
	startPosition := anInteger
%

category: 'accessing'
method: RBStringReplacement
stopPosition
	^stopPosition
%

category: 'initialize-release'
method: RBStringReplacement
stopPosition: anInteger 
	stopPosition := anInteger
%

category: 'accessing'
method: RBStringReplacement
string
	^string
%

category: 'initialize-release'
method: RBStringReplacement
string: aString 
	string := aString
%

! Class implementation for 'RBToken'

!		Class methods for 'RBToken'

category: 'instance creation'
classmethod: RBToken
start: anInterval 
	^self new start: anInterval
%

!		Instance methods for 'RBToken'

category: 'accessing'
method: RBToken
comments
	^comments
%

category: 'accessing'
method: RBToken
comments: anObject
	comments := anObject
%

category: 'testing'
method: RBToken
isAssignment
	^false
%

category: 'testing'
method: RBToken
isBinary
	^false
%

category: 'testing'
method: RBToken
isIdentifier
	^false
%

category: 'testing'
method: RBToken
isKeyword
	^false
%

category: 'testing'
method: RBToken
isLiteral
	^self isLiteralToken
%

category: 'testing'
method: RBToken
isLiteralArrayToken
	^false
%

category: 'testing'
method: RBToken
isLiteralToken
	^false
%

category: 'testing'
method: RBToken
isPath
  ^ false
%

category: 'testing'
method: RBToken
isPatternBlock
	^false
%

category: 'testing'
method: RBToken
isPatternVariable
	^false
%

category: 'testing'
method: RBToken
isSpecial
	^false
%

category: 'accessing'
method: RBToken
length
	^self subclassResponsibility
%

category: 'printing'
method: RBToken
printOn: aStream 
	aStream
		nextPut: $ ;
		nextPutAll: self class name
%

category: 'printing'
method: RBToken
rbStoreString

"Returns a string that, when evaluated, will recreate a copy of the
 receiver.  The default is to use storeOn: to create the description."

| stream str |
str := String new.
stream := WriteStreamPortable on: str.
self rbStoreOn: stream.
^str
%

category: 'accessing'
method: RBToken
removePositions
	sourcePointer := nil
%

category: 'accessing'
method: RBToken
start
	^ sourcePointer ifNil: [ 0 ]
%

category: 'initialize-release'
method: RBToken
start: anInteger 
	sourcePointer := anInteger
%

category: 'accessing'
method: RBToken
stop
	^ sourcePointer isNil 
		ifTrue: [ -1 ]
		ifFalse: [ self start + self length - 1 ]
%

! Class implementation for 'RBAssignmentToken'

!		Instance methods for 'RBAssignmentToken'

category: 'testing'
method: RBAssignmentToken
isAssignment
	^true
%

category: 'private'
method: RBAssignmentToken
length
	^2
%

! Class implementation for 'RBShortAssignmentToken'

!		Instance methods for 'RBShortAssignmentToken'

category: 'private'
method: RBShortAssignmentToken
length
	^ 1
%

! Class implementation for 'RBValueToken'

!		Class methods for 'RBValueToken'

category: 'instance creation'
classmethod: RBValueToken
value: aString start: anInteger 
	^self new value: aString start: anInteger
%

!		Instance methods for 'RBValueToken'

category: 'private'
method: RBValueToken
length
	^value size
%

category: 'printing'
method: RBValueToken
printOn: aStream
	super printOn: aStream.
	aStream nextPut: $(.
	value printOn: aStream.
	aStream nextPutAll: ')'
%

category: 'accessing'
method: RBValueToken
value
	^value
%

category: 'accessing'
method: RBValueToken
value: anObject
	value := anObject
%

category: 'initialize-release'
method: RBValueToken
value: aString start: anInteger 
	value := aString.
	sourcePointer := anInteger
%

! Class implementation for 'RBBinarySelectorToken'

!		Instance methods for 'RBBinarySelectorToken'

category: 'testing'
method: RBBinarySelectorToken
isBinary
	^true
%

! Class implementation for 'RBIdentifierToken'

!		Instance methods for 'RBIdentifierToken'

category: 'testing'
method: RBIdentifierToken
isIdentifier
	^true
%

category: 'testing'
method: RBIdentifierToken
isPatternVariable
	^value first = RBScanner patternVariableCharacter
%

! Class implementation for 'RBPathToken'

!		Instance methods for 'RBPathToken'

category: 'testing'
method: RBPathToken
isPath
  ^ true
%

! Class implementation for 'RBKeywordToken'

!		Instance methods for 'RBKeywordToken'

category: 'testing'
method: RBKeywordToken
isKeyword
	^true
%

category: 'testing'
method: RBKeywordToken
isPatternVariable
	^value first = RBScanner patternVariableCharacter
%

! Class implementation for 'RBLiteralArrayToken'

!		Instance methods for 'RBLiteralArrayToken'

category: 'testing'
method: RBLiteralArrayToken
isForByteArray
	^value last = $[
%

category: 'testing'
method: RBLiteralArrayToken
isLiteralArrayToken
	^true
%

! Class implementation for 'RBLiteralToken'

!		Class methods for 'RBLiteralToken'

category: 'instance creation'
classmethod: RBLiteralToken
value: anObject 
	| literal |
	literal := anObject class == Array 
				ifTrue: [anObject collect: [:each | self value: each]]
				ifFalse: [anObject].
	^self 
		value: literal
		start: nil
		stop: nil
%

category: 'instance creation'
classmethod: RBLiteralToken
value: aString start: anInteger stop: stopInteger 
	^(self new)
		value: aString
			start: anInteger
			stop: stopInteger;
		yourself
%

!		Instance methods for 'RBLiteralToken'

category: 'testing'
method: RBLiteralToken
isLiteralToken
	^true
%

category: 'testing'
method: RBLiteralToken
isMultiKeyword
	^false
%

category: 'private'
method: RBLiteralToken
length
	^stopPosition - self start + 1
%

category: 'printing'
method: RBLiteralToken
rbStoreOn: aStream
    value isSymbol
        ifTrue: [ 
            aStream nextPut: $#.
            value asString printOn: aStream.
            ^ self ].
    value class == Character
        ifTrue: [ 
            aStream
                nextPut: $$;
                nextPut: value.
            ^ self ].
    value rbStoreOn: aStream
%

category: 'accessing'
method: RBLiteralToken
realValue
	^value
%

category: 'accessing'
method: RBLiteralToken
stop: anObject 
	stopPosition := anObject
%

category: 'initialize-release'
method: RBLiteralToken
value: aString start: anInteger stop: stopInteger 
	value := aString.
	sourcePointer := anInteger.
	stopPosition := stopInteger
%

! Class implementation for 'RBMultiKeywordLiteralToken'

!		Instance methods for 'RBMultiKeywordLiteralToken'

category: 'testing'
method: RBMultiKeywordLiteralToken
isMultiKeyword
	^true
%

! Class implementation for 'RBNumberLiteralToken'

!		Class methods for 'RBNumberLiteralToken'

category: 'instance creation'
classmethod: RBNumberLiteralToken
value: aNumber start: anInteger stop: stopInteger source: sourceString 
	^(self 
		value: aNumber
		start: anInteger
		stop: stopInteger)
		source: sourceString;
		yourself
%

!		Instance methods for 'RBNumberLiteralToken'

category: 'printing'
method: RBNumberLiteralToken
rbStoreOn: aStream 
	aStream nextPutAll: source
%

category: 'accessing'
method: RBNumberLiteralToken
source
	^source
%

category: 'initialize-release'
method: RBNumberLiteralToken
source: aString 
	source := aString
%

! Class implementation for 'RBPatternBlockToken'

!		Instance methods for 'RBPatternBlockToken'

category: 'testing'
method: RBPatternBlockToken
isPatternBlock
	^true
%

! Class implementation for 'RBSpecialCharacterToken'

!		Instance methods for 'RBSpecialCharacterToken'

category: 'testing'
method: RBSpecialCharacterToken
isSpecial
	^true
%

category: 'private'
method: RBSpecialCharacterToken
length
	^1
%

! Class implementation for 'Rowan'

!		Class methods for 'Rowan'

category: 'public client services'
classmethod: Rowan
answeringServiceClass

	^ self platform answeringServiceClass
%

category: 'public'
classmethod: Rowan
automaticClassInitializationBlackList

	"Answer list of project names for which automatic class initialiation should be disabled."

	^ self platform automaticClassInitializationBlackList
%

category: 'public client services'
classmethod: Rowan
browserServiceClass

	^ self platform browserServiceClass
%

category: 'public client services'
classmethod: Rowan
classServiceClass

	^ self platform classServiceClass
%

category: 'public'
classmethod: Rowan
clearAutomaticClassInitializationBlackList

	"Clear list of project names for which automatic class initialiation should be disabled."

	^ self platform clearAutomaticClassInitializationBlackList
%

category: 'public'
classmethod: Rowan
clearDefaultAutomaticClassInitializationBlackList

	"Clear default list of project names for which automatic class initialiation should be disabled.
		Individual users may override the black list."

	^ self platform clearAutomaticClassInitializationBlackList_default
%

category: 'public client services'
classmethod: Rowan
commandResultClass

	^ self platform commandResultClass
%

category: 'public'
classmethod: Rowan
configuration

	^configuration
%

category: 'public'
classmethod: Rowan
defaultAutomaticClassInitializationBlackList

	"Answer default list of project names for which automatic class initialiation should be disabled.
		Individual users may override the black list."

	^ self platform automaticClassInitializationBlackList_default
%

category: 'private'
classmethod: Rowan
fileUtilities
	"Private to the Cypress system."

	^self platform fileUtilities
%

category: 'public tools'
classmethod: Rowan
gitTools

	^ self platform gitTools
%

category: 'public'
classmethod: Rowan
globalNamed: aName

	"Answer a global object with the given name.  If no object with the given name is found, returns nil."

	^ self platform globalNamed: aName
%

category: 'private'
classmethod: Rowan
image
	"Private to the Cypress system."

	^self platform image
%

category: 'public client services'
classmethod: Rowan
jadeServerClassNamed: className

	^ self platform jadeServerClassNamed: className
%

category: 'public client services'
classmethod: Rowan
loggingServiceClass

	^ self platform loggingServiceClass
%

category: 'public client services'
classmethod: Rowan
methodServiceClass

	^ self platform methodServiceClass
%

category: 'public'
classmethod: Rowan
packageNames

	"Return list of package names"

	^ self image packageNames
%

category: 'public client services'
classmethod: Rowan
packageServiceClass

	^ self platform packageServiceClass
%

category: 'public tools'
classmethod: Rowan
packageTools

	^self platform packageTools
%

category: 'private'
classmethod: Rowan
platform

	^ RwPlatform current
%

category: 'public'
classmethod: Rowan
platformConfigurationAttributes

	"Return list of platform-specific configuration attributes"

	^ self platform platformConfigurationAttributes
%

category: 'public'
classmethod: Rowan
projectNames

	"Return list of project names"

	^ self image projectNames
%

category: 'public client services'
classmethod: Rowan
projectServiceClass

	^ self platform projectServiceClass
%

category: 'public tools'
classmethod: Rowan
projectTools

	^self platform projectTools
%

category: 'public client services'
classmethod: Rowan
serviceClass

	^ self platform serviceClass
%

category: 'public'
classmethod: Rowan
unpackagedName

	"Answer the name used for unpackaged projects and packages"

	^ '(NONE)'
%

category: 'public'
classmethod: Rowan
version
	^ '1.2.13' asRwSemanticVersionNumber
%

! Class implementation for 'RowanCommandResult'

!		Class methods for 'RowanCommandResult'

category: 'accessing'
classmethod: RowanCommandResult
addResult: service
	service command: nil;
			commandArgs: nil. 
	self updateClientBoundServices: service.
	^service
%

category: 'accessing'
classmethod: RowanCommandResult
basicAddResult: service
	self results add: service
%

category: 'initailize'
classmethod: RowanCommandResult
initializeResults

	SessionTemps current at: #rowanCommandResults put: Array new.
%

category: 'instance creation'
classmethod: RowanCommandResult
new

	| inst |
	inst := super new initialize.
	self addResult: inst.
	^inst
%

category: 'accessing'
classmethod: RowanCommandResult
removeResult: aResult

	self results remove: aResult
%

category: 'accessing'
classmethod: RowanCommandResult
results

	"lazy initialize for a topaz session test" 
	^SessionTemps current at: #rowanCommandResults ifAbsentPut: [Array new]
%

category: 'private'
classmethod: RowanCommandResult
updateClientBoundServices: clientBoundService
	"We're about to add a service to the results collection. 
	That service will be sent to the client. Since services
	are not canonical, we need to do some housekeeping
	to ensure that we don't already have this service 
	somewhere in other client-bound services"
	(self results includes: clientBoundService) ifTrue:[
		self removeResult: clientBoundService].
	self basicAddResult: clientBoundService. 
	self results do:[:service |
		service updateInternalService: clientBoundService.
		clientBoundService updateInternalService: service].
%

!		Instance methods for 'RowanCommandResult'

category: 'accessing'
method: RowanCommandResult
command: anObject

	"results don't have commands"
%

category: 'accessing'
method: RowanCommandResult
commandArgs: anObject

	"results don't have commandArgs"
%

category: 'initialization'
method: RowanCommandResult
initialize
%

category: 'testing'
method: RowanCommandResult
isMethodService

	^false
%

category: 'private'
method: RowanCommandResult
rowanFixMe
%

category: 'accessing'
method: RowanCommandResult
updateInternalService: service
%

! Class implementation for 'RowanClassCategoryUpdate'

!		Instance methods for 'RowanClassCategoryUpdate'

category: 'accessing'
method: RowanClassCategoryUpdate
categories

	^categories
%

category: 'initialization'
method: RowanClassCategoryUpdate
initialize

	categories := Array new.
%

category: 'accessing'
method: RowanClassCategoryUpdate
selection

	^selection
%

category: 'accessing'
method: RowanClassCategoryUpdate
selection: anObject

	selection := anObject
%

category: 'jade'
method: RowanClassCategoryUpdate
writeCategoriesTo: writeStream

	categories do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanClassCategoryUpdate
writeSelectionTo: writeStream

	writeStream nextPutAll: selection.
	writeStream lf.
%

! Class implementation for 'RowanClassesUpdate'

!		Instance methods for 'RowanClassesUpdate'

category: 'accessing'
method: RowanClassesUpdate
classesFromNames
	| result |
	result := classNames collect:[:name | 
		| cls |
		cls := self objectInBaseNamed: (name subStrings first).
		name subStrings size = 2 "meta" ifTrue:[cls := cls class.].
		cls].
	^result
%

category: 'accessing'
method: RowanClassesUpdate
classNames

	^classNames
%

category: 'accessing'
method: RowanClassesUpdate
classNamesFrom: theClasses
	"store the class name for transport to the client"
	classNames := theClasses collect:[:class | class name]
%

category: 'private'
method: RowanClassesUpdate
historyOf: aClass

	| history |
	(history := aClass classHistory) isNil ifTrue: [
		history := Array with: aClass.
	].
	^history
%

category: 'initialization'
method: RowanClassesUpdate
initialize

	classNames := Array new.
	selectionNames := Array new.
%

category: 'private'
method: RowanClassesUpdate
objectInBaseNamed: aString

	^Rowan image symbolList objectNamed: aString asSymbol
%

category: 'accessing'
method: RowanClassesUpdate
selectionNames

	^selectionNames
%

category: 'accessing'
method: RowanClassesUpdate
selectionNamesAsSymbols

	^self selectionNames collect:[:string | string asSymbol]
%

category: 'accessing'
method: RowanClassesUpdate
selections

	^selectionNames
%

category: 'accessing'
method: RowanClassesUpdate
selections: aCollection

	selectionNames := aCollection.
%

category: 'jade'
method: RowanClassesUpdate
writeClass: aClass to: writeStream

	writeStream nextPutAll: aClass name.
		1 < (self historyOf: aClass) size ifTrue: [
			writeStream nextPutAll: ' ('.
			((self historyOf: aClass) indexOf: aClass) printOn: writeStream.
			writeStream nextPut: $/.
			(self historyOf: aClass) size printOn: writeStream.
			writeStream nextPut: $)].
	writeStream tab.
%

category: 'jade'
method: RowanClassesUpdate
writeClassesTo: writeStream

	self classesFromNames do:[:aClass | 
		self writeClass: aClass to: writeStream
	].
	writeStream lf.
%

category: 'jade'
method: RowanClassesUpdate
writeSelectionsTo: writeStream

	self selectionNames do:[:name | 
		self writeClass: (self objectInBaseNamed: (name subStrings first)) to: writeStream].
	writeStream lf.
%

category: 'jade'
method: RowanClassesUpdate
writeTestCaseInfoTo: writeStream

	| testCaseClass | 
	testCaseClass:= self objectInBaseNamed: #'TestCase'.
	testCaseClass isNil ifTrue: [
		false printOn: writeStream.
	] ifFalse: [
		(self selectionNames allSatisfy: [:each | (self objectInBaseNamed: each)  inheritsFrom: testCaseClass]) printOn: writeStream.
	].
	writeStream lf.
%

! Class implementation for 'RowanClassHierarchyUpdate'

!		Instance methods for 'RowanClassHierarchyUpdate'

category: 'accessing'
method: RowanClassHierarchyUpdate
addHierarchyFor: aClass
	classNames add: ((self hierarchyFor: aClass) collect:[:class | class name]).
%

category: 'accessing'
method: RowanClassHierarchyUpdate
addSelectionHierarchyFor: aClass
	self selections addAll: ((self hierarchyFor: aClass) collect:[:class | class asString])
%

category: 'accessing'
method: RowanClassHierarchyUpdate
allClasses

	| allClasses |
 
	allClasses := Set new. 
	classNames do:[:hierarchy | 
		allClasses addAll: (hierarchy collect: [:name | self objectInBaseNamed: name])]. 
	^allClasses asArray
%

category: 'accessing'
method: RowanClassHierarchyUpdate
hierarchyFor: aClass
	| currentClass hierarchy |
	currentClass := aClass.
	hierarchy := Array new. 
	[currentClass notNil] whileTrue: 
			[hierarchy add: currentClass.
			currentClass := currentClass superclass].
	^hierarchy
%

category: 'jade'
method: RowanClassHierarchyUpdate
writeHierarchyTo: writeStream
	
	classNames do:[:hierarchy |
		hierarchy do:[:name | 
			self writeClass: (self objectInBaseNamed: name) to: writeStream].
		writeStream lf].
	writeStream nextPut: $%; lf.
%

category: 'jade'
method: RowanClassHierarchyUpdate
writeSelectionHierarchyTo: writeStream
	
	super writeSelectionsTo: writeStream
%

category: 'jade'
method: RowanClassHierarchyUpdate
writeTestCaseInfoTo: writeStream
	"ignore test case info - method going away"
	writeStream nextPutAll: 'false';
		tab;
		lf
%

! Class implementation for 'RowanMethodsUpdate'

!		Instance methods for 'RowanMethodsUpdate'

category: 'testing'
method: RowanMethodsUpdate
filterSelections

	"intention revealing"

	^selectionNames
%

category: 'testing'
method: RowanMethodsUpdate
filterSelections: aCollection

	"intention revealing"

	selectionNames := aCollection
%

category: 'accessing'
method: RowanMethodsUpdate
inheritedClass: aString

	inheritedClass := aString
%

category: 'accessing'
method: RowanMethodsUpdate
inheritedClasses: aCollection

	inheritedClasses := aCollection
%

category: 'initialization'
method: RowanMethodsUpdate
initialize
	super initialize.
	methodFilters := IdentitySet new.
	methods := Array new.
%

category: 'accessing'
method: RowanMethodsUpdate
methodFilters

	^methodFilters
%

category: 'accessing'
method: RowanMethodsUpdate
methods

	^methods
%

category: 'accessing'
method: RowanMethodsUpdate
selectedClass

	^self objectInBaseNamed: (selectedClass subStrings first)
%

category: 'accessing'
method: RowanMethodsUpdate
selectedClass:  aString

	selectedClass := aString
%

category: 'testing'
method: RowanMethodsUpdate
selectedClassOverridesSelector: aSymbol

	^self selectedClass superclass notNil and: [self selectedClass superclass canUnderstand: aSymbol].
%

category: 'accessing'
method: RowanMethodsUpdate
selectedSelectors

	^selectedSelectors
%

category: 'accessing'
method: RowanMethodsUpdate
selectedSelectors: aCollection

	selectedSelectors := aCollection
%

category: 'accessing'
method: RowanMethodsUpdate
selectors

	^selectors
%

category: 'accessing'
method: RowanMethodsUpdate
selectors: aCollection

	selectors := aCollection
%

category: 'accessing'
method: RowanMethodsUpdate
type: anObject

	type := anObject
%

category: 'updating'
method: RowanMethodsUpdate
updateMethodCategories

	self classesFromNames do: [:each | 
		each 
			env: 0 
			categorysDo:[ :category :sels | methodFilters add: category ].
	].
	methodFilters isEmpty ifTrue: [methodFilters := #(#'other')].
%

category: 'updating'
method: RowanMethodsUpdate
updateMethodFilterSelections: oldSelections hasCategoryOverride: override
	self filterSelections: (oldSelections collect:[:sel | sel asSymbol]).
%

category: 'updating'
method: RowanMethodsUpdate
updateMethodPragmas

	| currentClass |
	currentClass := ((self objectInBaseNamed: #'Pragma') notNil and: [self selectionNames notEmpty]) ifTrue: [self objectInBaseNamed: self selectionNames first] ifFalse: [nil].
	methodFilters := IdentitySet new.
	currentClass notNil ifTrue: [
		(currentClass methodDictForEnv: 0) do: [:each | methodFilters addAll: each pragmas].
	].
	methodFilters := methodFilters collect: [:each | each keyword].
	methodFilters := (methodFilters asSortedCollection: [:a :b | a > b]) asArray.  "SortedCollections cannot be grown in Dolphin Smalltalk"
%

category: 'updating'
method: RowanMethodsUpdate
updateMethodsInfo

	selectors do:[:selector |
		| isTestClass update |

		isTestClass := false.
		self selectedClass _allSuperList do: [:each | 
			isTestClass := isTestClass or: [each name = #'TestCase'].
		].
		update := methods detect:[:methodUpdate | methodUpdate selector = selector] ifNone:[RowanMethodUpdate new].
		update selector: selector;
			isTestClass: isTestClass;
			isOverride: (self selectedClassOverridesSelector: selector).
		methods add: update. 
		].
%

category: 'updating'
method: RowanMethodsUpdate
updateMethodVariables

	| currentClass | 
	currentClass := classNames notEmpty ifTrue: [self classesFromNames last] ifFalse: [nil].
	methodFilters := OrderedCollection new.
	[
		currentClass notNil.
	] whileTrue: [
		methodFilters
			addAll: currentClass instVarNames reverse;
			add: ' ' , currentClass name;
			yourself.
		currentClass := currentClass superclass.
	].
%

category: 'jade'
method: RowanMethodsUpdate
writeInheritedClassesTo: writeStream

	inheritedClasses do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeInheritedClassTo: writeStream

	writeStream nextPutAll: inheritedClass; lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeMethodCategoriesTo: writeStream
	"Reverse order to be consistent with variables, where we add superclasses to the end"

	methodFilters := methodFilters asSortedCollection asArray reverse.
	self writeMethodFiltersTo: writeStream
%

category: 'jade'
method: RowanMethodsUpdate
writeMethodFiltersTo: writeStream

	methodFilters do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeMethodsTo: writeStream

	methods do: [:methodUpdate | 	
		writeStream 
"1"		nextPutAll: methodUpdate selector; tab;
"2"		nextPut: (methodUpdate isOverride ifTrue: [$T] ifFalse: [$F]); tab;
"3"		nextPut: (methodUpdate isTestClass ifTrue: [$T] ifFalse: [$F]); tab;
"4"		nextPut: $F; tab;
"5"		nextPutAll: methodUpdate selector; tab;	
		lf.
	].
	writeStream nextPut: $%; lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeSelectedSelectorsTo: writeStream

	selectedSelectors do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeSelectionsTo: writeStream

	self selectionNames do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanMethodsUpdate
writeTypeTo: writeStream

	writeStream 
		nextPutAll: type; tab;
		nextPutAll: '0';  "environment default"
		lf.
%

! Class implementation for 'RowanSuperclassUpdate'

!		Instance methods for 'RowanSuperclassUpdate'

category: 'accessing'
method: RowanSuperclassUpdate
tabName

	^tabName
%

category: 'accessing'
method: RowanSuperclassUpdate
tabName: aString

	tabName := aString
%

category: 'jade'
method: RowanSuperclassUpdate
writeTabNameTo: writeStream

	writeStream nextPutAll: tabName; lf.
%

! Class implementation for 'RowanClassInfoUpdate'

!		Instance methods for 'RowanClassInfoUpdate'

category: 'accessing'
method: RowanClassInfoUpdate
category: aString

	category := aString
%

category: 'accessing'
method: RowanClassInfoUpdate
comment: aString

	comment := aString
%

category: 'accessing'
method: RowanClassInfoUpdate
oop: aNumber

	oop := aNumber
%

category: 'accessing'
method: RowanClassInfoUpdate
template 

	^template
%

category: 'accessing'
method: RowanClassInfoUpdate
template: anObject

	template := anObject
%

category: 'jade'
method: RowanClassInfoUpdate
writeInfoOn: writeStream

	writeStream
		nextPutAll: oop printString; 
		lf;
		nextPut: $(;
		lf;
		nextPutAll: template;
		nextPut: $);
		lf;
		nextPutAll: String new.
	category ifNotNil: [
		writeStream
			nextPutAll: category;
			lf].
	writeStream
		nextPut: $%;
		lf.
	comment ifNotNil: [
		writeStream
			nextPutAll: comment;
			lf].
	writeStream
		nextPut: $%;
		lf.
%

! Class implementation for 'RowanDictionaryUpdate'

!		Instance methods for 'RowanDictionaryUpdate'

category: 'accessing'
method: RowanDictionaryUpdate
dictionaries

	^dictionaries
%

category: 'initialization'
method: RowanDictionaryUpdate
initialize

	dictionaries := Array new. 
	selections := Array new.
%

category: 'accessing'
method: RowanDictionaryUpdate
selections

	^selections
%

category: 'jade'
method: RowanDictionaryUpdate
writeDictionariesTo: writeStream

	dictionaries do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanDictionaryUpdate
writeSelectionsTo: writeStream

	selections do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

! Class implementation for 'RowanGlobalsUpdate'

!		Instance methods for 'RowanGlobalsUpdate'

category: 'accessing'
method: RowanGlobalsUpdate
globals

	^globals
%

category: 'initialization'
method: RowanGlobalsUpdate
initialize

	globals := Array new.
%

category: 'jade'
method: RowanGlobalsUpdate
writeGlobalsTo: writeStream
	"globals is an array of 5 elements"
	
	globals do: [:array | 
		1 to: 4 do:[:idx |
			writeStream nextPutAll: (array at: idx); tab].
		writeStream nextPutAll: (array at: 5); lf].
	writeStream nextPut: $%; lf.
%

! Class implementation for 'RowanGsObject'

!		Instance methods for 'RowanGsObject'

category: 'other'
method: RowanGsObject
name

	^name
%

category: 'other'
method: RowanGsObject
name: anObject

	name := anObject
%

category: 'other'
method: RowanGsObject
oopType

	^oopType
%

category: 'other'
method: RowanGsObject
oopType: anObject

	oopType := anObject
%

! Class implementation for 'RowanGsMethod'

!		Instance methods for 'RowanGsMethod'

category: 'accessing'
method: RowanGsMethod
behavior

	^behavior
%

category: 'accessing'
method: RowanGsMethod
behavior: anObject

	behavior := anObject
%

category: 'accessing'
method: RowanGsMethod
behaviorName

	^behaviorName
%

category: 'accessing'
method: RowanGsMethod
behaviorName: anObject

	behaviorName := anObject
%

category: 'accessing'
method: RowanGsMethod
breakPoints

	^breakPoints
%

category: 'accessing'
method: RowanGsMethod
breakPoints: anObject

	breakPoints := anObject asArray
%

category: 'accessing'
method: RowanGsMethod
category

	^category
%

category: 'accessing'
method: RowanGsMethod
category: anObject

	category := anObject
%

category: 'initialization'
method: RowanGsMethod
initialize

	stepPoints := Dictionary new
%

category: 'accessing'
method: RowanGsMethod
isReadOnly

	^isReadOnly
%

category: 'accessing'
method: RowanGsMethod
isReadOnly: anObject

	isReadOnly := anObject
%

category: 'accessing'
method: RowanGsMethod
originalSource

	^originalSource
%

category: 'accessing'
method: RowanGsMethod
originalSource: anObject

	originalSource := anObject
%

category: 'accessing'
method: RowanGsMethod
source

	^source
%

category: 'accessing'
method: RowanGsMethod
source: anObject

	source := anObject
%

category: 'accessing'
method: RowanGsMethod
stepPoints

	^stepPoints
%

category: 'accessing'
method: RowanGsMethod
stepPoints: anObject

	stepPoints := anObject
%

category: 'accessing'
method: RowanGsMethod
unimplementedSelectors

	^unimplementedSelectors
%

category: 'accessing'
method: RowanGsMethod
unimplementedSelectors: anObject

	unimplementedSelectors := anObject
%

category: 'accessing'
method: RowanGsMethod
warnings

	^warnings
%

category: 'accessing'
method: RowanGsMethod
warnings: anObject

	warnings := anObject
%

! Class implementation for 'RowanMethodUpdate'

!		Instance methods for 'RowanMethodUpdate'

category: 'accessing'
method: RowanMethodUpdate
breakPoints

	^gsMethod breakPoints
%

category: 'accessing'
method: RowanMethodUpdate
breakPoints: anObject

	gsMethod breakPoints: anObject asOrderedCollection
%

category: 'accessing'
method: RowanMethodUpdate
category

	^gsMethod category
%

category: 'accessing'
method: RowanMethodUpdate
category: anObject

	gsMethod category: anObject
%

category: 'accessing'
method: RowanMethodUpdate
className

	^gsMethod behaviorName
%

category: 'accessing'
method: RowanMethodUpdate
className: anObject

	gsMethod behaviorName: anObject
%

category: 'accessing'
method: RowanMethodUpdate
classOop

	^gsMethod behavior
%

category: 'accessing'
method: RowanMethodUpdate
classOop: anObject

	gsMethod behavior: anObject.
%

category: 'accessing'
method: RowanMethodUpdate
compilationWarnings

	^gsMethod warnings
%

category: 'accessing'
method: RowanMethodUpdate
compilationWarnings: aString

	gsMethod warnings: aString
%

category: 'accessing'
method: RowanMethodUpdate
firstSendOffsets

	^firstSendOffsets
%

category: 'initialization'
method: RowanMethodUpdate
initialize

	firstSendOffsets := Dictionary new.
	gsMethod := RowanGsMethod new.
%

category: 'accessing'
method: RowanMethodUpdate
isOverride

	^isOverride
%

category: 'accessing'
method: RowanMethodUpdate
isOverride: anObject

	isOverride := anObject
%

category: 'accessing'
method: RowanMethodUpdate
isReadOnly

	^gsMethod isReadOnly
%

category: 'accessing'
method: RowanMethodUpdate
isReadOnly: anObject

	gsMethod isReadOnly: anObject
%

category: 'accessing'
method: RowanMethodUpdate
isTestClass

	^isTestClass
%

category: 'accessing'
method: RowanMethodUpdate
isTestClass: anObject

	isTestClass := anObject
%

category: 'accessing'
method: RowanMethodUpdate
method: anObject
	
	method := anObject
%

category: 'accessing'
method: RowanMethodUpdate
methodOop

	^gsMethod oopType
%

category: 'accessing'
method: RowanMethodUpdate
methodOop: anObject

	gsMethod oopType: anObject
%

category: 'accessing'
method: RowanMethodUpdate
originalMethodSource

	 ^gsMethod originalSource
%

category: 'accessing'
method: RowanMethodUpdate
originalMethodSource: anObject

	gsMethod originalSource: anObject
%

category: 'accessing'
method: RowanMethodUpdate
selector

	^gsMethod name
%

category: 'accessing'
method: RowanMethodUpdate
selector: anObject

	gsMethod name: anObject
%

category: 'accessing'
method: RowanMethodUpdate
source

	^gsMethod source
%

category: 'accessing'
method: RowanMethodUpdate
source: anObject

	gsMethod source: anObject
%

category: 'accessing'
method: RowanMethodUpdate
stepPoints

	^gsMethod stepPoints
%

category: 'accessing'
method: RowanMethodUpdate
stepPoints: anObject

	gsMethod stepPoints: anObject
%

category: 'jade'
method: RowanMethodUpdate
writeMethodTo: writeStream
		
		writeStream 	"Line 1 for GsMethod (line 3 for JadeSystemBrowserPresenter)"
"1"		nextPutAll: self classOop printString; tab;
"2"		nextPutAll: self className; tab;
"3"		nextPutAll: self methodOop printString; tab;
"4"		nextPutAll: (self selector ifNil:[String new]); tab;
"5"		nextPutAll: self category; tab;
"6"		nextPutAll: self isReadOnly asString; tab;
		lf.

	"Method source"
	writeStream nextPutAll: self source.
	self source last = Character lf ifFalse: [writeStream lf].
	writeStream nextPut: $%; lf.	"Lines 2-N"

	"unimplemented selectors"			"https://github.com/jgfoster/Jade/issues/117"
	self firstSendOffsets keysAndValuesDo:[:offset :sel |
		writeStream 
			nextPutAll: offset printString;
			space;
			nextPutAll: sel;
			tab].
	writeStream lf.

	self stepPoints keysAndValuesDo:[:key :value |
		writeStream 
			nextPutAll: key
			space;
			nextPutAll: value; 
			tab].
	writeStream lf.
	
	self breakPoints do:[:bp | 
		writeStream nextPutAll: bp printString
		tab].
	writeStream lf.

	"original method"
	self originalMethodSource notNil ifTrue:[
		writeStream nextPutAll: self originalMethodSource.
		(self originalMethodSource notEmpty and: [self originalMethodSource last = Character lf]) ifFalse: [writeStream lf]].
	writeStream nextPut: $%; lf.

	"compilation warnings"
	writeStream nextPutAll: self compilationWarnings; nextPut: $%; lf.
%

! Class implementation for 'RowanPackageUpdate'

!		Instance methods for 'RowanPackageUpdate'

category: 'initialization'
method: RowanPackageUpdate
initialize

	packages := Array new. 
	modifiedPackages := Array new.
	selections := Array new.
%

category: 'accessing'
method: RowanPackageUpdate
modifiedPackages

	^modifiedPackages
%

category: 'accessing'
method: RowanPackageUpdate
packages

	^packages
%

category: 'accessing'
method: RowanPackageUpdate
selections

	^selections
%

category: 'jade'
method: RowanPackageUpdate
writeModifiedPackagesTo: writeStream

	modifiedPackages do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

category: 'jade'
method: RowanPackageUpdate
writePackagesTo: writeStream

	packages do: [:each | writeStream nextPutAll: each name; tab].
	writeStream lf.
%

category: 'jade'
method: RowanPackageUpdate
writeSelectionsTo: writeStream

	selections do: [:each | writeStream nextPutAll: each; tab].
	writeStream lf.
%

! Class implementation for 'RowanProjectsUpdate'

!		Instance methods for 'RowanProjectsUpdate'

category: 'initialize'
method: RowanProjectsUpdate
initialize

	projects := Array new. 
	modifiedProjects := Array new.
	selection := Array new.
%

category: 'accessing'
method: RowanProjectsUpdate
modifiedProjects

	^modifiedProjects
%

category: 'accessing'
method: RowanProjectsUpdate
projects

	^projects
%

category: 'accessing'
method: RowanProjectsUpdate
selection

	^selection
%

! Class implementation for 'RowanInterface'

!		Class methods for 'RowanInterface'

category: 'instance creation'
classmethod: RowanInterface
newNamed: aName

	^ self new
		initializeForName: aName;
		yourself
%

!		Instance methods for 'RowanInterface'

category: 'accessing'
method: RowanInterface
classes

	| classes |
	classes := IdentitySet new.
	classes
		addAll: self extendedClasses;
		addAll: self definedClasses.
	^ classes
%

category: 'accessing'
method: RowanInterface
definedClasses

	^ self subclassResponsibility: #'definedClasses'
%

category: 'accessing'
method: RowanInterface
extendedClasses

	^ self subclassResponsibility: #'extendedClasses'
%

category: 'initialization'
method: RowanInterface
initializeForName: aName

	name := aName
%

category: 'accessing'
method: RowanInterface
name

	^ name
%

category: 'accessing'
method: RowanInterface
project

	^ self RwProject newNamed: self _loadedProject name
%

category: 'private'
method: RowanInterface
_loadedProject

	^ self subclassResponsibility: #'_loadedProject'
%

category: 'private'
method: RowanInterface
_packageTools

	^ Rowan packageTools
%

category: 'private'
method: RowanInterface
_projectTools

	^ Rowan projectTools
%

! Class implementation for 'RwPackage'

!		Instance methods for 'RwPackage'

category: 'accessing'
method: RwPackage
definedClasses

	^ self _packageTools query classesForPackageNamed: self name
%

category: 'accessing'
method: RwPackage
extendedClasses

	^ self _packageTools query classExtensionsForPackageNamed: self name
%

category: 'testing'
method: RwPackage
isDirty

	^self _loadedPackage isDirty
%

category: 'private'
method: RwPackage
_loadedPackage

	^ Rowan image loadedPackageNamed: self name
%

category: 'private'
method: RwPackage
_loadedProject

	^ self _loadedPackage loadedProject
%

! Class implementation for 'RwProject'

!		Instance methods for 'RwProject'

category: 'properties'
method: RwProject
canCommit

	^ self _specification canCommit
%

category: 'properties'
method: RwProject
comment

	^ self _specification comment
%

category: 'accessing'
method: RwProject
currentBranchName

	| rootPath |
	self useGit
		ifFalse: [ ^ '' ].
	rootPath := self repositoryRootPath.
	rootPath ifNil: [ ^ '' ].
	^ Rowan gitTools gitBranchNameIn:rootPath
%

category: 'accessing'
method: RwProject
definedClasses

	^ self _projectTools query classForProjectNamed: self name
%

category: 'testing'
method: RwProject
existsOnDisk

	Rowan image loadedProjectNamed: self name ifAbsent: [ ^false ].
	^ Rowan platform fileUtilities directoryExists: self repositoryRootPath.
%

category: 'accessing'
method: RwProject
extendedClasses

	^ self _projectTools query classExtensionsForProjectNamed: self name
%

category: 'testing'
method: RwProject
isDirty

	^self _loadedProject isDirty
%

category: 'properties'
method: RwProject
loadedCommitId

	^ self _specification loadedCommitId
%

category: 'accessing'
method: RwProject
packageNames

	^ self _loadedProject packageNames
%

category: 'accessing'
method: RwProject
packages

	^ self packageNames collect: [ :packageName | RwPackage newNamed: packageName ]
%

category: 'accessing'
method: RwProject
project

	^ self
%

category: 'accessing'
method: RwProject
projectUrl

	"Return the projectUrl used to clone the project"

	^ self _loadedProject projectUrl
%

category: 'project creation'
method: RwProject
register
	"Create a loaded project based on the receiver's properties in the image."

	self _specification register
%

category: 'properties'
method: RwProject
remote

	^ self _specification remote
%

category: 'accessing'
method: RwProject
repositoryCommitId

	| rootPath |
	self useGit
		ifFalse: [ ^ '' ].
	rootPath := self repositoryRootPath.
	rootPath ifNil: [ ^ '' ].
	^ Rowan gitTools gitcommitShaIn: rootPath
%

category: 'properties'
method: RwProject
repositoryRootPath

	^ self _specification repositoryRootPath
%

category: 'testing'
method: RwProject
useGit

	^self _specification useGit
%

category: 'private'
method: RwProject
_loadedProject

	^ Rowan image loadedProjectNamed: self name
%

category: 'private'
method: RwProject
_specification

	^ self _loadedProject specification
%

! Class implementation for 'RowanService'

!		Class methods for 'RowanService'

category: 'autocommit'
classmethod: RowanService
autoCommit

	^SessionTemps current at: #'Jadeite_AutoCommit' ifAbsentPut: [false]
%

category: 'autocommit'
classmethod: RowanService
breakPointsAreEnabled

	^SessionTemps current at: #'Jadeite_BreakPointsAreEnabled' ifAbsentPut: [true]
%

category: 'autocommit'
classmethod: RowanService
flipAutoCommit
	| newValue |
	newValue := self autoCommit == #failed ifTrue:[false] ifFalse:[self autoCommit not].
	^self setAutoCommit: newValue
%

category: 'instance creation'
classmethod: RowanService
new

	^super new initialize
%

category: 'other'
classmethod: RowanService
rowanFixMe

	"send this message to see everywhere that GS_Jade should be fixed"
%

category: 'examples'
classmethod: RowanService
sampleService

	^self new sampleService
%

category: 'autocommit'
classmethod: RowanService
setAutoCommit: object

	^SessionTemps current at: #'Jadeite_AutoCommit' put: object
%

category: 'autocommit'
classmethod: RowanService
setBreakPointsAreEnabled: boolean
  ^ SessionTemps current at: #'Jadeite_BreakPointsAreEnabled' put: boolean
%

category: 'accessing'
classmethod: RowanService
version
  "change this method carefully and only at Jadeite release boundaries.
	Failure to do so will prevent logins"

  ^ 3091
%

!		Instance methods for 'RowanService'

category: 'other'
method: RowanService
answer: anObject

	| answeringService |
	answeringService := RowanAnsweringService new. 
	answeringService answer: anObject. 
	RowanCommandResult addResult: answeringService.
%

category: 'rowan'
method: RowanService
browserTool

	^self projectTools browser
%

category: 'commands support'
method: RowanService
classHierarchy: theClasses
  | superclassChains levels services hierarchies toExpand hierarchyServices |
  superclassChains := self superclassChainsFor: theClasses.
  hierarchies := self extendHierarchies: superclassChains.
  levels := self hierarchiesByLevel: hierarchies.
  services := Dictionary new.
  toExpand := Set new.
  self
    services: services
    from: levels
    expand: toExpand
    classes: theClasses.
  hierarchyServices := services reject: [ :array | array isEmpty ].
  hierarchyServices copy
    keysAndValuesDo: [ :key :value | 
      hierarchyServices
        at: key
        put:
          (value asSet asSortedCollection: [ :x :y | x name < y name ]) asArray ].
  ^ hierarchyServices
%

category: 'accessing'
method: RowanService
command

	^command
%

category: 'accessing'
method: RowanService
command: aSymbol

	command := aSymbol
%

category: 'accessing'
method: RowanService
commandArgs

	^commandArgs ifNil:[commandArgs := Array new]
%

category: 'accessing'
method: RowanService
commandArgs: anArray

	"for tests" 

	commandArgs := anArray
%

category: 'symbol dictionaries'
method: RowanService
createDefaultSymbolDictionary

	^self createSymbolDictionaryNamed: self defaultSymbolDictionaryName
%

category: 'samples'
method: RowanService
createSampleSymbolDictionary

	self removeSymbolDictionaryNamed: self sampleSymbolDictionaryName.
	self createSymbolDictionaryNamed: self sampleSymbolDictionaryName
%

category: 'symbol dictionaries'
method: RowanService
createSymbolDictionaryNamed: aName

	| dictionary size |
	dictionary := SymbolDictionary new.
	dictionary at: aName asSymbol put: dictionary.
	size := Rowan image symbolList size.
	System myUserProfile insertDictionary: dictionary at: size + 1.
	^ dictionary
%

category: 'symbol dictionaries'
method: RowanService
defaultSymbolDictionary

	^self symbolDictionaryNamed: self defaultSymbolDictionaryName
%

category: 'symbol dictionaries'
method: RowanService
defaultSymbolDictionaryName

	^'RowanProjects'
%

category: 'rowan'
method: RowanService
definitionClass

	^self subclassResponsibility
%

category: 'rowan'
method: RowanService
definitionClassName

	^self definitionClass name
%

category: 'replication'
method: RowanService
excludedInstVars

	^#( #organizer)
%

category: 'commands support'
method: RowanService
extendHierarchies: hierarchies
	
	"extend the hierarchies by one level
	of subclasses"

	| extendedHierarchies |
	extendedHierarchies := Array new. 
	hierarchies do:[:hierarchy |
		| theClass subclasses |
		theClass := hierarchy last. 
		(subclasses := organizer subclassesOf: theClass) isEmpty 
			ifTrue:[extendedHierarchies add: hierarchy]
			ifFalse:[
				subclasses do:[:sub |
					extendedHierarchies add: (hierarchy copy add: sub; yourself)
				]]].
	^extendedHierarchies
%

category: 'perform'
method: RowanService
handleDeletedService
  self updateType: #'removed:'.
  RowanCommandResult addResult: self
%

category: 'commands support'
method: RowanService
hierarchiesByLevel: hierarchies

	"Return dictionary of classes by level. 
	Example: 
		hierarchies - #(#(Object Collection Array) #(Object AbstractException Exception))
	Return: 
		#(#nil->#(Object) Object->#(Collection AbstractException) Collection->#(Array) AbstractException->#(Exception)
	"
	| levels |
	levels := hierarchies inject: Dictionary new into:[:dict :chain | 
		1 to: chain size do: [:index | 
			| cls theSuper classSet |
			cls := chain at: index.
			classSet := dict at: cls ifAbsentPut: [Array new].
			index = 1 
		ifTrue:[
			classSet := dict at: #'nil' ifAbsentPut: [Array new]. 
			((dict at: #'nil') includes: cls) ifFalse:[(dict at: #'nil') add: cls].
		]
		ifFalse:[
				theSuper := chain at: index - 1.
				((dict at: theSuper) includes: cls) ifFalse:[(dict at: theSuper) add: cls]
				]].
			dict].
	^levels
%

category: 'initialization'
method: RowanService
initialize
%

category: 'testing'
method: RowanService
isClassService

	^false
%

category: 'testing'
method: RowanService
isDictionaryService

	^false
%

category: 'testing'
method: RowanService
isMethodService

	^false
%

category: 'testing'
method: RowanService
isPackageService

	^false
%

category: 'testing'
method: RowanService
isProjectService

	^false
%

category: 'testing'
method: RowanService
isUpdating

	^command == #update
%

category: 'perform'
method: RowanService
isUpdatingButFoundToBeDeleted
  ^ self command == #'update' and: [ self wasDeleted ]
%

category: 'accessing'
method: RowanService
jadeiteServer

	^(Rowan jadeServerClassNamed: #JadeServer) theJadeiteServer
%

category: 'accessing'
method: RowanService
organizer: anOrganizer

	organizer := anOrganizer.
%

category: 'rowan'
method: RowanService
projectTools

	^Rowan projectTools
%

category: 'samples'
method: RowanService
removeSampleSymbolDictionary

	self removeSymbolDictionaryNamed: self sampleSymbolDictionaryName.
%

category: 'symbol dictionaries'
method: RowanService
removeSymbolDictionaryNamed: aName

	| index |
	index := Rowan image symbolList names indexOf: aName asSymbol.
	index ~= 0 ifTrue:[
		System myUserProfile removeDictionaryAt: index]
%

category: 'other'
method: RowanService
rowanFixMe
		
	"marker for all things broken in Rowan"
%

category: 'rowan'
method: RowanService
rowanLoadedPackageNames

	| stream packages |
	self rowanFixMe.	"handle modified package display"
	stream := WriteStream on: String new.
	packages := Rowan packageNames.
	packages do: 
					[:package |
					stream
						nextPutAll: package;
						tab;
						nextPut: ((RwPackage newNamed: package) isDirty ifTrue:[$Y] ifFalse:[$N]);
						tab;
						nextPutAll: package;
						lf].
	^stream contents
%

category: 'accessing'
method: RowanService
rowanProjectName

	"all services should be able to return a project name
	even if they are not truly packaged" 

	^nil
%

category: 'samples'
method: RowanService
sampleSymbolDictionaryName

	^'SampleSymbolDictionaryName'
%

category: 'perform'
method: RowanService
servicePerform: symbol withArguments: collection
  "each service updates itself after performing a command.
	Therefore, if the command is #update, don't run it here"

  SessionTemps current
    at: #'versionsVerified'
    ifAbsent: [ 
      SessionTemps current at: #'versionsVerified' put: false.
      self
        inform:
          'Version mismatch failure. Client version is older than server version.' ].
  symbol == #'update'
    ifTrue: [ ^ self ].
  ^ super perform: symbol withArguments: collection
%

category: 'commands support'
method: RowanService
services: services from: levels expand: toExpand classes: theClasses
  "In order to avoid the expense of creating duplicate services, we cache
them in the newServices temporary for look up"

  | newServices |
  newServices := Array new.
  theClasses
    do: [ :aClass | toExpand addAll: (organizer allSuperclassesOf: aClass) ].
  levels
    keysAndValuesDo: [ :key :value | 
      | newKey service |
      newKey := key = #'nil'
        ifTrue: [ #'nil' ]
        ifFalse: [ 
          service := newServices
            detect: [ :classService | classService name = key name ]
            ifNone: [ RowanClassService new classServiceFromOop: key asOop ].
          (toExpand includes: service theClass)
            ifTrue: [ service expand: true ]
            ifFalse: [ service expand: false ].
          service ].
      services
        at: newKey
        put:
          (value
            collect: [ :cls | 
              service := newServices
                detect: [ :classService | classService name = cls name ]
                ifNone: [ RowanClassService new classServiceFromOop: cls asOop ].
              (toExpand includes: service theClass)
                ifTrue: [ service expand: true ]
                ifFalse: [ service expand: false ].
              service ]) ]
%

category: 'replication'
method: RowanService
stonOn: stonWriter
    | instanceVariableNames |
    instanceVariableNames := self class allInstVarNames reject: [:iv | self excludedInstVars includes: iv].
    stonWriter writeObject: self
        streamMap: 
            [:dictionary |
            instanceVariableNames do: 
                    [:each |
                    (self instVarAt: (self class allInstVarNames indexOf: each asSymbol))
                        ifNotNil: [:value | dictionary at: each asSymbol put: value]
                        ifNil: [self stonShouldWriteNilInstVars ifTrue: [dictionary at: each asSymbol put: nil]]]]
%

category: 'replication'
method: RowanService
stonStringFor: anObject

	"return a string representing a complete object structure
	suitable for replicating on the client."

	^STON toString: anObject
%

category: 'commands support'
method: RowanService
superclassChainsFor: behaviors
	organizer := ClassOrganizer new. 
	^behaviors collect:[:behavior | | supers |
			supers := organizer allSuperclassesOf: behavior. 
			supers add: behavior. 
			supers].
%

category: 'symbol dictionaries'
method: RowanService
symbolDictionaryNamed: aName

	| symbolList  index |
	symbolList := Rowan image symbolList.
	index :=symbolList names indexOf: aName asSymbol.
	^index ~= 0
		ifTrue:[
			symbolList at: index]
		ifFalse:[
			self createSymbolDictionaryNamed: aName].
%

category: 'initialization'
method: RowanService
update
%

category: 'update'
method: RowanService
updateInternalService: updatedService

	"no internally held services to update"
%

category: 'update'
method: RowanService
updateLatest
  "subclasses may want to special behavior to update themselves
	to their loaded version"

  self update
%

category: 'accessing'
method: RowanService
updateType: aSymbol

	updateType := aSymbol
%

category: 'testing'
method: RowanService
wasDeleted

	^false
%

category: 'fileout'
method: RowanService
writeFileOutHeaderOn: stream
	"This method will write a fileout header onto the given file.
	Adapted from GBS - GbxBrowser>>writeFileOutHeaderOn:"

	| rawVer beVer cr |
	stream nextPutAll: 'fileformat utf8';
			cr. 
	rawVer := System _version.
	beVer := ''.
	cr := String with: Character cr.
	"Comment each newline"
	(rawVer subStrings: (Array with: Character lf)) do: [:line | beVer := beVer , '! ' , line , cr].
	stream
		nextPutAll: '!';
		cr;
		nextPutAll: '! From ';
		nextPutAll: beVer;
		cr;
		nextPutAll: '! On ';
		nextPutAll: Date today printString;
		nextPutAll: ', ';
		nextPutAll: Time now printString;
		cr;
		nextPutAll: '!';
		cr;
		flush
%

! Class implementation for 'RowanAnsweringService'

!		Instance methods for 'RowanAnsweringService'

category: 'private'
method: RowanAnsweringService
addLowerCaseSymbolsIn: theClass To: array
  array addAll: theClass selectors.
  array addAll: theClass class selectors.
  array addAll: theClass instVarNames.
  array addAll: theClass class instVarNames.
  array addAll: theClass classVarNames.
%

category: 'client commands'
method: RowanAnsweringService
allClassesStartingWith: string
  answer := SortedCollection new.
  organizer classes
    do: [ :cls | 
      (cls name beginsWith: string)
        ifTrue: [ answer add: cls name asString ] ].
  answer := answer asArray.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
allClassNames
  answer := SortedCollection new.
  answer addAll: (organizer classes collect: [ :cls | cls name asString ]).
  answer := answer asArray.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
allTestsIn: classServices
	answer := Array new. 
	classServices do:[:service | answer addAll: service allTests].
	RowanCommandResult addResult: self.
%

category: 'other'
method: RowanAnsweringService
answer

	^answer
%

category: 'Updating'
method: RowanAnsweringService
answer: anObject

	answer := anObject
%

category: 'client commands'
method: RowanAnsweringService
autoCommit

	answer := RowanService autoCommit. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
autocompleteSymbols
  | newClassNames newLowerCaseSymbols |
  newClassNames := Array new.
  newLowerCaseSymbols := Array new.
  organizer classes
    do: [ :cls | 
      newClassNames add: cls name asString.
      self addLowerCaseSymbolsIn: cls To: newLowerCaseSymbols ].
  newLowerCaseSymbols := newLowerCaseSymbols asSet asArray.
  SessionTemps current
    at: #'autocompleteSymbolCache'
    put: (Array with: newClassNames with: newLowerCaseSymbols).
  answer := Array
    with: newClassNames asOrderedCollection
    with: newLowerCaseSymbols asOrderedCollection.
  updateType := #'updateSymbols:'.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
breakPointsAreEnabled
  answer := RowanService breakPointsAreEnabled.
  updateType := #'breakpointSettingChanged:'.
  RowanCommandResult addResult: self.
  ^ answer	"for testing"
%

category: 'client commands'
method: RowanAnsweringService
clearAllBreaks
  | methodServices |
  methodServices := RowanQueryService new
    organizer: organizer;
    basicBreakpointMethods.
  GsNMethod clearAllBreaks.
  methodServices
    do: [ :methodService | RowanCommandResult addResult: methodService update ]
%

category: 'client commands'
method: RowanAnsweringService
clearMethodBreaks: methodServices
  methodServices
    do: [ :methodService | 
      methodService
        organizer: organizer;
        clearMethodBreaks ]
%

category: 'client commands'
method: RowanAnsweringService
disableAllBreaks
  | methodServices |
  methodServices := RowanQueryService new
    organizer: organizer;
    basicBreakpointMethods.
  GsNMethod _disableAllBreaks.
  methodServices
    do: [ :methodService | RowanCommandResult addResult: methodService update ]
%

category: 'client commands'
method: RowanAnsweringService
doClientAndServerVersionsMatch: clientVersion
  "Not to be sent through services so return an answer directly.
	Sent immediately after Jadeite login"

  SessionTemps current at: #'versionsVerified' put: false.
  clientVersion = RowanService version
    ifTrue: [ 
      answer := true.
      SessionTemps current at: #'versionsVerified' put: true ]
    ifFalse: [ 
      answer := clientVersion > RowanService version
        ifTrue: [ 
          'Client (' , clientVersion printString , ') is more recent than server ('
            , RowanService version printString , ')' ]
        ifFalse: [ 
          'Server (' , RowanService version printString , ') is more recent than client ('
            , clientVersion printString , ')' ] ].
  ^ answer
%

category: 'client commands'
method: RowanAnsweringService
enableAllBreaks
  | methodServices |
  methodServices := RowanQueryService new
    organizer: organizer;
    basicBreakpointMethods.
  GsNMethod _enableAllBreaks.
  methodServices
    do: [ :methodService | RowanCommandResult addResult: methodService update ]
%

category: 'client commands'
method: RowanAnsweringService
exec: aString

	"for command line service someday"
	answer := aString evaluate printString. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
exec: aString context: oop

	answer := [true -> (aString evaluateInContext: (Object _objectForOop: oop) symbolList: Rowan image symbolList) asOop] 
		on: CompileError do: [:ex | 
			false -> ex errorDetails
	].
	answer key ifTrue:[(RowanService autoCommit == true) ifTrue:[System commitTransaction]].
	RowanCommandResult addResult: self.

	"return answer for testing" 
	^answer
%

category: 'client commands'
method: RowanAnsweringService
exec: aString inFrame: level ofProcess: processOop context: oop
  | symbolList frameContents symbolDictionary process |
  symbolList := Rowan image symbolList.
  process := Object _objectForOop: processOop.
  process _isTerminated
    ifTrue: [ 
      RowanCommandResult addResult: self.
      ^ self ].
  frameContents := process _frameContentsAt: level.
  frameContents
    ifNotNil: [ 
      symbolDictionary := SymbolDictionary new.
      1 to: (frameContents at: 9) size do: [ :index | 
        ((frameContents at: 9) at: index) first = $.
          ifFalse: [ 
            symbolDictionary
              at: ((frameContents at: 9) at: index) asSymbol
              put: (frameContents at: 11 + index - 1) ] ].
      symbolList add: symbolDictionary before: symbolList first ].
  [ 
  answer := [ 
  true
    ->
      (aString evaluateInContext: (Object _objectForOop: oop) symbolList: symbolList)
        asOop ]
    on: CompileError
    do: [ :ex | false -> ex errorDetails ].
  answer key
    ifTrue: [ 
      RowanService autoCommit == true
        ifTrue: [ System commitTransaction ] ].
  RowanCommandResult addResult: self ]
    ensure: [ 
      1 to: (frameContents at: 9) size do: [ :index | 
        | argsAndTemps |
        argsAndTemps := frameContents at: 9.
        (argsAndTemps at: index) first = $.
          ifFalse: [ 
            | variableService |
            process
              _frameAt: level
              tempAt: index
              put: (symbolDictionary at: (argsAndTemps at: index)).
            variableService := RowanVariableService
              oop: (symbolDictionary at: (argsAndTemps at: index)) asOop
              key: (argsAndTemps at: index)
              value: (symbolDictionary at: (argsAndTemps at: index))
              className: (frameContents at: 8) class name asString.
            RowanCommandResult addResult: variableService ] ].
      symbolList remove: symbolDictionary ].	"return answer for testing"
  ^ answer
%

category: 'client commands'
method: RowanAnsweringService
expressionSelector: string
  "try to uncover a selector in the string. 
	If it's not possible, return the string and 
	let the application do with it what it will"

  | messageNode |
  messageNode := [ RBParser parseExpression: string ]
    on: Error
    do: [ :ex | nil ].
  answer := messageNode
    ifNil: [ string ]
    ifNotNil: [ 
      messageNode isMessage
        ifTrue: [ messageNode buildSelector ]
        ifFalse: [ string ] ].
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
flipTranscript
	self isTranscriptInstalled ifTrue:[
		self jadeiteServer uninstallTranscript]
	ifFalse:[
		self jadeiteServer installTranscript]
%

category: 'client commands'
method: RowanAnsweringService
initializeAutoCommit

	RowanService setAutoCommit: false
%

category: 'client commands'
method: RowanAnsweringService
initializeBreakPointsAreEnabled
  RowanService setBreakPointsAreEnabled: true
%

category: 'client commands'
method: RowanAnsweringService
interactionHandlerActive
  answer := SessionTemps current
    at: #'rowanServiceInteractionActive'
    ifAbsent: [ true ].
  RowanCommandResult addResult: self
%

category: 'testing'
method: RowanAnsweringService
isTranscriptInstalled

	^self transcriptObject == self jadeiteServer
%

category: 'client commands'
method: RowanAnsweringService
loadedPackageExists: packageName
	
	| actualName |
	actualName := Rowan image packageNames detect:[:loadedName | loadedName asLowercase = packageName asLowercase] ifNone:[]. 
	answer := (Rowan image loadedPackageNamed: actualName ifAbsent: []) notNil. 
	command := nil. 
	commandArgs := nil. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
needsCommit

	answer := System needsCommit.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAnsweringService
newPackageNamed: packageName
  | packageService |
  packageService := RowanPackageService new name: packageName.
  packageService update.
  answer := packageService.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
printStringOf: oop toMaxSize: integer

	answer := (Object _objectForOop: oop) printString. 
	answer := answer size > integer ifTrue: [(answer copyFrom: 1 to: integer) , '...'] ifFalse:[answer].
	RowanCommandResult addResult: self.
	^answer
%

category: 'client commands'
method: RowanAnsweringService
profile: block
  "not used yet. Utility method needs testing.
	Make sure block execution time is long enough - say 1 second. 
	Results may not be consistent

	Usage example: 
| block answeringService | 
block := [| browserService profMonitor |
		browserService := (RowanBrowserService new) .
		10 timesRepeat:[browserService packagesWithTests]]. 
answeringService := RowanAnsweringService new profile: block.
answeringService answer. "

  | time ns |
  time := System millisecondsToRun: block.
  ns := ProfMonitor computeInterval: time / 1000.
  answer := ProfMonitor monitorBlock: block intervalNs: ns.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
runMethodTests: methodServices

	| behavior |
	methodServices do:[:methodService |
		(methodService selector asString matchPattern: #('test' $*)) ifTrue:[ 
			behavior := methodService classFromName. 
			behavior debug: methodService selector]].
	answer := true. 
	RowanCommandResult initializeResults. "squash any client updates during server test run"
	RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
selectorsMatchingPattern: pattern
  answer := ((AllUsers userWithId: #'SymbolUser') resolveSymbol: #'AllSymbols')
    value.
  answer := answer
    select: [ :each | each charSize = 1 and: [ each _matchPatternNoCase: pattern ] ].
  answer := answer asSortedCollection asArray.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
setAutoCommit: object

	answer := RowanService setAutoCommit: object.
	RowanCommandResult addResult: self.
%

category: 'other'
method: RowanAnsweringService
setBreakPointsAreEnabled: boolean
  boolean
    ifTrue: [ self enableAllBreaks ]
    ifFalse: [ self disableAllBreaks ].
  RowanService setBreakPointsAreEnabled: boolean.
  answer := boolean.
  updateType := #'breakpointSettingChanged:'.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
setEnableInteractionHandler: boolean
  SessionTemps current at: #'rowanServiceInteractionActive' put: boolean
%

category: 'client commands'
method: RowanAnsweringService
sortedSymbols
  answer := SortedCollection new.
  ((AllUsers userWithId: #'SymbolUser') resolveSymbol: #'AllSymbols') value
    keysDo: [ :symbol | 
      symbol charSize = 1
        ifTrue: [ answer add: symbol ] ].
  answer := answer asArray.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanAnsweringService
subclassCreationTemplate: className
	 (RowanClassService new name: className) subclassCreationTemplate.  "gives an answer for us"
%

category: 'client commands'
method: RowanAnsweringService
transcriptInstalled

	answer := self isTranscriptInstalled.
	RowanCommandResult addResult: self.
%

category: 'private'
method: RowanAnsweringService
transcriptObject
	
	^(SessionTemps current  at: #'TranscriptStream_SessionStream')
%

category: 'client commands'
method: RowanAnsweringService
turnOffTranscriptWrites

	self isTranscriptInstalled ifTrue:[
		self flipTranscript]
%

category: 'client commands'
method: RowanAnsweringService
updateAutocompleteSymbols
  | cache newClassNames newLowerCaseSymbols |
  cache := SessionTemps current
    at: #'autocompleteSymbolCache'
    ifAbsent: [ ^ self	"autocomplete not activated" ].
  newClassNames := Array new.
  newLowerCaseSymbols := Array new.
  organizer classes
    do: [ :cls | 
      (cache first includes: cls name asString)
        ifFalse: [ newClassNames add: cls name asString ].
      self addLowerCaseSymbolsIn: cls To: newLowerCaseSymbols ].
  (SessionTemps current at: #'autocompleteSymbolCache') first
    addAll: newClassNames.
  newLowerCaseSymbols := newLowerCaseSymbols asSet asArray.
  cache last
    do: [ :selector | 
      (newLowerCaseSymbols includes: selector)
        ifTrue: [ newLowerCaseSymbols remove: selector ] ].
  (SessionTemps current at: #'autocompleteSymbolCache') last
    addAll: newLowerCaseSymbols.
  answer := Array with: newClassNames with: newLowerCaseSymbols.
  updateType := #'updateSymbols:'.
  RowanCommandResult addResult: self
%

! Class implementation for 'RowanAutoCommitService'

!		Instance methods for 'RowanAutoCommitService'

category: 'client commands'
method: RowanAutoCommitService
autoCommit: boolean

	self class setAutoCommit: boolean.
	autoCommit := self class autoCommit. 
	updateType := #autoCommitUpdate:.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanAutoCommitService
flipAutoCommit

	autoCommit := self class flipAutoCommit. 
	updateType := #autoCommitUpdate:.
	RowanCommandResult addResult: self.
%

! Class implementation for 'RowanBrowserService'

!		Instance methods for 'RowanBrowserService'

category: 'client commands'
method: RowanBrowserService
abortTransaction
  | autoCommitService autoCommitState |
  autoCommitState := RowanService autoCommit == #'failed'
    ifTrue: [ true ]
    ifFalse: [ RowanService autoCommit ].
  System abortTransaction.
  autoCommitService := RowanAutoCommitService new.
  autoCommitService autoCommit: autoCommitState.
  self updateProjects.
  self updateDictionaries
%

category: 'client commands'
method: RowanBrowserService
abortTransactionAndUpdateServices: services
  self abortTransaction.
  services
    do: [ :service | 
      "we just updated projects, package, & dictionary services"
      (service isProjectService not
        and: [ service isDictionaryService not and: [ service isPackageService not ] ])
        ifTrue: [ 
          service
            organizer: organizer;
            updateLatest ] ]
%

category: 'client commands'
method: RowanBrowserService
allClasses
	allClasses := self basicAllClasses.
	updateType := #classes. "#classes not used at the moment so no updates will be done"
	RowanCommandResult addResult: self
%

category: 'client commands support'
method: RowanBrowserService
basicAllClasses
  | theClasses |
  theClasses := SortedCollection sortBlock: [ :x :y | x name < y name ].
  theClasses
    addAll:
      (organizer classes
        collect: [ :class | 
          | service |
          service := RowanClassService new name: class name.
          service packageName: class rowanPackageName.
          service projectName: class rowanProjectName.
          service ]).
  ^ theClasses asArray
%

category: 'client commands'
method: RowanBrowserService
classHierarchy
	| theClasses |
	theClasses := allClasses collect:[:classService | classService theClass].
	hierarchyServices := self classHierarchy: theClasses. 
	updateType := #classHierarchyUpdate:browser:. 
	RowanCommandResult addResult: self.
%

category: 'private'
method: RowanBrowserService
classHierarchy: theClasses
  hierarchyServices := super classHierarchy: theClasses.
  ^ hierarchyServices
%

category: 'client commands'
method: RowanBrowserService
classHierarchyForDictionariesNamed: dictionaryNames
  | theClasses |
  theClasses := OrderedCollection new.
  dictionaryNames
    do: [ :dictionaryName | 
      (Rowan globalNamed: dictionaryName)
        keysAndValuesDo: [ :key :value | 
          value isClass
            ifTrue: [ theClasses add: value ] ] ].
  hierarchyServices := self classHierarchy: theClasses.
  updateType := #'classHierarchyUpdate:browser:'.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
classHierarchyForPackagesNamed: packageNames
  | theClasses |
  theClasses := OrderedCollection new.
  packageNames
    do: [ :packageName | 
      theClasses
        addAll:
          ((Rowan image loadedPackageNamed: packageName) loadedClasses 
            collect: [ :cls | cls handle]).
      theClasses
        addAll:
          ((Rowan image loadedPackageNamed: packageName) loadedClassExtensions
            collect: [ :cls | cls handle]) ].
  hierarchyServices := self classHierarchy: theClasses.
  updateType := #'classHierarchyUpdate:browser:'.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
compileClass: definitionString
  | anonymousMethod |
  self confirmDuplicateName: definitionString.
  anonymousMethod := definitionString
    _compileInContext: nil
    symbolList: Rowan image symbolList.
  SessionTemps current at: #'jadeiteCompileClassMethod' put: anonymousMethod
%

category: 'client commands support'
method: RowanBrowserService
confirmDuplicateName: definitionString
  | className |
  className := (definitionString subStrings at: 3) copyWithout: $'.
  (Rowan image symbolList resolveSymbol: className asSymbol)
    ifNotNil: [ 
      className = selectedClass
        ifFalse: [ 
          (self confirm: 'Class name is already an object. Continue?')
            ifFalse: [ ^ Error signal: 'Class not compiled. Name already exists.' ] ] ]
%

category: 'client commands'
method: RowanBrowserService
defaultClassHierarchy
	hierarchyServices := Dictionary new.   
	organizer hierarchy keysAndValuesDo: [:key :value |
		| classService |
		classService := key == #nil ifTrue:[#nil] ifFalse: [RowanClassService basicForClassNamed: key name].
		hierarchyServices at: classService put: (value collect:[:cls | RowanClassService basicForClassNamed: cls name]) asArray.
	].
	updateType := #classHierarchyUpdate:browser:. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanBrowserService
findRemovedServices: services

	services do:[:service | 
		service wasDeleted ifTrue:[
				service updateType: #removed:.
				RowanCommandResult addResult: service.
		]
	].
%

category: 'initialize'
method: RowanBrowserService
initialize
  super initialize.
  newCachedSelectors := Array new.
  newCachedClasses := Array new
%

category: 'accessing'
method: RowanBrowserService
newCachedClasses
	^newCachedClasses
%

category: 'accessing'
method: RowanBrowserService
newCachedClasses: object
	newCachedClasses := object
%

category: 'accessing'
method: RowanBrowserService
newCachedSelectors
	^newCachedSelectors
%

category: 'accessing'
method: RowanBrowserService
newCachedSelectors: object
	newCachedSelectors := object
%

category: 'window registry'
method: RowanBrowserService
openWindows

	"for testing"

	^SessionTemps current at: #rowanServicesWindowRegistry ifAbsent:[]
%

category: 'client commands'
method: RowanBrowserService
packagesWithTests
  organizer := ClassOrganizer new.	"when we call this method, our world has changed from a reload, etc."
  testPackages := Set new.
  testCount := 0.
  testPackages := Set new.
  testCount := 0.
  (organizer allSubclassesOf: TestCase)
    do: [ :sub | 
      | packageName testMethodCount |
      testMethodCount := (sub sunitSelectors
        select: [ :each | each beginsWith: 'test' ]) size.	"sending #testSelectors was slower"
      testCount := testCount + testMethodCount.
      testMethodCount > 0
        ifTrue: [ 
          packageName := sub rowanPackageName.
          packageName = Rowan unpackagedName
            ifFalse: [ 
              testPackages
                add:
                  (RowanPackageService new
                    name: packageName;
                    updateProjectName;
                    yourself) ].
          (Rowan image loadedClassExtensionsForClass: sub)
            do: [ :loadedThing | 
              testPackages
                add:
                  (RowanPackageService new
                    name: loadedThing loadedPackage name;
                    updateProjectName;
                    yourself)	"don't update the entire package for performance improvement" ] ] ].
  updateType := #'testPackages:'.
  testPackages := testPackages asArray.
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
recompileMethodsAfterClassCompilation
  "compileClass: must be run first"

  | theClass classService packageService projectService |
  theClass := [ 
  [ (SessionTemps current at: #'jadeiteCompileClassMethod') _executeInContext: nil ]
    on: CompileWarning
    do: [ :ex | ex resume ] ]
    ensure: [ SessionTemps current at: #'jadeiteCompileClassMethod' put: nil ].
  classService := RowanClassService new name: theClass name.
  classService update.
  classService isNewClass: true.	"if nothing else, the dirty state of the package/project services
	should be updated. Would like a less heavy weight solution than this, though."
  packageService := RowanPackageService
    forPackageNamed: classService packageName.
  packageService update.
  projectService := RowanProjectService newNamed: packageService projectName.
  projectService update.
  packageService selectedClass: classService.
  RowanCommandResult addResult: classService.
  selectedClass := classService.
  updateType := #'none'.
  self updateSymbols: (Array with: theClass name asString).
  RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
releaseWindowHandle: integer
  | registry |
  Rowan loggingServiceClass current
    logComment: 'Release window with handle: ' , integer printString.
  registry := SessionTemps current
    at: #'rowanServicesWindowRegistry'
    ifAbsent: [ ^ self ].
  registry removeKey: integer ifAbsent: [  ]
%

category: 'client commands'
method: RowanBrowserService
reloadProjects: projectServices andUpdateServices: services
  | projectNames answeringService |
  services do: [ :service | service organizer: organizer ].
  projectServices do: [ :service | service organizer: organizer ].
  projectServices do: [ :projectService | projectService reloadProject ].
  projectNames := projectServices
    collect: [ :projectService | projectService name ].
  services
    do: [ :service | 
      (projectNames includes: service rowanProjectName)
        ifTrue: [ service updateLatest ] ].
  answeringService := RowanAnsweringService new organizer: organizer.
  answeringService updateAutocompleteSymbols
%

category: 'client commands'
method: RowanBrowserService
removeDictionariesNamed: dictionaryNames
	"remove from both transient & persistent symbol lists" 

	dictionaryNames do:[:dictionaryName | 
		| dictionaryNameSymbol |
		dictionaryNameSymbol := dictionaryName asSymbol.
		(Rowan image symbolList names includes: dictionaryNameSymbol) ifTrue:[
			Rowan image symbolList removeDictionaryNamed: dictionaryNameSymbol].
		(System myUserProfile symbolList names includes: dictionaryNameSymbol) ifTrue:[
			System myUserProfile symbolList removeDictionaryNamed: dictionaryNameSymbol]].
	self updateDictionaries.
%

category: 'client commands'
method: RowanBrowserService
removeMethods: methodServices

	| notRemoved |
	notRemoved := Array new. 
	removedMethods := Array new. 
	methodServices do: [:methodService |
		| classService |
		classService := RowanClassService forClassNamed: methodService className. 
		classService meta: methodService meta. 
		classService removeSelector: methodService selector ifAbsent:[notRemoved add: methodService].
		classService updatePackageProject.
		(notRemoved includes: methodService) ifFalse:[
			methodService updateType: #removed:.
			RowanCommandResult addResult: methodService]. 
		removedMethods add: methodService].
	notRemoved isEmpty ifFalse:[
		self error: 'These selectors were not removed - ', (notRemoved collect:[:ea | ea selector]) printString].
	updateType := #methodsRemoved:. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanBrowserService
saveRootObject: oop windowHandle: integer

	" a window has been opened on the client. Save the 
	root object of the window so it won't be recycled"
	| dictionary |
	dictionary := SessionTemps current at: #rowanServicesWindowRegistry ifAbsentPut: [Dictionary new].
	dictionary at: integer put: (Object _objectForOop: oop).
%

category: 'other'
method: RowanBrowserService
selectedClass

	^selectedClass
%

category: 'other'
method: RowanBrowserService
selectedClass: object

	selectedClass := object
%

category: 'perform'
method: RowanBrowserService
servicePerform: symbol withArguments: collection
	super perform: symbol withArguments: collection.
%

category: 'client commands'
method: RowanBrowserService
unloadProjectsNamed: array
  array
    do: [ :projectName | 
      | project |
      project := Rowan image loadedProjectNamed: projectName ifAbsent: [  ].
      project
        ifNotNil: [ Rowan projectTools delete deleteProjectNamed: projectName ] ].
  self updateProjects
%

category: 'update'
method: RowanBrowserService
update
	self updateProjects
%

category: 'client commands'
method: RowanBrowserService
updateDictionaries

	dictionaries := Rowan image symbolList names collect:[:name | RowanDictionaryService new name: name asString].
	dictionaries := dictionaries asOrderedCollection. 
	updateType ifNil: [updateType := OrderedCollection new]. 
	updateType add: #dictionaryListUpdate:.
	RowanCommandResult addResult: self
%

category: 'client commands'
method: RowanBrowserService
updateProjects
  | sortedProjects |
  self packagesWithTests. "make sure tests are always updated" 
  sortedProjects := SortedCollection sortBlock: [ :a :b | a name < b name ].
  sortedProjects addAll: Rowan image loadedProjects.
  projects := sortedProjects
    collect: [ :project | RowanProjectService newNamed: project name ].
  updateType := Array with: updateType with: #'projectsUpdate:browser:'. "temporary hack" 
  RowanCommandResult addResult: self
%

category: 'update'
method: RowanBrowserService
updateSymbols: classNames
  newCachedClasses addAll: classNames.
  updateType := #'addCachedSymbols:'
%

! Class implementation for 'RowanClassService'

!		Class methods for 'RowanClassService'

category: 'instance creation'
classmethod: RowanClassService
basicForClassNamed: className 
	"Don't get method services. Efficient for classes with many methods"
	^self new basicForClassNamed: className
%

category: 'instance creation'
classmethod: RowanClassService
forClassNamed: className 

	^self new forClassNamed: className
%

category: 'instance creation'
classmethod: RowanClassService
forClassNamed: className meta: aBoolean

	| inst |
	inst := self forClassNamed: className subStrings first.
	inst meta: aBoolean.
	^inst
%

category: 'instance creation'
classmethod: RowanClassService
forClassNamed: className package: packageName

	| inst |
	inst := self forClassNamed: className.
	inst packageName: packageName.
	^inst
%

category: 'instance creation'
classmethod: RowanClassService
minimalForClassNamed: className 
	"Don't get method services. Efficient for classes with many methods"
	^self new minimalForClassNamed: className
%

!		Instance methods for 'RowanClassService'

category: 'comparing'
method: RowanClassService
= classService
	(classService class canUnderstand: #isClassService) ifFalse:[^false].
	^classService isClassService
			ifTrue: [  name asString = classService name asString and: [meta = classService meta]]
			ifFalse: [^false]
%

category: 'client commands'
method: RowanClassService
addCategory: string

	| theClass |

	theClass := self theClass.
	meta ifTrue:[theClass := theClass class]. 
	theClass addCategory: string.
%

category: 'constants'
method: RowanClassService
addSubclassWarningString

	^'Superclass is not packaged. Enter the desired package name'
%

category: 'client commands'
method: RowanClassService
allSubclassServices
  | subclassServices |
  subclassServices := self theClass subclasses asArray
    collect: [ :aClass | RowanClassService minimalForClassNamed: aClass name ].
  hierarchyServices := Dictionary new.
  hierarchyServices at: #'expand' put: subclassServices.
  (hierarchyServices at: #'expand')
    do: [ :classService | classService allSubclassServices ]
%

category: 'Accessing'
method: RowanClassService
allTests
	| allSelectors theClass |
	self isTestCase ifFalse:[^Array new]. 
	theClass := self theClass thisClass.
	theClass isAbstract ifTrue:[^Array new].
	allSelectors := self theClass thisClass allTestSelectors.
	^allSelectors collect:[:selector | 
			RowanMethodService forSelector: selector 
										class: (theClass whichClassIncludesSelector: selector asString)
										meta: false
										organizer: organizer].
%

category: 'testing'
method: RowanClassService
arePackageAndProjectClean

	^self packageIsDirty not and:[self projectIsDirty not]
%

category: 'initialization'
method: RowanClassService
basicForClassNamed: className 

	| theClass |
	self name: className. 
	theClass := self theClass. 
	theClass isNil ifTrue:[oop := nil. ^self].
	self basicRefreshFrom: theClass.
%

category: 'initialization'
method: RowanClassService
basicRefreshFrom: theClass
	| classOrMeta theFilters |
	oop := theClass asOop.
	command := nil. 
	commandArgs := nil. 
	superclassName := theClass superClass ifNotNil:[:theSuper | theSuper name asString]. 
	comment := theClass rwComment. 
	organizer ifNil: [organizer := ClassOrganizer new]. "for Jade and tests"
	versions := theClass classHistory size.
	version := theClass classHistory indexOf: theClass.
	self setComment.
	template := self classCreationTemplate.
	theFilters := SortedCollection new.
	classOrMeta := meta == true ifTrue:[theClass class] ifFalse:[theClass].
	self initializeVariablesFor: classOrMeta. 
	self initializeCategoriesFor: classOrMeta.
	packageName := definedPackageName := classOrMeta rowanPackageName.
	self setDictionary: classOrMeta.
	projectName := classOrMeta rowanProjectName.
	instVarNames := classOrMeta instVarNames asArray. 
	self setIsTestCase.
%

category: 'Accessing'
method: RowanClassService
behavior

	| behavior |
	behavior := self theClass. 
	meta == true ifTrue:[behavior := behavior class].
	^behavior
%

category: 'client commands'
method: RowanClassService
classComment: string
	| theClass |
	theClass := self theClass. 
	theClass rwComment: string.
%

category: 'rowan'
method: RowanClassService
classCreationTemplate
	
	^self browserTool classCreationTemplateForClass: self theClass hybridBrowser: true.
%

category: 'client commands'
method: RowanClassService
classHierarchy
	hierarchyServices := self classHierarchy: (Array with: self theClass). 
	RowanCommandResult addResult: self.
%

category: 'Accessing'
method: RowanClassService
classHierarchyNames

	| names |
	names := Array new. 
	hierarchyServices keys do:[:classService | 
		classService == #nil ifFalse:[names add: classService name]].
	^names
%

category: 'Accessing'
method: RowanClassService
classInstVarNames
	^classInstVarNames
%

category: 'Updating'
method: RowanClassService
classInstVarNames: newValue
	classInstVarNames := newValue
%

category: 'Accessing'
method: RowanClassService
classOrMeta

	^meta 
			ifTrue:[self theClass class] 
			ifFalse: [self theClass].
%

category: 'instance creation'
method: RowanClassService
classServiceFromOop: anOop
	| theClass className classService |
	theClass := Object _objectForOop: anOop. 
	className := theClass name. 
	classService := RowanClassService new name: className.
	^className asString = name asString ifTrue:[
			className asString = 'Object' 
				ifTrue:[
					classService basicRefreshFrom: theClass]
				ifFalse:[
					classService fastRefresh]]
		ifFalse:[
			classService minimalRefreshFrom: theClass]
%

category: 'Accessing'
method: RowanClassService
classType
	^classType
%

category: 'Updating'
method: RowanClassService
classType: newValue
	classType := newValue
%

category: 'Accessing'
method: RowanClassService
classVarNames
	^classVarNames
%

category: 'Updating'
method: RowanClassService
classVarNames: newValue
	classVarNames := newValue
%

category: 'Accessing'
method: RowanClassService
comment
	^comment
%

category: 'Updating'
method: RowanClassService
comment: newValue
	comment := newValue
%

category: 'constants'
method: RowanClassService
compileMethod: methodString behavior: aBehavior symbolList: aSymbolList inCategory: categorySymbol
	"returns (nil -> anArrayOfErrors) or (aGsNMethod -> compilerWarnings) or (aGsNMethod -> nil)"

	| method warnings |
	
	[ [ [ [ method := aBehavior rwCompileMethod: methodString category: categorySymbol.]
		on: RwExecuteClassInitializeMethodsAfterLoadNotification
		do: [:ex | ex resume: false ]]
			on: CompileError
			do: [:ex | ^nil -> (ex gsArguments at: 1)]]
				on: CompileWarning
				do: 
					[:ex | 
					warnings := ex warningString.
					ex resume]]
					on: RwPerformingUnpackagedEditNotification
					do: [:ex | ex resume ] .
	^[(self compiledMethodAt: method key selector inClass: aBehavior) -> warnings] on: Error
		do: [:ex | ex return: method -> warnings]
%

category: 'client commands'
method: RowanClassService
copyClassTo: newClassName
  | newTemplate newClass newClassService index |
  (Rowan image symbolList resolveSymbol: newClassName)
    ifNotNil: [ ^ self inform: newClassName , ' already exists' ].
  index := template findPattern: (Array with: name) startingAt: 1.
  newTemplate := template copy.
  newTemplate removeFrom: index to: index + name size - 1.
  newTemplate insertAll: newClassName at: index.
  newClass := GsCurrentSession currentSession execute: newTemplate.
  newClassService := RowanClassService new name: newClassName.
  self theClass thisClass
    methodsDo: [ :selector :gsMethod | 
      newClassService
        compileMethod: gsMethod sourceString
        behavior: newClass
        symbolList: Rowan image symbolList
        inCategory:
          (self theClass thisClass categoryOfSelector: selector) asSymbol ].
  self theClass thisClass class
    methodsDo: [ :selector :gsMethod | 
      newClassService
        compileMethod: gsMethod sourceString
        behavior: newClass class
        symbolList: Rowan image symbolList
        inCategory:
          (self theClass thisClass class categoryOfSelector: selector) asSymbol ].
  newClassService update.
  (RowanPackageService new name: newClassService packageName) update.
  (RowanDictionaryService new name: dictionaryName) update
%

category: 'Updating'
method: RowanClassService
definedPackageName: newValue

	definedPackageName := newValue
%

category: 'Updating'
method: RowanClassService
expand: boolean

	expand := boolean
%

category: 'client commands'
method: RowanClassService
fastRefresh
	"pushes less information to ston so it's faster"

	| theClass |
	theClass := self theClass. 
	self refreshFrom: theClass. 
	methods do:[:service1 |
			service1 source: nil;
				stepPoints: Array new].
	visibleTests do:[:service2 |
			service2 source: nil;
				stepPoints: Array new.
			].
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanClassService
fileoutCategories: array
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	array do:[:category |
		self behavior fileOutCategory: category on: ws]. 
	answeringService answer: ws contents. 
	RowanCommandResult addResult: answeringService.
%

category: 'client commands'
method: RowanClassService
fileoutClass
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	ws nextPutAll: self behavior fileOutClass. 
	answeringService answer: ws contents. 
	RowanCommandResult addResult: answeringService.
%

category: 'client commands'
method: RowanClassService
fileoutMethods: array
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	array do:[:methodService |
		self behavior fileOutMethod: methodService selector on: ws]. 
	answeringService answer: ws contents. 
	RowanCommandResult addResult: answeringService.
%

category: 'Accessing'
method: RowanClassService
filters
	^filters
%

category: 'Updating'
method: RowanClassService
filters: newValue
	filters := newValue
%

category: 'initialization'
method: RowanClassService
forClassNamed: className 

	| theClass |
	self name: className. 
	theClass := self theClass. 
	self refreshFrom: theClass.
%

category: 'client commands'
method: RowanClassService
fullHierarchy
  | behavior sortedSubclasses |
  behavior := self theClass.
  hierarchyServices := Dictionary new.
  hierarchyServices at: #'expand' put: Array new.
  sortedSubclasses := behavior subclasses
    asSortedCollection: [ :x :y | x name < y name ].
  RowanCommandResult addResult: self.
  sortedSubclasses
    do: [ :subclass | 
      | classService |
      classService := (self classServiceFromOop: subclass asOop) meta: meta.
      (hierarchyServices at: #'expand') add: classService.
      classService allSubclassServices ]
%

category: 'comparing'
method: RowanClassService
hash
	^self name hash bitXor: meta hash
%

category: 'Accessing'
method: RowanClassService
hierarchyServices

	^hierarchyServices
%

category: 'initialization'
method: RowanClassService
initialize

	isExtension := false.
	selectedMethods := Array new.
	meta := false. "assume most of our work is on the instance side"
	selectedPackageServices := Array new.
	isNewClass := false.
	methods := Array new.
	isInSymbolList := true.
	categories := Array new.
%

category: 'initialization'
method: RowanClassService
initializeCategoriesFor: classOrMeta

	| theFilters |
	theFilters := SortedCollection new.
	classOrMeta env: 0 categorysDo: [:category :selector | theFilters add: category asString].
	categories := theFilters asOrderedCollection.
%

category: 'initialization'
method: RowanClassService
initializeTestMethodsFor: aClass
	| testSelectors |
	(aClass inheritsFrom: TestCase) ifTrue:[
		aClass isAbstract ifTrue:[^self]. 
		testSelectors := aClass thisClass suite tests collect:[:method | method selector]. 
		methods do:[:methodService | 
			methodService isTestMethod: (testSelectors includes: methodService selector)]].
%

category: 'initialization'
method: RowanClassService
initializeVariablesFor: classOrMeta

	| theFilters |
	theFilters := SortedCollection new.
	theFilters addAll: (classOrMeta allInstVarNames collect:[:instVar | instVar asString]).
	variables := theFilters asOrderedCollection.
%

category: 'Accessing'
method: RowanClassService
instVarNames
	^instVarNames
%

category: 'Updating'
method: RowanClassService
instVarNames: newValue
	instVarNames := newValue
%

category: 'testing'
method: RowanClassService
isClassService

	^true
%

category: 'Updating'
method: RowanClassService
isExtension: boolean

	isExtension := boolean
%

category: 'Updating'
method: RowanClassService
isNewClass: boolean
	isNewClass := boolean
%

category: 'Updating'
method: RowanClassService
isTestCase

	^isTestCase
%

category: 'Updating'
method: RowanClassService
isTestCase: aBoolean

	isTestCase := aBoolean
%

category: 'Accessing'
method: RowanClassService
meta

	^meta
%

category: 'Updating'
method: RowanClassService
meta: anObject

	meta := anObject
%

category: 'Accessing'
method: RowanClassService
methods

	"for testing"
	^methods
%

category: 'private'
method: RowanClassService
methodServiceFrom: gsNMethod in: behavior compiltationResult: compilationResult
	| methodService |

	methodService := RowanMethodService forGsNMethod: gsNMethod organizer: organizer. 
	methodService compilationWarnings: compilationResult value.
	^methodService
%

category: 'private'
method: RowanClassService
methodServicesFor: classOrMeta organizer: theOrganizer

	methods addAll: (classOrMeta selectors collect:[:sel | 
			RowanMethodService 
				forSelector: sel class: classOrMeta thisClass meta: meta organizer: theOrganizer])
%

category: 'private'
method: RowanClassService
methodsIn: theClass categories: theCategories

	| selectors |
	selectors := Array new. 
	theCategories do:[:category |
		selectors addAll: (theClass selectorsIn: category)]. 
	^methods select:[:methodService | selectors includes: methodService selector]
%

category: 'testing'
method: RowanClassService
methodsNamed: selector
	"For testing. Multiple because class could have both instance and class methods"

	^methods select:[:methodService | methodService selector = selector]
%

category: 'initialization'
method: RowanClassService
minimalForClassNamed: className 

	| theClass |
	self name: className. 
	theClass := self theClass. 
	self minimalRefreshFrom: theClass.
%

category: 'initialization'
method: RowanClassService
minimalRefreshFrom: theClass
	| classOrMeta  |
	command := nil. 
	commandArgs := nil. 
	versions := theClass classHistory size.
	version := theClass classHistory indexOf: theClass.
	oop := theClass asOop.
	classOrMeta := meta == true ifTrue:[theClass class] ifFalse:[theClass].
	packageName := definedPackageName := classOrMeta rowanPackageName.
	self setDictionary: classOrMeta.
	projectName := classOrMeta rowanProjectName.
	instVarNames := classOrMeta instVarNames asArray. 
	template := self classCreationTemplate.
	self initializeVariablesFor: classOrMeta. 
	self initializeCategoriesFor: classOrMeta.
	self setIsTestCase.
%

category: 'client commands'
method: RowanClassService
moveMethods: methodServices to: category
	| behavior |
	behavior := self classOrMeta.
	methodServices do: [:methodService | 
			behavior rwMoveMethod: methodService selector toCategory: category.
			methodService category: category].
	self update. 
	self selectedMethods: methodServices.
%

category: 'Accessing'
method: RowanClassService
name
	^name
%

category: 'Updating'
method: RowanClassService
name: newValue
	name := newValue asString
%

category: 'private'
method: RowanClassService
objectInBaseNamed: aString

	^Rowan image symbolList objectNamed: aString asSymbol
%

category: 'client commands'
method: RowanClassService
oneLevelClassHierarchy
  "good for expanding an existing hierarchy quickly"

  | behavior sortedSubclasses |
  behavior := self theClass.
  hierarchyServices := Dictionary new.
  hierarchyServices at: #'expand' put: Array new.
  sortedSubclasses := behavior subclasses
    asSortedCollection: [ :x :y | x name < y name ].
  sortedSubclasses
    do: [ :subclass | 
      | classService |
      classService := (self classServiceFromOop: subclass asOop) meta: meta.
      (hierarchyServices at: #'expand') add: classService ].
  RowanCommandResult addResult: self
%

category: 'Accessing'
method: RowanClassService
oop
	^oop
%

category: 'Updating'
method: RowanClassService
oop: newValue
	oop := newValue
%

category: 'testing'
method: RowanClassService
packageIsDirty

	| behavior |
	behavior := self theClass.
	behavior rowanPackageName =  Rowan unpackagedName ifTrue:[^true]. "avoid a refresh by assuming it's dirty" 
	^(RowanPackageService new name: behavior rowanPackageName) rowanDirty
%

category: 'Accessing'
method: RowanClassService
packageName
	
	^packageName
%

category: 'Updating'
method: RowanClassService
packageName: pkgName
	
	packageName := pkgName
%

category: 'Accessing'
method: RowanClassService
poolDictionaryNames
	^poolDictionaryNames
%

category: 'Updating'
method: RowanClassService
poolDictionaryNames: newValue
	poolDictionaryNames := newValue
%

category: 'printing'
method: RowanClassService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $:. 
	aStream nextPutAll: (name ifNil: [nil printString])
%

category: 'testing'
method: RowanClassService
projectIsDirty

	| behavior |
	behavior := self theClass.
	behavior rowanProjectName =  Rowan unpackagedName ifTrue:[^true]. "avoid a refresh by assuming it's dirty" 
	^(RowanProjectService new name: behavior rowanProjectName) rowanDirty
%

category: 'other'
method: RowanClassService
projectName

	^projectName
%

category: 'Updating'
method: RowanClassService
projectName: newValue
	projectName := newValue
%

category: 'initialization'
method: RowanClassService
refreshFrom: theClass
	| classOrMeta  |
	self basicRefreshFrom: theClass. 
	classOrMeta := meta == true ifTrue:[theClass class] ifFalse:[theClass].
	self refreshMethodsFor: classOrMeta
%

category: 'initialization'
method: RowanClassService
refreshMethodsFor: classOrMeta
	| gsNMethods |
	methods := SortedCollection sortBlock: [:x :y | x selector < y selector].
	self methodServicesFor: classOrMeta organizer: organizer.
	methods := methods asOrderedCollection.
	classOrMeta allInstVarNames do:[:instVar | 
			gsNMethods := organizer accessorsOf: instVar inClass: classOrMeta.
			gsNMethods do:[:gsNMethod |
				| service |
				service := methods detect:[:methodService | methodService selector = gsNMethod selector] ifNone:[].
				service ifNotNil:[
					service accessedInstVars add: instVar asString]
	]].
	self initializeTestMethodsFor: classOrMeta thisClass. 
	self setVisibleTests. "methods must be available"
%

category: 'client commands'
method: RowanClassService
removeCategories: theCategories
	| theClass  | 
	self refreshFrom: self theClass. 
	theClass := self theClass.
	meta ifTrue:[theClass := theClass class]. 
	theCategories do: [:category |
		theClass rwRemoveCategory: category.
		].
%

category: 'client commands'
method: RowanClassService
removeMethods: methodsToRemove

	| notRemoved |
	notRemoved := Array new. 
	methodsToRemove do: [:methodService |
		self removeSelector: methodService selector ifAbsent:[notRemoved add: methodService].
		(notRemoved includes: methodService) ifFalse:[
			methodService updateType: #removed:.
			RowanCommandResult addResult: methodService.
		]].
	self updateTests.
	notRemoved isEmpty ifFalse:[
		self error: 'These selectors were not removed - ', (notRemoved collect:[:svc | svc selector]) printString].
%

category: 'rowan'
method: RowanClassService
removeSelector: selector

	self browserTool removeMethod: selector forClassNamed: name asString isMeta: meta
%

category: 'rowan'
method: RowanClassService
removeSelector: selector ifAbsent: absentBlock
	| theClass |
	theClass := self theClass. 
	meta ifTrue: [theClass := theClass class].
	(theClass compiledMethodAt: selector otherwise: nil) isNil ifTrue:[ ^absentBlock value ].
	[self browserTool removeMethod: selector forClassNamed: name asString isMeta: meta]
		on: RwPerformingUnpackagedEditNotification
		do: [:ex | ex resume ]
%

category: 'client commands'
method: RowanClassService
renameCategoryFrom: old to: new

	| affectedSelectors behavior |

	self update. 
	self addCategory: new. 
	behavior := self classOrMeta.
	affectedSelectors := behavior selectorsIn: old.
	methods := methods select:[:methodService | affectedSelectors includes: methodService selector].
	self moveMethods: methods to: new.
	self removeCategories: (Array with: old)
%

category: 'client commands'
method: RowanClassService
renameClass: oldClassName to: newClassName
  | references newMethods newClass oldClass |
  newMethods := Array new.
  oldClass := Rowan image resolveClassNamed: oldClassName.
  newClass := Rowan projectTools browser
    renameClassNamed: oldClassName
    to: newClassName.
  oop := newClass asOop.
  name := newClassName.
  self update.
  renamedName := oldClassName.
  self updateMethodsAfterRenameFrom: oldClassName to: newClassName.
  self updateSubclassesAfterRenameOf: newClass.
  references := organizer update referencesToObject: oldClass.
  references do: [ :method | 
    | newSource compileResult failedCompile methodService oldSource |
    failedCompile := false.
    oldSource := method sourceString.
    newSource := self
      replaceSubString: oldClassName
      in: oldSource
      with: newClassName.
    compileResult := [ 
    method inClass
      rwCompileMethod: newSource
      category: (method inClass categoryOfSelector: method selector) asSymbol ]
      on: CompileError
      do: [ :ex | 
        failedCompile := true.
        method ].
    methodService := RowanMethodService
      forGsNMethod: compileResult
      organizer: organizer.
    failedCompile
      ifTrue: [ methodService comparisonSource: oldClassName ]
      ifFalse: [ methodService comparisonSource: oldSource ].
    methodService failedCompile: failedCompile.
    methodService renamedName: oldClassName.
    newMethods add: methodService ].
  RowanCommandResult addResult: (RowanAnsweringService new answer: newMethods)
%

category: 'private'
method: RowanClassService
replaceSubString: old in: string with: new
	| offset newSource |
	newSource := string. 
	offset := 1. 	
	[(offset := newSource findString: old startingAt: offset) = 0] whileFalse:[
		newSource := newSource copyReplaceFrom: offset to: offset + old size - 1 with: new. 
		offset := offset + new size. 
	].
	^newSource
%

category: 'rowan'
method: RowanClassService
rowanProjectName

	^projectName
%

category: 'client commands'
method: RowanClassService
runClassTests: classService

	"if it errors, the client will handle the error. 
	If it passes, we return true and the client
	will display decent results." 
	| behavior |
	behavior := classService theClass. 
	self refreshFrom: behavior.
	self tests do:[:methodService |
			behavior debug: methodService selector]. 
	RowanCommandResult addResult: (RowanAnsweringService new answer: true).
%

category: 'client commands'
method: RowanClassService
runMethodTests: methodServices

	| behavior |
	behavior := self theClass.  
	methodServices do:[:methodService |
		(methodService selector asString matchPattern: #('test' $*)) ifTrue:[ 
			behavior debug: methodService selector]].
	RowanCommandResult addResult: (RowanAnsweringService new answer: true).
%

category: 'client commands'
method: RowanClassService
saveMethodSource: source category: category
  | behavior compilationResult gsNMethod updatedCategory methodService |
  meta
    ifNil: [ 
      behavior := Object _objectForOop: oop.
      meta := behavior isMeta ]
    ifNotNil: [ 
      behavior := meta
        ifTrue: [ self theClass class ]
        ifFalse: [ self theClass ] ].
  updatedCategory := category ifNil: [ 'other' ].
  compilationResult := self
    compileMethod: source
    behavior: behavior
    symbolList: Rowan image symbolList
    inCategory: updatedCategory asSymbol.
  (gsNMethod := compilationResult key) isNil
    ifTrue: [ 
      System
        signal: 1001
        args: (Array with: compilationResult value)
        signalDictionary: GemStoneError ].
  self update.
  methodService := self
    methodServiceFrom: gsNMethod
    in: behavior
    compiltationResult: compilationResult.
  RowanCommandResult addResult: methodService.
  RowanQueryService new
    organizer: ClassOrganizer new;
    hierarchyImplementorsOf: methodService selector
      inClass: methodService className.	"this will update hierarchy method indicators for client"
  self selectedMethods: (Array with: methodService).
  self updateDirtyState.
  self updateTests.
  self updateSymbols: gsNMethod _selectorPool asArray , (Array with: methodService selector)
%

category: 'other'
method: RowanClassService
selectedMethods
	"client side selection. Used after a method compile" 
	^selectedMethods
%

category: 'Updating'
method: RowanClassService
selectedMethods: theMethods
	selectedMethods := theMethods
%

category: 'Accessing'
method: RowanClassService
selectedPackageServices
	^selectedPackageServices
%

category: 'Updating'
method: RowanClassService
selectedPackageServices: newValue
	selectedPackageServices := newValue
%

category: 'Accessing'
method: RowanClassService
selectors

	^methods collect:[:methodService | methodService selector]
%

category: 'perform'
method: RowanClassService
servicePerform: symbol withArguments: collection
  | wasClean |
  self isUpdatingButFoundToBeDeleted
    ifTrue: [ ^ self handleDeletedService ].
  wasClean := self arePackageAndProjectClean.
  super servicePerform: symbol withArguments: collection.
  updateAfterCommand == false
    ifFalse: [ self update ].
  wasClean
    ifTrue: [ self updatePackageProject ]
%

category: 'Accessing'
method: RowanClassService
setComment
  comment := self theClass thisClass rwComment
%

category: 'private'
method: RowanClassService
setDictionary: classOrMeta
	| dictionaryList |
		dictionaryList := Rowan image symbolList dictionariesAndSymbolsOf: classOrMeta thisClass.
		dictionaryName := dictionaryList isEmpty 
		ifTrue:[String new]
		ifFalse:[dictionaryList first first name asString].
%

category: 'Updating'
method: RowanClassService
setIsTestCase

	isTestCase := self theClass isSubclassOf: TestCase
%

category: 'client commands'
method: RowanClassService
setIsTestCaseCommand

	self setIsTestCase.
%

category: 'client commands'
method: RowanClassService
setVisibleTests
	visibleTests := SortedCollection sortBlock: [:x :y | x selector < y selector]. 
	visibleTests addAll: self allTests.
	visibleTests := visibleTests asArray.
%

category: 'client commands'
method: RowanClassService
subclassCreationTemplate
  | answerService newClassPackageName |
  answerService := RowanAnsweringService new.
  newClassPackageName := self theClass rowanPackageName = Rowan unpackagedName
    ifTrue: [ self addSubclassWarningString ]
    ifFalse: [ self theClass rowanPackageName ].
  answerService
    answer:
      (self browserTool
        classCreationTemplateForSubclassOf: name
        className: 'NewSubclass'
        category: newClassPackageName).
  RowanCommandResult addResult: answerService
%

category: 'private'
method: RowanClassService
subclassServices: subclasses

	| sortedSubclasses |

	sortedSubclasses := SortedCollection sortBlock: [:x :y | x name < y name]. 
	sortedSubclasses addAll: subclasses. 
	^(sortedSubclasses collect:[:cls | (self classServiceFromOop: cls asOop) meta: meta]) asArray.
%

category: 'Accessing'
method: RowanClassService
subclassType
	^subclassType
%

category: 'Updating'
method: RowanClassService
subclassType: newValue
	subclassType := newValue
%

category: 'Accessing'
method: RowanClassService
superclassName
	^superclassName
%

category: 'Updating'
method: RowanClassService
superclassName: newValue
	superclassName := newValue
%

category: 'Accessing'
method: RowanClassService
template
	^template
%

category: 'Updating'
method: RowanClassService
template: newValue
	template := newValue
%

category: 'private'
method: RowanClassService
tests

	^methods select:[:methodService | methodService selector asString matchPattern: #('test' $*)]
%

category: 'instance creation'
method: RowanClassService
theClass
	| theClass |
	theClass := oop ifNil:[Rowan globalNamed: name] ifNotNil: [Object _objectForOop: oop].
	theClass isMeta ifTrue:[oop := theClass thisClass asOop]. 
	(Rowan globalNamed: name) ifNil:[isInSymbolList := false]. 
	theClass ifNil: [^nil]. 
	^theClass thisClass
%

category: 'updates'
method: RowanClassService
update

	self updateClass.
%

category: 'updates'
method: RowanClassService
updateClass

	"It's possible to have a nil class. For example, if we added & selected
	a class then aborted."

	| theClass |
	theClass := self theClass. 
	theClass isNil ifTrue:[oop := nil. ^self]. 
	theClass isBehavior ifFalse:[oop := theClass asOop. ^self].
	self refreshFrom: theClass.
	RowanCommandResult addResult: self
%

category: 'updates'
method: RowanClassService
updateDirtyState
	| projectService | 
	selectedPackageServices do:[:packageService | 
		packageService update. 
		RowanCommandResult addResult: packageService].
	projectService := RowanProjectService newNamed: self theClass rowanProjectName. 
	RowanCommandResult addResult: projectService.
%

category: 'updates'
method: RowanClassService
updateLatest
  oop := ((Rowan image symbolList resolveSymbol: name)
    ifNil: [ 
      wasRemoved := true.
      updateType := #'removedClass:'.
      RowanCommandResult addResult: self.
      ^ self ]) value asOop.
  super updateLatest
%

category: 'private'
method: RowanClassService
updateMethodsAfterRenameFrom: oldClassName to: newClassName
  methods
    do: [ :methodService | 
      methodService
        renamedName: oldClassName;
        className: newClassName. 
      RowanCommandResult addResult: methodService ]
%

category: 'updates'
method: RowanClassService
updatePackageProject
	| packageService projectService |

	packageService := RowanPackageService new name: packageName. 
	packageService update. 
	projectService := RowanProjectService new name: projectName. 
	projectService update.
%

category: 'private'
method: RowanClassService
updateSubclassesAfterRenameOf: newClass
  organizer := ClassOrganizer new.
  (organizer allSubclassesOf: newClass)
    do: [ :subclass | 
      | subclassService |
      subclassService := RowanClassService minimalForClassNamed: subclass name.
      RowanCommandResult addResult: subclassService ]
%

category: 'updates'
method: RowanClassService
updateSymbols: newSymbols
  | browserService |
  browserService := RowanBrowserService new.
  browserService newCachedSelectors addAll: newSymbols.
  browserService updateType: #'addCachedSymbols:'. 
  RowanCommandResult addResult: browserService
%

category: 'updates'
method: RowanClassService
updateTests
  "update the test browsers on certain operations"

  RowanBrowserService new packagesWithTests.
  (RowanPackageService new
    name: packageName;
    yourself) testClasses.
  RowanCommandResult addResult: self update
%

category: 'Accessing'
method: RowanClassService
version
	^version
%

category: 'Updating'
method: RowanClassService
version: newValue
	version := newValue
%

category: 'Accessing'
method: RowanClassService
versions
	^versions
%

category: 'Updating'
method: RowanClassService
versions: newValue
	versions := newValue
%

category: 'Accessing'
method: RowanClassService
visibleTests

	^visibleTests
%

category: 'testing'
method: RowanClassService
wasDeleted
	^(Rowan globalNamed: name) isNil
%

category: 'Accessing'
method: RowanClassService
wasRemoved: boolean

	wasRemoved := boolean
%

! Class implementation for 'RowanDebuggerService'

!		Instance methods for 'RowanDebuggerService'

category: 'debug string'
method: RowanDebuggerService
debugStringFrom: aString
  | debugStream newStream char peekChar |
  debugStream := ReadStream on: aString trimLeadingBlanks.
  [ 
  peekChar := debugStream peek.
  peekChar = Character tab
    or: [ peekChar = Character cr or: [ peekChar = Character lf ] ]	"trimLeadingBlanks doesn't look for tab or cr or lf" ]
    whileTrue: [ debugStream next ].
  debugStream contents isEmpty
    ifTrue: [ ^ 'nil halt.' ].
  newStream := WriteStream on: String new.
  (char := debugStream next) = $|
    ifTrue: [ 
      newStream nextPut: char.
      newStream
        nextPutAll: (debugStream upTo: $|);
        nextPut: $|;
        nextPut: Character space;
        nextPutAll: 'nil halt. ' ]
    ifFalse: [ 
      newStream
        nextPutAll: 'nil halt. ';
        nextPut: char ].
  newStream nextPutAll: debugStream upToEnd.
  ^ newStream contents
%

category: 'perform'
method: RowanDebuggerService
servicePerform: symbol withArguments: collection
	^self perform: symbol withArguments: collection.
%

category: 'other'
method: RowanDebuggerService
update
  processes := OrderedCollection
    with:
      (RowanProcessService onActiveProcess: (Object _objectForOop: initialProcessOop)).
  ProcessorScheduler scheduler readyProcesses
    do: [ :each | processes add: (RowanProcessService onReadyProcess: each) ].
  ProcessorScheduler scheduler suspendedProcesses
    do: [ :each | processes add: (RowanProcessService onSuspendedProcess: each) ].
  ProcessorScheduler scheduler waitingProcesses
    do: [ :each | processes add: (RowanProcessService onWaitingProcess: each) ].
  RowanCommandResult addResult: self
%

! Class implementation for 'RowanDictionaryService'

!		Instance methods for 'RowanDictionaryService'

category: 'client commands'
method: RowanDictionaryService
classHierarchy
	| theClasses |
	self update. 
	theClasses := classes collect:[:classService | classService theClass].
	"reuse behavior in package service for now" 
	hierarchyServices := (RowanPackageService new classes: classes) classHierarchy: theClasses. 
	RowanCommandResult addResult: self.
%

category: 'Updating'
method: RowanDictionaryService
defaultTemplate: newValue
	defaultTemplate := newValue
%

category: 'command support'
method: RowanDictionaryService
genericClassCreationTemplate

	^self browserTool classCreationTemplateForSubclassOf: 'Object' category: nil packageName: nil
%

category: 'initialization'
method: RowanDictionaryService
initialize

	self setDefaultTemplate
%

category: 'client commands'
method: RowanDictionaryService
insertAt: index

	| theDictionary |
	theDictionary := SymbolDictionary new. 
	theDictionary at: name asSymbol put: theDictionary. 
	System myUserProfile insertDictionary: theDictionary at: index. 
	RowanBrowserService new updateDictionaries.
%

category: 'testing'
method: RowanDictionaryService
isDictionaryService
  ^ true
%

category: 'accessing'
method: RowanDictionaryService
name
	^name
%

category: 'accessing'
method: RowanDictionaryService
name: object
	name := object
%

category: 'client commands'
method: RowanDictionaryService
removeClass: classService
	self removeClassNamed: classService name. 
	self setDefaultTemplate.
	classService updateType: #removedClass:.
	RowanCommandResult addResult: classService
%

category: 'client commands'
method: RowanDictionaryService
removeClassNamed: className

	self browserTool removeClassNamed: className.
%

category: 'client commands'
method: RowanDictionaryService
removeGlobalNamed: symbol
	| dictionary |
	dictionary := (System myUserProfile resolveSymbol: name asSymbol) value.
	dictionary ifNotNil: [
		dictionary removeKey: symbol ifAbsent:[]].
	self update.
%

category: 'perform'
method: RowanDictionaryService
servicePerform: symbol withArguments: collection
  self isUpdatingButFoundToBeDeleted
    ifTrue: [ ^ self handleDeletedService ].
  super servicePerform: symbol withArguments: collection.
  self update
%

category: 'client commands'
method: RowanDictionaryService
setDefaultTemplate

	defaultTemplate := self genericClassCreationTemplate.
%

category: 'updates'
method: RowanDictionaryService
update
  | dictionary sorted |
  classes := Array new.
  sorted := SortedCollection sortBlock: [ :x :y | x first < y first ].
  dictionary := Rowan image symbolList objectNamed: name.
  dictionary ifNil: [ ^ self ].
  dictionary
    keysAndValuesDo: [ :key :value | 
      value isClass
        ifTrue: [ 
          | classService |
          classService := RowanClassService new name: key asString.
          classService versions: value classHistory size.
          classService version: (value classHistory indexOf: value).
          classes add: classService ]
        ifFalse: [ 
          | printString theKey |
          printString := [ 
          value printString charSize > 1
            ifTrue: [ '<<unprintable string. charSize > 1>>' ]
            ifFalse: [ value printString ] ]
            on: Error
            do: [ :ex | 'unprintable string. Error - <' , ex printString , '>' ].
          key charSize = 1
            ifTrue: [ theKey := key ]
            ifFalse: [ theKey := '<<unprintable string. charSize > 1>>' ].
          sorted
            add:
              (Array
                with: name , '.' , theKey
                with: value class name
                with: value asOop
                with: printString) ] ].
  globals := sorted asArray.
  RowanCommandResult addResult: self
%

category: 'testing'
method: RowanDictionaryService
wasDeleted
  ^ (Rowan globalNamed: name) isNil
%

! Class implementation for 'RowanFrameService'

!		Class methods for 'RowanFrameService'

category: 'other'
classmethod: RowanFrameService
process: aGsProcess level: anInteger organizer: aClassOrganizer

	^self basicNew
		initializeProcess: aGsProcess level: anInteger organizer: aClassOrganizer;
		yourself
%

!		Instance methods for 'RowanFrameService'

category: 'other'
method: RowanFrameService
initializeProcess: aGsProcess level: anInteger organizer: aClassOrganizer
  "In 3.2.15 the server does some whacky things with IP, stepPoint, and nested methods.
	See http://kermit.gemtalksystems.com/bug?bug=45553 --JGF"

  | frameData gsNMethod homeMethodService |
  frameData := aGsProcess _frameContentsAt: anInteger.
  frameData isNil
    ifTrue: [^self "not sure if bad frame data is a 3.2.15 bug or not"].
  oop := (frameData at: 8) asOop.
  gsNMethod := frameData at: 1.
  label := aGsProcess _reportAt: anInteger.
  method := RowanMethodService
    forGsNMethod: gsNMethod
    organizer: aClassOrganizer.
  homeMethodService := RowanMethodService
    forGsNMethod: gsNMethod homeMethod
    organizer: aClassOrganizer.
  method breakPoints: homeMethodService breakPoints.
  homeMethodSelector := gsNMethod homeMethod selector.
  homeMethodClassName := gsNMethod homeMethod inClass
    ifNotNil: [ :cls | cls name asString ].
  stepPoint := gsNMethod == gsNMethod homeMethod
    ifTrue: [ aGsProcess _stepPointAt: anInteger ]
    ifFalse: [ gsNMethod homeMethod _stepPointForMeth: gsNMethod ip: (frameData at: 2) ].
  vars := self varsFor: frameData
%

category: 'perform'
method: RowanFrameService
servicePerform: symbol withArguments: collection
	^self perform: symbol withArguments: collection.
%

category: 'other'
method: RowanFrameService
varsFor: anArray

	| keys list receiver values |
	receiver := anArray at: 10.
	values := OrderedCollection new.
	(Reflection classOf: receiver) name == #'ClientForwarder' ifTrue: [
		keys := OrderedCollection with: 'clientObject'.
		values add: receiver clientObject.
		receiver := '[aClientForwarder(' , (self oopOf: receiver) printString , ')]'.
	] ifFalse: [
		((receiver isKindOf: BlockClosure) or: [receiver isKindOf: Class]) ifTrue: [
			keys := OrderedCollection new.
		] ifFalse: [
			keys := receiver class allInstVarNames asOrderedCollection collect: [:each | '-' , each].
			1 to: keys size do: [:i |
				values add: (receiver instVarAt: i).
			].
		].
	].
	keys addFirst: #'receiver'.
	values addFirst: receiver.
	keys addAll: (anArray at: 9).
	keys := keys reject: [:each | each first == $.].
	values addAll: (anArray size >= 11
		ifTrue: [anArray copyFrom: 11 to: anArray size]
		ifFalse: [#()]).
	list := Array new.
	1 to: (keys size min: values size) do: [:i | | theOop key value valueClass | 
		key := keys at: i.
		value := values at: i.
		valueClass := value class.
		theOop := value asOop.
		value := [
			value printString.
		] on: Error do: [:ex | 
			ex return: '(' , value class name , ' printString error: ' , ex description , ')'. 
		].
		value size > 500 ifTrue: [value := (value copyFrom: 1 to: 500) , '...'].
		value := value collect: [:char | (char asciiValue < 32 or: [127 < char asciiValue]) ifTrue: [$?] ifFalse: [char]].
		list add: (RowanVariableService oop: theOop key: key value: value className: valueClass name asString).
	].
	^list
%

! Class implementation for 'RowanLoggingService'

!		Class methods for 'RowanLoggingService'

category: 'accessing'
classmethod: RowanLoggingService
current

	"lazy initialize for a topaz session test" 
	^SessionTemps current at: #rowanLoggingService ifAbsentPut: [nil]
%

category: 'accessing'
classmethod: RowanLoggingService
current: anObject

	SessionTemps current at: #rowanLoggingService put: anObject
%

!		Instance methods for 'RowanLoggingService'

category: 'accessing'
method: RowanLoggingService
fileName
	^fileName
%

category: 'accessing'
method: RowanLoggingService
fileName: object
	fileName := object
%

category: 'client commands'
method: RowanLoggingService
logComment: string

	| stonString ws |
	isLogging ifFalse:[^self].
	comment := string.
	id := id + 1. 
	date := Date today.
	time := Time now.
	location := #server.
	stonString := STON toString: self.
	ws := FileStreamPortable 
				write: fileName
				mode: #append.
	[ws nextPutAll: stonString] ensure: [ws close].
	comment := nil "service may be reused. Clear comment"
%

category: 'accessing'
method: RowanLoggingService
logFileContents

	| rs |
	rs := [FileStreamPortable read: fileName] on: Error do:[:ex | ^String new].
	[^rs contents] ensure: [rs close]
%

category: 'client commands'
method: RowanLoggingService
logReceivedServices

	mode := #received.
	self class current: self. 
	self logServices
%

category: 'client commands'
method: RowanLoggingService
logSentServices

	mode := #sent.
	services := RowanCommandResult results copy asOrderedCollection.
	self logServices.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanLoggingService
logServices

	| stonString ws |
	isLogging ifFalse:[^self].
	id := id + 1. 
	date := Date today.
	time := Time now.
	location := #server.
	stonString := STON toString: self.
	ws := FileStreamPortable 
				write: fileName
				mode: #append.
	[ws nextPutAll: stonString] ensure: [ws close]
%

! Class implementation for 'RowanMethodService'

!		Class methods for 'RowanMethodService'

category: 'instance creation'
classmethod: RowanMethodService
forGsNMethod: aGsNMethod organizer: anOrganizer
	^self new
		initialize: aGsNMethod organizer: anOrganizer;
		yourself
%

category: 'instance creation'
classmethod: RowanMethodService
forSelector: sel class: theClass meta: boolean organizer: anOrganizer

	| service |
	service := self new. 
	service selector: sel;
		meta: boolean.
	service forClass: theClass organizer: anOrganizer.
	^service
%

category: 'utility'
classmethod: RowanMethodService
put: string onStreamWithoutUnicode: stream

	string do:[:char | 
			char asInteger > 255 ifTrue:[
				stream nextPutAll: '$\x', char asInteger asHexString]
			ifFalse:[
				stream nextPut: char
			]].
%

category: 'utility'
classmethod: RowanMethodService
removeUnicode: string

		| ws | 
		ws := WriteStream on: String new. 
		self put: string onStreamWithoutUnicode: ws. 
		^ws contents
%

category: 'utility'
classmethod: RowanMethodService
removeUnicodeFromSource: string

	"possibly a unicode string which is not yet 
	presentable in Jadeite."

	(string isKindOf: MultiByteString) ifTrue:[
		| ws | 
		ws := WriteStream on: String new. 
		ws nextPutAll: '''METHOD SOURCE CANNOT BE DISPLAYED
This method source contains unicode and is not displayable in Jadeite. 
An approximation of the source code is given printed below with $\x<char hex value>
replacing the actual unicode character.''';
			cr; 
			cr.
		self put: string onStreamWithoutUnicode: ws. 
		^ws contents]
	ifFalse:[
		^string].
%

category: 'instance creation'
classmethod: RowanMethodService
source: source selector: selector category: category className: className packageName: packageName meta: boolString

	| service |
	self rowanFixMe. "Need to include super and sub implementors"
	service := self new. 
	service 
		source: source;
		selector: selector;
		category: category asString;
		className: className;
		packageName: packageName;
		meta: boolString == true.
	^service
%

!		Instance methods for 'RowanMethodService'

category: 'comparing'
method: RowanMethodService
= methodService
	(methodService class canUnderstand: #isMethodService) ifFalse:[^false].
	methodService isMethodService ifFalse:[^false].
	^selector = methodService selector
		and: [className asString = methodService className asString and: [meta = methodService meta]]
%

category: 'Accessing'
method: RowanMethodService
accessedInstVars
  ^ accessedInstVars
%

category: 'Updating'
method: RowanMethodService
accessedInstVars: anArray
	accessedInstVars := anArray
%

category: 'rowan'
method: RowanMethodService
addOrUpdateMethod

		self browserTool  
                   addOrUpdateMethod: source
                   inProtocol: category
                   forClassNamed: self classService name
                   isMeta: meta
                   inPackageNamed: self classService packageName
%

category: 'client commands'
method: RowanMethodService
allReferences
  | methods |
  oop := self gsNMethod asOop.
  methods := organizer sendersOf: selector.
  references := methods first
    collect: [ :gsNMethod | self class forGsNMethod: gsNMethod organizer: organizer ].
  RowanCommandResult addResult: self
%

category: 'Accessing'
method: RowanMethodService
breakPoints

	^breakPoints
%

category: 'Accessing'
method: RowanMethodService
breakPoints: collection
  breakPoints := collection
%

category: 'initialization'
method: RowanMethodService
breakPointsFor: aGsNMethod
  "Answers an Array stepPoints"

  | list theMethod |
  list := OrderedCollection new.
  theMethod := aGsNMethod isMethodForBlock
    ifTrue: [ 
      isMethodForBlock := true.
      aGsNMethod homeMethod ]
    ifFalse: [ aGsNMethod ].
  homeMethodOop := theMethod asOop.
  theMethod _allBreakpoints
    ifNil: [ ^ OrderedCollection new ]
    ifNotNil: [ :anArray | 
      1 to: anArray size by: 3 do: [ :i | 
        list
          add:
            (theMethod _stepPointForMeth: (anArray at: i + 1) ip: (anArray at: i + 2) abs) ] ].
  ^ list asOrderedCollection
%

category: 'Accessing'
method: RowanMethodService
category
	^category
%

category: 'Updating'
method: RowanMethodService
category: newValue
	category := newValue asString
%

category: 'Accessing'
method: RowanMethodService
classFromName
  "the dictionary browser may have versions numbers in the name"

  | nameSymbol |
  nameSymbol := (className copyUpTo: Character space) asSymbol.
  ^ (System myUserProfile resolveSymbol: nameSymbol) value
%

category: 'Accessing'
method: RowanMethodService
className
	^className
%

category: 'Updating'
method: RowanMethodService
className: newValue
	className := newValue asString
%

category: 'Accessing'
method: RowanMethodService
classOrMeta

	^meta 
			ifTrue:[self classFromName class] 
			ifFalse: [self classFromName].
%

category: 'Accessing'
method: RowanMethodService
classService

	^classService ifNil:[classService := RowanClassService forClassNamed: className package: packageName]
%

category: 'Updating'
method: RowanMethodService
classService: newValue
	classService := newValue
%

category: 'client commands'
method: RowanMethodService
clearBreakAt: stepPoint
	| method |
	method := self isUnboundMethod 
			ifTrue:[(Object _objectForOop: oop) homeMethod] 
			ifFalse:[self gsNMethod].
	method clearBreakAtStepPoint: stepPoint.
	self update. 
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanMethodService
clearMethodBreaks
  self update.
  breakPoints do: [ :breakPoint | self clearBreakAt: breakPoint ]
%

category: 'Updating'
method: RowanMethodService
comparisonSource: string

	comparisonSource := string
%

category: 'Accessing'
method: RowanMethodService
compilationWarnings

	^compilationWarnings
%

category: 'Updating'
method: RowanMethodService
compilationWarnings: newValue
	compilationWarnings := newValue
%

category: 'client commands'
method: RowanMethodService
debugTest: testSelector inClassName: theClassName
  testResult := 'passed'.
  [ (Rowan image objectNamed: theClassName) debug: testSelector asSymbol ]
    on: Exception
    do: [ :ex | 
      testResult := ex class = TestFailure
        ifTrue: [ 'failure' ]
        ifFalse: [ 
          (ex class isSubclassOf: Notification)
            ifTrue: [ 'passed' ]
            ifFalse: [ 'error' ] ].
      ex pass ].
  testRunClassName := theClassName.
  RowanCommandResult addResult: self
%

category: 'Accessing'
method: RowanMethodService
definedPackage

	^definedPackage
%

category: 'rowan'
method: RowanMethodService
definitionClass

	^RwMethodDefinition
%

category: 'Updating'
method: RowanMethodService
failedCompile: boolean	
	
	failedCompile := boolean
%

category: 'client commands'
method: RowanMethodService
fileout
	| answeringService ws |
	answeringService := RowanAnsweringService new.
	ws := WriteStream on: String new. 
	self writeFileOutHeaderOn: ws.
	ws nextPutAll: (self behavior fileOutMethod: selector asString environmentId: 0).
	answeringService answer: ws contents.
	RowanCommandResult addResult: answeringService.
%

category: 'Accessing'
method: RowanMethodService
firstReference: integer

	firstReference := integer
%

category: 'initialization'
method: RowanMethodService
forClass: theClass organizer: theOrganizer
  "assume meta and selector are set"

  | classOrMeta gsNMethod |
  organizer := theOrganizer.
  classOrMeta := meta
    ifTrue: [ theClass class ]
    ifFalse: [ theClass ].
  gsNMethod := classOrMeta compiledMethodAt: selector.
  definedPackage := gsNMethod rowanPackageName.
  oop := gsNMethod asOop.
  stepPoints := self stepPointsFor: gsNMethod.
  breakPoints := self breakPointsFor: gsNMethod.
  self updateSource: gsNMethod sourceString.
  category := (classOrMeta categoryOfSelector: selector) asString.
  className := theClass name asString.
  packageName := gsNMethod rowanPackageName.
  projectName := gsNMethod rowanProjectName.
  self setSupersAndSubsFor: classOrMeta.
  isExtension := self rowanIsExtension.
  self initializeTestMethodsFor: classOrMeta thisClass
%

category: 'Accessing'
method: RowanMethodService
gsNMethod

	^[self classOrMeta compiledMethodAt: selector ] on: Error do:[:ex | nil "removed method"]
%

category: 'comparing'
method: RowanMethodService
hash
  ^ (selector hash bitXor: className hash) bitXor: meta hash
%

category: 'Accessing'
method: RowanMethodService
hasSubs

	^hasSubs
%

category: 'Updating'
method: RowanMethodService
hasSubs: aBoolean

	hasSubs := aBoolean
%

category: 'Accessing'
method: RowanMethodService
hasSupers

	^hasSupers
%

category: 'Updating'
method: RowanMethodService
hasSupers: aBoolean

	hasSupers := aBoolean
%

category: 'initialization'
method: RowanMethodService
initialize

	super initialize. 
	hasSupers := false. 
	hasSubs := false.
	accessedInstVars := Array new.
	isTestMethod := false.
	failedCompile := false.
	isMethodForBlock := false.
%

category: 'initialization'
method: RowanMethodService
initialize: aGsNMethod organizer: aClassOrganizer

	| inClass |
	oop := aGsNMethod asOop.
	definedPackage := aGsNMethod rowanPackageName. 
	selector := aGsNMethod selector.
	stepPoints := self stepPointsFor: aGsNMethod.
	breakPoints := self breakPointsFor: aGsNMethod.
	((inClass := aGsNMethod inClass) isNil or: [selector isNil]) ifTrue: [
		meta := false.
		self updateSource: aGsNMethod sourceString.
		hasSupers := false.
		hasSubs := false.
		organizer := aClassOrganizer. 
		inSelectedPackage := false.
		^self
	].
	meta := inClass isMeta.
	self 
		forClass: inClass thisClass 
		organizer: aClassOrganizer.
	self initializeTestMethodsFor: inClass thisClass
%

category: 'initialization'
method: RowanMethodService
initializeTestMethodsFor: aClass
  | testSelectors |
  (aClass inheritsFrom: TestCase)
    ifTrue: [ 
      aClass isAbstract
        ifTrue: [ ^ self ].
      testSelectors := aClass thisClass suite tests
        collect: [ :method | method selector ].
      isTestMethod := testSelectors includes: selector ]
%

category: 'testing'
method: RowanMethodService
isMethodService

	^true
%

category: 'testing'
method: RowanMethodService
isTestMethod

	^isTestMethod
%

category: 'Updating'
method: RowanMethodService
isTestMethod: boolean

	isTestMethod := boolean
%

category: 'testing'
method: RowanMethodService
isUnboundMethod

	(className notNil and: [selector notNil]) ifTrue:[^false].
	^(Object _objectForOop: oop) isKindOf: GsNMethod
%

category: 'Accessing'
method: RowanMethodService
meta
	^meta
%

category: 'Updating'
method: RowanMethodService
meta: aBoolean
	"allow nil parameter for now" 
	meta := aBoolean == true
%

category: 'Accessing'
method: RowanMethodService
method

	^self classFromName compiledMethodAt: selector otherwise: nil
%

category: 'Accessing'
method: RowanMethodService
methodDefinitions
	^methodDefinitions
%

category: 'Updating'
method: RowanMethodService
methodDefinitions: newValue
	methodDefinitions := newValue
%

category: 'Accessing'
method: RowanMethodService
name

	^selector
%

category: 'Accessing'
method: RowanMethodService
packageName
	^packageName
%

category: 'Updating'
method: RowanMethodService
packageName: newValue
	packageName := newValue
%

category: 'printing'
method: RowanMethodService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $(;
				nextPutAll: (className ifNil:[nil printString]); 
				nextPutAll: '>>'; 
				nextPutAll: (selector ifNil:[nil printString]);
				nextPut: $)
%

category: 'client commands'
method: RowanMethodService
reformatSource
  source := (RBParser parseMethod: source) formattedCode.
  updateType := #'dontUpdateSystem'.	"let browser update the source"
  RowanCommandResult addResult: self
%

category: 'rowan'
method: RowanMethodService
removeSelector: sel class: clsName
	
	self rowanFixMe. "combine remove methods variants"
	self browserTool removeMethod: sel asSymbol forClassNamed: (clsName subStrings first) isMeta: (clsName subStrings size = 2)
%

category: 'Accessing'
method: RowanMethodService
renamedName
	^renamedName
%

category: 'Accessing'
method: RowanMethodService
renamedName: object
	renamedName := object
%

category: 'rowan'
method: RowanMethodService
rowanIsExtension

	^Rowan projectTools browser isExtensionMethod: selector asString forClassNamed: className asString isMeta: meta
%

category: 'rowan'
method: RowanMethodService
rowanProjectName

	^projectName
%

category: 'client commands'
method: RowanMethodService
runTest: testSelector inClassName: theClassName

	| sunitTestResult |
	sunitTestResult := (Rowan image objectNamed: theClassName) run: testSelector asSymbol.
	sunitTestResult errorCount > 0 ifTrue:[testResult := 'error']. 
	sunitTestResult failureCount > 0 ifTrue:[testResult := 'failure']. 
	sunitTestResult passedCount > 0 ifTrue:[testResult := 'passed']. 
	testRunClassName := theClassName. 
	RowanCommandResult addResult: self.
%

category: 'Accessing'
method: RowanMethodService
selectedPackageServices

	^selectedPackageServices
%

category: 'Updating'
method: RowanMethodService
selectedPackageServices: collection

	selectedPackageServices := collection
%

category: 'Accessing'
method: RowanMethodService
selector

	^selector
%

category: 'Updating'
method: RowanMethodService
selector: aSymbol

	selector := aSymbol
%

category: 'perform'
method: RowanMethodService
servicePerform: symbol withArguments: collection
  | theCommand |
  self isUpdatingButFoundToBeDeleted
    ifTrue: [ ^ self handleDeletedService ].
  theCommand := command.
  super servicePerform: symbol withArguments: collection.
  theCommand = #'reformatSource'
    ifFalse: [ self update ]
%

category: 'client commands'
method: RowanMethodService
setBreakAt: stepPoint
  | method |
  method := self isUnboundMethod
    ifTrue: [ (Object _objectForOop: oop) homeMethod ]
    ifFalse: [ self gsNMethod ].
  method setBreakAtStepPoint: stepPoint.
  self class breakPointsAreEnabled
    ifFalse: [ GsNMethod _disableAllBreaks ].
  self update.
  RowanCommandResult addResult: self
%

category: 'initialization'
method: RowanMethodService
setSupersAndSubsFor: theClass

	| theSuper |
	theSuper := theClass superClass. 
	hasSupers := false. 
	[theSuper notNil and:[hasSupers not]] whileTrue:[
		hasSupers := theSuper selectors includes: selector.
		hasSupers ifTrue:[
			comparisonSource := theSuper sourceCodeAt: selector.
			superDisplayString := theSuper name, '>>', selector].
		theSuper := theSuper superClass].
	(organizer allSubclassesOf: theClass thisClass) do:[:cls |
		| aClass |
		aClass := theClass isMeta ifTrue:[cls class] ifFalse:[cls]. 
		(hasSubs := aClass includesSelector: selector) ifTrue:[
		^self]].
%

category: 'Accessing'
method: RowanMethodService
source

	^source
%

category: 'Updating'
method: RowanMethodService
source: string
	
	self updateSource: string
%

category: 'Accessing'
method: RowanMethodService
stepPoints

	"for testing"
	
	^stepPoints
%

category: 'Updating'
method: RowanMethodService
stepPoints: collection

	stepPoints := collection
%

category: 'initialization'
method: RowanMethodService
stepPointsFor: aGsNMethod
	"Answers an Array of Associations (offset -> selector) indexed by step point"

	|  selectors list |
	(selectors := aGsNMethod _allDebugInfo: 10) ifNil: [^#()].
	list := aGsNMethod homeMethod  _sourceOffsets.
	list := list collect: [:each |
		| index eachSelector |
		eachSelector := ''.
		index := selectors indexOf: each.
		0 < index ifTrue: [eachSelector := selectors at: index + 1].
		each -> eachSelector.
	].
	^list
%

category: 'Accessing'
method: RowanMethodService
testResult

	^testResult
%

category: 'updates'
method: RowanMethodService
update
	self isUnboundMethod ifFalse:[
		self wasRecycled ifTrue:[oop := self gsNMethod asOop].
		self wasDeleted ifTrue:[
			self updateType: #methodsRemoved:. 
			^RowanCommandResult addResult: self. ].  "removed method"
		oop ifNil: [oop := self gsNMethod asOop]].
	self 
		initialize: (Object _objectForOop: oop) 
		organizer: organizer.
	RowanCommandResult addResult: self.
%

category: 'updates'
method: RowanMethodService
updateLatest
  | theClass compiledMethod |
  theClass := (RowanClassService new name: className) theClass.
  theClass ifNil: [ ^ self ].
  compiledMethod := theClass compiledMethodAt: selector otherwise: nil.
  compiledMethod ifNil: [ ^ self ].
  oop := compiledMethod asOop.
  super updateLatest
%

category: 'private'
method: RowanMethodService
updateSource: string

	source := self class removeUnicodeFromSource: string
%

category: 'testing'
method: RowanMethodService
wasDeleted
	selector isNil ifTrue:[^false].
	^self gsNMethod isNil
%

category: 'testing'
method: RowanMethodService
wasRecycled
	(oop notNil and:[self gsNMethod asOop ~= oop]) ifTrue:[^true].
	^false
%

! Class implementation for 'RowanPackageService'

!		Class methods for 'RowanPackageService'

category: 'instance creation'
classmethod: RowanPackageService
forPackageNamed: aName

	| inst |
	inst := self new.  
	inst name: aName.
	aName isNil ifFalse:[
		inst isDirty. "lazy initialize"].
	inst setDefaultTemplate. 
	inst updateProjectName.
	^inst
%

!		Instance methods for 'RowanPackageService'

category: 'comparing'
method: RowanPackageService
= packageService
	(packageService isKindOf: RowanPackageService) ifFalse:[^false].
	^name = packageService name
%

category: 'testing'
method: RowanPackageService
arePackageAndProjectClean
  ^ self rowanDirty not and: [ self projectIsDirty not ]
%

category: 'rowan'
method: RowanPackageService
changes
   "diffForPackageName: not implemented yet"
 
   ^ (Rowan packageTools diff diffForPackageName: name) asString
%

category: 'other'
method: RowanPackageService
classes: collection

	classes := collection
%

category: 'client commands'
method: RowanPackageService
classHierarchy
	| theClasses |
	self update. 
	theClasses := classes collect:[:classService | classService theClass].
	hierarchyServices := self classHierarchy: theClasses. 
	RowanCommandResult addResult: self.
%

category: 'commands support'
method: RowanPackageService
classHierarchy: theClasses
  hierarchyServices := super classHierarchy: theClasses.
  ^ hierarchyServices
%

category: 'rowan'
method: RowanPackageService
createPackage
	| projectService default |
	default := RowanProjectService defaultProjectName.
	projectService := RowanProjectService new.
	projectService createProjectNamed: default.  
	(Rowan packageNames includes: name) ifFalse:[
		self browserTool addPackageNamed: name toProjectNamed: default].
%

category: 'rowan'
method: RowanPackageService
createPackageNamed: aString inProject: projName
	| projectService | 
	name := aString.
	projectService := RowanProjectService new.
	projectDefinition := projectService createProjectNamed: projName.  
	projectDefinition addPackageNamed: name.
	self projectTools load loadProjectDefinition: projectDefinition.
%

category: 'Updating'
method: RowanPackageService
defaultTemplate: newValue
	defaultTemplate := newValue
%

category: 'rowan'
method: RowanPackageService
definition

	^(Rowan image loadedPackageNamed: name) asDefinition
%

category: 'rowan'
method: RowanPackageService
deletePackage

	self browserTool removePackageNamed: name.
%

category: 'rowan'
method: RowanPackageService
genericClassCreationTemplate

	^self browserTool classCreationTemplateForSubclassOf: 'Object' category: name packageName: nil
%

category: 'comparing'
method: RowanPackageService
hash
	^self name hash
%

category: 'Accessing'
method: RowanPackageService
hierarchyServices

	^hierarchyServices
%

category: 'rowan'
method: RowanPackageService
isDirty

	^isDirty := self rowanDirty
%

category: 'Updating'
method: RowanPackageService
isDirty: boolean

	isDirty := boolean
%

category: 'Accessing'
method: RowanPackageService
jadeite_testClasses

	"for testing" 
	^testClasses
%

category: 'rowan'
method: RowanPackageService
loadedClasses

	| loadedPackage |
	loadedPackage := Rowan image loadedPackageNamed: name ifAbsent:[^KeyValueDictionary new].
	^loadedPackage loadedClasses
%

category: 'rowan'
method: RowanPackageService
loadedClassExtensions

	| loadedPackage |
	loadedPackage := Rowan image loadedPackageNamed: name ifAbsent:[^KeyValueDictionary new].
	^loadedPackage loadedClassExtensions
%

category: 'rowan'
method: RowanPackageService
loadedClassHandles
	| loadedClasses |
	loadedClasses := self loadedClasses collect:[:loadedClass | loadedClass handle].
	loadedClasses addAll: (self loadedClassExtensions collect:[:extension | extension handle]).
	^loadedClasses
%

category: 'rowan'
method: RowanPackageService
loadedClassNames

	^self loadedClasses collect:[:loadedClass | loadedClass name]
%

category: 'Accessing'
method: RowanPackageService
name
	^name
%

category: 'Updating'
method: RowanPackageService
name: newValue
	name := newValue
%

category: 'Accessing'
method: RowanPackageService
packageName
	^name
%

category: 'Updating'
method: RowanPackageService
packageName: newValue
	name := newValue
%

category: 'printing'
method: RowanPackageService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $:. 
	aStream nextPutAll: (name ifNil: [nil printString])
%

category: 'Accessing'
method: RowanPackageService
projectDefinition
	^projectDefinition
%

category: 'Updating'
method: RowanPackageService
projectDefinition: newValue
	projectDefinition := newValue
%

category: 'testing'
method: RowanPackageService
projectIsDirty

	^(RowanProjectService new name: projectName) rowanDirty
%

category: 'Accessing'
method: RowanPackageService
projectName
	^projectName
%

category: 'Updating'
method: RowanPackageService
projectName: newValue
	projectName := newValue
%

category: 'client commands'
method: RowanPackageService
removeClass: classService
  self removeClassNamed: classService name.
  self setDefaultTemplate.
  classService updateType: #'removedClass:'.
  classService wasRemoved: true.
  RowanCommandResult addResult: classService.
  RowanBrowserService new packagesWithTests	"sunit browser might need updated"
%

category: 'commands support'
method: RowanPackageService
removeClassNamed: className

	self browserTool removeClassNamed: className.
%

category: 'rowan'
method: RowanPackageService
rowanDirty

	^(RwPackage newNamed: name) isDirty
%

category: 'rowan'
method: RowanPackageService
rowanProjectName

	^projectName
%

category: 'other'
method: RowanPackageService
selectedClass
	
	^selectedClass
%

category: 'Accessing'
method: RowanPackageService
selectedClass: classService
	selectedClass := classService.
	classService selectedPackageServices: (Array with: self)
%

category: 'perform'
method: RowanPackageService
servicePerform: symbol withArguments: collection
  | wasClean |
  self isUpdatingButFoundToBeDeleted
    ifTrue: [ ^ self handleDeletedService ].
  wasClean := self arePackageAndProjectClean.
  super servicePerform: symbol withArguments: collection.
  self update.
  wasClean
    ifTrue: [ self updateProject ]
%

category: 'commands support'
method: RowanPackageService
services: services from: levels expand: toExpand
  ^ self
    services: services
    from: levels
    expand: toExpand
    classes: (classes collect: [ :classService | classService theClass ])
%

category: 'client commands'
method: RowanPackageService
setDefaultTemplate

	defaultTemplate := self genericClassCreationTemplate.
%

category: 'client commands'
method: RowanPackageService
testClasses
  organizer := ClassOrganizer new.
  testClasses := Set new.
  self loadedClasses
    valuesDo: [ :loadedClass | 
      | cls |
      cls := loadedClass handle.
      (cls inheritsFrom: TestCase)
        ifTrue: [ 
          cls isAbstract
            ifFalse: [ 
              | classService |
              classService := RowanClassService basicForClassNamed: cls name.
              testClasses add: classService ] ] ].
  self loadedClassExtensions
    valuesDo: [ :loadedClass | 
      | cls |
      cls := loadedClass handle.
      (cls inheritsFrom: TestCase)
        ifTrue: [ 
          cls isAbstract
            ifFalse: [ 
              | classService |
              classService := RowanClassService basicForClassNamed: cls name.
              testClasses add: classService ] ] ].
  updateType := #'testClasses:'.
  testClasses := testClasses asArray.
  RowanCommandResult addResult: self
%

category: 'updates'
method: RowanPackageService
update
	Rowan image loadedPackageNamed: name ifAbsent: [^self]. 
	classes := (self loadedClassNames keys collect:[:string | RowanClassService minimalForClassNamed: string]) asArray.
	classes addAll: (self loadedClassExtensions keys collect:[:string | 
		| classService | 
		classService := (RowanClassService minimalForClassNamed: string) 
			isExtension: true.
		(Rowan image loadedClassForClass: classService theClass ifAbsent:[]) 
			ifNotNil:[:cls | classService definedPackageName: cls packageName].
		classService]).
	classes do: [:clsService | clsService packageName: self name]. 
	self isDirty. 
	projectName := (Rowan image loadedPackageNamed: name) projectName.
	RowanCommandResult addResult: self
%

category: 'updates'
method: RowanPackageService
updateInternalService: updatedService

	"when sending services back to the client,
	verify any services held by this object are 
	updated. Services know what internal services
	they contain." 

	1 to: classes size do:[:index |
		| classesService |
		classesService := classes at: index. 
		classesService = updatedService ifTrue:[
			classes at: index put: updatedService
		]].
%

category: 'updates'
method: RowanPackageService
updateProject
	| projectService |

	projectService := RowanProjectService new name: projectName. 
	projectService update.
	RowanCommandResult addResult: projectService.
%

category: 'updates'
method: RowanPackageService
updateProjectName

	projectName := (Rowan image loadedPackageNamed: name) projectName.
%

category: 'testing'
method: RowanPackageService
wasDeleted

	^(Rowan image loadedPackageNamed: name
			ifAbsent: []) isNil
%

! Class implementation for 'RowanProcessService'

!		Class methods for 'RowanProcessService'

category: 'other'
classmethod: RowanProcessService
new

	self error: 'Use on*Process: constructors'.
%

category: 'other'
classmethod: RowanProcessService
onActiveProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'active';
		yourself
%

category: 'other'
classmethod: RowanProcessService
onReadyProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'ready';
		yourself
%

category: 'other'
classmethod: RowanProcessService
onSuspendedProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'suspended';
		yourself
%

category: 'other'
classmethod: RowanProcessService
onWaitingProcess: aGsProcess

	^self basicNew
		initialize: aGsProcess status: 'waiting';
		yourself
%

!		Instance methods for 'RowanProcessService'

category: 'initialize'
method: RowanProcessService
initialize: aGsProcess status: aString

	| theOrganizer |
	theOrganizer := ClassOrganizer new. 
	frames := Array new: aGsProcess stackDepth.
	1 to: aGsProcess stackDepth do: [:i | 
		frames at: i put: (RowanFrameService process: aGsProcess level: i organizer: theOrganizer).
	].
	oop := aGsProcess asOop.  
	status := aString.
%

category: 'perform'
method: RowanProcessService
servicePerform: symbol withArguments: collection
	^self perform: symbol withArguments: collection.
%

! Class implementation for 'RowanProjectService'

!		Class methods for 'RowanProjectService'

category: 'accessing'
classmethod: RowanProjectService
defaultProjectName

	^RowanServicePreferences current defaultProjectName
%

category: 'accessing'
classmethod: RowanProjectService
defaultProjectName: aString

	RowanServicePreferences current defaultProjectName: aString
%

category: 'instance creation'
classmethod: RowanProjectService
newNamed: aString

	| inst |
	inst := self new.
	inst name: aString.
	inst refresh.
	^inst
%

!		Instance methods for 'RowanProjectService'

category: 'comparing'
method: RowanProjectService
= projectService
	^projectService isProjectService ifTrue: [name = projectService name] ifFalse: [^false]
%

category: 'client commands'
method: RowanProjectService
addPackageNamed: packageName

	Rowan image loadedPackageNamed: packageName ifAbsent: [
		self browserTool addPackageNamed: packageName toProjectNamed: name. 
		self update.
		^self answer: #added.].
	self answer: #duplicatePackage
%

category: 'initialization'
method: RowanProjectService
basicRefresh
	name = Rowan unpackagedName ifTrue:[
		isLoaded := false.
		RowanBrowserService new updateDictionaries. ^self]. 
	(isLoaded := self projectIsLoaded) ifFalse:[
		existsOnDisk := false. 
		updateType := #removedProject:. 
		^RowanCommandResult addResult: self]. 
	isDirty := self isDirty. 
	self setExistsOnDisk.
	isSkew := self isSkew.
	sha := self rowanSha.
	branch := self rowanBranch.
	projectUrl := self rowanProjectUrl. 
	rowanProjectsHome := System gemEnvironmentVariable: 'ROWAN_PROJECTS_HOME' .
	RowanCommandResult addResult: self
%

category: 'accessing'
method: RowanProjectService
branch

	name isNil ifTrue:[^String new].
	^(RwProject newNamed: name) currentBranchName
%

category: 'accessing'
method: RowanProjectService
branch: anObject

	branch := anObject
%

category: 'client commands'
method: RowanProjectService
changes

	| jadeServer |
	jadeServer := Rowan platform jadeServerClassNamed: #JadeServer. 
	changes := Array new. 
	self packageNames do:[:packageName |
			| patch |
			patch := Rowan packageTools diff patchForPackageName: packageName.
			changes add:(jadeServer new
				_mcDescriptionOfPatch: patch
				baseName: 'closest ancestor'
				alternateName: nil)].
	self refresh.
	RowanCommandResult addResult: self.
%

category: 'client commands'
method: RowanProjectService
checkout: branchName

	| project branches |

	project := (RwProject newNamed: name). 
	branches := Rowan gitTools gitcheckoutIn: project repositoryRootPath with: branchName.
	^branches
%

category: 'client commands'
method: RowanProjectService
commitWithMessage: message
	
	Rowan projectTools write writeProjectNamed: name.
	Rowan projectTools commit
		commitProjectNamed: name
		message: message.
%

category: 'examples'
method: RowanProjectService
createProjectNamed: projectName 

	^self createProjectNamed: projectName in: self sampleSymbolDictionaryName.
%

category: 'examples'
method: RowanProjectService
createProjectNamed: projectName in: symbolDictionaryName

	self rowanFixMe. "Dale doesn't like Rowan projectNames"
	(Rowan projectNames includes: projectName) ifFalse:[
		self browserTool createGitPackageProjectNamed: projectName updateDefinition: [:pd | 
				pd defaultSymbolDictName: symbolDictionaryName; comment:  'Sample Rowan Project'] ].
%

category: 'accessing'
method: RowanProjectService
defaultProjectName

	^self class defaultProjectName
%

category: 'accessing'
method: RowanProjectService
defaultProjectName: aString

	self class defaultProjectName: aString
%

category: 'accessing'
method: RowanProjectService
existsOnDisk

	^existsOnDisk
%

category: 'comparing'
method: RowanProjectService
hash
	^self name hash
%

category: 'initialization'
method: RowanProjectService
initialize

	super initialize. 
	packages := Array new
%

category: 'rowan'
method: RowanProjectService
isDirty

	name isNil ifTrue:[^false].
	^(RwProject newNamed: name) isDirty
%

category: 'accessing'
method: RowanProjectService
isDirty: aBoolean

	isDirty := aBoolean.
%

category: 'rowan'
method: RowanProjectService
isSkew
	| repositorySha |
	name isNil ifTrue:[^false].
	self existsOnDisk ifFalse:[^false]. 
	repositorySha := [self repositorySha] on: Error do:[:ex | repositorySha := 'not on disk'].
	^self sha ~= repositorySha
%

category: 'client commands'
method: RowanProjectService
loadProjectNamed: aName

	[Rowan projectTools load loadProjectNamed: aName] 
		on: Warning
		do: [ :ex | Transcript cr; show: ex description. ex resume ].
	RowanBrowserService new updateProjects.
%

category: 'rowan'
method: RowanProjectService
log

	^Rowan projectTools log
		commitLogProjectNamed: name
		limit: 25
%

category: 'accessing'
method: RowanProjectService
name

	^name
%

category: 'accessing'
method: RowanProjectService
name: anObject

	name := anObject
%

category: 'client commands'
method: RowanProjectService
newGitProject: url root: rootPath useSsh: useSsh
	"set useSsh to false to clone using https:"

	Rowan projectTools clone
		cloneSpecUrl: url
		gitRootPath: rootPath
		useSsh: useSsh.
	(RowanBrowserService new organizer: organizer) updateProjects.
%

category: 'rowan'
method: RowanProjectService
packageNames
	"if no project is selected, return all package names"
	^name isNil ifTrue:[
		"list of visible packageNames for current user"
		Rowan image packageNames ]
	ifFalse:[
		"list of visible packageNames for current user and named project"
		Rowan image packageNamesForLoadedProjectNamed: name ]
%

category: 'rowan'
method: RowanProjectService
packageNameString
		"return a string showing the package names for a project"

	| ws packageNames |
	ws := WriteStream on: String new.
	ws
		nextPutAll: 'Packages for project: ' , name;
		cr.
	packageNames := Set new.
	packageNames addAll: (Rowan image loadedProjectNamed: name) packageNames.
	packageNames asSortedCollection do: 
			[:packageName |
			ws
				cr; 
				tab;
				nextPutAll: packageName
			].
	^ws contents
%

category: 'accessing'
method: RowanProjectService
packageServices

	^self packageNames collect:[:packageName | RowanPackageService forPackageNamed: packageName]
%

category: 'printing'
method: RowanProjectService
printOn: aStream

	super printOn: aStream. 
	aStream nextPut: $:. 
	aStream nextPutAll: (name ifNil: [nil printString])
%

category: 'testing'
method: RowanProjectService
projectIsLoaded

	^(Rowan image
		loadedProjectNamed: name
		ifAbsent: []) notNil
%

category: 'rowan'
method: RowanProjectService
projects

		^Rowan projectNames collect: 
			[:string |
			| service |
			service := self class new name: string. 
			service 
				sha: service rowanSha;
				branch: service rowanBranch;
				isDirty: service rowanDirty]
%

category: 'accessing'
method: RowanProjectService
projectUrl

	^projectUrl
%

category: 'accessing'
method: RowanProjectService
projectUrl: anObject

	projectUrl := anObject
%

category: 'client commands'
method: RowanProjectService
pullFromGit

	| project |
	project := RwProject newNamed: name. 
	Rowan gitTools
		gitpullIn: project repositoryRootPath
		remote: project remote
		branch: project currentBranchName
%

category: 'client commands'
method: RowanProjectService
pushToGit

	| project |
	project := RwProject newNamed: name. 
	Rowan gitTools
		gitpushIn: project repositoryRootPath
		remote: project remote
		branch: project currentBranchName
%

category: 'initialization'
method: RowanProjectService
refresh
	self basicRefresh. 
	isLoaded ifTrue:[
		packages := self packageServices].
%

category: 'client commands'
method: RowanProjectService
reloadProject
  [ Rowan projectTools load loadProjectNamed: name ]
    on: Warning
    do: [ :ex | 
      Transcript
        cr;
        show: ex description.
      ex resume ].
  self update.
  RowanCommandResult addResult: self.
  RowanBrowserService new packagesWithTests
%

category: 'rowan'
method: RowanProjectService
removeProjectNamed: projectName
   "remove project"
 
    (Rowan image loadedProjectNamed: projectName ifAbsent: [  ])
      ifNotNil: [ :project | Rowan image _removeLoadedProject: project ]
%

category: 'rowan'
method: RowanProjectService
repositorySha

	^(RwProject newNamed: name) repositoryCommitId
%

category: 'rowan'
method: RowanProjectService
rowanBranch
	
	name isNil ifTrue:[^String new].
	^ [ (RwProject newNamed: name) currentBranchName ] on: Error do: [:ex | ^'ERROR getting repository branch' ]
%

category: 'rowan'
method: RowanProjectService
rowanDirty

	^(RwProject newNamed: name) isDirty
%

category: 'rowan'
method: RowanProjectService
rowanProjectName

	^name
%

category: 'rowan'
method: RowanProjectService
rowanProjectUrl

	^(RwProject newNamed: name) projectUrl
%

category: 'rowan'
method: RowanProjectService
rowanSha

	name isNil ifTrue:[^0].
	^(RwProject newNamed: name) loadedCommitId
%

category: 'rowan'
method: RowanProjectService
rowanSkew

	^self sha ~= self repositorySha
%

category: 'perform'
method: RowanProjectService
servicePerform: symbol withArguments: collection
  self isUpdatingButFoundToBeDeleted
    ifTrue: [ ^ self handleDeletedService ].
  super servicePerform: symbol withArguments: collection.
  self update
%

category: 'client commands'
method: RowanProjectService
setDefaultProject

	self class defaultProjectName: name
%

category: 'rowan'
method: RowanProjectService
setExistsOnDisk
	"might be a better test than #repositorySha for
	determining if a project exists on disk." 

	existsOnDisk := (RwProject newNamed: name) existsOnDisk.
%

category: 'accessing'
method: RowanProjectService
sha

	name isNil ifTrue:[^0].
	^(RwProject newNamed: name) loadedCommitId
%

category: 'accessing'
method: RowanProjectService
sha: anObject

	"because skew is intimately associated with sha
	set it here" 
	sha := anObject.
	isSkew := self rowanSkew
%

category: 'rowan'
method: RowanProjectService
unload

	| loadedProject |
	loadedProject := Rowan image loadedProjects select:[:proj | proj name = name].
%

category: 'update'
method: RowanProjectService
update
	self refresh.
%

category: 'update'
method: RowanProjectService
updateInternalService: updatedService

	"when sending services back to the client,
	verify any services held by this object are 
	updated. Services know what internal services
	they contain." 

	1 to: packages size do:[:index |
		| packageService |
		packageService := packages at: index. 
		packageService = updatedService ifTrue:[
			packages at: index put: updatedService
		]].
%

category: 'testing'
method: RowanProjectService
wasDeleted
  ^ self projectIsLoaded not
%

category: 'client commands'
method: RowanProjectService
write
	Rowan projectTools write writeProjectNamed: name
%

category: 'accessing'
method: RowanProjectService
_isSkew

	^isSkew
%

! Class implementation for 'RowanQueryService'

!		Instance methods for 'RowanQueryService'

category: 'private'
method: RowanQueryService
basicBreakpointMethods
  | bpMethods bpArray |
  bpMethods := Array new.
  bpArray := (GsNMethod _breakReport: true) at: 2.
  bpArray do: [ :array | bpMethods add: (array at: 5) ].
  ^ (self methodServicesFrom: bpMethods) asSet asArray
%

category: 'queries'
method: RowanQueryService
breakPointMethods
  queryResults := self basicBreakpointMethods.
  self returnQueryToClient
%

category: 'queries'
method: RowanQueryService
browseClassReferences: className

	| methods |
	methods := organizer referencesTo: className asSymbol.
	queryResults := self methodServicesFrom: methods first.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
browseReferencesTo: symbol

	| methods |
	methods := organizer referencesTo: symbol.
	queryResults := self methodServicesFrom: methods first.
	self returnQueryToClient.
%

category: 'private'
method: RowanQueryService
defaultProjectLogSize

	^100
%

category: 'queries'
method: RowanQueryService
hierarchyImplementorsOf: selector inClass: className

	| methods behavior classes |
	behavior := Rowan globalNamed: className.
	classes := behavior allSuperclasses. 
	classes add: behavior. 
	classes addAll: (organizer allSubclassesOf: behavior). 
	methods := organizer implementorsOf: selector in: classes.
	queryResults := self methodServicesFrom: methods.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
hierarchySendersOf: selector inClass: className

	| methods behavior classes |
	behavior := Rowan globalNamed: className.
	classes := behavior allSuperclasses. 
	classes add: behavior. 
	classes addAll: (organizer allSubclassesOf: behavior). 
	methods := organizer sendersOf: selector in: classes.
	queryResults := self methodServicesFrom: methods first.
	self setFirstReferenceUsing: queryResults and: methods. 
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
implementorsOf: selector

	| methods |
	methods := organizer implementorsOf: selector asSymbol.
	queryResults := self methodServicesFrom: methods.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
instVarReaders: instVarName in: className
  | methods symbolAssociation theClasses |
  symbolAssociation := Rowan image symbolList resolveSymbol: className.
  symbolAssociation ifNil: [ ^ self ].
  theClasses := symbolAssociation value allSuperclasses.
  theClasses add: symbolAssociation value.
  theClasses addAll: (organizer allSubclassesOf: symbolAssociation value).
  methods := Array new.
  theClasses
    do: [ :theClass | 
      theClass
        methodsDo: [ :selector :method | 
          (method instVarsRead includes: instVarName asSymbol)
            ifTrue: [ methods add: method ] ] ].
  queryResults := self methodServicesFrom: methods.
  self returnQueryToClient
%

category: 'queries'
method: RowanQueryService
instVarWriters: instVarName in: className
  | methods symbolAssociation theClasses |
  symbolAssociation := Rowan image symbolList resolveSymbol: className.
  symbolAssociation ifNil: [ ^ self ].
  theClasses := symbolAssociation value allSuperclasses.
  theClasses add: symbolAssociation value.
  theClasses addAll: (organizer allSubclassesOf: symbolAssociation value).
  methods := Array new.
  theClasses
    do: [ :theClass | 
      theClass
        methodsDo: [ :selector :method | 
          (method instVarsWritten includes: instVarName asSymbol)
            ifTrue: [ methods add: method ] ] ].
  queryResults := self methodServicesFrom: methods.
  self returnQueryToClient
%

category: 'queries'
method: RowanQueryService
literalReferences: string

	| methods compilationResult |
	compilationResult := string evaluate.  
	methods := organizer referencesToLiteral: compilationResult.
	queryResults := self methodServicesFrom: methods first.
	self setFirstReferenceUsing: queryResults and: methods.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
methodsContaining: string

	| methods |
	methods := organizer substringSearch: string.
	queryResults := self methodServicesFrom: methods first.
	self returnQueryToClient.
%

category: 'queries'
method: RowanQueryService
methodServicesFrom: methods

	| sorted | 
	sorted := SortedCollection sortBlock: [:x :y | x className = y className ifTrue:[x selector < y selector] ifFalse:[x className < y className]].
	sorted addAll: (methods collect:[:gsNMethod | 
			RowanMethodService forSelector: gsNMethod selector class: gsNMethod inClass thisClass meta: gsNMethod inClass isMeta organizer: organizer]).
	^sorted asArray
%

category: 'queries'
method: RowanQueryService
projectBranches: projectName

	| project  |
	project := (RwProject newNamed: projectName). 
	queryResults := Rowan gitTools gitbranchIn: project repositoryRootPath with: ''.
	RowanCommandResult addResult: self
%

category: 'queries'
method: RowanQueryService
projectLog: projectName

	queryResults := 
		(Rowan projectTools log
		commitLogProjectNamed: projectName
		limit: self defaultProjectLogSize).
	RowanCommandResult addResult: self.
%

category: 'queryResults'
method: RowanQueryService
queryResults

	"for tests. So far, not needed on server." 

	^queryResults
%

category: 'private'
method: RowanQueryService
returnQueryToClient

	queryResults do:[:service |
		RowanCommandResult addResult: service].
	RowanCommandResult addResult: self.
%

category: 'queries'
method: RowanQueryService
sendersOf: selector

	| methods |
	methods := organizer sendersOf: selector asSymbol.
	queryResults := self methodServicesFrom: methods first.
	self setFirstReferenceUsing: queryResults and: methods. 
	self returnQueryToClient.
%

category: 'queryResults'
method: RowanQueryService
setFirstReferenceUsing: results and: methods
  results
    do: [ :methodService | 
      | gsMethod index |
      gsMethod := methods first
        detect: [ :meth | 
          meth selector = methodService selector
            and: [ meth inClass thisClass name asString = methodService className ] ]
        ifNone: [ 
          methodService firstReference: nil.
          nil ].
      gsMethod
        ifNotNil: [ 
          index := methods first indexOf: gsMethod.
          methodService firstReference: (methods last at: index) ] ]
%

category: 'ston'
method: RowanQueryService
stonOn: stonWriter   
	| instanceVariableNames |
	instanceVariableNames := self class allInstVarNames reject: [:iv | self excludedInstVars includes: iv].
	stonWriter writeObject: self
		streamMap: 
			[:dictionary |
			instanceVariableNames do: 
					[:each |
					(self instVarAt: (self class allInstVarNames indexOf: each asSymbol))
						ifNotNil: [:value | dictionary at: each asSymbol put: value]
						ifNil: [self stonShouldWriteNilInstVars ifTrue: [dictionary at: each asSymbol put: nil]]]]
%

category: 'update'
method: RowanQueryService
updateInternalService: updatedService

	"when sending services back to the client,
	verify any services held by this object are 
	updated. Services know what internal services
	they contain." 
	1 to: queryResults size do:[:index |
		| service |
		service := queryResults at: index. 
		service = updatedService ifTrue:[ 
			queryResults at: index put: updatedService
		]].
%

! Class implementation for 'RowanTestService'

!		Instance methods for 'RowanTestService'

category: 'command'
method: RowanTestService
createNewTestProjectNamed: projectName

	| proj |
	proj := RwProjectDefinition newForGitBasedProjectNamed: projectName.
	proj repositoryRootPath: '$ROWAN_PROJECTS_HOME/', projectName.
	Rowan projectTools create createProjectFor: proj.
	Rowan projectTools load loadProjectDefinition: proj.
	^proj
%

! Class implementation for 'RowanVariableService'

!		Class methods for 'RowanVariableService'

category: 'other'
classmethod: RowanVariableService
oop: anInteger key: nameString value: valueString className: classNameString

	^self basicNew
		oop: anInteger key: nameString value: valueString className: classNameString;
		yourself
%

!		Instance methods for 'RowanVariableService'

category: 'other'
method: RowanVariableService
oop: anInteger key: nameString value: valueString className: classNameString

	oop := anInteger.
	key := nameString.
	value := valueString.
	className := classNameString.
%

! Class implementation for 'RowanServicePreferences'

!		Class methods for 'RowanServicePreferences'

category: 'accessing'
classmethod: RowanServicePreferences
current
	^(RwPlatform _userPlatformDictionary) 
		at: #RowanServicePrefs 
		ifAbsentPut: [ self new ]
%

!		Instance methods for 'RowanServicePreferences'

category: 'accessing'
method: RowanServicePreferences
defaultProjectName

	^defaultProjectName
%

category: 'accessing'
method: RowanServicePreferences
defaultProjectName: aString

	defaultProjectName := aString
%

! Class implementation for 'RwAbstractConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwAbstractConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwAbstractConfigurationPlatformAttributeMatcher
match: anObject

	self subclassResponsibility: #match:
%

category: 'matching'
method: RwAbstractConfigurationPlatformAttributeMatcher
matchString: aString

	self subclassResponsibility: #matchString:
%

category: 'matching'
method: RwAbstractConfigurationPlatformAttributeMatcher
matchVersion: anRwGemStoneVersionNumber

	self subclassResponsibility: #matchVersion:
%

category: 'accessing'
method: RwAbstractConfigurationPlatformAttributeMatcher
pattern: anObject
	pattern := anObject
%

category: 'accessing'
method: RwAbstractConfigurationPlatformAttributeMatcher
patternMatchBlock: aBlock
	patternMatchBlock := aBlock
%

! Class implementation for 'RwGemStoneVersionConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwGemStoneVersionConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwGemStoneVersionConfigurationPlatformAttributeMatcher
match: anObject

	^ anObject rwPlatformAttributeMatchForGemStoneVersion: self
%

category: 'matching'
method: RwGemStoneVersionConfigurationPlatformAttributeMatcher
matchString: aString

	^ false
%

category: 'matching'
method: RwGemStoneVersionConfigurationPlatformAttributeMatcher
matchVersion: aGemStoneVersion

	^ patternMatchBlock cull: pattern cull: aGemStoneVersion
%

! Class implementation for 'RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
matchVersion: aGemStoneVersion

	^ patternMatchBlock cull: pattern cull: aGemStoneVersion cull: pattern2
%

category: 'accessing'
method: RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
pattern2: anObject
	pattern2 := anObject
%

! Class implementation for 'RwStringConfigurationPlatformAttributeMatcher'

!		Instance methods for 'RwStringConfigurationPlatformAttributeMatcher'

category: 'matching'
method: RwStringConfigurationPlatformAttributeMatcher
match: anObject

	^ anObject rwPlatformAttributeMatchForString: self
%

category: 'matching'
method: RwStringConfigurationPlatformAttributeMatcher
matchString: aString

	^ patternMatchBlock cull: pattern cull: aString
%

category: 'matching'
method: RwStringConfigurationPlatformAttributeMatcher
matchVersion: aGemStoneVersion

	^ false
%

! Class implementation for 'RwAbstractProjectConfiguration'

!		Class methods for 'RwAbstractProjectConfiguration'

category: 'instance creation'
classmethod: RwAbstractProjectConfiguration
fromUrl: specNameOrUrl

	"self fromUrl: 'file:/home/dhenrich/rogue/_homes/rogue/_home/shared/repos/RowanSample1/configs/Default.ston'"

	| url |
	url := specNameOrUrl asRwUrl.
	url scheme isNil
		ifTrue: [ self error: 'scheme must be file: or https:' ].
	url scheme = 'file'
		ifTrue: [ 
			CypressFileUtilities current
				readStreamFor: url fileName
				in: url pathForDirectory
				do: [ :stream | ^ self _readStonFrom: stream ] ].
	url scheme asString = 'https'
		ifTrue: [ 
			| client response |
			GsSecureSocket disableCertificateVerificationOnClient.
			client := (Rowan globalNamed: 'ZnClient') new.
			response := client
				beOneShot;
				enforceHttpSuccess: true;
				get: url.
			^ self _readStonFrom: response decodeFromUTF8 ].
	self error: 'Unknown scheme: ' , url scheme printString
%

category: 'instance creation'
classmethod: RwAbstractProjectConfiguration
new

	^self basicNew initialize
%

category: 'instance creation'
classmethod: RwAbstractProjectConfiguration
newNamed: aName for: projectName

	^ self new
		name: aName;
		projectName: projectName;
		yourself
%

category: 'private'
classmethod: RwAbstractProjectConfiguration
_readStonFrom: stream

	| reader | 
	(reader := STONReader on: stream)
		allowComplexMapKeys: true.
	^reader next
		initializeForImport;
		yourself
%

!		Instance methods for 'RwAbstractProjectConfiguration'

category: 'visiting'
method: RwAbstractProjectConfiguration
acceptCompoundVisitor: aVisitor

	^ self subclassResponsibility: #acceptCompoundVisitor:
%

category: 'visiting'
method: RwAbstractProjectConfiguration
acceptNestedVisitor: aVisitor

	^ self subclassResponsibility: #acceptNestedVisitor:
%

category: 'visiting'
method: RwAbstractProjectConfiguration
acceptVisitor: aVisitor

	^ self subclassResponsibility: #acceptVisitor:
%

category: 'accessing'
method: RwAbstractProjectConfiguration
comment

   ^comment
%

category: 'initialization'
method: RwAbstractProjectConfiguration
comment: anObject

   comment := anObject
%

category: 'accessing'
method: RwAbstractProjectConfiguration
configurationNames

   ^ configurationNames ifNil: [ Array new ]
%

category: 'accessing'
method: RwAbstractProjectConfiguration
configurationNames: anObject

   configurationNames := anObject
%

category: 'private'
method: RwAbstractProjectConfiguration
currentVersion

	"
		0.1.0 - initial version for specs
	"

	"concrete subclasses, will override as needed"

	^ '0.1.0'
%

category: 'exporting'
method: RwAbstractProjectConfiguration
export

	|  exportUrl exportPath |
	exportPath := self _repositoryRootPath , '/' , self _configsPath , '/'.
	Rowan fileUtilities ensureDirectoryExists: exportPath.
	exportUrl := 'file:' , exportPath.
	^ self exportToUrl: exportUrl
%

category: 'exporting'
method: RwAbstractProjectConfiguration
exportToUrl: fileUrl

	^ self copy
		initializeForExport;
		_exportToUrl: fileUrl
%

category: 'initialization'
method: RwAbstractProjectConfiguration
initialize

	comment := ''.
	version := self currentVersion.
%

category: 'initialization'
method: RwAbstractProjectConfiguration
initializeForExport

	"if spec is to be exported, clear out any of the fields that represent state that should 
	not be shared"

	projectName := nil
%

category: 'initialization'
method: RwAbstractProjectConfiguration
initializeForImport

	"if spec has been imported, clear out any of the fields that represent state that should 
	not be shared"

	projectName := nil
%

category: 'accessing'
method: RwAbstractProjectConfiguration
name

   ^name
%

category: 'initialization'
method: RwAbstractProjectConfiguration
name: anObject

   name := anObject
%

category: 'accessing'
method: RwAbstractProjectConfiguration
projectName

   ^projectName
%

category: 'initialization'
method: RwAbstractProjectConfiguration
projectName: anObject

   projectName := anObject
%

category: 'load support'
method: RwAbstractProjectConfiguration
resolvePackageNames

	"return the list of package names that is the result of resolving all of the receiver's references"

	self subclassResponsibility: #'resolvePackageNames'
%

category: 'load support'
method: RwAbstractProjectConfiguration
resolvePackageNames: visitedConfigurationNames

	"return the list of package names that is the result of resolving all of the receiver's references.
		Do not visit configurations already listed in visitedConfigurationNames "

	self subclassResponsibility: #'resolvePackageNames:'
%

category: 'accessing'
method: RwAbstractProjectConfiguration
version
	"answer the version of the class --- used to mark the version of the class for objects written to disk"

	"see currentVersion method for list of versions"

	^ version
%

category: 'accessing'
method: RwAbstractProjectConfiguration
version: aString

	self error: 'Do not use version: ... the version should only be set when read from disk using STON'
%

category: 'private'
method: RwAbstractProjectConfiguration
_configsPath

	^ self _specification configsPath
%

category: 'exporting'
method: RwAbstractProjectConfiguration
_exportToUrl: fileUrl

	| url |
	url := fileUrl asRwUrl.
	url schemeName = 'file'
		ifTrue: [ 
			Rowan fileUtilities
				writeStreamFor: self name , '.ston'
				in: url pathForDirectory
				do: [ :stream | 
					| string |
					string := STON toStringPretty: self.
					stream nextPutAll: string.
					^ self ] ].
	^ nil	"otherwise a noop"
%

category: 'private'
method: RwAbstractProjectConfiguration
_loadedProject

	^ Rowan image loadedProjectNamed: self projectName
%

category: 'private'
method: RwAbstractProjectConfiguration
_repositoryRootPath

	^ self _specification repositoryRootPath
%

category: 'private'
method: RwAbstractProjectConfiguration
_repositoryUrl

	^ self _specification repositoryUrl
%

category: 'private'
method: RwAbstractProjectConfiguration
_specification

	^ self _loadedProject specification
%

! Class implementation for 'RwAbstractProjectLoadConfiguration'

!		Instance methods for 'RwAbstractProjectLoadConfiguration'

category: 'visiting'
method: RwAbstractProjectLoadConfiguration
acceptCompoundVisitor: aVisitor

	self error: 'project load configurations may not be nested inside of compound configurations'
%

category: 'private'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecMatchers

	conditionalPackageMapSpecMatchers ifNotNil: [:val | ^ val ]. 
	conditionalPackageMapSpecMatchers := Dictionary new.
	self conditionalPackageMapSpecs keysAndValuesDo: [:platformPattern :packageMapSpecsMap |
		conditionalPackageMapSpecMatchers
			at: (self _platformPatternMatcherFor: platformPattern)
			put: packageMapSpecsMap ].
	^ conditionalPackageMapSpecMatchers
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecs

	^ conditionalPackageMapSpecs ifNil: [ conditionalPackageMapSpecs := Dictionary new ]
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecsAtGemStoneUserId: userId 

	^ ((self conditionalPackageMapSpecs at: 'gemstone' ifAbsent: [ ^ Dictionary new ])
		at: userId ifAbsent: [ ^ Dictionary new ])
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecsAtGemStoneUserId: userId andPackageName: packageName

	^ (((self conditionalPackageMapSpecs at: 'gemstone' ifAbsent: [ ^ Dictionary new ])
		at: userId ifAbsentPut: [ ^ Dictionary new ])
			at: #packageNameToPlatformPropertiesMap ifAbsent: [ ^ Dictionary new ])
				at: packageName ifAbsent: [ ^ Dictionary new ]
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecsAtGemStoneUserId: userId andPackageName: packageName setSymbolDictNameTo: symbolDictName

	((((self conditionalPackageMapSpecs at: 'gemstone' ifAbsentPut: [ Dictionary new ])
		at: userId ifAbsentPut: [ Dictionary new ])
			at: #packageNameToPlatformPropertiesMap ifAbsentPut: [ Dictionary new ])
				at: packageName ifAbsentPut: [ Dictionary new ])
					at: 'symbolDictName' put: symbolDictName asString
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMapSpecsAtGemStoneUserId: userId setDefaultSymbolDictNameTo: defaultSymbolDictName

	((self conditionalPackageMapSpecs at: 'gemstone' ifAbsentPut: [ Dictionary new ])
		at: userId ifAbsentPut: [ Dictionary new ])
			at: #defaultSymbolDictName put: defaultSymbolDictName asString
%

category: 'private'
method: RwAbstractProjectLoadConfiguration
conditionalPackageMatchers

	conditionalPackageMatchers ifNotNil: [:val | ^ val ]. 
	conditionalPackageMatchers := Dictionary new.
	self conditionalPackages keysAndValuesDo: [:platformPatterns :groupMap |
		conditionalPackageMatchers
			at: (platformPatterns collect: [:pattern | self _platformPatternMatcherFor: pattern ])
			put: groupMap ].
	^ conditionalPackageMatchers
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackages

	^ conditionalPackages ifNil: [ conditionalPackages := Dictionary new ]
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackagesAtConditions: conditions andGroup: groupName

	| thePackageNameMap |
	thePackageNameMap := (self conditionalPackages at: conditions asArray sort ifAbsent: [ ^ Set new])
		at: groupName ifAbsent: [ ^ Set new ].
	^ (thePackageNameMap at: #packageNames ifAbsent: [ Set new ]) asSet
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
conditionalPackagesAtConditions: conditions andGroup: groupName addPackageNames: packageNames

	| thePackageNames thePackageNameMap |
	thePackageNameMap := (self conditionalPackages at: conditions asArray sort ifAbsentPut: [ Dictionary new])
		at: groupName ifAbsentPut: [ Dictionary new ].
	thePackageNames := (thePackageNameMap at: #packageNames ifAbsentPut: [ Set new ]) asSet.
	thePackageNames addAll: packageNames.
	thePackageNameMap at: #packageNames put: thePackageNames asArray sort
%

category: 'accessing'
method: RwAbstractProjectLoadConfiguration
definedGroupNames
	"Empty list by default"

	^ #()
%

category: 'initialization'
method: RwAbstractProjectLoadConfiguration
initializeForExport

	"if spec is to be exported, clear out any of the fields that represent state that should 
	not be shared"

	super initializeForExport.
	conditionalPackageMatchers :=  conditionalPackageMapSpecMatchers := nil
%

category: 'private'
method: RwAbstractProjectLoadConfiguration
_platformPatternMatcherFor: pattern

	" Returns an instance of RwAbstractConfigurationPlatformAttributeMatcher:
		RwStringConfigurationPlatformAttributeMatcher,
		RwGemStoneVersionConfigurationPlatformAttributeMatcher,
		or RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher
	"

	| versionPattern gsVersion1 gsVersion2 |
	(pattern beginsWith: 'gs')
		ifFalse: [ 
			"simple equality match"
			^ RwStringConfigurationPlatformAttributeMatcher new
					pattern: pattern;
					patternMatchBlock: [:a :b | a = b ];
					yourself ].
	"GemStone version pattern"
	versionPattern := (pattern copyFrom: 3 to: pattern size) substrings: '.'.
	(versionPattern last beginsWith: '[')
		ifTrue: [ 
			| vpSize rangePattern dashIndex |
			"range pattern"
			vpSize := versionPattern size.
			gsVersion1 := RwGemStoneVersionNumber new: vpSize .
			1 to: vpSize - 1
				do: [:index | gsVersion1 at: index put: (versionPattern at: index) asInteger ].
			gsVersion1 at: vpSize put: 0.
			rangePattern := (versionPattern at: vpSize) trimBoth.
			(((rangePattern at: 1) = $[) and: [ (rangePattern at: rangePattern size) = $] ])
				ifFalse: [ self error: 'Poorly formed GemStone version range pattern ', rangePattern printString, ' in ', pattern printString ].
			rangePattern := rangePattern copyFrom: 2 to: rangePattern size -1.
			dashIndex := rangePattern indexOf: $-.
			dashIndex <= 1
				ifTrue: [ self error: 'Invalid version range pattern missing range begin' , rangePattern printString, ' in ', pattern printString ].
			gsVersion1 at: vpSize put: (rangePattern copyFrom: 1 to: dashIndex -1) asInteger.
			dashIndex = rangePattern size
				ifTrue: [
					"open range"
					gsVersion2 := gsVersion1 copyFrom: 1 to: gsVersion1 size -1.
					gsVersion2 at: gsVersion2 size put: (gsVersion2 at: gsVersion2 size) + 1.
					^ RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher new
							pattern: gsVersion1;
							pattern2: gsVersion2;
							patternMatchBlock: [:a :b :c | (a <= b) & (b < c ) ];
							yourself ].
			"closed range"
			gsVersion2 := gsVersion1 copy.
			gsVersion2 at: vpSize put: (rangePattern copyFrom: dashIndex + 1 to: rangePattern size) asInteger.
			^ RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher new
					pattern: gsVersion1;
					pattern2: gsVersion2;
					patternMatchBlock: [:a :b :c | (a <= b) & (b <= c ) ];
					yourself ].
	versionPattern last = 'x' 
		ifFalse: [
			"specific version number match, use ="
			^ RwGemStoneVersionConfigurationPlatformAttributeMatcher new
					pattern: (pattern copyFrom: 3 to: pattern size) asRwGemStoneVersionNumber;
					patternMatchBlock: [:a :b | a = b ];
					yourself ].
	" 'gs', <gemstone-version-number> , '.x'"
	"match all values in x field"
	gsVersion1 := ((pattern copyFrom: 3 to: pattern size - 2), '.0') asRwGemStoneVersionNumber.
	gsVersion2 := gsVersion1 copyFrom: 1 to: gsVersion1 size - 1.
	gsVersion2 at: gsVersion2 size put: (gsVersion2 at: gsVersion2 size) + 1.
	^ RwGemStoneVersionRangeConfigurationPlatformAttributeMatcher new
			pattern: gsVersion1;
			pattern2: gsVersion2;
			patternMatchBlock: [:a :b :c | (a <= b) & (b < c ) ];
			yourself
%

! Class implementation for 'RwNestedProjectLoadConfiguration'

!		Instance methods for 'RwNestedProjectLoadConfiguration'

category: 'visiting'
method: RwNestedProjectLoadConfiguration
acceptNestedVisitor: aVisitor

	^aVisitor visitNestedProjectLoadConfiguration: self
%

category: 'visiting'
method: RwNestedProjectLoadConfiguration
acceptVisitor: aVisitor

	^self error: 'nested configuration cannot be used as a top-level configuration. The receiver is nested inside of project load configurations'
%

! Class implementation for 'RwProjectLoadConfiguration'

!		Instance methods for 'RwProjectLoadConfiguration'

category: 'visiting'
method: RwProjectLoadConfiguration
acceptVisitor: aVisitor

	^aVisitor visitProjectLoadConfiguration: self
%

category: 'accessing'
method: RwProjectLoadConfiguration
addDefinedGroupName: groupName 

	"add a group that does not include any other groups"

	self addDefinedGroupName: groupName includeGroups: #()
%

category: 'accessing'
method: RwProjectLoadConfiguration
addDefinedGroupName: groupName includeGroups: includedGroups

	"add a group that does not include any other groups"

	self definedGroupNames at: groupName put: includedGroups asArray sort
%

category: 'accessing'
method: RwProjectLoadConfiguration
definedGroupNames

	^ definedGroupNames ifNil: [ definedGroupNames :=  Dictionary new ]
%

category: 'accessing'
method: RwProjectLoadConfiguration
definedGroupNames: aColl

	definedGroupNames := aColl
%

! Class implementation for 'RwProjectCompoundConfiguration'

!		Instance methods for 'RwProjectCompoundConfiguration'

category: 'visiting'
method: RwProjectCompoundConfiguration
acceptCompoundVisitor: aVisitor

	^aVisitor visitProjectCompoundConfiguration: self
%

category: 'visiting'
method: RwProjectCompoundConfiguration
acceptVisitor: aVisitor

	^self acceptCompoundVisitor: aVisitor
%

category: 'initialization'
method: RwProjectCompoundConfiguration
initialize

	super initialize.
	packageNames := Set new.
%

category: 'accessing'
method: RwProjectCompoundConfiguration
packageNames

   ^packageNames
%

category: 'accessing'
method: RwProjectCompoundConfiguration
packageNames: anObject

   packageNames := anObject
%

category: 'load support'
method: RwProjectCompoundConfiguration
resolvePackageNames

	"return the list of package names that is the result of resolving all of the receiver's references"

	"resolve each of the configurations in configurationNames to a list of package names and combine
		with the receiver's package names"

	| visitedConfigurationNames |
	visitedConfigurationNames := Set new.
	^ self resolvePackageNames: visitedConfigurationNames
%

category: 'load support'
method: RwProjectCompoundConfiguration
resolvePackageNames: visitedConfigurationNames

	| thePackageNames |
	(visitedConfigurationNames includes: self name)
		ifTrue: [ ^ #() ].
	visitedConfigurationNames add: self name.
	thePackageNames := self packageNames copy.
	self _configurations
		do: [ :config | thePackageNames addAll: (config resolvePackageNames: visitedConfigurationNames) ].
	^ thePackageNames
%

category: 'private'
method: RwProjectCompoundConfiguration
_configurations

	| spec urlBase |
	self configurationNames isEmpty ifTrue: [ ^ #() ].
	spec := self _specification.
	urlBase := 'file:' , spec repositoryRootPath , '/' , spec configsPath , '/'.
	^ self configurationNames
		collect: [ :configName | 
			| url |
			url := urlBase , configName , '.ston'.
			(RwAbstractProjectConfiguration fromUrl: url)
				projectName: self projectName;
				yourself ]
%

! Class implementation for 'RwProjectConfiguration'

!		Class methods for 'RwProjectConfiguration'

category: 'instance creation'
classmethod: RwProjectConfiguration
fromSton: stonReader

	self deprecated: 'The class RwProjectConfiguration is deprecated. Use the class RwProjectCompoundConfiguration instead'.
	^ super fromSton: stonReader
%

category: 'instance creation'
classmethod: RwProjectConfiguration
fromUrl: specNameOrUrl

	self deprecated: 'The class RwProjectConfiguration is deprecated. Use the class RwProjectCompoundConfiguration instead'.
	^ super fromUrl: specNameOrUrl
%

category: 'instance creation'
classmethod: RwProjectConfiguration
newNamed: aName for: projectName


	self deprecated: 'The class RwProjectConfiguration is deprecated. Use the class RwProjectCompoundConfiguration instead'.
	^ super newNamed: aName for: projectName
%

!		Instance methods for 'RwProjectConfiguration'

category: 'configs'
method: RwProjectConfiguration
addConfig: configName

	self configNames add: configName
%

category: 'accessing'
method: RwProjectConfiguration
configNames

	^ configNames ifNil: [ configNames := Set new ]
%

category: 'accessing'
method: RwProjectConfiguration
configNames: anObject

   configNames := anObject
%

category: 'configs'
method: RwProjectConfiguration
removeConfig: configName

	self configNames remove: configName ivAbsent: [  ]
%

category: 'load support'
method: RwProjectConfiguration
resolvePackageNames

	"return the list of package names that is the result of resolving all of the receiver's references"

	"all of the names in configNames, should be package names"

	^ self configNames
%

category: 'load support'
method: RwProjectConfiguration
resolvePackageNames: visitedConfigurationNames

	| thePackageNames |
	(visitedConfigurationNames includes: self name)
		ifTrue: [ ^ #() ].
	visitedConfigurationNames add: self name.
	thePackageNames := self resolvePackageNames.
	^ thePackageNames
%

! Class implementation for 'RwAbstractTool'

!		Class methods for 'RwAbstractTool'

category: 'commands'
classmethod: RwAbstractTool
git

	^ RwGitTool new
%

!		Instance methods for 'RwAbstractTool'

category: 'class lookup'
method: RwAbstractTool
definitionsForClassExtensionNamed: className ifFound: foundBlock ifAbsent: absentBlock

	"validate loaded class extension registry structure"

	^ Rowan image
		loadedClassExtensionsNamed: className
		ifFound: [ :loadedClassExtensionSet | 
			loadedClassExtensionSet
				do: [ :loadedClassExtension | 
					| loadedPackage projectDef packageDef classExtensionDef |
					loadedPackage := loadedClassExtension loadedPackage.
					projectDef := loadedPackage loadedProject asDefinition.
					packageDef := projectDef packageNamed: loadedPackage name.
					classExtensionDef := packageDef classExtensions
						at: loadedClassExtension name.
					foundBlock value: classExtensionDef value: packageDef value: projectDef ].
			^ self ]
		ifAbsent: absentBlock
%

category: 'class lookup'
method: RwAbstractTool
definitionsForClassNamed: className ifFound: foundBlock ifAbsent: absentBlock

	Rowan image
		loadedClassNamed: className
		ifFound: [ :loadedClass | 
			| loadedPackage projectDef packageDef classDef |
			loadedPackage := loadedClass loadedPackage.
			projectDef := loadedPackage loadedProject asDefinition.
			packageDef := projectDef packageNamed: loadedPackage name.
			classDef := packageDef classDefinitions at: loadedClass name.
			^ foundBlock value: classDef value: packageDef value: projectDef ]
		ifAbsent: absentBlock
%

category: 'class lookup'
method: RwAbstractTool
definitionsForMethod: selector inClassNamed: className isMeta: isMeta ifFound: foundBlock ifAbsent: absentBlock

	^ Rowan image
		loadedMethod: selector
		inClassNamed: className
		isMeta: isMeta
		ifFound: [ :loadedMethod | 
			| loadedPackage loadedClass projectDef packageDef classDef classExtensionDef |
			loadedPackage := loadedMethod loadedPackage.
			loadedClass := loadedMethod loadedClass.
			projectDef := loadedPackage loadedProject asDefinition.
			packageDef := projectDef packageNamed: loadedPackage name.
			loadedClass isLoadedClass
				ifTrue: [ classDef := packageDef classDefinitions at: loadedClass name ]
				ifFalse: [ classExtensionDef := packageDef classExtensions at: loadedClass name ].
			foundBlock
				value: loadedMethod asDefinition
				value: classDef
				value: classExtensionDef
				value: packageDef
				value: projectDef.
			^ self ]
		ifAbsent: absentBlock
%

category: 'git'
method: RwAbstractTool
doGitCommit: messageString

	| gitTool gitRootPath commitMessageFileName status |
	gitTool := Rowan gitTools.
	gitRootPath := specification repoSpec repositoryRootPath.
	commitMessageFileName := gitTool createTmpFileWith: messageString.
	gitTool gitaddIn: gitRootPath with: '-A .'.
	gitTool gitcommitIn: gitRootPath with: '--file=' , commitMessageFileName.
	status := gitTool gitlogIn: gitRootPath with: '-1'.
	Transcript
		cr;
		show: '==============';
		cr;
		show: status.
	^ status
%

category: 'git'
method: RwAbstractTool
doGitUpdateLoadedCommitId

	| repoRootPath |
	repoRootPath := specification repoSpec repositoryRootPath.
	repoRootPath
		ifNil: [ 
			"in memory repo without a rootPath is legal"
			^ nil ].
	^ self doGitUpdateLoadedCommitId: repoRootPath
%

category: 'git'
method: RwAbstractTool
doGitUpdateLoadedCommitId: gitRootPath

	| gitTool loadedCommitId |
	gitTool := Rowan gitTools.
	loadedCommitId := [ gitTool gitcommitShaIn: gitRootPath ]
		on: Error
		do: [ :ignored | 
			"most likely no commits yet"
			^ nil ].
	^ specification imageSpec loadedCommitId: loadedCommitId
%

category: 'private'
method: RwAbstractTool
fileUtilities
  ^ Rowan fileUtilities
%

category: 'smalltalk api'
method: RwAbstractTool
help

	^self manPage asText
%

category: 'bash utilities'
method: RwAbstractTool
readlink: filepath

	"resolve (possible) symbolic links in filepath and return an absolute path"
	"NOTE: may need alternate solution on OSX"

	| command |
	command := self _sh_realpath_source, '; realpath ' , filepath.
	^Rowan gitTools performOnServer: command logging: true
%

category: 'smalltalk api'
method: RwAbstractTool
specification: aRwSpecification
  self validate: aRwSpecification.
  ^ specification := aRwSpecification
%

category: 'smalltalk api'
method: RwAbstractTool
specUrl: aString
  ^ self specification: (RwSpecification fromUrl: aString)
%

category: 'validation'
method: RwAbstractTool
validate: aRwSpecification
  aRwSpecification specName
    ifNil: [ self error: 'The specification must have a specName specified.' ]
%

category: 'validation'
method: RwAbstractTool
validateForRead: aRwSpecification
  aRwSpecification repositoryRootPath
    ifNil: [ 
      self
        error:
          'The repositoryRootPath must be defined in the specification: '
            , aRwSpecification specName printString ]
%

category: 'validation'
method: RwAbstractTool
validateForWrite: aRwSpecification
  aRwSpecification repositoryRootPath
    ifNil: [ 
      self
        error:
          'The repositoryRootPath must be defined in the specification: '
            , aRwSpecification specName printString ]
%

category: 'private'
method: RwAbstractTool
_sh_realpath_source

	"https://github.com/mkropat/sh-realpath/blob/master/realpath.sh"

	"all on one line because that's what our perform on server call wants - I think:)"

	^'realpath() { canonicalize_path "$(resolve_symlinks "$1")"; }; resolve_symlinks() { local dir_context path ; path=$(readlink -- "$1"); if [ $? -eq 0 ]; then dir_context=$(dirname -- "$1"); resolve_symlinks "$(_prepend_path_if_relative "$dir_context" "$path")"; else printf ''%s\n'' "$1"; fi; }; _prepend_path_if_relative() { case "$2" in /* ) printf ''%s\n'' "$2" ;; * ) printf ''%s\n'' "$1/$2" ;; esac; }; canonicalize_path() { if [ -d "$1" ]; then _canonicalize_dir_path "$1"; else _canonicalize_file_path "$1"; fi; }; _canonicalize_dir_path() { (cd "$1" 2>/dev/null && pwd -P); }; _canonicalize_file_path() { local dir file; dir=$(dirname -- "$1"); file=$(basename -- "$1"); (cd "$dir" 2>/dev/null && printf ''%s/%s\n'' "$(pwd -P)" "$file"); }'
%

category: 'private'
method: RwAbstractTool
_symbolDictionaryForSpecification

	^ Rowan image
		newOrExistingSymbolDictionaryNamed:
			(specification platformSpec at: 'gemstone') defaultSymbolDictName
%

! Class implementation for 'RwClassTool'

!		Class methods for 'RwClassTool'

category: 'commands'
classmethod: RwClassTool
clas
  ^ RwClsDiffTool new
%

! Class implementation for 'RwClsAuditTool'

!		Instance methods for 'RwClsAuditTool'

category: 'audit'
method: RwClsAuditTool
auditLoadedClass: aLoadedClass
"look for methods compiled into class without Rowan API"
| res  |

	res := self _result.
	(Rowan globalNamed: aLoadedClass name)  
		ifNil: [self errorLog: res add: aLoadedClass name -> 'Missing gemstone class for loaded class ' ] "there is no matching Class for LoadedClass"
		ifNotNil: [:aBehavior | 

			aBehavior == aLoadedClass handle
				ifFalse: [ 
					self
						errorLog: res
						add:
							aLoadedClass name
								->
									('loaded class (' , aLoadedClass handle asOop printString
									, ') not latest version of class ('
									, aBehavior asOop printString , ') ') ].

			"audit class properties"
			self errorLog: res addAll:  (self _auditLoadedClassProperties: aLoadedClass forBehavior: aBehavior).
			"audit categories"

			aBehavior categorysDo: [:category :selectors | 
				self errorLog: res addAll: (self  _auditCategory: category forBehavior: aBehavior loadedClass: aLoadedClass)
			].
			aBehavior class categorysDo: [:category :selectors | 
				self errorLog: res  addAll: (self  _auditCategory: category forBehavior: aBehavior class loadedClass: aLoadedClass)
			].
		"audit loaded class methods"
		aLoadedClass 
			loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClass :aLoadedMethod | (aBehavior compiledMethodAt: aLoadedMethod name otherwise: nil) 
					ifNil: [(self _auditLoadedInstanceMethod: aLoadedMethod forBehavior: aBehavior loadedClass: loadedClass) ifNotNil: [:a | self errorLog: res add: a]]]

			loadedClassMethodsDo: [:loadedProject :loadedPackage :loadedClass :aLoadedMethod |(aBehavior class compiledMethodAt: aLoadedMethod name otherwise: nil) 
					ifNil: [(self _auditLoadedClassMethod: aLoadedMethod forBehavior: aBehavior class loadedClass: loadedClass)  ifNotNil: [:a | self errorLog: res add: a]]
			]
	].
	^res
%

category: 'audit'
method: RwClsAuditTool
errorLog: aResult add: aMessage	
"add error to results. print to file"
	aResult add: aMessage.
	GsFile gciLogServer: aMessage value asString,'  ', aMessage key asString.
	Notification signal: aMessage value asString,'  ', aMessage key asString.
%

category: 'audit'
method: RwClsAuditTool
errorLog: aResult addAll: aCol	
"add all messages to result"
	aCol do: [:e | self errorLog: aResult add: e].
%

category: 'audit'
method: RwClsAuditTool
_asClassPrefix: aBoolean

	^aBoolean ifTrue: ['class' ] ifFalse: ['']
%

category: 'audit'
method: RwClsAuditTool
_auditCategory: category forBehavior: aBehavior loadedClass: aLoadedClass
	| aPackage |
		"must be an extension. Do basic checks"
	aPackage := (category copyFrom: 2 to: category size).

	^category first == $*	ifTrue: ["must be an extension category. See if package exists"
		(aPackage asLowercase isEquivalent: aBehavior rowanPackageName asLowercase) 
			ifTrue: [{aLoadedClass name , ' #' , category asString -> 'Extension category name can not be same as class package' }]
			ifFalse: [
				(Rowan image loadedClassExtensionsNamed: aBehavior thisClass name 
					ifFound: [:extensions | extensions detect: [:e | e loadedPackage name asLowercase isEquivalent: aPackage] ifNone: [nil]] 
					ifAbsent: [nil]) isNil 
						ifTrue: [ | res | 
									res := self _auditCategory: category selectors: (aBehavior selectorsIn: category)  forBehavior: aBehavior loadedClass: aLoadedClass		.
									"res add: (aLoadedClass name , ' #' , category asString -> 'Class Extension is not present in the package '); 
									yourself"
						] 
						ifFalse: [{}"no basic extension problems found, class extension will be audited separately"]
			]
	] ifFalse: [
		self _auditCategory: category selectors: (aBehavior selectorsIn: category)  forBehavior: aBehavior loadedClass: aLoadedClass		
	]
%

category: 'audit'
method: RwClsAuditTool
_auditCategory: category selectors: aSelectorSet forBehavior: aBehavior loadedClass: aLoadedClass
	|  res |
	
		res := res := self _result.

		aSelectorSet do: [:aSelector |
				(
					aBehavior isMeta
						ifTrue: [	self  _auditClassSelector: aSelector forBehavior: aBehavior loadedClass: aLoadedClass ]
						ifFalse: [ self  _auditSelector: aSelector forBehavior: aBehavior loadedClass: aLoadedClass]	
				)  ifNotNil: [:aRes | self errorLog: res add: aRes]
				
		].

		^res
%

category: 'audit'
method: RwClsAuditTool
_auditClassSelector: aSelector forBehavior: aBehavior loadedClass: aLoadedClass
"audit a selector. verify compiled method matches loaded method reference return nil if no problem found"

	^(aLoadedClass loadedMethodAt: aSelector isMeta:  true)
			ifNil: [(aLoadedClass name ,  ' >> ', aSelector) -> 'Missing loaded classmethod '.]
			ifNotNil: [:aLoadedMethod |
				(aBehavior compiledMethodAt: aSelector  otherwise: nil) == aLoadedMethod handle
						ifTrue: [
							((aLoadedMethod propertyAt: 'protocol') equalsNoCase: (aBehavior categoryOfSelector:  aSelector ) ) 
								ifTrue: [nil]
								ifFalse: [aLoadedClass name , '#', (aLoadedMethod propertyAt: 'protocol') -> 'Missing class method category for loaded class']
						] 
						ifFalse: [(aLoadedClass name ,  ' >> ', aSelector) -> 'Compiled classmethod is not identical to loaded class method ']
			]
%

category: 'audit'
method: RwClsAuditTool
_auditLoadedClassMethod: aLoadedMethod forBehavior: aClassOrMeta loadedClass: aLoadedClassOrExtension
"verify that compiled method is present for each loaded class method. return nil if no error"
"we already check verifying selectors that compiled method matches loaded method"

		^( aClassOrMeta compiledMethodAt: aLoadedMethod name  otherwise: nil) 
				ifNil: [(aLoadedClassOrExtension name ,  ' >> ', aLoadedMethod name) -> 'Missing compiled class method. ' ]
				ifNotNil: [:aMethod | aMethod == aLoadedMethod handle 
						ifTrue: [((aLoadedMethod propertyAt: 'protocol') equalsNoCase: (aClassOrMeta categoryOfSelector: aMethod selector) ) 
							ifTrue: [nil]
							ifFalse: [aLoadedClassOrExtension name , '#', (aLoadedMethod properties at: 'protocol') -> 'Missing class method category for loaded class']
						]
						ifFalse: [(aClassOrMeta name ,  ' >> ', aLoadedMethod name) -> 'Compiled class method is not identical to loaded class method. ']		
			]
%

category: 'audit'
method: RwClsAuditTool
_auditLoadedClassProperties: aLoadedClass forBehavior: aBehavior
"Check #( 'instvars', 'superclass', 'classinstvars',  'gs_SymbolDictionary', 'comment', 'classvars', 'pools', 'category')"

	| res  aDict |
	res :=  self _result.
	((aLoadedClass propertyAt: 'superclass') isEquivalent: aBehavior superclass name ) 
		ifFalse: [self errorLog: res  add: aLoadedClass name -> 'Superclass is different from loaded class'].
	((aLoadedClass propertyAt: 'instvars') = (aBehavior instVarNames collect: [:e | e asString]) ) 
			ifFalse: [self errorLog: res  add: aLoadedClass name -> 'instVarNames changed in compiled class v loaded class'].
	((aLoadedClass propertyAt: 'classvars') = ((aBehavior.classVars ifNil: [SymbolDictionary new]) 
			keys collect: [:e | e asString]) asSortedCollection asArray) ifFalse: [
				self errorLog: res  add: aLoadedClass name -> 'ClassVars changed in compiled class v loaded class'].
	((aLoadedClass propertyAt: 'pools') = ((aBehavior.poolDictionaries ifNil: [Array new]) collect: [:e | e asString]) ) 
			ifFalse: [self errorLog: res  add: aLoadedClass name -> 'PoolDictionaries changed in compiled class v loaded class'].
	((aLoadedClass propertyAt: 'comment' ifAbsent: ['']) isEquivalent: aBehavior rwComment ) 
			ifFalse: [self errorLog: res  add: aLoadedClass name -> 'Comment has changed in compiled class v loaded class'].
	((aLoadedClass propertyAt: 'category') = aBehavior category ) 
			ifFalse: [self errorLog: res  add: aLoadedClass name -> 'Class category has changed in compiled class v loaded class'].
	(aDict := System myUserProfile resolveSymbol: (aLoadedClass propertyAt: 'gs_SymbolDictionary') asSymbol ) 
			ifNil: [self errorLog: res  add: aLoadedClass name -> ('Unable to find SymbolDictionary ' ,(aLoadedClass propertyAt: 'gs_SymbolDictionary'))] 
			ifNotNil: [:smbd | smbd value at: aLoadedClass name asSymbol 
					ifAbsent: [self errorLog: res  add: aLoadedClass name -> 'Compiled class not found in symbol dictionary of loaded class']] .

	^res
%

category: 'audit'
method: RwClsAuditTool
_auditLoadedInstanceMethod: aLoadedMethod forBehavior: aClassOrMeta loadedClass: aLoadedClassOrExtension
"verify that compiled method is present for each loaded instance method. return nil if no error"
"we already check verifying selectors that compiled method matches loaded method"

		^( aClassOrMeta compiledMethodAt: aLoadedMethod name  otherwise: nil) 
				ifNil: [(aLoadedClassOrExtension name ,  ' >> ', aLoadedMethod name) -> 'Missing compiled instance method. ' ]
				ifNotNil: [:aMethod | aMethod == aLoadedMethod handle 
						ifTrue: [((aLoadedMethod propertyAt: 'protocol') equalsNoCase: (aClassOrMeta categoryOfSelector: aMethod selector) ) 
							ifTrue: [nil]
							ifFalse: [aLoadedClassOrExtension name , '#', (aLoadedMethod propertyAt: 'protocol') -> 'Missing method category for loaded class. ']
						]
						ifFalse: [(aClassOrMeta name ,  ' >> ', aLoadedMethod name) -> 'Compiled instance method is not identical to loaded instance method. ']		
			]
%

category: 'audit'
method: RwClsAuditTool
_auditSelector: aSelector forBehavior: aBehavior loadedClass: aLoadedClass
"audit an instance selector. return nil if no problem found"

	^(aLoadedClass loadedMethodAt: aSelector isMeta:  aBehavior isMeta)
			ifNil: [(aLoadedClass name ,  ' >> ', aSelector) -> 'Missing loaded instance method. '.]
			ifNotNil: [:aLoadedMethod |
				(aBehavior compiledMethodAt: aSelector  otherwise: nil) == aLoadedMethod handle
						ifTrue: [
							((aLoadedMethod propertyAt: 'protocol') equalsNoCase: (aBehavior categoryOfSelector:   aSelector ) ) 
								ifTrue: [nil]
								ifFalse: [aLoadedClass name , '#', (aLoadedMethod propertyAt: 'protocol') -> 'Missing instance method category for loaded class']
						] 
						ifFalse: [(aLoadedClass name ,  ' >> ', aSelector) -> 'Compiled instance method is not identical to loaded method. ']
			]
%

category: 'audit'
method: RwClsAuditTool
_result

	^Array new.
%

! Class implementation for 'RwClsExtensionAuditTool'

!		Instance methods for 'RwClsExtensionAuditTool'

category: 'other'
method: RwClsExtensionAuditTool
auditLoadedClassExtension: aLoadedClassExtension
"look for methods compiled into class without Rowan API"
| res   extensionCategoryName|

	res := self _result.
	extensionCategoryName :=  aLoadedClassExtension loadedPackage asExtensionName "'*' , aLoadedClassExtension loadedPackage name" .
	(Rowan globalNamed: aLoadedClassExtension name) 
		ifNil: [self errorLog: res  add: aLoadedClassExtension name -> ' Class does not exists for loaded class '] 
		ifNotNil: [:aBehavior ||categories | 
					
				aBehavior == aLoadedClassExtension handle
					ifFalse: [ 
						self
							errorLog: res
							add:
								(aLoadedClassExtension name , ' #' , extensionCategoryName)
									->
										(' loaded extension class (' , aLoadedClassExtension handle asOop printString
										, ') not latest version of class ('
										, aBehavior asOop printString , ') ') ].

				categories := aBehavior rwMethodCategories
					ifNil: [ #() ]
					ifNotNil: [ :catDict | catDict keys ].
				(categories	
					detect: [:each | each equalsNoCase: extensionCategoryName ] ifNone: [ ])
						ifNotNil: [:aCategory | self errorLog: res  addAll:  (self _auditCategory: aCategory forBehavior: aBehavior loadedClass: aLoadedClassExtension)]
						ifNil: [aLoadedClassExtension loadedInstanceMethods notEmpty ifTrue: [
							self errorLog: res add: aLoadedClassExtension name , ' #' ,extensionCategoryName -> 'Missing instance method extension category ']
			].


				categories := aBehavior class rwMethodCategories
					ifNil: [ #() ]
					ifNotNil: [ :catDict | catDict keys ].
			(categories
				detect: [:each | each equalsNoCase: extensionCategoryName ] ifNone: [ ])
					ifNotNil: [:aCategory | self errorLog: res  addAll:  (self _auditCategory: aCategory forBehavior: aBehavior class loadedClass: aLoadedClassExtension)]
					ifNil: [aLoadedClassExtension loadedClassMethods notEmpty ifTrue: [
						self errorLog: res add: aLoadedClassExtension name , ' #' ,extensionCategoryName -> 'Missing class method extension category ']
			].

		
			aLoadedClassExtension 
				loadedInstanceMethodsDo: [:loadedProject :loadedPackage :loadedClass :aLoadedMethod | 
					(self _auditLoadedInstanceMethod: aLoadedMethod forBehavior: aBehavior loadedClass: loadedClass) ifNotNil: [:x | self errorLog: res add: x]
				] 
				loadedClassMethodsDo: [:loadedProject :loadedPackage :loadedClass :aLoadedMethod |
					(self _auditLoadedClassMethod: aLoadedMethod forBehavior: aBehavior class loadedClass: loadedClass) ifNotNil: [:x |self errorLog: res add: x]
				]
		].
		^res
%

category: 'other'
method: RwClsExtensionAuditTool
_auditCategory: anExtentionCategory forBehavior: aClassOrMeta loadedClass: aLoadedClassExtension
"if we have loaded methods but no compiled methods add error to result"
| res |
	res := super _auditCategory: anExtentionCategory selectors:  (aClassOrMeta selectorsIn: anExtentionCategory) forBehavior: aClassOrMeta loadedClass: aLoadedClassExtension.
	aClassOrMeta isMeta 
		ifTrue: [
			(aLoadedClassExtension loadedClassMethods notEmpty and: [(aClassOrMeta selectorsIn: anExtentionCategory) isEmpty])
				ifTrue: [ self errorLog: res  add: ((aLoadedClassExtension name , ' #' ,anExtentionCategory asString -> 'Missing expected class methods in the category '))   ].
	] 	ifFalse: [
			(aLoadedClassExtension loadedInstanceMethods notEmpty and: [(aClassOrMeta selectorsIn: anExtentionCategory) isEmpty])
				ifTrue: [ self errorLog: res  add: (aLoadedClassExtension name , ' #' ,anExtentionCategory asString -> ('Missing expected instances methods in the category'))   ].
	].
	^res
%

! Class implementation for 'RwGitTool'

!		Instance methods for 'RwGitTool'

category: 'smalltalk api'
method: RwGitTool
createTmpFileWith: fileContents

	| file filename |
	filename := (self performOnServer: '/bin/mktemp --tmpdir commitMessage.XXXX' logging: true) trimRight.
	[ 
	| count |
	file := GsFile openWriteOnServer: filename.
	(count := file nextPutAll: fileContents withGemstoneLineEndings)
		ifNil: [ self error: 'failed write' ] ]
		ensure: [ file close ].
	^ filename
%

category: 'smalltalk api'
method: RwGitTool
gitaddIn: gitRepoPath with: args

	^ self performGitCommand: 'add' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitbranchIn: gitRepoPath with: args

	^ self performGitCommand: 'branch' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitBranchNameIn: gitRepoPath

	"return current branch for git repository located at gitPath"

	| command result |
	command := 'set -e; cd ' , gitRepoPath , ';git branch | sed -n ''/\* /s///p'''.
	result := self performOnServer: command logging: false.
	^ result trimWhiteSpace
%

category: 'smalltalk api'
method: RwGitTool
gitcheckoutIn: gitRepoPath with: args

	^ self performGitCommand: 'checkout' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitcloneIn: gitRootPath with: args

	^ self gitcloneIn: gitRootPath with: args logging: true
%

category: 'smalltalk api'
method: RwGitTool
gitcloneIn: gitRootPath with: gitArgs logging: logging

	| commandBase command gitCommand |
	gitCommand := 'clone'.
	commandBase := 'set -e; cd ' , gitRootPath , '; git ' , gitCommand , ' '.
	command := commandBase , gitArgs.
	^ self performOnServer: command logging: logging
%

category: 'smalltalk api'
method: RwGitTool
gitcommitIn: gitRepoPath with: args

	^ self performGitCommand: 'commit' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitcommitShaIn: gitRepoPath

	| result |
	gitRepoPath ifNil: [ ^ '' ].
	result := self gitlogIn: gitRepoPath with: ' -1 --pretty=format:%h '.
	(result beginsWith: 'fatal:')
		ifTrue: [ ^ nil ].
	^ result trimWhiteSpace
%

category: 'smalltalk api'
method: RwGitTool
gitinitIn: dirPath with: args

	| command |
	command := 'set -e; cd ' , dirPath , '; git init ' , args.
	^ self performOnServer: command logging: true
%

category: 'smalltalk api'
method: RwGitTool
gitlogFull: commitish limit: limit gitRepoDirectory: gitRepoPath

	| commitLog |
	commitLog := self
		gitlogIn: gitRepoPath
		with: ' -' , limit printString , ' ' , commitish.
	^ commitLog
%

category: 'smalltalk api'
method: RwGitTool
gitlogIn: gitRepoPath with: args

	^ self performGitCommand: 'log' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitlogtool: commitish limit: limit gitRepoDirectory: gitRepoPath

	^ self
		gitlogIn: gitRepoPath
		with:
			'--date=relative --format="%h %cd %s" -' , limit printString , ' ' , commitish
%

category: 'smalltalk api'
method: RwGitTool
gitPresentIn: gitRepoPath

	| gitHome command cdResponse |
	[ 
	gitHome := self gitrevparseShowTopLevelIn: gitRepoPath.
	command := 'set -e; cd ' , gitRepoPath , '; pwd'.
	cdResponse := self performOnServer: command logging: true ]
		on: Error
		do: [ :ex | ^ false ].
	^ (self readlink: gitHome) = (self readlink: cdResponse)
%

category: 'smalltalk api'
method: RwGitTool
gitpullIn: gitRepoPath

	^ self gitpullIn: gitRepoPath with: ''
%

category: 'smalltalk api'
method: RwGitTool
gitpullIn: gitRepoPath remote: remoteName branch: branchName

	^ self gitpullIn: gitRepoPath with: remoteName , ' ' , branchName
%

category: 'smalltalk api'
method: RwGitTool
gitpullIn: gitRepoPath with: args

	^ self performGitCommand: 'pull' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitpushIn: gitRepoPath remote: remoteName branch: branchName

	^ self gitpushIn: gitRepoPath with: remoteName , ' ' , branchName
%

category: 'smalltalk api'
method: RwGitTool
gitpushIn: gitRepoPath with: args

	^ self performGitCommand: 'push' in: gitRepoPath with: args
%

category: 'smalltalk api'
method: RwGitTool
gitrevparseShowTopLevelIn: dirPath

	| command |
	command := 'set -e; cd ' , dirPath , '; git rev-parse --show-toplevel'.
	^ self performOnServer: command logging: true
%

category: 'smalltalk api'
method: RwGitTool
gitstatusIn: gitRepoPath with: args

	^ self performGitCommand: 'status' in: gitRepoPath with: args
%

category: 'private'
method: RwGitTool
performGitCommand: gitCommand in: gitRepoPath with: gitArgs

	^ self
		performGitCommand: gitCommand
		in: gitRepoPath
		worktree: gitRepoPath
		with: gitArgs
		logging: true
%

category: 'private'
method: RwGitTool
performGitCommand: gitCommand in: gitRepoPath worktree: workTreePath with: gitArgs logging: logging

	"unconditional cd to work-tree because of git pull problem with git prior to 1.7.7.2"

	| commandBase command |
	commandBase := 'set -e; cd ' , workTreePath , '; git --git-dir ' , gitRepoPath
		, '/.git --work-tree ' , workTreePath , ' ' , gitCommand , ' '.
	command := commandBase , gitArgs.
	^ self performOnServer: command logging: logging
%

category: 'private'
method: RwGitTool
performOnServer: commandLine logging: logging
  | result |
  result := self
    performOnServer: commandLine
    status: [ :performOnServerStatusArray | 
      "Array of 5 elements: 
       raw status Integer, 
       child process status Integer (after WEXITSTATUS macro applied), 
       result String (or nil if operation failed) ,
       error string from script file write, fork, or result file read ,
       errno value, a SmallInteger from file write, fork, or file read"
      (performOnServerStatusArray at: 1) ~~ 0
        ifTrue: [ 
          | message |
          message := 'performOnServer: ' , commandLine printString , ' stdout: '
            , (performOnServerStatusArray at: 3) printString
            , ' failed with status: '
            , (performOnServerStatusArray at: 1) printString , ' errno: '
            , (performOnServerStatusArray at: 5) printString , ' errStr: '
            , (performOnServerStatusArray at: 4) asString.
          self error: message ].
      performOnServerStatusArray at: 3 ].
  logging
    ifTrue: [ 
      Transcript
        cr;
        show: commandLine printString;
        cr;
        show: result ].
  ^ result
%

category: 'private'
method: RwGitTool
performOnServer: commandLine status: statusBlock
  | performOnServerStatusArray |
  performOnServerStatusArray := System _performOnServer: commandLine.
  ^ statusBlock value: performOnServerStatusArray
%

! Class implementation for 'RwPackageTool'

!		Class methods for 'RwPackageTool'

category: 'commands'
classmethod: RwPackageTool
adopt
  ^ RwPkgAdoptTool new
%

category: 'commands'
classmethod: RwPackageTool
audit
  ^ RwPkgAuditTool new
%

category: 'commands'
classmethod: RwPackageTool
commit
  ^ RwPkgCommitTool new
%

category: 'commands'
classmethod: RwPackageTool
copy
  ^ RwPkgCopyTool new
%

category: 'commands'
classmethod: RwPackageTool
create
  ^ RwPkgCreateTool new
%

category: 'commands'
classmethod: RwPackageTool
diff
  ^ RwPkgDiffTool new
%

category: 'commands'
classmethod: RwPackageTool
disown
  ^ RwPkgDisownTool new
%

category: 'commands'
classmethod: RwPackageTool
edit

	^ RwPkgEditTool new
%

category: 'commands'
classmethod: RwPackageTool
install
	^ RwPkgInstallTool new
%

category: 'commands'
classmethod: RwPackageTool
list
  ^ RwPkgListTool new
%

category: 'commands'
classmethod: RwPackageTool
load
  ^ RwPkgLoadTool new
%

category: 'commands'
classmethod: RwPackageTool
move
  ^ RwPkgMoveTool new
%

category: 'commands'
classmethod: RwPackageTool
read
	^ RwPkgReadTool new
%

category: 'commands'
classmethod: RwPackageTool
recompile
  ^ RwPkgRecompileTool new
%

category: 'commands'
classmethod: RwPackageTool
remove
  ^ RwPkgRemoveTool new
%

category: 'commands'
classmethod: RwPackageTool
rename
  ^ RwPkgRenameTool new
%

category: 'commands'
classmethod: RwPackageTool
revert
  ^ RwPkgRevertTool new
%

category: 'commands'
classmethod: RwPackageTool
write
  ^ RwPkgWriteTool new
%

! Class implementation for 'RwPkgAdoptTool'

!		Instance methods for 'RwPkgAdoptTool'

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassExtensionNamed: className  instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName

	"adopt extension methods for the class named <className> into the package named <packageName>"

	self 
		adoptClassNamed: className 
		classExtension: true 
		instanceSelectors: instanceSelectors 
		classSelectors: classSelectors 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassNamed: className classExtension: classExtension instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName

	"adopt the methods for class named <className> and it's methods into the package named <packageName>, 
		if it is not a <classExtension>, adopt the class into the package as well."

	"Ignore packaged instance and class methods"

	| loadedPackage loadedProject gemstoneSpec packageSymDictName theClass theSymbolDictionary registry 
		theBehavior |
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	
	gemstoneSpec := loadedProject specification platformSpec at: 'gemstone'.
	packageSymDictName := (gemstoneSpec symbolDictNameForPackageNamed: packageName) asSymbol.

	theClass := Rowan globalNamed: className.
	(Rowan image symbolList dictionariesAndSymbolsOf: theClass)
		do: [:ar |
			(ar at: 1) name == packageSymDictName
				ifTrue: [ theSymbolDictionary := (ar at: 1). ] ].
	theSymbolDictionary 
		ifNil: [ 
			self error: 'The symbol dictionary for class ', 
				className printString, 
				' does not match the symbol dictionary for the package ', 
				packageName printString, 
				'. REQUIRED.'.]. 

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	classExtension
		ifFalse: [
			[ registry
				addClassAssociation: (theSymbolDictionary associationAt: theClass name) 
				forClass: theClass 
				toPackageNamed: packageName ]
					on: RwExistingAssociationWithSameKeyNotification
					do: [:ex | ex resume ] ].

	theBehavior := theClass.
	instanceSelectors do: [:methodSelector |
		| theCompiledMethod |
		theCompiledMethod := theBehavior compiledMethodAt: methodSelector.
		registry
			adoptCompiledMethod: theCompiledMethod
			classExtension: classExtension
			for: theBehavior 
			protocol: (theBehavior categoryOfSelector: methodSelector) 
			toPackageNamed: packageName ].

	theBehavior := theClass class.
	classSelectors do: [:methodSelector |
		| theCompiledMethod |
		theCompiledMethod := theBehavior compiledMethodAt: methodSelector.
		registry
			adoptCompiledMethod: theCompiledMethod 
			classExtension: classExtension
			for: theBehavior 
			protocol: (theBehavior categoryOfSelector: methodSelector) 
			toPackageNamed: packageName ].
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassNamed: className  instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: packageName

	"adopt the class named <className> and it's methods into the package named <packageName>"

	"Ignore packaged instance and class methods"
	
	self 
		adoptClassNamed: className 
		classExtension: false 
		instanceSelectors: instanceSelectors 
		classSelectors: classSelectors 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptClassNamed: className  intoPackageNamed: packageName

	"adopt the class named <className> and it's methods into the package named <packageName>"

	"Ignore packaged instance and class methods"

	| theClass |

	theClass := Rowan globalNamed: className.
	self 
		adoptClassNamed: className 
		instanceSelectors: theClass selectors 
		classSelectors: theClass class selectors 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptMethod: methodSelector inClassNamed: className  isMeta: isMeta intoPackageNamed: packageName

	"adopt the method <methodSelector> in class named <className> and it's methods into the package named <packageName>"

	| theClass theBehavior protocolString  |
	theClass := Rowan globalNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].
	protocolString := (theBehavior categoryOfSelector: methodSelector asSymbol) asString. 
	self 
		adoptMethod: methodSelector 
		protocol: protocolString 
		inClassNamed: className  
		isMeta: isMeta 
		intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptMethod: methodSelector protocol: protocolString inClassNamed: className  isMeta: isMeta intoPackageNamed: packageName

	"adopt the method <methodSelector> in class named <className> and it's methods into the package named <packageName>.
		move the method into protocol <protocolString> "

	| loadedPackage loadedProject gemstoneSpec packageSymDictName theClass theSymbolDictionary registry 
		theBehavior theCompiledMethod |
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	gemstoneSpec := loadedProject specification platformSpec at: 'gemstone'.
	packageSymDictName := gemstoneSpec symbolDictNameForPackageNamed: packageName.

	theClass := Rowan globalNamed: className.
	theSymbolDictionary := Rowan globalNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].

	theCompiledMethod := theBehavior compiledMethodAt: methodSelector.

	theCompiledMethod rowanProjectName = Rowan unpackagedName
		ifFalse: [ self error: 'The method ', className printString, '>>', methodSelector asString, ' is already packaged ... no need to adopt' ].

	theClass  rowanPackageName ~= packageName
		ifTrue: [ 
			registry
				addExtensionCompiledMethod: theCompiledMethod 
				for: theBehavior 
				protocol: protocolString 
				toPackageNamed: packageName ]
		ifFalse: [ 
			registry
				adoptCompiledMethod: theCompiledMethod 
				classExtension: false
				for: theBehavior 
				protocol: protocolString
				toPackageNamed: packageName ].
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolDictionary: symbolDictionary intoPackageNamed: packageName

	"create loaded classes in the loaded package <packageName> for the unpackaged classes in <symbolDictionary>"

	symbolDictionary keysAndValuesDo: [:className :object |
		object isBehavior
			ifTrue: [ 
				object rowanPackageName = Rowan unpackagedName
					ifTrue: [ self adoptClassNamed: className asString intoPackageNamed: packageName ] ] ]
.
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolDictionaryNamed: symDictName intoPackageNamed: packageName

	"create loaded classes in the loaded package <packageName> for the unpackaged classes in the symbol dictionary named <symDictName>"

	^ self adoptSymbolDictionary: (Rowan globalNamed: symDictName) intoPackageNamed: packageName
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolList: symbolList excluding: excludedSymbolDictionaries intoPackagesNamed: packageNameMap

	"create loaded classes for the unpackaged classes in each of the symbol dictionaries in symbolList, except for those listed in
		<excludedSymbolDictionaries>. The loaded classes should be created in the package associated with the name of the symbol 
		dictionary in <packageNameMap>"

	symbolList do: [:symbolDict |
		(excludedSymbolDictionaries includes: symbolDict)
			ifFalse: [ self adoptSymbolDictionary: symbolDict intoPackageNamed: (packageNameMap at: symbolDict name asString) ] ]
%

category: 'smalltalk api'
method: RwPkgAdoptTool
adoptSymbolList: symbolList excludingSymbolDictsNamed: excludedSymbolDictionaryNames intoPackagesNamed: packageNameMap

	"create loaded classes for the unpackaged classes in each of the symbol dictionaries in symbolList, except for those named in
		<excludedSymbolDictionaryNames>. The loaded classes should be created in the package associated with the name of the symbol 
		dictionary in <packageNameMap>"

	symbolList do: [:symbolDict |
		| symDictName |
		symDictName := symbolDict name asString.
		(excludedSymbolDictionaryNames includes: symDictName)
			ifFalse: [ self adoptSymbolDictionary: symbolDict intoPackageNamed: (packageNameMap at: symDictName) ] ]
%

! Class implementation for 'RwPkgCreateTool'

!		Instance methods for 'RwPkgCreateTool'

category: 'smalltalk api'
method: RwPkgCreateTool
createLoadedPackageNamed: packageName inProjectNamed: projectName

	"create a loaded package named <packageName> in the loaded project named <projectName>"

	| spec registry theSymbolDictionary packageSymDictName gemstoneSpec loadedPackage loadedProject |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	spec := loadedProject specification.
	gemstoneSpec := spec platformSpec at: 'gemstone'.
	packageSymDictName := gemstoneSpec symbolDictNameForPackageNamed: packageName.
	theSymbolDictionary := Rowan image newOrExistingSymbolDictionaryNamed: packageSymDictName.
	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.
	loadedPackage := registry newLoadedPackageNamed: packageName.
	loadedProject addLoadedPackage: loadedPackage.
%

! Class implementation for 'RwPkgDiffTool'

!		Instance methods for 'RwPkgDiffTool'

category: 'smalltalk api'
method: RwPkgDiffTool
patchForPackageName: packageName

	| loadedPackage loadedProject repo diskSnapshot imageSnapshot |
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.
	super specification: loadedProject specification.
	repo := specification repositoryUrl asRwRepository.
	diskSnapshot := (repo readPackageStructureForPackageNamed: packageName)
		snapshot.
	imageSnapshot := (RwCypressPackageStructure
		fromPackage: loadedPackage asDefinition) snapshot.
	^ CypressPatch fromBase: diskSnapshot toTarget: imageSnapshot
%

category: 'smalltalk api'
method: RwPkgDiffTool
patchSpecification: aRwSpecification packageName: packageName

	| repo diskSnapshot imageSnapshot |
	super specification: aRwSpecification.
	repo := CypressAbstractRepository
		onUrl: (CypressUrl absoluteFromText: specification repositoryUrl)
		alias: ''.

	diskSnapshot := repo readPackageStructureForPackageNamed: packageName.
	imageSnapshot := (CypressPackageDefinition named: packageName) snapshot.
	^ CypressPatch fromBase: diskSnapshot toTarget: imageSnapshot
%

category: 'smalltalk api'
method: RwPkgDiffTool
patchSpecUrl: aString packageName: packageName

	^ self
		patchSpecification: (RwSpecification fromUrl: aString)
		packageName: packageName
%

! Class implementation for 'RwPkgDisownTool'

!		Instance methods for 'RwPkgDisownTool'

category: 'classes'
method: RwPkgDisownTool
disownClassExtensionMethodsInClassNamed: className forPackageNamed: packageName

	"Remove the extension methods in the named class for the named package"

	"The methods are not removed from the system"

	"use:
		Rowan packageTools adopt
			adoptClassExtensionNamed: className  instanceSelectors: <instanceSelectors> classSelectors: <classSelectors> intoPackageNamed: packageName
	to restore the classes and methods to the loaded things"

	| loadedPackage loadedProject loadedClassExtension gemstoneSpec packageSymDictName theClass theSymbolDictionary registry |
	theClass := Rowan globalNamed: className.

	loadedClassExtension := (Rowan image loadedClassExtensionsForClass: theClass) 
		detect: [:classExtension |  classExtension loadedPackage name = packageName ]
		ifNone: [ self error: 'No class extensions for the package ' , packageName printString, ' found in the class ' , className printString ].

	loadedPackage := loadedClassExtension loadedPackage.
	loadedProject := loadedPackage loadedProject.

	gemstoneSpec := loadedProject specification platformSpec at: 'gemstone'.
	packageSymDictName := gemstoneSpec symbolDictNameForPackageNamed: packageName.

	theSymbolDictionary := Rowan globalNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	registry disownClassExtensions: theClass forLoadedPackage: loadedPackage
%

category: 'classes'
method: RwPkgDisownTool
disownClassNamed: className

	"Remove the specified class and all of it's packaged instance and class methods from the loaded things. Methods that are not in the same package as
		the class are not disowned. "

	"The classes and methods are not removed from the system"

	"use:
		Rowan packageTools adopt
			adoptClassNamed: className classExtension: classExtension instanceSelectors: instanceSelectors classSelectors: classSelectors intoPackageNamed: <packageName>
	to restore the classes and methods to the loaded things"

	| packageName loadedPackage loadedProject gemstoneSpec packageSymDictName theClass theSymbolDictionary registry |
	theClass := Rowan globalNamed: className.

	theClass rowanProjectName = Rowan unpackagedName
		ifTrue: [ self error: 'The class ', className printString, ' is not packaged ... cannot disown an unpackaged class' ].

	packageName := theClass rowanPackageName.
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	gemstoneSpec := loadedProject specification platformSpec at: 'gemstone'.
	packageSymDictName := gemstoneSpec symbolDictNameForPackageNamed: packageName.

	theSymbolDictionary := Rowan globalNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	registry disownClass: theClass
%

category: 'methods'
method: RwPkgDisownTool
disownMethod: methodSelector inClassNamed: className isMeta: isMeta

	"remove the specified method from the loaded things. The method becomes unpackaged, but is not remove the system."

	"use:
		Rowan packageTools adopt
			adoptMethod: methodSelector inClassNamed: className  isMeta: isMeta intoPackageNamed: <packageName>
	to restore the specified method to the loaded things"

	| packageName loadedPackage loadedProject gemstoneSpec packageSymDictName theClass theSymbolDictionary registry 
		theBehavior theCompiledMethod |
	theClass := Rowan globalNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].
	theCompiledMethod := theBehavior compiledMethodAt: methodSelector.

	theCompiledMethod rowanProjectName = Rowan unpackagedName
		ifTrue: [ self error: 'The method ', className printString, '>>', methodSelector asString, ' is not packaged ... no need to disown' ].

	packageName := theCompiledMethod rowanPackageName.
	loadedPackage := Rowan image loadedPackageNamed: packageName.
	loadedProject := loadedPackage loadedProject.

	gemstoneSpec := loadedProject specification platformSpec at: 'gemstone'.
	packageSymDictName := gemstoneSpec symbolDictNameForPackageNamed: packageName.

	theSymbolDictionary := Rowan globalNamed: packageSymDictName.

	registry := theSymbolDictionary rowanSymbolDictionaryRegistry.

	registry _doDeleteCompiledMethodFromLoadedThings: theCompiledMethod for: theBehavior
%

category: 'packages'
method: RwPkgDisownTool
disownPackageNamed: packageName

	"Remove the classes and methods managed by the package from the loaded things."

	"The classes and methods are not removed from the system"

	"Use the adopt tool to restore the classes and methods to the loaded things"

	| loadedPackage registry |

	loadedPackage := Rowan image loadedPackageNamed: packageName.
	registry :=Rowan image loadedRegistryForPackageNamed: packageName.

	loadedPackage loadedClasses values
		do: [:loadedClass | 
			| class |
			class := Rowan globalNamed: loadedClass key.
			loadedClass disownFromLoaded: registry.
			registry classRegistry removeKey: class classHistory ].

	loadedPackage loadedClassExtensions values 
		do: [:loadedClassExtension | 
			| class |
			class := Rowan globalNamed: loadedClassExtension key.
			loadedClassExtension disownFromLoaded: registry ].

	registry deletePackage: packageName
%

! Class implementation for 'RwPkgLoadTool'

!		Instance methods for 'RwPkgLoadTool'

category: 'smalltalk api'
method: RwPkgLoadTool
loadPackageSetDefinition: packageSetDefinitionToLoad

	^ self
		loadPackageSetDefinition: packageSetDefinitionToLoad
		instanceMigrator: Rowan platform instanceMigrator
%

category: 'smalltalk api'
method: RwPkgLoadTool
loadPackageSetDefinition: packageSetDefinitionToLoad instanceMigrator: instanceMigrator

	"NOTE: not sure that we want to support the loading of arbitrary package sets (mixed projects) ... used by relatively old tests at the moment ... should be legal if the we create some project sets where the package to be loaded replace the packages in definitions derived from loaded things ... do a single load with proper updating of loaded packages in specification ..."

	| loadedPackageSet diff loadedEntitySet |
	loadedEntitySet := packageSetDefinitionToLoad deriveLoadedThings.
	loadedPackageSet := loadedEntitySet asPackageDefinitionSet.
	diff := packageSetDefinitionToLoad compareAgainstBase: loadedPackageSet.
	diff isEmpty
		ifTrue: [ 
			| msg |
			msg := 'The packages are already up to date'.
			self inform: msg.
			^ msg ].
	Rowan image applyModification: diff instanceMigrator: instanceMigrator.
	^ diff
%

! Class implementation for 'RwPkgQueryTool'

!		Instance methods for 'RwPkgQueryTool'

category: 'smalltalk API'
method: RwPkgQueryTool
classesForPackageNamed: projectName

	| loadedPackage classes |
	classes := IdentitySet new.
	loadedPackage := Rowan image loadedPackageNamed: projectName.
	loadedPackage loadedClasses values
		do: [ :rowanLoadedClass | classes add: rowanLoadedClass handle ].
	^ classes
%

category: 'smalltalk API'
method: RwPkgQueryTool
classExtensionsForPackageNamed: projectName

	| loadedPackage classExtensions |
	classExtensions := IdentitySet new.
	loadedPackage := Rowan image loadedPackageNamed: projectName.
	loadedPackage loadedClassExtensions values
		do: [ :rowanLoadedClass | classExtensions add: rowanLoadedClass handle ].
	^ classExtensions
%

! Class implementation for 'RwPkgReadTool'

!		Instance methods for 'RwPkgReadTool'

category: 'smalltalk api'
method: RwPkgReadTool
readPackageSetForSpecification: aRwSpecification

	| repo repositoryUrl readPackages |
	self specification: aRwSpecification.
	repositoryUrl := specification repositoryUrl
		ifNil: [ 
			('cypress:' , specification repoSpec repositoryRootPath , '/'
				, specification repoPath , '/') asRwUrl ]
		ifNotNil: [ :urlString | urlString asRwUrl ].
	repo := repositoryUrl asRwRepository.
	readPackages := {}.
	repo packageNames
		do: [ :packageName | 
			| structureName reader packageDefinition |
			structureName := packageName , repo packageExtension.
			reader := repo reader.
			reader
				packageStructure: (RwCypressPackageStructure named: structureName);
				packageDirectory:
						(reader fileUtils
								directoryFromPath: structureName
								relativeTo: repo directoryPath);
				readPackageStructure.
			packageDefinition := reader packageStructure rwSnapshot.
			readPackages add: packageDefinition ].
	^ (RwEntitySet withAll: readPackages) asPackageDefinitionSet
%

category: 'validation'
method: RwPkgReadTool
validate: aRwSpecification
  super validate: aRwSpecification.
  self validateForRead: aRwSpecification
%

! Class implementation for 'RwPkgAuditTool'

!		Instance methods for 'RwPkgAuditTool'

category: 'other'
method: RwPkgAuditTool
auditForPackage: loadedPackage
"audit dirty packages"
	|  res|
	res := KeyValueDictionary new.
	GsFile gciLogClient: '  -- Auditing package ', loadedPackage name.
		loadedPackage 
				loadedClassesDo: [:aLoadedClass |  (self auditLoadedClass: aLoadedClass) 
					ifNotEmpty: [:aColl | res at: aLoadedClass name put: aColl]]				
				loadedClassExtensionsDo: [:aLoadedClass | (self auditLoadedClassExtension: aLoadedClass) 
					ifNotEmpty: [:aColl | res at: aLoadedClass name put: aColl] ] .
	^res
%

category: 'other'
method: RwPkgAuditTool
auditForPackageNamed: packageName
	
	^self auditForPackage: (Rowan image loadedPackageNamed: packageName).
%

category: 'other'
method: RwPkgAuditTool
auditLoadedClass: aLoadedClass
"look for methods compiled into class without Rowan API"

	^RwClsAuditTool new auditLoadedClass: aLoadedClass.
%

category: 'other'
method: RwPkgAuditTool
auditLoadedClassExtension: aLoadedClass
"look for methods compiled into class without Rowan API"

	^RwClsExtensionAuditTool new auditLoadedClassExtension: aLoadedClass
%

category: 'other'
method: RwPkgAuditTool
checkAll
"check all packages regardless dirty or not"
	^(SessionTemps current at: #RwDirtyOnly otherwise: false) not
%

category: 'other'
method: RwPkgAuditTool
_addAll: aColl to: aDict for: aName

	aDict at: aName ifAbsentPut: [aColl].
%

! Class implementation for 'RwProjectTool'

!		Class methods for 'RwProjectTool'

category: 'commands'
classmethod: RwProjectTool
adopt

	^ RwPrjAdoptTool new
%

category: 'commands'
classmethod: RwProjectTool
audit

	^RwPrjAuditTool new
%

category: 'commands'
classmethod: RwProjectTool
browser

	^ RwPrjBrowserTool new
%

category: 'commands'
classmethod: RwProjectTool
checkout

	^RwPrjCheckoutTool new
%

category: 'commands'
classmethod: RwProjectTool
clone

	^RwPrjCloneTool new
%

category: 'commands'
classmethod: RwProjectTool
commit

	^RwPrjCommitTool new
%

category: 'commands'
classmethod: RwProjectTool
create
  ^ RwPrjCreateTool new
%

category: 'commands'
classmethod: RwProjectTool
delete

	^ RwPrjDeleteTool new
%

category: 'commands'
classmethod: RwProjectTool
diff

	^RwPrjDiffTool new
%

category: 'commands'
classmethod: RwProjectTool
disown

	^ RwPrjDisownTool new
%

category: 'commands'
classmethod: RwProjectTool
edit

	^ RwPrjEditTool new
%

category: 'commands'
classmethod: RwProjectTool
install
	^ RwPrjInstallTool new
%

category: 'commands'
classmethod: RwProjectTool
list

	^RwPrjListTool new
%

category: 'commands'
classmethod: RwProjectTool
load

	^RwPrjLoadTool new
%

category: 'commands'
classmethod: RwProjectTool
log

	^RwPrjLogTool new
%

category: 'commands'
classmethod: RwProjectTool
pull

	^RwPrjPullTool new
%

category: 'commands'
classmethod: RwProjectTool
push

	^RwPrjPushTool new
%

category: 'commands'
classmethod: RwProjectTool
query

	^ RwPrjQueryTool new
%

category: 'commands'
classmethod: RwProjectTool
read
  ^ RwPrjReadTool new
%

category: 'commands'
classmethod: RwProjectTool
reconcile

	^ RwPrjReconcileTool new
%

category: 'commands'
classmethod: RwProjectTool
register
  ^ RwPrjRegisterTool new
%

category: 'commands'
classmethod: RwProjectTool
registry

	^RwPrjRegistryTool new
%

category: 'commands'
classmethod: RwProjectTool
revert

	^RwPrjRevertTool new
%

category: 'commands'
classmethod: RwProjectTool
spec
  ^ RwPrjSpecTool new
%

category: 'commands'
classmethod: RwProjectTool
test

	^RwPrjTestTool new
%

category: 'commands'
classmethod: RwProjectTool
unregister

	^RwPrjUnregisterTool new
%

category: 'commands'
classmethod: RwProjectTool
upgrade

	^RwPrjUpgradeTool new
%

category: 'commands'
classmethod: RwProjectTool
write

	^RwPrjWriteTool new
%

!		Instance methods for 'RwProjectTool'

category: 'smalltalk api'
method: RwProjectTool
repositoryUrl
  ^ self specification repositoryUrl
%

! Class implementation for 'RwPrjAdoptTool'

!		Instance methods for 'RwPrjAdoptTool'

category: 'smalltalk api'
method: RwPrjAdoptTool
adoptProjectDefinition: projectDefinition

	| pkgAdoptTool |
	pkgAdoptTool := Rowan packageTools adopt.
	projectDefinition packages valuesDo: [:packageDef |
		packageDef classDefinitions valuesDo: [:classDef |
			pkgAdoptTool
				adoptClassNamed: classDef name 
				instanceSelectors: classDef instanceMethodDefinitions keys 
				classSelectors: classDef classMethodDefinitions keys 
				intoPackageNamed: packageDef name].
		packageDef classExtensions valuesDo: [:classDef |
			pkgAdoptTool
				adoptClassExtensionNamed: classDef name 
				instanceSelectors: classDef instanceMethodDefinitions keys 
				classSelectors: classDef classMethodDefinitions keys 
				intoPackageNamed: packageDef name ] ]
%

category: 'smalltalk api'
method: RwPrjAdoptTool
adoptProjectSetDefinition: projectSetDefinitionToAdopt

	projectSetDefinitionToAdopt projects do: [:projectDef |
		self adoptProjectDefinition: projectDef ]
%

! Class implementation for 'RwPrjAuditTool'

!		Instance methods for 'RwPrjAuditTool'

category: 'other'
method: RwPrjAuditTool
auditAll
	
	^self auditAllForUser: System myUserProfile userId
%

category: 'other'
method: RwPrjAuditTool
auditAllForUser: aUserId
| res |
	res := StringKeyValueDictionary new.
			(Rowan image  _loadedProjectRegistryForUserId: aUserId) keysAndValuesDo: [:prjName :aLoadedProject |
				(self auditForProject: aLoadedProject) ifNotEmpty: [:aColl | res at: prjName put: aColl]
	].
	^res
%

category: 'other'
method: RwPrjAuditTool
auditForProject: aLoadedProject
"audit loaded project"

	| res|

	res := KeyValueDictionary new.
	GsFile gciLogClient: '==============Auditing project ', aLoadedProject name.
		aLoadedProject loadedPackages values do: [:loadedPackage | 
			(Rowan image 
				loadedPackageNamed: loadedPackage name 
				ifAbsent: [])
					ifNil: [
						"this is a package that is not visible to the current user, so it isn't 
							necessary to audit it, because it isn't likely that the classes 
							referenced by the package are visible to the current user" ]
					ifNotNil: [
						(Rowan packageTools audit auditForPackage: loadedPackage) 
							ifNotEmpty: [:aColl | res at: loadedPackage name put: aColl ] ] ].	
	^res
%

category: 'other'
method: RwPrjAuditTool
auditForProjectNamed: aProjectName

	^self auditForProject: (Rowan image loadedProjectNamed: aProjectName)
%

category: 'other'
method: RwPrjAuditTool
auditForProjectsNamed: aCol
"audit all named projects"
	
	| res |
	res := Array new.
		aCol do: [:prjName | res addAll: (self auditForProjectNamed: prjName )	].
	^res
%

category: 'other'
method: RwPrjAuditTool
auditProjectsNamed: aCol
"audit all named projects"
	
	| res |
	res := Array new.
		aCol do: [:prjName | res addAll: (self auditForProjectNamed: prjName )	].
	^res
%

! Class implementation for 'RwPrjBrowserTool'

!		Instance methods for 'RwPrjBrowserTool'

category: 'class browsing'
method: RwPrjBrowserTool
addOrUpdateClassDefinition: className type: type superclass: superclassName instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: category packageName: packageName constraints: constraintsArray options: optionsArray

	| loadedPackage loadedProject loadedClass theOptions theConstraints |
	loadedPackage := self
		_loadedPackageNamed: packageName
		ifAbsent: [ self error: 'No package named ' , packageName printString , ' found' ].
	loadedProject := loadedPackage loadedProject.
	anArrayOfPoolDicts isEmpty
		ifFalse: [ self error: 'poolDictionaries not supported yet' ].
	loadedClass := self _loadedClassNamed: className ifAbsent: [  ].
	theOptions := optionsArray collect: [:each | each asString ].
	(constraintsArray isKindOf: Array)
		ifTrue: [
			theConstraints := {}.
			constraintsArray do: [:ar |
				(ar isKindOf: Array)
					ifTrue: [ theConstraints add: { (ar at: 1) asString . (ar at: 2) name asString } ]
					ifFalse: [ theConstraints add: ar name asString ] ] ]
		ifFalse: [
			theConstraints := constraintsArray
				ifNil: [ #() ]
				ifNotNil: [ constraintsArray ]].
	loadedClass
		ifNil: [ 
			| classDef |
			"create a new class"
			classDef := RwClassDefinition
				newForClassNamed: className
				super: superclassName
				instvars: anArrayOfStrings
				classinstvars: anArrayOfClassInstVars
				classvars: anArrayOfClassVars
				category: category
				comment: nil
				pools: #()
				type: type.
			classDef gs_options: theOptions.
			classDef gs_constraints: theConstraints.
			self createClass: classDef inPackageNamed: packageName ]
		ifNotNil: [ 
			self class edit
				definitionsForClassNamed: className
				ifFound: [ :classDef :packageDef :projectDef | 
					| classProjectDef projectSetDef |
					classProjectDef := projectDef.
					projectSetDef := RwProjectSetDefinition new.
					projectSetDef addProject: classProjectDef.
					classDef
						superclassName: superclassName;
						instVarNames: anArrayOfStrings;
						classVarNames: anArrayOfClassVars;
						classInstVarNames: anArrayOfClassInstVars;
						gs_options: theOptions;
						gs_constraints: theConstraints;
						category: category;
						yourself.
					loadedClass packageName = packageName
						ifFalse: [ 
							| thePackageDef |
							"move class to another package"
							packageDef removeClassDefinition: classDef.
							thePackageDef := classProjectDef
								packageNamed: packageName
								ifAbsent: [ 
									| packageProjectDef |
									"loadedPackage in a different project"
									packageProjectDef := loadedPackage loadedProject asDefinition.
									projectSetDef addProject: packageProjectDef.
									packageProjectDef packageNamed: packageName ].
							thePackageDef addClassDefinition: classDef ].
					self class load loadProjectSetDefinition: projectSetDef ]
				ifAbsent: [ 
					"shouldn't happen ... loadedClass known to exist"
					self error: 'unexpected missing class ' , className printString ] ].
	^ (self _loadedClassNamed: className ifAbsent: [  ]) handle currentVersion
%

category: 'class browsing'
method: RwPrjBrowserTool
addOrUpdateClassDefinition: className type: type superclass: superclassName instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: category packageName: packageName options: optionsArray

	^ self 
		addOrUpdateClassDefinition: className
		type: type 
		superclass: superclassName 
		instVarNames: anArrayOfStrings 
		classVars: anArrayOfClassVars 
		classInstVars: anArrayOfClassInstVars 
		poolDictionaries: anArrayOfPoolDicts 
		category: category 
		packageName: packageName 
		constraints: #() 
		options: optionsArray
%

category: 'method browsing'
method: RwPrjBrowserTool
addOrUpdateMethod: methodSource inProtocol: hybridPackageName forClassNamed: className isMeta: isMeta

	"If the method is already installed in a different package, remove the method from that package.
	 If package name matches the name of the package of the class definition, then add the method 
		to the class definition.
	 If there is no matching class extension or the package name does not match, add the method 
		to a class extension in the named package.
	 Return the resulting compiled method"

	"a hybrid package name has a leading '*' followed by the name of a package ... 
 		where the hybrid package name is not expected to preserve case"

	| loadedPackage |
	loadedPackage := (hybridPackageName at: 1) = $*
		ifTrue: [ 
			Rowan image
				loadedHybridPackageNamed: hybridPackageName
				ifAbsent: [ 
					self
						error:
							'A package for hybrid package name ' , hybridPackageName printString
								, ' was not found.' ] ]
		ifFalse: [ 
			| loadedClass |
			loadedClass := Rowan image 
				loadedClassNamed: className 
				ifAbsent: [
					| theBehavior |
					theBehavior := Rowan image objectNamed: className.
					isMeta ifTrue:  [ theBehavior := theBehavior class ].
					RwPerformingUnpackagedEditNotification signal: 'Attempt to add or modify an unpackage method in the class ', className printString, '. The modification will not be tracked by Rowan'.
					"Notification resumed, so continue with add/modify"
					^ theBehavior
						compileMethod: methodSource
						dictionaries: Rowan image symbolList
						category: hybridPackageName
						environmentId: 0 
						].
			loadedClass loadedPackage ].

	^ self
		addOrUpdateMethod: methodSource
		inProtocol: hybridPackageName
		forClassNamed: className
		isMeta: isMeta
		inPackageNamed: loadedPackage name
%

category: 'method browsing'
method: RwPrjBrowserTool
addOrUpdateMethod: methodSource inProtocol: protocol forClassNamed: className isMeta: isMeta inPackageNamed: packageName

	"If the method is already installed in a different package, remove the method from that package.
	 If package name matches the name of the package of the class definition, then add the method 
		to the class definition.
	 If there is no matching class extension or the package name does not match, add the method 
		to a class extension in the named package.
	 Return the resulting compiled method"

	| projectTools loadedPackage classExtensionDef methodDef updateBlock projectDefinition packageDefinition projectSetDefinition loadedMethodToBeRemoved |
	projectSetDefinition := RwProjectSetDefinition new.

	methodDef := RwMethodDefinition newForSource: methodSource protocol: protocol.
	loadedMethodToBeRemoved := self
		_loadedMethod: methodDef selector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ 
			"no pre-existing method for this selector installed"
			 ].

	projectTools := Rowan projectTools.
	updateBlock := [ :cDef :pDef | 
	loadedMethodToBeRemoved
		ifNil: [
			"no method needs to be remove, just add the method to the class or extension def"
			isMeta
				ifTrue: [ cDef addClassMethodDefinition: methodDef ]
				ifFalse: [ cDef addInstanceMethodDefinition: methodDef ] ]
		ifNotNil: [ :loadedMethod | 
			| loadedPackageForMethod |
			loadedPackageForMethod := loadedMethod loadedPackage.
			loadedPackageForMethod name = packageName
				ifTrue: [ 
					"loaded method being updated in same package, sjust update the method def"
					isMeta
						ifTrue: [ cDef updateClassMethodDefinition: methodDef ]
						ifFalse: [ cDef updateInstanceMethodDefinition: methodDef ] ]
				ifFalse: [ 
					| loadedClassOrExtension projectDef packageDef crDef |
					"loaded method in different package than new version of method"
					projectDef := loadedPackageForMethod loadedProject asDefinition.
					projectDef name = pDef name
						ifTrue: [ 
							"both packages are in same project"
							projectDef := pDef ]
						ifFalse: [ 
							"each package in a different project, will need to load loaded method project as well"
							projectSetDefinition addProject: projectDef ].
					packageDef := projectDef packageNamed: loadedPackageForMethod name.
					loadedClassOrExtension := loadedMethod loadedClass.
					crDef := loadedClassOrExtension isLoadedClass
						ifTrue: [ packageDef classDefinitions at: loadedClassOrExtension name ]
						ifFalse: [ packageDef classExtensions at: loadedClassOrExtension name ].
					"remove the method from one package and add it to the other"
					isMeta
						ifTrue: [ 
							crDef removeClassMethod: methodDef selector.
							cDef addClassMethodDefinition: methodDef  ]
						ifFalse: [ 
							crDef removeInstanceMethod: methodDef selector.
							cDef addInstanceMethodDefinition: methodDef  ] ] ].
	projectSetDefinition addProject: pDef.
	projectTools load loadProjectSetDefinition: projectSetDefinition.
	(self _loadedMethod: methodDef selector inClassNamed: className isMeta: isMeta)
		handle ].

	self
		definitionsForClassNamed: className
		ifFound: [ :classDef :packageDef :projectDef | 
			packageDef name = packageName
				ifTrue: [ ^ updateBlock value: classDef value: projectDef ]
				ifFalse: [ 
					"the named package is different from the class definition package"
					 ] ]
		ifAbsent: [ 
			"no loaded class definition, so we probably need to add a class extension"
			 ].
	loadedPackage := Rowan image
		loadedPackageNamed: packageName
		ifAbsent: [ self error: 'A package named ' , packageName printString , ' was not found.' ].
	projectDefinition := loadedPackage loadedProject asDefinition.
	packageDefinition := projectDefinition packageNamed: packageName.

	classExtensionDef := packageDefinition classExtensions
		at: className
		ifAbsent: [ 
			"no existing class extension definition ... create a new one"
			classExtensionDef := RwClassExtensionDefinition newForClassNamed: className.

			packageDefinition addClassExtension: classExtensionDef.
			classExtensionDef ].

	^ updateBlock value: classExtensionDef value: projectDefinition
%

category: 'package browsing'
method: RwPrjBrowserTool
addPackageNamed: packageName toProjectNamed: projectName

	| projectDefinition |
	projectDefinition := self _projectNamed: projectName.
	projectDefinition addPackage: (RwPackageDefinition newNamed: packageName).
	Rowan projectTools load loadProjectDefinition: projectDefinition
%

category: 'package browsing'
method: RwPrjBrowserTool
addPackagesNamed: packageNames toProjectNamed: projectName

	| projectDefinition |
	projectDefinition := self _projectNamed: projectName.
	packageNames
		do: [ :packageName | projectDefinition addPackage: (RwPackageDefinition newNamed: packageName) ].
	Rowan projectTools load loadProjectDefinition: projectDefinition
%

category: 'project browsing'
method: RwPrjBrowserTool
addRowanSymbolDictionariesToPersistentSymbolList

	self addRowanSymbolDictionariesToPersistentSymbolListFor: System myUserProfile
%

category: 'project browsing'
method: RwPrjBrowserTool
addRowanSymbolDictionariesToPersistentSymbolListFor: userProfile

	| systemUser |
	systemUser := AllUsers userWithId: 'SystemUser'.
	self _rowanSymbolDictionaryNames do: [:symDictName |
		| aSymbolDictionary anIndex |
		aSymbolDictionary := systemUser objectNamed: symDictName.
		anIndex := userProfile symbolList size + 1.
		userProfile
			insertDictionary: aSymbolDictionary at: anIndex ]
%

category: 'project browsing'
method: RwPrjBrowserTool
addRowanSymbolDictionariesToTransientSymbolList
  | systemUser |
  systemUser := AllUsers userWithId: 'SystemUser'.
  self _rowanSymbolDictionaryNames
    do: [ :symDictName | 
      | aSymbolDictionary anIndex transient |
      transient := GsSession currentSession symbolList.
      aSymbolDictionary := systemUser objectNamed: symDictName.
      anIndex := transient size + 1.
      transient insertObject: aSymbolDictionary at: anIndex ]
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForClass: aClass

	^ self classCreationTemplateForClass: aClass hybridBrowser: false
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForClass: aClass hybridBrowser: hybridBrowser

	| result anArray lfsp newByteSubclass civs superClass className thePackageName nonRowanClass |
	result := String new.
	superClass := aClass superclass.
	className := aClass name asString.
	superClass
		ifNil: [ result addAll: 'nil' ]
		ifNotNil: [ result addAll: superClass name asString ].
	lfsp := Character lf asString tab.
	newByteSubclass := false.
	thePackageName := aClass rowanPackageName.
	nonRowanClass := thePackageName = Rowan unpackagedName.
	(aClass isBytes _and: [ superClass isBytes not ])
		ifTrue: [ 
			nonRowanClass
				ifTrue: [ result addAll: ' byteSubclass: ''' ]
				ifFalse: [ result addAll: ' rwByteSubclass: ''' ].
			result
				addAll: className;
				addLast: $'.
			newByteSubclass := true ]
		ifFalse: [ 
			(aClass isIndexable and: [superClass isIndexable not])
				ifTrue: [ 
					nonRowanClass
						ifTrue: [ result addAll: ' indexableSubclass: ''' ]
						ifFalse: [ result addAll: ' rwIndexableSubclass: ''' ].
					result
						addAll: className;
						addLast: $' ]
				ifFalse: [ 
					nonRowanClass
						ifTrue: [ result addAll: ' subclass: ''' ]
						ifFalse: [ result addAll: ' rwSubclass: ''' ].
					result
						addAll: className;
						addLast: $' ] ].
	newByteSubclass
		ifFalse: [ 
			result
				addAll: lfsp;
				addAll: 'instVarNames: #(';
				addAll: (aClass _instVarNamesWithSeparator: lfsp , '                 ');
				add: $) ].
	result
		addAll: lfsp;
		addLast: 'classVars: #('.
	aClass _sortedClassVarNames
		do: [ :aKey | 
			result addLast: $ .
			(aKey includesValue: $')
				ifTrue: [ result addAll: aKey _asSource ]
				ifFalse: [ result addAll: aKey ] ].
	result addLast: $).
	result
		addAll: lfsp;
		addLast: 'classInstVars: #('.
	civs := aClass class allInstVarNames.
	civs removeFrom: 1 to: aClass class superClass instSize.
	civs
		do: [ :civName | 
			result addLast: $ .
			(civName includesValue: $')
				ifTrue: [ result addAll: civName _asSource ]
				ifFalse: [ result addAll: civName ] ].
	result addLast: $).
	result
		addAll: lfsp;
		addAll: 'poolDictionaries: '.
	result addAll: '#()'.	"ignored for now"
	nonRowanClass
		ifTrue: [ 
			"if the class is unpackaged, then we need to provide for the specification of symbol dictionary into which the class will be installed"
			result
				addAll: lfsp;
				addAll: 'inDictionary: '.
			anArray := Rowan image symbolList dictionariesAndSymbolsOf: aClass.
			anArray isEmpty
				ifTrue: [ result addAll: '''''' ]
				ifFalse: [ result addAll: ((anArray at: 1) at: 1) name asString ] ]
		ifFalse: [ 
			result
				addAll: lfsp;
				addAll: 'category: '.
			result addAll: aClass category printString.
			(hybridBrowser and: [ thePackageName = aClass category ])
				ifFalse: [ 
					result
						addAll: lfsp;
						addAll: 'packageName: '.
					result addAll: thePackageName printString ] ].
	aClass _hasConstraints
		ifTrue: [ 
			result
				add: lfsp;
				add: aClass _rwDefinitionOfConstraints ].
	result
		add: lfsp;
		add: aClass _rwOptionsForDefinition.
	result add: Character lf.
	^ result
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName category: category

	^ self
		classCreationTemplateForSubclassOf: superclassName
		category: category
		packageName: nil
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName category: category packageName: packageName

	^ self
		classCreationTemplateForSubclassOf: superclassName
		className: 'NameOfSubclass'
		category: category
		packageName: packageName
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName className: className category: category

	^ self
		classCreationTemplateForSubclassOf: superclassName
		className: className
		category: category
		packageName: nil
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName className: className category: category packageName: packageName

	^ self
		classCreationTemplateForSubclassOf: superclassName
		className: className
		type: 'normal'
		category: category
		packageName: packageName
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName className: className type: classType category: category packageName: packageNameOrNil

	"classType may be 'normal', 'bytes', or 'variable'"

	| result lfsp superClass |
	result := String new.
	superClass := Rowan image objectNamed: superclassName.
	result addAll: superclassName.
	lfsp := Character lf asString tab.
	classType = 'normal'
		ifTrue: [ result addAll: ' rwSubclass: ' ].
	classType = 'variable'
		ifTrue: [ result addAll: ' rwIndexableSubclass: ' ].
	classType = 'bytes'
		ifTrue: [ result addAll: ' rwByteSubclass: ' ].
	result addAll: className printString.
	classType ~= 'bytes'
		ifTrue: [ 
			result
				addAll: lfsp;
				addAll: 'instVarNames: #()' ].
	result
		addAll: lfsp;
		addLast: 'classVars: #()';
		addAll: lfsp;
		addLast: 'classInstVars: #()';
		addAll: lfsp;
		addAll: 'poolDictionaries: #()'.
	result
		addAll: lfsp;
		addAll: 'category: ';
		addAll: category printString.
	packageNameOrNil
		ifNotNil: [ 
			result
				addAll: lfsp;
				addAll: 'packageName: '.
			result addAll: packageNameOrNil printString ].
	result
		add: lfsp;
		add: 'options: #()';
		add: Character lf.
	^ result
%

category: 'class browsing'
method: RwPrjBrowserTool
classCreationTemplateForSubclassOf: superclassName className: className type: classType instanceVariablesString: instanceVariablesString classVariablesString: classVariablesString classInstanceVariablesString: classInstanceVariablesString poolDictionariesString: poolDictionariesString 
comment: comment category: category

	"classType may be 'normal', 'bytes', or 'variable'"

	| result lfsp |
	result := String new.
	lfsp := Character lf asString tab.
	comment isEmpty 
		ifFalse: [ 
			result 
				addAll: '(';
				addAll: lfsp ].
	result
		addAll: superclassName.
	classType = 'normal'
		ifTrue: [ result addAll: ' rwSubclass: ' ].
	classType = 'variable'
		ifTrue: [ result addAll: ' rwIndexableSubclass: ' ].
	classType = 'bytes'
		ifTrue: [ result addAll: ' rwByteSubclass: ' ].
	result addAll: className.
	classType ~= 'bytes'
		ifTrue: [ 
			result
				addAll: lfsp;
				addAll: 'instVarNames: #(' , instanceVariablesString , ')' ].
	result
		addAll: lfsp;
		addLast: 'classVars: #(' , classVariablesString , ')';
		addAll: lfsp;
		addLast: 'classInstVars: #(' , classInstanceVariablesString , ')';
		addAll: lfsp;
		addAll: 'poolDictionaries: #(' , poolDictionariesString , ')'.
	result
		addAll: lfsp;
		addAll: 'category: ';
		addAll: category.
	result
		add: lfsp;
		add: 'options: #()';
		add: Character lf.
	comment isEmpty 
		ifFalse: [ 
			result 
				addAll: ') ';
				addAll: lfsp;
				addAll: 'comment: ';
				addAll: comment;
				addAll: lfsp ].
	^ result
%

category: 'definition updating'
method: RwPrjBrowserTool
classNamed: className updateDefinition: updateBlock

	^ self
		classNamed: className
		updateDefinition: updateBlock
		ifAbsent: [ 
			self
				error:
					'expected class definition for class ' , className printString , ' not found.' ]
%

category: 'definition updating'
method: RwPrjBrowserTool
classNamed: className updateDefinition: updateBlock ifAbsent: absentBlock

	| projectDefinition classDefinition |
	self class edit
		definitionsForClassNamed: className
		ifFound: [ :classDef :packageDef :projectDef | 
			projectDefinition := projectDef.
			classDefinition := classDef ]
		ifAbsent: [ ^ absentBlock value ].

	updateBlock value: classDefinition.
	self class load loadProjectDefinition: projectDefinition
%

category: 'class browsing'
method: RwPrjBrowserTool
copyClassNamed: className to: newName

	"anser the new copy of the class"

	| projectSetDefinition |
	projectSetDefinition := self _copyClassDefinitionNamed: className to: newName.

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	^ Rowan globalNamed: newName
%

category: 'class browsing'
method: RwPrjBrowserTool
createClass: classDefinition inPackageNamed: packageName

	| loadedPackage projectDefinition projectTools |
	loadedPackage := Rowan image
		loadedPackageNamed: packageName
		ifAbsent: [ self error: 'The package named ' , packageName printString , ' was not found' ].
	projectDefinition := loadedPackage loadedProject asDefinition.

	projectTools := Rowan projectTools.

	projectTools edit
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: projectDefinition.

	projectTools load loadProjectDefinition: projectDefinition
%

category: 'project browsing'
method: RwPrjBrowserTool
createGitPackageProjectNamed: projectName

	self createGitPackageProjectNamed: projectName updateDefinition: [  ]
%

category: 'definition updating'
method: RwPrjBrowserTool
createGitPackageProjectNamed: projectName updateDefinition: updateBlock

	| projectDefinition |
	projectDefinition := RwProjectDefinition
		newForGitBasedProjectNamed: projectName.
	updateBlock cull: projectDefinition.
	self class load loadProjectDefinition: projectDefinition
%

category: 'project browsing'
method: RwPrjBrowserTool
exposeRowanToolsSymbolDictionary

	| transient size dict |
	transient := Rowan image symbolList.
	size := transient size.
	dict := (AllUsers userWithId: 'SystemUser') objectNamed: 'RowanTools'.
	transient insertObject: dict at: size + 1.
%

category: 'method browsing'
method: RwPrjBrowserTool
isExtensionMethod: methodSelector forClassNamed: className isMeta: isMeta

	"Answer true if the specified method is a Rowan extension method"

	| loadedMethod loadedClassOrExtension loadedPackage |

	loadedMethod := self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ 
			"No loaded method found ... it is not an extension method"
			^ false ].
	loadedPackage := loadedMethod loadedPackage.

	loadedClassOrExtension := loadedPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- no class or extension for ' , className printString
						, ' in package ' , loadedPackage name printString , '.' ].

	^loadedClassOrExtension isLoadedClassExtension
%

category: 'method browsing'
method: RwPrjBrowserTool
moveMethod: methodSelector forClassNamed: className isMeta: isMeta toProtocol: hybridPackageName

	"hybridPackageName is expected to be an existing protocol in className"

	| loadedMethodToBeMoved srcLoadedMethodPackage srcLoadedClassPackage srcLoadedClassOrExtension projectDef packageDef 
		clsDef projectSetDefinition destinationLoadedPackage methodDef |

	loadedMethodToBeMoved := self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ ].

	destinationLoadedPackage := (hybridPackageName at: 1) = $*
		ifTrue: [ 
			Rowan image
				loadedHybridPackageNamed: hybridPackageName
				ifAbsent: [ 
					self
						error:
							'A package for hybrid package name ' , hybridPackageName printString
								, ' was not found.' ] ]
		ifFalse: [ 
			| lc |
			lc := self
				_loadedClassNamed: className
				ifAbsent: [].
			lc 
				ifNil: [
					loadedMethodToBeMoved
						ifNil: [ 
							"unpackaged method moved to unpackaged category"
							^ (Rowan image objectNamed: className) moveMethod: methodSelector toCategory: hybridPackageName ].
				RwPerformingUnpackagedEditNotification signal: 'Attempt to move a packaged method to an unpackaged class ', className printString, '. The unpackaged method will not be tracked by Rowan'.
				"Notification resumed, so continue with move"
				"Move packaged method to unpackaged category"
				"Disown the method, then move it to proper category" 
				Rowan packageTools disown disownMethod: methodSelector inClassNamed: className isMeta: isMeta.
				^ (Rowan image objectNamed: className) moveMethod: methodSelector toCategory: hybridPackageName ].
			"use the loaded package for the class that contains the method"
			srcLoadedClassPackage := lc loadedPackage ].

	loadedMethodToBeMoved
		ifNil: [
			| instanceSelectors classSelectors res |
			"Moving an unpackaged method to a package in an unpackage class"
			"Move the method to the proper category and then adopt the method"
			isMeta
				ifTrue: [
					instanceSelectors := {}.
					classSelectors := { methodSelector } ]
				ifFalse: [
					instanceSelectors := { methodSelector }.
					classSelectors := {} ].
			res := (Rowan image objectNamed: className) moveMethod: methodSelector toCategory: hybridPackageName.
			Rowan packageTools adopt
				adoptClassNamed: className 
				classExtension: true
				instanceSelectors: instanceSelectors 
				classSelectors: classSelectors 
				intoPackageNamed: destinationLoadedPackage name.
			^ res ].

	"Moving a packaged method to another package"
	srcLoadedMethodPackage := loadedMethodToBeMoved loadedPackage.
	srcLoadedClassOrExtension := srcLoadedMethodPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- no class or extension for ' , className printString
						, ' in package ' , srcLoadedMethodPackage name printString , '.' ].

	projectSetDefinition := RwProjectSetDefinition new.
	projectDef := srcLoadedMethodPackage loadedProject asDefinition.
	packageDef := projectDef packageNamed: srcLoadedMethodPackage name.
	clsDef := srcLoadedClassOrExtension isLoadedClass
		ifTrue: [ packageDef classDefinitions at: className ]
		ifFalse: [ packageDef classExtensions at: className ].

	projectSetDefinition addProject: projectDef.
	destinationLoadedPackage name = srcLoadedMethodPackage name
		ifTrue: [
			"method is not moving to a different package, only need to change the protocol for the method"

			methodDef := isMeta
				ifTrue: [ clsDef classMethodDefinitions at: methodSelector ]
				ifFalse: [ clsDef instanceMethodDefinitions at: methodSelector ].
			methodDef protocol: hybridPackageName ]
		ifFalse: [
			"method is moving to a different package"

			| destProjectDef destPackageDef destClsDef srcPackageDef  srcClsDef |
			destinationLoadedPackage loadedProject name = projectDef name 
				ifTrue: [ destProjectDef := projectDef ]
				ifFalse: [ 
					"method is moving to a different project"
					destProjectDef := destinationLoadedPackage loadedProject asDefinition.
					projectSetDefinition addProject: destProjectDef ].
			srcPackageDef := projectDef packageNamed: srcLoadedMethodPackage name.
			srcClsDef := srcLoadedClassOrExtension isLoadedClass
				ifTrue: [ srcPackageDef classDefinitions at: className ]
				ifFalse: [ srcPackageDef classExtensions at: className ].

			destPackageDef := destProjectDef packageNamed: destinationLoadedPackage name. 

			destClsDef := srcLoadedClassPackage == destinationLoadedPackage
				ifTrue: [
					"method is not an extension method ... add the method to the class definition"
					destPackageDef 
						classDefinitions 
							at: className 
							ifAbsent: [ 
								self error: 'internal error - class ', 
									className printString , 
									' not found in expected package ', 
									destinationLoadedPackage name printString ] ]
				ifFalse: [ 
					"method is to be added as an extension method" 
					destPackageDef classExtensions at: className ifAbsentPut: [ RwClassExtensionDefinition newForClassNamed: className ] ].
			isMeta
				ifTrue: [
					methodDef := srcClsDef classMethodDefinitions at: methodSelector.
					methodDef protocol: hybridPackageName.
					destClsDef addClassMethodDefinition: methodDef.
					srcClsDef removeClassMethod: methodSelector ]
				ifFalse: [ 
					methodDef := srcClsDef instanceMethodDefinitions at: methodSelector.
					methodDef protocol: hybridPackageName.
					destClsDef addInstanceMethodDefinition: methodDef.
					srcClsDef removeInstanceMethod: methodSelector ] ].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.
%

category: 'project browsing'
method: RwPrjBrowserTool
projectNamed: projectName

	^ self _projectNamed: projectName
%

category: 'definition updating'
method: RwPrjBrowserTool
projectNamed: projectName updateDefinition: updateBlock

	| projectDefinition |
	projectDefinition := self _projectNamed: projectName.
	updateBlock value: projectDefinition.
	self class load loadProjectDefinition: projectDefinition
%

category: 'definition updating'
method: RwPrjBrowserTool
projectsNamed: projectNames updateDefinition: updateBlock

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectNames
		do: [ :projectName | 
			| projectDefinition |
			projectDefinition := self _projectNamed: projectName.
			updateBlock value: projectDefinition.
			projectSetDefinition addProject: projectDefinition ].
	self class load loadProjectSetDefinition: projectSetDefinition
%

category: 'class browsing'
method: RwPrjBrowserTool
removeClassNamed: className

	| projectSetDefinition loadedClass loadedClassProjectDef  loadedClassProjectDefName loadedClassExtensions |
	projectSetDefinition := RwProjectSetDefinition new.

	loadedClass := self _loadedClassNamed: className ifAbsent: [ ].
	loadedClassExtensions := #(). "only apply if the class itself is not managed by Rowan"

	loadedClass 
		ifNil: [
			"Give developer a chance to handle and abort the removal of unpackaged class"
			RwPerformingUnpackagedEditNotification signal: 'Attempt to remove an unpackaged class ', className printString, '. The removal will not be tracked by Rowan'.
			"Notification resumed, so continue with removal ... actual removal is performed below"
				loadedClassExtensions := self _loadedClassExtensionsNamed: className ifAbsent: [ #() ] ]
		ifNotNil: [
			| loadedPackage projectDef packageDef classDef |
			loadedPackage := loadedClass loadedPackage.
			projectDef := loadedClass loadedProject asDefinition.
			packageDef := projectDef packageNamed: loadedPackage name.
			classDef := packageDef classDefinitions at: loadedClass name.
			packageDef removeClassDefinition: classDef.
			projectSetDefinition addProject: projectDef.
			loadedClassProjectDef := projectDef.
			loadedClassProjectDefName := projectDef name ].

	loadedClassExtensions
		do: [ :loadedClassExtension | 
			| loadedClassExtensionPackage ceProjectDef cePackageDef |
			loadedClassExtensionPackage := loadedClassExtension loadedPackage.
			ceProjectDef := loadedClassExtension loadedProject asDefinition.
			ceProjectDef name = loadedClassProjectDefName
				ifTrue: [
					"extensions defined in same project as the class itself, entry already exists in projectSetDefinition"
					ceProjectDef := loadedClassProjectDef ]
				ifFalse: [ projectSetDefinition addProject: ceProjectDef ].
			cePackageDef := ceProjectDef packageNamed: loadedClassExtensionPackage name.
			cePackageDef
				removeClassExtension:
					(cePackageDef classExtensions at: loadedClassExtension name) ].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	loadedClass 
		ifNil: [
			"need to do the actual removal of the unpackaged class after Rowan has done it's job"
			| theClass |
			theClass := Rowan image objectNamed: className.
			(Rowan image symbolList dictionariesAndSymbolsOf: theClass)
				do: [:ar | | dict key |
					"brute force removal of the class from system dictionaries"
					dict := ar at: 1.	
					key := ar at: 2.
					dict removeKey: key ] ]
%

category: 'method browsing'
method: RwPrjBrowserTool
removeMethod: methodSelector forClassNamed: className isMeta: isMeta

	"Remove the given method selector from the class named className"

	| loadedMethodToBeRemoved loadedPackage loadedClassOrExtension projectDef packageDef crDef |
	loadedMethodToBeRemoved := self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [
			| theBehavior |
			theBehavior := Rowan image objectNamed: className.
			isMeta ifTrue:  [ theBehavior := theBehavior class ].
			RwPerformingUnpackagedEditNotification signal: 'Attempt to remove an unpackaged method from the class ', className printString, '. The removal will not be tracked by Rowan'.
			"Notification resumed, so continue with removal"
			^ theBehavior removeSelector: methodSelector ].
	loadedPackage := loadedMethodToBeRemoved loadedPackage.
	loadedClassOrExtension := loadedPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- no class or extension for ' , className printString
						, ' in package ' , loadedPackage name printString , '.' ].
	projectDef := loadedPackage loadedProject asDefinition.
	packageDef := projectDef packageNamed: loadedPackage name.
	crDef := loadedClassOrExtension isLoadedClass
		ifTrue: [ packageDef classDefinitions at: loadedClassOrExtension name ]
		ifFalse: [ packageDef classExtensions at: loadedClassOrExtension name ].
	isMeta
		ifTrue: [ crDef removeClassMethod: methodSelector ]
		ifFalse: [ crDef removeInstanceMethod: methodSelector ].
	Rowan projectTools load loadProjectDefinition: projectDef
%

category: 'package browsing'
method: RwPrjBrowserTool
removePackageNamed: packageName

	| loadedPackage projectDef |
	loadedPackage := self _loadedPackageNamed: packageName.
	projectDef := loadedPackage loadedProject asDefinition.
	projectDef removePackageNamed: loadedPackage name.

	Rowan projectTools load loadProjectDefinition: projectDef
%

category: 'class browsing'
method: RwPrjBrowserTool
removeProtocol: hybridPackageName fromClassNamed: className isMeta: isMeta

	"hybridPackageName is expected to be an existing protocol in className, that may or may not be empty"

	| projectSetDefinition loadedClass theClass theBehavior loadedPackage |
	projectSetDefinition := RwProjectSetDefinition new.

	loadedClass := self _loadedClassNamed: className ifAbsent: [ ].

	loadedPackage := (hybridPackageName at: 1) = $*
		ifTrue: [ 
			Rowan image
				loadedHybridPackageNamed: hybridPackageName
				ifAbsent: [ 
					self
						error:
							'A package for hybrid package name ' , hybridPackageName printString
								, ' was not found.' ] ]
		ifFalse: [ loadedClass loadedPackage ].

	theClass := Rowan image objectNamed: className.
	theBehavior := isMeta
		ifTrue: [ theClass class ]
		ifFalse: [ theClass ].

	(((theBehavior selectorsIn: hybridPackageName)
		collect: [:methodSelector |
			self
				_loadedMethod: methodSelector
				inClassNamed: className
				isMeta: isMeta
				ifAbsent: [
					RwPerformingUnpackagedEditNotification signal: 'Attempt to remove an unpackaged method from the class ', className printString, '. The removal will not be tracked by Rowan'.
					"Notification resumed, so continue with removal"
					(Rowan image objectNamed: className) removeSelector: methodSelector.
					nil "no loaded method involved" ] ]) select: [:each | each notNil ])
			do: [:loadedMethodToBeRemoved |
				| loadedClassOrExtension projectDef crDef packageDef methodSelector | 

				methodSelector := loadedMethodToBeRemoved selector.
				loadedPackage == loadedMethodToBeRemoved loadedPackage
					ifFalse: [ self error: 'Internal error -- the loaded package of a method to be removed does not match the expected loaded package' ].
				loadedClassOrExtension := loadedPackage
					classOrExtensionForClassNamed: className
					ifAbsent: [ 
						self
							error:
								'Internal error -- no class or extension for ' , className printString
									, ' in package ' , loadedPackage name printString , '.' ].
				projectDef := projectSetDefinition
					projectNamed: loadedPackage loadedProject name
					ifAbsent: [ 
						projectDef := loadedPackage loadedProject asDefinition.
						projectSetDefinition addProject: projectDef.
						projectDef ].
				packageDef := projectDef packageNamed: loadedPackage name.
				crDef := loadedClassOrExtension isLoadedClass
					ifTrue: [ packageDef classDefinitions at: loadedClassOrExtension name ]
					ifFalse: [ packageDef classExtensions at: loadedClassOrExtension name ].
				isMeta
					ifTrue: [ crDef removeClassMethod: methodSelector ]
					ifFalse: [ crDef removeInstanceMethod: methodSelector ] ].

	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	"Rowan does not automatically remove empty method categories ... just removes methods,
		we need to clean up after Rowan is done."
	theBehavior removeCategory: hybridPackageName asSymbol
%

category: 'class browsing'
method: RwPrjBrowserTool
renameClassNamed: className to: newName

	"During renameClassNamed:to: a class is created with the new name and all methods 
		are copied from the old class to the new class. If there are subclasses of the old class,
		the subclasses are moved under the new class, then the old class is removed. It is
		recommended that before renaming a class, you should find references to the class 
		and be prepared to edit the methods once the rename is complete.

	Worry about the fact that any references to the original class that may be in methods in 
		the class itself or in subclass methods will error out, if recompiled 
	"

	"anser the new copy of the class"

	| projectSetDefinition loadedClass loadedPackage loadedProject projectDef packageDef |
"1. find references to the original class [not yet implemented]"

"2. copy class to renamed class"
	projectSetDefinition := self _copyClassDefinitionNamed: className to: newName.

	loadedClass := self 
		_loadedClassNamed: className 
		ifAbsent: [  self error: 'No loaded class named: ', className printString , ' found.' ].

"3. remove original class definition"
	loadedPackage := loadedClass loadedPackage.
	loadedProject := loadedPackage loadedProject.
	projectDef := projectSetDefinition projectNamed: loadedProject name ifAbsent: [ self error: 'No loaded project named: ', loadedProject printString , ' found.'].
	packageDef := projectDef packageNamed: loadedPackage name.

	packageDef removeClassNamed: className.

"4. change superclass for all subclasses of original class to renamed class"
	(Rowan globalNamed: className) subclasses do: [:subclass |
		| subclassName classDef  |
		subclassName := subclass name asString.
		loadedClass := self 
			_loadedClassNamed: subclassName
			ifAbsent: [  self error: 'No loaded class named: ', subclassName printString , ' found.' ].

		loadedPackage := loadedClass loadedPackage.
		loadedProject := loadedPackage loadedProject.
		projectDef := projectSetDefinition 
			projectNamed: loadedProject name 
			ifAbsent: [ 
				| pDef |
				pDef := loadedPackage loadedProject asDefinition.
				projectSetDefinition addProject: pDef.
				pDef ].
		packageDef := projectDef packageNamed: loadedPackage name.
		classDef := packageDef classDefinitions at: subclassName.
		classDef superclassName: newName ].

"load projectSetDefinition & do rename"
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinition.

	^ Rowan globalNamed: newName
%

category: 'class browsing'
method: RwPrjBrowserTool
updateClassComment: aString forClassNamed: className 

	"update the comment of the named class"

	| loadedClass projectDefinition packageDefinition classDefinition |
	loadedClass := Rowan image 
		loadedClassNamed: className 
		ifAbsent: [
			RwPerformingUnpackagedEditNotification signal: 'Attempt to add or modify a comment for the class ', className printString, '. The modification will not be tracked by Rowan'.
			"Notification resumed, so continue with add/modify"
			^ (Rowan globalNamed: className) comment: aString ].

	projectDefinition := loadedClass loadedProject asDefinition.
	packageDefinition := projectDefinition packageNamed: loadedClass loadedPackage name.
	classDefinition := packageDefinition classDefinitions at: loadedClass name.
	classDefinition comment: aString.

	self class load loadProjectDefinition: projectDefinition.
%

category: 'private'
method: RwPrjBrowserTool
_copyClassDefinitionNamed: className to: newName

	"answer a projectSetDefinition that includes the copied class definition"

	| loadedClass classDef loadedPackage projectDef packageDef  projectSetDefinition |
	(self _loadedClassNamed: newName ifAbsent:  [])
		ifNotNil: [ self error: 'There is already a class named ', newName printString, ' in the system.' ].
	loadedClass := self 
		_loadedClassNamed: className 
		ifAbsent: [  self error: 'No loaded class named: ', className printString , ' found.' ].
	projectSetDefinition := RwProjectSetDefinition new.
	loadedPackage := loadedClass loadedPackage.
	projectDef := loadedPackage loadedProject asDefinition.
	packageDef := projectDef packageNamed: loadedPackage name.
	classDef := loadedClass asDefinition.
	classDef name: newName.
	packageDef addClassDefinition: classDef.
	projectSetDefinition addProject: projectDef.

	(self _loadedClassExtensionsNamed: className ifAbsent: [ #() ])
		do: [:loadedClassExtension | 
			| classExtDef loadedProject |
			loadedPackage := loadedClassExtension loadedPackage.
			loadedProject := loadedPackage loadedProject.
			projectDef := projectSetDefinition
				projectNamed: loadedPackage loadedProject name
				ifAbsent: [ 
					projectDef := loadedProject asDefinition.
					projectSetDefinition addProject: projectDef.
					projectDef ].

			packageDef := projectDef packageNamed: loadedPackage name.
			classExtDef := loadedClassExtension asDefinition.
			classExtDef name: newName.
			packageDef addClassExtension: classExtDef ].

	^ projectSetDefinition
%

category: 'private'
method: RwPrjBrowserTool
_loadedClassExtensionsNamed: className

	^ self
		_loadedClassExtensionsNamed: className
		ifAbsent: [ 
			self
				error:
					'No extensions for the class ' , className printString , ' were found' ]
%

category: 'private'
method: RwPrjBrowserTool
_loadedClassExtensionsNamed: className ifAbsent: absentBlock

	^ Rowan image
		loadedClassExtensionsNamed: className
		ifFound: [ :loadedClassExtensionSet | ^ loadedClassExtensionSet ]
		ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserTool
_loadedClassNamed: className

	^ self
		_loadedClassNamed: className
		ifAbsent: [ self error: 'The class ' , className printString , ' was not found' ]
%

category: 'private'
method: RwPrjBrowserTool
_loadedClassNamed: className ifAbsent: absentBlock

	^ Rowan image loadedClassNamed: className ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserTool
_loadedMethod: methodSelector inClassNamed: className isMeta: isMeta

	^ self
		_loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifAbsent: [ 
			self
				error:
					'No loaded method for ' , methodSelector printString , ' was found for class '
						, className printString ]
%

category: 'private'
method: RwPrjBrowserTool
_loadedMethod: methodSelector inClassNamed: className isMeta: isMeta ifAbsent: absentBlock

	^ Rowan image
		loadedMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta
		ifFound: [ :loadedMethod | ^ loadedMethod ]
		ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserTool
_loadedPackageNamed: packageName

	^ self
		_loadedPackageNamed: packageName
		ifAbsent: [ self error: 'No package named ' , packageName printString , ' found' ]
%

category: 'private'
method: RwPrjBrowserTool
_loadedPackageNamed: packageName ifAbsent: absentBlock

	^ Rowan image loadedPackageNamed: packageName ifAbsent: absentBlock
%

category: 'private'
method: RwPrjBrowserTool
_loadedProjectForClassNamed: className

	^ (self _loadedClassNamed: className) loadedProject
%

category: 'private'
method: RwPrjBrowserTool
_loadedProjectForMethod: methodSelector inClassNamed: className isMeta: isMeta

	^ (self _loadedMethod: methodSelector inClassNamed: className isMeta: isMeta)
		loadedProject
%

category: 'private'
method: RwPrjBrowserTool
_loadedProjectForPackageNamed: packageName

	^ (self _loadedPackageNamed: packageName) loadedProject
%

category: 'private'
method: RwPrjBrowserTool
_loadedProjectNamed: projectName

	^ Rowan image
		loadedProjectNamed: projectName
		ifAbsent: [ self error: 'No project named ' , projectName printString , ' found' ]
%

category: 'private'
method: RwPrjBrowserTool
_projectForClassNamed: className

	^ (self _loadedProjectForClassNamed: className) asDefinition
%

category: 'private'
method: RwPrjBrowserTool
_projectForMethod: methodSelector inClassNamed: className isMeta: isMeta

	^ (self
		_loadedProjectForMethod: methodSelector
		inClassNamed: className
		isMeta: isMeta) asDefinition
%

category: 'private'
method: RwPrjBrowserTool
_projectForPackageNamed: packageName

	^ (self _loadedProjectForPackageNamed: packageName) asDefinition
%

category: 'private'
method: RwPrjBrowserTool
_projectNamed: projectName

	^ (self _loadedProjectNamed: projectName) asDefinition
%

category: 'private'
method: RwPrjBrowserTool
_rowanSymbolDictionaryNames

	^ #( #RowanKernel #RowanLoader #RowanTools )
%

! Class implementation for 'RwPrjCheckoutTool'

!		Instance methods for 'RwPrjCheckoutTool'

category: 'smalltalk api'
method: RwPrjCheckoutTool
checkoutSpecification: aRwSpecification

	| checkout |
	self specification: aRwSpecification.
	checkout := specification repoSpec committish.
	checkout
		ifNil: [ 
			| msg |
			msg := 'No committish defined for the spec '
				, specification specName printString.
			self inform: msg.
			^ msg ]
		ifNotNil: [ 
			| gitTool gitRepoPath |
			gitTool := Rowan gitTools.
			gitRepoPath := specification repoSpec repositoryRootPath.
			gitTool gitcheckoutIn: gitRepoPath with: checkout ].
	^ specification
%

category: 'smalltalk api'
method: RwPrjCheckoutTool
checkoutSpecUrl: aString 

	^self checkoutSpecification: (RwSpecification fromUrl: aString) 
%

! Class implementation for 'RwPrjCloneTool'

!		Instance methods for 'RwPrjCloneTool'

category: 'smalltalk api'
method: RwPrjCloneTool
cloneSpecification: aRwSpecification gitRootPath: gitRootPath useSsh: useSsh

	^ self cloneSpecification: aRwSpecification gitRootPath: gitRootPath useSsh: useSsh registerProject: true
%

category: 'smalltalk api'
method: RwPrjCloneTool
cloneSpecification: aRwSpecification gitRootPath: gitRootPath useSsh: useSsh registerProject: registerProject

	| gitTool response projectUrl gitRepoPath cloneUrl cloneOption checkout segments |
	registerProject
		ifTrue: [ 
			"Register project show that is shows up as a loaded project in project list ... ready to be explicitly loaded"
			self specification: aRwSpecification ]
		ifFalse: [ specification := aRwSpecification ].
	gitRepoPath := gitRootPath , '/' , aRwSpecification specName.
	self
		_validateForGitRootPathForSpecification: gitRootPath
		gitRepoDir: gitRepoPath
		useSsh: useSsh
		ifDone: [ :msg | 
			"done block is invoked when it is not necessary to perform further processing. Typically,
		the clone is already present."
			^ msg ].
	gitTool := Rowan gitTools.
	projectUrl := RwUrl fromString: specification projectUrl.
	cloneUrl := useSsh
		ifTrue: [ 'git@' , projectUrl authority , ':' ]
		ifFalse: [ 'https://' , projectUrl authority , '/' ].
	segments := projectUrl segments.
	cloneUrl := segments size = 1
		ifTrue: [ cloneUrl , (segments at: 1) , '.git' ]
		ifFalse: [ cloneUrl , (segments at: 1) , '/' , (projectUrl segments at: 2) , '.git' ].
	cloneOption := ' --no-checkout '.
	checkout := specification repoSpec committish.
	checkout ifNil: [ cloneOption := '' ].
	response := gitTool gitcloneIn: gitRootPath with: cloneOption , cloneUrl.
	specification
		repositoryUrl: 'cypress:' , gitRepoPath , '/' , specification repoPath , '/'.
	specification repositoryRootPath: gitRepoPath.
	checkout
		ifNotNil: [ Rowan projectTools checkout checkoutSpecification: specification ].
	^ specification
%

category: 'smalltalk api'
method: RwPrjCloneTool
cloneSpecUrl: aString gitRootPath: gitRootPath useSsh: useSsh

	^self 
		cloneSpecification: (RwSpecification fromUrl: aString) 
		gitRootPath: gitRootPath 
		useSsh: useSsh
%

category: 'smalltalk api'
method: RwPrjCloneTool
specification: aRwSpecification
  "let the validation run before sending #register"

  ^ (super specification: aRwSpecification) register
%

category: 'private'
method: RwPrjCloneTool
_validateForGitRootPathForSpecification: gitRootPath gitRepoDir: gitRepoPath useSsh: useSsh ifDone: doneBlock

	| gitTool response command cdResponse |
	gitTool := Rowan gitTools.
	specification repositoryUrl
		ifNotNil: [ :repoUrlString | 
			| repoUrl |
			repoUrl := RwUrl fromString: repoUrlString.
			response := gitTool gitrevparseShowTopLevelIn: repoUrl pathString.
			command := 'set -e; cd ' , gitRepoPath , '; pwd'.
			cdResponse := gitTool performOnServer: command logging: true.
			(self readlink: response) = (self readlink: cdResponse)
				ifTrue: [ 
					| msg |
					msg := 'A clone for ' , specification specName printString
						, ' already exists in ' , gitRepoPath printString , '. Skipping clone.'.
					self inform: msg.
					doneBlock value: msg ].
			self
				error:
					'A clone for a different project (' , response printString
						, ') is already present in ' , gitRepoPath printString ].
	(Rowan fileUtilities directoryExists: gitRepoPath)
		ifTrue: [ 
			[ 
			"if gitRepoDir exists and it is a git repo, then make sure that the clone is for the target
		project ... if not error out of here."
			response := gitTool gitrevparseShowTopLevelIn: gitRepoPath.
			command := 'set -e; cd ' , gitRepoPath , '; pwd'.
			cdResponse := gitTool performOnServer: command logging: true.
			(self readlink: response) = (self readlink: cdResponse)
				ifTrue: [ 
					| msg |
					specification
						repositoryUrl:
							'cypress:' , gitRepoPath , '/' , specification repoPath , '/'.
					specification repositoryRootPath: gitRepoPath.
					msg := 'A clone for '
						, specification specName printString , ' already exists in '
						, gitRepoPath printString , ', so the clone operation is being skipped'
						, '
The project project has been registered with Rowan at the existing location .'.
					self inform: msg.
					doneBlock value: msg ] ]
				on: Error
				do: [ :ignored | 
					self
						error:
							'Expected a git repository to present in the directory: '
								, gitRepoPath printString ] ].
	(Rowan fileUtilities directoryExists: gitRootPath)
		ifFalse: [ Rowan fileUtilities ensureDirectoryExists: gitRootPath ]
%

! Class implementation for 'RwPrjCommitTool'

!		Instance methods for 'RwPrjCommitTool'

category: 'smalltalk api'
method: RwPrjCommitTool
commitPackagesForSpecification: aRwSpecification message: messageString

	"commit repository ... packages must be written out independently with write tool"

	self specification: aRwSpecification.
	specification canCommit
		ifFalse: [ 
			| msg |
			msg := 'repository for ' , specification specName printString
				,
					' does not support commit operations. Source written to repository and skipping commit'.
			self inform: msg.
			^ msg ].
	specification commitForTool: self message: messageString.
	^ specification updateLoadedCommitIdForTool: self
%

category: 'smalltalk api'
method: RwPrjCommitTool
commitPackagesForSpecUrl: aSpecUrlString message: messageString

	"commit repository ... packages must be written out independently with write tool"

	^ self
		commitPackagesForSpecification: (RwSpecification fromUrl: aSpecUrlString)
		message: messageString
%

category: 'smalltalk api'
method: RwPrjCommitTool
commitProjectDefinition: projectDefinition message: messageString

	"commit repository ... packages must be written out independently with write tool"

	projectDefinition canCommit
		ifFalse: [ 
			| msg |
			msg := 'repository for project ' , projectDefinition name printString
				, ' does not support commit operations.'.
			self inform: msg.
			^ msg ].
	self specification: projectDefinition specification.
	specification commitForTool: self message: messageString.
	^ specification updateLoadedCommitIdForTool: self
%

category: 'smalltalk api'
method: RwPrjCommitTool
commitProjectNamed: projectName message: messageString

	"commit repository ... packages must be written out independently with write tool"

	| loadedProject projectDefinition |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	projectDefinition := loadedProject asDefinition.
	projectDefinition canCommit
		ifFalse: [ 
			| msg |
			msg := 'repository for project ' , projectDefinition name printString
				, ' does not support commit operations.'.
			self inform: msg.
			^ msg ].
	self specification: projectDefinition specification.
	specification commitForTool: self message: messageString.
	^ specification updateLoadedCommitIdForTool: self
%

! Class implementation for 'RwPrjCreateTool'

!		Instance methods for 'RwPrjCreateTool'

category: 'loaded project creation'
method: RwPrjCreateTool
createDiskBasedProject: projectName packageNames: packageNames format: format root: rootPath

	"Create a new loaded project based on the given attributes. <rootPath> is the parent directory of the Rowan project. If the project exists on disk
		it will be used, if the project does not exist on disk it will be created. "

	| projectDefinition |
	projectDefinition := (RwProjectDefinition newForDiskBasedProjectNamed: projectName)
		packageNames: packageNames;
		yourself.
	^ self
		createProjectFor: projectDefinition 
		format: format 
		root: rootPath 
		configsPath: 'rowan/configs' 
		repoPath: 'rowan/src' 
		specsPath: 'rowan/specs'
%

category: 'loaded project creation'
method: RwPrjCreateTool
createDiskBasedProject: projectName packageNames: packageNames format: format root: rootPath configsPath: configsPath repoPath: repoPath specsPath: specsPath

	"Create a new loaded project based on the given attributes. <rootPath> is the parent directory of the Rowan project. If the project exists on disk
		it will be used, if the project does not exist on disk it will be created. "

	| projectDefinition |
	projectDefinition := self 
		createDiskBasedProjectDefinition: projectName 
		packageNames: packageNames 
		format: format 
		root: rootPath 
		configsPath: configsPath 
		repoPath: repoPath 
		specsPath: specsPath.
	^ self
		createProjectFor: projectDefinition 
		format: format
%

category: 'project definition creation'
method: RwPrjCreateTool
createDiskBasedProjectDefinition: projectName packageNames: packageNames format: format root: rootPath
	"Create a new project definition for a disk-based Rowan project with the given attributes"

	| utils rootRepoPath |
	utils := self fileUtilities.
	rootRepoPath := rootPath , utils pathNameDelimiter , projectName.
	^ (RwProjectDefinition newForDiskBasedProjectNamed: projectName)
		packageNames: packageNames;
		repositoryRootPath: rootRepoPath;
		projectOwnerId: Rowan image currentUserId;
		yourself.
%

category: 'project definition creation'
method: RwPrjCreateTool
createDiskBasedProjectDefinition: projectName packageNames: packageNames format: format root: rootPath configsPath: configsPath repoPath: repoPath specsPath: specsPath
	"Create a new project definition for a disk-based Rowan project with the given attributes"

	| utils rootRepoPath |
	utils := self fileUtilities.
	rootRepoPath := rootPath , utils pathNameDelimiter , projectName.
	^ (RwProjectDefinition newForDiskBasedProjectNamed: projectName)
		packageNames: packageNames;
		configsPath: configsPath;
		repoPath: repoPath;
		specsPath: specsPath;
		repositoryRootPath: rootRepoPath;
		projectOwnerId: Rowan image currentUserId;
		yourself.
%

category: 'loaded project creation'
method: RwPrjCreateTool
createGitBasedProject: projectName packageNames: packageNames format: format root: rootPath

	"Create a new loaded project based on the given attributes. <rootPath> is the parent directory of the Rowan project. If the git project exists on disk
		it will be used, if the git project does not exist on disk it will be created. "

	| projectDefinition |
	projectDefinition := (RwProjectDefinition newForGitBasedProjectNamed: projectName)
		packageNames: packageNames;
		yourself.
	^ self
		createProjectFor: projectDefinition 
		format: format 
		root: rootPath 
		configsPath: 'rowan/configs' 
		repoPath: 'rowan/src' 
		specsPath: 'rowan/specs'
%

category: 'loaded project creation'
method: RwPrjCreateTool
createGitBasedProject: projectName packageNames: packageNames format: format root: rootPath configsPath: configsPath repoPath: repoPath specsPath: specsPath

	"Create a new loaded project based on the given attributes. <rootPath> is the parent directory of the Rowan project. If the git project exists on disk
		it will be used, if the git project does not exist on disk it will be created. "

	| projectDefinition |
	projectDefinition := self 
		createGitBasedProjectDefinition: projectName 
		packageNames: packageNames 
		format: format 
		root: rootPath 
		configsPath: configsPath 
		repoPath: repoPath 
		specsPath: specsPath.
	^ self
		createProjectFor: projectDefinition 
		format: format
%

category: 'project definition creation'
method: RwPrjCreateTool
createGitBasedProjectDefinition: projectName packageNames: packageNames format: format root: rootPath
	"Create a new project definition for a git-based Rowan project with the given attributes"

	| utils rootRepoPath |
	utils := self fileUtilities.
	rootRepoPath := rootPath , utils pathNameDelimiter , projectName.
	^(RwProjectDefinition newForGitBasedProjectNamed: projectName)
		packageNames: packageNames;
		repositoryRootPath: rootRepoPath;
		projectOwnerId: Rowan image currentUserId;
		yourself.
%

category: 'project definition creation'
method: RwPrjCreateTool
createGitBasedProjectDefinition: projectName packageNames: packageNames format: format root: rootPath configsPath: configsPath repoPath: repoPath specsPath: specsPath
	"Create a new project definition for a git-based Rowan project with the given attributes"

	| utils rootRepoPath |
	utils := self fileUtilities.
	rootRepoPath := rootPath , utils pathNameDelimiter , projectName.
	^(RwProjectDefinition newForGitBasedProjectNamed: projectName)
		packageNames: packageNames;
		configsPath: configsPath;
		repoPath: repoPath;
		specsPath: specsPath;
		repositoryRootPath: rootRepoPath;
		projectOwnerId: Rowan image currentUserId;
		yourself.
%

category: 'project definition creation'
method: RwPrjCreateTool
createProjectDefinitionFromSpecUrl: fileUrlOrString
	"Answer a project definition based on the given <fileUrlOrString> 
		<fileUrlOrString> is expected to be an RwFileUrl for a project spec _in_ an existing Rowan project"

	| fileUrl spec specsPath specFilePath index projectRootPath |
	fileUrl := fileUrlOrString asRwUrl.
	fileUrl scheme = 'file'
		ifFalse: [ self error: 'the url ', fileUrlOrString printString, ' is expected to be a file: url referencing a project specification file in an existing Rowan project' ].
	spec := fileUrl asSpecification.
	specsPath := spec specsPath.
    specFilePath := fileUrl pathDirString.
	index := specFilePath findString: specsPath startingAt: 1.
	projectRootPath := specFilePath copyFrom: 1 to: index - 1.
	^ self createProjectDefinitionFromSpecUrl: fileUrlOrString projectRootPath: projectRootPath
%

category: 'project definition creation'
method: RwPrjCreateTool
createProjectDefinitionFromSpecUrl: fileUrlOrString projectRootPath: projectRootPath
	"Answer a project definition based on the spec given in <fileUrlOrString> 
		<projectRootPath> is the path to the root directory of the Rowan project"

	| path fileUrl spec projectDefinition |
	fileUrl := fileUrlOrString asRwUrl.
	fileUrl scheme = 'file'
		ifFalse: [ self error: 'the url ', fileUrlOrString printString, ' is expected to be a file: url referencing a project specification file in an existing Rowan project' ].
	spec := fileUrl asSpecification.
	spec 
		repositoryRootPath: projectRootPath;
		repositoryUrl: 'cypress:', projectRootPath, '/', spec repoPath, '/'.
	path :=  spec repositoryRootPath , '/' , spec repoPath , '/'.
	(Rowan fileUtilities directoryExists: path)
		ifFalse: [ self error: 'No source repository found at ' , path printString ].
	path :=  spec repositoryRootPath , '/' , spec configsPath , '/'.
	(Rowan fileUtilities directoryExists: path)
		ifFalse: [ self error: 'No configuration directory found at ' , path printString ].
	projectDefinition := spec asDefinition.
	^ projectDefinition
%

category: 'loaded project creation'
method: RwPrjCreateTool
createProjectFor: projectDefinition

	"Create a new loaded project based on the given project definition. If the project exists on disk it will be used, if the project 
		does not exist on disk it will be created."

	"If project does not exist on disk, create project on disk using tonel format"

	^ self createProjectFor: projectDefinition format: 'tonel'
%

category: 'loaded project creation'
method: RwPrjCreateTool
createProjectFor: projectDefinition format: format

	"Create a new loaded project based on the given project definition. If the project exists on disk it will be used, if the project 
		does not exist on disk it will be created."

	"format is only used if project does not exist on disk"

	| projectName rootRepoPath dirPath useGit utils repositoryUrl |
	projectName := projectDefinition name.
	useGit := projectDefinition useGit.
	rootRepoPath := projectDefinition repositoryRootPath.
	repositoryUrl :=  'cypress:' , rootRepoPath , '/' , projectDefinition repoPath , '/'.
	utils := self fileUtilities.

	self
		_createProjectRepositoryDirectory: rootRepoPath
		useGit: useGit
		abort: [ 
			projectDefinition repositoryUrl: repositoryUrl.
			projectDefinition specification register.
			^ projectDefinition ].

	projectDefinition repositoryUrl:repositoryUrl.

	dirPath := rootRepoPath , utils pathNameDelimiter , projectDefinition repoPath.
	utils ensureDirectoryExists: dirPath.
	utils
		writeStreamFor: 'properties.st'
		in: dirPath
		do: [ :fileStream | fileStream nextPutAll: '{ #format : ' , format printString , '}' ].

	{projectDefinition configsPath. projectDefinition repoPath. projectDefinition specsPath }
		do: [ :path |
			dirPath := rootRepoPath , utils pathNameDelimiter , path.
			utils ensureDirectoryExists: dirPath ].

	projectDefinition specification export.
	projectDefinition specification register.
	projectDefinition configurationTemplate export.

	^ projectDefinition
%

category: 'loaded project creation'
method: RwPrjCreateTool
createProjectFor: projectDefinition format: format root: rootPath

	"Create a new loaded project based on the given project definition. If the project exists on disk at <rootPath> it will be used, if the project 
		does not exist on disk it will be created."

	| projectName utils |
	projectName := projectDefinition name.
	utils := self fileUtilities.
	projectDefinition repositoryRootPath:  rootPath , utils pathNameDelimiter , projectName.
	^ self createProjectFor: projectDefinition format: format
%

category: 'loaded project creation'
method: RwPrjCreateTool
createProjectFor: projectDefinition format: format root: rootPath configsPath: configsPath repoPath: repoPath specsPath: specsPath

	"Create a new loaded project based on the given project definition. If the project exists on disk at <rootPath> it will be used, if the project 
		does not exist on disk it will be created."

	| projectName utils |
	projectName := projectDefinition name.
	utils := self fileUtilities.
	projectDefinition
		repositoryRootPath: rootPath , utils pathNameDelimiter , projectName;
		repoPath: repoPath;
		configsPath: configsPath;
		repoPath: repoPath;
		specsPath: specsPath;
		repositoryRootPath: rootPath , utils pathNameDelimiter , projectName;
		projectOwnerId: Rowan image currentUserId.
	^ self createProjectFor: projectDefinition format: format
%

category: 'loaded project creation'
method: RwPrjCreateTool
createProjectFromSpecUrl: fileUrlOrString

	"Create a new loaded project based on the given <fileUrlOrString>. If the project exists on disk it will be used, if the project 
		does not exist on disk it will be created."

	| projectDefinition |
	projectDefinition := self createProjectDefinitionFromSpecUrl: fileUrlOrString.
	^ self createProjectFor: projectDefinition
%

category: 'private'
method: RwPrjCreateTool
_createProjectRepositoryDirectory: repoPath useGit: useGit abort: abortBlock

	| utils gitTool |
	utils := self fileUtilities.
	gitTool := Rowan gitTools.
	(utils directoryExists: repoPath)
		ifTrue: [ 
			(self
				confirm:
					'There is already a directory named ' , repoPath printString
						, '. The contents of the directory will be deleted if you continue.')
				== true
				ifFalse: [ ^ abortBlock value ].
			utils deleteAll: repoPath ]
		ifFalse: [ utils ensureDirectoryExists: repoPath ].
	useGit
		ifTrue: [ 
			(gitTool gitPresentIn: repoPath)
				ifFalse: [ 
					"create a git repository"
					gitTool gitinitIn: repoPath with: '' ] ]
%

! Class implementation for 'RwPrjDeleteTool'

!		Instance methods for 'RwPrjDeleteTool'

category: 'delete project definitions'
method: RwPrjDeleteTool
deleteProjectDefinition: projectDefinition

	"Remove the classes and methods managed by the project definition."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects the delete will fail ... deleteProjectDefinitionSet: to delete multiple projects"

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

	^ self deleteProjectSetDefinition: projectSetDefinition
%

category: 'delete projects by name'
method: RwPrjDeleteTool
deleteProjectNamed: projectName

	"Remove the classes and methods managed by the project from the loaded things."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects the delete will fail ... deleteProjectDefinitionSet: to delete multiple projects"

	| loadedProject |

	loadedProject := Rowan image loadedProjectNamed: projectName.

	^ self deleteProjectDefinition: loadedProject asDefinition
%

category: 'delete project definitions'
method: RwPrjDeleteTool
deleteProjectSetDefinition: projectSetDefinitionToDelete

	"Remove the classes and methods managed by the listed project definitions."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will fail ... 
		add projects containing  subclasses to the <projectSetDefinitionToDelete> ."

	| loadedProjectSet |
	loadedProjectSet := projectSetDefinitionToDelete deriveLoadedThings.

	projectSetDefinitionToDelete definitions
		do: [ :projectDef |
			projectDef packageNames do: [:packageName | 
				projectDef removePackageNamed: packageName ] ].
	Rowan projectTools load loadProjectSetDefinition: projectSetDefinitionToDelete.

	loadedProjectSet do: [:loadedProject |
		Rowan image _removeLoadedProject: loadedProject ]
%

category: 'delete project definitions'
method: RwPrjDeleteTool
forceDeleteProjectDefinition: projectDefinition

	"Remove the classes and methods managed by the project definition."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will NOT fail."

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

	^ self forceDeleteProjectSetDefinition: projectSetDefinition
%

category: 'delete projects by name'
method: RwPrjDeleteTool
forceDeleteProjectNamed: projectName

	"Remove the classes and methods managed by the project from the loaded things."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will NOT fail."

	| loadedProject |

	loadedProject := Rowan image loadedProjectNamed: projectName.

	^ self forceDeleteProjectDefinition: loadedProject asDefinition
%

category: 'delete project definitions'
method: RwPrjDeleteTool
forceDeleteProjectSetDefinition: projectSetDefinitionToDelete

	"Remove the classes and methods managed by the listed project definitions."

	"The classes and methods are removed from the system"

	"If there are subclasses of classes in other projects not in the set, the delete will NOT fail."

	| loadedProjectSet classesToDelete methodsToDelete mySymbolList |
	loadedProjectSet := projectSetDefinitionToDelete deriveLoadedThings.

	classesToDelete := IdentitySet new.
	methodsToDelete := IdentityKeyValueDictionary new.

	loadedProjectSet do: [:theLoadedProject |
		theLoadedProject 
			loadedPackagesDo: [ :loadedProject :loadedPackage | "ignored" ] 
			loadedClassedDo: [ :loadedProject :loadedPackage :loadedClass | 
				"collect the classes defined in the project"
				classesToDelete add: loadedClass handle currentVersion ] 
			loadedClassExtensionsDo: [:loadedProject :loadedPackage :loadedClassExtension | "ignored" ] 
			loadedInstanceMethodsDo: [:loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod |
				loadedClassOrClassExtension isLoadedClassExtension
					ifTrue: [ 
						"collect extension instance methods"
						((methodsToDelete at: loadedClassOrClassExtension handle currentVersion ifAbsentPut: [Dictionary new]) 
							at: 'instance' ifAbsentPut: [ IdentitySet new ]) add: loadedMethod handle selector ] ] 
			loadedClassMethodsDo: [:loadedProject :loadedPackage :loadedClassOrClassExtension :loadedMethod | 
				loadedClassOrClassExtension isLoadedClassExtension
					ifTrue: [ 
						"collect extension class methods"
						((methodsToDelete at: loadedClassOrClassExtension handle currentVersion ifAbsentPut: [Dictionary new]) 
							at: 'class' ifAbsentPut: [ IdentitySet new ]) add: loadedMethod handle selector ] ] ].
	classesToDelete do: [:class | 
		"remove any classes that are going to be deleted from methodsToDelete"
		methodsToDelete removeKey: class ifAbsent: [ ] ].

	loadedProjectSet do: [:theLoadedProject |
		"remove the methods, classes, packages and projects from loaded things"
		Rowan projectTools disown disownProjectNamed: theLoadedProject name ].

	mySymbolList := System myUserProfile symbolList. "persistent symbol list"
	classesToDelete do: [:class |
		"remove classes from system"
		(mySymbolList dictionariesAndSymbolsOf: class) do: [:ar |
			GsFile gciLogServer: 'Forcibly delete class ', class name asString printString.
			(ar at: 1) removeKey: (ar at: 2) ] ].

	methodsToDelete keysAndValuesDo: [:class :selectorDict |
		| behavior |
		"remove extension methods from the classes remaining in system"
		GsFile gciLogServer: 'Forcibly remove extension methods from class ', class name asString printString.
		GsFile gciLogServer: '	instance'.
		(selectorDict at: 'instance' ifAbsent: [ #() ]) do: [:selector |
			GsFile gciLogServer: '		', selector asString printString.
			class removeSelector: selector ].
		behavior := class class.
		GsFile gciLogServer: '	class'.
		(selectorDict at: 'class' ifAbsent: [ #() ]) do: [:selector |
			GsFile gciLogServer: '		', selector asString printString.
			behavior removeSelector: selector ] ].
%

! Class implementation for 'RwPrjDiffTool'

!		Instance methods for 'RwPrjDiffTool'

category: 'smalltalk api'
method: RwPrjDiffTool
diffSpecUrl: aString

	^ self diffSpecification: (RwSpecification fromUrl: aString)
%

category: 'validation'
method: RwPrjDiffTool
validate: aRwSpecification
  super validate: aRwSpecification.
  self validateForRead: aRwSpecification
%

! Class implementation for 'RwPrjDisownTool'

!		Instance methods for 'RwPrjDisownTool'

category: 'projects'
method: RwPrjDisownTool
disownProjectNamed: projectName

	"Remove the classes and methods managed by the project from the loaded things."

	"The classes and methods are not removed from the system"

	"Use the adopt tool to restore the classes and methods to the loaded things"

	| loadedProject disownTool |

	loadedProject := Rowan image loadedProjectNamed: projectName.

	disownTool := Rowan packageTools disown.
	loadedProject loadedPackages 
		do: [:loadedPackage |
			disownTool disownPackageNamed: loadedPackage name ].

	Rowan image _removeLoadedProject: loadedProject
%

! Class implementation for 'RwPrjEditTool'

!		Instance methods for 'RwPrjEditTool'

category: 'class editing'
method: RwPrjEditTool
addClass: classDefinition inPackageNamed: packageName inProject: projectDefinition

	"Add the given class definition to the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition addClassDefinition: classDefinition.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
addClass: classDefinition inPackageNamed: packageName inProjectNamed: projectName

	"Add the given class definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		addClass: classDefinition
		inPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

category: 'class extension editting'
method: RwPrjEditTool
addClassExtension: classExtensionDefinition inPackageNamed: packageName inProject: projectDefinition

	"Add the given class extension definition to the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition addClassExtension: classExtensionDefinition.
	^ projectDefinition
%

category: 'class extension editting'
method: RwPrjEditTool
addClassExtension: classExtensionDefinition inPackageNamed: packageName inProjectNamed: projectName

	"Add the given class extension definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		addClassExtension: classExtensionDefinition
		inPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

category: 'class editing'
method: RwPrjEditTool
removeClass: classDefinition fromPackageNamed: packageName inProject: projectDefinition

	"Remove the given class definition from the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition removeClassDefinition: classDefinition.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
removeClass: classDefinition fromPackageNamed: packageName inProjectNamed: projectName

	"Remove the given class definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		removeClass: classDefinition
		fromPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

category: 'class editing'
method: RwPrjEditTool
removeClassNamed: className fromPackageNamed: packageName inProject: projectDefinition

	"Remove the named class definition from the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition removeClassNamed: className.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
removeClassNamed: className fromPackageNamed: packageName inProjectNamed: projectName

	"Remove the named class definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		removeClassNamed: className
		fromPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

category: 'class editing'
method: RwPrjEditTool
updateOrAddClass: classDefinition inPackageNamed: packageName inProject: projectDefinition

	"Update or add the given class definition to the named package in the given project. 
		Return the projectDefinition"

	| packageDefinition |
	packageDefinition := projectDefinition packageNamed: packageName.
	packageDefinition updateClassDefinition: classDefinition.
	^ projectDefinition
%

category: 'class editing'
method: RwPrjEditTool
updateOrAddClass: classDefinition inPackageNamed: packageName inProjectNamed: projectName

	"Update or add the given class definition to the named package in the named project. 
		Return a projectDefinition for the named project"

	^ self
		updateOrAddClass: classDefinition
		inPackageNamed: packageName
		inProject: (Rowan image loadedProjectNamed: projectName) asDefinition
%

! Class implementation for 'RwPrjLoadTool'

!		Instance methods for 'RwPrjLoadTool'

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectDefinition: projectDefinition

	| projectSetDefinition |
	projectSetDefinition := RwProjectSetDefinition new.
	projectSetDefinition addDefinition: projectDefinition.

	^ self loadProjectSetDefinition: projectSetDefinition
%

category: 'load project by spec url'
method: RwPrjLoadTool
loadProjectFromSpecUrl: fileUrlOrString

	| projectDefinition projectSetDefinition res |
	projectDefinition := Rowan projectTools create createProjectDefinitionFromSpecUrl: fileUrlOrString.
	projectSetDefinition := Rowan projectTools read readProjectSetForProjectDefinition: projectDefinition.
	res := self loadProjectSetDefinition: projectSetDefinition.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by spec url'
method: RwPrjLoadTool
loadProjectFromSpecUrl: fileUrlOrString  projectRootPath: projectRootPath

	| projectDefinition projectSetDefinition res |

	projectDefinition := Rowan projectTools create createProjectDefinitionFromSpecUrl: fileUrlOrString projectRootPath: projectRootPath.
	projectSetDefinition := Rowan projectTools read readProjectSetForProjectDefinition: projectDefinition.
	res := self loadProjectSetDefinition: projectSetDefinition.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by spec url'
method: RwPrjLoadTool
loadProjectFromSpecUrl: fileUrlOrString withConfigurations: configNames groupNames: groupNames

	| projectDefinition projectSetDefinition res |
	projectDefinition := Rowan projectTools create createProjectDefinitionFromSpecUrl: fileUrlOrString.
	projectSetDefinition := Rowan projectTools read 
		readProjectSetForProjectDefinition: projectDefinition 
		withConfigurations: configNames
		groupNames: groupNames.
	res := self loadProjectSetDefinition: projectSetDefinition.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by spec url'
method: RwPrjLoadTool
loadProjectFromSpecUrl: fileUrlOrString  withConfigurations: configNames groupNames: groupNames projectRootPath: projectRootPath

	| projectDefinition projectSetDefinition res |

	projectDefinition := Rowan projectTools create createProjectDefinitionFromSpecUrl: fileUrlOrString projectRootPath: projectRootPath.
	projectSetDefinition := Rowan projectTools read 
		readProjectSetForProjectDefinition: projectDefinition 
		withConfigurations: configNames
		groupNames: groupNames.
	res := self loadProjectSetDefinition: projectSetDefinition.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	^ self loadProjectNamed: projectNamed instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed instanceMigrator: instanceMigrator

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed.
	res := self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed withConfigurations: configNames groupNames: groupNames

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	^ self loadProjectNamed: projectNamed withConfigurations: configNames groupNames: groupNames instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed withConfigurations: configNames groupNames: groupNames instanceMigrator: instanceMigrator

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed
		withConfigurations: configNames 
		groupNames: groupNames.
	res := self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed withGroupNames: groupNames

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	^ self loadProjectNamed: projectNamed withGroupNames: groupNames instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed: projectNamed withGroupNames: groupNames instanceMigrator: instanceMigrator

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed
		withGroupNames: groupNames.
	res := self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project by name'
method: RwPrjLoadTool
loadProjectNamed_254: projectNamed instanceMigrator: instanceMigrator

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed.
	res := self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectSetDefinition: projectSetDefinitionToLoad

	^ self
		loadProjectSetDefinition: projectSetDefinitionToLoad
		instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectSetDefinition: projectSetDefinition instanceMigrator: instanceMigrator

	"NOTE: when loading a definition into a stone, the loaded things are not marked as non-dirty ... dirty state is relative to the disk image for a
		project and a definition can have come from anywhere"

	^ self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new
%

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectSetDefinition_254: projectSetDefinitionToLoad

	^ self
		loadProjectSetDefinition_254: projectSetDefinitionToLoad
		instanceMigrator: Rowan platform instanceMigrator
%

category: 'load project definitions'
method: RwPrjLoadTool
loadProjectSetDefinition_254: projectSetDefinition instanceMigrator: instanceMigrator

	"NOTE: when loading a definition into a stone, the loaded things are not marked as non-dirty ... dirty state is relative to the disk image for a
		project and a definition can have come from anywhere"

	^ self 
		_doProjectSetLoad_254: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new
%

category: 'utilities'
method: RwPrjLoadTool
markProjectSetNotDirty: projectSetDefinition

	"This method should only be used when the projectSetDefinitions have been read from disk - mark them not dirty. Not dirty means that the loaded things match the code on disk."

	projectSetDefinition deriveLoadedThings do: [:loadedProject |
		loadedProject markNotDirty.
		loadedProject loadedPackages valuesDo: [:loadedPackage | loadedPackage markNotDirty ] ].
%

category: 'private'
method: RwPrjLoadTool
_doProjectSetLoad: projectSetDefinition instanceMigrator: instanceMigrator originalProjectSet: originalProjectSet processedClassNames: processedClassNames
	| copiedProjectSetDef theClassName theClass projectDef theLoadedProject loadedClass packageDef |
	[ ^ self
		_loadProjectSetDefinition: projectSetDefinition
		instanceMigrator: instanceMigrator ]
			on: RwExistingVisitorAddingExistingClassNotification
			do: [:ex | 
				theClassName := ex classDefinition name.
				(processedClassNames includes: theClassName) ifTrue: [ ex resume ].
				theClass := Rowan globalNamed: theClassName.
				theClass isBehavior ifFalse: [ self halt. ex pass ].
				theLoadedProject := Rowan image loadedProjectNamed: theClass rowanProjectName.
				theLoadedProject 
					ifNil: [ 
						"the loaded project should not be nil - if it is, pass the notification"
						ex pass ].
				(originalProjectSet projectNamed: theLoadedProject name ifAbsent: []) 
					ifNotNil: [
						"If the loadedProject is in the originalProjectSet, then is likely to be a class move - resume and let the chips fall where they may"
						ex resume ].
				copiedProjectSetDef := projectSetDefinition copy.
				"a project in the original project set is taking ownership of an already  loaded class,
					remove the class from the original project's package and attempt a reload"
				projectDef := copiedProjectSetDef 
					projectNamed: theLoadedProject name
					ifAbsent: [ 
						projectDef := theLoadedProject asDefinition.
						copiedProjectSetDef addProject: projectDef.
						projectDef ].
				loadedClass := Rowan image loadedClassNamed: theClassName.
				packageDef := projectDef packageNamed: loadedClass loadedPackage name.
				packageDef removeClassNamed: theClassName.
				processedClassNames add: theClassName ].
	"trim the stack"
	^ self _doProjectSetLoad: copiedProjectSetDef instanceMigrator: instanceMigrator originalProjectSet: originalProjectSet processedClassNames: processedClassNames
%

category: 'private'
method: RwPrjLoadTool
_doProjectSetLoad_254: projectSetDefinition instanceMigrator: instanceMigrator originalProjectSet: originalProjectSet processedClassNames: processedClassNames
	| copiedProjectSetDef theClassName theClass projectDef theLoadedProject loadedClass packageDef |
	[ ^ self
		_loadProjectSetDefinition_254: projectSetDefinition
		instanceMigrator: instanceMigrator ]
			on: RwExistingVisitorAddingExistingClassNotification
			do: [:ex | 
				theClassName := ex classDefinition name.
				(processedClassNames includes: theClassName) ifTrue: [ ex resume ].
				theClass := Rowan globalNamed: theClassName.
				theClass isBehavior ifFalse: [ self halt. ex pass ].
				theLoadedProject := Rowan image loadedProjectNamed: theClass rowanProjectName.
				theLoadedProject 
					ifNil: [ 
						"the loaded project should not be nil - if it is, pass the notification"
						ex pass ].
				(originalProjectSet projectNamed: theLoadedProject name ifAbsent: []) 
					ifNotNil: [
						"If the loadedProject is in the originalProjectSet, then is likely to be a class move - resume and let the chips fall where they may"
						ex resume ].
				copiedProjectSetDef := projectSetDefinition copy.
				"a project in the original project set is taking ownership of an already  loaded class,
					remove the class from the original project's package and attempt a reload"
				projectDef := copiedProjectSetDef 
					projectNamed: theLoadedProject name
					ifAbsent: [ 
						projectDef := theLoadedProject asDefinition.
						copiedProjectSetDef addProject: projectDef.
						projectDef ].
				loadedClass := Rowan image loadedClassNamed: theClassName.
				packageDef := projectDef packageNamed: loadedClass loadedPackage name.
				packageDef removeClassNamed: theClassName.
				processedClassNames add: theClassName ].
	"trim the stack"
	^ self _doProjectSetLoad_254: copiedProjectSetDef instanceMigrator: instanceMigrator originalProjectSet: originalProjectSet processedClassNames: processedClassNames
%

category: 'private'
method: RwPrjLoadTool
_loadProjectSetDefinition: projectSetDefinitionToLoad instanceMigrator: instanceMigrator

	| loadedProjectSet diff loadedProjectInfo| 
	loadedProjectSet := projectSetDefinitionToLoad deriveLoadedThings
		asProjectDefinitionSet.
	diff := projectSetDefinitionToLoad compareAgainstBase: loadedProjectSet.
	diff isEmpty
		ifTrue: [ 
			| msg |
			msg := 'The projects are already up to date'.
			self inform: msg.
			^ msg ].
	loadedProjectInfo := projectSetDefinitionToLoad properties at: 'loadedProjectInfo' ifAbsent: [ Dictionary new ].
	loadedProjectInfo keysAndValuesDo: [:projectName :projectInfo |
			"install the packageMapSpecs for this load into the specification prior to the load"
			| projectDefinition |
			projectDefinition := projectSetDefinitionToLoad projectNamed: projectName ifAbsent: [].
			projectDefinition updateGsPlatformSpecLoadedProjectInfo: projectInfo ].
	Rowan image applyModification: diff instanceMigrator: instanceMigrator.
	projectSetDefinitionToLoad definitions
		do: [ :projectDef | 
			self specification: projectDef specification.
			projectDef projectDefinitionSourceProperty = RwLoadedProject _projectDiskDefinitionSourceValue
				ifTrue: [ projectDef  updateLoadedCommitIdForTool: self ].
			(loadedProjectInfo at: projectDef name ifAbsent: [])
				ifNotNil: [:map |
					projectDef specification imageSpec
						loadedConfigurationNames: (map at: 'loadedConfigurationNames');
						loadedGroupNames: (map at: 'loadedGroupNames') ]].
	^ diff
%

category: 'private'
method: RwPrjLoadTool
_loadProjectSetDefinition_254: projectSetDefinitionToLoad instanceMigrator: instanceMigrator

	| loadedProjectSet loadedProjectDefinitionSet diff loadedProjectInfo| 
	loadedProjectSet := projectSetDefinitionToLoad deriveLoadedThings.
	loadedProjectDefinitionSet := loadedProjectSet asProjectDefinitionSet.
	loadedProjectInfo := projectSetDefinitionToLoad properties at: 'loadedProjectInfo' ifAbsent: [ Dictionary new ].
	loadedProjectInfo keysAndValuesDo: [:projectName :projectInfo |
			"install the packageMapSpecs for this load into the specification prior to the load"
			| projectDefinition |
			projectDefinition := projectSetDefinitionToLoad projectNamed: projectName ifAbsent: [].
			projectDefinition updateGsPlatformSpecLoadedProjectInfo: projectInfo ].
	projectSetDefinitionToLoad definitions keysAndValuesDo: [:projectName :projectDefinition |
			projectDefinition packages keysAndValuesDo: [:packageName :packageDefinition |
				"set the target symbol dictionary name for each incoming package definition"
				packageDefinition gs_symbolDictionary: (projectDefinition symbolDictNameForPackageNamed: packageName) ] ].
	diff := projectSetDefinitionToLoad compareAgainstBase_254: loadedProjectDefinitionSet.
	diff isEmpty
		ifFalse: [  Rowan image applyModification_254: diff instanceMigrator: instanceMigrator ].
	projectSetDefinitionToLoad definitions
		do: [ :projectDef |
			| theSpec |
			theSpec := (loadedProjectSet entities at: projectDef name ifAbsent: [])
				ifNil: [ projectDef specification ]
				ifNotNil: [:loadedProject | loadedProject specification ].
			self specification: theSpec.
			projectDef projectDefinitionSourceProperty = RwLoadedProject _projectDiskDefinitionSourceValue
				ifTrue: [  theSpec updateLoadedCommitIdForTool: self ].
			(loadedProjectInfo at: projectDef name ifAbsent: [])
				ifNotNil: [:map |
					theSpec imageSpec
						loadedConfigurationNames: (map at: 'loadedConfigurationNames');
						loadedGroupNames: (map at: 'loadedGroupNames') ] ].
	^ diff
%

! Class implementation for 'RwPrjLogTool'

!		Instance methods for 'RwPrjLogTool'

category: 'smalltalk api'
method: RwPrjLogTool
commitLogProjectNamed: projectName limit: logLimit

	| loadedProject |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	self specification: loadedProject specification.
	^ specification commitLogForTool: self limit: logLimit
%

category: 'smalltalk api'
method: RwPrjLogTool
commitLogSpecification: aRwSpecification limit: logLimit
  self specification: aRwSpecification.
  ^ specification commitLogForTool: self limit: logLimit
%

category: 'smalltalk api'
method: RwPrjLogTool
commitLogSpecUrl: aString limit: logLimit
  ^ self
    commitLogSpecification: (RwSpecification fromUrl: aString)
    limit: logLimit
%

category: 'git'
method: RwPrjLogTool
doGitCommitLog: logLimit

	| gitTool gitRootPath |
	gitTool := Rowan gitTools.
	gitRootPath := specification repoSpec repositoryRootPath.
	^ gitTool gitlogtool: 'HEAD' limit: logLimit gitRepoDirectory: gitRootPath
%

! Class implementation for 'RwPrjPullTool'

!		Instance methods for 'RwPrjPullTool'

category: 'git'
method: RwPrjPullTool
doGitPull: remote

	| gitTool gitRootPath |
	gitTool := Rowan gitTools.
	gitRootPath := specification repoSpec repositoryRootPath.
	^ remote isEmpty
		ifTrue: [ gitTool gitpullIn: gitRootPath with: '' ]
		ifFalse: [ 
			| currentBranchName |
			currentBranchName := gitTool gitBranchNameIn: gitRootPath.
			gitTool gitpullIn: gitRootPath with: remote , ' ' , currentBranchName ]
%

category: 'smalltalk api'
method: RwPrjPullTool
pullSpecification: aRwSpecification
  ^ self pullSpecification: aRwSpecification remote: nil
%

category: 'smalltalk api'
method: RwPrjPullTool
pullSpecification: aRwSpecification remote: remoteOrNil
  | remote |
  self specification: aRwSpecification.
  remoteOrNil
    ifNil: [ remote := specification repoSpec remote ]
    ifNotNil: [ remote := remoteOrNil ].
  ^ specification pullForTool: self remote: remote
%

category: 'smalltalk api'
method: RwPrjPullTool
pullSpecUrl: aSpecUrlString
  ^ self
    pullSpecification: (RwSpecification fromUrl: aSpecUrlString)
    remote: nil
%

category: 'smalltalk api'
method: RwPrjPullTool
pullSpecUrl: aSpecUrlString remote: remote
  ^ self
    pullSpecification: (RwSpecification fromUrl: aSpecUrlString)
    remote: remote
%

! Class implementation for 'RwPrjPushTool'

!		Instance methods for 'RwPrjPushTool'

category: 'git'
method: RwPrjPushTool
doGitPush: remote

	| gitTool gitRootPath |
	gitTool := Rowan gitTools.
	gitRootPath := specification repoSpec repositoryRootPath.
	^ remote isEmpty
		ifTrue: [ gitTool gitpushIn: gitRootPath with: '' ]
		ifFalse: [ 
			| currentBranchName |
			currentBranchName := gitTool gitBranchNameIn: gitRootPath.
			gitTool gitpushIn: gitRootPath with: remote , ' ' , currentBranchName ]
%

category: 'smalltalk api'
method: RwPrjPushTool
pushSpecification: aRwSpecification
  ^ self pushSpecification: aRwSpecification remote: nil
%

category: 'smalltalk api'
method: RwPrjPushTool
pushSpecification: aRwSpecification remote: remoteOrNil
  | remote |
  self specification: aRwSpecification.
  remoteOrNil
    ifNil: [ remote := specification repoSpec remote ]
    ifNotNil: [ remote := remoteOrNil ].
  ^ specification pushForTool: self remote: remote
%

category: 'smalltalk api'
method: RwPrjPushTool
pushSpecUrl: aSpecUrlString
  ^ self
    pushSpecification: (RwSpecification fromUrl: aSpecUrlString)
    remote: nil
%

category: 'smalltalk api'
method: RwPrjPushTool
pushSpecUrl: aSpecUrlString remote: remote
  ^ self
    pushSpecification: (RwSpecification fromUrl: aSpecUrlString)
    remote: remote
%

! Class implementation for 'RwPrjQueryTool'

!		Instance methods for 'RwPrjQueryTool'

category: 'smalltalk API'
method: RwPrjQueryTool
classesForProjectNamed: projectName

	| loadedProject classes |
	classes := IdentitySet new.
	loadedProject := Rowan image loadedProjectNamed: projectName.
	loadedProject loadedPackages
		do: [ :loadedPackage | 
			loadedPackage loadedClasses values
				do: [ :rowanLoadedClass | classes add: rowanLoadedClass handle ] ].
	^ classes
%

category: 'smalltalk API'
method: RwPrjQueryTool
classExtensionsForProjectNamed: projectName

	| loadedProject classExtensions |
	classExtensions := IdentitySet new.
	loadedProject := Rowan image loadedProjectNamed: projectName.
	loadedProject loadedPackages
		do: [ :loadedPackage | 
			loadedPackage loadedClassExtensions values
				do: [ :rowanLoadedClass | classExtensions add: rowanLoadedClass handle ] ].
	^ classExtensions
%

! Class implementation for 'RwPrjReadTool'

!		Instance methods for 'RwPrjReadTool'

category: 'read configurations'
method: RwPrjReadTool
readConfigurationsForProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames

	| spec theConfigNames theGroupNames |
	spec := projectDefinition specification.
	theConfigNames := configNames isEmpty
		ifTrue: [ spec defaultConfigurationNames ]
		ifFalse: [ configNames ].
	theGroupNames := groupNames isEmpty
		ifTrue: [  spec defaultGroupNames ]
		ifFalse: [ groupNames ].
	^ self 
		_visitConfigurations: RwProjectLoadConfigurationVisitor 
		forProjectDefinition: projectDefinition 
		withConfigurations: theConfigNames 
		groupNames: theGroupNames
%

category: 'read project definitions'
method: RwPrjReadTool
readProjectDefinition: projectDefinition
	"read all of the packages in the existing Rowan project associated with the given project definition"

	|  repo packageNames |
	repo := projectDefinition repositoryUrl asRwRepository.
	packageNames := repo packageNames.
	^ self 
		_readProjectDefinition: projectDefinition 
		packageNames: packageNames
		fromRepo: repo
%

category: 'read project definitions'
method: RwPrjReadTool
readProjectSetForProjectDefinition: projectDefinition

	| repo spec packageNames |
	spec := projectDefinition specification.
	spec loadedConfigurationNames
		ifNotNil: [:configNames |
			"project has been loaded previously, use the loaded config and group names"
			^ self 
					readProjectSetForProjectDefinition: projectDefinition
					withConfigurations: configNames
					groupNames: spec loadedGroupNames ].
	spec defaultConfigurationNames
		ifNotNil: [:configNames |
			"project has not been loaded previously use the default config and group names from the spec"
			^ self 
					readProjectSetForProjectDefinition: projectDefinition
					withConfigurations: configNames
					groupNames: spec defaultGroupNames ].
	"no configuration associated with the project, load all of the packages in the repository"
	repo := projectDefinition repositoryUrl asRwRepository.
	packageNames := repo packageNames.
	^ self 
		_readProjectSetForProjectDefinition: projectDefinition 
		packageNames: packageNames
		fromRepo: repo
%

category: 'read project definitions'
method: RwPrjReadTool
readProjectSetForProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames

	| projectName repo spec packageNames projectSetDefinition packageMapSpecs visitor |
	projectName := projectDefinition name.
	spec := projectDefinition specification.
	repo := projectDefinition repositoryUrl asRwRepository.
	visitor := self readConfigurationsForProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames.
	visitor 
		ifNotNil: [ 
			packageNames := visitor packageNames.
			packageMapSpecs := visitor packageMapSpecs ]
		ifNil: [ 
			packageNames := projectDefinition packageNames.
			packageMapSpecs := Dictionary new ].	
	projectSetDefinition := self 
		_readProjectSetForProjectDefinition: projectDefinition 
		packageNames: packageNames 
		fromRepo: repo.
	((projectSetDefinition properties at: 'loadedProjectInfo' ifAbsentPut: [Dictionary new])
		at: projectName ifAbsentPut: [ Dictionary new ])
			at: 'loadedConfigurationNames' put: configNames;
			at: 'loadedGroupNames' put: groupNames;
			at: 'packageMapSpecs' put: packageMapSpecs.
	^ projectSetDefinition
%

category: 'read project by name'
method: RwPrjReadTool
readProjectSetForProjectNamed: projectName

	| projectDefinition |
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	^ self readProjectSetForProjectDefinition: projectDefinition
%

category: 'deprecation candidates'
method: RwPrjReadTool
readProjectSetForProjectNamed: projectName withConfiguration: configName

	| projectDefinition repo spec url config |
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	spec := projectDefinition specification.
	url := 'file:' , spec repositoryRootPath , '/' , spec configsPath , '/'
		, configName , '.ston'.
	[ config := RwAbstractProjectConfiguration fromUrl: url ]
		on: Error
		do: [ :ignored | 
			^ self readProjectSetForProjectNamed: projectName ].
	repo := projectDefinition repositoryUrl asRwRepository.
	config projectName: projectName.
	^ self 
		_readProjectSetForProjectDefinition: projectDefinition 
		packageNames: config resolvePackageNames 
		fromRepo: repo
%

category: 'read project by name'
method: RwPrjReadTool
readProjectSetForProjectNamed: projectName withConfigurations: configNames groupNames: groupNames

	| projectDefinition |
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	^ self readProjectSetForProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames
%

category: 'read project by name'
method: RwPrjReadTool
readProjectSetForProjectNamed: projectName withGroupNames: groupNames

	| projectDefinition spec theConfigNames |
	projectDefinition := (Rowan image loadedProjectNamed: projectName) asDefinition.
	spec := projectDefinition specification.
	theConfigNames := spec loadedConfigurationNames
		ifNotNil: [:configNames | configNames ]
		ifNil: [
			spec defaultConfigurationNames
				ifNotNil: [:configNames | configNames ]
				ifNil: [ #('Default') ] ].
	^ self 
		readProjectSetForProjectDefinition: projectDefinition 
		withConfigurations: theConfigNames 
		groupNames: groupNames
%

category: 'validation'
method: RwPrjReadTool
validate: aRwSpecification
  super validate: aRwSpecification.
  self validateForRead: aRwSpecification
%

category: 'private'
method: RwPrjReadTool
_readProjectDefinition: projectDefinition packageNames: packageNames fromRepo: repo

	projectDefinition packageNames do: [:packageName | 
		(packageNames includes: packageName) 
			ifFalse: [ 
				"deleted package"
				projectDefinition removePackageNamed: packageName ] ].
	packageNames
		do: [ :packageName | 
			| structureName reader packageDefinition |
			structureName := packageName , repo packageExtension.
			reader := repo reader.
			reader
				packageStructure: (RwCypressPackageStructure named: structureName);
				packageDirectory:
						(reader fileUtils
								directoryFromPath: structureName
								relativeTo: repo directoryPath);
				readPackageStructure.
			packageDefinition := reader packageStructure rwSnapshot.
			projectDefinition addOrUpdatePackage: packageDefinition ].
	projectDefinition propertyAt: RwLoadedProject _projectDefinitionSourceKey put: RwLoadedProject _projectDiskDefinitionSourceValue.
	^ projectDefinition
%

category: 'private'
method: RwPrjReadTool
_readProjectSetForProjectDefinition: projectDefinition packageNames: packageNames fromRepo: repo

	self _readProjectDefinition: projectDefinition packageNames: packageNames fromRepo: repo.
	^ RwProjectSetDefinition new
		addProject: projectDefinition;
		yourself
%

category: 'private'
method: RwPrjReadTool
_visitConfigurations: visitorClass forProjectDefinition: projectDefinition withConfigurations: configNames groupNames: groupNames

	| spec projectName configDirectory visitor |
	spec := projectDefinition specification.
	projectName := projectDefinition name.
	configDirectory := spec repositoryRootPath , '/' , spec configsPath , '/'.
	(Rowan fileUtilities directoryExists: configDirectory)
		ifFalse: [ ^ nil ].
	visitor := visitorClass new
		platformAttributes: Rowan platformConfigurationAttributes;
		groupNames: groupNames;
		configurationBasePath: configDirectory;
		yourself.
	configNames do: [:configName |
		| config url |
		url := 'file:' , configDirectory, configName , '.ston'.
		config := RwAbstractProjectConfiguration fromUrl: url.
		config projectName: projectName.
		visitor visit: config ].
	^visitor
%

! Class implementation for 'RwPrjReconcileTool'

!		Instance methods for 'RwPrjReconcileTool'

category: 'smalltalk api'
method: RwPrjReconcileTool
reconcileGlobalClassExtensionsForProjectDefinitionSet: projectDefinitionSet defaultGroupName: defaultGroupName globalsGroupName: globalsGroupName globalsUserId: globalsUserId

	| configExportMap |
	configExportMap := Dictionary new.
	projectDefinitionSet projects do: [:projectDef |
		| config movedClassExtensions globalPackageNames originalPackageNames |
		movedClassExtensions := Set new.
		globalPackageNames := Set new.
		originalPackageNames := projectDef packageNames.
		projectDef packages values do: [:packageDef |
			packageDef classExtensions values do: [:classDef |
				(Globals 
					at: classDef name asSymbol 
					ifAbsent: [])
						ifNotNil: [ 
							"the class extension is for a class that is Globals, so it needs to be moved to a new Globals extension package"
							movedClassExtensions add: {classDef . packageDef . projectDef } ] ] ].
		movedClassExtensions do: [:ar |
			| theClassDef packageDef theProjectDef  newPackageName |
			theClassDef := ar at: 1.
			packageDef := ar at: 2.
			theProjectDef := ar at: 3.
			newPackageName :=  packageDef name , '-Globals'.
			self 
				_moveClassExtension: theClassDef 
				toNewPackageNamed: packageDef name , '-Globals'
				clonedFrom: packageDef 
				inProject: theProjectDef.
			globalPackageNames add: newPackageName ].
		config := RwProjectLoadConfiguration new
			name: 'Default';
			projectName: projectDef name;
			yourself.
		{ defaultGroupName . globalsGroupName }
			do: [:groupName | config addDefinedGroupName: groupName ].
		config 
			conditionalPackagesAtConditions: { Rowan platform basePlatformAttribute } 
				andGroup: defaultGroupName 
				addPackageNames: originalPackageNames;
			conditionalPackagesAtConditions: { Rowan platform basePlatformAttribute } 
				andGroup: globalsGroupName 
				addPackageNames: globalPackageNames.
		globalPackageNames do: [:packageName |
			config 
				conditionalPackageMapSpecsAtGemStoneUserId: globalsUserId 
				andPackageName: packageName 
				setSymbolDictNameTo: 'Globals' ].
		configExportMap at: config put: projectDef configurationExportUrl ].
	^ configExportMap
%

category: 'smalltalk api'
method: RwPrjReconcileTool
reconcileGlobalClassExtensionsForProjectFromSpecUrl: specUrl defaultGroupName: defaultGroupName globalsGroupName: globalsGroupName  globalsUserId: globalsUserId writeProject: writeProjectBool
	| projectDefinition projectDefinitionSet projectTools loadedProjectInfo configExportMap |
	projectTools := Rowan projectTools.
	projectDefinition := projectTools create createProjectDefinitionFromSpecUrl: specUrl.
	projectDefinitionSet := projectTools read readProjectSetForProjectDefinition: projectDefinition.

	loadedProjectInfo := projectDefinitionSet properties at: 'loadedProjectInfo' ifAbsent: [ Dictionary new ].
	loadedProjectInfo keysAndValuesDo: [:projectName :projectInfo |
			"install the packageMapSpecs for this load into the specification prior to the reconcile"
			(projectDefinitionSet projectNamed: projectName ifAbsent: [])
				updateGsPlatformSpecLoadedProjectInfo: projectInfo ].

	configExportMap := self 
		reconcileGlobalClassExtensionsForProjectDefinitionSet: projectDefinitionSet 
		defaultGroupName: defaultGroupName 
		globalsGroupName: globalsGroupName  
		globalsUserId: globalsUserId.
	writeProjectBool
		ifTrue: [
			configExportMap keysAndValuesDo: [:config :exportUrl |
				config exportToUrl: exportUrl ].
			projectTools write writeProjectDefinition: projectDefinition ].
	^ projectDefinition
%

category: 'smalltalk api'
method: RwPrjReconcileTool
reconcileProjectDefinitionSet: projectDefinitionSet
	| movedClassExtensions packageNameToSymbolDictNameMap configExportMap |

	configExportMap := Dictionary new.
	movedClassExtensions := Set new.
	packageNameToSymbolDictNameMap := Dictionary new.
	projectDefinitionSet projects do: [:projectDef |
		| config |
		projectDef packages values do: [:packageDef |
			packageDef classDefinitions values do: [:classDef |
				self 
					_checkExpectedSymbolDictForClassDefinition: classDef 
					packageDef: packageDef 
					projectDef: projectDef 
					classNotFound: [:theClassDef  | self error: 'The class ', theClassDef name printString, ' not found' ] 
					ifCorrect: [:theClassDef :actualSymDictName | 
						(packageNameToSymbolDictNameMap at: packageDef name ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol ] 
					ifIncorrect: [:theClassDef :expectedSymDictName :actualSymDictName | 
						"the class is defined in the actualSymDictName and that's where the package should be loaded"
						(packageNameToSymbolDictNameMap at: packageDef name ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol ] ].
			packageDef classExtensions values do: [:classDef |
				self 
					_checkExpectedSymbolDictForClassDefinition: classDef 
					packageDef: packageDef 
					projectDef: projectDef 
					classNotFound: [:theClassDef  | self error: 'The class to be extended ', theClassDef name printString, ' not found'  ] 
					ifCorrect: [:theClassDef :actualSymDictName | 
						(packageNameToSymbolDictNameMap at: packageDef name ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol ] 
					ifIncorrect: [:theClassDef :expectedSymDictName :actualSymDictName | 
						"the class extension is in the actualSymDictName and that's where the package should be loaded"
						movedClassExtensions add: {theClassDef . packageDef . actualSymDictName . projectDef } ] ] ].
		movedClassExtensions do: [:ar |
			| theClassDef packageDef actualSymDictName theProjectDef  newPackageDef|
			theClassDef := ar at: 1.
			packageDef := ar at: 2.
			actualSymDictName := ar at: 3.
			theProjectDef := ar at: 4.
			newPackageDef := self 
				_moveClassExtension: theClassDef 
				toNewPackageClonedFrom: packageDef 
				inSymbolDictionary: actualSymDictName 
				inProject: theProjectDef.
			(packageNameToSymbolDictNameMap at: newPackageDef name ifAbsentPut: [ IdentitySet new ]) add: actualSymDictName asSymbol  ].
		config := projectDef configurationTemplate.
		packageNameToSymbolDictNameMap keysAndValuesDo: [:packageName :symDictNames |
			symDictNames size > 1 ifTrue: [ self error: 'More than one symbol dictionary associated with package ', packageName printString ].
			config 
				conditionalPackageMapSpecsAtGemStoneUserId: Rowan image currentUserId 
				andPackageName: packageName 
				setSymbolDictNameTo: symDictNames any ].
		configExportMap at: config put: projectDef configurationExportUrl ].
	^ configExportMap
%

category: 'smalltalk api'
method: RwPrjReconcileTool
reconcileProjectFromSpecUrl: specUrl writeProject: writeProjectBool
	| projectDefinition projectDefinitionSet projectTools loadedProjectInfo configExportMap |
	projectTools := Rowan projectTools.
	projectDefinition := projectTools create createProjectDefinitionFromSpecUrl: specUrl.
	projectDefinitionSet := projectTools read readProjectSetForProjectDefinition: projectDefinition.

	loadedProjectInfo := projectDefinitionSet properties at: 'loadedProjectInfo' ifAbsent: [ Dictionary new ].
	loadedProjectInfo keysAndValuesDo: [:projectName :projectInfo |
			"install the packageMapSpecs for this load into the specification prior to the reconcile"
			(projectDefinitionSet projectNamed: projectName ifAbsent: [])
				updateGsPlatformSpecLoadedProjectInfo: projectInfo ].

	configExportMap := self reconcileProjectDefinitionSet: projectDefinitionSet.
	writeProjectBool
		ifTrue: [
			configExportMap keysAndValuesDo: [:config :exportUrl |
				config exportToUrl: exportUrl ].
			projectTools write writeProjectDefinition: projectDefinition ].
	^ projectDefinition
%

category: 'private'
method: RwPrjReconcileTool
_checkExpectedSymbolDictForClassDefinition: classDef packageDef: packageDef projectDef: projectDef classNotFound: classNotFoundBlock ifCorrect: correctBlock ifIncorrect: incorrectBlock
	| class ar symDict expectedSymDictName actualSymDictName |
	class := Rowan globalNamed: classDef name.
	class
		ifNil: [ classNotFoundBlock value: classDef ]
		ifNotNil: [
			ar := Rowan image symbolList dictionariesAndSymbolsOf: class.
			ar size > 1 ifTrue: [self error: 'The class ', classDef name printString, ' is in multiple symbol dictionaries'].
			symDict := ar first at: 1.
			actualSymDictName := symDict name asString.
			expectedSymDictName := projectDef symbolDictNameForPackageNamed: packageDef name.
			expectedSymDictName = actualSymDictName
				ifTrue: [ correctBlock value: classDef value: actualSymDictName ]
				ifFalse: [ incorrectBlock value:  classDef value: expectedSymDictName value: actualSymDictName ] ]
%

category: 'private'
method: RwPrjReconcileTool
_moveClassExtension: theClassExtension toNewPackageClonedFrom: packageDef inSymbolDictionary: expectedSymDictName inProject: projectDef

	| newPackageName newPackageDef |
	newPackageName := packageDef name, '-ext-', expectedSymDictName.
	newPackageDef := projectDef 
		packageNamed: newPackageName 
		ifAbsent: [ 
			| pDef |
			pDef := RwPackageDefinition newNamed: newPackageName.
			projectDef addPackage: pDef.
			pDef ].
	packageDef removeClassExtension: theClassExtension.
	newPackageDef addClassExtension: theClassExtension.
	"update the method categories --- hybrid only ... but that is what we're doing"
	theClassExtension instanceMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	theClassExtension classMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	^ newPackageDef
%

category: 'private'
method: RwPrjReconcileTool
_moveClassExtension: theClassExtension toNewPackageNamed: newPackageName clonedFrom: packageDef inProject: projectDef

	| newPackageDef |
	newPackageDef := projectDef 
		packageNamed: newPackageName 
		ifAbsent: [ 
			| pDef |
			pDef := RwPackageDefinition newNamed: newPackageName.
			projectDef addPackage: pDef.
			pDef ].
	packageDef removeClassExtension: theClassExtension.
	newPackageDef addClassExtension: theClassExtension.
	"update the method categories --- hybrid only ... but that is what we're doing"
	theClassExtension instanceMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	theClassExtension classMethodDefinitions values do: [:methodDef |
		methodDef protocol: '*', newPackageName ].
	^ newPackageDef
%

! Class implementation for 'RwPrjRegisterTool'

!		Instance methods for 'RwPrjRegisterTool'

category: 'smalltalk api'
method: RwPrjRegisterTool
registerSpecification: aRwSpecification

  self specification: aRwSpecification.
  ^ specification register
%

category: 'smalltalk api'
method: RwPrjRegisterTool
registerSpecification: aRwSpecification as: aSpecName
  self registerSpecification: aRwSpecification copy.
%

category: 'smalltalk api'
method: RwPrjRegisterTool
registerSpecUrl: aString as: aSpecName
  ^ self registerSpecification: (RwSpecification fromUrl: aString) copy.
%

! Class implementation for 'RwPrjRegistryTool'

!		Instance methods for 'RwPrjRegistryTool'

category: 'smalltalk api'
method: RwPrjRegistryTool
registeredSpecNames

	^ Rowan projectNames
%

category: 'smalltalk api'
method: RwPrjRegistryTool
registeredSpecs

	^ Rowan projectNames collect: [ :aString | Rowan image loadedProjectNamed: aString ]
%

! Class implementation for 'RwPrjSpecTool'

!		Instance methods for 'RwPrjSpecTool'

category: 'smalltalk api'
method: RwPrjSpecTool
exportProjectDefinition: projectDefinition

	self specification: projectDefinition specification.
	^ specification export
%

category: 'smalltalk api'
method: RwPrjSpecTool
exportProjectNamed: projectName

	| loadedProject |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	self specification: loadedProject specification.
	^ specification export
%

category: 'smalltalk api'
method: RwPrjSpecTool
exportSpecification: aRwSpecification

	self specification: aRwSpecification.
	^specification export
%

category: 'smalltalk api'
method: RwPrjSpecTool
exportSpecification: aRwSpecification toUrl: fileUrl

	self specification: aRwSpecification.
	^specification exportToUrl: fileUrl
%

category: 'smalltalk api'
method: RwPrjSpecTool
exportSpecUrl: aString

	^ self exportSpecification: (RwSpecification fromUrl: aString)
%

category: 'smalltalk api'
method: RwPrjSpecTool
exportSpecUrl: aString toUrl: exportUrl

	^ self exportSpecification: (RwSpecification fromUrl: aString) toUrl: exportUrl
%

category: 'smalltalk api'
method: RwPrjSpecTool
specForProjectNamed: projectName

	| loadedProject |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	^ loadedProject specification
%

! Class implementation for 'RwPrjTestTool'

!		Instance methods for 'RwPrjTestTool'

category: 'smalltalk api'
method: RwPrjTestTool
testSuiteForProjectNamed: projectName

	| suite |
	suite := TestSuite named: projectName , ' tests'.
	self _addTestsForProjectNamed: projectName toTestSuite: suite.
	^ suite
%

category: 'smalltalk api'
method: RwPrjTestTool
testSuiteForProjectsNamed: projectNames

	| suite strm |
	strm := WriteStream on: String new.
	projectNames do: [:projectName | strm nextPutAll: projectName; space ].
	strm nextPutAll:  'tests'.
	suite := TestSuite named: strm contents.
	projectNames do: [:projectName | self _addTestsForProjectNamed: projectName toTestSuite: suite ].
	^ suite
%

category: 'private'
method: RwPrjTestTool
_addTestsForProjectNamed: projectName toTestSuite: suite

	| loadedProject |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	loadedProject loadedPackages
		do: [ :loadedPackage | 
			loadedPackage loadedClasses values
				do: [ :rowanLoadedClass | 
					| cl |
					cl := rowanLoadedClass handle.
					(cl inheritsFrom: TestCase)
						ifTrue: [ 
							cl isAbstract
								ifFalse: [ suite addTests: cl suite tests ] ] ] ].
	^ suite
%

! Class implementation for 'RwPrjUnregisterTool'

!		Instance methods for 'RwPrjUnregisterTool'

category: 'smalltalk api'
method: RwPrjUnregisterTool
unregisterSpecification: aRwSpecification

  self specification: aRwSpecification.
  ^ specification unregister
%

category: 'smalltalk api'
method: RwPrjUnregisterTool
unregisterSpecUrl: aString

	^ self unregisterSpecification: (RwSpecification fromUrl: aString)
%

! Class implementation for 'RwPrjUpgradeTool'

!		Instance methods for 'RwPrjUpgradeTool'

category: 'utilities'
method: RwPrjUpgradeTool
markProjectSetNotDirty: projectSetDefinition

	"This method should only be used when the projectSetDefinitions have been read from disk - mark them not dirty. Not dirty means that the loaded things match the code on disk."

	projectSetDefinition deriveLoadedThings do: [:loadedProject |
		loadedProject markNotDirty.
		loadedProject loadedPackages valuesDo: [:loadedPackage | loadedPackage markNotDirty ] ].
%

category: 'upgradeproject by spec url'
method: RwPrjUpgradeTool
upgradeProjectFromSpecUrl: fileUrlOrString

	| projectDefinition projectSetDefinition res |
	projectDefinition := Rowan projectTools create createProjectDefinitionFromSpecUrl: fileUrlOrString.
	projectSetDefinition := Rowan projectTools read readProjectSetForProjectDefinition: projectDefinition.
	res := self
		_doProjectSetUpgrade: projectSetDefinition
		instanceMigrator: Rowan platform instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: 'private'
method: RwPrjUpgradeTool
_doProjectSetUpgrade: projectSetDefinition instanceMigrator: instanceMigrator originalProjectSet: originalProjectSet processedClassNames: processedClassNames
	| copiedProjectSetDef theClassName theClass projectDef theLoadedProject loadedClass packageDef |
	[ ^ self
		_upgradeProjectSetDefinition: projectSetDefinition
		instanceMigrator: instanceMigrator ]
			on: RwExistingVisitorAddingExistingClassNotification
			do: [:ex | 
				theClassName := ex classDefinition name.
				(processedClassNames includes: theClassName) ifTrue: [ ex resume ].
				theClass := Rowan globalNamed: theClassName.
				theClass isBehavior ifFalse: [ self halt. ex pass ].
				theLoadedProject := Rowan image loadedProjectNamed: theClass rowanProjectName.
				theLoadedProject 
					ifNil: [ 
						"the loaded project should not be nil - if it is, pass the notification"
						ex pass ].
				(originalProjectSet projectNamed: theLoadedProject name ifAbsent: []) 
					ifNotNil: [
						"If the loadedProject is in the originalProjectSet, then is likely to be a class move - resume and let the chips fall where they may"
						ex resume ].
				copiedProjectSetDef := projectSetDefinition copy.
				"a project in the original project set is taking ownership of an already  loaded class,
					remove the class from the original project's package and attempt a reload"
				projectDef := copiedProjectSetDef 
					projectNamed: theLoadedProject name
					ifAbsent: [ 
						projectDef := theLoadedProject asDefinition.
						copiedProjectSetDef addProject: projectDef.
						projectDef ].
				loadedClass := Rowan image loadedClassNamed: theClassName.
				packageDef := projectDef packageNamed: loadedClass loadedPackage name.
				packageDef removeClassNamed: theClassName.
				processedClassNames add: theClassName ].
	"trim the stack"
	^ self _doProjectSetUpgrade: copiedProjectSetDef instanceMigrator: instanceMigrator originalProjectSet: originalProjectSet processedClassNames: processedClassNames
%

category: 'private'
method: RwPrjUpgradeTool
_upgradeProjectSetDefinition: projectSetDefinitionToLoad instanceMigrator: instanceMigrator

	| loadedProjectSet loadedProjectDefinitionSet diff loadedProjectInfo| 
	loadedProjectSet := projectSetDefinitionToLoad deriveLoadedThings.
	loadedProjectDefinitionSet := loadedProjectSet asProjectDefinitionSet.
	loadedProjectInfo := projectSetDefinitionToLoad properties at: 'loadedProjectInfo' ifAbsent: [ Dictionary new ].
	loadedProjectInfo keysAndValuesDo: [:projectName :projectInfo |
			"install the packageMapSpecs for this load into the specification prior to the load"
			| projectDefinition |
			projectDefinition := projectSetDefinitionToLoad projectNamed: projectName ifAbsent: [].
			projectDefinition updateGsPlatformSpecLoadedProjectInfo: projectInfo ].
	projectSetDefinitionToLoad definitions keysAndValuesDo: [:projectName :projectDefinition |
			projectDefinition packages keysAndValuesDo: [:packageName :packageDefinition |
				"set the target symbol dictionary name for each incoming package definition"
				packageDefinition gs_symbolDictionary: (projectDefinition symbolDictNameForPackageNamed: packageName) ] ].
	diff := projectSetDefinitionToLoad compareAgainstBase_forUpgrade: loadedProjectDefinitionSet.
	diff isEmpty
		ifFalse: [  Rowan image applyModification_254: diff instanceMigrator: instanceMigrator ].
	projectSetDefinitionToLoad definitions
		do: [ :projectDef |
			| theSpec |
			theSpec := (loadedProjectSet entities at: projectDef name ifAbsent: [])
				ifNil: [ projectDef specification ]
				ifNotNil: [:loadedProject | loadedProject specification ].
			self specification: theSpec.
			projectDef projectDefinitionSourceProperty = RwLoadedProject _projectDiskDefinitionSourceValue
				ifTrue: [  theSpec updateLoadedCommitIdForTool: self ].
			(loadedProjectInfo at: projectDef name ifAbsent: [])
				ifNotNil: [:map |
					theSpec imageSpec
						loadedConfigurationNames: (map at: 'loadedConfigurationNames');
						loadedGroupNames: (map at: 'loadedGroupNames') ] ].
	^ diff
%

! Class implementation for 'RwPrjWriteTool'

!		Instance methods for 'RwPrjWriteTool'

category: 'smalltalk api'
method: RwPrjWriteTool
validate: aRwSpecification
  super validate: aRwSpecification.
  self validateForWrite: aRwSpecification
%

category: 'smalltalk api'
method: RwPrjWriteTool
writePackageSet: aRwPackageSet specification: aRwSpecification

	| repo repositoryUrl |
	self specification: aRwSpecification.
	repositoryUrl := specification repositoryUrl
		ifNil: [ 
			specification repoSpec repositoryRootPath
				ifNil: [ self error: 'repositoryUrl or repository rootPath must be defined in url' ]
				ifNotNil: [ :rootPath | ('cypress:' , rootPath , '/' , specification repoPath , '/') asRwUrl ] ]
		ifNotNil: [ :urlString | urlString asRwUrl ].
	repo := repositoryUrl asRwRepository.
	aRwPackageSet packages values
		do: [ :rwPackage | 
			| packageStructure |
			packageStructure := RwCypressPackageStructure fromPackage: rwPackage.
			repo writePackageStructure: packageStructure ].
	^ specification
%

category: 'smalltalk api'
method: RwPrjWriteTool
writeProjectDefinition: projectDefinition
	"project defintion does represent a loaded project, so the loaded projects and packages 
		will not be marked not dirty"

	| repo repositoryUrl |
	repositoryUrl := projectDefinition repositoryUrl
		ifNil: [ 
			projectDefinition repositoryRootPath
				ifNil: [ self error: 'repositoryUrl or repository rootPath must be defined in url' ]
				ifNotNil: [ :rootPath | ('cypress:' , rootPath , '/' , projectDefinition repoPath , '/') asRwUrl ] ]
		ifNotNil: [ :urlString | urlString asRwUrl ].
	repo := repositoryUrl asRwRepository.
	projectDefinition packages values
		do: [ :rwPackageDefinition | 
			| packageStructure |
			packageStructure := RwCypressPackageStructure
				fromPackage: rwPackageDefinition.
			repo writePackageStructure: packageStructure ]
%

category: 'smalltalk api'
method: RwPrjWriteTool
writeProjectNamed: projectName

	| loadedProject repo repositoryUrl projectDefinition packageDefinitionSet loadedPackages |
	loadedProject := Rowan image loadedProjectNamed: projectName.
	projectDefinition := loadedProject asDefinition.
	repositoryUrl := projectDefinition repositoryUrl
		ifNil: [ 
			projectDefinition repositoryRootPath
				ifNil: [ self error: 'repositoryUrl or repository rootPath must be defined in url' ]
				ifNotNil: [ :rootPath | ('cypress:' , rootPath , '/' , projectDefinition repoPath , '/') asRwUrl ] ]
		ifNotNil: [ :urlString | urlString asRwUrl ].
	repo := repositoryUrl asRwRepository.
	loadedPackages := self _loadedPackagesForProject: projectDefinition.
	packageDefinitionSet := loadedPackages asPackageDefinitionSet.
	packageDefinitionSet
		do: [ :rwPackageDefinition | 
			| packageStructure |
			packageStructure := RwCypressPackageStructure
				fromPackage: rwPackageDefinition.
			repo writePackageStructure: packageStructure ].
	"loaded project and loaded packages written to disk - mark them not dirty"
	loadedProject markNotDirty.
	loadedPackages do: [:loadedPackage | loadedPackage markNotDirty ].
%

category: 'private'
method: RwPrjWriteTool
_loadedPackagesForProject: projectDefinition

	"Answer a PackageSet containing packages for the given project definition."

	^ self
		_loadedPackagesNamed: projectDefinition packageNames
		forProject: projectDefinition
%

category: 'private'
method: RwPrjWriteTool
_loadedPackagesNamed: someNames forProject: projectDefinition

	"Answer a PackageSet containing packages with the given names in the image.
 	If any name is not a loaded package, that name is ignored."

	"very likely we should be dealing with a project name at this point ... unless there is a use 
		case for loading a collection of packages without directly using the project interface 
		--- loaded packages do know what project they belong to ... so there might be something 
		done behind the scenes"

	| loadedPackages |
	loadedPackages := someNames
		collect: [ :aName | Rowan image loadedPackageNamed: aName ifAbsent: [ nil ] ].
	^ RwEntitySet
		withAll:
			(loadedPackages
				select: [ :loadedPackage | 
					loadedPackage notNil
						and: [ loadedPackage loadedProject name = projectDefinition name ] ])
%

! Class implementation for 'RwRepositoryTool'

!		Class methods for 'RwRepositoryTool'

category: 'commands'
classmethod: RwRepositoryTool
add
  ^ RwRepAddTool new
%

category: 'commands'
classmethod: RwRepositoryTool
commit
  ^ RwRepCommitTool new
%

category: 'commands'
classmethod: RwRepositoryTool
list
  ^ RwRepListTool new
%

category: 'commands'
classmethod: RwRepositoryTool
packages
  ^ RwRepPackagesTool new
%

category: 'commands'
classmethod: RwRepositoryTool
pull
  ^ RwRepPullTool new
%

category: 'commands'
classmethod: RwRepositoryTool
push
  ^ RwRepPushTool new
%

category: 'commands'
classmethod: RwRepositoryTool
remove
  ^ RwRepRemoveTool new
%

! Class implementation for 'RwRepCommitTool'

!		Instance methods for 'RwRepCommitTool'

category: 'smalltalk api'
method: RwRepCommitTool
commitRepositoryForSpecification: aRwSpecification message: messageString
  self specification: aRwSpecification.
  specification canCommit
    ifFalse: [ 
      | msg |
      msg := 'repository for ' , specification specName printString
        ,
          ' does not support commit operations. Source written to repository and skipping commit'.
      self inform: msg.
      ^ msg ].
  specification commitForTool: self message: messageString.
  ^ specification updateLoadedCommitIdForTool: self
%

category: 'smalltalk api'
method: RwRepCommitTool
commitRepositoryForSpecUrl: aSpecUrlString message: messageString
  "commit repository"

  ^ self
    commitRepositoryForSpecification: (RwSpecification fromUrl: aSpecUrlString)
    message: messageString
%

! Class implementation for 'RwClassAdditionOrRemoval'

!		Class methods for 'RwClassAdditionOrRemoval'

category: 'instance creation'
classmethod: RwClassAdditionOrRemoval
packageDefinition: aPackageDefinition classKey: aClassKey classesModification: aClassesModification

	^(self new)
		packageDefinition: aPackageDefinition;
		classKey: aClassKey;
		classesModification: aClassesModification;
		yourself
%

category: 'instance creation'
classmethod: RwClassAdditionOrRemoval
projectDefinition: aProjectDefinition packageDefinition: aPackageDefinition classKey: aClassKey classesModification: aClassesModification

	^(self new)
		projectDefinition: aProjectDefinition;
		packageDefinition: aPackageDefinition;
		classKey: aClassKey;
		classesModification: aClassesModification;
		yourself
%

!		Instance methods for 'RwClassAdditionOrRemoval'

category: 'Accessing'
method: RwClassAdditionOrRemoval
classesModification
	^classesModification
%

category: 'Updating'
method: RwClassAdditionOrRemoval
classesModification: newValue
	classesModification := newValue
%

category: 'Accessing'
method: RwClassAdditionOrRemoval
classKey
	^classKey
%

category: 'Updating'
method: RwClassAdditionOrRemoval
classKey: newValue
	classKey := newValue
%

category: 'Accessing'
method: RwClassAdditionOrRemoval
packageDefinition
	^packageDefinition
%

category: 'Updating'
method: RwClassAdditionOrRemoval
packageDefinition: newValue
	packageDefinition := newValue
%

category: 'Accessing'
method: RwClassAdditionOrRemoval
projectDefinition
	^projectDefinition
%

category: 'Updating'
method: RwClassAdditionOrRemoval
projectDefinition: newValue
	projectDefinition := newValue
%

! Class implementation for 'RwConfiguration'

!		Instance methods for 'RwConfiguration'

category: 'testing'
method: RwConfiguration
needsPackageProtocolNames

	"Answer true if image protocol names need to be *<packageName>*"

	^ packageInfoSource == #'Category'
%

category: 'accessing'
method: RwConfiguration
packageInfoSource
	^packageInfoSource
%

category: 'accessing'
method: RwConfiguration
packageInfoSource: newValue
	"Valid values for GemStone are #Cypress, #Category, #SymbolDictionary"

	packageInfoSource := newValue
%

! Class implementation for 'RwDefinition'

!		Class methods for 'RwDefinition'

category: 'instance creation'
classmethod: RwDefinition
new

	^(super new)
		initialize;
		yourself
%

!		Instance methods for 'RwDefinition'

category: 'private'
method: RwDefinition
addDefinition: aDefinition to: aDictionary

	| key |
	key := aDefinition key.
	(aDictionary includesKey: key)
		ifTrue: [self error: 'Duplicate definition.'].
	aDictionary at: key put: aDefinition
%

category: 'converting'
method: RwDefinition
asDefinition
  ^ self
%

category: 'comparing'
method: RwDefinition
compareAgainstBase: aDefinition
	"Diff myself for changes against the given base definition. 
	Answer a Modification, which might be empty if there are no changes."

	self subclassResponsibility
%

category: 'comparing'
method: RwDefinition
compareAgainstBaseForNewClassVersion: aBaseDefinition

	"Diff myself for changes against the given base definition. 
	Answer a Modification, which might be empty if there are no changes."

	"Filter the definition to include changes that are only applicable to new class versions"

	self subclassResponsibility
%

category: 'comparing'
method: RwDefinition
compareDictionary: myDictionary againstBaseDictionary: baseDictionary into: anElementsModification elementClass: elementClass

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys do: 
			[:key |
			| before after modification |
			before := baseDictionary at: key ifAbsent: [elementClass new].
			after := myDictionary at: key ifAbsent: [elementClass new].
			modification := after compareAgainstBase: before.
			modification isEmpty
				ifFalse: [anElementsModification addElementModification: modification]]
%

category: 'comparing'
method: RwDefinition
compareDictionary: myDictionary againstBaseDictionary_forUpgrade: baseDictionary into: anElementsModification elementClass: elementClass

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys do: 
			[:key |
			| before after modification |
			before := baseDictionary at: key ifAbsent: [elementClass new].
			after := myDictionary at: key ifAbsent: [elementClass new].
			modification := after compareAgainstBase_forUpgrade: before.
			modification isEmpty
				ifFalse: [anElementsModification addElementModification: modification]]
%

category: 'initialization'
method: RwDefinition
initialize

	properties := Dictionary new
%

category: 'testing'
method: RwDefinition
isEmpty
	"Answer true if this definition does not actually define anything.
	All definitions are expected to have at least a name property."

	^properties isEmpty
%

category: 'properties'
method: RwDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container."

	self subclassResponsibility
%

category: 'copying'
method: RwDefinition
postCopy

	super postCopy.
	properties := properties copy
%

category: 'printing'
method: RwDefinition
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' for ';
		nextPutAll: (self key ifNil: ['nil'])
%

category: 'accessing'
method: RwDefinition
properties

	^properties
%

category: 'accessing'
method: RwDefinition
properties: propertiesDictionary

	properties := propertiesDictionary
%

category: 'accessing'
method: RwDefinition
propertyAt: aKey

	^properties at: aKey
%

category: 'accessing'
method: RwDefinition
propertyAt: aKey ifAbsent: absentBlock

	^properties at: aKey ifAbsent: absentBlock
%

category: 'properties'
method: RwDefinition
propertyAt: aKey put: aValue

	^properties at: aKey put: aValue
%

category: 'private'
method: RwDefinition
removeDefinition: aDefinition from: aDictionary

	| key |
	key := aDefinition key.
	aDictionary
		removeKey: key
		ifAbsent: [ self error: 'no definition for ' , key printString , ' found' ]
%

category: 'private'
method: RwDefinition
removeKey: key from: aDictionary

	aDictionary
		removeKey: key
		ifAbsent: [ self error: 'no definition for ' , key printString , ' found' ]
%

category: 'private'
method: RwDefinition
updateDefinition: aDefinition in: aDictionary

	| key |
	key := aDefinition key.
	aDictionary at: key put: aDefinition
%

category: 'private'
method: RwDefinition
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue

	^ propertyValue = baseValue
%

! Class implementation for 'RwAbstractClassDefinition'

!		Class methods for 'RwAbstractClassDefinition'

category: 'instance creation'
classmethod: RwAbstractClassDefinition
withProperties: propertiesDictionary classMethodDefinitions: classMethodDefinitions instanceMethodDefinitions: instanceMethodDefinitions

	^(self basicNew)
		properties: propertiesDictionary;
		classMethodDefinitions: classMethodDefinitions;
		instanceMethodDefinitions: instanceMethodDefinitions;
		yourself
%

!		Instance methods for 'RwAbstractClassDefinition'

category: 'accessing'
method: RwAbstractClassDefinition
addClassMethodDefinition: aMethodDefinition

	self addDefinition: aMethodDefinition to: classMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
addInstanceMethodDefinition: aMethodDefinition

	self addDefinition: aMethodDefinition to: instanceMethodDefinitions
%

category: 'private'
method: RwAbstractClassDefinition
addMethodDefinition: aMethodDefinition to: aDictionary

	| selector |
	selector := aMethodDefinition propertyAt: 'selector'.
	(aDictionary includesKey: selector)
		ifTrue: [self error: 'Duplicate selector in behavior'].
	aDictionary at: selector put: aMethodDefinition
%

category: 'accessing'
method: RwAbstractClassDefinition
classMethodDefinitions

	^classMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
classMethodDefinitions: dictionaryOfDefinitions

	classMethodDefinitions := dictionaryOfDefinitions
%

category: 'comparing'
method: RwAbstractClassDefinition
compareAgainstBase: aDefinition

	| modification instanceMethodsModification classMethodsModification className |
	modification := self _modificationClass before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	className := self _classNameForCompare: aDefinition.
	instanceMethodsModification := self _methodsModificationClass
		extendedClassName: className.
	classMethodsModification := self _methodsModificationClass
		extendedClassName: className.
	self
		compareDictionary: instanceMethodDefinitions
		againstBaseDictionary: aDefinition instanceMethodDefinitions
		into: instanceMethodsModification
		elementClass: RwMethodDefinition
		isMeta: false.
	self
		compareDictionary: classMethodDefinitions
		againstBaseDictionary: aDefinition classMethodDefinitions
		into: classMethodsModification
		elementClass: RwMethodDefinition
		isMeta: true.
	modification
		instanceMethodsModification: instanceMethodsModification;
		classMethodsModification: classMethodsModification.
	^ modification
%

category: 'comparing'
method: RwAbstractClassDefinition
compareAgainstBaseForNewClassVersion: aDefinition

	"all unchanged and unremoved methods need to be applied to the patch"

	| modification instanceMethodsModification classMethodsModification |
	modification := self _modificationClass before: aDefinition after: self.
	instanceMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	classMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	self
		compareDictionary: instanceMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition instanceMethodDefinitions
		into: instanceMethodsModification
		elementClass: RwMethodDefinition
		isMeta: false.
	self
		compareDictionary: classMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition classMethodDefinitions
		into: classMethodsModification
		elementClass: RwMethodDefinition
		isMeta: true.
	modification
		instanceMethodsModification: instanceMethodsModification;
		classMethodsModification: classMethodsModification.
	^ modification
%

category: 'comparing'
method: RwAbstractClassDefinition
compareAgainstBase_forUpgrade: aDefinition

	| modification instanceMethodsModification classMethodsModification className |
	modification := self _modificationClass before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	className := self _classNameForCompare: aDefinition.
	instanceMethodsModification := self _methodsModificationClass
		extendedClassName: className.
	classMethodsModification := self _methodsModificationClass
		extendedClassName: className.
	self
		compareDictionary: instanceMethodDefinitions
		againstBaseDictionary_forUpgrade: aDefinition instanceMethodDefinitions
		into: instanceMethodsModification
		elementClass: RwMethodDefinition
		isMeta: false.
	self
		compareDictionary: classMethodDefinitions
		againstBaseDictionary_forUpgrade: aDefinition classMethodDefinitions
		into: classMethodsModification
		elementClass: RwMethodDefinition
		isMeta: true.
	modification
		instanceMethodsModification: instanceMethodsModification;
		classMethodsModification: classMethodsModification.
	^ modification
%

category: 'comparing'
method: RwAbstractClassDefinition
compareDictionary: myDictionary againstBaseDictionary: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys do: 
			[:key |
			| before after modification |
			before := baseDictionary at: key ifAbsent: [elementClass new].
			after := myDictionary at: key ifAbsent: [elementClass new].
			modification := after compareAgainstBase: before.
			modification 
				isMeta: isClassMeta;
				classDefinition: self.
			modification isEmpty
				ifFalse: [anElementsModification addElementModification: modification]]
%

category: 'comparing'
method: RwAbstractClassDefinition
compareDictionary: myDictionary againstBaseDictionaryForNewClassVersion: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys
		do: [ :key | 
			(baseDictionary
				at: key
				ifAbsent: [ 
					"additions do not apply for new class version - the original modification should not be changed"
					 ])
				ifNotNil: [ :before | 
					(myDictionary
						at: key
						ifAbsent: [ 
							"deletions do not apply for new class version - the original modification should not be changed"
							 ])
						ifNotNil: [ :after | 
							| modification |
							modification := after compareAgainstBaseForNewClassVersion: before.
							modification
								isMeta: isClassMeta;
								classDefinition: self.
							modification isEmpty
								ifFalse: [ anElementsModification addElementModification: modification ] ] ] ]
%

category: 'comparing'
method: RwAbstractClassDefinition
compareDictionary: myDictionary againstBaseDictionary_forUpgrade: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys do: 
			[:key |
			| before after modification |
			before := baseDictionary at: key ifAbsent: [elementClass new].
			after := myDictionary at: key ifAbsent: [elementClass new].
			modification := after compareAgainstBase_forUpgrade: before.
			modification 
				isMeta: isClassMeta;
				classDefinition: self.
			modification isEmpty
				ifFalse: [anElementsModification addElementModification: modification]]
%

category: 'initialization'
method: RwAbstractClassDefinition
initialize

	super initialize.
	classMethodDefinitions := Dictionary new.
	instanceMethodDefinitions := Dictionary new
%

category: 'accessing'
method: RwAbstractClassDefinition
instanceMethodDefinitions

	^instanceMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
instanceMethodDefinitions: dictionaryOfDefinitions

	instanceMethodDefinitions := dictionaryOfDefinitions
%

category: 'testing'
method: RwAbstractClassDefinition
isClassExtension
	^ false
%

category: 'testing'
method: RwAbstractClassDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & classMethodDefinitions isEmpty
		& instanceMethodDefinitions isEmpty
%

category: 'private'
method: RwAbstractClassDefinition
key

	^properties at: 'name' ifAbsent: [nil]
%

category: 'accessing'
method: RwAbstractClassDefinition
name: aString

	properties at: 'name' put: aString
%

category: 'copying'
method: RwAbstractClassDefinition
postCopy

	super postCopy.
	classMethodDefinitions :=  classMethodDefinitions copy.
	instanceMethodDefinitions := instanceMethodDefinitions copy
%

category: 'accessing'
method: RwAbstractClassDefinition
removeClassMethod: selector

	| definition |
	definition := classMethodDefinitions
		at: selector
		ifAbsent: [ self error: 'No method definition for ' , selector printString , ' found.' ].
	self removeDefinition: definition from: classMethodDefinitions.
	^ definition
%

category: 'accessing'
method: RwAbstractClassDefinition
removeInstanceMethod: selector

	| definition |
	definition := instanceMethodDefinitions
		at: selector
		ifAbsent: [ self error: 'No method definition for ' , selector printString , ' found.' ].
	self removeDefinition: definition from: instanceMethodDefinitions.
	^ definition
%

category: 'accessing'
method: RwAbstractClassDefinition
updateClassMethodDefinition: aMethodDefinition

	self updateDefinition: aMethodDefinition in: classMethodDefinitions
%

category: 'accessing'
method: RwAbstractClassDefinition
updateInstanceMethodDefinition: aMethodDefinition

	self updateDefinition: aMethodDefinition in: instanceMethodDefinitions
%

category: 'private'
method: RwAbstractClassDefinition
_classNameForCompare: aDefinition

	^ self key ifNil: [ aDefinition key ]
%

category: 'private'
method: RwAbstractClassDefinition
_methodsModificationClass

	self subclassResponsibility: #'__methodsModificationClass'
%

category: 'private'
method: RwAbstractClassDefinition
_modificationClass

	self subclassResponsibility: #'_modificationClass'
%

! Class implementation for 'RwClassDefinition'

!		Class methods for 'RwClassDefinition'

category: 'instance creation'
classmethod: RwClassDefinition
newForClassNamed: className super: superClassName instvars: instvars classinstvars: classinstvars classvars: classvars category: category comment: comment pools: pools type: type

	| propertiesDictionary |
	propertiesDictionary := Dictionary new.
	category
		ifNotNil: [ 
			propertiesDictionary
				at: 'category' put: category;
				yourself ].
	propertiesDictionary
		at: 'classinstvars' put: classinstvars;
		at: 'classvars' put: classvars;
		at: 'instvars' put: instvars;
		at: 'name' put: className;
		at: 'pools' put: pools;
		at: 'superclass' put: superClassName;
		at: 'type' put: type.
	comment ifNotNil: [ propertiesDictionary at: 'comment' put: comment ].
	^ self
		withProperties: propertiesDictionary
		classMethodDefinitions: Dictionary new
		instanceMethodDefinitions: Dictionary new
%

!		Instance methods for 'RwClassDefinition'

category: 'accessing'
method: RwClassDefinition
classType
	"Legal types are normal, variable, and bytes."

	^self propertyAt: 'type' ifAbsent: ['normal']
%

category: 'accessing'
method: RwClassDefinition
classVarNames
  ^ properties at: 'classvars'
%

category: 'accessing'
method: RwClassDefinition
classVarNames: anArrayOfClassVarNames

	^ properties at: 'classvars' put: anArrayOfClassVarNames
%

category: 'accessing'
method: RwClassDefinition
comment: aString
  properties at: 'comment' put: aString
%

category: 'accessing'
method: RwClassDefinition
instVarNames

	^ properties at: 'instvars'
%

category: 'accessing'
method: RwClassDefinition
instVarNames: arrayOfInstanceVariableNames

	^ properties at: 'instvars' put: arrayOfInstanceVariableNames
%

category: 'accessing'
method: RwClassDefinition
superclassName

	^self propertyAt: 'superclass' ifAbsent: [self propertyAt: 'super']
%

category: 'accessing'
method: RwClassDefinition
superclassName: aString

	^ self propertyAt: 'superclass' put: aString
%

! Class implementation for 'RwClassExtensionDefinition'

!		Class methods for 'RwClassExtensionDefinition'

category: 'instance creation'
classmethod: RwClassExtensionDefinition
newForClassNamed: className

	| propertiesDictionary |
	propertiesDictionary := Dictionary new
		at: 'name' put: className;
		yourself.
	^ self
		withProperties: propertiesDictionary
		classMethodDefinitions: Dictionary new
		instanceMethodDefinitions: Dictionary new
%

!		Instance methods for 'RwClassExtensionDefinition'

category: 'comparing'
method: RwClassExtensionDefinition
compareDictionary: myDictionary againstBaseDictionary: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys
		do: [ :key | 
			| before after modification |
			before := baseDictionary at: key ifAbsent: [ elementClass new ].
			after := myDictionary at: key ifAbsent: [ elementClass new ].
			modification := after compareExtensionMethodsAgainstBase: before.
			modification
				isMeta: isClassMeta;
				classDefinition: self.
			modification isEmpty
				ifFalse: [ anElementsModification addElementModification: modification ] ]
%

category: 'comparing'
method: RwClassExtensionDefinition
compareDictionary: myDictionary againstBaseDictionary_forUpgrade: baseDictionary into: anElementsModification elementClass: elementClass isMeta: isClassMeta

	| keys |
	keys := myDictionary keys copy.
	keys addAll: baseDictionary keys.
	keys
		do: [ :key | 
			| before after modification |
			before := baseDictionary at: key ifAbsent: [ elementClass new ].
			after := myDictionary at: key ifAbsent: [ elementClass new ].
			modification := after compareExtensionMethodsAgainstBase_forUpgrade: before.
			modification
				isMeta: isClassMeta;
				classDefinition: self.
			modification isEmpty
				ifFalse: [ anElementsModification addElementModification: modification ] ]
%

category: 'testing'
method: RwClassExtensionDefinition
isClassExtension
	^ true
%

category: 'private'
method: RwClassExtensionDefinition
_classNameForCompare: aDefinition

	^ self key ifNil: 
		[ | cName |
		cName := aDefinition key.
		self name: cName.
		cName ]
%

! Class implementation for 'RwDefinitionSetDefinition'

!		Instance methods for 'RwDefinitionSetDefinition'

category: 'accessing'
method: RwDefinitionSetDefinition
addDefinition: aDefinition

	| key |
	key := aDefinition key.
	(definitions includesKey: key)
		ifTrue: [ self error: 'Duplicate definition ' ].
	definitions at: key put: aDefinition
%

category: 'accessing'
method: RwDefinitionSetDefinition
definitionNames

	^ self definitions keys asArray
%

category: 'accessing'
method: RwDefinitionSetDefinition
definitions

	^ definitions
%

category: 'accessing'
method: RwDefinitionSetDefinition
definitionWithKey: aKey ifAbsent: absentBlock

	^ definitions at: aKey ifAbsent: absentBlock
%

category: 'deriving'
method: RwDefinitionSetDefinition
deriveLoadedThings

	self subclassResponsibility: #'deriveLoadedThings'
%

category: 'enumerating'
method: RwDefinitionSetDefinition
do: aBlock

	^ self definitions do: aBlock
%

category: 'initialization'
method: RwDefinitionSetDefinition
initialize

	super initialize.
	definitions := Dictionary new
%

category: 'testing'
method: RwDefinitionSetDefinition
isEmpty

	"Answer true if this definition does not actually define anything."

	^ super isEmpty & definitions isEmpty
%

category: 'properties'
method: RwDefinitionSetDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container.
	But PackageSets have no container, so we don't expect them to have a key."

	^nil
%

category: 'accessing'
method: RwDefinitionSetDefinition
keys

	^ definitions keys
%

category: 'copying'
method: RwDefinitionSetDefinition
postCopy

	super postCopy.
	definitions := definitions copy
%

category: 'printing'
method: RwDefinitionSetDefinition
printOn: aStream

	aStream nextPutAll: self asString
%

category: 'accessing'
method: RwDefinitionSetDefinition
size

	^ definitions size
%

! Class implementation for 'RwPackageSetDefinition'

!		Instance methods for 'RwPackageSetDefinition'

category: 'accessing'
method: RwPackageSetDefinition
addPackage: aDefinition

	self addDefinition: aDefinition
%

category: 'deriving'
method: RwPackageSetDefinition
deriveLoadedThings

	^ RwEntitySet
		withAll:
			((self definitionNames
				collect: [ :packageName | Rowan image loadedPackageNamed: packageName ifAbsent: [  ] ])
				select: [ :each | each notNil ])
%

category: 'accessing'
method: RwPackageSetDefinition
packageNames

	^ self definitionNames
%

category: 'accessing'
method: RwPackageSetDefinition
packages

	^ self definitions
%

! Class implementation for 'RwProjectSetDefinition'

!		Instance methods for 'RwProjectSetDefinition'

category: 'accessing'
method: RwProjectSetDefinition
addProject: aDefinition

	self addDefinition: aDefinition
%

category: 'deriving'
method: RwProjectSetDefinition
deriveLoadedThings

	"extract the loaded projects that correspond to the project defintions held by the receiver"

	^ RwEntitySet
		withAll:
			((self definitionNames
				collect: [ :projectName | Rowan image loadedProjectNamed: projectName ifAbsent: [  ] ])
				select: [ :each | each notNil ])
%

category: 'accessing'
method: RwProjectSetDefinition
projectNamed: projectName ifAbsent: absentBlock

	^ self definitionWithKey: projectName ifAbsent: absentBlock
%

category: 'accessing'
method: RwProjectSetDefinition
projectNames

	^ self definitionNames
%

category: 'accessing'
method: RwProjectSetDefinition
projects

	^ self definitions
%

! Class implementation for 'RwMethodDefinition'

!		Class methods for 'RwMethodDefinition'

category: 'instance creation'
classmethod: RwMethodDefinition
newForSelector: selector protocol: protocol source: source

	^ self
		withProperties:
			(Dictionary with: 'selector' -> selector with: 'protocol' -> protocol)
		source: source
%

category: 'instance creation'
classmethod: RwMethodDefinition
newForSource: methodSource protocol: protocol

	| selector |
	selector := Rowan platform parseSelectorFrom: methodSource.
	^ self
		newForSelector: selector asSymbol
		protocol: protocol
		source: methodSource
%

category: 'instance creation'
classmethod: RwMethodDefinition
withProperties: propertiesDictionary source: sourceString 

	^(self basicNew)
		properties: propertiesDictionary;
		source: sourceString;
		yourself
%

!		Instance methods for 'RwMethodDefinition'

category: 'testing'
method: RwMethodDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & source isNil
%

category: 'private'
method: RwMethodDefinition
key

	^properties at: 'selector' ifAbsent: [nil]
%

category: 'accessing'
method: RwMethodDefinition
protocol

	^properties at: 'protocol'
%

category: 'accessing'
method: RwMethodDefinition
protocol: aString

	properties at: 'protocol' put: aString
%

category: 'accessing'
method: RwMethodDefinition
selector

	^properties at: 'selector'
%

category: 'accessing'
method: RwMethodDefinition
source

	^source
%

category: 'accessing'
method: RwMethodDefinition
source: sourceString

	source := sourceString
%

! Class implementation for 'RwPackageDefinition'

!		Class methods for 'RwPackageDefinition'

category: 'instance creation'
classmethod: RwPackageDefinition
newNamed: packageName

	^ self
		withProperties: (Dictionary with: 'name' -> packageName)
		classDefinitions: Dictionary new
		classExtensions: Dictionary new
%

category: 'instance creation'
classmethod: RwPackageDefinition
withProperties: properties classDefinitions: classDefinitions classExtensions: classExtensionDefinitions

	^(self basicNew)
		properties: properties;
		classDefinitions: classDefinitions;
		classExtensions: classExtensionDefinitions;
		yourself
%

!		Instance methods for 'RwPackageDefinition'

category: 'accessing'
method: RwPackageDefinition
addClassDefinition: aClassDefinition

	self addDefinition: aClassDefinition to: classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
addClassExtension: aClassExtensionDefinition

	self addDefinition: aClassExtensionDefinition to: classExtensions
%

category: 'accessing'
method: RwPackageDefinition
classDefinitions

	^classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
classDefinitions: classDefinitionDictionary

	classDefinitions := classDefinitionDictionary
%

category: 'accessing'
method: RwPackageDefinition
classExtensions

	^classExtensions
%

category: 'accessing'
method: RwPackageDefinition
classExtensions: classExtensionDefinitionsDictionary

	classExtensions := classExtensionDefinitionsDictionary
%

category: 'initialization'
method: RwPackageDefinition
initialize

	super initialize.
	classDefinitions := Dictionary new.
	classExtensions := Dictionary new
%

category: 'testing'
method: RwPackageDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & classDefinitions isEmpty & classExtensions isEmpty
%

category: 'properties'
method: RwPackageDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container."

	^self propertyAt: 'name' ifAbsent: [nil]
%

category: 'copying'
method: RwPackageDefinition
postCopy

	super postCopy.
	classDefinitions := classDefinitions copy.
	classExtensions := classExtensions copy
%

category: 'accessing'
method: RwPackageDefinition
removeClassDefinition: aClassDefinition

	self removeDefinition: aClassDefinition from: classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
removeClassExtension: aClassExtension

	self removeDefinition: aClassExtension from: classExtensions
%

category: 'accessing'
method: RwPackageDefinition
removeClassNamed: className

	self removeKey: className from: classDefinitions
%

category: 'accessing'
method: RwPackageDefinition
updateClassDefinition: aClassDefinition

	self updateDefinition: aClassDefinition in: classDefinitions
%

! Class implementation for 'RwProjectDefinition'

!		Class methods for 'RwProjectDefinition'

category: 'instance creation'
classmethod: RwProjectDefinition
newForDiskBasedProjectNamed: aString

	| spec |
	spec := RwSimpleProjectSpecification new
		specName: aString;
		repoSpec: RwDiskRepositorySpecification new;
		yourself.
	^ self newForSpecification: spec
%

category: 'instance creation'
classmethod: RwProjectDefinition
newForGitBasedProjectNamed: aString

	| spec |
	spec := RwSimpleProjectSpecification new
		specName: aString;
		yourself.
	^ self newForSpecification: spec
%

category: 'instance creation'
classmethod: RwProjectDefinition
newForSpecification: aRwSpecification

	^ self
		withProperties:
			(Dictionary new
				add: 'name' -> aRwSpecification specName;
				add: 'spec' -> aRwSpecification;
				yourself)
		packageDefinitions: Dictionary new
%

category: 'instance creation'
classmethod: RwProjectDefinition
withProperties: properties packageDefinitions: packageDefinitions

	^ self basicNew
		properties: properties;
		packages: packageDefinitions;
		yourself
%

!		Instance methods for 'RwProjectDefinition'

category: 'accessing'
method: RwProjectDefinition
addOrUpdatePackage: aPackageDefinition

	| key |
	key := aPackageDefinition key.
	packages at: key put: aPackageDefinition
%

category: 'accessing'
method: RwProjectDefinition
addPackage: aPackageDefinition

	| key |
	key := aPackageDefinition key.
	(packages includesKey: key) ifTrue: [self error: 'Duplicate package'].
	packages at: key put: aPackageDefinition
%

category: 'accessing'
method: RwProjectDefinition
addPackageNamed: packageName

	self addPackage: (RwPackageDefinition newNamed: packageName)
%

category: 'accessing'
method: RwProjectDefinition
addPackagesNamed: packageNames

	packageNames
		do: [ :packageName | self addPackage: (RwPackageDefinition newNamed: packageName) ]
%

category: 'properties'
method: RwProjectDefinition
canCommit

	^ self specification canCommit
%

category: 'properties'
method: RwProjectDefinition
comment

	^ self specification comment
%

category: 'properties'
method: RwProjectDefinition
comment: aString

	self specification comment: aString
%

category: 'properties'
method: RwProjectDefinition
configsPath

	^ self specification configsPath
%

category: 'properties'
method: RwProjectDefinition
configsPath: aDirectoryPathString

	self specification configsPath: aDirectoryPathString
%

category: 'properties'
method: RwProjectDefinition
configurationExportUrl

	"Return an RwFileUrl suitable for saving the receiver's configuration in the appropriate configs directory"

	| exportPath |
	self repositoryUrl
		ifNil: [ self error: 'RepositoryUrl has not been set. Receiver has not bee associated with an existing Rowan project on disk.' ].
	exportPath := self repositoryRootPath , '/' , self configsPath , '/'.
	^('file:' , exportPath) asRwUrl
%

category: 'properties'
method: RwProjectDefinition
configurationTemplate

	"Return a generic RwProjectLoadConfiguration based on the list of packages in the reciever"

	| config groupNames |
	config := RwProjectLoadConfiguration new
		name: 'Default';
		projectName: self specification specName;
		yourself.
	groupNames := self specification defaultGroupNames.
	groupNames
		do: [:groupName | config addDefinedGroupName: groupName ].
	config 
		conditionalPackagesAtConditions: { Rowan platform basePlatformAttribute } 
		andGroup: (groupNames at: 1) 
		addPackageNames: self packageNames.
	^ config
%

category: 'accessing'
method: RwProjectDefinition
definitionWithKey: aKey ifAbsent: absentBlock

	^packages at: aKey ifAbsent: absentBlock
%

category: 'initialization'
method: RwProjectDefinition
initialize

	super initialize.
	packages := Dictionary new
%

category: 'testing'
method: RwProjectDefinition
isEmpty
	"Answer true if this definition does not actually define anything."

	^super isEmpty & packages isEmpty
%

category: 'properties'
method: RwProjectDefinition
key
	"Answer an object that can be used to uniquely identify myself in the context of my container."

	^self propertyAt: 'name' ifAbsent: [nil]
%

category: 'accessing'
method: RwProjectDefinition
keys

	^packages keys
%

category: 'properties'
method: RwProjectDefinition
loadedCommitId

	^ self specification loadedCommitId
%

category: 'accessing'
method: RwProjectDefinition
packageNamed: aString

	^ self
		packageNamed: aString
		ifAbsent: [ self error: 'A package named ' , aString printString , ' was not found.' ]
%

category: 'accessing'
method: RwProjectDefinition
packageNamed: aString ifAbsent: absentBlock

	^ self packages at: aString ifAbsent: absentBlock
%

category: 'accessing'
method: RwProjectDefinition
packageNames
  ^ self packages keys asArray
%

category: 'accessing'
method: RwProjectDefinition
packageNames: packageNames

	packageNames
		do: [ :packageName | self addPackage: (RwPackageDefinition newNamed: packageName) ]
%

category: 'accessing'
method: RwProjectDefinition
packages

	^packages
%

category: 'accessing'
method: RwProjectDefinition
packages: aPackageDefinitionDictionary

	packages := aPackageDefinitionDictionary
%

category: 'copying'
method: RwProjectDefinition
postCopy

	super postCopy.
	packages := packages copy
%

category: 'accessing'
method: RwProjectDefinition
removePackage: aPackageDefinition

	| key |
	key := aPackageDefinition key.
	(packages includesKey: key) ifFalse: [self error: 'Package not present.'].
	packages removeKey: key
%

category: 'accessing'
method: RwProjectDefinition
removePackageNamed: packageName

	^self removePackage: (self packageNamed: packageName)
%

category: 'properties'
method: RwProjectDefinition
repoPath

	^ self specification repoPath
%

category: 'properties'
method: RwProjectDefinition
repoPath: aDirectoryPathString

	self specification repoPath: aDirectoryPathString
%

category: 'properties'
method: RwProjectDefinition
repositoryRootPath

	^ self specification repositoryRootPath
%

category: 'properties'
method: RwProjectDefinition
repositoryRootPath: rootRepoPath

	self specification repositoryRootPath: rootRepoPath
%

category: 'properties'
method: RwProjectDefinition
repositoryUrl

	^ self specification repositoryUrl
%

category: 'properties'
method: RwProjectDefinition
repositoryUrl: aString

	self specification repositoryUrl: aString
%

category: 'properties'
method: RwProjectDefinition
specification

	^ properties at: 'spec'
%

category: 'properties'
method: RwProjectDefinition
specsPath

	^ self specification specsPath
%

category: 'properties'
method: RwProjectDefinition
specsPath: aDirectoryPathString

	self specification specsPath: aDirectoryPathString
%

category: 'properties'
method: RwProjectDefinition
useGit

	^ self specification useGit
%

! Class implementation for 'RwElementsModification'

!		Class methods for 'RwElementsModification'

category: 'instance creation'
classmethod: RwElementsModification
new

	^self basicNew initialize
%

!		Instance methods for 'RwElementsModification'

category: 'modifications'
method: RwElementsModification
addElementModification: aModification

	aModification isEmpty
		ifFalse: [elementsModified at: aModification key put: aModification]
%

category: 'Accessing'
method: RwElementsModification
elementsModified
	^elementsModified
%

category: 'initialization'
method: RwElementsModification
initialize

	elementsModified := Dictionary new
%

category: 'testing'
method: RwElementsModification
isEmpty

	^elementsModified isEmpty
%

category: 'Accessing'
method: RwElementsModification
modificationOf: aKey

	^elementsModified at: aKey
%

category: 'printing'
method: RwElementsModification
printOn: aStream

	super printOn: aStream.
	self isEmpty ifTrue: [aStream nextPutAll: ' (empty)']
%

category: 'Accessing'
method: RwElementsModification
removeModificationOf: aKey

	elementsModified removeKey: aKey
%

! Class implementation for 'RwClassesModification'

!		Instance methods for 'RwClassesModification'

category: 'visiting'
method: RwClassesModification
acceptVisitor: aVisitor

	^aVisitor visitClassesModification: self
%

! Class implementation for 'RwClassExtensionsModification'

!		Instance methods for 'RwClassExtensionsModification'

category: 'visiting'
method: RwClassExtensionsModification
acceptVisitor: aVisitor

	^aVisitor visitClassExtensionsModification: self
%

! Class implementation for 'RwEntitySetModification'

!		Instance methods for 'RwEntitySetModification'

category: 'accessing'
method: RwEntitySetModification
movedClasses

	^ movedClasses
%

category: 'accessing'
method: RwEntitySetModification
movedMethods

	^ movedMethods
%

! Class implementation for 'RwPackageSetModification'

!		Instance methods for 'RwPackageSetModification'

category: 'visiting'
method: RwPackageSetModification
acceptVisitor: aVisitor

	^aVisitor visitPackageSetModification: self
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsAddedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> true -> newMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> false -> newMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsAddedByPackageModification: packageModification toDictionary: dictionary

	self
		addMethodsAddedByClassesOrExtensionsModification: packageModification
				classesModification
		inPackage: packageModification after
		toDictionary: dictionary.
	self
		addMethodsAddedByClassesOrExtensionsModification: packageModification
				classExtensionsModification
		inPackage: packageModification after
		toDictionary: dictionary
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsRemovedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> true -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification before
										methodKey: oldMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> false -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: oldMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwPackageSetModification
addMethodsRemovedByPackageModification: packageModification toDictionary: dictionary

	self
		addMethodsRemovedByClassesOrExtensionsModification: packageModification
				classesModification
		inPackage: packageModification before
		toDictionary: dictionary.
	self
		addMethodsRemovedByClassesOrExtensionsModification: packageModification
				classExtensionsModification
		inPackage: packageModification before
		toDictionary: dictionary
%

category: 'enumerating'
method: RwPackageSetModification
classesModificationAndPackageModificationAndProjectModificationDo: aBlock

	"enumerate the classesModification in the packagesModification in the projectModification in the receiver.
		The classesModification, packageModification are arguments to the block. "

	elementsModified
		do: [ :packageModification | aBlock cull: packageModification classesModification cull: packageModification  ]
%

category: 'enumerating'
method: RwPackageSetModification
classesModificationAndPackageModificationDo: aBlock

	"enumerate the classesModification in the packagesModification in the receiver.
		The classesModification and ppackageModification are arguments to the block. "

	elementsModified
		do: [ :packageModification | aBlock cull: packageModification classesModification cull: packageModification  ]
%

category: 'private - moves'
method: RwPackageSetModification
findAddedClasses

	| addedClasses |
	addedClasses := Dictionary new.
	elementsModified do: 
			[:packageModification |
			| classesModification |
			classesModification := packageModification classesModification.
			classesModification elementsModified do: 
					[:classModification |
					classModification before isEmpty
						ifTrue: 
							[| newClass |
							newClass := classModification after.
							addedClasses at: newClass key
								put: (RwClassAdditionOrRemoval
										packageDefinition: packageModification before
										classKey: newClass key
										classesModification: classesModification)]]].
	^addedClasses
%

category: 'private - moves'
method: RwPackageSetModification
findAddedMethods
	"Answer a dictionary of added methods."

	| addedMethods |
	addedMethods := Dictionary new.
	elementsModified do: 
			[:packageModification |
			self addMethodsAddedByPackageModification: packageModification
				toDictionary: addedMethods].
	^addedMethods
%

category: 'private - moves'
method: RwPackageSetModification
findRemovedClasses

	| removedClasses |
	removedClasses := Dictionary new.
	elementsModified do: 
			[:packageModification |
			| classesModification |
			classesModification := packageModification classesModification.
			classesModification elementsModified do: 
					[:classModification |
					classModification after isEmpty
						ifTrue: 
							[| oldClass |
							oldClass := classModification before.
							removedClasses at: oldClass key
								put: (RwClassAdditionOrRemoval
										packageDefinition: packageModification after
										classKey: oldClass key
										classesModification: classesModification)]]].
	^removedClasses
%

category: 'private - moves'
method: RwPackageSetModification
findRemovedMethods
	"Answer a dictionary of removed methods."

	| removedMethods |
	removedMethods := Dictionary new.
	elementsModified do: 
			[:packageModification |
			self addMethodsRemovedByPackageModification: packageModification
				toDictionary: removedMethods].
	^removedMethods
%

category: 'initialization'
method: RwPackageSetModification
initialize

	super initialize.
	movedClasses := Set new.
	movedMethods := Set new
%

category: 'private - moves'
method: RwPackageSetModification
updateForClassMoveFrom: removal to: addition
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition classModification |
	oldDefinition := (removal classesModification
				modificationOf: removal classKey) before.
	newDefinition := (addition classesModification
				modificationOf: addition classKey) after.

	"Delete the removal and the addition."
	removal classesModification removeModificationOf: removal classKey.
	addition classesModification removeModificationOf: addition classKey.

	"Record the move."
	movedClasses add: (RwClassMove
				classBefore: oldDefinition
				classAfter: newDefinition
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition).

	"Does the class have other modifications that need to be recorded?"
	classModification := newDefinition compareAgainstBase: oldDefinition.
	classModification isEmpty
		ifFalse: 
			[addition classesModification addElementModification: classModification]
%

category: 'moves'
method: RwPackageSetModification
updateForClassMoves

	| classAdditions classRemovals |
	classAdditions := self findAddedClasses.
	classRemovals := self findRemovedClasses.

	"Any keys that match between added and removed should be considered a move."
	classAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := classRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [self updateForClassMoveFrom: removal to: addition]]
%

category: 'private - moves'
method: RwPackageSetModification
updateForMethodMoveFrom: removal to: addition
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition methodModification |
	oldDefinition := (removal methodsModification
				modificationOf: removal methodKey) before.
	newDefinition := (addition methodsModification
				modificationOf: addition methodKey) after.

	"Delete the removal and the addition."
	removal methodsModification removeModificationOf: removal methodKey.
	addition methodsModification removeModificationOf: addition methodKey.

	"Record the move."
	movedMethods add: (RwMethodMove
				methodBefore: oldDefinition
				methodAfter: newDefinition
				classOrExtensionBefore: removal classDefinitionOrExtension
				classOrExtensionAfter: addition classDefinitionOrExtension
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition
				isMeta: addition isMeta).

	"Does the method have other modifications that need to be recorded?"
	methodModification := newDefinition compareAgainstBase: oldDefinition.
	methodModification isEmpty
		ifFalse: 
			[addition methodsModification addElementModification: methodModification]
%

category: 'moves'
method: RwPackageSetModification
updateForMethodMoves
	"Methods that have been moved between packages will initially show up as a remove and an add rather than a move.
	Find moved methods and correct the structure."

	| methodAdditions methodRemovals |
	methodAdditions := self findAddedMethods.
	methodRemovals := self findRemovedMethods.
	"Any keys that match between added and removed should be considered a move."
	methodAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := methodRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [self updateForMethodMoveFrom: removal to: addition]]
%

! Class implementation for 'RwProjectSetModification'

!		Instance methods for 'RwProjectSetModification'

category: 'visiting'
method: RwProjectSetModification
acceptVisitor: aVisitor

	^ aVisitor visitProjecteSetModification: self
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsAddedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package inProject: project toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before key
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> true -> newMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification before key
						ifNil: 
							[| newMethod |
							newMethod := methodModification after.
							dictionary at: classModification key -> false -> newMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: newMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsAddedByPackageModification: packageModification inProject: projectModification toDictionary: dictionary

	packageModification after key notNil
	ifTrue: [ 
		"ignore additions for packages that have been removed"
		self
			addMethodsAddedByClassesOrExtensionsModification: packageModification
					classesModification
			inPackage: packageModification after
			inProject: projectModification after
			toDictionary: dictionary.
		self
			addMethodsAddedByClassesOrExtensionsModification: packageModification
					classExtensionsModification
			inPackage: packageModification after
			inProject: projectModification after
			toDictionary: dictionary]
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsRemovedByClassesOrExtensionsModification: classesOrExtensionsModification inPackage: package inProject: project toDictionary: dictionary

	classesOrExtensionsModification elementsModified do: 
			[:classModification |
			| classMethodsModification instanceMethodsModification |
			classMethodsModification := classModification classMethodsModification.
			instanceMethodsModification := classModification
						instanceMethodsModification.
			classMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after key
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> true -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification before
										methodKey: oldMethod key
										isMeta: true
										methodsModification: classMethodsModification)]].
			instanceMethodsModification elementsModified do: 
					[:methodModification |
					methodModification after key
						ifNil: 
							[| oldMethod |
							oldMethod := methodModification before.
							dictionary at: classModification key -> false -> oldMethod key
								put: (RwMethodAdditionOrRemoval
										projectDefinition: project
										packageDefinition: package
										classDefinitionOrExtension: classModification after
										methodKey: oldMethod key
										isMeta: false
										methodsModification: instanceMethodsModification)]]]
%

category: 'private - moves'
method: RwProjectSetModification
addMethodsRemovedByPackageModification: packageModification inProject: projectModification toDictionary: dictionary

	packageModification before key notNil
	ifTrue: [ 
		"ignore removals for packages that have been added"
		self
			addMethodsRemovedByClassesOrExtensionsModification: packageModification
					classesModification
			inPackage: packageModification before
			inProject: projectModification before
			toDictionary: dictionary.
		self
			addMethodsRemovedByClassesOrExtensionsModification: packageModification
					classExtensionsModification
			inPackage: packageModification before
			inProject: projectModification before
			toDictionary: dictionary ]
%

category: 'enumerating'
method: RwProjectSetModification
classesModificationAndPackageModificationAndProjectModificationDo: aBlock

	"enumerate the classesModification in the packagesModification in the projectModification in the receiver.
		The classesModification, packageModification, and projectModification are arguments to the block. "

	elementsModified
		do: [ :projectModification | 
			projectModification packagesModification elementsModified
				do: [ :packageModification | aBlock cull: packageModification classesModification cull: packageModification cull: projectModification ] ]
%

category: 'private - moves'
method: RwProjectSetModification
findAddedClasses

	| addedClasses |
	addedClasses := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				| classesModification |
				classesModification := packageModification classesModification.
				classesModification elementsModified do: 
						[:classModification |
						classModification before isEmpty
							ifTrue: 
								[| newClass |
								newClass := classModification after.
								addedClasses at: newClass key
									put: (RwClassAdditionOrRemoval
											projectDefinition: projectModification after
											packageDefinition: packageModification after
											classKey: newClass key
											classesModification: classesModification)]]]].
	^addedClasses
%

category: 'private - moves'
method: RwProjectSetModification
findAddedMethods
	"Answer a dictionary of added methods."

	| addedMethods |
	addedMethods := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				self addMethodsAddedByPackageModification: packageModification
					inProject: projectModification
					toDictionary: addedMethods] ].
	^addedMethods
%

category: 'private - moves'
method: RwProjectSetModification
findRemovedClasses

	| removedClasses |
	removedClasses := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				| classesModification |
				classesModification := packageModification classesModification.
				classesModification elementsModified do: 
						[:classModification |
						classModification after isEmpty
							ifTrue: 
								[| oldClass |
								oldClass := classModification before.
								removedClasses at: oldClass key
									put: (RwClassAdditionOrRemoval
											projectDefinition: projectModification before
											packageDefinition: packageModification before
											classKey: oldClass key
											classesModification: classesModification)]]]].
	^removedClasses
%

category: 'private - moves'
method: RwProjectSetModification
findRemovedMethods
	"Answer a dictionary of removed methods."

	| removedMethods |
	removedMethods := Dictionary new.
	elementsModified do: 
			[:projectModification |
			| packagesModification |
			packagesModification := projectModification packagesModification.
			packagesModification elementsModified do: 
				[:packageModification |
				self addMethodsRemovedByPackageModification: packageModification
					inProject: projectModification
					toDictionary: removedMethods]].
	^removedMethods
%

category: 'initialization'
method: RwProjectSetModification
initialize

	super initialize.
	movedClasses := Set new.
	movedMethods := Set new
%

category: 'private - moves'
method: RwProjectSetModification
updateForClassMoveFrom: removal to: addition
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition classModification |
	oldDefinition := (removal classesModification
				modificationOf: removal classKey) before.
	newDefinition := (addition classesModification
				modificationOf: addition classKey) after.

	"Delete the removal and the addition."
	removal classesModification removeModificationOf: removal classKey.
	addition classesModification removeModificationOf: addition classKey.

	"Record the move."
	movedClasses add: (RwClassMove
				classBefore: oldDefinition
				classAfter: newDefinition
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition
				projectBefore: removal projectDefinition
				projectAfter: addition projectDefinition).

	"Does the class have other modifications that need to be recorded?"
	classModification := newDefinition compareAgainstBase: oldDefinition.
	classModification isEmpty
		ifFalse: 
			[addition classesModification addElementModification: classModification]
%

category: 'moves'
method: RwProjectSetModification
updateForClassMoves

	| classAdditions classRemovals |
	classAdditions := self findAddedClasses.
	classRemovals := self findRemovedClasses.

	"Any keys that match between added and removed should be considered a move."
	classAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := classRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [self updateForClassMoveFrom: removal to: addition]]
%

category: 'private - moves'
method: RwProjectSetModification
updateForMethodMoveFrom: removal to: addition  isMeta: isMeta
	"Transform the given removal and addition to a move."

	| oldDefinition newDefinition methodModification |
	oldDefinition := (removal methodsModification
				modificationOf: removal methodKey) before.
	newDefinition := (addition methodsModification
				modificationOf: addition methodKey) after.

	"Delete the removal and the addition."
	removal methodsModification removeModificationOf: removal methodKey.
	addition methodsModification removeModificationOf: addition methodKey.

	"Record the move."
	movedMethods add: (RwMethodMove
				methodBefore: oldDefinition
				methodAfter: newDefinition
				classOrExtensionBefore: removal classDefinitionOrExtension
				classOrExtensionAfter: addition classDefinitionOrExtension
				packageBefore: removal packageDefinition
				packageAfter: addition packageDefinition
				projectBefore: removal projectDefinition
				projectAfter: addition projectDefinition
				isMeta: addition isMeta).

	"Does the method have other modifications that need to be recorded?"
	methodModification := newDefinition compareAgainstBase: oldDefinition.
	methodModification 
		isMeta: isMeta;
		classDefinition: addition classDefinitionOrExtension.
	methodModification isEmpty
		ifFalse: 
			[addition methodsModification addElementModification: methodModification]
%

category: 'moves'
method: RwProjectSetModification
updateForMethodMoves
	"Methods that have been moved between packages will initially show up as a remove and an add rather than a move.
	Find moved methods and correct the structure."

	| methodAdditions methodRemovals |
	methodAdditions := self findAddedMethods.
	methodRemovals := self findRemovedMethods.
	"Any keys that match between added and removed should be considered a move."
	methodAdditions keysAndValuesDo: 
			[:key :addition |
			| removal |
			removal := methodRemovals at: key ifAbsent: [nil].
			removal ifNotNil: [ self updateForMethodMoveFrom: removal to: addition isMeta: key key value]]
%

! Class implementation for 'RwMethodsModification'

!		Class methods for 'RwMethodsModification'

category: 'instance creation'
classmethod: RwMethodsModification
extendedClassName: ignored

	^ self new
%

!		Instance methods for 'RwMethodsModification'

category: 'visiting'
method: RwMethodsModification
acceptVisitor: aVisitor

	^aVisitor visitMethodsModification: self
%

category: 'merging'
method: RwMethodsModification
mergeForExistingClassWith: anExistingMethodsModification

	"merge anExistingMethodsModification modifictions into the receiver"

	anExistingMethodsModification elementsModified
		keysAndValuesDo: [ :selector :anExistingMethodModification | 
			"anExistingMethodsModification contains any new  or modified methods that 
				were applied to this class and they all need to be brought forward 
				along with the forced new versions of methods (those not changed or removed)"
			(elementsModified at: selector ifAbsent: [  ])
				ifNil: [
					"added method"
					elementsModified at: selector put: anExistingMethodModification ]
				ifNotNil: [
					 "modified method"
					elementsModified 
						at: selector 
						put: anExistingMethodModification asMethodModificationForNewClassVersion] ]
%

category: 'merging'
method: RwMethodsModification
mergeForNewClassVersionWith: aMethodsModification

	"merge aMethodsModification modifictions into the receiver"

	"add all method modifications to the receiver, there should be no selector overlap, if there is 
		the receiver wins --- but for now we'll error out. "

	aMethodsModification elementsModified
		keysAndValuesDo: [ :selector :aMethodModification | 
			(elementsModified at: selector ifAbsent: [  ])
				ifNil: [elementsModified at: selector put: aMethodModification]
				ifNotNil: [ :existingMethodModification | 
					existingMethodModification mergeForNewClassVersionWith: aMethodModification ] ]
%

! Class implementation for 'RwExtensionMethodsModification'

!		Class methods for 'RwExtensionMethodsModification'

category: 'instance creation'
classmethod: RwExtensionMethodsModification
extendedClassName: aString

	^ self new
		extendedClassName: aString;
		yourself
%

!		Instance methods for 'RwExtensionMethodsModification'

category: 'visiting'
method: RwExtensionMethodsModification
acceptVisitor: aVisitor

	^ aVisitor visitExtensionMethodsModification: self
%

category: 'modifications'
method: RwExtensionMethodsModification
addElementModification: aModification

	aModification isEmpty
		ifFalse: [ 
			| anExtensionModification |
			anExtensionModification := aModification asExtensionMethodModification.
			anExtensionModification extendedClassName: self extendedClassName.
			elementsModified at: anExtensionModification key put: anExtensionModification ]
%

category: 'accessing'
method: RwExtensionMethodsModification
extendedClassName

   ^extendedClassName
%

category: 'accessing'
method: RwExtensionMethodsModification
extendedClassName: anObject

	extendedClassName := anObject
%

! Class implementation for 'RwPackagesModification'

!		Instance methods for 'RwPackagesModification'

category: 'visiting'
method: RwPackagesModification
acceptVisitor: aVisitor

	^ aVisitor visitPackagesModification: self
%

! Class implementation for 'RwPropertiesModification'

!		Instance methods for 'RwPropertiesModification'

category: 'visiting'
method: RwPropertiesModification
acceptVisitor: aVisitor

	^aVisitor visitPropertiesModification: self
%

! Class implementation for 'RwSourceModification'

!		Instance methods for 'RwSourceModification'

category: 'visiting'
method: RwSourceModification
acceptVisitor: aVisitor

	^aVisitor visitSourceModification: self
%

! Class implementation for 'RwEntitySet'

!		Class methods for 'RwEntitySet'

category: 'instance creation'
classmethod: RwEntitySet
withAll: somePackageRefs

	^(self new)
		initialize;
		addAll: somePackageRefs;
		yourself
%

!		Instance methods for 'RwEntitySet'

category: 'accessing'
method: RwEntitySet
addAll: aRwDefinitionOrRwLoadedThingCollection

	aRwDefinitionOrRwLoadedThingCollection
		do: [ :entity | entities at: entity name put: entity ].
	^ aRwDefinitionOrRwLoadedThingCollection
%

category: 'definitions'
method: RwEntitySet
asDefinitionSet

	| result |
	result := RwDefinitionSetDefinition new.
	entities do: [ :entity | result addDefinition: entity asDefinition ].
	^ result
%

category: 'definitions'
method: RwEntitySet
asPackageDefinitionSet

	| result |
	result := RwPackageSetDefinition new.
	entities do: [ :entity | result addDefinition: entity asDefinition ].
	^ result
%

category: 'definitions'
method: RwEntitySet
asProjectDefinitionSet

	| result |
	result := RwProjectSetDefinition new.
	entities do: [ :entity | result addDefinition: entity asDefinition ].
	^ result
%

category: 'enumeration'
method: RwEntitySet
do: aBlock

	^ entities do: aBlock
%

category: 'accessing'
method: RwEntitySet
entities

	^ entities
%

category: 'initialization'
method: RwEntitySet
initialize

	entities := Dictionary new
%

category: 'accessing'
method: RwEntitySet
size

	^ entities size
%

! Class implementation for 'RwGsFileUtilities'

!		Class methods for 'RwGsFileUtilities'

category: 'utilities'
classmethod: RwGsFileUtilities
deleteAll: aDirectory
  "Delete all the files and directories under the named directory.
	 Ensure we don't try to recursively delete . or .."

  self deleteAll: aDirectory rejecting: [ :filename | false ]
%

category: 'utilities'
classmethod: RwGsFileUtilities
deleteAll: aDirectory rejecting: rejectBlock
  "Delete all the files and directories under the named directory.
       Reject file and directores in aDirectory that are rejected by rejectBlock.
       The rejectBlock is not used recursively.
       Ensure we don't try to recursively delete . or .."

  | filename isFile |
  (GsFile contentsAndTypesOfDirectory: aDirectory onClient: false)
    doWithIndex: [ :each :index | 
      index odd
        ifTrue: [ filename := each ]
        ifFalse: [ 
          isFile := each.
          isFile
            ifTrue: [ 
              (rejectBlock value: filename)
                ifFalse: [ 
                  (rejectBlock value: filename)
                    ifFalse: [ GsFile removeServerFile: filename ] ] ]
            ifFalse: [ 
              (self _endsWithSpecial: filename)
                ifFalse: [ 
                  (rejectBlock value: filename)
                    ifFalse: [ 
                      self deleteAll: filename rejecting: rejectBlock.
                      GsFile removeServerDirectory: filename ] ] ] ] ]
%

category: 'utilities'
classmethod: RwGsFileUtilities
deleteDirectory: aDirectory
  "Delete the named directory and all of it contents"

	self deleteAll: aDirectory.
   GsFile removeServerDirectory: aDirectory
%

category: 'utilities'
classmethod: RwGsFileUtilities
directoryEntriesFrom: aDirectory
	"Answer fully qualified paths to the contents of aDirectory."

	^(GsFile contentsOfDirectory: aDirectory onClient: false) ifNil: [#()]
%

category: 'utilities'
classmethod: RwGsFileUtilities
directoryFromPath: directoryPath relativeTo: aDirectory

	^((aDirectory endsWith: self pathNameDelimiter)
		or: [directoryPath beginsWith: self pathNameDelimiter])
			ifTrue: [aDirectory , directoryPath]
			ifFalse: [aDirectory , self pathNameDelimiter , directoryPath]
%

category: 'private'
classmethod: RwGsFileUtilities
endsWithSpecial: filename
	"Answer true if the given filename ends with any of the special sequences
	'/..' '/.' '\..' '\.', false otherwise."

	| filenameSize finalChars |
	filenameSize := filename size.
	finalChars := filename copyFrom: filenameSize - 1 to: filenameSize.
	finalChars = '/.' ifTrue: [^true].
	finalChars = '\.' ifTrue: [^true].
	finalChars := filename copyFrom: filenameSize - 2 to: filenameSize.
	finalChars = '/..' ifTrue: [^true].
	finalChars = '\..' ifTrue: [^true].
	^false
%

category: 'utilities'
classmethod: RwGsFileUtilities
ensureDirectoryExists: aDirectory

	| lastSeparator |
	(GsFile existsOnServer: aDirectory) == true ifTrue: [^aDirectory].
	(GsFile createServerDirectory: aDirectory) ifNotNil: [^aDirectory].
	lastSeparator := aDirectory findLastSubString: self pathNameDelimiter
				startingAt: aDirectory size.
	lastSeparator <= 1 ifTrue: [self error: 'Cannot create directory'].
	self ensureDirectoryExists: (aDirectory copyFrom: 1 to: lastSeparator - 1).
	self ensureDirectoryExists: aDirectory
%

category: 'utilities'
classmethod: RwGsFileUtilities
entryNamesFrom: aDirectory
  "Answer just the name of the contents of aDirectory."

  ^ (((self directoryEntriesFrom: aDirectory)
    collect: [ :each | self localNameFrom: each ])
    reject: [ :each | each = '.' or: [ each = '..' ] ])
    sortWithBlock: [ :a :b | a <= b ]
%

category: 'utilities'
classmethod: RwGsFileUtilities
localNameFrom: aDirectory

	| endOfPath |
	endOfPath := aDirectory findLastSubString: self pathNameDelimiter
				startingAt: aDirectory size.
	^aDirectory copyFrom: endOfPath + 1 to: aDirectory size
%

category: 'utilities'
classmethod: RwGsFileUtilities
pathNameDelimiter

	^'/'
%

category: 'utilities'
classmethod: RwGsFileUtilities
readStreamFor: filePath do: aOneArgBlock

	| file stream result |
	GsFile serverErrorString.
	file := GsFile openReadOnServer: filePath.
	GsFile serverErrorString
		ifNotNil: [:errorMessage | self error: errorMessage].
	
	[stream := ReadStreamPortable
				on: (String withAll: file contents asByteArray decodeFromUTF8).
	result := aOneArgBlock value: stream]
			ensure: [file close].
	^result
%

category: 'utilities'
classmethod: RwGsFileUtilities
readStreamFor: filePath in: aDirectory do: aOneArgBlock

	self
		readStreamFor: (self directoryFromPath: filePath relativeTo: aDirectory)
		do: aOneArgBlock
%

category: 'utilities'
classmethod: RwGsFileUtilities
writeStreamFor: filePath in: aDirectory do: aOneArgBlock

	| file stream |
	GsFile serverErrorString.
	file := GsFile openWriteOnServer: (self directoryFromPath: filePath relativeTo: aDirectory).
	GsFile serverErrorString ifNotNil: [:errorMessage | self error: errorMessage].
	stream := WriteStreamPortable on: String new.
	[aOneArgBlock value: stream] ensure: [file nextPutAll: stream contents encodeAsUTF8; close]
%

category: 'private'
classmethod: RwGsFileUtilities
_endsWithSpecial: filename
  "Answer true if the given filename ends with any of the special sequences
	'/..' '/.' '\..' '\.', false otherwise."

  | filenameSize finalChars |
  filenameSize := filename size.
  finalChars := filename copyFrom: filenameSize - 1 to: filenameSize.
  finalChars = '/.'
    ifTrue: [ ^ true ].
  finalChars = '\.'
    ifTrue: [ ^ true ].
  finalChars := filename copyFrom: filenameSize - 2 to: filenameSize.
  finalChars = '/..'
    ifTrue: [ ^ true ].
  finalChars = '\..'
    ifTrue: [ ^ true ].
  ^ false
%

! Class implementation for 'RwGsImage'

!		Class methods for 'RwGsImage'

category: 'querying'
classmethod: RwGsImage
addLoadedProject: aRwLoadedProject

	"Register a project"

	| projectName projectRegistry |
	aRwLoadedProject projectOwnerId: self currentUserId.
	projectName := aRwLoadedProject name.
	projectRegistry := self
		_loadedProjectRegistryForUserId: aRwLoadedProject projectOwnerId.
	projectRegistry
		at: projectName
		ifAbsent: [ ^ projectRegistry at: projectName put: aRwLoadedProject ].
	self
		error:
			'There is already a project named ' , projectName printString , ' registered'
%

category: 'testing'
classmethod: RwGsImage
canWrite: anObject

	^ System canWrite: anObject
%

category: 'querying'
classmethod: RwGsImage
currentUserId

	^ GsCurrentSession currentSession userProfile userId
%

category: 'operations'
classmethod: RwGsImage
ensureSessionMethodsEnabled

	"Ensure that session methods are enabled for the current user."

	GsPackagePolicy current enabled
		ifFalse: [ GsPackagePolicy current enable ].
%

category: 'querying'
classmethod: RwGsImage
existingSymbolDictionaryNamed: dictName

	"If the current session's transient symbol list includes a dictionary with the given name, answer it. "

	| symbolName |
	symbolName := dictName asSymbol.
	^ self symbolList
		detect: [ :each | (each at: symbolName ifAbsent: [ nil ]) == each ]
		ifNone: [ nil ]
%

category: 'querying'
classmethod: RwGsImage
loadedClassAndSymbolDicitonaryForClass: class ifPresent: presentBlock ifAbsent: absentBlock

        "scan the symbol list for a RwLoadedClass instances for the given compiled method"

        self symbolList
                do: [ :symbolDict |
                        symbolDict rowanSymbolDictionaryRegistry
                                ifNotNil: [ :registry |
                                        (registry classRegistry at: class classHistory ifAbsent: [  ])
                                                ifNotNil: [ :loadedClass | ^ presentBlock value: symbolDict value: loadedClass ] ] ].
        ^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedClassExtensionsForClass: class

	"lookup the loadedClassExtensions for the given class"

	| history found |
	history := class classHistory.
	found := IdentitySet new.
	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry classExtensionRegistry at: history ifAbsent: [  ])
						ifNotNil: [ :loadedClassExtensionSet | found addAll: loadedClassExtensionSet ] ] ].
	^ found
%

category: 'querying'
classmethod: RwGsImage
loadedClassExtensionsNamed: className ifFound: foundBlock ifAbsent: absentBlock

	"scan the symbol list for a RwLoadedClassExtension instances of the given name"

	| class found |
	class := self objectNamed: className.
	class ifNil: [ ^ absentBlock value ].
	found := self loadedClassExtensionsForClass: class.
	found isEmpty
		ifFalse: [ ^ foundBlock value: found ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedClassForClass: class ifAbsent: absentBlock

	"Lookup the given class in the classRegistry"

	| history |
	history := class classHistory.
	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry classRegistry at: history ifAbsent: [  ])
						ifNotNil: [ :loadedClass | ^ loadedClass ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedClassNamed: className

	^ self
		loadedClassNamed: className
		ifAbsent: [ self error: 'loaded class named ' , className printString , ' not found.' ]
%

category: 'querying'
classmethod: RwGsImage
loadedClassNamed: className ifAbsent: absentBlock

	^ self
		loadedClassNamed: className
		ifFound: [ :loadedClass | ^ loadedClass ]
		ifAbsent: absentBlock
%

category: 'querying'
classmethod: RwGsImage
loadedClassNamed: className ifFound: foundBlock ifAbsent: absentBlock

	"scan the symbol list for a RwLoadedClass instance of the given name"

	| class loadedClass |
	class := self objectNamed: className.
	class ifNil: [ ^ absentBlock value ].
	loadedClass := self
		loadedClassForClass: class
		ifAbsent: [ ^ absentBlock value ].
	^ foundBlock value: loadedClass
%

category: 'querying'
classmethod: RwGsImage
loadedHybridPackageNamed: aHybridName ifAbsent: absentBlock

	"scan the symbol list a RwLoadedPackage instance of the given hybrid name"

	"a hybrid package name has a leading '*' followed by the name of a package ... 
		where the hybrid package name is not expected to preserve case"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry loadedHybridPackageNamed: aHybridName ifAbsent: [  ])
						ifNotNil: [ :loadedPackage | ^ loadedPackage ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedMethod: selector inClassNamed: className isMeta: isMeta ifFound: foundBlock ifAbsent: absentBlock

	"scan the symbol list for a RwLoadedMethod instances for the given selector in the named class"

	| behavior compiledMethod |
	behavior := self objectNamed: className.
	behavior ifNil: [ ^ absentBlock value ].
	isMeta
		ifTrue: [ behavior := behavior class ].
	compiledMethod := behavior
		compiledMethodAt: selector asSymbol
		environmentId: 0
		otherwise: nil.
	compiledMethod ifNil: [ ^ absentBlock value ].
	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry methodRegistry at: compiledMethod ifAbsent: [  ])
						ifNotNil: [ :loadedMethod | ^ foundBlock value: loadedMethod ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedMethodAndSymbolDicitonaryForMethod: compiledMethod ifPresent: presentBlock ifAbsent: absentBlock

        "scan the symbol list for a RwLoadedMethod instances for the given compiled method"

        self symbolList
                do: [ :symbolDict |
                        symbolDict rowanSymbolDictionaryRegistry
                                ifNotNil: [ :registry |
                                        (registry methodRegistry at: compiledMethod ifAbsent: [  ])
                                                ifNotNil: [ :loadedMethod | ^ presentBlock value: symbolDict value: loadedMethod ] ] ].
        ^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedMethodForMethod: compiledMethod

	"scan the symbol list for a RwLoadedMethod instances for the given compiled method"

	^ self
		loadedMethodForMethod: compiledMethod
		ifAbsent: [ 
			self
				error:
					'No loadedMethod found for the comiled method ' , compiledMethod printString ]
%

category: 'querying'
classmethod: RwGsImage
loadedMethodForMethod: compiledMethod ifAbsent: absentBlock

	"scan the symbol list for a RwLoadedMethod instances for the given compiled method"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry methodRegistry at: compiledMethod ifAbsent: [  ])
						ifNotNil: [ :loadedMethod | ^ loadedMethod ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedPackageNamed: aString

	^ self
		loadedPackageNamed: aString
		ifAbsent: [ self error: 'No loaded package named ' , aString printString , ' found' ]
%

category: 'querying'
classmethod: RwGsImage
loadedPackageNamed: aName ifAbsent: absentBlock

	"scan the symbol list a RwLoadedPackage instance of the given name"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry loadedPackageNamed: aName ifAbsent: [  ])
						ifNotNil: [ :loadedPackage | ^ loadedPackage ] ] ].
	^ absentBlock value
%

category: 'querying'
classmethod: RwGsImage
loadedProjectNamed: aString

	^ self
		loadedProjectNamed: aString
		ifAbsent: [ self error: 'No loaded project named ' , aString printString , ' found' ]
%

category: 'querying'
classmethod: RwGsImage
loadedProjectNamed: aString ifAbsent: absentBlock

	"Look up a loaded project. First in current users project registry, then scan AllUsers for the project ... note that the user needs to be the project owner."

	| currentUserId |
	currentUserId := self currentUserId.
	^ self _loadedProjectRegistry
		at: aString
		ifAbsent: [
			| matchingProjects |
			matchingProjects := self loadedProjects select: [:each | each name = aString ].
			matchingProjects size > 1 ifTrue: [ self error: 'Multiple projects with same name available from symbol dictionaries in symbol list' ].
			matchingProjects size = 0 ifTrue: [ ^ absentBlock value ].
			matchingProjects any ]
%

category: 'querying'
classmethod: RwGsImage
loadedProjects

	"Return the list of loaded projects based on the packages that are visible in the current transient symbol list."

	| loadedProjects |
	loadedProjects := (self _loadedProjectRegistryForUserId: self currentUserId) values asIdentitySet. "list of projects created by current user"
	(self symbolList select: [:symDict | 
		symDict rowanSymbolDictionaryRegistry notNil])
		do: [:symDict | 
			"visible loaded packages"
			symDict rowanSymbolDictionaryRegistry packageRegistry values 
				do: [:loadedPackage | 
					"visible loaded projects"
					loadedProjects add: loadedPackage loadedProject ] ].
	^loadedProjects
%

category: 'querying'
classmethod: RwGsImage
loadedRegistryForPackageNamed:  aName

	"scan the symbol list for a RwLoadedPackage instance of the given name and return the registry"

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | 
					(registry loadedPackageNamed: aName ifAbsent: [  ])
						ifNotNil: [ :loadedPackage | ^ registry ] ] ].
	^self error: 'The package ', aName printString, ' was not found'
%

category: 'querying'
classmethod: RwGsImage
newOrExistingSymbolDictionaryNamed: dictName

	"If the current session's transient symbol list includes a dictionary with the given name, answer it.
	Otherwise, create one, add it to the beginning of both transient and persistent symbol lists, and 
	answer it."

	| symbolName session symbolList symbolDict |
	symbolName := dictName asSymbol.
	session := GsCurrentSession currentSession.
	symbolList := session symbolList.
	symbolDict := symbolList
		detect: [ :each | (each at: symbolName ifAbsent: [ nil ]) == each ]
		ifNone: [ 
			| newDict size |
			newDict := SymbolDictionary new
				name: symbolName;
				objectSecurityPolicy: symbolList objectSecurityPolicy;
				yourself.
			size := System myUserProfile symbolList size.
			System myUserProfile insertDictionary: newDict at: size + 1.
			newDict ].
	symbolDict rowanSymbolDictionaryRegistry
		ifNil: [ RwGsSymbolDictionaryRegistry installIn: symbolDict ].
	^ symbolDict
%

category: 'querying'
classmethod: RwGsImage
objectNamed: aSymbol

	"Returns the first object in the current session's symbol list that has the given
 name.  If no object with the given name is found, returns nil."

	^ self symbolList objectNamed: aSymbol
%

category: 'querying'
classmethod: RwGsImage
packageNames

	"Return list of package names. All sytem projects are visible, but not all packages of visible projects
		are visible."

	| packageNames visiblePackageNames |
	packageNames := Set new.
	visiblePackageNames := Set new.
	(self symbolList select: [:symDict | 
		symDict rowanSymbolDictionaryRegistry notNil])
		do: [:symDict | 
			visiblePackageNames 
				addAll: symDict rowanSymbolDictionaryRegistry packageRegistry keys ].
	self loadedProjects
		do: [ :loadedProject | 
			loadedProject packageNames do: [:packageName |
				(visiblePackageNames includes: packageName) ifTrue: [ packageNames add: packageName ] ] ].
	^ packageNames asArray
%

category: 'querying'
classmethod: RwGsImage
packageNamesForLoadedProjectNamed: projectName

	"Return list of package names for the loaded project with the given name. All sytem projects are visible, but not all packages of visible projects
		are visible."

	| packageNames visiblePackageNames |
	packageNames := Set new.
	visiblePackageNames := Set new.
	(self symbolList select: [:symDict | 
		symDict rowanSymbolDictionaryRegistry notNil])
		do: [:symDict | 
			visiblePackageNames 
				addAll: symDict rowanSymbolDictionaryRegistry packageRegistry keys ].
	(self loadedProjectNamed: projectName) packageNames do: [:packageName |
				(visiblePackageNames includes: packageName) ifTrue: [ packageNames add: packageName ] ].
	^ packageNames asArray
%

category: 'cypress (old)'
classmethod: RwGsImage
projectNames

	"Return list of project names"

	^ (self loadedProjects collect: [ :loadedProject | loadedProject name ]) asArray
%

category: 'querying'
classmethod: RwGsImage
removeLoadedClassExtensionsForClass: class

	"The class has or will be deleted from the system, remove the loadedClassExtensions that refer
		to the given class"

	| history |
	history := class classHistory.
	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | registry classExtensionRegistry removeKey: history ifAbsent: [  ] ] ]
%

category: 'querying'
classmethod: RwGsImage
removeLoadedMethodForCompileMethod: compiledMethod

	"The given compiled method is being removed from the system, remove the loadedMethod associated 
		with the compiled method."

	self symbolList
		do: [ :symbolDict | 
			symbolDict rowanSymbolDictionaryRegistry
				ifNotNil: [ :registry | registry methodRegistry removeKey: compiledMethod ifAbsent: [  ] ] ]
%

category: 'querying'
classmethod: RwGsImage
resolveClassNamed: aName

	"If the given name is bound to a class in the environment of the current session, 
	answer that class. Otherwise, answer nil."

	| resolved |
	resolved := self objectNamed: aName.
	^ (resolved isBehavior and: [ resolved isMeta not ])
		ifTrue: [ resolved ]
		ifFalse: [ nil ]
%

category: 'querying'
classmethod: RwGsImage
resolveName: aName

	"Searches the current session's symbol list for an Association whose key is equal to
 aString, and returns that Association.  If no such Association is found in the
 symbol list, returns nil. Uses the current session's transient copy of the symbol list."

	^ GsCurrentSession currentSession resolveSymbol: aName asSymbol
%

category: 'querying'
classmethod: RwGsImage
symbolList

	"Answer the current session (transient) symbol list"

	^ GsCurrentSession currentSession symbolList
%

category: 'private'
classmethod: RwGsImage
_loadedProjectRegistry

	^ self _loadedProjectRegistryForUserId: self currentUserId
%

category: 'private'
classmethod: RwGsImage
_loadedProjectRegistryForUserId: aUserId

	| userProfile userPlatformDict |
	userProfile := AllUsers userWithId: aUserId.
	(userProfile defaultObjectSecurityPolicy ifNil: [true] ifNotNil: [:x |x currentUserCanRead])
		ifFalse: [
			"do not have permissions to read objects created by <aUserId>"
			^ nil ].
	userPlatformDict := RwPlatform _userPlatformDictionaryForUser: aUserId.
	^ userPlatformDict
		at: #'RwGsLoadedProjectRegistry'
		ifAbsent: [ 
			(self currentUserId = aUserId)
				ifFalse: [ ^ nil ].
			userPlatformDict at: #'RwGsLoadedProjectRegistry' put: StringKeyValueDictionary new ]
%

category: 'cypress (old)'
classmethod: RwGsImage
_projectRegistry

	^ self _projectRegistryForUserId: self currentUserId
%

category: 'querying'
classmethod: RwGsImage
_removeLoadedProject: aRwLoadedProject

	"note that it is not safe to just remove a loaded project from the registry, however this method is supplied as a convenience for tests"

	| projectName projectRegistry |
	projectName := aRwLoadedProject name.
	projectRegistry := self
		_loadedProjectRegistryForUserId: aRwLoadedProject projectOwnerId.
	(projectRegistry at: projectName ifAbsent: [ ^ nil ]) == aRwLoadedProject
		ifFalse: [ 
			self
				error:
					'The specified project is not identical to the loaded project in the registry ... this is not expected' ].
	projectRegistry removeKey: projectName
%

! Class implementation for 'RwGsImagePatchVisitor'

!		Class methods for 'RwGsImagePatchVisitor'

category: 'instance creation'
classmethod: RwGsImagePatchVisitor
new

	^super new initialize
%

!		Instance methods for 'RwGsImagePatchVisitor'

category: 'private'
method: RwGsImagePatchVisitor
addAddedPackage: aPackageDefinition

	currentPackage := aPackageDefinition.
	patchSet addAddedPackage: currentPackage inProject: currentProject.
	self addClasses: currentPackage classDefinitions.
	self addClassExtensions: currentPackage classExtensions
%

category: 'private'
method: RwGsImagePatchVisitor
addAddedProject: aProjectDefinition

	currentProject := aProjectDefinition.
	patchSet addAddedProject: currentProject
%

category: 'private'
method: RwGsImagePatchVisitor
addClasses: classDefinitions

	classDefinitions
		do: [ :classDefinition | 
			"https://github.com/dalehenrich/Rowan/issues/210 - make sure that the added classes are not already loaded
				in a project that is not included in this load"
			(Rowan globalNamed: classDefinition name) ifNotNil: [:global | (RwExistingVisitorAddingExistingClassNotification new classDefinition: classDefinition) signal ]].
	classDefinitions
		do: [ :classDefinition | 
			patchSet
				addAddedClass: classDefinition
				inPackage: currentPackage
				inProject: currentProject.
			classDefinition classMethodDefinitions
				do: [ :classMethodDefinition | 
					patchSet
						addAddedClassMethod: classMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ].
			classDefinition instanceMethodDefinitions
				do: [ :instanceMethodDefinition | 
					patchSet
						addAddedInstanceMethod: instanceMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ] ]
%

category: 'private'
method: RwGsImagePatchVisitor
addClassExtensions: classExtensions

	classExtensions
		do: [ :classDefinition | 
			patchSet
				addExtendedClass: classDefinition
				inPackage: currentPackage
				inProject: currentProject.
			classDefinition classMethodDefinitions
				do: [ :classMethodDefinition | 
					patchSet
						addExtendedClassMethod: classMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ].
			classDefinition instanceMethodDefinitions
				do: [ :instanceMethodDefinition | 
					patchSet
						addExtendedInstanceMethod: instanceMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ] ]
%

category: 'private'
method: RwGsImagePatchVisitor
addDeletedPackage: aPackageDefinition

	self deletePackages: {aPackageDefinition}
%

category: 'private'
method: RwGsImagePatchVisitor
addPackages: packageDefinitions

	packageDefinitions
		do: [:packageDefinition | self addAddedpackage: packageDefinition]
%

category: 'private'
method: RwGsImagePatchVisitor
deleteClasses: classDefinitions

	classDefinitions
		do: [ :classDefinition | 
			patchSet
				addDeletedClass: classDefinition
				inPackage: currentPackage
				inProject: currentProject.
			classDefinition classMethodDefinitions
				do: [ :classMethodDefinition | 
					patchSet
						addDeletedClassMethod: classMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ].
			classDefinition instanceMethodDefinitions
				do: [ :instanceMethodDefinition | 
					patchSet
						addDeletedInstanceMethod: instanceMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ] ]
%

category: 'private'
method: RwGsImagePatchVisitor
deletePackages: packageDefinitions

	packageDefinitions
		do: [ :packageDefinition | 
			currentPackage := packageDefinition.
			patchSet addDeletedPackage: currentPackage inProject: currentProject.
			self deleteClasses: packageDefinition classDefinitions.
			packageDefinition classExtensions
				do: [ :classExtension | 
					classExtension classMethodDefinitions
						do: [ :classMethodDefinition | 
							patchSet
								addDeletedClassMethod: classMethodDefinition
								inClass: classExtension
								inPackage: packageDefinition
								inProject: currentProject ].
					classExtension instanceMethodDefinitions
						do: [ :instanceMethodDefinition | 
							patchSet
								addDeletedInstanceMethod: instanceMethodDefinition
								inClass: classExtension
								inPackage: packageDefinition
								inProject: currentProject ] ] ]
%

category: 'initialization'
method: RwGsImagePatchVisitor
initialize

	patchSet := self _patchSetClass new
%

category: 'accessing'
method: RwGsImagePatchVisitor
patchSet
	^patchSet
%

category: 'public'
method: RwGsImagePatchVisitor
visit: aPackageSetModification

	^aPackageSetModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor
visitClassesModification: aClassesModification

	aClassesModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor
visitClassExtensionModification: aClassExtensionModification

	aClassExtensionModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassExtensionModification after.
	aClassExtensionModification instanceMethodsModification acceptVisitor: self.
	aClassExtensionModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor
visitClassExtensionsModification: aClassExtensionsModification

	aClassExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor
visitClassModification: aClassModification

	aClassModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassModification after.
	aClassModification instanceMethodsModification acceptVisitor: self.
	aClassModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor
visitClassModificationForcingNewVersion: aClassModification

	aClassModification
		addModificationForcingNewClassVersionToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassModification after.
	aClassModification instanceMethodsModification acceptVisitor: self.
	aClassModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor
visitExtensionMethodModification: anExtensionMethodModification

	anExtensionMethodModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor
visitExtensionMethodModificationForNewClassVersion: aMethodModification

	aMethodModification
		addExtensionModificationToPatchSetForNewClassVersion: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor
visitExtensionMethodsModification: anExtensionMethodsModification

	anExtensionMethodsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor
visitMethodModification: aMethodModification

	aMethodModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor
visitMethodModificationForNewClassVersion: aMethodModification

	aMethodModification
		addModificationToPatchSetForNewClassVersion: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor
visitMethodsModification: aMethodsModification

	aMethodsModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor
visitPackageModification: aPackageModification

	| propertiesModification |
	aPackageModification isAddition
		ifTrue: [ 
			self addAddedPackage: aPackageModification after.
			^ self ].
	aPackageModification isDeletion
		ifTrue: [ 
			self addDeletedPackage: aPackageModification before.
			^ self ].
	currentPackage := aPackageModification after.
	propertiesModification := aPackageModification propertiesModification.
	propertiesModification isEmpty
		ifFalse: [ 
			"https://github.com/dalehenrich/Rowan/issues/180"
			self error: 'internal error - unexpected non-empty package properties modification. See Issue #180' ].
	aPackageModification classesModification acceptVisitor: self.
	aPackageModification classExtensionsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor
visitPackageSetModification: aPackageSetModification

	aPackageSetModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor
visitPackagesModification: aPackagesModification

	aPackagesModification elementsModified do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor
visitProjecteSetModification: aProjectSetModification

	aProjectSetModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor
visitProjectModification: aProjectModification

	| propertiesModification |
	aProjectModification isAddition
		ifTrue: [ 
			self addAddedProject: aProjectModification after.
			aProjectModification packagesModification acceptVisitor: self.
			^ self ].
	aProjectModification isDeletion
		ifTrue: [ 
			self addDeletedProject: aProjectModification before.
			aProjectModification packagesModification acceptVisitor: self.
			^ self ].
	currentProject := aProjectModification after.
	propertiesModification := aProjectModification propertiesModification.
	propertiesModification isEmpty
		ifFalse: [ 
			"https://github.com/dalehenrich/Rowan/issues/180"
			self error: 'internal error - unexpected non-empty project properties modification. See Issue #180'  ].
	aProjectModification packagesModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor
visitPropertiesModification: aPropertiesModification

	self error: 'internal error - not yet implemented'
%

category: 'visting'
method: RwGsImagePatchVisitor
visitSourceModification: aSourceModification

	self error: 'internal error - not yet implemented'
%

category: 'private'
method: RwGsImagePatchVisitor
_patchSetClass

	^ RwGsPatchSet
%

! Class implementation for 'RwGsImagePatchVisitor_254'

!		Class methods for 'RwGsImagePatchVisitor_254'

category: 'instance creation'
classmethod: RwGsImagePatchVisitor_254
new

	^super new initialize
%

!		Instance methods for 'RwGsImagePatchVisitor_254'

category: 'private'
method: RwGsImagePatchVisitor_254
addAddedPackage: aPackageDefinition

	currentPackage := aPackageDefinition.
	patchSet addAddedPackage: currentPackage inProject: currentProject.
%

category: 'private'
method: RwGsImagePatchVisitor_254
addAddedProject: aProjectDefinition

	currentProject := aProjectDefinition.
	patchSet addAddedProject: currentProject
%

category: 'private'
method: RwGsImagePatchVisitor_254
addClasses: classDefinitions

	classDefinitions
		do: [ :classDefinition | 
			"https://github.com/dalehenrich/Rowan/issues/210 - make sure that the added classes are not already loaded
				in a project that is not included in this load"
			(Rowan globalNamed: classDefinition name) ifNotNil: [:global | (RwExistingVisitorAddingExistingClassNotification new classDefinition: classDefinition) signal ]].
	classDefinitions
		do: [ :classDefinition | 
			patchSet
				addAddedClass: classDefinition
				inPackage: currentPackage
				inProject: currentProject.
			classDefinition classMethodDefinitions
				do: [ :classMethodDefinition | 
					patchSet
						addAddedClassMethod: classMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ].
			classDefinition instanceMethodDefinitions
				do: [ :instanceMethodDefinition | 
					patchSet
						addAddedInstanceMethod: instanceMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ] ]
%

category: 'private'
method: RwGsImagePatchVisitor_254
addClassExtensions: classExtensions

	classExtensions
		do: [ :classDefinition | 
			patchSet
				addExtendedClass: classDefinition
				inPackage: currentPackage
				inProject: currentProject.
			classDefinition classMethodDefinitions
				do: [ :classMethodDefinition | 
					patchSet
						addExtendedClassMethod: classMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ].
			classDefinition instanceMethodDefinitions
				do: [ :instanceMethodDefinition | 
					patchSet
						addExtendedInstanceMethod: instanceMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ] ]
%

category: 'private'
method: RwGsImagePatchVisitor_254
addDeletedPackage: aPackageDefinition

	currentPackage := aPackageDefinition.
	patchSet addDeletedPackage: currentPackage inProject: currentProject
%

category: 'private'
method: RwGsImagePatchVisitor_254
deleteClasses: classDefinitions

	classDefinitions
		do: [ :classDefinition | 
			patchSet
				addDeletedClass: classDefinition
				inPackage: currentPackage
				inProject: currentProject.
			classDefinition classMethodDefinitions
				do: [ :classMethodDefinition | 
					patchSet
						addDeletedClassMethod: classMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ].
			classDefinition instanceMethodDefinitions
				do: [ :instanceMethodDefinition | 
					patchSet
						addDeletedInstanceMethod: instanceMethodDefinition
						inClass: classDefinition
						inPackage: currentPackage
						inProject: currentProject ] ]
%

category: 'initialization'
method: RwGsImagePatchVisitor_254
initialize

	patchSet := self _patchSetClass new
%

category: 'accessing'
method: RwGsImagePatchVisitor_254
patchSet
	^patchSet
%

category: 'public'
method: RwGsImagePatchVisitor_254
visit: aPackageSetModification

	^aPackageSetModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitClassesModification: aClassesModification

	aClassesModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitClassExtensionModification: aClassExtensionModification

	aClassExtensionModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassExtensionModification after.
	aClassExtensionModification instanceMethodsModification acceptVisitor: self.
	aClassExtensionModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitClassExtensionsModification: aClassExtensionsModification

	aClassExtensionsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitClassModification: aClassModification

	aClassModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassModification after.
	aClassModification instanceMethodsModification acceptVisitor: self.
	aClassModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitClassModificationForcingNewVersion: aClassModification

	aClassModification
		addModificationForcingNewClassVersionToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject.
	currentClass := aClassModification after.
	aClassModification instanceMethodsModification acceptVisitor: self.
	aClassModification classMethodsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitExtensionMethodModification: anExtensionMethodModification

	anExtensionMethodModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitExtensionMethodModificationForNewClassVersion: aMethodModification

	aMethodModification
		addExtensionModificationToPatchSetForNewClassVersion: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitExtensionMethodsModification: anExtensionMethodsModification

	anExtensionMethodsModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitMethodModification: aMethodModification

	aMethodModification
		addModificationToPatchSet: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitMethodModificationForNewClassVersion: aMethodModification

	aMethodModification
		addModificationToPatchSetForNewClassVersion: patchSet
		inPackage: currentPackage
		inProject: currentProject
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitMethodsModification: aMethodsModification

	aMethodsModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitPackageModification: aPackageModification

	| propertiesModification |
	aPackageModification isAddition
		ifTrue: [ self addAddedPackage: aPackageModification after ].
	aPackageModification isDeletion
		ifTrue: [ self addDeletedPackage: aPackageModification before ].
	currentPackage := aPackageModification after.
	aPackageModification isModification
		ifTrue: [ 
			propertiesModification := aPackageModification propertiesModification.
			propertiesModification isEmpty
				ifFalse: [ patchSet addMovedPackage: currentPackage inProject: currentProject ] ].
	aPackageModification classesModification acceptVisitor: self.
	aPackageModification classExtensionsModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitPackageSetModification: aPackageSetModification

	aPackageSetModification elementsModified
		do: [:each | each acceptVisitor: self]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitPackagesModification: aPackagesModification

	aPackagesModification elementsModified do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitProjecteSetModification: aProjectSetModification

	aProjectSetModification movedClasses do: [:movedClass | 
		movedClass addMovedClassToPatchSet: patchSet ].
	aProjectSetModification movedMethods do: [:movedMethod | 
		movedMethod addMovedMethodToPatchSet: patchSet ].
	aProjectSetModification elementsModified
		do: [ :each | each acceptVisitor: self ]
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitProjectModification: aProjectModification

	| propertiesModification |
	aProjectModification isAddition
		ifTrue: [ 
			self addAddedProject: aProjectModification after.
			aProjectModification packagesModification acceptVisitor: self.
			^ self ].
	aProjectModification isDeletion
		ifTrue: [ 
			self addDeletedProject: aProjectModification before.
			aProjectModification packagesModification acceptVisitor: self.
			^ self ].
	currentProject := aProjectModification after.
	propertiesModification := aProjectModification propertiesModification.
	propertiesModification isEmpty
		ifFalse: [ 
			"https://github.com/dalehenrich/Rowan/issues/180"
			| modifiedProperties |
			modifiedProperties := String new.
			propertiesModification elementsModified keys do: [:key | modifiedProperties add: ' '; add: key printString ].
			self error: 'internal error - unexpected non-empty project properties modification:', modifiedProperties, '. See Issue #180'  ].
	aProjectModification packagesModification acceptVisitor: self
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitPropertiesModification: aPropertiesModification

	self error: 'internal error - not yet implemented'
%

category: 'visting'
method: RwGsImagePatchVisitor_254
visitSourceModification: aSourceModification

	self error: 'internal error - not yet implemented'
%

category: 'private'
method: RwGsImagePatchVisitor_254
_patchSetClass

	^ RwGsPatchSet_254
%

! Class implementation for 'RwGsInstanceMigrator'

!		Class methods for 'RwGsInstanceMigrator'

category: 'instance creation'
classmethod: RwGsInstanceMigrator
aggressiveMigration

	^ self new
		maxThreads: SystemRepository _aggressiveMaxThreadCount;
		maxCpuPercentage: 95;
		yourself
%

category: 'instance creation'
classmethod: RwGsInstanceMigrator
conservativeMigration

	^ self new
%

category: 'instance creation'
classmethod: RwGsInstanceMigrator
noMigration

	^ self new
		migrationEnabled: false;
		yourself
%

!		Instance methods for 'RwGsInstanceMigrator'

category: 'accessing'
method: RwGsInstanceMigrator
maxCpuPercentage

	^ maxCpuPercentage ifNil: [ 90 ]
%

category: 'accessing'
method: RwGsInstanceMigrator
maxCpuPercentage: anObject

   maxCpuPercentage := anObject
%

category: 'accessing'
method: RwGsInstanceMigrator
maxThreads

	^ maxThreads ifNil: [ 2 ]
%

category: 'accessing'
method: RwGsInstanceMigrator
maxThreads: anObject

   maxThreads := anObject
%

category: 'migration'
method: RwGsInstanceMigrator
migrateInstancesOf: aClassArray

	| instancesArray classCount |
	self migrationEnabled
		ifFalse: [ ^ self ].
	System commit.
	instancesArray := SystemRepository
		listInstances: aClassArray
		limit: 0
		toDirectory: nil
		withMaxThreads: self maxThreads
		maxCpuUsage: self maxCpuPercentage
		memoryOnly: false.
	classCount := 1.
	1 to: instancesArray size by: 2 do: [ :index | 
		| class instances history instanceCount |
		class := aClassArray at: classCount.
		instanceCount := instancesArray at: index.
		instances := instancesArray at: index + 1.
		history := class classHistory.
		instanceCount > 0
			ifTrue: [ class migrateInstances: instances to: history last ].
		[ 1 < history size ] whileTrue: [ | cl | cl := history first. cl classHistory removeVersion: cl ].
		classCount := classCount + 1 ]
%

category: 'accessing'
method: RwGsInstanceMigrator
migrationEnabled

	^ migrationEnabled ifNil: [ true ]
%

category: 'accessing'
method: RwGsInstanceMigrator
migrationEnabled: anObject

   migrationEnabled := anObject
%

! Class implementation for 'RwGsDeferredInstanceMigrator'

!		Instance methods for 'RwGsDeferredInstanceMigrator'

category: 'accessing'
method: RwGsDeferredInstanceMigrator
classesToMigrate

	^ classesToMigrate
%

category: 'migration'
method: RwGsDeferredInstanceMigrator
migrateInstancesOf: aClassArray

	"Record the list of classes with new class versions"

	classesToMigrate := aClassArray
%

! Class implementation for 'RwGsPatch'

!		Instance methods for 'RwGsPatch'

category: 'accessing'
method: RwGsPatch
packageDefinition
	^packageDefinition
%

category: 'accessing'
method: RwGsPatch
packageDefinition: newValue
	packageDefinition := newValue
%

category: 'accessing'
method: RwGsPatch
packageName

	^packageDefinition key
%

category: 'accessing'
method: RwGsPatch
projectDefinition

	^ projectDefinition ifNil: [ RwUnmanagedProjectDefinition new ]
%

category: 'accessing'
method: RwGsPatch
projectDefinition: newValue
	projectDefinition := newValue
%

category: 'accessing'
method: RwGsPatch
projectName

	^projectDefinition key
%

category: 'utility'
method: RwGsPatch
resolveName: aName

	"Answer a SymbolAssociation for the given name."

	^ Rowan image resolveName: aName
%

category: 'accessing'
method: RwGsPatch
symbolDictionary

	^ self symbolDictionaryFor: self packageName
%

category: 'accessing'
method: RwGsPatch
symbolDictionaryFor: aPackageName

	^ self symbolDictionaryFor: aPackageName projectDefinition: self projectDefinition
%

category: 'accessing'
method: RwGsPatch
symbolDictionaryFor: aPackageName projectDefinition: aProjectDefinition

	| symDictName symDict |
	symDictName := aProjectDefinition
		symbolDictNameForPackageNamed:aPackageName.
	symDict := GsCurrentSession currentSession symbolList objectNamed: symDictName asSymbol.
	symDict
		ifNotNil: [ symDict rowanSymbolDictionaryRegistry ifNotNil: [ ^ symDict ] ].
	^ Rowan image newOrExistingSymbolDictionaryNamed: symDictName
%

category: 'accessing'
method: RwGsPatch
symbolDictionaryRegistry

	^ self symbolDictionary rowanSymbolDictionaryRegistry
%

category: 'accessing'
method: RwGsPatch
symbolDictionaryRegistryFor: aPackageName

	^ (self symbolDictionaryFor: aPackageName) rowanSymbolDictionaryRegistry
%

! Class implementation for 'RwGsClassPatch'

!		Class methods for 'RwGsClassPatch'

category: 'instance creation'
classmethod: RwGsClassPatch
for: aClassDefinition inPackage: aPackageDefinition

	^(self new)
		classDefinition: aClassDefinition;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassPatch'

category: 'actions'
method: RwGsClassPatch
addToNewClassesByName: aDictionary

	"Dictionary is class name -> classAdditionPatch. Error on duplicate name."

	| name |
	name := classDefinition key.
	name ifNil: [ self error: 'Class definition with no name.' ].
	(aDictionary includesKey: name)
		ifTrue: [ self error: 'Duplicate name' ].
	aDictionary at: name put: self
%

category: 'private'
method: RwGsClassPatch
basicCreateClassWithSuperclass: superclass

	"For GemStone, the valid values are:
	bytes
	variable
	normal for non-indexable pointer object"

	"Must be in-synch with RwGsLoadedClass>>updateClassTypeFromClass"

	| type oldVersion createdClass gs_options oldConstraints |
	type := classDefinition classType.
	oldVersion := self oldClassVersion.
	oldConstraints := oldVersion
		ifNil: [ #() ]
		ifNotNil: [ oldVersion _rwSortedConstraints ].
	gs_options := (classDefinition gs_options)
		collect: [ :each | each asSymbol ].
	createdClass := type = 'normal'
		ifTrue: [ 
			superclass
				subclass: classDefinition key
				instVarNames: (classDefinition propertyAt: 'instvars')
				classVars: (classDefinition propertyAt: 'classvars')
				classInstVars: (classDefinition propertyAt: 'classinstvars')
				poolDictionaries: (classDefinition propertyAt: 'pools')
				inDictionary: nil
				newVersionOf: oldVersion
				description: (classDefinition propertyAt: 'comment' ifAbsent: [ '' ])
				constraints: oldConstraints
				options: gs_options ]
		ifFalse: [ 
			type = 'variable'
				ifTrue: [ 
					superclass
						indexableSubclass: classDefinition key
						instVarNames: (classDefinition propertyAt: 'instvars')
						classVars: (classDefinition propertyAt: 'classvars')
						classInstVars: (classDefinition propertyAt: 'classinstvars')
						poolDictionaries: (classDefinition propertyAt: 'pools')
						inDictionary: nil
						newVersionOf: oldVersion
						description: (classDefinition propertyAt: 'comment' ifAbsent: [ '' ])
						constraints: oldConstraints
						options: gs_options ]
				ifFalse: [ 
					type = 'bytes'
						ifTrue: [ 
							(classDefinition propertyAt: 'instvars') isEmpty
								ifFalse: [ self error: 'Cannot define byte class with named instvars.' ].
							superclass
								byteSubclass: classDefinition key
								classVars: (classDefinition propertyAt: 'classvars')
								classInstVars: (classDefinition propertyAt: 'classinstvars')
								poolDictionaries: (classDefinition propertyAt: 'pools')
								inDictionary: nil
								newVersionOf: oldVersion
								description: (classDefinition propertyAt: 'comment' ifAbsent: [ '' ])
								options: gs_options ]
						ifFalse: [ self error: 'Unknown class type' ] ] ].
	^ createdClass
%

category: 'accessing'
method: RwGsClassPatch
classDefinition
	^classDefinition
%

category: 'accessing'
method: RwGsClassPatch
classDefinition: newValue
	classDefinition := newValue
%

category: 'accessing'
method: RwGsClassPatch
className

	^classDefinition key
%

category: 'actions'
method: RwGsClassPatch
createClassFor: aPatchSet

	| createdClass |
	createdClass := self privateCreateClassFor: aPatchSet.
	aPatchSet createdClass: createdClass.
	^ createdClass
%

category: 'patching moved classes'
method: RwGsClassPatch
installPropertiesPatchFor: aPatchSet classMove: aClassMove

	| theRegistry |
	theRegistry := (self symbolDictionaryFor: aClassMove packageAfter name projectDefinition: aClassMove projectAfter)
		rowanSymbolDictionaryRegistry.
	self installPropertiesPatchFor: aPatchSet registry: theRegistry
%

category: 'versioning'
method: RwGsClassPatch
oldClassVersion
	"The old version is what is currently bound to the class definition's name."

	^ (self resolveName: classDefinition key) value
%

category: 'private'
method: RwGsClassPatch
privateCreateClassFor: aPatchSet

	| superclass |
	superclass := aPatchSet superclassNamed: classDefinition superclassName.
	superclass
		ifNil: [ 
			classDefinition superclassName = 'nil'
				ifFalse: [ 
					self
						error:
							'The class named ' , classDefinition superclassName printString
								, ' does not exist.' ] ].
	^ self privateCreateClassWithSuperclass: superclass
%

category: 'private'
method: RwGsClassPatch
privateCreateClassWithSuperclass: superclass

	| classProperties infoSource category createdClass |
	createdClass := self basicCreateClassWithSuperclass: superclass.
	classProperties := classDefinition properties.
	infoSource := Rowan configuration packageInfoSource.
	category := infoSource == #'Category'
		ifTrue: [ self packageName ]
		ifFalse: [ classProperties at: 'category' ifAbsent: [  ] ].
	createdClass category: category.
	^ createdClass
%

category: 'accessing'
method: RwGsClassPatch
superclassName

	^classDefinition superclassName
%

category: 'private'
method: RwGsClassPatch
_classFormat: fmt forSubclassType: classType
	"Legal types are normal, variable, and bytes."

	"These values need to be moved into Class"
	^classType = 'normal'
		ifTrue: [ fmt ]
		ifFalse: 
			[ classType = 'variable'
				ifTrue: [ fmt bitOr: 16r4.	"add indexable bit" ]
				ifFalse: 
					[ classType = 'bytes'
						ifTrue: [ (fmt bitAnd: 16r3 bitInvert) bitOr: 16r1 + 16r4 ]
						ifFalse: [self error: 'Unknown class type']]]
%

category: 'private'
method: RwGsClassPatch
_gemStoneConstraintsFrom:	gs_constraints
	"reify the constraints array converting to references to instvar names and classes"

	(gs_constraints isKindOf: Array)
		ifTrue: [ 
			gs_constraints isEmpty
				ifTrue: [^ #() ]
				ifFalse: [
					| theConstraints |
					 theConstraints := {}.
					gs_constraints do: [ :ar | 
						(ar isKindOf: Array)
							ifTrue: [ theConstraints add: { (ar at: 1) asSymbol . Rowan globalNamed: (ar at: 2) } ]
							ifFalse: [ theConstraints add: (Rowan globalNamed: ar) ] ].
					^ theConstraints ] ]
		ifFalse: [ ^ Rowan globalNamed: gs_constraints ].
%

! Class implementation for 'RwGsClassAdditionSymbolDictPatch'

!		Instance methods for 'RwGsClassAdditionSymbolDictPatch'

category: 'actions'
method: RwGsClassAdditionSymbolDictPatch
createAndInstallLoadedClass

	self symbolDictionaryRegistry
		createAndInstallLoadedClassForClass: newClass 
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'actions'
method: RwGsClassAdditionSymbolDictPatch
createClassFor: aPatchSet
	newClass := super createClassFor: aPatchSet.
	symbolAssociation := aPatchSet tempAssociationFor: newClass name.
	^ newClass
%

category: 'actions'
method: RwGsClassAdditionSymbolDictPatch
installClassInSystem

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	self symbolDictionaryRegistry
		addClassAssociation: symbolAssociation
		forClass: newClass
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'accessing'
method: RwGsClassAdditionSymbolDictPatch
newClass
	^newClass
%

category: 'versioning'
method: RwGsClassAdditionSymbolDictPatch
oldClassVersion
	"We are adding a new class, so there is no old version."

	^nil
%

! Class implementation for 'RwGsClassConstraintsSymDictPatch'

!		Instance methods for 'RwGsClassConstraintsSymDictPatch'

category: 'actions'
method: RwGsClassConstraintsSymDictPatch
addToNewClassesByName: aDictionary

	"noop"

	
%

category: 'installing'
method: RwGsClassConstraintsSymDictPatch
installPropertiesPatchFor: aPatchSet

	self installPropertiesPatchFor: aPatchSet registry: self symbolDictionaryRegistry
%

category: 'installing'
method: RwGsClassConstraintsSymDictPatch
installPropertiesPatchFor: aPatchSet registry: aSymbolDictionaryRegistry
	" update class and update loadedClass with new constraints"

	| className existingClass theConstraints existingConstraintsMap existingVaryingConstraint theConstraintsMap theVaryingConstraint keys existingConstraints instVarNames superConstraints superConstraintsMap superC superInstVarNames |
	className := classDefinition key asSymbol.
	existingClass := aPatchSet createdClasses
		at: className
		ifAbsent: [ 
			aPatchSet tempSymbols
				at: className
				ifAbsent: [ self error: 'Cannot find class to update constraints for.' ] ].
	superConstraintsMap := Dictionary new.
	existingConstraintsMap := Dictionary new.
	existingVaryingConstraint := existingClass _varyingConstraint.
	instVarNames := existingClass allInstVarNames.
	superC := existingClass superClass.
	superInstVarNames := superC ifNil: [ {} ] ifNotNil: [ superC allInstVarNames ].
	[ 
	superConstraints := superC
		ifNil: [ {} ]
		ifNotNil: [ :superCl | superCl _constraints ifNil: [ {} ] ].
	existingConstraints := existingClass _constraints ]
		on: Deprecated
		do: [ :ex | ex resume ].
	1 to: superConstraints size do: [ :index | 
		superConstraintsMap
			at: (superInstVarNames at: index)
			put: (superConstraints at: index) ].
	1 to: existingConstraints size do: [ :index | 
		existingConstraintsMap
			at: (instVarNames at: index)
			put: (existingConstraints at: index) ].
	theConstraints := self _gemStoneConstraintsFrom: classDefinition gs_constraints.
	theConstraintsMap := Dictionary new.
	theVaryingConstraint := Object.
	theConstraints
		do: [ :arrayOrVaryingConstraintClass | 
			arrayOrVaryingConstraintClass _isArray
				ifTrue: [ 
					theConstraintsMap
						at: (arrayOrVaryingConstraintClass at: 1)
						put: (arrayOrVaryingConstraintClass at: 2) ]
				ifFalse: [ theVaryingConstraint := arrayOrVaryingConstraintClass ] ].
	keys := existingConstraintsMap keys copy.
	keys addAll: theConstraintsMap keys.
	keys
		do: [ :key | 
			| existingConstraint theConstraint superConstraint instVarString |
			existingConstraint := existingConstraintsMap at: key ifAbsent: [  ].
			superConstraint := superConstraintsMap at: key ifAbsent: [  ].
			theConstraint := theConstraintsMap at: key ifAbsent: [  ].
			instVarString := key asString.
			existingConstraint == theConstraint
				ifTrue: [ 
					(theConstraint isNil and: [ superConstraint notNil ])
						ifTrue: [ 
							"inherit constraint from superclass"
							self _rwInstVar: instVarString constrainTo: superConstraint ] ]
				ifFalse: [ 
					existingConstraint == nil
						ifTrue: [ 
							"add theConstraint"
							existingClass _rwInstVar: instVarString constrainTo: theConstraint ]
						ifFalse: [ 
							theConstraint == nil
								ifTrue: [ 
									superConstraint notNil
										ifTrue: [ 
											existingConstraint ~= superConstraint
												ifTrue: [ 
													"inherit constraint from superclass"
													self _rwInstVar: instVarString constrainTo: superConstraint ] ]
										ifFalse: [ 
											"remove the constraint"
											existingClass _rwInstVar: instVarString constrainTo: Object ] ]
								ifFalse: [ 
									"change the value of the constraint"
									existingClass _rwInstVar: instVarString constrainTo: theConstraint ] ] ] ].
	existingVaryingConstraint == theVaryingConstraint
		ifFalse: [ 
			"change the varying constraint"
			[ existingClass _setVaryingConstraint: theVaryingConstraint ]
				on: Deprecated
				do: [ :ex | ex resume ] ].
	aSymbolDictionaryRegistry
		updateClassProperties: existingClass
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

! Class implementation for 'RwGsClassDeletionSymbolDictPatch'

!		Class methods for 'RwGsClassDeletionSymbolDictPatch'

category: 'instance creation'
classmethod: RwGsClassDeletionSymbolDictPatch
for: aClassDefinition

	^self new classDefinition: aClassDefinition
%

!		Instance methods for 'RwGsClassDeletionSymbolDictPatch'

category: 'actions'
method: RwGsClassDeletionSymbolDictPatch
addToNewClassesByName: aDictionary

	"noop"

	
%

category: 'deleting'
method: RwGsClassDeletionSymbolDictPatch
deleteClassFromSystem

	self symbolDictionaryRegistry deleteClassNamedFromPackage: self className implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'accessing'
method: RwGsClassDeletionSymbolDictPatch
symbolDictionaryFor: aPackageName

	"because this is a deletion, we can look up the symbol dictionariy directly"

	| className class | 
	className := self classDefinition name.
	class := Rowan globalNamed: className.
	Rowan image 
		loadedClassAndSymbolDicitonaryForClass: class 
		ifPresent: [:symDict :loadedClass | ^symDict ]
		ifAbsent: [ self error: 'No symbol dictionary found for the class ', className printString ].
%

! Class implementation for 'RwGsClassExtensionSymbolDictPatch'

!		Instance methods for 'RwGsClassExtensionSymbolDictPatch'

category: 'actions'
method: RwGsClassExtensionSymbolDictPatch
installClassExtensionInSystem

	"The class must already exist.
        Create or update the LoadedClassExtension for the extended class."

	(self projectDefinition
		useSessionMethodsForExtensionsForPackageNamed: self packageName)
		ifTrue: [ | resolved |
			((resolved := Rowan image symbolList objectNamed: self className asSymbol) notNil and: [resolved isBehavior and: [ resolved isMeta not ]])
				ifFalse: [ 
					self
						error:
							'The extension class named ' , self className printString , ' cannot be found.' ] ]
		ifFalse: [ 
			self symbolDictionaryRegistry
				ensureExtensionClassNamed: self className
				existsForPackageNamed: self packageName
				implementationClass: RwGsSymbolDictionaryRegistry_Implementation ]
%

! Class implementation for 'RwGsClassPropertiesSymDictPatch'

!		Instance methods for 'RwGsClassPropertiesSymDictPatch'

category: 'actions'
method: RwGsClassPropertiesSymDictPatch
addToNewClassesByName: aDictionary

	"noop"

	
%

category: 'installing'
method: RwGsClassPropertiesSymDictPatch
installPropertiesPatchFor: aPatchSet

	self installPropertiesPatchFor: aPatchSet registry: self symbolDictionaryRegistry
%

category: 'installing'
method: RwGsClassPropertiesSymDictPatch
installPropertiesPatchFor: aPatchSet registry: aSymbolDictionaryRegistry

	" update class and update loadedClass with new properties"

	| className existingClass createdClass |
	className := classDefinition key asSymbol.
	existingClass := aPatchSet createdClasses
		at: className
		ifAbsent: [ 
			aPatchSet tempSymbols
				at: className
				ifAbsent: [ self error: 'Cannot find class to update properties for.' ] ].
	createdClass := self createClassFor: aPatchSet.	"use createClassFor:, but not expected to create new class version"
	createdClass == existingClass
		ifFalse: [ 
			self
				error:
					'internal error - class changed during class property update ... should have been a class versioning patch' ].
	aSymbolDictionaryRegistry updateClassProperties: existingClass implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

! Class implementation for 'RwGsClassSymbolDictionaryMoveSymDictPatch'

!		Class methods for 'RwGsClassSymbolDictionaryMoveSymDictPatch'

category: 'instance creation'
classmethod: RwGsClassSymbolDictionaryMoveSymDictPatch
for: aClassModification inPackage: aPackageDefinition

	^ self new
		classModification: aClassModification;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassSymbolDictionaryMoveSymDictPatch'

category: 'accessing'
method: RwGsClassSymbolDictionaryMoveSymDictPatch
classModification

	^classModification
%

category: 'accessing'
method: RwGsClassSymbolDictionaryMoveSymDictPatch
classModification: aClassModification

	classModification := aClassModification.
	classDefinition := classModification after
%

category: 'installing'
method: RwGsClassSymbolDictionaryMoveSymDictPatch
installSymbolDictionaryPatchFor: aPatchSet

	| before originalSymbolDictionary assoc newSymbolDictionary theClass registry |
	theClass := Rowan globalNamed: classDefinition name.
	before := classModification before.
	originalSymbolDictionary := Rowan globalNamed: before gs_symbolDictionary.
	assoc := originalSymbolDictionary associationAt: before key asSymbol.
	registry := originalSymbolDictionary rowanSymbolDictionaryRegistry.
	registry deleteClassNamedFromPackage: classDefinition name implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	newSymbolDictionary := Rowan globalNamed: ((projectDefinition specification platformSpec at: 'gemstone')
				symbolDictNameForPackageNamed: packageDefinition name) .
	registry := newSymbolDictionary rowanSymbolDictionaryRegistry.
	registry 
		addClassAssociation: assoc 
			forClass: theClass 
			toPackageNamed: packageDefinition name
			implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'installing'
method: RwGsClassSymbolDictionaryMoveSymDictPatch
installSymbolDictionaryPatchFor: aPatchSet classMove: aClassMove

	RwGsSymbolDictionaryRegistry_Implementation moveClassFor: aClassMove
%

! Class implementation for 'RwGsClassVariableChangeSymbolDictPatch'

!		Instance methods for 'RwGsClassVariableChangeSymbolDictPatch'

category: 'actions'
method: RwGsClassVariableChangeSymbolDictPatch
createClassFor: aPatchSet

	"we're using createClassFor: to apply the class variable modifications. not expected to 
		create a new class version"

	| oldClassVersion newClassVersion |
	oldClassVersion := self oldClassVersion.
	newClassVersion := self privateCreateClassFor: aPatchSet.
	oldClassVersion == newClassVersion
		ifFalse: [ 
			self
				error:
					'internal error - unexpected new class version for class variable modification' ].
	^ oldClassVersion
%

category: 'installing'
method: RwGsClassVariableChangeSymbolDictPatch
installPropertiesPatchFor: aPatchSet

	self installPropertiesPatchFor: aPatchSet registry: self symbolDictionaryRegistry
%

category: 'installing'
method: RwGsClassVariableChangeSymbolDictPatch
installPropertiesPatchFor: aPatchSet registry: aSymbolDictionaryRegistry

	" update class and update loadedClass with new properties"

	| className existingClass |
	className := classDefinition key asSymbol.
	existingClass := aPatchSet createdClasses
		at: className
		ifAbsent: [ 
			aPatchSet tempSymbols
				at: className
				ifAbsent: [ self error: 'Cannot find class to update properties for.' ] ].
	aSymbolDictionaryRegistry updateClassProperties: existingClass  implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

! Class implementation for 'RwGsClassVersioningPatch'

!		Class methods for 'RwGsClassVersioningPatch'

category: 'patching'
classmethod: RwGsClassVersioningPatch
addPatchedClassModification: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet

	"Need to decide whether the patches in aClassModification warrant a new class version or 
	 simple property changes."

	^ self new
		addPatchedClassModification: aClassModification
		inPackage: aPackageDefinition
		inProject: aProjectDefinition
		toPatchSet: aRwGsPatchSet
%

category: 'patching'
classmethod: RwGsClassVersioningPatch
addPatchedClassModificationForcingNewClassVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet

	"Need to decide whether the patches in aClassModification warrant a new class version or 
	 simple property changes."

	^ self new
		addPatchedClassModificationForcingNewClassVersion: aClassModification
		inPackage: aPackageDefinition
		inProject: aProjectDefinition
		toPatchSet: aRwGsPatchSet
%

category: 'instance creation'
classmethod: RwGsClassVersioningPatch
for: aClassModification inPackage: aPackageDefinition

	^ self new
		classModification: aClassModification;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassVersioningPatch'

category: 'patching'
method: RwGsClassVersioningPatch
addPatchedClassModification: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet

	"Need to decide whether the patches in aClassModification warrant a new class version or 
	 simple property changes."

	| dict existingClass newFormat afterClassDefinition beforeClassDefinition newSuperclassAssoc afterSymDict beforeSymDict |
	packageDefinition := aPackageDefinition.
	projectDefinition := aProjectDefinition.
	afterClassDefinition := aClassModification after.
	beforeClassDefinition := aClassModification before.
	(newSuperclassAssoc := self resolveName: afterClassDefinition superclassName)
		ifNil: [
			"new superclass does not currently exist ... so it will be a new class, which means a new class version, guaranteed"
			aRwGsPatchSet
				addPatchedClassNewVersion: aClassModification
				inPackage: aPackageDefinition
				inProject: aProjectDefinition.
			^ self ].
	dict := Rowan image symbolList objectNamed: beforeClassDefinition gs_symbolDictionary.
	existingClass := dict
		at: beforeClassDefinition name asSymbol
		ifAbsent: [ self error: 'Internal error. Attempt to modify a class whose name is not bound.' ].
	newFormat := self
		_classFormat: existingClass superclass format
		forSubclassType: afterClassDefinition classType.
	afterSymDict := self symbolDictionary name asString.
	beforeSymDict := beforeClassDefinition gs_symbolDictionary.
	beforeSymDict ~= afterSymDict
		ifTrue: [
			aRwGsPatchSet
				addPatchedClassSymbolDictionaryMove: aClassModification
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ].
	self
		_newSubclassWithSuperclass: newSuperclassAssoc value
		isEquivalentToSubclass: existingClass
		newOpts: (afterClassDefinition gs_options collect: [:each | each asSymbol])
		newFormat: newFormat
		newInstVars: afterClassDefinition instVarNames
		newClassInstVars: afterClassDefinition classInstVarNames
		newPools: afterClassDefinition poolDictionaryNames
		newClassVars: afterClassDefinition classVarNames
		newConstraints: (self _gemStoneConstraintsFrom: afterClassDefinition gs_constraints)
		patchedClassProperties: [
			aClassModification propertiesModification isEmpty
				ifFalse: [ 
					aRwGsPatchSet
						addPatchedClassProperties: afterClassDefinition
						inPackage: aPackageDefinition
						inProject: aProjectDefinition ] ]
		patchedConstraints: [
			aRwGsPatchSet
						addPatchedClassConstraints: afterClassDefinition
						inPackage: aPackageDefinition
						inProject: aProjectDefinition ]
		patchedClassVars: [ 
			aRwGsPatchSet
				addPatchedClassClassVariables: afterClassDefinition
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ]
		patchedClassNewVersions: [ 
			aRwGsPatchSet
				addPatchedClassNewVersion: aClassModification
				inPackage: aPackageDefinition
				inProject: aProjectDefinition ]
%

category: 'patching'
method: RwGsClassVersioningPatch
addPatchedClassModificationForcingNewClassVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition toPatchSet: aRwGsPatchSet

	"Uncontitionally create a new class version"

	| dict existingClass beforeClassDefinition |
	packageDefinition := aPackageDefinition.
	projectDefinition := aProjectDefinition.
	beforeClassDefinition := aClassModification before.
	dict := Rowan image symbolList objectNamed: beforeClassDefinition gs_symbolDictionary.
	existingClass := dict
		at: beforeClassDefinition name asSymbol
		ifAbsent: [ self error: 'Internal error. Attempt to modify a class whose name is not bound.' ].
	aRwGsPatchSet
		addPatchedClassNewVersion: aClassModification
		inPackage: aPackageDefinition
		inProject: aProjectDefinition
%

category: 'accessing'
method: RwGsClassVersioningPatch
classModification: aClassModification

	classModification := aClassModification.
	classDefinition := classModification after
%

category: 'actions'
method: RwGsClassVersioningPatch
createClassFor: aPatchSet
	"we're using createClassFor: to apply the class modifications to the existing class
	oldClassVersion and produce a new class version"

	oldClassVersion := self oldClassVersion.
	newClassVersion := super createClassFor: aPatchSet.
	symbolAssociation := self resolveName: newClassVersion name.
	^ newClassVersion
%

category: 'accessing'
method: RwGsClassVersioningPatch
oldClassDefinition

	^ classModification before
%

category: 'versioning'
method: RwGsClassVersioningPatch
oldClassVersion

	"The old version is what is currently bound to the old class definition's name."

	^ (self resolveName: self oldClassDefinition key) value
%

category: 'actions'
method: RwGsClassVersioningPatch
updateSymbolAssociation

	oldClassVersion == newClassVersion 
		ifTrue: [ 
			"no newClassVersion created when property modifications applied .. not a problem"
			^self ].
	symbolAssociation value: newClassVersion
%

category: 'private'
method: RwGsClassVersioningPatch
_newSubclassWithSuperclass: newSuperclass isEquivalentToSubclass: oldClass 
newOpts: optionsArray newFormat: theFormat newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars 
newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars newConstraints: aConstraint
patchedClassProperties: patchedClassPropertiesBlock 
patchedConstraints: patchedConstraintsBlock 
patchedClassVars: patchedClassVarsBlock 
patchedClassNewVersions: patchedClassNewVersionsBlock

	" based on Class>>_equivalentSubclass:superCls:name:newOpts:newFormat:newInstVars:newClassInstVars:newPools:newClassVars:inDict:isKernel: and ultimately needs to be rolled back into base, so that class creation and Rowan use the same new class version rules.
"

	"Class>>_equivalentSubclass:... has unwanted side effects"

	"squeezed down to the bare minimum"

	"oldClass is equivalent to the subclass that would be created using
 the other arguments if 
     instVar names match exactly ,
   and class instVar names match exactly ,
   and the classVars in oldClass can be modified to add/remove Associations 
     to match anArrayOfClassVars ,
   and pool dictionaries match exactly

  With respect to options and format, oldClass is equivalent if
    The state of format bits dbTransient, instancesNonPersistent, instancesInvariant  
     match exactly ,
    and subclassesDisallowed cannot be set in the new subclass if it not set in oldClass ,
    and modifiable  cannot be set if it is not set in oldClass  ,
    and  (SELF_CAN_BE_SPECIAL, NSC_DUPLICATES, INDEXABLE, IMPLEMENTATION, NO_STRUCT_UPDATE bits)
        of the formats must match exactly.
"

	| supr opts ivs civs poolds cvars cons cvarsPatched |
	cvarsPatched := (anArrayOfClassVars asSortedCollection = oldClass classVarNames asSortedCollection) not.
	self
		_newSubclassWithSuperclass: newSuperclass
		isEquivalentToSubclass: oldClass
		newOpts: optionsArray
		newFormat: theFormat
		newInstVars: anArrayOfInstvarNames
		newClassInstVars: anArrayOfClassInstVars
		newPools: anArrayOfPoolDicts
		newClassVars: anArrayOfClassVars
		newConstraints: aConstraint
		suprBlock: [ :bool | supr := bool not ]
		optsBlock: [ :arg | "arg is true or a String" opts := arg ~~ true  ]
		ivsBlock: [ :bool | ivs := bool not ]
		civsBlock: [ :bool | civs := bool not ]
		poolsBlock: [ :bool | poolds := bool not ]
		cvarsBlock: [ :bool | cvars := bool not ]
		consBlock:  [ :bool | cons := bool not ].
	(supr or: [ opts or: [ ivs or: [ civs or: [ poolds or: [cvars ] ] ] ] ])
		ifTrue: [ 
			"new class version means that class vars will be patched (for free) before methods compiled"
			patchedClassNewVersionsBlock value.
			^ self ].
	cvarsPatched
		ifTrue: [ 
			"have to patch class variables BEFORE methods are compiled"
			patchedClassVarsBlock value ].
	cons
		ifTrue: [
			"constraint changes are added in separate step after all classes have been created"
			patchedConstraintsBlock value ].
	"class property changes that do not affect method compilation"
	patchedClassPropertiesBlock value
%

! Class implementation for 'RwGsClassVersioningSymbolDictPatch'

!		Class methods for 'RwGsClassVersioningSymbolDictPatch'

category: 'instance creation'
classmethod: RwGsClassVersioningSymbolDictPatch
for: aClassModification inPackage: aPackageDefinition

	^ self new
		classModification: aClassModification;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsClassVersioningSymbolDictPatch'

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatch
classModification: aClassModification

	classModification := aClassModification.
	classDefinition := classModification after
%

category: 'actions'
method: RwGsClassVersioningSymbolDictPatch
createClassFor: aPatchSet

	"we're using createClassFor: to apply the class modifications to the existing class
	oldClassVersion and produce a new class version"

	oldClassVersion := self oldClassVersion.	"grab the class version BEFORE creating newClassVersion ...it may be needed later"
	newClassVersion := super createClassFor: aPatchSet.
	symbolAssociation := self resolveName: newClassVersion name.
	^ newClassVersion
%

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatch
existingSymbolDictionary
	"answer the current symbol dictionary for the class ... before being (potentially) moved to a different symbolDictionary"

	| symDictName symDict |
	symDictName := classModification before gs_symbolDictionary.
	symDict := GsCurrentSession currentSession symbolList objectNamed: symDictName asSymbol.
	symDict
		ifNotNil: [ symDict rowanSymbolDictionaryRegistry ifNotNil: [ ^ symDict ] ].
	^ Rowan image newOrExistingSymbolDictionaryNamed: symDictName
%

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatch
existingSymbolDictionaryRegistry

	^ self existingSymbolDictionary rowanSymbolDictionaryRegistry
%

category: 'patching'
method: RwGsClassVersioningSymbolDictPatch
installNewClassVersionInSystem

	"Install the new class association in the symbolAssociation for the class.
	 Update the LoadedClass with properties for the new classversion."

	self symbolDictionaryRegistry addNewClassVersionToAssociation: newClassVersion implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'patching'
method: RwGsClassVersioningSymbolDictPatch
moveNewClassVersionInSystem: aClassMove

	"Move the class association for the class.
	 Update the LoadedClass with properties for the new classversion."

	| theRegistry |
	theRegistry := (self symbolDictionaryFor: aClassMove packageAfter name projectDefinition: aClassMove projectAfter)
		rowanSymbolDictionaryRegistry.

	theRegistry addNewClassVersionToAssociation: newClassVersion 
			implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'versioning'
method: RwGsClassVersioningSymbolDictPatch
newClassVersion

	^ newClassVersion
%

category: 'accessing'
method: RwGsClassVersioningSymbolDictPatch
oldClassDefinition

	^ classModification before
%

category: 'versioning'
method: RwGsClassVersioningSymbolDictPatch
oldClassVersion

	"The old version is what is currently bound to the old class definition's name."

	oldClassVersion ifNotNil: [ ^ oldClassVersion ].
	^ (self resolveName: self oldClassDefinition key) value
%

category: 'new version support'
method: RwGsClassVersioningSymbolDictPatch
updateNewClassVersionPatchesForExtensionsIn: aProjectSetModification patchSet: aPatchSet

	| className class |
	className := classDefinition name.
	class := Rowan globalNamed: className.
	self
		_updateNewClassVersionPatchesForClass: class
		in: aProjectSetModification
		patchSet: aPatchSet
%

category: 'new version support'
method: RwGsClassVersioningSymbolDictPatch
updateNewClassVersionPatchesForSubclassesIn: aProjectSetModification patchSet: patchSet

	| subclassesOfClassWithNewVersions existingClass classesWithNewVersions |
	existingClass := self oldClassVersion.
	subclassesOfClassWithNewVersions := IdentitySet new.
	subclassesOfClassWithNewVersions
		addAll: ((ClassOrganizer new allSubclassesOf: existingClass) reject: [:class | (Rowan image loadedClassForClass: class ifAbsent: []) isNil ]).
	classesWithNewVersions := patchSet classesWithNewVersions
		collect: [ :patch | patch oldClassVersion ].
	subclassesOfClassWithNewVersions removeAllPresent: classesWithNewVersions.
	subclassesOfClassWithNewVersions
		do: [ :subclass | 
			| loadedClass loadedPackage loadedProject loadedClassDefinition subclassName newVersionClassModification 
				projectModification packageModification classesModification classesModified |
			subclassName := subclass name asString.
			loadedClass := Rowan image loadedClassNamed: subclassName.
			loadedClassDefinition := loadedClass asDefinition.
			loadedPackage := loadedClass loadedPackage.
			loadedProject := loadedClass loadedProject.
			newVersionClassModification := loadedClassDefinition
				compareAgainstBaseForcingNewClassVersion: loadedClassDefinition.

			projectModification := aProjectSetModification elementsModified 
				at: loadedProject name 
				ifAbsentPut: [
					| def |
					"arrange for anew project modification to be added"
					def := loadedProject asDefinition.
					(RwProjectModification before: def after: def)
						propertiesModification: RwPropertiesModification new;
						packagesModification: RwPackagesModification new;
						yourself ].
			packageModification := projectModification packagesModification elementsModified 
					at: loadedPackage name 
					ifAbsentPut: [  
						| def |
						"arrange for a new package modification to be added"
						def := loadedPackage asDefinition.
						(RwPackageModification before: def after: def)
							classesModification: RwClassesModification new;
							classExtensionsModification: RwClassExtensionsModification new;
							yourself  ].
			classesModification := packageModification classesModification.
			classesModified := classesModification elementsModified.
			classesModification isEmpty
				ifTrue: [ 
					classesModified at: subclassName put: newVersionClassModification.
					newVersionClassModification
						mergeForNewClassVersionWith: newVersionClassModification ]
				ifFalse: [ 
					(classesModified at: subclassName ifAbsent: [  ])
						ifNil: [
							classesModified at: subclassName put: newVersionClassModification.
							newVersionClassModification
								mergeForNewClassVersionWith: newVersionClassModification ]
						ifNotNil: [ :existingClassModification | 
							existingClassModification isDeletion
								ifTrue: [ 
									"a deletion is not unexpected ... "
									]
								ifFalse: [
									newVersionClassModification mergeForExistingClassWith: existingClassModification.
									classesModified at: subclassName put: newVersionClassModification ] ] ] .
			self
				_updateNewClassVersionPatchesForClass: subclass
				in: aProjectSetModification
				patchSet: patchSet ]
%

category: 'new version support'
method: RwGsClassVersioningSymbolDictPatch
updatePatchesForNewClassVersion: aProjectSetModification patchSet: patchSet

	| existingClass loadedClass loadedPackageName loadedClassDefinition newVersionClassModification existingClassName movedDeletedMap |
	movedDeletedMap := Dictionary new.
	patchSet movedClassesMap keysAndValuesDo: [:className :classMove | movedDeletedMap at: className put: classMove ].
	existingClass := self oldClassVersion.
	existingClassName := existingClass name asString.

	loadedClass := self existingSymbolDictionaryRegistry existingForClass: existingClass.
	loadedClassDefinition := loadedClass asDefinition.
	loadedPackageName := loadedClass loadedPackage name.

	newVersionClassModification := self classDefinition
		compareAgainstBaseForNewClassVersion: loadedClassDefinition.
	newVersionClassModification isEmpty
		ifFalse: [ 
			"only newVersionClassModification with substance need further processing"
			aProjectSetModification
				classesModificationAndPackageModificationAndProjectModificationDo: [ :classesModification :packageModification | 
					classesModification isEmpty
						ifFalse: [ 
							| classesModified |
							classesModified := classesModification elementsModified.
							(classesModified at: existingClassName ifAbsent: [  ])
								ifNil: [ "not unexpected ... if there are multiple packages involved" ]
								ifNotNil: [ :existingClassModification | 
									| deleteClassModification |
									deleteClassModification := false.
									(movedDeletedMap at: existingClassName ifAbsent: []) ifNotNil: [:classMove |
										deleteClassModification := classMove packageBefore name = packageModification after name ].
									deleteClassModification
										ifTrue: [classesModified removeKey: existingClassName]
										ifFalse: [
											newVersionClassModification mergeForExistingClassWith: existingClassModification.
											classesModified at: existingClassName put: newVersionClassModification ] ] ] ] ]
%

category: 'private'
method: RwGsClassVersioningSymbolDictPatch
_createMethodExtensionModificationForNewVersionOfClassNamed: className isMeta: isMeta loadedMethod: loadedMethod projectSetModification: aProjectSetModification

	| loadedProject loadedPackage loadedClassExtension projectModification packageModification 
		classExtensionModification methodsModification methodDef source sourceModification modification
		afterMethodDef beforeMethodDef |
	loadedClassExtension := loadedMethod loadedClass.
	loadedPackage := loadedMethod loadedPackage.
	loadedProject := loadedMethod loadedProject.
	projectModification := aProjectSetModification elementsModified
		at: loadedProject name
		ifAbsentPut: [
			| def |
			def := loadedProject asDefinition.
			(RwProjectModification before: def after: def)
				propertiesModification: RwPropertiesModification new;
				packagesModification: RwPackagesModification new;
				yourself ].
	packageModification := projectModification packagesModification
		elementsModified
		at: loadedPackage name
		ifAbsentPut: [ 
			| def |
			"arrange for a new package to be added"
			def := loadedPackage asDefinition.
			(RwPackageModification before: def after: def)
				classesModification: RwClassesModification new;
				classExtensionsModification: RwClassExtensionsModification new;
				yourself ].
	classExtensionModification := packageModification classExtensionsModification
		elementsModified
		at: className
		ifAbsentPut: [ 
			| def |
			def := (loadedPackage loadedClassExtensions at: className) asDefinition.
			(RwClassExtensionModification
				before: RwClassExtensionDefinition new
				after: def)
				instanceMethodsModification:
						(RwExtensionMethodsModification extendedClassName: className);
				classMethodsModification:
						(RwExtensionMethodsModification extendedClassName: className);
				yourself ].
	methodsModification := isMeta
		ifTrue: [ classExtensionModification classMethodsModification elementsModified ]
		ifFalse: [ classExtensionModification instanceMethodsModification elementsModified ].
	(methodsModification at: loadedMethod selector ifAbsent: [  ])
		ifNil: [
			afterMethodDef := beforeMethodDef := methodDef := loadedMethod asDefinition.
			source := methodDef source.
			sourceModification := RwSourceModification new
				addElementModification:
						(RwUnconditionalPropertyModification
								key: 'source'
								oldValue: source
								newValue: source);
				yourself.
			modification := (RwExtensionMethodModificationForNewClassVersion
				before: beforeMethodDef
				after: afterMethodDef)
				isMeta: isMeta;
				classDefinition: loadedClassExtension asDefinition;
				propertiesModification: RwPropertiesModification new;
				sourceModification: sourceModification;
				yourself ]
		ifNotNil: [:theMethodModification |
			modification := (RwExtensionMethodModificationForNewClassVersion
				before: theMethodModification before
				after: theMethodModification after)
				isMeta: isMeta;
				classDefinition: loadedClassExtension asDefinition;
				propertiesModification: theMethodModification propertiesModification;
				sourceModification: theMethodModification sourceModification;
				yourself ].

	methodsModification at: loadedMethod selector put: modification
%

category: 'private'
method: RwGsClassVersioningSymbolDictPatch
_updateNewClassVersionPatchesForClass: class in: aProjectSetModification patchSet: aPatchSet

	| className extensionMap emptyDict |
	className := class name asString.
	extensionMap := Dictionary new.
	emptyDict := Dictionary new.
	(Rowan image loadedClassExtensionsForClass: class)
		do: [ :loadedClassExtension | 
			| dict |
			dict := extensionMap at: className ifAbsentPut: [ Dictionary new ].
			loadedClassExtension
				loadedInstanceMethodsDo: [ :loadedProject :loadedPackage :loadedClass :loadedMethod | 
					(dict at: 'instance' ifAbsentPut: [ Dictionary new ])
						at: loadedMethod selector
						put: loadedMethod ]
				loadedClassMethodsDo: [ :loadedProject :loadedPackage :loadedClass :loadedMethod | 
					(dict at: 'class' ifAbsentPut: [ Dictionary new ])
						at: loadedMethod selector
						put: loadedMethod ] ].
	extensionMap isEmpty
		ifTrue: [ ^ self ].
	aPatchSet
		allPatchesAffectingLiveMethodsDo: [ :patch | 
			| methodsDict selectorDict |
			methodsDict := extensionMap
				at: patch classDefinition name
				ifAbsent: [ emptyDict ].
			selectorDict := patch isMeta
				ifTrue: [ methodsDict at: 'class' ifAbsent: [ emptyDict ] ]
				ifFalse: [ methodsDict at: 'instance' ifAbsent: [ emptyDict ] ] ]
		deletedMethodsDo: [ :patch | 
			| methodsDict selectorDict |
			methodsDict := extensionMap
				at: patch classDefinition name
				ifAbsent: [ emptyDict ].
			selectorDict := patch isMeta
				ifTrue: [ methodsDict at: 'class' ifAbsent: [ emptyDict ] ]
				ifFalse: [ methodsDict at: 'instance' ifAbsent: [ emptyDict ] ].
			selectorDict removeKey: patch methodDefinition selector ifAbsent: [  ] ].
	extensionMap
		valuesDo: [ :methodsDict | 
			(methodsDict at: 'instance' ifAbsent: [ emptyDict ])
				valuesDo: [ :loadedMethod | 
					self
						_createMethodExtensionModificationForNewVersionOfClassNamed: className
						isMeta: false
						loadedMethod: loadedMethod
						projectSetModification: aProjectSetModification ].
			(methodsDict at: 'class' ifAbsent: [ emptyDict ])
				valuesDo: [ :loadedMethod | 
					self
						_createMethodExtensionModificationForNewVersionOfClassNamed: className
						isMeta: true
						loadedMethod: loadedMethod
						projectSetModification: aProjectSetModification ] ]
%

! Class implementation for 'RwGsMethodPatch'

!		Class methods for 'RwGsMethodPatch'

category: 'instance creation'
classmethod: RwGsMethodPatch
forMethod: aMethodDefinition isMeta: isMeta inClass: aClassDefinition inPackage: aPackageDefinition

	^(self new)
		methodDefinition: aMethodDefinition;
		isMeta: isMeta;
		classDefinition: aClassDefinition;
		packageDefinition: aPackageDefinition;
		yourself
%

!		Instance methods for 'RwGsMethodPatch'

category: 'accessing'
method: RwGsMethodPatch
behavior

	^ behavior
%

category: 'accessing'
method: RwGsMethodPatch
classDefinition

	^ classDefinition
%

category: 'accessing'
method: RwGsMethodPatch
classDefinition: newValue
	classDefinition := newValue
%

category: 'accessing'
method: RwGsMethodPatch
className

	^ self classDefinition key
%

category: 'accessing'
method: RwGsMethodPatch
compiledMethod

	^ compiledMethod
		ifNil: [ 
			| methodDictionary |
			methodDictionary := behavior persistentMethodDictForEnv: 0.
			selector := methodDefinition selector.
			compiledMethod := methodDictionary
				at: selector
				ifAbsent: [ self error: 'internal error - compiled method not present in method dictionary' ] ]
%

category: 'compiling'
method: RwGsMethodPatch
compileUsingNewClasses: createdClasses andExistingClasses: tempSymbols

	| sourceString symbolList protocol |
	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ self error: 'Class ' , self className printString , ' not found.' ].

	sourceString := methodDefinition source.
	symbolList := SymbolList with: tempSymbols.
	protocol := (methodDefinition propertyAt: 'protocol') asSymbol.
	compiledMethod := behavior
		compileMethod: sourceString
		dictionaries: symbolList
		category: protocol
		intoMethodDict: false
		intoCategories: nil
		intoPragmas: nil
		environmentId: self methodEnvironmentId
%

category: 'initializers'
method: RwGsMethodPatch
isAnInitializer

	"answer true if I represent a class initialization method"

	^ isMeta and: [ selector == #'initialize' ]
%

category: 'accessing'
method: RwGsMethodPatch
isMeta

	^ isMeta
%

category: 'accessing'
method: RwGsMethodPatch
isMeta: newValue
	isMeta := newValue
%

category: 'private'
method: RwGsMethodPatch
loadedClassOrExtensionForMethod

	"The loaded class or extension should already exist."

	| loadedPackage className |
	loadedPackage := Rowan image
		loadedPackageNamed: self packageName
		ifAbsent: [ 
			self
				error: 'Internal error -- attempt to add a method to a nonexistent package.' ].
	className := classDefinition key.
	^ loadedPackage
		classOrExtensionForClassNamed: className
		ifAbsent: [ 
			self
				error:
					'Internal error -- attempt to add a method to a package in which its class is neither defined nor extended.' ]
%

category: 'accessing'
method: RwGsMethodPatch
methodDefinition
	^methodDefinition
%

category: 'accessing'
method: RwGsMethodPatch
methodDefinition: newValue
	methodDefinition := newValue
%

category: 'compiling'
method: RwGsMethodPatch
methodEnvironmentId

	"use the project load spec package properties"

	^ self projectDefinition methodEnvForPackageNamed: self packageName
%

category: 'private-installing'
method: RwGsMethodPatch
packageProtocolName

	"If I'm for an extension method, my protocol in the image may need to be *<packageName>*."

	^ '*' , self packageName
%

category: 'private'
method: RwGsMethodPatch
primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols

	| className class |
	classDefinition key
		ifNil: [ 
			"class is being deleted ... we're done"
			^ self ].
	className := classDefinition key asSymbol.
	class := createdClasses
		at: className
		ifAbsent: [ 
			tempSymbols
				at: className
				ifAbsent: [ 
					"cannot find class ... caller can decide whether or not that is a problem"
					^ self ] ].
	behavior := isMeta
		ifTrue: [ class class ]
		ifFalse: [ class ]
%

category: 'printing'
method: RwGsMethodPatch
printOn: aStream

	super printOn: aStream.
	aStream
		nextPutAll: ' for ';
		nextPutAll: self className asString.
	isMeta
		ifTrue: [ aStream nextPutAll: ' class' ].
	aStream
		nextPutAll: '>>';
		nextPutAll: methodDefinition key asString
%

category: 'private-installing'
method: RwGsMethodPatch
propertiesProtocolName

	^methodDefinition propertyAt: 'protocol' ifAbsent: ['unknown']
%

category: 'initializers'
method: RwGsMethodPatch
runInitializer

	"execute class initialization methods"

	self isAnInitializer
		ifTrue: [ behavior thisClass initialize ]
%

category: 'accessing'
method: RwGsMethodPatch
selector

	^ selector
%

category: 'private-installing'
method: RwGsMethodPatch
setProtocolTo: protocolString

	| protocolSymbol |
	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [behavior addCategory: protocolSymbol].
	behavior moveMethod: selector toCategory: protocolSymbol
%

! Class implementation for 'RwGsMethodAdditionSymbolDictPatch'

!		Instance methods for 'RwGsMethodAdditionSymbolDictPatch'

category: 'installing'
method: RwGsMethodAdditionSymbolDictPatch
installMethod

	self symbolDictionaryRegistry
		addNewCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

category: 'installing'
method: RwGsMethodAdditionSymbolDictPatch
installMovedMethod: aClassMove newClassVersionPatch: newClassVersionPatch
	"the receiver represents an existing method for a class with a new version that has moved to a new package"

	"the old method in the old class version must be removed from the loaded things in the new registry, since it was moved earlier, 
		then the regular installMethod should be performed --- new version requires that all methods be compiled"

	"https://github.com/dalehenrich/Rowan/issues/316"

	| oldClassVersion oldBehavior theRegistry |
	theRegistry := (self symbolDictionaryFor: aClassMove packageAfter name projectDefinition: aClassMove projectAfter)
		rowanSymbolDictionaryRegistry.

	oldClassVersion := newClassVersionPatch oldClassVersion.
	oldClassVersion ~~ newClassVersionPatch newClassVersion
		ifTrue: [ 
			"only do this work if we truly have a new class version"
			oldBehavior := self isMeta
				ifTrue: [ oldClassVersion class ]
				ifFalse: [ oldClassVersion ].
			(oldBehavior compiledMethodAt: self methodDefinition selector otherwise: nil)
				ifNotNil: [ :oldCompiledMethod |
					"new methods will not be in the old method dictionary"
					(theRegistry methodRegistry
						at: oldCompiledMethod
						ifAbsent: [])
							ifNil: [
								theRegistry
									error:
										'Internal error -- no existing LoadedMethod found for deleted method.' ]
							ifNotNil: [ :oldLoadedMethod | theRegistry methodRegistry removeKey: oldCompiledMethod ] ] ].

	theRegistry
		addNewCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: aClassMove packageAfter name
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodDeletionSymbolDictPatch'

!		Instance methods for 'RwGsMethodDeletionSymbolDictPatch'

category: 'deleting'
method: RwGsMethodDeletionSymbolDictPatch
deleteMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class is being deleted, nothing else to do"
			^ self ].

	self symbolDictionaryRegistry
		deleteMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionSymbolDictPatch
deleteMovedLoadedMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class is being deleted, nothing else to do"
			^ self ].

	self symbolDictionaryRegistry
		deleteMovedLoadedMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionSymbolDictPatch
deleteMovedMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class is being deleted, nothing else to do"
			^ self ].

	self symbolDictionaryRegistry
		deleteMovedMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionSymbolDictPatch
deleteNewVersionMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	"remove the method from deleted things"

	self symbolDictionaryRegistry
		_doDeleteCompiledMethodFromLoadedThings: self compiledMethod
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'initializers'
method: RwGsMethodDeletionSymbolDictPatch
isAnInitializer

	"answer true if I represent a class initialization method"

	^ false
%

category: 'initializers'
method: RwGsMethodDeletionSymbolDictPatch
runInitializer
	"noop"
%

category: 'accessing'
method: RwGsMethodDeletionSymbolDictPatch
symbolDictionary
	"For deleting methods, we have to find the symbol dictionary where the loaded method is currently stored ... "

	^ Rowan image 
			loadedMethodAndSymbolDicitonaryForMethod: self compiledMethod 
			ifPresent: [ :symbolDict :loadedMethod | ^ symbolDict ]
			ifAbsent: [ ^ super symbolDictionary ]
%

! Class implementation for 'RwGsMethodDeletionExtensionSymbolDictPatch'

!		Instance methods for 'RwGsMethodDeletionExtensionSymbolDictPatch'

category: 'accessing'
method: RwGsMethodDeletionExtensionSymbolDictPatch
className

	^ self extendedClassName
%

category: 'accessing'
method: RwGsMethodDeletionExtensionSymbolDictPatch
extendedClassName

   ^extendedClassName
%

category: 'accessing'
method: RwGsMethodDeletionExtensionSymbolDictPatch
extendedClassName: anObject

	extendedClassName := anObject
%

category: 'private'
method: RwGsMethodDeletionExtensionSymbolDictPatch
primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols

	| className class |
	className := extendedClassName asSymbol.
	class := createdClasses
		at: className
		ifAbsent: [ 
			tempSymbols
				at: className
				ifAbsent: [ 
					"class is being deleted ... we're done"
					^ self] ].
	behavior := isMeta
		ifTrue: [ class class ]
		ifFalse: [ class ]
%

! Class implementation for 'RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch'

!		Instance methods for 'RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch'

category: 'accessing'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
compiledMethod

	^ compiledMethod
		ifNil: [ 
			| dictsArray mDict |
			dictsArray := self symbolDictionaryRegistry homeSessionMethods
				methodAndCategoryDictionaryFor: behavior.
			mDict := dictsArray at: 1.
			selector := methodDefinition selector.
			compiledMethod := mDict
				at: selector
				ifAbsent: [ 
					self
						error:
							'internal error - compiled session method not present in method dictionary' ] ]
%

category: 'deleting'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
deleteMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class cannot be found, so the method is already gone"
			^ self ].

	self symbolDictionaryRegistry
		deleteMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
deleteMovedLoadedMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class cannot be found, so the method is already gone"
			^ self ].

	self symbolDictionaryRegistry
		deleteMovedLoadedMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
deleteMovedMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ 
			"class cannot be found, so the method is already gone"
			^ self ].

	self symbolDictionaryRegistry
		deleteMovedMethod: methodDefinition selector
		for: behavior
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'deleting'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
deleteNewVersionMethodNewClasses: createdClasses andExistingClasses: tempSymbols

	"noop for class extension methods"
%

category: 'accessing'
method: RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch
symbolDictionary

	^self symbolDictionaryFor: self packageName
%

! Class implementation for 'RwGsMethodExtensionSymbolDictPatch'

!		Instance methods for 'RwGsMethodExtensionSymbolDictPatch'

category: 'installing'
method: RwGsMethodExtensionSymbolDictPatch
installMethod

	self symbolDictionaryRegistry
		addExtensionCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: self packageName
		 implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

category: 'installing'
method: RwGsMethodExtensionSymbolDictPatch
installMovedMethod: aMethodMove newClassVersionPatch: newClassVersionPatch
	"the receiver represents an existing method for a class with a new version that has moved to a new package"

	"the old method in the old class version must be removed from the loaded things in the new registry, since it was moved earlier, 
		then the regular installMethod should be performed --- new version requires that all methods be compiled"

	"https://github.com/dalehenrich/Rowan/issues/316"

	| oldClassVersion oldBehavior theRegistry |
	theRegistry := (self symbolDictionaryFor: aMethodMove packageAfter name projectDefinition: aMethodMove projectAfter)
		rowanSymbolDictionaryRegistry.
	oldClassVersion := newClassVersionPatch oldClassVersion.
	oldClassVersion ~~ newClassVersionPatch newClassVersion
		ifTrue: [ 
			"only do this work if we truly have a new class version"
			oldBehavior := self isMeta
				ifTrue: [ oldClassVersion class ]
				ifFalse: [ oldClassVersion ].
			(oldBehavior compiledMethodAt: self methodDefinition selector otherwise: nil)
				ifNotNil: [ :oldCompiledMethod |
					"new methods will not be in the old method dictionary"
					(theRegistry methodRegistry
						at: oldCompiledMethod
						ifAbsent: [])
							ifNil: [
								theRegistry
									error:
										'Internal error -- no existing LoadedMethod found for deleted method.' ]
							ifNotNil: [ :oldLoadedMethod | theRegistry methodRegistry removeKey: oldCompiledMethod ] ] ].

	theRegistry
		addExtensionCompiledMethod: compiledMethod
		for: behavior
		protocol: self propertiesProtocolName
		toPackageNamed: aMethodMove packageAfter name
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodExtensionSessionMethodSymbolDictPatch'

!		Instance methods for 'RwGsMethodExtensionSessionMethodSymbolDictPatch'

category: 'compiling'
method: RwGsMethodExtensionSessionMethodSymbolDictPatch
compileUsingNewClasses: createdClasses andExistingClasses: tempSymbols

	| sourceString symbolList protocol |
	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ self error: 'Class ' , self className printString , ' not found.' ].

	sourceString := methodDefinition source.
	symbolList := SymbolList with: tempSymbols.
	protocol := (methodDefinition propertyAt: 'protocol') asSymbol.

	methDict := GsMethodDictionary new.
	catDict := GsMethodDictionary new.
	compiledMethod := behavior
		compileMethod: sourceString
		dictionaries: symbolList
		category: protocol
		intoMethodDict: methDict
		intoCategories: catDict
		intoPragmas: pArray
		environmentId: self methodEnvironmentId
%

category: 'installing'
method: RwGsMethodExtensionSessionMethodSymbolDictPatch
installMethod

	"expecting only a single method to be compiled here"

	compiledMethod := self symbolDictionaryRegistry
		addExtensionSessionMethods: methDict
		catDict: catDict
		for: behavior
		toPackageNamed: self packageName
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation.

	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodPropertiesSymDictPatch'

!		Instance methods for 'RwGsMethodPropertiesSymDictPatch'

category: 'installing'
method: RwGsMethodPropertiesSymDictPatch
installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols

	" update method protocol and update loadedMethod with new compiled method"

	| methodDictionary oldCompiledMethod |
	self primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols.
	behavior
		ifNil: [ self error: 'Class ' , self className printString , ' not found.' ].

	methodDictionary := behavior persistentMethodDictForEnv: 0.
	selector := methodDefinition selector.
	oldCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			self
				error:
					'Internal error -- no existing CompileMethod found for patched method.' ].

	self symbolDictionaryRegistry
		moveCompiledMethod: oldCompiledMethod
		toProtocol: self propertiesProtocolName
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation
%

category: 'initializers'
method: RwGsMethodPropertiesSymDictPatch
isAnInitializer

	"answer true if I represent a class initialization method"

	^ false
%

category: 'initializers'
method: RwGsMethodPropertiesSymDictPatch
runInitializer
	"noop"
%

! Class implementation for 'RwGsMethodExtensionSessionMethodPropertiesSymDictPatch'

!		Instance methods for 'RwGsMethodExtensionSessionMethodPropertiesSymDictPatch'

category: 'installing'
method: RwGsMethodExtensionSessionMethodPropertiesSymDictPatch
installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols

	^ super installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols
%

! Class implementation for 'RwGsMethodSourceSymbolDictPatch'

!		Instance methods for 'RwGsMethodSourceSymbolDictPatch'

category: 'installing'
method: RwGsMethodSourceSymbolDictPatch
installSourcePatch

	" update methodDictionary and update loadedMethod with new compiled method"

	self symbolDictionaryRegistry addRecompiledMethod: compiledMethod implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsMethodExtensionSessionMethodSourceSymbolDictPatch'

!		Instance methods for 'RwGsMethodExtensionSessionMethodSourceSymbolDictPatch'

category: 'installing'
method: RwGsMethodExtensionSessionMethodSourceSymbolDictPatch
installSourcePatch

	" update methodDictionary and update loadedMethod with new compiled method"

	self symbolDictionaryRegistry addRecompiledSessionMethodMethod: compiledMethod implementationClass: RwGsSymbolDictionaryRegistry_Implementation.
	selector := compiledMethod selector
%

! Class implementation for 'RwGsPackagePatch'

!		Class methods for 'RwGsPackagePatch'

category: 'instance creation'
classmethod: RwGsPackagePatch
for: aPackageDefinition

	^self new packageDefinition: aPackageDefinition
%

! Class implementation for 'RwGsPackageAdditionSymbolDictPatch'

!		Instance methods for 'RwGsPackageAdditionSymbolDictPatch'

category: 'applying'
method: RwGsPackageAdditionSymbolDictPatch
createLoadedPackage

	| loadedPackage loadedProject |
	loadedPackage := self symbolDictionaryRegistry
		createLoadedPackageFromDefinition: self packageDefinition
		implementationClass: RwGsSymbolDictionaryRegistry_Implementation.

	projectDefinition ifNil: [ ^ self ].

	loadedProject := Rowan image
		loadedProjectNamed: projectDefinition name
		ifAbsent: [ 
			self
				error:
					'expected a loaded project named ' , projectDefinition name printString ].

	loadedProject addLoadedPackage: loadedPackage
%

! Class implementation for 'RwGsPackageDeletionSymbolDictPatch'

!		Instance methods for 'RwGsPackageDeletionSymbolDictPatch'

category: 'deleting'
method: RwGsPackageDeletionSymbolDictPatch
deletePackage

	(Rowan image loadedRegistryForPackageNamed: packageDefinition name)
		deletePackage: packageDefinition name
%

! Class implementation for 'RwGsPackageMoveSymbolDictPatch'

!		Instance methods for 'RwGsPackageMoveSymbolDictPatch'

category: 'moving'
method: RwGsPackageMoveSymbolDictPatch
movePackage

	"Loader already makes sure that the package is created properly, but we do have to make sure that the old package is deleted from it's original location"

	(Rowan image loadedRegistryForPackageNamed: packageDefinition name)
		movePackage: packageDefinition name to: packageDefinition gs_symbolDictionary
%

! Class implementation for 'RwGsProjectPatch'

!		Class methods for 'RwGsProjectPatch'

category: 'instance creation'
classmethod: RwGsProjectPatch
for: aProjectDefinition

	^self new projectDefinition: aProjectDefinition
%

!		Instance methods for 'RwGsProjectPatch'

category: 'applying'
method: RwGsProjectPatch
updateProjectProperties

	| loadedProject |
	loadedProject := Rowan image
		loadedProjectNamed: self projectName
		ifAbsent: [ self error: 'Internal error. Attempt to update unregistered project.' ].
	loadedProject setPropertiesTo: self projectDefinition properties
%

! Class implementation for 'RwGsProjectAdditionPatch'

!		Instance methods for 'RwGsProjectAdditionPatch'

category: 'applying'
method: RwGsProjectAdditionPatch
createLoadedProject

	| projectName existingLoadedProject newLoadedProject |
	projectName := self projectName.
	existingLoadedProject := Rowan image
		loadedProjectNamed: projectName
		ifAbsent: [ nil ].
	existingLoadedProject
		ifNotNil: [ self error: 'Internal error -- Attempt to add a project that exists.' ].
	newLoadedProject := RwGsLoadedSymbolDictProject
		newForLoadSpecification: projectDefinition specification.
	Rowan image addLoadedProject: newLoadedProject.
	self updateProjectProperties
%

category: 'applying'
method: RwGsProjectAdditionPatch
updateProjectProperties

	"noop - properties updated during createLoadedProject"

	
%

! Class implementation for 'RwGsPatchSet'

!		Class methods for 'RwGsPatchSet'

category: 'private - method initialization order'
classmethod: RwGsPatchSet
methodPatchesInInitializationOrder: methodPatches

	"Returns acollection of the specified methodPatches ordered in superclass order, which is sufficient for initialization order."

	| order toBeOrdered processed aClass patchMap |
	patchMap := IdentityKeyValueDictionary new.
	methodPatches do: [:methodPatch |
		patchMap at: methodPatch behavior thisClass put: methodPatch ].
	toBeOrdered := patchMap keys asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[ (aClass := self _anyElementOf: toBeOrdered ifEmpty: [ nil ]) isNil ]
		whileFalse: [ 
			self
				_orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed ].
  ^ (order collect: [:orderedClass | patchMap at: orderedClass ifAbsent: []]) select: [:patch | patch notNil ]
%

category: 'instance creation'
classmethod: RwGsPatchSet
new

	^super new initialize
%

category: 'private - method initialization order'
classmethod: RwGsPatchSet
_anyElementOf: aCollection ifEmpty: aBlock
	aCollection do: [ :each | ^ each ].
	^ aBlock value
%

category: 'private - method initialization order'
classmethod: RwGsPatchSet
_orderBySuperclass: aClass from: toBeOrdered into: order ignoring: processed
  "Private. Add to 'order', superclasses first, aClass and any of its superclasses 
	that appear in 'toBeOrdered' but do not appear in 'processed'.
	Remove from 'toBeOrdered' any class added to 'ordered'.
	Any class seen, add to 'processed' whether or not added to 'order'."

  | superclass |
  superclass := aClass superclass.
  superclass isNil | (processed includes: superclass)
    ifFalse: [ 
      self
        _orderBySuperclass: superclass
        from: toBeOrdered
        into: order
        ignoring: processed ].
  processed add: aClass.
  (toBeOrdered includes: aClass)
    ifTrue: [ 
      toBeOrdered remove: aClass.
      order add: aClass ]
%

!		Instance methods for 'RwGsPatchSet'

category: 'building'
method: RwGsPatchSet
addAddedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedClasses
		add:
			((self _classAdditionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'private - applying'
method: RwGsPatchSet
addAddedClassesToTempSymbols
	"Just need the names for now, they don't need to resolve to anything in particular."

	addedClasses do: [:patch | 
		(movedClassesMap includesKey: patch className)
			ifFalse: [
				| key |
				key :=  patch className asSymbol.
				(tempSymbols includesKey: key) ifTrue: [ self error: 'Encountered an existing association for a new class ', key asString ].
				tempSymbols at: key put: nil ] ].
%

category: 'building'
method: RwGsPatchSet
addAddedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedMethods
		add:
			((self _methodAdditionPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addAddedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedMethods
		add:
			((self _methodAdditionPatchClass
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addAddedPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedPackages
		add:
			((self _packageAdditionPatchClass for: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addAddedProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedProjects
		add: (self _projectAdditionPatchClass for: aProjectDefinition) yourself
%

category: 'private - applying'
method: RwGsPatchSet
addAndUpdateLoadedPackages
	"Update the LoadedPackages to reflect the results of this patchSet. Does not update the other loadedThings."

	addedPackages
		do: [:packageAdditionPatch | packageAdditionPatch createLoadedPackage]
%

category: 'private - applying'
method: RwGsPatchSet
addAndUpdateLoadedProjects

	"Update the LoadedProjects to reflect the results of this patchSet. Does not update the other loadedThings."

	addedProjects
		do: [ :projectAdditionPatch | projectAdditionPatch createLoadedProject ].
	projectsWithPropertyChanges do: [ :patch | patch updateLoadedProject ]
%

category: 'modification dispatching'
method: RwGsPatchSet
addClassModification: aRwClassModification toPatchSetInPackage: aPackage inProject: aProjectDefinition

	"Double dispatch from aRwClassModification ... needed to isolate the loader methods from meaningful changes 
		while updating the loader using the loader"

	aRwClassModification isAddition
		ifTrue: [ 
			self
				addAddedClass: aRwClassModification after
				inPackage: aPackage
				inProject: aProjectDefinition ].
	aRwClassModification isDeletion
		ifTrue: [ 
			self
				addDeletedClass: aRwClassModification before
				inPackage: aPackage
				inProject: aProjectDefinition ].
	aRwClassModification isModification
		ifTrue: [ 
			RwGsClassVersioningPatch
				addPatchedClassModification: aRwClassModification
				inPackage: aPackage
				inProject: aProjectDefinition
				toPatchSet: self ]
%

category: 'private - applying'
method: RwGsPatchSet
addCreatedClassesAndVersionsTo: newClassesByName

	addedClasses do: [ :patch | 
		(movedClassesMap includesKey: patch className)
			ifFalse: [ patch addToNewClassesByName: newClassesByName ] ].
	classesWithClassVariableChanges
		do: [ :each | each addToNewClassesByName: newClassesByName ].
	classesWithNewVersions
		do: [ :each | each addToNewClassesByName: newClassesByName ]
%

category: 'building'
method: RwGsPatchSet
addDeletedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedClasses
		add:
			((self _classDeletionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addDeletedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			((self _methodDeletionPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addDeletedExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition named: className inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			(((self _methodExtensionDeletionPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				extendedClassName: className;
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addDeletedExtendedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition named: className inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			(((self _methodExtensionDeletionPatchClass: aPackageDefinition key)
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				extendedClassName: className;
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addDeletedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			((self _methodDeletionPatchClass
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addDeletedPackage: packageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedPackages
		add:
			((self _packageDeletionPatchClass for: packageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addExtendedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedClasses
		add:
			((self _classExtensionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedMethods
		add:
			(((self _methodExtensionPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addExtendedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedMethods
		add:
			(((self _methodExtensionPatchClass: aPackageDefinition key)
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'modification dispatching'
method: RwGsPatchSet
addForcingNewClassVersionModification: aRwClassModificationForcingNewClassVersion toPatchSetInPackage: aPackage inProject: aProjectDefinition

	"Double dispatch from aRwClassModificationForcingNewClassVersion ... needed to isolate the loader methods from meaningful changes 
		while updating the loader using the loader"

	aRwClassModificationForcingNewClassVersion isAddition
		ifTrue: [ self error: 'unexpected addition for modification forcing new class version' ].
	aRwClassModificationForcingNewClassVersion isDeletion
		ifTrue: [ self error: 'unexpected deletion for modification forcing new class version' ].
	aRwClassModificationForcingNewClassVersion isModification
		ifTrue: [ 
			RwGsClassVersioningPatch
				addPatchedClassModificationForcingNewClassVersion: aRwClassModificationForcingNewClassVersion
				inPackage: aPackage
				inProject: aProjectDefinition
				toPatchSet: self ]
%

category: 'building'
method: RwGsPatchSet
addPatchedClassClassVariables: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithClassVariableChanges
		add:
			((self _classVariablePatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			((self _methodSourcePatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedClassMethodProperties: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			((self _methodPropertiesPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedClassNewVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.

	classesWithNewVersions
		add:
			((self _classVersioningPatchClass
				for: aClassModification
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedClassProperties: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithPropertyChanges
		add:
			((self _classPropertiesPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedClassSymbolDictionaryMove: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithSymbolDictionaryChanges
		add:
			((self _classSymbolDictionaryMovePatchClass
				for: aClassModification
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			(((self _methodExtensionSourcePatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedExtendedClassMethodProperties: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			(((self _methodExtensionPropertiesPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedExtendedInstanceMethod: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			(((self _methodExtensionSourcePatchClass: aPackageDefinition key)
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedExtendedInstanceMethodProperties: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			(((self _methodExtensionPropertiesPatchClass: aPackageDefinition key)
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedInstanceMethod: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			((self _methodSourcePatchClass
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet
addPatchedInstanceMethodProperties: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			((self _methodPropertiesPatchClass
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'private - applying'
method: RwGsPatchSet
allPatchesAffectingLiveMethodsDo: liveMethodsBlock deletedMethodsDo: deletedMethodsBlock

	"Evaluate aBlock with every patch that can affect a method, traverse deletions separately."

	{addedMethods.
	extendedMethods.
	methodsNeedingRecompile} do: [ :patches | patches do: liveMethodsBlock ].
	deletedMethods do: deletedMethodsBlock
%

category: 'private - applying'
method: RwGsPatchSet
anyElementOfCollection: aCollection
	"if aCollection is empty, answer nil. Otherwise, answer the first in enumeration order (which is unspecified for unordered collections)."

	aCollection do: [:each | ^each].
	^nil
%

category: 'public'
method: RwGsPatchSet
apply

	"Apply the changes I represent to the running image."
false ifTrue: [ self halt].
	self
		setupForApply;
		removeDeletedClassesFromTempSymbols;
		addAddedClassesToTempSymbols;
		recordCompiledForNewClassVersionDeletions;
		createNewClassesAndClassVersions;
		moveMethodsBetweenPackages;
		compileMethods.
	self reportAnyErrors
		ifTrue: [ ^ self ].	"No errors -- go ahead and install what's been compiled."
	self
		addAndUpdateLoadedProjects;
		addAndUpdateLoadedPackages;
		removeDeletedClassesFromSystem;
		"removeDeletedClassExtensionsFromSystem;" 
		installAddedClasses;
		installAddedClassExtensions;
		doMoveClassesBetweenPackages;
		moveClassesBetweenSymbolDictionaries;
		updateSymbolAssociations;
		updateClassProperties;
		deleteMovedLoadedExtensionMethods;
		removeDeletedMethods;
		updateMethodDictionaries;
		updateMethodProperties;
		"removeDeletedClassesAndExtensionsFromPackages;"
		removeDeletedPackages;
		commit;
		runInitializers;
		commit;
		migrateInstances;
		commit
%

category: 'public'
method: RwGsPatchSet
applyForNewClassVersions: anInstanceMigrator

	"ignore deleted methods when applying patches to new class version.
		all methods effectively deleted from class when the new class version is created, "

	| classNames |
	instanceMigrator := anInstanceMigrator.
	classNames := Set new.
	classesWithNewVersions
		do: [ :patch | classNames add: patch classDefinition key ].
	deletedMethods copy
		do: [ :patch | 
			(classNames includes: patch className)
				ifTrue: [ 
					deleteNewVersionMethods add: patch.
					deletedMethods remove: patch ] ].
	self apply
%

category: 'accessing'
method: RwGsPatchSet
classesWithNewVersions

	^ classesWithNewVersions
%

category: 'private - applying'
method: RwGsPatchSet
commit
	"I don't think I like the idea that we commit during a load ... the developer should always be in control of
		when a commit is performed ... automatic instance migration does do commits, however, it is a developer
		choice to do the commits ... if an error occurs after a commit is performed, I am concerned that the loaded 
		state of system will be corrupted ... "

	false ifTrue: [ System commit ]
%

category: 'private - applying'
method: RwGsPatchSet
compileMethodPatch: aMethodAdditionPatch

	aMethodAdditionPatch compileUsingNewClasses: createdClasses
		andExistingClasses: tempSymbols
%

category: 'private - applying'
method: RwGsPatchSet
compileMethods

	addedMethods do: [:each | self compileMethodPatch: each].
	extendedMethods do: [:each | self compileMethodPatch: each].
	methodsNeedingRecompile do: [:each | self compileMethodPatch: each]
%

category: 'private - applying'
method: RwGsPatchSet
createClassesFromWorklist: workList andClassesByName: newClassesByName
	"Pick one class or class version from the workList and create it, creating any superclasses or superclass versions that are to be created.
	Remove any classes created from the workList."

	| className |
	className := self anyElementOfCollection: workList.
	className ifNil: [self error: 'Empty WorkList.'].
	self
		createClassNamed: className
		fromWorkList: workList
		andClassesByName: newClassesByName
%

category: 'private - applying'
method: RwGsPatchSet
createClassNamed: className fromWorkList: workList andClassesByName: newClassesByName
	"Create the named class from the workList, creating any superclasses or superclass versions that are to be created.
	Remove any classes created from the workList."

	| patch superclassName |
	workList remove: className.
	patch := newClassesByName at: className.
	superclassName := patch superclassName.
	(workList includes: superclassName)
		ifTrue: 
			[self
				createClassNamed: superclassName
				fromWorkList: workList
				andClassesByName: newClassesByName].
	patch createClassFor: self
%

category: 'patch access'
method: RwGsPatchSet
createdClass: aClass

	| className |
	className := aClass name.
	(createdClasses at: className ifAbsent: [ ])
		ifNil: [ 
			createdClasses
				add: (SymbolAssociation newWithKey: className value: aClass) ]
		ifNotNil: [:cl | 
			cl == aClass
				ifFalse: [ 
					"new version created, update entry in createdClasses"
					createdClasses at: className put: aClass ] ]
%

category: 'accessing'
method: RwGsPatchSet
createdClasses
	^ createdClasses
%

category: 'private - applying'
method: RwGsPatchSet
createNewClassesAndClassVersions

	"Who: Added classes and classes with new versions and classes with class variable changes
	   How: Create the new class or class version. Superclass by identity, not name resolution.
	   Order: Superclasses first.
	   Errors: Collect for reporting later"

	| newClassesByName workList |
	newClassesByName := Dictionary new.
	self addCreatedClassesAndVersionsTo: newClassesByName.
	workList := Set withAll: newClassesByName keys.
	[ workList isEmpty ]
		whileFalse: [ self createClassesFromWorklist: workList andClassesByName: newClassesByName ]
%

category: 'private - applying'
method: RwGsPatchSet
deleteMovedLoadedExtensionMethods

	deletedExtensionMethods
		do: [:methodDeletionPatch | methodDeletionPatch deleteMovedLoadedMethodNewClasses: createdClasses andExistingClasses: tempSymbols ]
%

category: 'private - applying'
method: RwGsPatchSet
doMoveClassesBetweenPackages

	self doMoveClassesBetweenPackages: (movedClassesMap values collect: [:ar | ar at: 1])
%

category: 'private - applying'
method: RwGsPatchSet
doMoveClassesBetweenPackages: patches

	| image |
	image := Rowan image.
	patches 
		do: [:patch |
			| loadedClass |
				loadedClass := image loadedClassNamed: patch classDefinition name.
				loadedClass loadedPackage removeLoadedClass: loadedClass.
				(image loadedPackageNamed: patch packageDefinition name)
					addLoadedClass: loadedClass ].
%

category: 'initialization'
method: RwGsPatchSet
initialize

	addedPackages := Set new.
	addedProjects := Set new.
	deletedPackages := Set new.
	projectsWithPropertyChanges := Set new.
	deletedClasses := Set new.
	addedClasses := Set new.
	extendedClasses := Set new.
	classesWithNewVersions := Set new.
	classesWithClassVariableChanges := Set new.
	classesWithPropertyChanges := Set new.
	classesWithSymbolDictionaryChanges := Set new.
	movedClassesMap := Dictionary new.
	deletedMethods := Set new.
	deletedExtensionMethods := Set new.
	deleteNewVersionMethods := Set new.
	movedMethodsMap := Dictionary new.
	addedMethods := Set new.
	extendedMethods := Set new.
	methodsNeedingRecompile := Set new.
	methodsWithPropertyChanges := Set new.
	pureMovedMethods := Set new.
	tempSymbols := SymbolDictionary new.
	createdClasses := Dictionary new.
	errors := Set new
%

category: 'private - applying'
method: RwGsPatchSet
installAddedClasses
	"Copy the name association from TempSymbols to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	addedClasses do: [:patch | 
		(movedClassesMap includesKey: patch className)
			ifFalse: [ patch installClassInSystem ] ]
%

category: 'private - applying'
method: RwGsPatchSet
installAddedClassExtensions

	extendedClasses do: [ :each | each installClassExtensionInSystem ]
%

category: 'accessing'
method: RwGsPatchSet
instanceMigrator

	^ instanceMigrator
%

category: 'private - applying'
method: RwGsPatchSet
migrateInstances

	"conditionally migrate instances of classes with new versions"

	| classSet |
	classSet := classesWithNewVersions collect: [ :patch | patch oldClassVersion ].
	classSet isEmpty
		ifTrue: [ ^ self ].
	instanceMigrator
		ifNil: [ 
			"if instanceMigrator is not set, then we are not ready to do instance migration on this pass"
			^ self ].
	instanceMigrator migrateInstancesOf: classSet asArray
%

category: 'private - applying'
method: RwGsPatchSet
moveClassesBetweenPackages

	| image |
	deletedClassesMap := Dictionary new.
	deletedClasses isEmpty
		ifTrue: [ 
			"no move without deleted classes"
			^ self ].
	deletedClasses
		do: [ :patch | 
			patch classDefinition key
				ifNotNil: [ deletedClassesMap at: patch classDefinition key put: patch ] ].

	image := Rowan image.
	addedClasses copy
		do: [ :addedClassPatch | 
			(deletedClassesMap at: addedClassPatch classDefinition key ifAbsent: [ ])
				ifNotNil: [ :deletedClassPatch | 
					| modification |
					movedClassesMap at: addedClassPatch className put: {addedClassPatch. deletedClassPatch}.
					modification := addedClassPatch classDefinition
						compareAgainstBase: deletedClassPatch classDefinition.
					modification isEmpty
						ifFalse: [ 
							"we must modify the modifications here, similar to what goes on when we deal with new class versions"
							modification
								addModificationToPatchSet: self
								inPackage: addedClassPatch packageDefinition
								inProject: addedClassPatch projectDefinition ] ] ]
%

category: 'private - applying'
method: RwGsPatchSet
moveClassesBetweenSymbolDictionaries

	classesWithSymbolDictionaryChanges do: [:each | each installSymbolDictionaryPatchFor: self ].
%

category: 'private - applying'
method: RwGsPatchSet
moveClassesWithNewVersionsBetweenPackages

	self doMoveClassesBetweenPackages: classesWithNewVersions.
	self moveClassesBetweenPackages.
%

category: 'accessing'
method: RwGsPatchSet
movedClassesMap
	^ movedClassesMap
%

category: 'private - applying'
method: RwGsPatchSet
moveMethodsBetweenPackages

	| deletedMethodsMap symDictClassMoves |
	deletedMethods isEmpty
		ifTrue: [ 
			"no move without deleted methods"
			^ self ].
	deletedMethodsMap := Dictionary new.
	(deletedMethods copy
		addAll: deleteNewVersionMethods;
		yourself)
		do: [ :patch | 
			| className |
			className := patch classDefinition key.
			(className isNil 
				or: [ (movedClassesMap includesKey: className) not and: [ deletedClassesMap includesKey:className ] ])
				ifFalse: [ 
					((deletedMethodsMap at: className ifAbsentPut: [ Dictionary new ]) 
						at: patch isMeta ifAbsentPut: [Dictionary new ])
							at: patch methodDefinition key put: patch ] ].
	symDictClassMoves := classesWithSymbolDictionaryChanges collect: [:each | each classDefinition name].
	(addedMethods copy
		addAll: extendedMethods;
		yourself)
		do: [ :methodAdditionPatch | 
					(deletedMethodsMap at: methodAdditionPatch className ifAbsent: [  ])
						ifNotNil: [ :isMetaMap |
							(isMetaMap at: methodAdditionPatch isMeta ifAbsent: [])
								ifNotNil: [:selectorMap | 
									(selectorMap at: methodAdditionPatch methodDefinition selector ifAbsent: [])
										ifNotNil: [ :methodDeletionPatch | 
											| methodMod |
											(symDictClassMoves includes: methodAdditionPatch className)
												ifFalse: [ 
													"If a class is moved to a package that is in the SAME symbol dictionary, we can afford to make certain optimizations
														and avoid excessive method churn, by skipping the step of deleting/installing methods from/to the class that is moved,
														since the classes are already present in the class method dictionary ... we do have to update the loaded packages 
														structure.

														deletedExtensionMethods, movedMethodsMap and pureMoveMethods are used to make sure that the loaded things
															are properly updated, and that the appropriate steps are skipped in a safe manner."
													(extendedMethods includes: methodAdditionPatch)
														ifTrue: [ deletedExtensionMethods add: methodDeletionPatch ].
													deletedMethods remove: methodDeletionPatch ifAbsent: [].
													((movedMethodsMap at: methodAdditionPatch className ifAbsentPut: [ Dictionary new ])
														at: methodAdditionPatch isMeta ifAbsentPut: [Dictionary new ])
															at: methodAdditionPatch methodDefinition selector put: {methodAdditionPatch. methodDeletionPatch}.
													methodMod := methodAdditionPatch methodDefinition compareAgainstBase: methodDeletionPatch methodDefinition.
													methodMod isEmpty
														ifFalse: [
															methodMod propertiesModification isEmpty
																ifFalse: [									 
																	methodAdditionPatch isMeta
																		ifTrue: [ 
																			self
																				addPatchedClassMethodProperties: methodMod after
																				inClass: methodAdditionPatch classDefinition
																				inPackage: methodAdditionPatch packageDefinition
																				inProject: methodAdditionPatch projectDefinition ]
																		ifFalse: [ 
																			self
																				addPatchedInstanceMethodProperties: methodMod after
																				inClass: methodAdditionPatch classDefinition
																				inPackage: methodAdditionPatch packageDefinition
																				inProject: methodAdditionPatch projectDefinition ] ] ].
													(methodMod isEmpty or: [ methodMod sourceModification isEmpty ])
														ifTrue: [ 
															"the source is identical ... so it is a pure move of the method ... record this fact
																for operations that care. "
															pureMovedMethods add: methodAdditionPatch ] ] ] ] ] ]
%

category: 'private - applying'
method: RwGsPatchSet
recordCompiledForNewClassVersionDeletions

	deleteNewVersionMethods
		do: [ :each | each primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols ]
%

category: 'private - applying'
method: RwGsPatchSet
removeDeletedClassesFromSystem
	"Remove the name binding from the SymbolDictionaries in the live SymbolList
        Remove the LoadedClass from its LoadedPackage"

	deletedClasses do: [:patch | 
		(movedClassesMap includesKey: patch className)
			ifFalse: [ patch deleteClassFromSystem ] ]
%

category: 'private - applying'
method: RwGsPatchSet
removeDeletedClassesFromTempSymbols
	"Deleted class names should not resolve during compilation."

	deletedClasses do: [:patch | 
		(movedClassesMap includesKey: patch className)
			ifFalse: [ tempSymbols removeKey: patch className asSymbol ] ]
%

category: 'private - applying'
method: RwGsPatchSet
removeDeletedMethods

	deletedMethods
		do: [ :methodDeletionPatch | 
			| className |
			className := methodDeletionPatch className.
			(movedClassesMap includesKey: className)
				ifTrue: [ methodDeletionPatch deleteMovedMethodNewClasses: createdClasses andExistingClasses: tempSymbols ]
				ifFalse: [ 
					(deletedClassesMap includesKey: className)
						ifFalse: [methodDeletionPatch deleteMethodNewClasses: createdClasses andExistingClasses: tempSymbols ] ] ].
	deleteNewVersionMethods
		do: [ :methodDeletionPatch | 
			(movedClassesMap includesKey: methodDeletionPatch className)
				ifFalse: [ 
					methodDeletionPatch
						deleteNewVersionMethodNewClasses: createdClasses
						andExistingClasses: tempSymbols ] ]
%

category: 'private - applying'
method: RwGsPatchSet
removeDeletedPackages

	deletedPackages do: [:each | each deletePackage ]
%

category: 'private - applying'
method: RwGsPatchSet
reportAnyErrors
	"We're currently not collecting errors, but once we do, this will be the place they are reported.
	Answer true if errors detected (and exception resumed), false otherwise."

	^errors isEmpty
		ifFalse: 
			[self halt: 'Errors detected. Aborting application of patch.'.
			true]
		ifTrue: [false]
%

category: 'private - applying'
method: RwGsPatchSet
runInitializers

	"run the class initialization methods as needed"

	| methodPatches orderedMethodPatches |
	methodPatches := (addedMethods copy
		addAll: extendedMethods;
		addAll: methodsNeedingRecompile;
		yourself) select: [:each | each isAnInitializer ].
	methodPatches isEmpty ifTrue: [ ^ self ].
	orderedMethodPatches :=  (self class respondsTo: #methodPatchesInInitializationOrder:)
		ifTrue: [ self class methodPatchesInInitializationOrder: methodPatches ]
		ifFalse: [ methodPatches ].
	orderedMethodPatches do: [ :methodPatch | 
			"a pure move, is a method that moved between packages with no change in source ... do not run initialize method in this case"
			(pureMovedMethods includes: methodPatch) 
				ifFalse: [ 
					RwExecuteClassInitializeMethodsAfterLoadNotification signal 
						ifTrue: [ methodPatch runInitializer ] ] ]
%

category: 'private - applying'
method: RwGsPatchSet
setupForApply

	"Copy the entire namespace from the user's transient SymbolList into a temporary SymbolDictionary in a temporary 
	SymbolList, the tempSymbols. The tempSymbols, once suitably modified, will be used as the environment in which 
	to compile methods during this apply operation."

	| symbolList |
	tempSymbols := SymbolDictionary new.
	symbolList := Rowan image symbolList.	
	"If there are any duplicated symbols, we only want the one that will be found first one, 
	so we copy in reverse order of search order, thereby overwriting later definitions with earlier ones."
	symbolList
		reverseDo: [ :dict | 
			"Need to preserve association identity, tempSymbols is used for compiling methods"
			dict associationsDo: [ :assoc | tempSymbols add: assoc ] ].
%

category: 'patch access'
method: RwGsPatchSet
superclassNamed: aName

	| superclassName |
	superclassName := aName asSymbol.
	^ createdClasses
		at: superclassName
		ifAbsent: [ 
			tempSymbols
				at: superclassName
				ifAbsent: [ self error: 'Superclass not found: ' , aName printString ] ]
%

category: 'accessing'
method: RwGsPatchSet
symbolDictionaryRegistryClass

	^ self _currentProjectDefinition
		ifNil: [ RwGsSymbolDictionaryRegistry ]
		ifNotNil: [ :projectDefinition | projectDefinition symbolDictionaryRegistryClass ]
%

category: 'patch access'
method: RwGsPatchSet
tempAssociationFor: aName
	^ tempSymbols associationAt: aName
%

category: 'accessing'
method: RwGsPatchSet
tempSymbols
	^ tempSymbols
%

category: 'private - applying'
method: RwGsPatchSet
updateClassProperties

	"For classes with changes that don't require versioning, 
	update the properties in the class and the LoadedClasses as appropriate."

	(classesWithClassVariableChanges copy
		addAll: classesWithPropertyChanges;
		yourself) do: [ :each | each installPropertiesPatchFor: self ]
%

category: 'private - applying'
method: RwGsPatchSet
updateMethodDictionaries
	"For added methods and methods that need recompiling,
	copy from temporary methodDictionaries to live methodDictionaries
	For added methods, create LoadedMethods and add to the appropriate LoadedClass
	or LoadedExtension
	For methods that need recompiling updated the LoadedMethods registration. "

	addedMethods do: [:patch | 
		(movedMethodsMap at: patch className ifAbsent: [])
			ifNil: [ patch installMethod ]
			ifNotNil: [ :isMetaMap |
				(isMetaMap at: patch isMeta ifAbsent: [])
					ifNil: [ patch installMethod ]
					ifNotNil: [ :selectorMap |
						(selectorMap at: patch methodDefinition selector ifAbsent: [])
							ifNil: [ patch installMethod ] ] ] ].
	extendedMethods do: [:each | each installMethod ].
	methodsNeedingRecompile do: [:each | each installSourcePatch ]
%

category: 'private - applying'
method: RwGsPatchSet
updateMethodProperties

	methodsWithPropertyChanges
		do: [:each | each installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols ]
%

category: 'private - applying'
method: RwGsPatchSet
updateSymbolAssociations
	"Install new class versions."

	classesWithNewVersions do: [:each | each installNewClassVersionInSystem ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_classAdditionPatchClass

	^ RwGsClassAdditionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_classDeletionPatchClass

	^ RwGsClassDeletionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_classExtensionPatchClass

	^ RwGsClassExtensionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_classPropertiesPatchClass

	^ RwGsClassPropertiesSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_classSymbolDictionaryMovePatchClass

	^ RwGsClassSymbolDictionaryMoveSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_classVariablePatchClass

	^ RwGsClassVariableChangeSymbolDictPatch 
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_classVersioningPatchClass

	^ RwGsClassVersioningSymbolDictPatch
%

category: 'private - applying'
method: RwGsPatchSet
_currentProjectDefinition

	^ currentProjectDefinition
		ifNil: [ 
			currentProjectDefinition := Rowan image
				loadedProjectNamed: Rowan unpackagedName
				ifAbsent: [ RwUnmanagedProjectDefinition new ] ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_methodAdditionPatchClass

	^ RwGsMethodAdditionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_methodDeletionPatchClass

	^ RwGsMethodDeletionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_methodExtensionDeletionPatchClass: packageName

	^ (self _currentProjectDefinition
		useSessionMethodsForExtensionsForPackageNamed: packageName)
			ifTrue: [ RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch ]
			ifFalse: [ RwGsMethodDeletionExtensionSymbolDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_methodExtensionPatchClass: packageName

	^ (self _currentProjectDefinition
		useSessionMethodsForExtensionsForPackageNamed: packageName)
			ifTrue: [ RwGsMethodExtensionSessionMethodSymbolDictPatch ]
			ifFalse: [ RwGsMethodExtensionSymbolDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_methodExtensionPropertiesPatchClass:  packageName

	^ (self _currentProjectDefinition
			useSessionMethodsForExtensionsForPackageNamed: packageName)
				ifTrue: [ RwGsMethodExtensionSessionMethodPropertiesSymDictPatch ]
				ifFalse: [ RwGsMethodPropertiesSymDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_methodExtensionSourcePatchClass: packageName

	^ (self _currentProjectDefinition
			useSessionMethodsForExtensionsForPackageNamed: packageName)
				ifTrue: [ RwGsMethodExtensionSessionMethodSourceSymbolDictPatch ]
				ifFalse: [ RwGsMethodSourceSymbolDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_methodPropertiesPatchClass

	^ RwGsMethodPropertiesSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_methodSourcePatchClass

	^ RwGsMethodSourceSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_packageAdditionPatchClass

	^ RwGsPackageAdditionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_packageDeletionPatchClass

	^ RwGsPackageDeletionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet
_projectAdditionPatchClass

	^ RwGsProjectAdditionPatch
%

! Class implementation for 'RwGsPatchSet_254'

!		Class methods for 'RwGsPatchSet_254'

category: 'private - method initialization order'
classmethod: RwGsPatchSet_254
classPatchesInReverseHierarchyOrder: classPatches tempSymbols: tempSymbols

	"Returns acollection of the specified classPatches ordered in reverse superclass order"

	| order toBeOrdered processed aClass patchMap |
	patchMap := IdentityKeyValueDictionary new.
	classPatches do: [:classPatch |
		| class |
		class := tempSymbols
				at: classPatch className
				ifAbsent: [ self error: 'Cannot find class to update constraints for.' ].
		patchMap at: class put: classPatch ].
	toBeOrdered := patchMap keys asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[ (aClass := self _anyElementOf: toBeOrdered ifEmpty: [ nil ]) isNil ]
		whileFalse: [ 
			self
				_orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed ].
  ^ ((order collect: [:orderedClass | patchMap at: orderedClass ifAbsent: []]) select: [:patch | patch notNil ]) reverse
%

category: 'private - method initialization order'
classmethod: RwGsPatchSet_254
methodPatchesInInitializationOrder: methodPatches

	"Returns acollection of the specified methodPatches ordered in superclass order, which is sufficient for initialization order."

	| order toBeOrdered processed aClass patchMap |
	patchMap := IdentityKeyValueDictionary new.
	methodPatches do: [:methodPatch |
		patchMap at: methodPatch behavior thisClass put: methodPatch ].
	toBeOrdered := patchMap keys asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[ (aClass := self _anyElementOf: toBeOrdered ifEmpty: [ nil ]) isNil ]
		whileFalse: [ 
			self
				_orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed ].
  ^ (order collect: [:orderedClass | patchMap at: orderedClass ifAbsent: []]) select: [:patch | patch notNil ]
%

category: 'instance creation'
classmethod: RwGsPatchSet_254
new

	^super new initialize
%

category: 'private - method initialization order'
classmethod: RwGsPatchSet_254
_anyElementOf: aCollection ifEmpty: aBlock
	aCollection do: [ :each | ^ each ].
	^ aBlock value
%

category: 'private - method initialization order'
classmethod: RwGsPatchSet_254
_orderBySuperclass: aClass from: toBeOrdered into: order ignoring: processed
  "Private. Add to 'order', superclasses first, aClass and any of its superclasses 
	that appear in 'toBeOrdered' but do not appear in 'processed'.
	Remove from 'toBeOrdered' any class added to 'ordered'.
	Any class seen, add to 'processed' whether or not added to 'order'."

  | superclass |
  superclass := aClass superclass.
  superclass isNil | (processed includes: superclass)
    ifFalse: [ 
      self
        _orderBySuperclass: superclass
        from: toBeOrdered
        into: order
        ignoring: processed ].
  processed add: aClass.
  (toBeOrdered includes: aClass)
    ifTrue: [ 
      toBeOrdered remove: aClass.
      order add: aClass ]
%

!		Instance methods for 'RwGsPatchSet_254'

category: 'building'
method: RwGsPatchSet_254
addAddedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedClasses
		add:
			((self _classAdditionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'private - applying'
method: RwGsPatchSet_254
addAddedClassesToTempSymbols
	"Just need the names for now, they don't need to resolve to anything in particular."

	addedClasses do: [:patch | 
		| key |
		key :=  patch className asSymbol.
		(tempSymbols includesKey: key) ifTrue: [ self error: 'Encountered an existing association for a new class ', key asString ].
		tempSymbols at: key put: nil ].
%

category: 'building'
method: RwGsPatchSet_254
addAddedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedMethods
		add:
			((self _methodAdditionPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addAddedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedMethods
		add:
			((self _methodAdditionPatchClass
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addAddedPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedPackages
		add:
			((self _packageAdditionPatchClass for: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addAddedProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	addedProjects
		add: (self _projectAdditionPatchClass for: aProjectDefinition) yourself
%

category: 'private - applying'
method: RwGsPatchSet_254
addAndUpdateLoadedPackages
	"Update the LoadedPackages to reflect the results of this patchSet. Does not update the other loadedThings."

	addedPackages
		do: [:packageAdditionPatch | packageAdditionPatch createLoadedPackage]
%

category: 'private - applying'
method: RwGsPatchSet_254
addAndUpdateLoadedProjects

	"Update the LoadedProjects to reflect the results of this patchSet. Does not update the other loadedThings."

	addedProjects
		do: [ :projectAdditionPatch | projectAdditionPatch createLoadedProject ].
	projectsWithPropertyChanges do: [ :patch | patch updateLoadedProject ]
%

category: 'modification dispatching'
method: RwGsPatchSet_254
addClassModification: aRwClassModification toPatchSetInPackage: aPackage inProject: aProjectDefinition

	"Double dispatch from aRwClassModification ... needed to isolate the loader methods from meaningful changes 
		while updating the loader using the loader"

	aRwClassModification isAddition
		ifTrue: [ 
			"https://github.com/dalehenrich/Rowan/issues/210 - make sure that the added classes are not already loaded
				in a project that is not included in this load"
			(Rowan globalNamed: aRwClassModification after name) ifNotNil: [:global | (RwExistingVisitorAddingExistingClassNotification new classDefinition: aRwClassModification after) signal ].
			self
				addAddedClass: aRwClassModification after
				inPackage: aPackage
				inProject: aProjectDefinition.
			(aRwClassModification propertiesModification elementsModified at: 'gs_constraints' ifAbsent: [])
				ifNotNil: [:constraints |  
					"arrange to add constraints to a newly created class - constraints not created during class creation"
					self 
						addPatchedClassConstraints: aRwClassModification after 
						inPackage: aPackage 
						inProject: aProjectDefinition ] ].
	aRwClassModification isDeletion
		ifTrue: [ 
			self
				addDeletedClass: aRwClassModification before
				inPackage: aPackage
				inProject: aProjectDefinition ].
	aRwClassModification isModification
		ifTrue: [ 
			RwGsClassVersioningPatch
				addPatchedClassModification: aRwClassModification
				inPackage: aPackage
				inProject: aProjectDefinition
				toPatchSet: self.
			(aRwClassModification propertiesModification elementsModified at: 'gs_constraints' ifAbsent: [])
				ifNotNil: [:constraints |  
					"arrange to add constraints to a newly created class - constraints not created during class creation"
					self 
						addPatchedClassConstraints: aRwClassModification after 
						inPackage: aPackage 
						inProject: aProjectDefinition ] ]
%

category: 'building'
method: RwGsPatchSet_254
addClassMove: aRwClassMove

	movedClasses add: aRwClassMove
%

category: 'private - applying'
method: RwGsPatchSet_254
addCreatedClassesAndVersionsTo: newClassesByName

	addedClasses do: [ :patch | patch addToNewClassesByName: newClassesByName ].
	classesWithClassVariableChanges
		do: [ :each | each addToNewClassesByName: newClassesByName ].
	classesWithNewVersions
		do: [ :each | each addToNewClassesByName: newClassesByName ]
%

category: 'building'
method: RwGsPatchSet_254
addDeletedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedClasses
		add:
			((self _classDeletionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addDeletedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			((self _methodDeletionPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addDeletedExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition named: className inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			(((self _methodExtensionDeletionPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				extendedClassName: className;
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addDeletedExtendedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition named: className inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			(((self _methodExtensionDeletionPatchClass: aPackageDefinition key)
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				extendedClassName: className;
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addDeletedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedMethods
		add:
			((self _methodDeletionPatchClass
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addDeletedPackage: packageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	deletedPackages
		add:
			((self _packageDeletionPatchClass for: packageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addExtendedClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedClasses
		add:
			((self _classExtensionPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedMethods
		add:
			(((self _methodExtensionPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addExtendedInstanceMethod: anInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	extendedMethods
		add:
			(((self _methodExtensionPatchClass: aPackageDefinition key)
				forMethod: anInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'modification dispatching'
method: RwGsPatchSet_254
addForcingNewClassVersionModification: aRwClassModificationForcingNewClassVersion toPatchSetInPackage: aPackage inProject: aProjectDefinition

	"Double dispatch from aRwClassModificationForcingNewClassVersion ... needed to isolate the loader methods from meaningful changes 
		while updating the loader using the loader"

	aRwClassModificationForcingNewClassVersion isAddition
		ifTrue: [ self error: 'unexpected addition for modification forcing new class version' ].
	aRwClassModificationForcingNewClassVersion isDeletion
		ifTrue: [ self error: 'unexpected deletion for modification forcing new class version' ].
	aRwClassModificationForcingNewClassVersion isModification
		ifTrue: [ 
			RwGsClassVersioningPatch
				addPatchedClassModificationForcingNewClassVersion: aRwClassModificationForcingNewClassVersion
				inPackage: aPackage
				inProject: aProjectDefinition
				toPatchSet: self ]
%

category: 'building'
method: RwGsPatchSet_254
addMethodMove: aRwMethodMove

	movedMethods add: aRwMethodMove
%

category: 'building'
method: RwGsPatchSet_254
addMovedPackage: packageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	movedPackages
		add:
			((self _packageMovePatchClass for: packageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassClassVariables: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithClassVariableChanges
		add:
			((self _classVariablePatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassConstraints: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithConstraintChanges
		add:
			((self _classConstraintPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			((self _methodSourcePatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassMethodProperties: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			((self _methodPropertiesPatchClass
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassNewVersion: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.

	classesWithNewVersions
		add:
			((self _classVersioningPatchClass
				for: aClassModification
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassProperties: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithPropertyChanges
		add:
			((self _classPropertiesPatchClass
				for: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedClassSymbolDictionaryMove: aClassModification inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	classesWithSymbolDictionaryChanges
		add:
			((self _classSymbolDictionaryMovePatchClass
				for: aClassModification
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedExtendedClassMethod: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			(((self _methodExtensionSourcePatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedExtendedClassMethodProperties: aClassMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			(((self _methodExtensionPropertiesPatchClass: aPackageDefinition key)
				forMethod: aClassMethodDefinition
				isMeta: true
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedExtendedInstanceMethod: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			(((self _methodExtensionSourcePatchClass: aPackageDefinition key)
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedExtendedInstanceMethodProperties: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			(((self _methodExtensionPropertiesPatchClass: aPackageDefinition key)
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedInstanceMethod: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsNeedingRecompile
		add:
			((self _methodSourcePatchClass
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'building'
method: RwGsPatchSet_254
addPatchedInstanceMethodProperties: aInstanceMethodDefinition inClass: aClassDefinition inPackage: aPackageDefinition inProject: aProjectDefinition

	currentProjectDefinition := aProjectDefinition.
	methodsWithPropertyChanges
		add:
			((self _methodPropertiesPatchClass
				forMethod: aInstanceMethodDefinition
				isMeta: false
				inClass: aClassDefinition
				inPackage: aPackageDefinition)
				projectDefinition: aProjectDefinition;
				yourself)
%

category: 'private - applying'
method: RwGsPatchSet_254
allPatchesAffectingLiveMethodsDo: liveMethodsBlock deletedMethodsDo: deletedMethodsBlock

	"Evaluate aBlock with every patch that can affect a method, traverse deletions separately."

	{addedMethods.
	extendedMethods.
	methodsNeedingRecompile} do: [ :patches | patches do: liveMethodsBlock ].
	deletedMethods do: deletedMethodsBlock
%

category: 'private - applying'
method: RwGsPatchSet_254
anyElementOfCollection: aCollection
	"if aCollection is empty, answer nil. Otherwise, answer the first in enumeration order (which is unspecified for unordered collections)."

	aCollection do: [:each | ^each].
	^nil
%

category: 'public'
method: RwGsPatchSet_254
apply

	"Apply the changes I represent to the running image."
(UserGlobals at: #ConditionalHalt ifAbsent: [ false ]) ifTrue: [ self halt ].
	self
		setupForApply;
		removeDeletedClassesFromTempSymbols;
		addAddedClassesToTempSymbols;
		recordCompiledForNewClassVersionDeletions;
		createNewClassesAndClassVersions;
		compileMethods.
	self reportAnyErrors
		ifTrue: [ ^ self ].	"No errors -- go ahead and install what's been compiled."
	self
		addAndUpdateLoadedProjects;
		addAndUpdateLoadedPackages;
		removeDeletedClassesFromSystem;
		"removeDeletedClassExtensionsFromSystem;" 
		installAddedClasses;
		movePackages;
		moveClassesBetweenSymbolDictionaries;
		installAddedClassExtensions;
		doMoveClassesBetweenPackages;
		doMoveMethodsBetweenPackages;
		updateSymbolAssociations;
		updateClassProperties;
		removeDeletedMethods;
		updateMethodDictionaries;
		updateMethodProperties;
		"removeDeletedClassesAndExtensionsFromPackages;"
		removeDeletedPackages;
		commit;
		runInitializers;
		commit;
		migrateInstances;
		commit
%

category: 'public'
method: RwGsPatchSet_254
applyForNewClassVersions: anInstanceMigrator

	"ignore deleted methods when applying patches to new class version.
		all methods effectively deleted from class when the new class version is created, "

	| classNames |
	instanceMigrator := anInstanceMigrator.
	classNames := Set new.
	classesWithNewVersions
		do: [ :patch | classNames add: patch classDefinition key ].
	deletedMethods copy
		do: [ :patch | 
			(classNames includes: patch className)
				ifTrue: [ 
					deleteNewVersionMethods add: patch.
					deletedMethods remove: patch ] ].
	self apply
%

category: 'accessing'
method: RwGsPatchSet_254
classesWithNewVersions

	^ classesWithNewVersions
%

category: 'private - applying'
method: RwGsPatchSet_254
commit
	"I don't think I like the idea that we commit during a load ... the developer should always be in control of
		when a commit is performed ... automatic instance migration does do commits, however, it is a developer
		choice to do the commits ... if an error occurs after a commit is performed, I am concerned that the loaded 
		state of system will be corrupted ... "

	false ifTrue: [ System commit ]
%

category: 'private - applying'
method: RwGsPatchSet_254
compileMethodPatch: aMethodAdditionPatch

	aMethodAdditionPatch compileUsingNewClasses: createdClasses
		andExistingClasses: tempSymbols
%

category: 'private - applying'
method: RwGsPatchSet_254
compileMethods

	addedMethods do: [:each | self compileMethodPatch: each].
	extendedMethods do: [:each | self compileMethodPatch: each].
	methodsNeedingRecompile do: [:each | self compileMethodPatch: each]
%

category: 'private - applying'
method: RwGsPatchSet_254
createClassesFromWorklist: workList andClassesByName: newClassesByName
	"Pick one class or class version from the workList and create it, creating any superclasses or superclass versions that are to be created.
	Remove any classes created from the workList."

	| className |
	className := self anyElementOfCollection: workList.
	className ifNil: [self error: 'Empty WorkList.'].
	self
		createClassNamed: className
		fromWorkList: workList
		andClassesByName: newClassesByName
%

category: 'private - applying'
method: RwGsPatchSet_254
createClassNamed: className fromWorkList: workList andClassesByName: newClassesByName
	"Create the named class from the workList, creating any superclasses or superclass versions that are to be created.
	Remove any classes created from the workList."

	| patch superclassName |
	workList remove: className.
	patch := newClassesByName at: className.
	superclassName := patch superclassName.
	(workList includes: superclassName)
		ifTrue: 
			[self
				createClassNamed: superclassName
				fromWorkList: workList
				andClassesByName: newClassesByName].
	patch createClassFor: self
%

category: 'patch access'
method: RwGsPatchSet_254
createdClass: aClass

	| className |
	className := aClass name.
	(createdClasses at: className ifAbsent: [ ])
		ifNil: [ 
			createdClasses
				add: (SymbolAssociation newWithKey: className value: aClass) ]
		ifNotNil: [:cl | 
			cl == aClass
				ifFalse: [ 
					"new version created, update entry in createdClasses"
					createdClasses at: className put: aClass ] ]
%

category: 'accessing'
method: RwGsPatchSet_254
createdClasses
	^ createdClasses
%

category: 'private - applying'
method: RwGsPatchSet_254
createNewClassesAndClassVersions

	"Who: Added classes and classes with new versions and classes with class variable changes
	   How: Create the new class or class version. Superclass by identity, not name resolution.
	   Order: Superclasses first.
	   Errors: Collect for reporting later"

	| newClassesByName workList |
	newClassesByName := Dictionary new.
	self addCreatedClassesAndVersionsTo: newClassesByName.
	workList := Set withAll: newClassesByName keys.
	[ workList isEmpty ]
		whileFalse: [ self createClassesFromWorklist: workList andClassesByName: newClassesByName ]
%

category: 'private - applying'
method: RwGsPatchSet_254
doMoveClassesBetweenPackages

	| image |
	image := Rowan image.
	movedClasses 
		do: [:aClassMove |
			| loadedClass |
			loadedClass := image loadedClassNamed: aClassMove classBefore name.
			loadedClass loadedPackage removeLoadedClass: loadedClass.
			(image loadedPackageNamed: aClassMove packageAfter name)
				addLoadedClass: loadedClass ]
%

category: 'private - applying'
method: RwGsPatchSet_254
doMoveMethodsBetweenPackages

	| image |
	image := Rowan image.
	movedMethods 
		do: [:aMethodMove |
			| packageDef classOrExtensionDef loadedPackage loadedClassOrExtension loadedMethods loadedMethod compiledMethod registry |
			packageDef := aMethodMove packageBefore.
			classOrExtensionDef := aMethodMove classOrExtensionBefore.
			loadedPackage := image loadedPackageNamed: packageDef name.
			loadedClassOrExtension := loadedPackage 
				classOrExtensionForClassNamed: classOrExtensionDef name 
				ifAbsent: [ 
					self error: 'internal error - no loaded class or extension found for class ', 
						classOrExtensionDef name printString, 
						'  in package ', 
						packageDef name printString ].
			loadedMethods := aMethodMove isMeta
				ifTrue: [ loadedClassOrExtension loadedClassMethods ]
				ifFalse: [ loadedClassOrExtension loadedInstanceMethods ].
			loadedMethod := loadedMethods at: aMethodMove methodBefore selector.

			registry := image loadedRegistryForPackageNamed: loadedPackage name.

			loadedClassOrExtension removeLoadedMethod: loadedMethod.
			loadedClassOrExtension isLoadedClassExtension
				ifTrue: [
					loadedClassOrExtension isEmpty
						ifTrue: [ 
							| theKey classExtensionRegistry |
							theKey := loadedClassOrExtension handle classHistory.
							classExtensionRegistry := registry classExtensionRegistry.
							(classExtensionRegistry at: theKey ifAbsent: [])
								ifNotNil: [ :loadedClassExtensions |
									loadedClassExtensions isEmpty
										ifFalse: [ 
											loadedClassExtensions remove: loadedClassOrExtension.
											loadedClassExtensions isEmpty
												ifTrue: [ classExtensionRegistry removeKey: theKey ] ] ].
							loadedPackage removeLoadedClassExtension: loadedClassOrExtension ] ].

            compiledMethod := loadedMethod handle.
			registry methodRegistry removeKey: compiledMethod ifAbsent: [].

			packageDef := aMethodMove packageAfter.
			classOrExtensionDef := aMethodMove classOrExtensionAfter.
			loadedPackage := image loadedPackageNamed: packageDef name.
			registry := (Rowan globalNamed: ((aMethodMove projectAfter specification platformSpec at: 'gemstone')
				symbolDictNameForPackageNamed: aMethodMove packageAfter name)) rowanSymbolDictionaryRegistry.
			loadedClassOrExtension := loadedPackage 
				classOrExtensionForClassNamed: classOrExtensionDef name 
				ifAbsent: [ 
					classOrExtensionDef isClassExtension
						ifTrue: [ 
							"add a new class extension on demand"
							(aMethodMove projectAfter
								useSessionMethodsForExtensionsForPackageNamed: aMethodMove packageAfter name)
								ifTrue: [ | resolved |
									((resolved := Rowan image symbolList objectNamed: classOrExtensionDef name asSymbol) notNil 
										and: [resolved isBehavior and: [ resolved isMeta not ]])
										ifFalse: [ 
											self
												error:
													'The extension class named ' , self className printString , ' cannot be found.' ].
"logic is not quite correct here ... need to create a lodedClassExtension for this puppy ... deferring session method work to a later date"
"https://github.com/dalehenrich/Rowan/issues/254"]
								ifFalse: [
									registry
										ensureExtensionClassNamed: classOrExtensionDef name
										existsForPackageNamed: packageDef name
										implementationClass: RwGsSymbolDictionaryRegistry_Implementation ].
							loadedPackage loadedClassExtensions at: classOrExtensionDef name ]
						ifFalse: [ 
							self error: 'internal error - no loaded class found for class ', 
								classOrExtensionDef name printString, 
								'  in package ', 
								packageDef name printString ] ].

			loadedClassOrExtension addLoadedMethod: loadedMethod.

			registry methodRegistry at: compiledMethod put: loadedMethod ]
%

category: 'initialization'
method: RwGsPatchSet_254
initialize

	addedPackages := Set new.
	addedProjects := Set new.
	deletedPackages := Set new.
	movedPackages := Set new.
	projectsWithPropertyChanges := Set new.
	deletedClasses := Set new.
	addedClasses := Set new.
	extendedClasses := Set new.
	classesWithNewVersions := Set new.
	classesWithClassVariableChanges := Set new.
	classesWithPropertyChanges := Set new.
	classesWithConstraintChanges := Set new.
	classesWithSymbolDictionaryChanges := Set new.
	movedClasses := Set new.
	movedClassesMap := Dictionary new.
	deletedMethods := Set new.
	deleteNewVersionMethods := Set new.
	movedMethods := Set new.
	addedMethods := Set new.
	extendedMethods := Set new.
	methodsNeedingRecompile := Set new.
	methodsWithPropertyChanges := Set new.
	tempSymbols := SymbolDictionary new.
	createdClasses := Dictionary new.
	errors := Set new
%

category: 'private - applying'
method: RwGsPatchSet_254
installAddedClasses
	"Copy the name association from TempSymbols to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	addedClasses do: [:patch |  patch installClassInSystem ]
%

category: 'private - applying'
method: RwGsPatchSet_254
installAddedClassExtensions

	extendedClasses do: [ :each | each installClassExtensionInSystem ]
%

category: 'accessing'
method: RwGsPatchSet_254
instanceMigrator

	^ instanceMigrator
%

category: 'private - applying'
method: RwGsPatchSet_254
migrateInstances

	"conditionally migrate instances of classes with new versions"

	| classSet |
	classSet := classesWithNewVersions collect: [ :patch | patch oldClassVersion ].
	classSet isEmpty
		ifTrue: [ ^ self ].
	instanceMigrator
		ifNil: [ 
			"if instanceMigrator is not set, then we are not ready to do instance migration on this pass"
			^ self ].
	instanceMigrator migrateInstancesOf: classSet asArray
%

category: 'private - applying'
method: RwGsPatchSet_254
moveClassesBetweenSymbolDictionaries

	classesWithSymbolDictionaryChanges do: [:each | 
		| className |
		className := each classDefinition name.
		(movedClassesMap at: className ifAbsent: [])
				ifNil: [ each installSymbolDictionaryPatchFor: self ]
				ifNotNil: [:classMove | each installSymbolDictionaryPatchFor: self classMove: classMove ] ].
%

category: 'accessing'
method: RwGsPatchSet_254
movedClassesMap
	^ movedClassesMap
%

category: 'private - applying'
method: RwGsPatchSet_254
movePackages

	movedPackages do: [:each | each movePackage ]
%

category: 'private - applying'
method: RwGsPatchSet_254
recordCompiledForNewClassVersionDeletions

	deleteNewVersionMethods
		do: [ :each | each primeBehaviorNewClasses: createdClasses andExistingClasses: tempSymbols ]
%

category: 'private - applying'
method: RwGsPatchSet_254
removeDeletedClassesFromSystem
	"Remove the name binding from the SymbolDictionaries in the live SymbolList
        Remove the LoadedClass from its LoadedPackage"

	deletedClasses do: [:patch | patch deleteClassFromSystem ]
%

category: 'private - applying'
method: RwGsPatchSet_254
removeDeletedClassesFromTempSymbols
	"Deleted class names should not resolve during compilation."

	deletedClasses do: [:patch | tempSymbols removeKey: patch className asSymbol ]
%

category: 'private - applying'
method: RwGsPatchSet_254
removeDeletedMethods

	deletedMethods
		do: [ :methodDeletionPatch | 
			| className |
			className := methodDeletionPatch className.
			methodDeletionPatch deleteMethodNewClasses: createdClasses andExistingClasses: tempSymbols ].
	deleteNewVersionMethods
		do: [ :methodDeletionPatch | 
			methodDeletionPatch
				deleteNewVersionMethodNewClasses: createdClasses
				andExistingClasses: tempSymbols  ]
%

category: 'private - applying'
method: RwGsPatchSet_254
removeDeletedPackages

	deletedPackages do: [:each | each deletePackage ]
%

category: 'private - applying'
method: RwGsPatchSet_254
reportAnyErrors
	"We're currently not collecting errors, but once we do, this will be the place they are reported.
	Answer true if errors detected (and exception resumed), false otherwise."

	^errors isEmpty
		ifFalse: 
			[self halt: 'Errors detected. Aborting application of patch.'.
			true]
		ifTrue: [false]
%

category: 'private - applying'
method: RwGsPatchSet_254
runInitializers

	"run the class initialization methods as needed"

	| methodPatches orderedMethodPatches blackList |
	blackList := Rowan automaticClassInitializationBlackList.
	methodPatches := (addedMethods copy
		addAll: extendedMethods;
		addAll: methodsNeedingRecompile;
		yourself) select: [:each | each isAnInitializer ].
	methodPatches isEmpty ifTrue: [ ^ self ].
	orderedMethodPatches :=  (self class respondsTo: #methodPatchesInInitializationOrder:)
		ifTrue: [ self class methodPatchesInInitializationOrder: methodPatches ]
		ifFalse: [ methodPatches ].
	orderedMethodPatches do: [ :methodPatch | 
		(blackList includes: methodPatch projectDefinition name)
			ifFalse: [ 
				(RwExecuteClassInitializeMethodsAfterLoadNotification new
					candidateClass: methodPatch behavior thisClass) signal 
						ifTrue: [ methodPatch runInitializer ] ] ]
%

category: 'private - applying'
method: RwGsPatchSet_254
setupForApply

	"Copy the entire namespace from the user's transient SymbolList into a temporary SymbolDictionary in a temporary 
	SymbolList, the tempSymbols. The tempSymbols, once suitably modified, will be used as the environment in which 
	to compile methods during this apply operation."

	| symbolList |
	tempSymbols := SymbolDictionary new.
	symbolList := Rowan image symbolList.	
	"If there are any duplicated symbols, we only want the one that will be found first one, 
	so we copy in reverse order of search order, thereby overwriting later definitions with earlier ones."
	symbolList
		reverseDo: [ :dict | 
			"Need to preserve association identity, tempSymbols is used for compiling methods"
			dict associationsDo: [ :assoc | tempSymbols add: assoc ] ].

	self setupForMovedClasses
%

category: 'private - applying'
method: RwGsPatchSet_254
setupForMovedClasses

	self _createMovedClasses
%

category: 'private - applying'
method: RwGsPatchSet_254
setupForNewClassVersionUpdates

	self _createMovedClasses
%

category: 'patch access'
method: RwGsPatchSet_254
superclassNamed: aName

	| superclassName |
	superclassName := aName asSymbol.
	^ createdClasses
		at: superclassName
		ifAbsent: [ 
			tempSymbols
				at: superclassName
				ifAbsent: [ self error: 'Superclass not found: ' , aName printString ] ]
%

category: 'accessing'
method: RwGsPatchSet_254
symbolDictionaryRegistryClass

	^ self _currentProjectDefinition
		ifNil: [ RwGsSymbolDictionaryRegistry ]
		ifNotNil: [ :projectDefinition | projectDefinition symbolDictionaryRegistryClass ]
%

category: 'patch access'
method: RwGsPatchSet_254
tempAssociationFor: aName
	^ tempSymbols associationAt: aName
%

category: 'accessing'
method: RwGsPatchSet_254
tempSymbols
	^ tempSymbols
%

category: 'private - applying'
method: RwGsPatchSet_254
updateClassProperties

	"For classes with changes that don't require versioning, 
	update the properties in the class and the LoadedClasses as appropriate."

	| classPatches ts |
	ts := self tempSymbols.
	classPatches := OrderedCollection new.
	classPatches 
		addAll: (self class classPatchesInReverseHierarchyOrder: classesWithClassVariableChanges tempSymbols: ts);
		addAll: (self class classPatchesInReverseHierarchyOrder: classesWithPropertyChanges tempSymbols: ts);
		addAll: (self class classPatchesInReverseHierarchyOrder: classesWithConstraintChanges tempSymbols: ts);
		yourself.
	classPatches 
		do: [ :each | 
			(movedClassesMap at: each className ifAbsent: [])
				ifNil: [ each installPropertiesPatchFor: self ]
				ifNotNil: [:aClassMove | each installPropertiesPatchFor: self classMove: aClassMove ] ]
%

category: 'private - applying'
method: RwGsPatchSet_254
updateMethodDictionaries
	"For added methods and methods that need recompiling,
	copy from temporary methodDictionaries to live methodDictionaries
	For added methods, create LoadedMethods and add to the appropriate LoadedClass
	or LoadedExtension
	For methods that need recompiling updated the LoadedMethods registration. "

	| movedClassesWithNewVersionMap movedExtensionMethodsMap |
	movedClassesWithNewVersionMap := Dictionary new.
	classesWithNewVersions do: [:patch | 
		(movedClassesMap at: patch className ifAbsent: []) 
			ifNotNil: [:aClassMove | 
				movedClassesWithNewVersionMap at: patch className put: {aClassMove . patch} ] ]. 
	addedMethods do: [:patch |
		| className |
		className := patch className.
		(movedClassesWithNewVersionMap at: className ifAbsent: [])
			ifNil: [ patch installMethod ]
			ifNotNil: [:ar | 
				"https://github.com/dalehenrich/Rowan/issues/316"
				patch installMovedMethod: (ar at: 1) newClassVersionPatch: (ar at: 2) ] ].
	movedClassesWithNewVersionMap isEmpty
		ifFalse: [
			"calculate moved extension methods map only if there are moved new class versions as well"
			movedExtensionMethodsMap := Dictionary new.
			movedMethods do: [:aMethodMove |
				| classExtDict key methodDict  |
				classExtDict := movedExtensionMethodsMap  at: aMethodMove classOrExtensionAfter name ifAbsentPut: [ Dictionary new].
				key := aMethodMove isMeta ifTrue: [ 'class' ] ifFalse: [ 'instance'].
				methodDict := classExtDict at: key ifAbsentPut: [ Dictionary new ]. 
				methodDict at: aMethodMove methodAfter selector put: aMethodMove ] ].
	extendedMethods do: [:patch |
		| className |
		className := patch className.
		(movedClassesWithNewVersionMap at: className ifAbsent: [])
			ifNil: [ patch installMethod ]
			ifNotNil: [:ar | 
				"https://github.com/dalehenrich/Rowan/issues/316"
				(movedExtensionMethodsMap at: className ifAbsent: [])
					ifNil: [ patch installMethod ]
					ifNotNil: [:classExtDict |
						| methodDict |
						methodDict := patch isMeta
							ifTrue: [ classExtDict at: 'class' ifAbsent: [ Dictionary new ] ]
							ifFalse: [ classExtDict at: 'instance' ifAbsent: [ Dictionary new ] ].
						(methodDict at: patch methodDefinition selector ifAbsent: [])
							ifNil: [ patch installMethod ]
							ifNotNil: [:aMethodMove |
								patch installMovedMethod: aMethodMove newClassVersionPatch: (ar at: 2) ] ] ] ].
	methodsNeedingRecompile do: [:each | each installSourcePatch ]
%

category: 'private - applying'
method: RwGsPatchSet_254
updateMethodProperties

	methodsWithPropertyChanges
		do: [:each | each installPropertiesPatchNewClasses: createdClasses andExistingClasses: tempSymbols ]
%

category: 'private - applying'
method: RwGsPatchSet_254
updateSymbolAssociations
	"Install new class versions."

	classesWithNewVersions do: [:each | 
		(movedClassesMap at: each className ifAbsent: [])
			ifNil: [ each installNewClassVersionInSystem ]
			ifNotNil: [:aClassMove | each moveNewClassVersionInSystem: aClassMove ].
		 ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classAdditionPatchClass

	^ RwGsClassAdditionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classConstraintPatchClass

	^ RwGsClassConstraintsSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classDeletionPatchClass

	^ RwGsClassDeletionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classExtensionPatchClass

	^ RwGsClassExtensionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classPropertiesPatchClass

	^ RwGsClassPropertiesSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classSymbolDictionaryMovePatchClass

	^ RwGsClassSymbolDictionaryMoveSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classVariablePatchClass

	^ RwGsClassVariableChangeSymbolDictPatch 
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_classVersioningPatchClass

	^ RwGsClassVersioningSymbolDictPatch
%

category: 'private - applying'
method: RwGsPatchSet_254
_createMovedClasses

	movedClasses do: [:movedClass | 
		movedClassesMap 
			at: movedClass classBefore name 
			put: movedClass ].
%

category: 'private - applying'
method: RwGsPatchSet_254
_currentProjectDefinition

	^ currentProjectDefinition
		ifNil: [ 
			currentProjectDefinition := Rowan image
				loadedProjectNamed: Rowan unpackagedName
				ifAbsent: [ RwUnmanagedProjectDefinition new ] ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodAdditionPatchClass

	^ RwGsMethodAdditionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodDeletionPatchClass

	^ RwGsMethodDeletionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodExtensionDeletionPatchClass: packageName

	^ (self _currentProjectDefinition
		useSessionMethodsForExtensionsForPackageNamed: packageName)
			ifTrue: [ RwGsMethodDeletionExtensionSessionMethodSymbolDictPatch ]
			ifFalse: [ RwGsMethodDeletionExtensionSymbolDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodExtensionPatchClass: packageName

	^ (self _currentProjectDefinition
		useSessionMethodsForExtensionsForPackageNamed: packageName)
			ifTrue: [ RwGsMethodExtensionSessionMethodSymbolDictPatch ]
			ifFalse: [ RwGsMethodExtensionSymbolDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodExtensionPropertiesPatchClass:  packageName

	^ (self _currentProjectDefinition
			useSessionMethodsForExtensionsForPackageNamed: packageName)
				ifTrue: [ RwGsMethodExtensionSessionMethodPropertiesSymDictPatch ]
				ifFalse: [ RwGsMethodPropertiesSymDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodExtensionSourcePatchClass: packageName

	^ (self _currentProjectDefinition
			useSessionMethodsForExtensionsForPackageNamed: packageName)
				ifTrue: [ RwGsMethodExtensionSessionMethodSourceSymbolDictPatch ]
				ifFalse: [ RwGsMethodSourceSymbolDictPatch ]
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodPropertiesPatchClass

	^ RwGsMethodPropertiesSymDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_methodSourcePatchClass

	^ RwGsMethodSourceSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_packageAdditionPatchClass

	^ RwGsPackageAdditionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_packageDeletionPatchClass

	^ RwGsPackageDeletionSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_packageMovePatchClass

	^ RwGsPackageMoveSymbolDictPatch
%

category: 'private - patch class accessors'
method: RwGsPatchSet_254
_projectAdditionPatchClass

	^ RwGsProjectAdditionPatch
%

! Class implementation for 'RwGsSymbolDictionaryRegistry'

!		Class methods for 'RwGsSymbolDictionaryRegistry'

category: 'accessing'
classmethod: RwGsSymbolDictionaryRegistry
defaultProtocolString

	^ 'as yet unclassified'
%

category: 'installation'
classmethod: RwGsSymbolDictionaryRegistry
globalSymbol

	^ #'RwSymbolDictionaryRegistry'
%

category: 'installation'
classmethod: RwGsSymbolDictionaryRegistry
installIn: aSymbolDictionary

	| registry |
	registry := self newForSymbolDictionary: aSymbolDictionary.
	aSymbolDictionary at: self globalSymbol put: registry.
	^ registry
%

category: 'instance creation'
classmethod: RwGsSymbolDictionaryRegistry
newForSymbolDictionary: aSymbolDictionary

	^ self new
		_symbolDictionary: aSymbolDictionary;
		initialize;
		yourself
%

!		Instance methods for 'RwGsSymbolDictionaryRegistry'

category: 'private'
method: RwGsSymbolDictionaryRegistry
addClassAssociation: assoc forClass: class toPackageNamed: packageName

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	^ self class registry_ImplementationClass addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addClassAssociation: assoc forClass: class toPackageNamed: packageName implementationClass: implementationClass

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName

	^ self class registry_ImplementationClass addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName

	"expecting only a single method to be in methDict/catDict"

	^ self class registry_ImplementationClass addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName implementationClass: implementationClass

	"expecting only a single method to be in methDict/catDict"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addMovedDeletedMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName

	"there is an existing compiled method that has already been deleted from another package ... so we're adding it
		back using specialized processing"

	^ self class registry_ImplementationClass addMovedDeletedMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addMovedDeletedMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName implementationClass: implementationClass

	"there is an existing compiled method that has already been deleted from another package ... so we're adding it
		back using specialized processing"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addMovedDeletedMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addNewClassVersionToAssociation: newClass

	"a new class version is being added to the association in the receiver previously occupied by the original class"

	self class registry_ImplementationClass addNewClassVersionToAssociation: newClass instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addNewClassVersionToAssociation: newClass implementationClass: implementationClass

	"a new class version is being added to the association in the receiver previously occupied by the original class"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	implementationClass addNewClassVersionToAssociation: newClass instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName

	^ self class registry_ImplementationClass addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addRecompiledMethod: newCompiledMethod

	"add a recompiled compiled method to behavior and update the loaded things"

	^ self class registry_ImplementationClass addRecompiledMethod: newCompiledMethod instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addRecompiledMethod: newCompiledMethod implementationClass: implementationClass

	"add a recompiled compiled method to behavior and update the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addRecompiledMethod: newCompiledMethod instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addRecompiledSessionMethodMethod: newCompiledMethod

	"add a recompiled session method compiled method to behavior and update the loaded things"

	^ self class registry_ImplementationClass addRecompiledSessionMethodMethod: newCompiledMethod instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
addRecompiledSessionMethodMethod: newCompiledMethod implementationClass: implementationClass

	"add a recompiled session method compiled method to behavior and update the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass addRecompiledSessionMethodMethod: newCompiledMethod instance: self
%

category: 'method - adopt api'
method: RwGsSymbolDictionaryRegistry
adoptCompiledMethod: compiledMethod classExtension: classExtension for: behavior protocol: protocolString toPackageNamed: packageName

	| methodDictionary selector protocolSymbol existing loadedMethod loadedPackage loadedClassOrExtension |
	classExtension
		ifTrue: [
			"to adopt and extension method, it is much less complicated" 
			^ self 
				addExtensionCompiledMethod: compiledMethod 
				for: behavior 
				protocol: protocolString 
				toPackageNamed: packageName ].

	methodDictionary := behavior persistentMethodDictForEnv: 0.
	selector := compiledMethod selector.
	compiledMethod == (methodDictionary at: selector ifAbsent: [ self error: 'expected an existing compiled method' ])
		ifFalse: [ self error: 'The given compiled method does not the existing compiled method in the class.' ].

	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [ behavior addCategory: protocolSymbol ].
	behavior moveMethod: selector toCategory: protocolSymbol.

	existing := methodRegistry at: compiledMethod ifAbsent: [ nil ].
	existing
		ifNotNil: [
			"existing LoadedMethod found for compiled method ... ignore already packaged methods"
			^ self ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	methodRegistry at: compiledMethod put: loadedMethod.

	loadedPackage := self
		loadedPackageNamed: packageName
		ifAbsent: [ 
			self
				error: 'Internal error -- attempt to add a method to a nonexistent package.' ].

	loadedClassOrExtension := loadedPackage
		loadedClassOrClassExtensionForClass: behavior
		ifAbsent: [ 
			self
				error:
					'Internal error -- attempt to add a method to a package in which its class is neither defined nor extended.' ].
	loadedClassOrExtension addLoadedMethod: loadedMethod
%

category: 'accessing'
method: RwGsSymbolDictionaryRegistry
classExtensionRegistry

	^ classExtensionRegistry
%

category: 'accessing'
method: RwGsSymbolDictionaryRegistry
classRegistry

   ^classRegistry
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
createAndInstallLoadedClassForClass: class toPackageNamed: packageName

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	^ self class registry_ImplementationClass createAndInstallLoadedClassForClass: class toPackageNamed: packageName instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
createAndInstallLoadedClassForClass: class toPackageNamed: packageName implementationClass: implementationClass

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass createAndInstallLoadedClassForClass: class toPackageNamed: packageName instance: self
%

category: 'package - patch api'
method: RwGsSymbolDictionaryRegistry
createLoadedPackageFromDefinition: packageDefinition

	^ self class registry_ImplementationClass createLoadedPackageFromDefinition: packageDefinition instance: self
%

category: 'package - patch api'
method: RwGsSymbolDictionaryRegistry
createLoadedPackageFromDefinition: packageDefinition implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass createLoadedPackageFromDefinition: packageDefinition instance: self
%

category: 'package - patch api'
method: RwGsSymbolDictionaryRegistry
createLoadedPackageNamed: packageName properties: properties

	^ self class registry_ImplementationClass createLoadedPackageNamed: packageName properties: properties instance: self
%

category: 'package - patch api'
method: RwGsSymbolDictionaryRegistry
createLoadedPackageNamed: packageName properties: properties  implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass createLoadedPackageNamed: packageName properties: properties instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
deleteClassFromPackage: class

	"a class association is being deleted from the receiver remove it from the loaded things"

	^ self class registry_ImplementationClass deleteClassFromPackage: class instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
deleteClassFromPackage: class implementationClass: implementationClass

	"a class association is being deleted from the receiver remove it from the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteClassFromPackage: class instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
deleteClassNamedFromPackage: className

	"a class association is being deleted from the receiver remove it from the loaded things"

	^ self class registry_ImplementationClass deleteClassNamedFromPackage: className instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
deleteClassNamedFromPackage: className implementationClass: implementationClass

	"a class association is being deleted from the receiver remove it from the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteClassNamedFromPackage: className instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteCompiledMethod: compiledMethod from: behavior

	"delete a compiled method from behavior and remove it from the loaded things"

	^ self class registry_ImplementationClass deleteCompiledMethod: compiledMethod from: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteCompiledMethod: compiledMethod from: behavior implementationClass: implementationClass

	"delete a compiled method from behavior and remove it from the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteCompiledMethod: compiledMethod from: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteMethod: selector for: behavior

	^ self class registry_ImplementationClass deleteMethod: selector for: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteMethod: selector for: behavior implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteMethod: selector for: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteMovedLoadedMethod: selector for: behavior implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteMovedLoadedMethod: selector for: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deleteMovedMethod: selector for: behavior implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass deleteMovedMethod: selector for: behavior instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
deletePackage: packageName

	^  self class registry_ImplementationClass deletePackage: packageName instance: self
%

category: 'class disown api'
method: RwGsSymbolDictionaryRegistry
disownClass: class

	"Remove the specified class and all of it's packaged instance and class methods from the loaded things."

	^ self class registry_ImplementationClass disownClass: class instance: self
%

category: 'class disown api'
method: RwGsSymbolDictionaryRegistry
disownClassExtensions: class forLoadedPackage: loadedPackage

	"Remove the extension methods in the named class for the named package"

	^ self class registry_ImplementationClass disownClassExtensions: class forLoadedPackage: loadedPackage instance: self
%

category: 'class disown api'
method: RwGsSymbolDictionaryRegistry
disownClassExtensions: class forPackageNamed: packageName

	"Remove the extension methods in the named class for the named package"

	^ self class registry_ImplementationClass disownClassExtensions: class forPackageNamed: packageName instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
ensureExtensionClassNamed: className existsForPackageNamed: packageName

	^ self class registry_ImplementationClass ensureExtensionClassNamed: className existsForPackageNamed: packageName instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
ensureExtensionClassNamed: className existsForPackageNamed: packageName implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass ensureExtensionClassNamed: className existsForPackageNamed: packageName instance: self
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
existingForClass: aClass

	"Answer the registered LoadedClass for the given class."

	^ self
		existingForClass: aClass
		ifAbsent: [ self error: 'no loaded class found for ' , aClass name printString ]
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
existingForClass: aClass ifAbsent: absentBlock

	"Answer the registered LoadedClass for the given class."

	^ classRegistry at: aClass classHistory ifAbsent: absentBlock
%

category: 'package - creation api'
method: RwGsSymbolDictionaryRegistry
existingOrNewLoadedPackageNamed: packageName

	^ self class registry_ImplementationClass existingOrNewLoadedPackageNamed: packageName instance: self
%

category: 'package - creation api'
method: RwGsSymbolDictionaryRegistry
existingOrNewLoadedPackageNamed: packageName implementationClass: implementationClass

	^ implementationClass existingOrNewLoadedPackageNamed: packageName instance: self
%

category: 'session methods'
method: RwGsSymbolDictionaryRegistry
homeSessionMethods

	| package |
	package := self _symbolDictionary at: GsPackage globalName otherwise: nil.
	package ifNil: [ package := GsPackage installIn: self _symbolDictionary ].
	^ package
%

category: 'initialization'
method: RwGsSymbolDictionaryRegistry
initialize

	| symbolDictObjectSecurityPolicy |
	packageRegistry := KeyValueDictionary new.	"keyed by package name"
	classRegistry := IdentityKeyValueDictionary new.	"keyed by class classHistory"
	classExtensionRegistry := IdentityKeyValueDictionary new.	"keyed by class classHistory"
	methodRegistry := IdentityKeyValueDictionary new.	"keyed by compiledMethod"

	symbolDictObjectSecurityPolicy := symbolDictionary objectSecurityPolicy.
	packageRegistry objectSecurityPolicy: symbolDictObjectSecurityPolicy.
	classRegistry objectSecurityPolicy: symbolDictObjectSecurityPolicy.
	classExtensionRegistry objectSecurityPolicy: symbolDictObjectSecurityPolicy.
	methodRegistry objectSecurityPolicy: symbolDictObjectSecurityPolicy.
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock

	^ self class registry_ImplementationClass loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock instance: self
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock instance: self
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
loadedPackageNamed: packageName ifAbsent: absentBlock

	^ self class registry_ImplementationClass loadedPackageNamed: packageName ifAbsent: absentBlock instance: self
%

category: 'loaded queries'
method: RwGsSymbolDictionaryRegistry
loadedPackageNamed: packageName ifAbsent: absentBlock implementationClass: implementationClass

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass loadedPackageNamed: packageName ifAbsent: absentBlock instance: self
%

category: 'accessing'
method: RwGsSymbolDictionaryRegistry
methodRegistry

   ^methodRegistry
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
moveCompiledMethod: compiledMethod toProtocol: newProtocol

	"move a compiled method into a different protocol and update loaded things"

	^ self class registry_ImplementationClass moveCompiledMethod: compiledMethod toProtocol: newProtocol instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
moveCompiledMethod: compiledMethod toProtocol: newProtocol implementationClass: implementationClass

	"move a compiled method into a different protocol and update loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass moveCompiledMethod: compiledMethod toProtocol: newProtocol instance: self
%

category: 'method - patch api'
method: RwGsSymbolDictionaryRegistry
movePackage: packageName to: symbolDictionaryName

	^  self class registry_ImplementationClass movePackage: packageName  to: symbolDictionaryName instance: self
%

category: 'package - creation api'
method: RwGsSymbolDictionaryRegistry
newLoadedPackageNamed: packageName

	^ self class registry_ImplementationClass newLoadedPackageNamed: packageName instance: self
%

category: 'package - creation api'
method: RwGsSymbolDictionaryRegistry
newLoadedPackageNamed: packageName implementationClass: implementationClass

	^ implementationClass newLoadedPackageNamed: packageName instance: self
%

category: 'accessing'
method: RwGsSymbolDictionaryRegistry
packageRegistry

   ^packageRegistry
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
updateClassProperties: class

	"class properties have changed, update the clas properties of the loaded things"

	^ self class registry_ImplementationClass updateClassProperties: class instance: self
%

category: 'class - patch api'
method: RwGsSymbolDictionaryRegistry
updateClassProperties: class  implementationClass: implementationClass

	"class properties have changed, update the clas properties of the loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass updateClassProperties: class instance: self
%

category: 'method - private api'
method: RwGsSymbolDictionaryRegistry
_doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior

	"remove a compiled method from loaded things"

	^ self class registry_ImplementationClass _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: self
%

category: 'method - private api'
method: RwGsSymbolDictionaryRegistry
_doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior implementationClass: implementationClass

	"remove a compiled method from loaded things"

	"Use for calls from classes in Rowan-GemStone-Loader package"

	^ implementationClass _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: self
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_loadedClassFor: class noNewVersion: noNewVersionBlock

	self
		_loadedClassFor: class
		noNewVersion: noNewVersionBlock
		newVersion: [ :loadedClass | 
			self
				error:
					'internal error - the value associated with the key ' , class name printString
						, ' is not identical to the given class' ]
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_loadedClassFor: class noNewVersion: noNewVersionBlock newVersion: newVersionBlock

	| loadedClass classKey |
	(class isKindOf: Class)
		ifFalse: [ self error: 'internal error - expected a class' ].
	loadedClass := classRegistry
		at: class classHistory
		ifAbsent: [ 
			self
				error:
					'internal error - No package found for the class ' , class name printString ].
	classKey := loadedClass key asSymbol.
	self
		_symbolDictionaryAssociationAt: classKey
		ifPresent: [ :assoc | 
			assoc value == class
				ifTrue: [ ^ noNewVersionBlock cull: loadedClass cull: assoc ]
				ifFalse: [ ^ newVersionBlock cull: loadedClass cull: assoc ] ].

	self
		error:
			'internal error - there is no assocation present in the receiver for the given class '
				, classKey asString printString
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionary

	^ symbolDictionary
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionary: aSymbolDictionary

	symbolDictionary := aSymbolDictionary
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionaryAssociationAt: aKey ifPresent: oneArgBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the symbol association associated with the key, otherwise answer nil."

	| anAssoc |
	anAssoc := self _symbolDictionary associationAt: aKey otherwise: nil.
	anAssoc ifNotNil: [ ^ oneArgBlock cull: anAssoc ].
	^ nil
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionaryAssociationAt: key ifPresent: oneArgBlock ifAbsent: absentBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the symbol association associated with the key, otherwise answer the value of absentBlock."

	self
		_symbolDictionaryAssociationAt: key
		ifPresent: [ :v | ^ oneArgBlock cull: v ].
	^ absentBlock value
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionaryAt: key ifPresent: oneArgBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v := self _symbolDictionary at: key ifAbsent: [ ^ nil ].
	^ oneArgBlock cull: v
%

category: 'private'
method: RwGsSymbolDictionaryRegistry
_symbolDictionaryAt: key ifPresent: oneArgBlock ifAbsent: absentBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the value associated with the key, otherwise answer the value of absentBlock."

	| v |
	v := self _symbolDictionary at: key ifAbsent: [ ^absentBlock value ].
	^ oneArgBlock cull: v
%

! Class implementation for 'RwGsSymbolDictionaryRegistry_Implementation'

!		Class methods for 'RwGsSymbolDictionaryRegistry_Implementation'

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addClassAssociation: assoc forClass: class toPackageNamed: packageName instance: registryInstance

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	| loadedPackage loadedClass |
	loadedPackage := self existingOrNewLoadedPackageNamed: packageName instance: registryInstance.

	loadedClass := registryInstance classRegistry
		at: class classHistory
		ifAbsent: [ 
			loadedClass := RwGsLoadedSymbolDictClass newForClass: class.
			loadedPackage addLoadedClass: loadedClass.
			loadedClass updatePropertiesFromClassFor: registryInstance.
			registryInstance classRegistry at: class classHistory put: loadedClass.
			(loadedPackage loadedClassExtensions at: class name ifAbsent: [  ])
				ifNotNil: [ :loadedClassExtension | 
					"I think we need to subsume the loadedClassExtension methods into a loadedClass ..."
					"have yet to come with a test case that takes this path"
					registryInstance error: 'internal error - unexpected class extenstions for a loaded class ', class name asString printString , ' that has no entry in classRegistry in package ', loadedPackage name printString, '.' ] ].

	self 
		_symbolDictionary: registryInstance _symbolDictionary 
		at: assoc key 
		ifPresent: [:theClass |
			theClass ~~ class
				ifTrue: [
					(RwExistingAssociationWithSameKeyNotification new
						errorMessage: 'Found an existing association in the ',  
								registryInstance _symbolDictionary name asString printString, 
								' symbol dictionary with a duplicate key ',
								assoc key printString, 
								' while attempting to add a new class' )
						signal.
					(registryInstance _symbolDictionary associationAt: assoc key) value: class ] ]
		ifAbsent: [
			assoc value: class.
			registryInstance _symbolDictionary add: assoc].
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addExtensionSessionMethods: methDict catDict: catDict for: behavior toPackageNamed: packageName instance: registryInstance


	"expecting only a single method to be in methDict/catDict"

	| dictsArray mDict cDict existing loadedMethod loadedPackage loadedClassExtension compiledMethod |
	dictsArray := registryInstance homeSessionMethods methodAndCategoryDictionaryFor: behavior.
	mDict := dictsArray at: 1.
	cDict := dictsArray at: 2.
	catDict
		keysAndValuesDo: [ :protocolSymbol :selectors | 
			| symbolSet |
			symbolSet := cDict
				at: protocolSymbol
				ifAbsent: [ cDict at: protocolSymbol put: SymbolSet new ].
			symbolSet addAll: selectors ].
	methDict
		keysAndValuesDo: [ :sel :meth | 
			mDict at: sel put: meth.
			GsPackagePolicy current updateMethodLookupCacheFor: meth in: behavior.
			compiledMethod := meth ].

	existing := registryInstance methodRegistry at: compiledMethod ifAbsent: [ nil ].
	existing
		ifNotNil: [ 
			registryInstance
				error:
					'Internal error -- existing LoadedMethod found for extension compiled method.' ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	registryInstance methodRegistry at: compiledMethod put: loadedMethod.

	loadedPackage := self existingOrNewLoadedPackageNamed: packageName instance: registryInstance.

	loadedClassExtension := loadedPackage
		loadedClassExtensionForClass: behavior
		ifAbsent: [ 
			| class ext |
			class := behavior theNonMetaClass.
			ext := RwGsLoadedSymbolDictClassExtension
				newForClass: class
				inPackage: loadedPackage.
			(registryInstance classExtensionRegistry
				at: class classHistory
				ifAbsentPut: [ IdentitySet new ]) add: ext.
			ext ].
	loadedClassExtension addLoadedMethod: loadedMethod.

	^ compiledMethod
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addNewClassVersionToAssociation: newClass instance: registryInstance

	"a new class version is being added to the association in the receiver previously occupied by the original class"

	self 
		_loadedClassFor: newClass
		noNewVersion: [ 
			"newClass is actually not a new class version of existing class, that's okay... update properties anyway"
			self updateClassProperties: newClass instance: registryInstance.]
		newVersion: [ :loadedClass :assoc | 
			"association for class is present, install in association and update the loadedthing"
			assoc value: newClass.
			loadedClass handleClassDeletionOrNewVersion
				ifTrue: [ loadedClass updatePropertiesFromClassFor: registryInstance ]
				ifFalse: [ registryInstance error: 'internal error - new version of class not properly installed' ] ]
		instance: registryInstance.
	self 
		_loadedClassExtensionsFor: newClass
		noNewVersion: [ 
			"newClass is actually not a new class version of existing class, that's okay... noop"
]
		newVersion: [ :loadedClassExtension | 
			loadedClassExtension handleClassDeletionOrNewVersion
				ifFalse: [ registryInstance error: 'internal error - new version of class not properly installed' ] ]
		instance: registryInstance.
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addRecompiledSessionMethodMethod: newCompiledMethod instance: registryInstance

	"add a recompiled session method compiled method to behavior and update the loaded things"

	| selector behavior dictsArray mDict cDict oldCompiledMethod loadedMethod |
	selector := newCompiledMethod selector.
	behavior := newCompiledMethod inClass.
	dictsArray := registryInstance homeSessionMethods methodAndCategoryDictionaryFor: behavior.
	mDict := dictsArray at: 1.
	cDict := dictsArray at: 2.
	oldCompiledMethod := mDict
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- expected an existing compiled method in the session method method dictionary' ].

	oldCompiledMethod == newCompiledMethod
		ifTrue: [ 
			"exit early, no more work to be done"
			^ registryInstance ].
	mDict at: selector put: newCompiledMethod.
	GsPackagePolicy current
		updateMethodLookupCacheFor: newCompiledMethod
		in: behavior.

	loadedMethod := registryInstance methodRegistry
		at: oldCompiledMethod
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for the old compiledMethod.' ].
	registryInstance methodRegistry removeKey: oldCompiledMethod.
	loadedMethod handle: newCompiledMethod.
	registryInstance methodRegistry at: newCompiledMethod put: loadedMethod
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
createAndInstallLoadedClassForClass: class toPackageNamed: packageName instance: registryInstance

	"Copy the name association to the correct 
        SymbolDictionary in the live SymbolList.
        Create a LoadedClass for the new class, add it to the defining LoadedPackage."

	| loadedPackage loadedClass |
	loadedPackage := self existingOrNewLoadedPackageNamed: packageName instance: registryInstance.

	registryInstance classRegistry
		at: class classHistory
		ifAbsent: [ 
			loadedClass := RwGsLoadedSymbolDictClass newForClass: class.
			loadedPackage addLoadedClass: loadedClass.
			loadedClass updatePropertiesFromClassFor: registryInstance.
			registryInstance classRegistry at: class classHistory put: loadedClass.
			(loadedPackage loadedClassExtensions at: class name ifAbsent: [  ])
				ifNotNil: [ :loadedClassExtension | 
					"I think we need to subsume the loadedClassExtension methods into a loadedClass ..."
					"have yet to come with a test case that takes this path"
					registryInstance error: 'internal error - unexpected class extenstions for a loaded class ', class name asString printString , ' that has no entry in classRegistry in package ', loadedPackage name printString, '.' ] ].
	^ registryInstance
%

category: 'package - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
createLoadedPackageFromDefinition: packageDefinition instance: registryInstance

	^ self
		createLoadedPackageNamed: packageDefinition key
		properties: packageDefinition properties
		instance: registryInstance
%

category: 'package - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
createLoadedPackageNamed: packageName properties: properties instance: registryInstance 

	| existingLoadedPackage newLoadedPackage |
	existingLoadedPackage := registryInstance packageRegistry at: packageName ifAbsent: [ nil ].
	existingLoadedPackage
		ifNotNil: [ self error: 'Internal error -- Attempt to add a package that exists.' ].
	newLoadedPackage := RwGsLoadedSymbolDictPackage newNamed: packageName.
	newLoadedPackage setPropertiesTo: properties.
	registryInstance packageRegistry at: packageName put: newLoadedPackage.
	^ newLoadedPackage
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteClassFromPackage: class instance: registryInstance

	"a class association is being deleted from the receiver remove it from the loaded things and remove class from system"

	| removeClassFromSystem |
	removeClassFromSystem := RwDeleteClassFromSystemNotification new
		candidateClass: class;
		signal. "handle and `resume: true` if you want class to remain in system, unpackaged"
	^ self _doDeleteClassFromLoadedThings: class removeClassFromSystem: removeClassFromSystem instance: registryInstance
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteClassNamedFromPackage: className instance: registryInstance

	"a class association is being deleted from the receiver remove it from the loaded things"

	| class |
	class := registryInstance _symbolDictionary
		at: className asSymbol
		ifAbsent: [ registryInstance error: 'No class found for the given class name: ' , className printString ].
	^ self deleteClassFromPackage: class instance: registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteCompiledMethod: compiledMethod from: behavior instance: registryInstance

	"delete a compiled method from behavior and remove it from the loaded things"

	self _doDeleteCompiledMethod: compiledMethod from: behavior instance: registryInstance.

	self _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: registryInstance.

	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteMethod: selector for: behavior instance: registryInstance

	| compiledMethod |

	compiledMethod := behavior compiledMethodAt: selector.
	self deleteCompiledMethod: compiledMethod from: behavior instance: registryInstance.
	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteMovedCompiledMethod: compiledMethod from: behavior instance: registryInstance

	"delete a compiled method from behavior - moved method already removed from the loaded things"

	self _doDeleteCompiledMethod: compiledMethod from: behavior instance: registryInstance.

	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteMovedLoadedMethod: selector for: behavior instance: registryInstance

	| compiledMethod |

	compiledMethod := behavior compiledMethodAt: selector.
	self _doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: registryInstance.
	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deleteMovedMethod: selector for: behavior instance: registryInstance

	| compiledMethod |

	compiledMethod := behavior compiledMethodAt: selector.
	self deleteMovedCompiledMethod: compiledMethod from: behavior instance: registryInstance.
	^ registryInstance
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
deletePackage: packageName instance: registryInstance

	| loadedPackage |
	loadedPackage := registryInstance packageRegistry
		removeKey: packageName
		ifAbsent: [ registryInstance error: 'package ' , packageName printString , ' not found' ].
	loadedPackage loadedProject removeLoadedPackage: loadedPackage.
	^ registryInstance
%

category: 'class disown api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
disownClass: class instance: registryInstance

	"Remove the specified class and all of it's packaged instance and class methods from the loaded things."

	self
		_loadedClassFor: class
		noNewVersion: [ :loadedClass | 
			loadedClass disownFromLoaded: registryInstance.
			registryInstance classRegistry removeKey: class classHistory ]
		instance: registryInstance.
	^ registryInstance
%

category: 'class disown api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
disownClassExtensions: class forLoadedPackage: loadedPackage instance: registryInstance

	"Remove the extension methods in the class for the given package"

	| loadedClassExtension |
	loadedClassExtension := loadedPackage
		loadedClassExtensionForClass: class
		ifAbsent: [ self error: 'No class extensions found for the class ', class name asString printString, ' in the package ', loadedPackage name printString ].
	
	loadedClassExtension disownFromLoaded: registryInstance.

	loadedPackage removeLoadedClassExtension: loadedClassExtension.

	^ registryInstance
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
ensureExtensionClassNamed: className existsForPackageNamed: packageName instance: registryInstance

	| extensionClass loadedPackage loadedClassExtension |
	extensionClass := registryInstance _symbolDictionary
		at: className asSymbol
		ifAbsent: [ 
			registryInstance
				error:
					'The extension class named ' , className printString
						, ' cannot be found in this symbol dictionary (' , registryInstance _symbolDictionary name printString
						,
							'). Packages that extend a class must be loaded into the symbol dictionary in which the class is installed.' ].
	loadedPackage := self existingOrNewLoadedPackageNamed: packageName instance: registryInstance.

	loadedPackage
		loadedClassExtensionForClass: extensionClass
		ifAbsent: [ 
			loadedClassExtension := RwGsLoadedSymbolDictClassExtension
				newForClass: extensionClass
				inPackage: loadedPackage.
			(registryInstance classExtensionRegistry
				at: extensionClass classHistory
				ifAbsentPut: [ IdentitySet new ]) add: loadedClassExtension ].
	^ registryInstance
%

category: 'package - creation api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
existingOrNewLoadedPackageNamed: packageName instance: registryInstance

	^ registryInstance packageRegistry
			at: packageName
			ifAbsent: [ 
				registryInstance packageRegistry
					at: packageName
					put: (RwGsLoadedSymbolDictPackage newNamed: packageName) ].
%

category: 'loaded queries'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
loadedHybridPackageNamed: hybridPackageName ifAbsent: absentBlock instance: registryInstance

	| packageName |
	(hybridPackageName at: 1) = $*
		ifFalse: [ 
			registryInstance
				error:
					'Improperly formed hybrid package name' , hybridPackageName printString
						, '. Expected a leading ''*''' ].
	packageName := (hybridPackageName copyFrom: 2 to: hybridPackageName size)
		asLowercase.
	registryInstance packageRegistry keys
		do: [ :key | 
			key asLowercase = packageName
				ifTrue: [ ^ registryInstance packageRegistry at: key ] ].
	^ absentBlock value
%

category: 'loaded queries'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
loadedPackageNamed: packageName ifAbsent: absentBlock instance: registryInstance

	^ registryInstance packageRegistry at: packageName ifAbsent: absentBlock
%

category: 'class symbol dict - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
moveClassFor: classMove
	" move class from <oldRegistry> to <newRegistry> which includes moveing the loaded methods associated with the class"

	"loaded things are handled elsewhere, just need to update the various registries ... and move the association"

	"extension methods will be dealt with later"

	| originalSymbolDictionary newSymbolDictionary before assoc theClass loadedClass theBehavior oldRegistry newRegistry |

	before := classMove classBefore.
	originalSymbolDictionary := Rowan globalNamed: before gs_symbolDictionary.
	assoc := originalSymbolDictionary associationAt: before key asSymbol.
	theClass := assoc value.
	theBehavior := theClass class.
	oldRegistry := originalSymbolDictionary rowanSymbolDictionaryRegistry.

	newSymbolDictionary := Rowan globalNamed: ((classMove projectAfter specification platformSpec at: 'gemstone')
				symbolDictNameForPackageNamed: classMove packageAfter name) .
	newRegistry := newSymbolDictionary rowanSymbolDictionaryRegistry.

	loadedClass := oldRegistry classRegistry removeKey: theClass classHistory.
	originalSymbolDictionary removeKey: assoc key.

	self 
		_symbolDictionary: newSymbolDictionary 
		at: assoc key 
		ifPresent: [:class |
			theClass ~~ class
				ifTrue: [ self error: ' internal error - found an existing association in the ',  
								newSymbolDictionary name asString printString, 
								' symbol dictionary with a duplicate key ',
								assoc key printString, 
								' while attempting to move class ', assoc key asString printString ] ]
		ifAbsent: [ newSymbolDictionary add: assoc ].

	newRegistry classRegistry at: theClass classHistory put: loadedClass.

	loadedClass loadedInstanceMethods values do: [:loadedMethod |
		| compiledMethod |
		compiledMethod := theClass compiledMethodAt: loadedMethod selector asSymbol.
		oldRegistry methodRegistry removeKey: compiledMethod.
		newRegistry methodRegistry at: compiledMethod put: loadedMethod ].
	loadedClass loadedClassMethods values do: [:loadedMethod |
		| compiledMethod |
		compiledMethod := theBehavior compiledMethodAt: loadedMethod selector asSymbol.
		oldRegistry methodRegistry removeKey: compiledMethod.
		newRegistry methodRegistry at: compiledMethod put: loadedMethod ].
%

category: 'method - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
movePackage: packageName to: symbolDictionaryName instance: fromRegistryInstance

	| loadedPackage toRegistryInstance |
	loadedPackage := fromRegistryInstance packageRegistry
		removeKey: packageName
		ifAbsent: [ fromRegistryInstance error: 'package ' , packageName printString , ' not found' ].
	toRegistryInstance := (Rowan image newOrExistingSymbolDictionaryNamed: symbolDictionaryName) rowanSymbolDictionaryRegistry.
	(toRegistryInstance packageRegistry at: packageName ifAbsent: [])
		ifNotNil: [:unexpectedLoadedPackage | toRegistryInstance error: 'package ', packageName printString, ' unexpectedly found in ', symbolDictionaryName printString ].
	toRegistryInstance packageRegistry at: packageName put: loadedPackage.
	^ fromRegistryInstance
%

category: 'package - creation api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
newLoadedPackageNamed: packageName instance: registryInstance

	(registryInstance packageRegistry includesKey: packageName)
		ifTrue: [ registryInstance error: 'The package ', packageName printString, ' already exists' ].
	^ registryInstance existingOrNewLoadedPackageNamed: packageName implementationClass: self
%

category: 'class - patch api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
updateClassProperties: class instance: registryInstance

	"class properties have changed, update the clas properties of the loaded things"

	(class isKindOf: Class)
		ifFalse: [ registryInstance error: 'internal error - expected a class' ].
	registryInstance
		_loadedClassFor: class
		noNewVersion: [ :loadedClass | 
			"association for class is present, update the loaded thing"
			loadedClass updatePropertiesFromClassFor: registryInstance ].
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_clearLookupCachesFor: aBehavior env: envId

"Invalidates method lookup caches for all classes.
 Invalidates all send-site caches for the specified environment.

 envId must be a SmallInteger >= 0 and <= 255 .
"

 "set bit in VM's cbCodeChanged word so it can propagate to
  other VMs upon commit.  Code which adds or removes entries
  in persistent method dictionaries must send this method. "

	aBehavior 
		_clearLookupCaches: envId;
		_codeChangedForEnv: envId
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_doDeleteClassFromLoadedThings: class removeClassFromSystem: removeClassFromSystem instance: registryInstance

	"a class association is being deleted from the receiver remove it from the loaded things. Conditionally remove class from system"

	self
		_loadedClassFor: class
		noNewVersion: [ :loadedClass | 
			"association for class is present, finish delete operation"
			loadedClass removeFromLoaded: registryInstance.
			registryInstance classRegistry removeKey: class classHistory.
			removeClassFromSystem ifTrue: [ registryInstance _symbolDictionary removeKey: loadedClass key asSymbol ] ]
		instance: registryInstance.
	^ registryInstance
%

category: 'method - private api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_doDeleteCompiledMethod: compiledMethod from: behavior instance: registryInstance

	"delete a compiled method from behavior"

	| selector |
	selector := compiledMethod selector.
	behavior removeSelector: selector asString environmentId: 0.

	^ registryInstance
%

category: 'method - private api'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_doDeleteCompiledMethodFromLoadedThings: compiledMethod for: behavior instance: registryInstance

	"remove a compiled method from loaded things"

	| loadedMethod loadedPackage loadedClassOrExtension |
	loadedMethod := registryInstance methodRegistry
		at: compiledMethod
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for deleted method.' ].

	registryInstance methodRegistry removeKey: compiledMethod.

	loadedPackage := loadedMethod loadedPackage.
	loadedClassOrExtension := loadedPackage
		classOrExtensionForClass: behavior
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- attempt to remove a method from a package in which its class is neither defined nor extended.' ].

	loadedClassOrExtension removeLoadedMethod: loadedMethod.
	loadedClassOrExtension isLoadedClassExtension
		ifTrue: [
			loadedClassOrExtension isEmpty
				ifTrue: [ 
					| theKey classExtensionRegistry |
					theKey := loadedClassOrExtension handle classHistory.
					classExtensionRegistry := registryInstance classExtensionRegistry.
					(classExtensionRegistry at: theKey) remove: loadedClassOrExtension.
					(classExtensionRegistry at: theKey) isEmpty
						ifTrue: [ classExtensionRegistry removeKey: theKey ].
					loadedPackage removeLoadedClassExtension: loadedClassOrExtension ] ].

	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_loadedClassExtensionsFor: class noNewVersion: noNewVersionBlock newVersion: newVersionBlock instance: registryInstance
	| loadedClassExtensionSet |
	(class isKindOf: Class)
		ifFalse: [ registryInstance error: 'internal error - expected a class' ].
	loadedClassExtensionSet := registryInstance classExtensionRegistry
		at: class classHistory
		ifAbsent: [ 
			"we're done here"
			^ self ].
	loadedClassExtensionSet
		do: [ :loadedClassExtension | 
			| classKey |
			classKey := loadedClassExtension key asSymbol.
			self
				_symbolDictionary: registryInstance _symbolDictionary
				associationAt: classKey
				ifPresent: [ :assoc | 
					assoc value == loadedClassExtension handle
						ifTrue: [ ^ noNewVersionBlock cull: loadedClassExtension ]
						ifFalse: [ ^ newVersionBlock cull: loadedClassExtension ] ] ]
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_loadedClassFor: class noNewVersion: noNewVersionBlock instance: registryInstance

	self
		_loadedClassFor: class
		noNewVersion: noNewVersionBlock
		newVersion: [ :loadedClass | 
			self
				error:
					'internal error - the value associated with the key ' , class name printString
						, ' is not identical to the given class' ]
		instance: registryInstance.
	^ registryInstance
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_loadedClassFor: class noNewVersion: noNewVersionBlock newVersion: newVersionBlock instance: registryInstance

	| loadedClass classKey |
	(class isKindOf: Class)
		ifFalse: [ registryInstance error: 'internal error - expected a class' ].
	loadedClass := registryInstance classRegistry
		at: class classHistory
		ifAbsent: [ 
			registryInstance
				error:
					'internal error - No package found for the class ' , class name printString ].
	classKey := loadedClass key asSymbol.
	self
		_symbolDictionary: registryInstance _symbolDictionary
		associationAt: classKey
		ifPresent: [ :assoc | 
			assoc value == class
				ifTrue: [ ^ noNewVersionBlock cull: loadedClass cull: assoc ]
				ifFalse: [ ^ newVersionBlock cull: loadedClass cull: assoc ] ].

	registryInstance
		error:
			'internal error - there is no assocation present in the receiver for the given class '
				, classKey asString printString
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_symbolDictionary: symbolDictionary associationAt: aKey ifPresent: oneArgBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the symbol association associated with the key, otherwise answer nil."

	| anAssoc |
	anAssoc := symbolDictionary associationAt: aKey otherwise: nil.
	anAssoc ifNotNil: [ ^ oneArgBlock cull: anAssoc ].
	^ nil
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_symbolDictionary: symbolDictionary associationAt: key ifPresent: oneArgBlock ifAbsent: absentBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the symbol association associated with the key, otherwise answer the value of absentBlock."

	self
		_symbolDictionary: symbolDictionary 
		associationAt: key
		ifPresent: [ :v | ^ oneArgBlock cull: v ].
	^ absentBlock value
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_symbolDictionary: symbolDictionary at: key ifPresent: oneArgBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."

	| v |
	v := symbolDictionary at: key ifAbsent: [ ^ nil ].
	^ oneArgBlock cull: v
%

category: 'private'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_symbolDictionary: symbolDictionary at: key ifPresent: oneArgBlock ifAbsent: absentBlock

	"Lookup the given key in the receiver's symbolDictionary. If it is present, answer the value of evaluating the oneArgBlock with the value associated with the key, otherwise answer the value of absentBlock."

	| v |
	v := symbolDictionary at: key ifAbsent: [ ^absentBlock value ].
	^ oneArgBlock cull: v
%

! Class implementation for 'RwLoadedThing'

!		Class methods for 'RwLoadedThing'

category: 'accessing'
classmethod: RwLoadedThing
absentToken

	^AbsentToken
%

category: 'class initialization'
classmethod: RwLoadedThing
initialize
  "RwLoadedThing initialize"

  AbsentToken := '<absent>'
%

category: 'instance creation'
classmethod: RwLoadedThing
newNamed: aName

	^(self new)
		initialize;
		initializeForName: aName;
		yourself
%

!		Instance methods for 'RwLoadedThing'

category: 'accessing'
method: RwLoadedThing
absentToken

	^AbsentToken
%

category: 'private'
method: RwLoadedThing
definitionsFor: loadedThings

	| result |
	result := Dictionary new: loadedThings size.
	loadedThings
		do: [:loadedThing | result at: loadedThing key put: loadedThing asDefinition].
	^result
%

category: 'accessing'
method: RwLoadedThing
handle
	"Answer a reference to the platform-specific image object for which I hold information."

	^handle
%

category: 'accessing'
method: RwLoadedThing
handle: anObject
	"Set my reference to the platform-specific image object for which I hold information."

	self markPackageDirty.
	handle := anObject
%

category: 'initialization'
method: RwLoadedThing
initialize

	properties := Dictionary new
%

category: 'initialization'
method: RwLoadedThing
initializeForName: aName

	name := aName
%

category: 'accessing'
method: RwLoadedThing
loadedPackage

	^ self subclassResponsibility: #'loadedPackage'
%

category: 'accessing'
method: RwLoadedThing
loadedProject

	^ self loadedPackage loadedProject
%

category: 'accessing'
method: RwLoadedThing
name

	^name
%

category: 'accessing'
method: RwLoadedThing
name: aString

	self markPackageDirty.
	name := aString
%

category: 'printing'
method: RwLoadedThing
printOn: aStream

	super printOn: aStream.
	name
		ifNotNil: 
			[aStream
				space;
				nextPutAll: name]
%

category: 'private'
method: RwLoadedThing
propertiesForDefinition

	^properties copy
%

category: 'accessing'
method: RwLoadedThing
propertyAt: propertyName

	^properties at: propertyName ifAbsent: [AbsentToken]
%

category: 'accessing'
method: RwLoadedThing
propertyAt: propertyName ifAbsent: aBlock

	^properties at: propertyName ifAbsent: aBlock
%

category: 'accessing'
method: RwLoadedThing
propertyAt: propertyName put: aValue
	"Value should be a string"

	self markPackageDirty.
	^properties at: propertyName put: aValue
%

category: 'accessing'
method: RwLoadedThing
removeProperty: propertyName

	self markPackageDirty.
	^properties removeKey: propertyName ifAbsent: [AbsentToken]
%

category: 'accessing'
method: RwLoadedThing
setPropertiesTo: aDictionary

	properties := aDictionary copy
%

! Class implementation for 'RwLoadedClass'

!		Instance methods for 'RwLoadedClass'

category: 'definitions'
method: RwLoadedClass
asDefinition
	"Create a Definition corresponding to what I define in the image."
	^RwClassDefinition
		withProperties: self propertiesForDefinition
		classMethodDefinitions: self classMethodDefinitions
		instanceMethodDefinitions: self instanceMethodDefinitions
%

category: 'private'
method: RwLoadedClass
classMethodDefinitions

	^self definitionsFor: loadedClassMethods
%

category: 'testing'
method: RwLoadedClass
includesSelector: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods includesKey: aSelector ]
		ifFalse: [ loadedInstanceMethods includesKey: aSelector ]
%

category: 'private'
method: RwLoadedClass
instanceMethodDefinitions

	^self definitionsFor: loadedInstanceMethods
%

category: 'testing'
method: RwLoadedClass
isEmpty

	^loadedInstanceMethods isEmpty and: [loadedClassMethods isEmpty]
%

category: 'testing'
method: RwLoadedClass
isLoadedClass

	^ true
%

category: 'testing'
method: RwLoadedClass
isLoadedClassExtension

	^ false
%

category: 'accessing'
method: RwLoadedClass
loadedClassMethods

	^ loadedClassMethods
%

category: 'accessing'
method: RwLoadedClass
loadedInstanceMethods 

	^ loadedInstanceMethods
%

category: 'enumeration'
method: RwLoadedClass
loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedInstanceMethods
		valuesDo: [ :loadedMethod | 
			loadedInstanceMethodBlock
				cull:  self loadedProject
				cull: self loadedPackage
				cull: self 
				cull: loadedMethod
				
	].
	loadedClassMethods
		valuesDo: [ :loadedMethod | 
			loadedClassMethodBlock
				cull: self loadedProject
				cull: self loadedPackage
				cull: self 
				cull: loadedMethod
	]
%

category: 'testing'
method: RwLoadedClass
loadedMethodAt: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods at: aSelector ifAbsent: [nil]]
		ifFalse: [ loadedInstanceMethods at: aSelector ifAbsent: [nil] ]
%

category: 'accessing'
method: RwLoadedClass
loadedPackage

	^loadedPackage
%

category: 'accessing'
method: RwLoadedClass
loadedPackage: aLoadedPackage

	loadedPackage := aLoadedPackage
%

category: 'private'
method: RwLoadedClass
markPackageDirty

	loadedPackage markDirty
%

category: 'accessing'
method: RwLoadedClass
packageName

	^loadedPackage name
%

! Class implementation for 'RwGsLoadedSymbolDictClass'

!		Class methods for 'RwGsLoadedSymbolDictClass'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictClass
newForClass: aClass

	^self new initializeForClass: aClass
%

!		Instance methods for 'RwGsLoadedSymbolDictClass'

category: 'methods'
method: RwGsLoadedSymbolDictClass
addLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
addLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
addLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self addLoadedClassMethod: aLoadedMethod]
		ifFalse: [self addLoadedInstanceMethod: aLoadedMethod]
%

category: 'removing'
method: RwGsLoadedSymbolDictClass
disownFromLoaded: aPackageSymbolDictionary

	loadedInstanceMethods
		valuesDo: [ :loadedInstanceMethod | 
			self removeLoadedInstanceMethod: loadedInstanceMethod.
			aPackageSymbolDictionary methodRegistry
				removeKey: loadedInstanceMethod handle ].
	loadedClassMethods
		valuesDo: [ :loadedClassMethod | 
			self removeLoadedClassMethod: loadedClassMethod.
			aPackageSymbolDictionary methodRegistry removeKey: loadedClassMethod handle ].
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
handleClassDeletion

	"The class to which I refer has been deleted, so I must unregister myself.
	Normally, I will have a loadedPackage, but if something interrupted my initialization it might be nil."

	GsPackagePolicy currentOrNil
		ifNotNil: [ :pp | 
			pp
				removeAllMethodsFor: handle;
				removeAllMethodsFor: handle class ].
	(Rowan image loadedClassExtensionsForClass: handle)
		do: [ :loadedClassExtension | loadedClassExtension handleClassDeletion ].
	Rowan image removeLoadedClassExtensionsForClass: handle.
	self loadedPackage removeLoadedClass: self
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
handleClassDeletionOrNewVersion

	"The class is deleted if both:
	* its name no longer resolves to a class in the classHistory of the class I remember.
	* no class in the classHistory of the class I remember is accessible under its name.
	If my name no longer resolves to my class, but another class in its classHistory does resolve,
	consider it a class re-version or rename.
	Answer true if the class still exists, false if it has been deleted."

	| resolved thoseResolving |
	resolved := Rowan image resolveClassNamed: name.
	resolved == handle
		ifTrue: [ ^ true ].	"Has been deleted, renamed, or a new version under the same name.
	Answer false if deleted, set handle and answer true otherwise."
	thoseResolving := handle classHistory reverse
		select: [ :aClass | aClass == (Rowan image resolveClassNamed: aClass name) ].
	thoseResolving size = 0
		ifTrue: [ 
			self handleClassDeletion.
			^ false ].
	thoseResolving size > 1
		ifTrue: [ 
			RwNotification
				signal:
					'Class history with multiple "current" members found. One associated name is '
						, name ].
	handle := thoseResolving first.
	^ true
%

category: 'initialization'
method: RwGsLoadedSymbolDictClass
initialize

	super initialize.
	loadedInstanceMethods := KeyValueDictionary new.
	loadedClassMethods := KeyValueDictionary new
%

category: 'initialization'
method: RwGsLoadedSymbolDictClass
initializeForClass: aClass

	self initialize.
	self initializeForName: aClass name asString.
	handle := aClass
%

category: 'initialization'
method: RwGsLoadedSymbolDictClass
initializeForName: aClassName

	super initializeForName: aClassName.
	properties at: 'name' put: aClassName
%

category: 'accessing'
method: RwGsLoadedSymbolDictClass
key
	"Answer some token that will uniquely identify me relative to any other LoadedClass in the same package."

	^name
%

category: 'removing'
method: RwGsLoadedSymbolDictClass
removeFromLoaded: aPackageSymbolDictionary

	self disownFromLoaded: aPackageSymbolDictionary.
	self handleClassDeletion
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
removeLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in loadedClass']
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
removeLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in loadedClass']
%

category: 'methods'
method: RwGsLoadedSymbolDictClass
removeLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self removeLoadedClassMethod: aLoadedMethod]
		ifFalse: [self removeLoadedInstanceMethod: aLoadedMethod]
%

category: 'private'
method: RwGsLoadedSymbolDictClass
symbolDictionaryName: aName

	self propertyAt: 'gs_SymbolDictionary' put: aName asString
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateCategoryFromClass

	| propertyName oldValue newValue absentToken |
	propertyName := 'category'.
	absentToken := self absentToken.
	oldValue := self propertyAt: propertyName.
	newValue := handle _classCategory ifNil: [ absentToken ].
	(newValue ~~ absentToken and: [ newValue isEmpty ])
		ifTrue: [ newValue := absentToken ].	"Absent token must be compared by identity, because a comment of '<absent>' would be equal to no comment."
	(oldValue == absentToken | (newValue == absentToken)
		ifTrue: [ oldValue == newValue ]
		ifFalse: [ oldValue = newValue ])
		ifFalse: [ 
			newValue == absentToken
				ifTrue: [ self removeProperty: propertyName ]
				ifFalse: [ self propertyAt: propertyName put: newValue ] ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassInstvarNamesFromClass
	"Order of instvars does not matter to Cypress (at least not in GemStone) so we keep the instvar names sorted."

	| propertyName oldNames newNames |
	propertyName := 'classinstvars'.
	oldNames := self propertyAt: propertyName.
	newNames := handle class instVarNames collect: [:each | each asString].
	oldNames = newNames ifFalse: [self propertyAt: propertyName put: newNames]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassNameFromClass

	| oldName newName |
	oldName := name.
	newName := handle name asString.
	oldName = newName
		ifFalse: 
			[self name: newName.
			self propertyAt: 'name' put: name]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassTypeFromClass
	"For GemStone, the valid values are:
	bytes
	variable
	normal for non-indexable pointer object"

	"Must be in-synch with RwGsClassCreationPatch>>basicCreateClassFor:"

	| propertyName oldValue newValue |
	propertyName := 'type'.
	oldValue := self propertyAt: propertyName.
	newValue := handle isBytes
						ifTrue: [
							handle superClass isBytes not
								ifTrue: [ 'bytes' ]
								ifFalse: [ 'normal' ]]
						ifFalse: [ 
							handle isSpecial
								ifTrue: [ 'immediate' ]
								ifFalse: 
									[ handle isNsc
										ifTrue: [ 'normal' ]
										ifFalse:  [
											(handle isVariable and: [handle superClass isVariable not])
												ifTrue: [ 'variable' ]
												ifFalse: [ 'normal' ] ] ] ].

	oldValue = newValue
		ifFalse: 
			[ self propertyAt: propertyName put: newValue ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateClassVariableNamesFromClass
	"Order of variable names does not matter to Cypress (at least not for GemStone) so we keep the names sorted."

	| propertyName oldNames newNames |
	propertyName := 'classvars'.
	oldNames := self propertyAt: propertyName.
	newNames := (handle classVarNames collect: [:each | each asString])
				asSortedCollection asArray.
	oldNames = newNames ifFalse: [self propertyAt: propertyName put: newNames]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateCommentFromClass

	| propertyName oldValue newValue absentToken |
	propertyName := 'comment'.
	absentToken := self absentToken.
	oldValue := self propertyAt: propertyName.
	(oldValue ~~ absentToken and: [oldValue isEmpty])
		ifTrue: [oldValue := absentToken].
	newValue := (handle _extraDictAt: #comment) ifNil: [absentToken].
	(newValue ~~ absentToken and: [newValue isEmpty])
		ifTrue: [newValue := absentToken].

	"Absent token must be compared by identity, because a comment of '<absent>' would be equal to no comment."
	(oldValue == absentToken | (newValue == absentToken)
		ifTrue: [oldValue == newValue]
		ifFalse: [oldValue = newValue])
			ifFalse: 
				[newValue == absentToken
					ifTrue: [self removeProperty: propertyName]
					ifFalse: [self propertyAt: propertyName put: newValue]]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateConstraintsFromClass
	| propertyName oldValue newValue sortedConstraints |
	propertyName := 'gs_constraints'.
	oldValue := self propertyAt: propertyName.
	sortedConstraints := handle _rwSortedConstraints.
	(sortedConstraints isKindOf: Array ) 
		ifTrue: [
			newValue := (sortedConstraints collect: [:ar | 
					(ar isKindOf: Array )
						ifTrue: [ {(ar at: 1) asString . (ar at: 2) name asString } ]
						ifFalse: [ 
							"varyingConstraint"
							ar name asString ] ]) asArray.
			newValue isEmpty ifTrue: [newValue := self absentToken] ]
		ifFalse: [
			newValue :=  sortedConstraints 
				ifNil: [ self absentToken ]
				ifNotNil: [ sortedConstraints ] ].

	"Since the absent token is not equal to any other valid value, we can skip the identity check in this case."
	oldValue = newValue
		ifFalse: 
			[newValue == self absentToken
				ifTrue: [self removeProperty: propertyName]
				ifFalse: [self propertyAt: propertyName put: newValue]]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateInstvarNamesFromClass
	"Order of instvars does not matter to Cypress (at least not in GemStone) so we keep the instvar names sorted."

	| propertyName oldNames newNames |
	propertyName := 'instvars'.
	oldNames := self propertyAt: propertyName.
	newNames := handle instVarNames collect: [:each | each asString].
	oldNames = newNames ifFalse: [self propertyAt: propertyName put: newNames]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateOptionsFromClass
	"Options are GemStone-specific. If the class has no options, the property is absent.
	Otherwise, the property is a sorted array of strings. The valid values are:

	dbTransient
	disallowGciStore
	instancesInvariant
	instancesNonPersistent
	modifiable
	subclassesDisallowed
	traverseByCallback

	Not all combinations are legal, but we don't have to worry about that here, since we're getting the values
	from the image, and the image is trusted to only have valid values."

	| propertyName oldValue newValue |
	propertyName := 'gs_options'.
	oldValue := self propertyAt: propertyName.
	newValue := (handle _rwOptionsArray collect: [:option | option asString])
				asSortedCollection asArray.
	newValue isEmpty ifTrue: [newValue := self absentToken].

	"Since the absent token is not equal to any other valid value, we can skip the identity check in this case."
	oldValue = newValue
		ifFalse: 
			[newValue == self absentToken
				ifTrue: [self removeProperty: propertyName]
				ifFalse: [self propertyAt: propertyName put: newValue]]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updatePoolDictionaryNamesFromClass
	"Order of pool dictionaries *does* matter in GemStone, so we keep the names in the order given in the image."

	| propertyName oldNames newNames |
	propertyName := 'pools'.
	oldNames := self propertyAt: propertyName.
	newNames := (handle sharedPools collect: [ :each | each name asString ])
		asArray.
	oldNames = newNames
		ifFalse: [ self propertyAt: propertyName put: newNames ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updatePropertiesFromClassFor: aSymbolDictionaryRegistry

	"Update my properties from the class. Leave unknown properties alone, they may apply to another platform."

	self
		updateSymbolDictionaryFromClassFor:
				aSymbolDictionaryRegistry _symbolDictionary;
		updateClassNameFromClass;
		updateSuperclassNameFromClass;
		updateInstvarNamesFromClass;
		updateClassInstvarNamesFromClass;
		updateClassVariableNamesFromClass;
		updatePoolDictionaryNamesFromClass;
		updateClassTypeFromClass;
		updateOptionsFromClass;
		updateConstraintsFromClass;
		updateCommentFromClass;
		updateCategoryFromClass
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateSuperclassNameFromClass
  | oldName newName |
  oldName := self propertyAt: 'superclass'.
  newName := handle superclass
    ifNil: [ 'nil' ]
    ifNotNil: [ :superclass | superclass name asString ].
  oldName = newName
    ifFalse: [ self propertyAt: 'superclass' put: newName ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClass
updateSymbolDictionaryFromClassFor: aSymbolDictionary

	| newName oldName |
	newName := aSymbolDictionary name.
	oldName := self propertyAt: 'gs_SymbolDictionary'.
	oldName = newName
		ifFalse: [ self symbolDictionaryName: newName ]
%

! Class implementation for 'RwLoadedClassExtension'

!		Instance methods for 'RwLoadedClassExtension'

category: 'definitions'
method: RwLoadedClassExtension
asDefinition
	"Create a Definition corresponding to what I define in the image."
	^RwClassExtensionDefinition
		withProperties: self propertiesForDefinition
		classMethodDefinitions: self classMethodDefinitions
		instanceMethodDefinitions: self instanceMethodDefinitions
%

category: 'private'
method: RwLoadedClassExtension
classMethodDefinitions

	^self definitionsFor: loadedClassMethods
%

category: 'testing'
method: RwLoadedClassExtension
includesSelector: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods includesKey: aSelector ]
		ifFalse: [ loadedInstanceMethods includesKey: aSelector ]
%

category: 'private'
method: RwLoadedClassExtension
instanceMethodDefinitions

	^self definitionsFor: loadedInstanceMethods
%

category: 'testing'
method: RwLoadedClassExtension
isEmpty

	^loadedInstanceMethods isEmpty and: [loadedClassMethods isEmpty]
%

category: 'testing'
method: RwLoadedClassExtension
isLoadedClass

	^ false
%

category: 'testing'
method: RwLoadedClassExtension
isLoadedClassExtension

	^ true
%

category: 'accessing'
method: RwLoadedClassExtension
loadedClassMethods

	^ loadedClassMethods
%

category: 'accessing'
method: RwLoadedClassExtension
loadedInstanceMethods 

	^ loadedInstanceMethods
%

category: 'enumeration'
method: RwLoadedClassExtension
loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedInstanceMethods
		valuesDo: [ :loadedMethod | 
			loadedInstanceMethodBlock
				cull: self loadedProject 
				cull: self loadedPackage
				cull: self 
				cull: loadedMethod
				
	].
	loadedClassMethods
		valuesDo: [ :loadedMethod | 
			loadedClassMethodBlock
				cull: self loadedProject
				cull: self loadedPackage
				cull: self 
				cull: loadedMethod 
				
	].
%

category: 'private'
method: RwLoadedClassExtension
loadedMethodAt: aSelector isMeta: isMeta

	^ isMeta
		ifTrue: [ loadedClassMethods at: aSelector ifAbsent: [nil]]
		ifFalse: [ loadedInstanceMethods at: aSelector ifAbsent: [nil] ]
%

category: 'accessing'
method: RwLoadedClassExtension
loadedPackage

	^loadedPackage
%

category: 'accessing'
method: RwLoadedClassExtension
loadedPackage: aLoadedPackage

	loadedPackage := aLoadedPackage
%

category: 'private'
method: RwLoadedClassExtension
markPackageDirty

	loadedPackage markDirty
%

category: 'accessing'
method: RwLoadedClassExtension
packageName

	^loadedPackage name
%

! Class implementation for 'RwGsLoadedSymbolDictClassExtension'

!		Class methods for 'RwGsLoadedSymbolDictClassExtension'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictClassExtension
newForClass: aClass inPackage: aLoadedPackage

	^ self new initializeForClass: aClass inPackage: aLoadedPackage
%

!		Instance methods for 'RwGsLoadedSymbolDictClassExtension'

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
addLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
addLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods at: aLoadedMethod key put: aLoadedMethod.
	aLoadedMethod loadedClass: self
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
addLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self addLoadedClassMethod: aLoadedMethod]
		ifFalse: [self addLoadedInstanceMethod: aLoadedMethod]
%

category: 'removing'
method: RwGsLoadedSymbolDictClassExtension
disownFromLoaded: aPackageSymbolDictionary

	loadedInstanceMethods
		valuesDo: [ :loadedInstanceMethod | 
			self removeLoadedInstanceMethod: loadedInstanceMethod.
			aPackageSymbolDictionary methodRegistry
				removeKey: loadedInstanceMethod handle ].
	loadedClassMethods
		valuesDo: [ :loadedClassMethod | 
			self removeLoadedClassMethod: loadedClassMethod.
			aPackageSymbolDictionary methodRegistry removeKey: loadedClassMethod handle ].

	(aPackageSymbolDictionary classExtensionRegistry at: handle classHistory) remove: self.
	(aPackageSymbolDictionary classExtensionRegistry at: handle classHistory) isEmpty
		ifTrue: [ aPackageSymbolDictionary classExtensionRegistry removeKey: handle classHistory ].
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClassExtension
handleClassDeletion

	"The class to which I refer is or has been deleted. Clean up the loaded extension methods.
		I expect the caller to remove me from the registry."

	loadedInstanceMethods values , loadedClassMethods values
		do: [ :loadedMethod | loadedMethod handleClassDeletion ].
	self loadedPackage removeLoadedClassExtension: self
%

category: 'private-updating'
method: RwGsLoadedSymbolDictClassExtension
handleClassDeletionOrNewVersion
	"The class is deleted if both:
	* its name no longer resolves to a class in the classHistory of the class I remember.
	* no class in the classHistory of the class I remember is accessible under its name.
	If my name no longer resolves to my class, but another class in its classHistory does resolve,
	consider it a class re-version or rename.
	Answer true if the class still exists, false if it has been deleted."

	| resolved thoseResolving |
	resolved := Rowan image resolveClassNamed: name.
	resolved == handle
		ifTrue: [ ^ true ].	"Has been deleted, renamed, or a new version under the same name.
	Answer false if deleted, set handle and answer true otherwise."
	thoseResolving := handle classHistory reverse
		select: [ :aClass | aClass == (Rowan image resolveClassNamed: aClass name) ].
	thoseResolving size = 0
		ifTrue: [ 
			self handleClassDeletion.
			^ false ].
	thoseResolving size > 1
		ifTrue: [ 
			RwNotification
				signal:
					'Class history with multiple "current" members found. One associated name is '
						, name ].
	handle := thoseResolving first.
	^ true
%

category: 'initialization'
method: RwGsLoadedSymbolDictClassExtension
initialize

	super initialize.
	loadedInstanceMethods := KeyValueDictionary new.
	loadedClassMethods := KeyValueDictionary new
%

category: 'initialization'
method: RwGsLoadedSymbolDictClassExtension
initializeForClass: aClass inPackage: aLoadedPackage

	self initialize.
	name := aClass name asString.
	handle := aClass.
	aLoadedPackage addLoadedClassExtension: self.
	self propertyAt: 'name' put: name
%

category: 'accessing'
method: RwGsLoadedSymbolDictClassExtension
key
	"Answer some token that will uniquely identify me relative to any other LoadedExtendedClass in the same package."

	^name
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
removeLoadedClassMethod: aLoadedMethod

	self markPackageDirty.
	loadedClassMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in LoadedClassExtension']
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
removeLoadedInstanceMethod: aLoadedMethod

	self markPackageDirty.
	loadedInstanceMethods removeKey: aLoadedMethod key
		ifAbsent: [self error: 'Method not present in LoadedClassExtension']
%

category: 'methods'
method: RwGsLoadedSymbolDictClassExtension
removeLoadedMethod: aLoadedMethod

	aLoadedMethod classIsMeta
		ifTrue: [self removeLoadedClassMethod: aLoadedMethod]
		ifFalse: [self removeLoadedInstanceMethod: aLoadedMethod]
%

! Class implementation for 'RwLoadedMethod'

!		Instance methods for 'RwLoadedMethod'

category: 'definitions'
method: RwLoadedMethod
asDefinition
	"Create a Definition corresponding to what I define in the image."

	^RwMethodDefinition withProperties: self propertiesForDefinition
		source: self source
%

category: 'accessing'
method: RwLoadedMethod
classIsMeta

	^classIsMeta
%

category: 'accessing'
method: RwLoadedMethod
classIsMeta: aBoolean

	classIsMeta := aBoolean
%

category: 'queries'
method: RwLoadedMethod
loadedClass

	^loadedClass
%

category: 'accessing'
method: RwLoadedMethod
loadedClass: aLoadedClass

	loadedClass := aLoadedClass
%

category: 'queries'
method: RwLoadedMethod
loadedPackage

	^self loadedClass loadedPackage
%

category: 'private'
method: RwLoadedMethod
markPackageDirty
	"LoadedClass may still be nil if we're creating a new LoadedMethod."

	loadedClass ifNotNil: [loadedClass markPackageDirty]
%

category: 'definitions'
method: RwLoadedMethod
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at: 'selector' put: name.
	^props
%

category: 'accessing'
method: RwLoadedMethod
selector

	^ properties at: 'selector'
%

category: 'accessing'
method: RwLoadedMethod
source

	self subclassResponsibility
%

! Class implementation for 'RwGsLoadedSymbolDictMethod'

!		Class methods for 'RwGsLoadedSymbolDictMethod'

category: 'instance creation'
classmethod: RwGsLoadedSymbolDictMethod
forMethod: aGsNMethod

	| instance |
	instance := self newNamed: aGsNMethod selector.
	instance
		handle: aGsNMethod;
		updateFromHandle.
	^ instance
%

!		Instance methods for 'RwGsLoadedSymbolDictMethod'

category: 'private'
method: RwGsLoadedSymbolDictMethod
definingPackageOfClass

	^loadedClass loadedPackage
%

category: 'private-updating'
method: RwGsLoadedSymbolDictMethod
handleClassDeletion

	"The class to which I refer has been deleted, so I must unregister myself."

	Rowan image removeLoadedMethodForCompileMethod: handle
%

category: 'accessing'
method: RwGsLoadedSymbolDictMethod
key

	"Answer some token that will uniquely identify me relative to any other LoadedMethod in the same LoadedClass."

	^ name	"This is inadequate because the same selector can be defined in both class and metaclass?"
%

category: 'printing'
method: RwGsLoadedSymbolDictMethod
printOn: aStream

	super printOn: aStream.
	name
		ifNotNil: 
			[aStream
				space;
				nextPutAll: handle inClass printString, ' ( ', handle inClass asOop asString, ' )' ]
%

category: 'accessing'
method: RwGsLoadedSymbolDictMethod
source

	^handle sourceString copy
%

category: 'private-updating'
method: RwGsLoadedSymbolDictMethod
updateForProtocolChange
	"Check to see whether I'm in a different protocol. If I am, that could change which package I'm in and I need to update that."

	| oldProtocol newProtocol |
	oldProtocol := self propertyAt: 'protocol'.
	newProtocol := (handle inClass categoryOfSelector: handle selector)
				asString.

	"Must test for AbsentToken by identity, or a new protocol of '<absent>' would not  be detected."
	oldProtocol == AbsentToken | (oldProtocol ~= newProtocol)
		ifTrue: [	self propertyAt: 'protocol' put: newProtocol ]
%

category: 'private-updating'
method: RwGsLoadedSymbolDictMethod
updateFromHandle

	"update method properties: selector and protocol, and classIsMeta"

	self updateForProtocolChange.
	self propertyAt: 'selector' put: handle selector asSymbol.
	classIsMeta := handle inClass isMeta
%

! Class implementation for 'RwLoadedPackage'

!		Instance methods for 'RwLoadedPackage'

category: 'accessing'
method: RwLoadedPackage
addLoadedClass: aLoadedClass

	self markDirty.
	loadedClasses at: aLoadedClass key put: aLoadedClass.
	aLoadedClass loadedPackage: self
%

category: 'accessing'
method: RwLoadedPackage
addLoadedClassExtension: aLoadedClassExtension

	self markDirty.
	loadedClassExtensions at: aLoadedClassExtension key
		put: aLoadedClassExtension.
	aLoadedClassExtension loadedPackage: self
%

category: 'definitions'
method: RwLoadedPackage
asDefinition
	"Create a Definition corresponding to what I define in the image."

	^RwPackageDefinition
		withProperties: self propertiesForDefinition
		classDefinitions: self classDefinitions
		classExtensions: self classExtensionDefinitions
%

category: 'other'
method: RwLoadedPackage
asExtensionName

	^'*', self name asLowercase
%

category: 'private'
method: RwLoadedPackage
classDefinitions
	"Create definitions from all of the classes I define, and answer the collection of them"

	^self definitionsFor: loadedClasses
%

category: 'private'
method: RwLoadedPackage
classExtensionDefinitions
	"Create definitions from all of the class extensions I define, and answer the collection of them"

	^self definitionsFor: loadedClassExtensions
%

category: 'queries'
method: RwLoadedPackage
classOrExtensionForClassNamed: className ifAbsent: absentBlock

	^loadedClasses at: className
		ifAbsent: [loadedClassExtensions at: className ifAbsent: absentBlock]
%

category: 'testing'
method: RwLoadedPackage
isDirty

	^ isDirty
%

category: 'testing'
method: RwLoadedPackage
isEmpty

	^loadedClasses isEmpty and: [loadedClassExtensions isEmpty]
%

category: 'accessing'
method: RwLoadedPackage
key

	^ name
%

category: 'enumeration'
method: RwLoadedPackage
loadedClassedDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedClasses
		valuesDo: [ :loadedClass | 
			loadedClassBlock cull: self loadedProject cull: self cull: loadedClass.
			loadedClass
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ].
	loadedClassExtensions
		valuesDo: [ :loadedClassExtension | 
			loadedClassExtensionBlock
				cull: self loadedProject
				cull: self
				cull: loadedClassExtension.
			loadedClassExtension
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ]
%

category: 'accessing'
method: RwLoadedPackage
loadedClasses
	^loadedClasses
%

category: 'enumeration'
method: RwLoadedPackage
loadedClassesDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock 

	loadedClasses
		valuesDo: [ :loadedClass | 
			loadedClassBlock 
				cull: loadedClass
				cull: self loadedProject 
				cull: self].
	loadedClassExtensions
		valuesDo: [ :loadedClassExtension | 
			loadedClassExtensionBlock
				cull: loadedClassExtension
				cull: self loadedProject
				cull: self ]
%

category: 'enumeration'
method: RwLoadedPackage
loadedClassesDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedClasses
		valuesDo: [ :loadedClass | 
			loadedClassBlock 
				cull: loadedClass
				cull: self loadedProject 
				cull: self. 
			loadedClass
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ].
	loadedClassExtensions
		valuesDo: [ :loadedClassExtension | 
			loadedClassExtensionBlock
				cull: loadedClassExtension
				cull: self loadedProject
				cull: self.
			loadedClassExtension
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ]
%

category: 'accessing'
method: RwLoadedPackage
loadedClassExtensions
	^loadedClassExtensions
%

category: 'accessing'
method: RwLoadedPackage
loadedProject

   ^loadedProject
%

category: 'accessing'
method: RwLoadedPackage
loadedProject: anObject

   loadedProject := anObject
%

category: 'private'
method: RwLoadedPackage
markDirty
	"I have been changed independent of a change to my repository, and therefore may be out of sync with my repository"

	isDirty := true
%

category: 'private'
method: RwLoadedPackage
markNotDirty
	"I have been changed to be consistent with my source, so mark not dirty."

	isDirty := false
%

category: 'private'
method: RwLoadedPackage
markPackageDirty

	self markDirty
%

category: 'accessing'
method: RwLoadedPackage
projectName

	^ loadedProject name
%

category: 'accessing'
method: RwLoadedPackage
removeLoadedClass: aLoadedClass

	self markDirty.
	loadedClasses removeKey: aLoadedClass key.
	aLoadedClass loadedPackage: nil
%

category: 'accessing'
method: RwLoadedPackage
removeLoadedClassExtension: aLoadedClassExtension

	self markDirty.
	loadedClassExtensions removeKey: aLoadedClassExtension key.
	aLoadedClassExtension loadedPackage: nil
%

! Class implementation for 'RwGsLoadedSymbolDictPackage'

!		Instance methods for 'RwGsLoadedSymbolDictPackage'

category: 'queries'
method: RwGsLoadedSymbolDictPackage
classOrExtensionForClass: behavior ifAbsent: absentBlock

	| className |
	className := behavior thisClass name asString.
	^ self classOrExtensionForClassNamed: className ifAbsent: absentBlock
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
classOrExtensionForClassNamed: className ifAbsent: absentBlock

	^ loadedClasses
		at: className
		ifAbsent: [ loadedClassExtensions at: className ifAbsent: absentBlock ]
%

category: 'initialization'
method: RwGsLoadedSymbolDictPackage
initialize

	super initialize.
	loadedClasses := KeyValueDictionary new.
	loadedClassExtensions := KeyValueDictionary new.
	"A new package is dirty until it has been shown to be identical to a repository."
	isDirty := true
%

category: 'initialization'
method: RwGsLoadedSymbolDictPackage
initializeForName: aName

	super initializeForName: aName.
	properties at: 'name' put: aName
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
loadedClassExtensionForClass: aClass ifAbsent: absentBlock

	"If there is an existing extension for the given (non-meta) class in this package, answer it, otherwise invoke absentBlock."

	^ loadedClassExtensions
		at: aClass thisClass name asString
		ifAbsent: absentBlock
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
loadedClassForClass: aClass ifAbsent: absentBlock

	"If there is an existing loadedClass for the given (non-meta) class in this package, answer it, otherwise invoke absentBlock.."

	^ loadedClasses at: aClass thisClass name asString ifAbsent: absentBlock
%

category: 'queries'
method: RwGsLoadedSymbolDictPackage
loadedClassOrClassExtensionForClass: aClass ifAbsent: absentBlock

	"If there is an existing loaded class or loaded class extesnion for the given (non-meta) class in this package, answer it, otherwise invoke absentBlock."

	^ loadedClasses
		at: aClass thisClass name asString
		ifAbsent: [ self loadedClassExtensionForClass: aClass ifAbsent: absentBlock ]
%

category: 'private'
method: RwGsLoadedSymbolDictPackage
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at:  'gs_SymbolDictionary' put: (Rowan image loadedRegistryForPackageNamed: self name) _symbolDictionary name asString.
	^ props
%

! Class implementation for 'RwLoadedProject'

!		Class methods for 'RwLoadedProject'

category: 'instance creation'
classmethod: RwLoadedProject
newForLoadSpecification: aLoadSpecification

	^ self new
		initialize;
		initializeForLoadSpecification: aLoadSpecification;
		yourself
%

category: 'accessing'
classmethod: RwLoadedProject
_projectDefinitionSourceKey
	"The value of the property key indicates which source the project definition was derived from.
		Currently used when deciding whether to change the loaded commit id, during a load ... 
		if the load is derived from a loaded project (RwLoadedProject class _projectDefinitionSourceValue), 
		then it isn't necessary to update the loaded commit id."

	^ '_Project_Definition_Source'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectDiskDefinitionSourceValue
	"This value of the property key indicates that the source of the project definition was loaded from disk, 
		then it isn't necessary to update the loaded commit id."

	^ 'loaded from disk'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectLoadedDefinitionSourceValue
	"This value of the property key indicates that the source of the project definition was derived from
		a loaded project, then it isn't necessary to update the loaded commit id."

	^ 'loaded project'
%

category: 'accessing'
classmethod: RwLoadedProject
_projectUnknownDefinitionSourceValue
	"This value of the property key indicates that the source of the project definition is unknown."

	^ 'unknown'
%

!		Instance methods for 'RwLoadedProject'

category: 'accessing'
method: RwLoadedProject
addLoadedPackage: aLoadedPackage

	self markDirty.
	loadedPackages at: aLoadedPackage key put: aLoadedPackage.
	aLoadedPackage loadedProject: self
%

category: 'definitions'
method: RwLoadedProject
asDefinition

	"Create a Definition corresponding to what I define in the image."

	^ RwProjectDefinition
		withProperties: self propertiesForDefinition
		packageDefinitions: self loadedPackageDefinitions
%

category: 'initialization'
method: RwLoadedProject
initialize

	super initialize.
	loadedPackages := KeyValueDictionary new.
	isDirty := true. "a project is dirty if it has changes that are not written to disk"
%

category: 'initialization'
method: RwLoadedProject
initializeForLoadSpecification: aLoadSpecification

	self initializeForName: aLoadSpecification specName.
	handle := aLoadSpecification
%

category: 'testing'
method: RwLoadedProject
isDirty

	"a project is dirty if it has changes that are not written to disk, or it's packages have changes that are not written to  disk."

	isDirty ifTrue: [ ^ true].
	self loadedPackages
		do: [ :loadedPackage | 
			loadedPackage isDirty
				ifTrue: [ ^ true ] ].
	^ false
%

category: 'testing'
method: RwLoadedProject
isEmpty

	^ loadedPackages isEmpty
%

category: 'accessing'
method: RwLoadedProject
key

	^ name
%

category: 'accessing'
method: RwLoadedProject
loadedPackageDefinitions

	"Create definitions from all of the packages I define, and answer the collection of them"

	^ self definitionsFor: loadedPackages
%

category: 'accessing'
method: RwLoadedProject
loadedPackages

	^ loadedPackages
%

category: 'accessing'
method: RwLoadedProject
loadedPackages: anObject

   loadedPackages := anObject
%

category: 'enumeration'
method: RwLoadedProject
loadedPackagesDo: loadedPackageBlock loadedClassedDo: loadedClassBlock loadedClassExtensionsDo: loadedClassExtensionBlock loadedInstanceMethodsDo: loadedInstanceMethodBlock loadedClassMethodsDo: loadedClassMethodBlock

	loadedPackages
		valuesDo: [ :loadedPackage | 
			loadedPackageBlock cull: self cull: loadedPackage.
			loadedPackage
				loadedClassedDo: loadedClassBlock
				loadedClassExtensionsDo: loadedClassExtensionBlock
				loadedInstanceMethodsDo: loadedInstanceMethodBlock
				loadedClassMethodsDo: loadedClassMethodBlock ]
%

category: 'accessing'
method: RwLoadedProject
loadedProject

	^ self
%

category: 'accessing'
method: RwLoadedProject
loadSpecification

	^ handle
%

category: 'private'
method: RwLoadedProject
markDirty
	"I have been changed independent of a change to my repository, and therefore may be out of sync with my repository"

	isDirty := true
%

category: 'private'
method: RwLoadedProject
markNotDirty
	"I have been changed to be consistent with my source, so mark not dirty."
self halt.
	isDirty := false
%

category: 'private'
method: RwLoadedProject
markProjectDirty

	self markDirty
%

category: 'accessing'
method: RwLoadedProject
packageNames

	"Return list of package names in the receiver"

	^ self loadedPackages keys asArray
%

category: 'accessing'
method: RwLoadedProject
projectUrl

	"Return the projectUrl used to clone the project"

	^ self specification projectUrl
%

category: 'definitions'
method: RwLoadedProject
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at: 'name' put: name.
	props at: self class _projectDefinitionSourceKey put: self class _projectLoadedDefinitionSourceValue.
	^ props
%

category: 'accessing'
method: RwLoadedProject
removeLoadedPackage: aLoadedPackage

	self markDirty.
	loadedPackages removeKey: aLoadedPackage key
%

category: 'properties'
method: RwLoadedProject
specification

	^ properties at: 'spec'
%

! Class implementation for 'RwGsLoadedSymbolDictProject'

!		Instance methods for 'RwGsLoadedSymbolDictProject'

category: 'private'
method: RwGsLoadedSymbolDictProject
markDirty
	"I have been changed independent of a change to my repository, and therefore may be out of sync with my repository"

	isDirty := true
%

category: 'private'
method: RwGsLoadedSymbolDictProject
markNotDirty
	"I have been changed to be consistent with my source, so mark not dirty."

	isDirty := false
%

category: 'private'
method: RwGsLoadedSymbolDictProject
markProjectDirty

self halt.
	self markDirty
%

category: 'specifiction'
method: RwGsLoadedSymbolDictProject
projectOwnerId

	^ (self specification platformSpec at: 'gemstone') projectOwnerId
%

category: 'specifiction'
method: RwGsLoadedSymbolDictProject
projectOwnerId: aUserId

	^ (self specification platformSpec at: 'gemstone') projectOwnerId: aUserId
%

category: 'definitions'
method: RwGsLoadedSymbolDictProject
propertiesForDefinition

	| props |
	props := super propertiesForDefinition.
	props at: 'spec' put: handle.
	^ props
%

category: 'properties'
method: RwGsLoadedSymbolDictProject
specification

	^ handle
%

! Class implementation for 'RwMethodAdditionOrRemoval'

!		Class methods for 'RwMethodAdditionOrRemoval'

category: 'instance creation'
classmethod: RwMethodAdditionOrRemoval
packageDefinition: aPackageDefinition classDefinitionOrExtension: aClassDefinitionOrExtension methodKey: aMethodKey isMeta: isMeta methodsModification: aMethodsModification

	^(self new)
		packageDefinition: aPackageDefinition;
		classDefinitionOrExtension: aClassDefinitionOrExtension;
		methodKey: aMethodKey;
		isMeta: isMeta;
		methodsModification: aMethodsModification;
		yourself
%

category: 'instance creation'
classmethod: RwMethodAdditionOrRemoval
projectDefinition: aProjectDefinition packageDefinition: aPackageDefinition classDefinitionOrExtension: aClassDefinitionOrExtension methodKey: aMethodKey isMeta: isMeta methodsModification: aMethodsModification

	^(self new)
		projectDefinition: aProjectDefinition;
		packageDefinition: aPackageDefinition;
		classDefinitionOrExtension: aClassDefinitionOrExtension;
		methodKey: aMethodKey;
		isMeta: isMeta;
		methodsModification: aMethodsModification;
		yourself
%

!		Instance methods for 'RwMethodAdditionOrRemoval'

category: 'Accessing'
method: RwMethodAdditionOrRemoval
classDefinitionOrExtension
	^classDefinitionOrExtension
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
classDefinitionOrExtension: newValue
	classDefinitionOrExtension := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
isMeta
	^isMeta
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
isMeta: newValue
	isMeta := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
methodKey
	^methodKey
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
methodKey: newValue
	methodKey := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
methodsModification
	^methodsModification
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
methodsModification: newValue
	methodsModification := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
packageDefinition
	^packageDefinition
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
packageDefinition: newValue
	packageDefinition := newValue
%

category: 'Accessing'
method: RwMethodAdditionOrRemoval
projectDefinition
	^ projectDefinition
%

category: 'Updating'
method: RwMethodAdditionOrRemoval
projectDefinition: newValue
	projectDefinition := newValue
%

! Class implementation for 'RwModification'

!		Class methods for 'RwModification'

category: 'instance creation'
classmethod: RwModification
before: beforeDefinition after: afterDefinition

	^(self new initialize)
		before: beforeDefinition;
		after: afterDefinition;
		yourself
%

!		Instance methods for 'RwModification'

category: 'Accessing'
method: RwModification
after
	^after
%

category: 'Updating'
method: RwModification
after: newValue
	after := newValue
%

category: 'Accessing'
method: RwModification
before
	^before
%

category: 'Updating'
method: RwModification
before: newValue
	before := newValue
%

category: 'initializing'
method: RwModification
initialize
	"Dummy that understands isEmpty for printing"

	propertiesModification := RwPropertiesModification new
%

category: 'testing'
method: RwModification
isAddition

	^before isEmpty
%

category: 'testing'
method: RwModification
isDeletion

	^after isEmpty
%

category: 'testing'
method: RwModification
isEmpty

	^propertiesModification isEmpty
%

category: 'testing'
method: RwModification
isModification

	^after isEmpty not and: [ before isEmpty not ]
%

category: 'Accessing'
method: RwModification
key

	| beforeKey |
	beforeKey := before key.
	^beforeKey ifNil: [after key] ifNotNil: [beforeKey]
%

category: 'Printing'
method: RwModification
printOn: aStream

	super printOn: aStream.
	self isEmpty ifTrue: [aStream nextPutAll: ' (empty)']
%

category: 'Accessing'
method: RwModification
propertiesModification
	^propertiesModification
%

category: 'Updating'
method: RwModification
propertiesModification: newValue
	propertiesModification := newValue
%

! Class implementation for 'RwClassModification'

!		Instance methods for 'RwClassModification'

category: 'visiting'
method: RwClassModification
acceptVisitor: aVisitor

	^aVisitor visitClassModification: self
%

category: 'Accessing'
method: RwClassModification
classMethodsModification
	^classMethodsModification
%

category: 'Updating'
method: RwClassModification
classMethodsModification: newValue
	classMethodsModification := newValue
%

category: 'initialization'
method: RwClassModification
initialize
	"Dummy initialization that understands isEmpty for printing."

	super initialize.
	instanceMethodsModification := #().
	classMethodsModification := #()
%

category: 'Accessing'
method: RwClassModification
instanceMethodsModification
	^instanceMethodsModification
%

category: 'Updating'
method: RwClassModification
instanceMethodsModification: newValue
	instanceMethodsModification := newValue
%

category: 'testing'
method: RwClassModification
isEmpty

	^super isEmpty & instanceMethodsModification isEmpty
		& classMethodsModification isEmpty
%

category: 'merging'
method: RwClassModification
mergeForExistingClassWith: anExistingClassModification

	"merge aClassModification modifictions into the receiver"

	anExistingClassModification propertiesModification isEmpty
		ifFalse: [
			self propertiesModification isEmpty
				ifFalse: ["the properties modification for the receiver can be safely ignored" ].
			propertiesModification := anExistingClassModification propertiesModification copy ].
	instanceMethodsModification
		mergeForExistingClassWith: anExistingClassModification instanceMethodsModification.
	classMethodsModification
		mergeForExistingClassWith: anExistingClassModification classMethodsModification.
	after := anExistingClassModification after
%

category: 'merging'
method: RwClassModification
mergeForNewClassVersionWith: aClassModification

	"merge aClassModification modifictions into the receiver"

	aClassModification propertiesModification isEmpty
		ifFalse: [ 
			self
				error:
					'internal error - an incoming class modification is not expected to have properties when a new class version is involved' ].
	instanceMethodsModification
		mergeForNewClassVersionWith: aClassModification instanceMethodsModification.
	classMethodsModification
		mergeForNewClassVersionWith: aClassModification classMethodsModification
%

! Class implementation for 'RwClassExtensionModification'

!		Instance methods for 'RwClassExtensionModification'

category: 'visiting'
method: RwClassExtensionModification
acceptVisitor: aVisitor

	^aVisitor visitClassExtensionModification: self
%

category: 'patching'
method: RwClassExtensionModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ 
			aPatchSet
				addExtendedClass: self after
				inPackage: aPackage
				inProject: aProjectDefinition ].
	self isDeletion
		ifTrue: [ 
			"nothing interesting to do for deletion"
			 ].
	self isModification
		ifTrue: [ 
			"nothing interesting to do for modification"
			 ]
%

! Class implementation for 'RwClassModificationForcingNewClassVersion'

!		Instance methods for 'RwClassModificationForcingNewClassVersion'

category: 'visiting'
method: RwClassModificationForcingNewClassVersion
acceptVisitor: aVisitor

	^ aVisitor visitClassModificationForcingNewVersion: self
%

! Class implementation for 'RwMethodModification'

!		Instance methods for 'RwMethodModification'

category: 'visiting'
method: RwMethodModification
acceptVisitor: aVisitor

	^ aVisitor visitMethodModification: self
%

category: 'patching'
method: RwMethodModification
addExtensionModificationToPatchSetForNewClassVersion: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ self error: 'internal error - unexpected method addition' ].
	self isDeletion
		ifTrue: [ self error: 'internal error - unexpected method deletion' ].
	self isModification
		ifTrue: [ 
			"treat like an addition, since it is an addition of a method to the new class version"
			self isMeta
				ifTrue: [ 
					aPatchSet
						addExtendedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addExtendedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ] ]
%

category: 'patching'
method: RwMethodModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addAddedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addAddedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isDeletion
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addDeletedClassMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addDeletedInstanceMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isModification
		ifTrue: [ 
			sourceModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedClassMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedInstanceMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ].
			propertiesModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedClassMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedInstanceMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ] ]
%

category: 'converting'
method: RwMethodModification
asExtensionMethodModification

	^ (RwExtensionMethodModification before: before after: after)
		isMeta: self isMeta;
		propertiesModification: propertiesModification;
		sourceModification: sourceModification;
		classDefinition: self classDefinition;
		yourself
%

category: 'converting'
method: RwMethodModification
asMethodModificationForNewClassVersion

	^ (RwMethodModificationForNewClassVersion before: before after: after)
		isMeta: self isMeta;
		classDefinition: self classDefinition;
		propertiesModification: self propertiesModification;
		sourceModification: self sourceModification;
		yourself
%

category: 'Accessing'
method: RwMethodModification
classDefinition
	^classDefinition
%

category: 'Updating'
method: RwMethodModification
classDefinition: aClassDefinition
	classDefinition := aClassDefinition
%

category: 'testing'
method: RwMethodModification
isEmpty

	^super isEmpty & sourceModification isEmpty
%

category: 'Accessing'
method: RwMethodModification
isMeta
	^isMeta
%

category: 'Updating'
method: RwMethodModification
isMeta: newValue
	isMeta := newValue
%

category: 'merging'
method: RwMethodModification
mergeForNewClassVersionWith: aMethodModification

	"validate that this is a proper modification"

	self sourceModification isEmpty
		ifTrue: [ 
			aMethodModification sourceModification isEmpty
				ifTrue: [ 
					self
						error:
							'internal error - unexpected missing source modification during method modification for new class version merge' ]
				ifFalse: [ 
					"this is as it should be ... method source must be carried forward to the new class version"
					 ] ].
	self propertiesModification isEmpty
		ifTrue: [ 
			aMethodModification propertiesModification isEmpty
				ifFalse: [ self error: 'internal error - not yet implemented' ] ]
%

category: 'Accessing'
method: RwMethodModification
sourceModification
	^sourceModification
%

category: 'Accessing'
method: RwMethodModification
sourceModification: aRWSourceModification
	sourceModification := aRWSourceModification
%

! Class implementation for 'RwExtensionMethodModification'

!		Instance methods for 'RwExtensionMethodModification'

category: 'visiting'
method: RwExtensionMethodModification
acceptVisitor: aVisitor

	^ aVisitor visitExtensionMethodModification: self
%

category: 'patching'
method: RwExtensionMethodModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isAddition
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addExtendedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addExtendedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isDeletion
		ifTrue: [ 
			self isMeta
				ifTrue: [ 
					aPatchSet
						addDeletedExtendedClassMethod: self before
						inClass: self classDefinition
						named: self extendedClassName
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addDeletedExtendedInstanceMethod: self before
						inClass: self classDefinition
						named: self extendedClassName
						inPackage: aPackage
						inProject: aProjectDefinition ].
			^ self ].
	self isModification
		ifTrue: [ 
			sourceModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedExtendedClassMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedExtendedInstanceMethod: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ].
			propertiesModification isEmpty
				ifFalse: [ 
					self isMeta
						ifTrue: [ 
							aPatchSet
								addPatchedExtendedClassMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ]
						ifFalse: [ 
							aPatchSet
								addPatchedExtendedInstanceMethodProperties: self after
								inClass: self classDefinition
								inPackage: aPackage
								inProject: aProjectDefinition ] ] ]
%

category: 'converting'
method: RwExtensionMethodModification
asExtensionMethodModification

	^ self
%

category: 'accessing'
method: RwExtensionMethodModification
classDefinition: aClassDefinition
	classDefinition := aClassDefinition
%

category: 'accessing'
method: RwExtensionMethodModification
extendedClassName

   ^extendedClassName
%

category: 'accessing'
method: RwExtensionMethodModification
extendedClassName: anObject

   extendedClassName := anObject
%

! Class implementation for 'RwMethodModificationForNewClassVersion'

!		Instance methods for 'RwMethodModificationForNewClassVersion'

category: 'visiting'
method: RwMethodModificationForNewClassVersion
acceptVisitor: aVisitor

	^ aVisitor visitMethodModificationForNewClassVersion: self
%

category: 'patching'
method: RwMethodModificationForNewClassVersion
addModificationToPatchSetForNewClassVersion: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self isDeletion
		ifTrue: [ 
			"method deletions on a new class version can be ignored: https://github.com/dalehenrich/Rowan/issues/353"
			"method deletions on a new class version needs to have the loaded things taken core of: https://github.com/dalehenrich/Rowan/issues/393"

			"treat like a deletion, since this ends up being a deletion of a method from the new class version"
			self isMeta
				ifTrue: [ 
					aPatchSet
						addDeletedClassMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addDeletedInstanceMethod: self before
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ] ].
	(self isAddition or: [ self isModification ])
		ifTrue: [ 
			"treat like an addition, since this ends up being an addition of a method to the new class version"
			self isMeta
				ifTrue: [ 
					aPatchSet
						addAddedClassMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ]
				ifFalse: [ 
					aPatchSet
						addAddedInstanceMethod: self after
						inClass: self classDefinition
						inPackage: aPackage
						inProject: aProjectDefinition ] ].
%

! Class implementation for 'RwExtensionMethodModificationForNewClassVersion'

!		Instance methods for 'RwExtensionMethodModificationForNewClassVersion'

category: 'visiting'
method: RwExtensionMethodModificationForNewClassVersion
acceptVisitor: aVisitor

	^ aVisitor visitExtensionMethodModificationForNewClassVersion: self
%

! Class implementation for 'RwPackageModification'

!		Instance methods for 'RwPackageModification'

category: 'visiting'
method: RwPackageModification
acceptVisitor: aVisitor

	^aVisitor visitPackageModification: self
%

category: 'Accessing'
method: RwPackageModification
classesModification
	^classesModification
%

category: 'Updating'
method: RwPackageModification
classesModification: newValue
	classesModification := newValue
%

category: 'Accessing'
method: RwPackageModification
classExtensionsModification
	^classExtensionsModification
%

category: 'Updating'
method: RwPackageModification
classExtensionsModification: newValue
	classExtensionsModification := newValue
%

category: 'initialization'
method: RwPackageModification
initialize
	"Dummy initialization that understands isEmpty for printing."

	super initialize.
	classesModification := #().
	classExtensionsModification := #()
%

category: 'testing'
method: RwPackageModification
isEmpty

	^super isEmpty & classesModification isEmpty
		& classExtensionsModification isEmpty
%

! Class implementation for 'RwProjectModification'

!		Instance methods for 'RwProjectModification'

category: 'visiting'
method: RwProjectModification
acceptVisitor: aVisitor

	^ aVisitor visitProjectModification: self
%

category: 'initialization'
method: RwProjectModification
initialize

	"Dummy initialization that understands isEmpty for printing."

	super initialize.
	packagesModification := #()
%

category: 'testing'
method: RwProjectModification
isEmpty

	^ super isEmpty & packagesModification isEmpty
%

category: 'accessing'
method: RwProjectModification
packagesModification

   ^packagesModification
%

category: 'accessing'
method: RwProjectModification
packagesModification: anObject

   packagesModification := anObject
%

! Class implementation for 'RwMove'

!		Instance methods for 'RwMove'

category: 'Accessing'
method: RwMove
packageAfter
	^packageAfter
%

category: 'Updating'
method: RwMove
packageAfter: newValue
	packageAfter := newValue
%

category: 'Accessing'
method: RwMove
packageBefore
	^packageBefore
%

category: 'Updating'
method: RwMove
packageBefore: newValue
	packageBefore := newValue
%

category: 'Accessing'
method: RwMove
projectAfter
	^projectAfter
%

category: 'Updating'
method: RwMove
projectAfter: newValue
	projectAfter := newValue
%

category: 'Accessing'
method: RwMove
projectBefore
	^projectBefore
%

category: 'Updating'
method: RwMove
projectBefore: newValue
	projectBefore := newValue
%

! Class implementation for 'RwClassMove'

!		Class methods for 'RwClassMove'

category: 'instance creation'
classmethod: RwClassMove
classBefore: beforeClassDefinition classAfter: afterClassDefinition packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition

	^(self new)
		classBefore: beforeClassDefinition;
		classAfter: afterClassDefinition;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		yourself
%

category: 'instance creation'
classmethod: RwClassMove
classBefore: beforeClassDefinition classAfter: afterClassDefinition packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition projectBefore: beforeProjectDefinition projectAfter: afterProjectDefinition

	^(self new)
		classBefore: beforeClassDefinition;
		classAfter: afterClassDefinition;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		projectBefore: beforeProjectDefinition;
		projectAfter: afterProjectDefinition;
		yourself
%

!		Instance methods for 'RwClassMove'

category: 'Accessing'
method: RwClassMove
classAfter
	^classAfter
%

category: 'Updating'
method: RwClassMove
classAfter: newValue
	classAfter := newValue
%

category: 'Accessing'
method: RwClassMove
classBefore
	^classBefore
%

category: 'Updating'
method: RwClassMove
classBefore: newValue
	classBefore := newValue
%

! Class implementation for 'RwMethodMove'

!		Class methods for 'RwMethodMove'

category: 'unknown'
classmethod: RwMethodMove
methodBefore: beforeMethodDefinition methodAfter: afterMethodDefinition classOrExtensionBefore: beforeClassDefinitionOrExtension classOrExtensionAfter: afterClassDefinitionOrExtension packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition isMeta: isMeta

	^(self new)
		methodBefore: beforeMethodDefinition;
		methodAfter: afterMethodDefinition;
		classOrExtensionBefore: beforeClassDefinitionOrExtension;
		classOrExtensionAfter: afterClassDefinitionOrExtension;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		isMeta: isMeta;
		yourself
%

category: 'unknown'
classmethod: RwMethodMove
methodBefore: beforeMethodDefinition methodAfter: afterMethodDefinition classOrExtensionBefore: beforeClassDefinitionOrExtension classOrExtensionAfter: afterClassDefinitionOrExtension packageBefore: beforePackageDefinition packageAfter: afterPackageDefinition projectBefore: beforeProjectDefinition projectAfter: afterProjectDefinition isMeta: isMeta

	^(self new)
		methodBefore: beforeMethodDefinition;
		methodAfter: afterMethodDefinition;
		classOrExtensionBefore: beforeClassDefinitionOrExtension;
		classOrExtensionAfter: afterClassDefinitionOrExtension;
		packageBefore: beforePackageDefinition;
		packageAfter: afterPackageDefinition;
		projectBefore: beforeProjectDefinition;
		projectAfter: afterProjectDefinition;
		isMeta: isMeta;
		yourself
%

!		Instance methods for 'RwMethodMove'

category: 'Accessing'
method: RwMethodMove
classOrExtensionAfter
	^classOrExtensionAfter
%

category: 'Updating'
method: RwMethodMove
classOrExtensionAfter: newValue
	classOrExtensionAfter := newValue
%

category: 'Accessing'
method: RwMethodMove
classOrExtensionBefore
	^classOrExtensionBefore
%

category: 'Updating'
method: RwMethodMove
classOrExtensionBefore: newValue
	classOrExtensionBefore := newValue
%

category: 'Accessing'
method: RwMethodMove
isMeta
	^isMeta
%

category: 'Updating'
method: RwMethodMove
isMeta: newValue
	isMeta := newValue
%

category: 'Accessing'
method: RwMethodMove
methodAfter
	^methodAfter
%

category: 'Updating'
method: RwMethodMove
methodAfter: newValue
	methodAfter := newValue
%

category: 'Accessing'
method: RwMethodMove
methodBefore
	^methodBefore
%

category: 'Updating'
method: RwMethodMove
methodBefore: newValue
	methodBefore := newValue
%

! Class implementation for 'RwPlatform'

!		Instance methods for 'RwPlatform'

category: 'automatic class initialization'
method: RwPlatform
automaticClassInitializationBlackList

	"Answer list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		preferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setPreferenceFor: preferenceSymbol to: list.
			list]
%

category: 'automatic class initialization'
method: RwPlatform
automaticClassInitializationBlackList_default

	"Answer default list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		defaultPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setDefaultPreferenceFor: preferenceSymbol to: list.
			list]
%

category: 'automatic class initialization'
method: RwPlatform
automaticClassInitializationBlackList_global

	"Answer global list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		globalPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setDefaultPreferenceFor: preferenceSymbol to: list.
			list]
%

category: 'queries'
method: RwPlatform
basePlatformAttribute
	"Answer the generic configuration attribute for the platform"

	"Examples include: 'gemstone', 'pharo', 'squeak'"


	self subclassResponsibility: #basePlatformAttribute
%

category: 'preferences'
method: RwPlatform
clearAllPreferencesFor: preferenceSymbol 

	self subclassResponisbility: #clearAllPreferencesFor:
%

category: 'automatic class initialization'
method: RwPlatform
clearAutomaticClassInitializationBlackList

	"Answer list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwPlatform
clearAutomaticClassInitializationBlackList_default

	"Answer default list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearDefaultPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwPlatform
clearAutomaticClassInitializationBlackList_global

	"Answer default list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearGlobalPreferenceFor: preferenceSymbol
%

category: 'preferences'
method: RwPlatform
clearDefaultPreferenceFor: preferenceSymbol 

	self subclassResponisbility: #clearDefaultPreferenceFor:
%

category: 'preferences'
method: RwPlatform
clearPreferenceFor: preferenceSymbol 

	self subclassResponisbility: #clearPreferenceFor:
%

category: 'preferences'
method: RwPlatform
defaultPreferenceFor: preferenceSymbol

	^ self defaultPreferenceFor: preferenceSymbol ifAbsent: [ self error: 'No preference found for ', preferenceSymbol asString printString ]
%

category: 'preferences'
method: RwPlatform
defaultPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self subclassResponisbility: #defaultPreferenceFor:ifAbsent:
%

category: 'queries'
method: RwPlatform
fileUtilities
	"Answer the platform-specific object for accessing files and directories"

	self subclassResponsibility: #fileUtilities
%

category: 'queries'
method: RwPlatform
globalNamed: aString

	"Answer a global object with the given name.  If no object with the given name is found, returns nil."

	self subclassResponsibility: #'globalNamed:'
%

category: 'queries'
method: RwPlatform
loadedPackageClass
	"Answer the platform-specific class for LoadedPackage"

	self subclassResponsibility: #'loadedPackageClass'
%

category: 'queries'
method: RwPlatform
platformConfigurationAttributes
	"Answer the configuration attributes. Currently 'common' is the only shared attribute."

	"subclasses need to override and provide additional platform-specific attributes"

	^ #('common')
%

category: 'preferences'
method: RwPlatform
preferenceFor: preferenceSymbol

	^ self preferenceFor: preferenceSymbol ifAbsent: [ self error: 'No preference found for ', preferenceSymbol asString printString ]
%

category: 'preferences'
method: RwPlatform
preferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self subclassResponisbility: #preferenceFor:ifAbsent:
%

category: 'preferences'
method: RwPlatform
setDefaultPreferenceFor: preferenceSymbol to: anObject

	self subclassResponisbility: #setDefaultPreferenceFor:to:
%

category: 'preferences'
method: RwPlatform
setPreferenceFor: preferenceSymbol to: anObject

	self subclassResponisbility: #setPreferenceFor:to:
%

category: 'queries'
method: RwPlatform
tools
	"Answer the platform-specific class for tools"

	self subclassResponsibility: #tools
%

category: 'automatic class initialization'
method: RwPlatform
_automaticClassInitializationBlackList_symbol

	^#automaticClassInitializationBlackList
%

! Class implementation for 'RwGsPlatform'

!		Instance methods for 'RwGsPlatform'

category: 'automatic class initialization'
method: RwGsPlatform
automaticClassInitializationBlackList_session

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		sessionPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setSessionPreferenceFor: preferenceSymbol to: list.
			list ]
%

category: 'automatic class initialization'
method: RwGsPlatform
automaticClassInitializationBlackList_user

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	^ self 
		userPreferenceFor: preferenceSymbol 
		ifAbsent: [
			| list |
			list := OrderedCollection new.
			self setUserPreferenceFor: preferenceSymbol to: list.
			list ]
%

category: 'queries'
method: RwGsPlatform
basePlatformAttribute
	"Answer the generic configuration attribute for the platform"


	^ 'gemstone'
%

category: 'preferences'
method: RwGsPlatform
clearAllPreferencesFor: preferenceSymbol


	self 
		clearSessionPreferenceFor: preferenceSymbol;
		clearUserPreferenceFor: preferenceSymbol;
		clearGlobalPreferenceFor: preferenceSymbol;
		yourself
%

category: 'automatic class initialization'
method: RwGsPlatform
clearAutomaticClassInitializationBlackList_global

	"Answer global list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearGlobalPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwGsPlatform
clearAutomaticClassInitializationBlackList_session

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearSessionPreferenceFor: preferenceSymbol
%

category: 'automatic class initialization'
method: RwGsPlatform
clearAutomaticClassInitializationBlackList_user

	"Answer session list of project names for which automatic class initialiation should be disabled."

	| preferenceSymbol |
	preferenceSymbol := self _automaticClassInitializationBlackList_symbol.
	self clearUserPreferenceFor: preferenceSymbol
%

category: 'preferences'
method: RwGsPlatform
clearDefaultPreferenceFor: preferenceSymbol
	"global preferences implements default preference"

	self clearGlobalPreferenceFor: preferenceSymbol
%

category: 'preferences - gemstone'
method: RwGsPlatform
clearGlobalPreferenceFor: preferenceSymbol

	self _globalPreferenceDict removeKey: preferenceSymbol ifAbsent: []
%

category: 'preferences'
method: RwGsPlatform
clearPreferenceFor: preferenceSymbol
	"clear sessoin and userPreferences - preserve non-gemstone semantics"

	self 
		clearSessionPreferenceFor: preferenceSymbol;
		clearUserPreferenceFor: preferenceSymbol;
		yourself
%

category: 'preferences - gemstone'
method: RwGsPlatform
clearSessionPreferenceFor: preferenceSymbol

	self _sessionPreferenceDict removeKey: preferenceSymbol ifAbsent: []
%

category: 'preferences - gemstone'
method: RwGsPlatform
clearUserPreferenceFor: preferenceSymbol

	self _userPreferenceDict removeKey: preferenceSymbol ifAbsent: []
%

category: 'defaults'
method: RwGsPlatform
defaultConfiguration

	^ RwConfiguration new
		packageInfoSource: #'SymbolDictionary';
		yourself
%

category: 'preferences'
method: RwGsPlatform
defaultPreferenceFor: preferenceSymbol ifAbsent: aBlock

	"global preferences implements default preference"

	^self globalPreferenceFor: preferenceSymbol ifAbsent: aBlock
%

category: 'queries'
method: RwGsPlatform
fileUtilities
  "Answer the platform-specific object for accessing files and directories"

  ^ RwGsFileUtilities
%

category: 'queries'
method: RwGsPlatform
globalNamed: aString

	"Answer a global object with the given name.  If no object with the given name is found, returns nil."

	^ Rowan image objectNamed: aString
%

category: 'preferences - gemstone'
method: RwGsPlatform
globalPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _globalPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: aBlock
%

category: 'queries'
method: RwGsPlatform
image

	"Answer the platform-specific object for querying the local image"

	^ alternateImageClass ifNil: [ RwGsImage ]
%

category: 'initialization'
method: RwGsPlatform
initialize

	self automaticClassInitializationBlackList
%

category: 'queries'
method: RwGsPlatform
instanceMigrator

	^ instanceMigrator
		ifNil: [ instanceMigrator := RwGsInstanceMigrator noMigration ]
%

category: 'queries'
method: RwGsPlatform
instanceMigrator: anInstanceMigrator

	instanceMigrator := anInstanceMigrator
%

category: 'parsing'
method: RwGsPlatform
parseSelectorFrom: methodString

	| meth |
	^ [ 
	meth := self
		_parseMethod: methodString
		category: #'xyzzy'
		using: self image symbolList
		environmentId: 0.
	meth class ~~ GsNMethod
		ifTrue: [ 
			"if error slot is nil, then the method wasn't compiled because of errors"
			(meth at: 2) == nil
				ifFalse: [ ^ nil ].
			meth := meth at: 1 ].
	meth selector asString ]
		on: CompileError
		do: [ :ex | ex return: '_____could_not_parse_selector_from_method_source_____' ]
%

category: 'queries'
method: RwGsPlatform
platformConfigurationAttributes
	"Answer the configuration attributes for the current platform."

	^ super platformConfigurationAttributes, {self basePlatformAttribute. 'gemstone-kernel'. (System stoneVersionReport at: 'gsVersion') asRwGemStoneVersionNumber}
%

category: 'preferences'
method: RwGsPlatform
preferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _sessionPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: [ 
			self 
				_userPreferenceDict at: preferenceSymbol 
				ifAbsent: [
					self _globalPreferenceDict 
						at: preferenceSymbol
						ifAbsent:aBlock ] ]
%

category: 'preferences - gemstone'
method: RwGsPlatform
sessionPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _sessionPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: aBlock
%

category: 'preferences'
method: RwGsPlatform
setDefaultPreferenceFor: preferenceSymbol to: anObject

	"global preferences implements default preference"

	^self setGlobalPreferenceFor: preferenceSymbol to: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
setGlobalPreferenceFor: preferenceSymbol to: anObject

	self _globalPreferenceDict at: preferenceSymbol put: anObject
%

category: 'preferences'
method: RwGsPlatform
setPreferenceFor: preferenceSymbol to: anObject

	"clear session; set userPreferences - preserve non-gemstone semantics"

	self clearSessionPreferenceFor: preferenceSymbol.
	^self setUserPreferenceFor: preferenceSymbol to: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
setSessionPreferenceFor: preferenceSymbol to: anObject

	self _sessionPreferenceDict at: preferenceSymbol put: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
setUserPreferenceFor: preferenceSymbol to: anObject

	self _userPreferenceDict at: preferenceSymbol put: anObject
%

category: 'preferences - gemstone'
method: RwGsPlatform
userPreferenceFor: preferenceSymbol ifAbsent: aBlock

	^ self _userPreferenceDict 
		at: preferenceSymbol 
		ifAbsent: aBlock
%

category: 'private'
method: RwGsPlatform
_alternateImageClass

	^ alternateImageClass
%

category: 'private'
method: RwGsPlatform
_alternateImageClass: anImageClass

	alternateImageClass := anImageClass
%

category: 'private'
method: RwGsPlatform
_globalPreferenceDict

	^ (self class _userPlatformDictionaryForUser: 'SystemUser') at: #RwGlobalPlatform_Preferences ifAbsentPut: [ Dictionary new ]
%

category: 'private'
method: RwGsPlatform
_parseMethod: source category: cat using: aSymbolList environmentId: anEnvironmentId
	"Compiles the method into disposable dictionaries, if possible.
	 Attempts auto-recompile for undefinedSymbols.
	 Returns the compiled method or signals a CompileError."

	| undefinedSymbolList undefinedSymbols |
	undefinedSymbols := SymbolDictionary new name: #UndefinedSymbols.
	undefinedSymbolList := SymbolList with: undefinedSymbols.
	^
	[UndefinedObject
		compileMethod: source
		dictionaries: aSymbolList
		category: cat
		intoMethodDict: GsMethodDictionary new
		intoCategories: GsMethodDictionary new
		intoPragmas: nil
		environmentId: anEnvironmentId]
			onSynchronous: (Array with: CompileError with: CompileWarning)
			do: (Array with: 
						[:ex |
						| undefSymbol symbols |
						undefSymbol := true.
						symbols := Array new.
						ex errorDetails do: 
								[:errArray |
								(errArray atOrNil: 1) == 1031
									ifTrue: [symbols add: (errArray atOrNil: 5) asSymbol]
									ifFalse: [undefSymbol := false]].
						undefSymbol
							ifTrue: 
								["attempt auto-define of undefined symbols"
								symbols do: [:sym | undefinedSymbols at: sym put: nil].
								
								[^UndefinedObject
									compileMethod: source
									dictionaries: aSymbolList , undefinedSymbolList
									category: cat
									intoMethodDict: GsMethodDictionary new
									intoCategories: GsMethodDictionary new
									intoPragmas: nil
									environmentId: anEnvironmentId]
										onException: CompileError
										do: [:exb | undefSymbol := false]].
						undefSymbol ifFalse: [ex outer]]
					with: [:ex | ex resume])
%

category: 'private'
method: RwGsPlatform
_sessionPreferenceDict

	^ SessionTemps current at: #RwSessionPlatform_Preferences ifAbsentPut: [ Dictionary new ]
%

category: 'private'
method: RwGsPlatform
_userPreferenceDict

	^ self class _userPlatformDictionary at: #RwUserPlatform_Preferences ifAbsentPut: [ Dictionary new ]
%

! Class implementation for 'RwProjectLoadConfigurationVisitor'

!		Class methods for 'RwProjectLoadConfigurationVisitor'

category: 'instance creation'
classmethod: RwProjectLoadConfigurationVisitor
new

	^super new initialize
%

!		Instance methods for 'RwProjectLoadConfigurationVisitor'

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
configurationBasePath

	^ configurationBasePath
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
configurationBasePath: aString

	configurationBasePath := aString
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
configurationNames

	^ configurationNames
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
groupNames

	^ groupNames
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
groupNames: aColl

	groupNames := aColl copy
%

category: 'initialization'
method: RwProjectLoadConfigurationVisitor
initialize

	packageNames := Set new.
	visitedConfigurationNames := Set new.
	configurationNames := Set new.
	platformAttributes := #().
	groupNames := {}.
	configurationBasePath := ''.
	packageMapSpecs := Dictionary new.
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
packageMapSpecs

	^ packageMapSpecs
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
packageNames

	^ packageNames
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
platformAttributes

	^ platformAttributes
%

category: 'accessing'
method: RwProjectLoadConfigurationVisitor
platformAttributes: aColl

	platformAttributes := aColl
%

category: 'visiting'
method: RwProjectLoadConfigurationVisitor
visit: aProjectConfiguration

	^aProjectConfiguration acceptVisitor: self
%

category: 'visiting'
method: RwProjectLoadConfigurationVisitor
visitNestedProjectLoadConfiguration: aNestedProjectLoadConfiguration

	(visitedConfigurationNames includes: aNestedProjectLoadConfiguration name)
		ifTrue: [ ^ self ].

	self _visited: aNestedProjectLoadConfiguration. 

	self _processConditionalPackageNames: aNestedProjectLoadConfiguration.

	self _processConditionalPackageMapSpecs: aNestedProjectLoadConfiguration.

	self configurationNames addAll: aNestedProjectLoadConfiguration configurationNames.
	(self _configurations: self configurationBasePath, '/' forProject: aNestedProjectLoadConfiguration projectName)
		do: [:config | config acceptNestedVisitor: self ].
%

category: 'visiting'
method: RwProjectLoadConfigurationVisitor
visitProjectCompoundConfiguration: aProjectCompoundConfiguration

	(visitedConfigurationNames includes: aProjectCompoundConfiguration name)
		ifTrue: [ ^ self ].

	self _visited: aProjectCompoundConfiguration. 

	self _addPackageNames: aProjectCompoundConfiguration packageNames for: aProjectCompoundConfiguration.

	aProjectCompoundConfiguration _configurations
		do: [:config | config acceptCompoundVisitor: self ].
%

category: 'visiting'
method: RwProjectLoadConfigurationVisitor
visitProjectLoadConfiguration: aProjectLoadConfiguration

	| seedGroupNames |
	(visitedConfigurationNames includes: aProjectLoadConfiguration name)
		ifTrue: [ ^ self ].

	self _visited: aProjectLoadConfiguration. 

	definedGroupNames := aProjectLoadConfiguration definedGroupNames.
	seedGroupNames := groupNames asSet copy.
	[seedGroupNames isEmpty ]
		whileFalse: [ 
			seedGroupNames copy do: [:groupName |
				| referencedGroupNames |
				"make sure that required groups are included in group names, recursively"
				seedGroupNames remove: groupName.
				referencedGroupNames := definedGroupNames at: groupName ifAbsent: [ #() ].
				groupNames addAll: referencedGroupNames.
				seedGroupNames addAll: referencedGroupNames ] ].

	self _processConditionalPackageNames: aProjectLoadConfiguration.

	self _processConditionalPackageMapSpecs: aProjectLoadConfiguration.

	self configurationNames addAll: aProjectLoadConfiguration configurationNames.
	(self _configurations: self configurationBasePath, '/' forProject: aProjectLoadConfiguration projectName)
		do: [:config | config acceptNestedVisitor: self ].
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_addPackageNames: somePackageNames for: aConfiguration

	self packageNames addAll: somePackageNames
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_configurations: configDirPath forProject: aProjectName

	| urlBase |
	self configurationNames isEmpty ifTrue: [ ^ #() ].
	urlBase := 'file:' ,configDirPath.
	^ self configurationNames
		collect: [ :configName | 
			| url |
			url := urlBase , configName , '.ston'.
			(RwAbstractProjectConfiguration fromUrl: url)
				projectName: aProjectName;
				yourself ]
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_matchPlatformAttributes: platformPatternMatcher

	self platformAttributes do: [:anObject |
		(platformPatternMatcher match: anObject) ifTrue: [ ^true ] ].
	^false
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_platformAttributeMatchIn: platformMatchersList

	platformMatchersList do: [:platformPatternMatcher |
		(self _matchPlatformAttributes: platformPatternMatcher) 
			ifTrue: [ ^true ] ].
	^false
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_processConditionalPackageMapSpecs: aProjectLoadConfiguration

	| currentUserId |
	currentUserId := Rowan image currentUserId.
	aProjectLoadConfiguration conditionalPackageMapSpecMatchers keysAndValuesDo: [:platformMatcher :thePackageMapSpecsMap | 
		(self _platformAttributeMatchIn: {platformMatcher})
			ifTrue: [
				(thePackageMapSpecsMap 
					at: currentUserId 
					ifAbsent: [ 
						"<allusers> is preferred, but for the alpha, there are outstanding configs that use <default>"
						thePackageMapSpecsMap at: 'default'  
							ifAbsent: [ thePackageMapSpecsMap at: 'allusers'  ifAbsent: [] ] ])
								ifNotNil: [:thePackageMapSpecs |
									(thePackageMapSpecs at: #defaultSymbolDictName otherwise: nil) 
										ifNotNil: [:name | packageMapSpecs at: #defaultSymbolDictName put: name ].
									(thePackageMapSpecs at: #defaultUseSessionMethodsForExtensions otherwise: nil) 
										ifNotNil: [:boolean | packageMapSpecs at: #defaultUseSessionMethodsForExtensions put: boolean  ].
									(thePackageMapSpecs at: #packageNameToPlatformPropertiesMap otherwise: nil) 
										ifNotNil: [:theMap | 
											| map |
											map := packageMapSpecs at: #packageNameToPlatformPropertiesMap ifAbsentPut: [ Dictionary new ].
											theMap keysAndValuesDo: [:thePackageName :thePropMap | 
												thePropMap keysAndValuesDo: [:thePropertyName :thePropertyValue |
													| packageMap |
													packageMap  := map at: thePackageName ifAbsentPut: [ Dictionary new ].
													(#('symbolDictName' 'userId' 'useSessionMethodsForExtensions' ) includes: thePropertyName)
														ifTrue: [ packageMap at: thePropertyName put: thePropertyValue  ] 
														ifFalse: [ self error: 'Unrecognized property name ', thePropertyName printString, ' in package name to properties map' ] ] ] ] ] ] ]
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_processConditionalPackageNames: aProjectLoadConfiguration

	aProjectLoadConfiguration conditionalPackageMatchers keysAndValuesDo: [:platformMatchers :groupMap | 
		(self _platformAttributeMatchIn: platformMatchers)
			ifTrue: [
				groupMap keysAndValuesDo: [:group :map |
					(self groupNames includes: group)
						ifTrue: [ 
							self _addPackageNames: (map at: #packageNames ifAbsent: [ #() ]) for: aProjectLoadConfiguration.
							self configurationNames addAll: (map at: #configurationNames ifAbsent: [ #()] ) ] ] ] ].
%

category: 'private'
method: RwProjectLoadConfigurationVisitor
_visited: aConfiguration

	visitedConfigurationNames add:  aConfiguration name.
%

! Class implementation for 'RwProjectLoadConfigurationAnalysisVisitor'

!		Instance methods for 'RwProjectLoadConfigurationAnalysisVisitor'

category: 'initialization'
method: RwProjectLoadConfigurationAnalysisVisitor
initialize

	super initialize.
	visitedConfigurationMap := Dictionary new.
	packageToConfigurationMap := Dictionary new
%

category: 'accessing'
method: RwProjectLoadConfigurationAnalysisVisitor
packageToConfigurationMap 

	^ packageToConfigurationMap
%

category: 'accessing'
method: RwProjectLoadConfigurationAnalysisVisitor
visitedConfigurationMap 

	^ visitedConfigurationMap
%

category: 'private'
method: RwProjectLoadConfigurationAnalysisVisitor
_addPackageNames: somePackageNames for: aConfiguration

	super _addPackageNames: somePackageNames for: aConfiguration.
	somePackageNames do: [:aPackageName |
		(packageToConfigurationMap at: aPackageName ifAbsentPut: [ {} ])
			add: aConfiguration ]
%

category: 'private'
method: RwProjectLoadConfigurationAnalysisVisitor
_visited: aConfiguration

	super _visited: aConfiguration.
	visitedConfigurationMap at:  aConfiguration name put: aConfiguration.
%

! Class implementation for 'RwPropertyModification'

!		Class methods for 'RwPropertyModification'

category: 'instance creation'
classmethod: RwPropertyModification
key: key oldValue: oldValue newValue: newValue

	^(self new)
		key: key;
		oldValue: oldValue;
		newValue: newValue;
		yourself
%

!		Instance methods for 'RwPropertyModification'

category: 'testing'
method: RwPropertyModification
isEmpty

	^oldValue = newValue
%

category: 'Accessing'
method: RwPropertyModification
key
	^key
%

category: 'Updating'
method: RwPropertyModification
key: znewValue
	key := znewValue
%

category: 'Accessing'
method: RwPropertyModification
newValue
	^newValue
%

category: 'Updating'
method: RwPropertyModification
newValue: znewValue
	newValue := znewValue
%

category: 'Accessing'
method: RwPropertyModification
oldValue
	^oldValue
%

category: 'Updating'
method: RwPropertyModification
oldValue: znewValue
	oldValue := znewValue
%

! Class implementation for 'RwPropertyModificationForUpgrade'

!		Instance methods for 'RwPropertyModificationForUpgrade'

category: 'testing'
method: RwPropertyModificationForUpgrade
isEmpty
"guarantee that even though the oldValue and newValue are #=, we answer false
	which forces the modification to be applied"

	^ false
%

! Class implementation for 'RwUnconditionalPropertyModification'

!		Instance methods for 'RwUnconditionalPropertyModification'

category: 'testing'
method: RwUnconditionalPropertyModification
isEmpty

	^ false
%

! Class implementation for 'RwSpecification'

!		Class methods for 'RwSpecification'

category: 'instance creation'
classmethod: RwSpecification
fromUrl: specNameOrUrl

	"self fromUrl: 'file:/export/foos1/users/dhenrich/dev/_home/shared/repos/rowan/CypressReferenceImplementation/rowanLoadSpec.ston'"

	"self fromUrl: 'sampleLoadSpec'"

	"self fromUrl: 'https://raw.githubusercontent.com/dalehenrich/CypressReferenceImplementation/rowan/rowanLoadSpec.ston'"

	| url |
	url := specNameOrUrl asRwUrl.
	url scheme isNil
		ifTrue: [ 
			^ Rowan image
				loadedProjectNamed: specNameOrUrl
				ifAbsent: [ self error: 'No project named ' , specNameOrUrl printString , ' found' ] ].
	url scheme = 'file'
		ifTrue: [ 
			CypressFileUtilities current
				readStreamFor: url fileName
				in: url pathForDirectory
				do: [ :stream | 
					^ (STON fromStream: stream)
						initializeForImport;
						yourself ] ].
	url scheme asString = 'https'
		ifTrue: [ 
			| client response |
			GsSecureSocket disableCertificateVerificationOnClient.
			client := (Rowan globalNamed: 'ZnClient') new.
			response := client
				beOneShot;
				enforceHttpSuccess: true;
				get: url.
			^ (STON fromString: response decodeFromUTF8)
				initializeForImport;
				yourself ].
	self error: 'Unknown scheme: ' , url scheme printString
%

category: 'instance creation'
classmethod: RwSpecification
new

	^self basicNew initialize
%

!		Instance methods for 'RwSpecification'

category: 'private'
method: RwSpecification
currentVersion
	"
		0.1.0 - initial version for specs
		0.2.0 - defaultConfigurationNames and defaultGroupNames i.v. added to RwProjectSpecification
	"
	^ '0.2.0'
%

category: 'initialization'
method: RwSpecification
initialize
  
%

category: 'initialization'
method: RwSpecification
initializeForExport
  "if spec has been exported, clear out any of the fields that represent local disk state"
%

category: 'initialization'
method: RwSpecification
initializeForImport

  "if spec has been imported, clear out any of the fields that represent local disk state"
  
%

category: 'copying'
method: RwSpecification
postCopy
  "don't forget to copy any compound state objects"

  
%

category: 'accessing'
method: RwSpecification
projectUrl: ignored
  
%

! Class implementation for 'RwImageSpecification'

!		Instance methods for 'RwImageSpecification'

category: 'accessing'
method: RwImageSpecification
loadedCommitId

	^ loadedCommitId ifNil: [ '' ]
%

category: 'accessing'
method: RwImageSpecification
loadedCommitId: anObject
  loadedCommitId := anObject
%

category: 'accessing'
method: RwImageSpecification
loadedConfigurationNames

	^ loadedConfigurationNames
%

category: 'accessing'
method: RwImageSpecification
loadedConfigurationNames: aCollection

	loadedConfigurationNames := aCollection
%

category: 'accessing'
method: RwImageSpecification
loadedGroupNames

	^ loadedGroupNames
%

category: 'accessing'
method: RwImageSpecification
loadedGroupNames: aCollection

	loadedGroupNames := aCollection
%

category: 'copying'
method: RwImageSpecification
postCopy
  "don't forget to copy any compound state objects"

  super postCopy
%

category: 'accessing'
method: RwImageSpecification
repositoryUrl

   ^repositoryUrl
%

category: 'accessing'
method: RwImageSpecification
repositoryUrl: anObject

   repositoryUrl := anObject
%

! Class implementation for 'RwPackageProjectImageSpecification'

!		Instance methods for 'RwPackageProjectImageSpecification'

category: 'accessing'
method: RwPackageProjectImageSpecification
loadedPackageNames

	"method and iv should go away when Rowan is managed in Rowan"

	^ loadedPackageNames ifNil: [ #() ]
%

category: 'accessing'
method: RwPackageProjectImageSpecification
loadedPackageNames: anObject

	loadedPackageNames := anObject
%

category: 'copying'
method: RwPackageProjectImageSpecification
postCopy

	"don't forget to copy any compound state objects"

	super postCopy.
	loadedPackageNames := loadedPackageNames copy
%

! Class implementation for 'RwGemStoneSpecification'

!		Instance methods for 'RwGemStoneSpecification'

category: 'accessing'
method: RwGemStoneSpecification
defaultMethodEnv

	^ defaultMethodEnv ifNil: [ defaultMethodEnv := 0 ]
%

category: 'accessing'
method: RwGemStoneSpecification
defaultMethodEnv: anInteger

	defaultMethodEnv := anInteger
%

category: 'accessing'
method: RwGemStoneSpecification
defaultSymbolDictName

	^ defaultSymbolDictName ifNil: [ 'UserGlobals' ]
%

category: 'accessing'
method: RwGemStoneSpecification
defaultSymbolDictName: aString

	defaultSymbolDictName := aString
%

category: 'accessing'
method: RwGemStoneSpecification
defaultUseSessionMethodsForExtensions

	^ defaultUseSessionMethodsForExtensions
		ifNil: [ defaultUseSessionMethodsForExtensions := false ]
%

category: 'accessing'
method: RwGemStoneSpecification
defaultUseSessionMethodsForExtensions: aBool

	aBool ifTrue: [ Rowan image ensureSessionMethodsEnabled ].
	defaultUseSessionMethodsForExtensions := aBool
%

category: 'initialization'
method: RwGemStoneSpecification
initialize

	super initialize.
	packageNameToPlatformPropertiesMap := Dictionary new
%

category: 'initialization'
method: RwGemStoneSpecification
initializeForExport
  "if spec has been exported, clear out any of the fields that represent local disk state"

	super initializeForExport.
	projectOwnerId := nil.
%

category: 'accessing'
method: RwGemStoneSpecification
methodEnv: methodEnv forPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ packageNameToPlatformPropertiesMap at: packageName put: Dictionary new ].
	packageProperties at: 'methodEnv' put: methodEnv
%

category: 'accessing'
method: RwGemStoneSpecification
methodEnvForPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ ^ self defaultMethodEnv ].
	^ packageProperties at: 'methodEnv' ifAbsent: [ ^ self defaultMethodEnv ]
%

category: 'accessing'
method: RwGemStoneSpecification
packageNameToPlatformPropertiesMap

	^ packageNameToPlatformPropertiesMap
%

category: 'accessing'
method: RwGemStoneSpecification
packageNameToPlatformPropertiesMap: aDictionary

	packageNameToPlatformPropertiesMap := aDictionary
%

category: 'copying'
method: RwGemStoneSpecification
postCopy

	"don't forget to copy any compound state objects"

	super postCopy.
	packageNameToPlatformPropertiesMap := packageNameToPlatformPropertiesMap copy.
	packageNameToPlatformPropertiesMap
		keysAndValuesDo: [ :key :value | packageNameToPlatformPropertiesMap at: key put: value copy ]
%

category: 'accessing'
method: RwGemStoneSpecification
projectOwnerId

	^ projectOwnerId ifNil: [ Rowan image currentUserId ]
%

category: 'accessing'
method: RwGemStoneSpecification
projectOwnerId: anObject

   projectOwnerId := anObject
%

category: 'accessing'
method: RwGemStoneSpecification
setSymbolDictName: symbolDictName forPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ packageNameToPlatformPropertiesMap at: packageName put: Dictionary new ].
	symbolDictName 
		ifNil: [
			"remove the entry if it exists"
			packageProperties removeKey: 'symbolDictName' ifAbsent: [].
			^self ].
	packageProperties at: 'symbolDictName' put: symbolDictName
%

category: 'accessing'
method: RwGemStoneSpecification
setUseSessionMethodsForExtensions: aBool forPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ packageNameToPlatformPropertiesMap at: packageName put: Dictionary new ].
	aBool 
		ifNil: [
			"remove the entry if it exists"
			packageProperties removeKey: 'useSessionMethodsForExtensions' ifAbsent: [].
			^self ].
	aBool ifTrue: [ Rowan image ensureSessionMethodsEnabled ].
	packageProperties at: 'useSessionMethodsForExtensions' put: aBool
%

category: 'accessing'
method: RwGemStoneSpecification
symbolDictNameForPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ ^ self defaultSymbolDictName ].
	^ packageProperties
		at: 'symbolDictName'
		ifAbsent: [ ^ self defaultSymbolDictName ]
%

category: 'accessing'
method: RwGemStoneSpecification
userId: userId forPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ packageNameToPlatformPropertiesMap at: packageName put: Dictionary new ].
	packageProperties at: 'userId' put: userId
%

category: 'accessing'
method: RwGemStoneSpecification
useSessionMethodsForExtensionsForPackageNamed: packageName

	| packageProperties |
	packageProperties := packageNameToPlatformPropertiesMap
		at: packageName
		ifAbsent: [ ^ self defaultUseSessionMethodsForExtensions ].
	^ packageProperties
		at: 'useSessionMethodsForExtensions'
		ifAbsent: [ ^ self defaultUseSessionMethodsForExtensions ]
%

! Class implementation for 'RwProjectSpecification'

!		Class methods for 'RwProjectSpecification'

category: 'instance creation'
classmethod: RwProjectSpecification
newNamed: aString

	^ self new
		specName: aString;
		yourself
%

!		Instance methods for 'RwProjectSpecification'

category: 'converting'
method: RwProjectSpecification
asDefinition

	"answer an RwProjectDefintion created using the reciever"

	^RwProjectDefinition newForSpecification: self
%

category: 'testing'
method: RwProjectSpecification
canCommit
  ^ self repositoryUrl notNil and: [ self repoSpec canCommit ]
%

category: 'accessing'
method: RwProjectSpecification
comment

   ^comment
%

category: 'accessing'
method: RwProjectSpecification
comment: anObject

   comment := anObject
%

category: 'actions'
method: RwProjectSpecification
commitForTool: aRwTool message: messageString
  ^ self repoSpec commitForTool: aRwTool message: messageString
%

category: 'actions'
method: RwProjectSpecification
commitLogForTool: aRwTool limit: logLimit
  ^ self repoSpec commitLogForTool: aRwTool limit: logLimit
%

category: 'accessing'
method: RwProjectSpecification
configsPath

	^ configsPath ifNil: [ configsPath := 'rowan/configs' ]
%

category: 'accessing'
method: RwProjectSpecification
configsPath: anObject

   configsPath := anObject
%

category: 'accessing'
method: RwProjectSpecification
defaultConfigurationNames

	^ defaultConfigurationNames
%

category: 'accessing'
method: RwProjectSpecification
defaultGroupNames

	^ defaultGroupNames
%

category: 'exporting'
method: RwProjectSpecification
export

	| url exportUrl exportPath |
	self repositoryUrl
		ifNil: [ self error: 'exportToUrl: must be used if repositoryUrl has not been set' ].
	url := RwUrl fromString: self repositoryUrl.
	exportPath := self repositoryRootPath , '/' , self specsPath , '/'.
	CypressFileUtilities current ensureDirectoryExists: exportPath.
	exportUrl := 'file:' , exportPath.
	^ self exportToUrl: exportUrl
%

category: 'exporting'
method: RwProjectSpecification
exportToUrl: fileUrl

	^ self copy
		initializeForExport;
		_exportToUrl: fileUrl
%

category: 'exporting'
method: RwProjectSpecification
exportToUrl: fileUrl as: fileName

	^ self copy
		initializeForExport;
		_exportToUrl: fileUrl as: fileName
%

category: 'accessing'
method: RwProjectSpecification
imageSpec

	^ imageSpec ifNil: [ imageSpec := RwSimpleProjectImageSpecification new ]
%

category: 'accessing'
method: RwProjectSpecification
imageSpec: anObject

   imageSpec := anObject
%

category: 'initialization'
method: RwProjectSpecification
initializeForExport

	"before spec is exported, clear out any of the fields that are not to be included"

	super initializeForExport.
	imageSpec := nil.
	platformSpec valuesDo: [:each | each initializeForExport ].
	repoSpec initializeForExport
%

category: 'initialization'
method: RwProjectSpecification
initializeForImport

	"if spec has been imported, clear out any of the fields that represent local disk state"

	super initializeForImport.
	imageSpec := nil.
	platformSpec valuesDo: [:each | each initializeForImport ].
	repoSpec initializeForImport
%

category: 'accessing'
method: RwProjectSpecification
loadedCommitId

	imageSpec ifNil: [ ^ '' ].
	^ self imageSpec loadedCommitId
%

category: 'accessing'
method: RwProjectSpecification
loadedConfigurationNames

	imageSpec ifNil: [ ^ #() ].
	^ self imageSpec loadedConfigurationNames
%

category: 'accessing'
method: RwProjectSpecification
loadedGroupNames

	imageSpec ifNil: [ ^ #() ].
	^ self imageSpec loadedGroupNames
%

category: 'accessing'
method: RwProjectSpecification
packageOrGroupNamesToLoad: packageOrGroupNames

	self subclassResponsibility: #packageOrGroupNamesToLoad:
%

category: 'accessing'
method: RwProjectSpecification
platformSpec: anObject

   platformSpec := anObject
%

category: 'copying'
method: RwProjectSpecification
postCopy
  "don't forget to copy any compound state objects"

  | oldPlatformSpec |
  super postCopy.
  oldPlatformSpec := platformSpec.
  platformSpec := Dictionary new.
  oldPlatformSpec
    keysAndValuesDo: [ :key :value | platformSpec at: key put: value copy ].
  repoSpec := repoSpec copy.
  imageSpec := imageSpec copy
%

category: 'accessing'
method: RwProjectSpecification
projectUrl

   ^projectUrl
%

category: 'accessing'
method: RwProjectSpecification
projectUrl: anObject

   projectUrl := anObject
%

category: 'actions'
method: RwProjectSpecification
pullForTool: aRwTool remote: remoteString
  ^ self repoSpec pullForTool: aRwTool remote: remoteString
%

category: 'actions'
method: RwProjectSpecification
pushForTool: aRwTool remote: remoteString
  ^ self repoSpec pushForTool: aRwTool remote: remoteString
%

category: 'accessing'
method: RwProjectSpecification
remote

	^ self repoSpec remote
%

category: 'accessing'
method: RwProjectSpecification
repoPath

   ^repoPath ifNil: [ repoPath := 'rowan/src' ]
%

category: 'accessing'
method: RwProjectSpecification
repoPath: anObject

   repoPath := anObject
%

category: 'accessing'
method: RwProjectSpecification
repositoryRootPath
  ^ self repoSpec repositoryRootPath
%

category: 'accessing'
method: RwProjectSpecification
repositoryRootPath: anObject
  self repoSpec repositoryRootPath: anObject
%

category: 'accessing'
method: RwProjectSpecification
repositoryUrl

   ^self imageSpec repositoryUrl
%

category: 'accessing'
method: RwProjectSpecification
repositoryUrl: anObject

   self imageSpec repositoryUrl: anObject
%

category: 'accessing'
method: RwProjectSpecification
repoSpec

   ^repoSpec
%

category: 'accessing'
method: RwProjectSpecification
repoSpec: anObject

   repoSpec := anObject
%

category: 'accessing'
method: RwProjectSpecification
specName

   ^specName
%

category: 'accessing'
method: RwProjectSpecification
specName: anObject

   specName := anObject
%

category: 'accessing'
method: RwProjectSpecification
specsPath

	^ specsPath ifNil: [ specsPath := 'rowan/specs' ]
%

category: 'accessing'
method: RwProjectSpecification
specsPath: anObject

   specsPath := anObject
%

category: 'actions'
method: RwProjectSpecification
updateLoadedCommitIdForTool: aRwTool
  ^ self repoSpec updateLoadedCommitIdForTool: aRwTool
%

category: 'accessing'
method: RwProjectSpecification
useGit

	^ self repoSpec useGit
%

category: 'accessing'
method: RwProjectSpecification
version
	"answer the version of the class --- used to mark the version of the class for objects written to disk"

	"see currentVersion method for list of versions"

	"currently RwProjectSpecification is the only instance being versioned as it represents the version of the whole structure, 
		but I don't want to rule out the possiblity that other specs may need to be independently versioned."

	^ version
%

category: 'exporting'
method: RwProjectSpecification
_exportToUrl: fileUrl
	^ self _exportToUrl: fileUrl as: self specName , '.ston'
%

category: 'exporting'
method: RwProjectSpecification
_exportToUrl: fileUrl as: fileName
  | url |
  url := RwUrl fromString: fileUrl.
  url schemeName = 'file'
    ifTrue: [ 
      CypressFileUtilities current
        writeStreamFor: fileName
        in: url pathForDirectory
        do: [ :stream | 
          | string |
          string := STON toStringPretty: self.
          stream nextPutAll: string.
          ^ self ] ].
  ^ nil	"otherwise a noop"
%

category: 'private'
method: RwProjectSpecification
_myUserProfile
  ^ System myUserProfile
%

! Class implementation for 'RwPackageProjectSpecification'

!		Instance methods for 'RwPackageProjectSpecification'

category: 'accessing'
method: RwPackageProjectSpecification
imageSpec

	^ imageSpec ifNil: [ imageSpec := RwPackageProjectImageSpecification new ]
%

category: 'accessing'
method: RwPackageProjectSpecification
packageNamesToLoad: anObject

   packageNamesToLoad := anObject
%

category: 'accessing'
method: RwPackageProjectSpecification
packageOrGroupNamesToLoad: packageOrGroupNames

   packageNames := packageOrGroupNames
%

category: 'copying'
method: RwPackageProjectSpecification
postCopy
  "don't forget to copy any compound state objects"

  super postCopy.
  packageNames := packageNames copy.
  packageNamesToLoad := packageNamesToLoad copy
%

! Class implementation for 'RwReferenceSpecification'

!		Instance methods for 'RwReferenceSpecification'

category: 'accessing'
method: RwReferenceSpecification
referenceUrl

   ^referenceUrl
%

category: 'accessing'
method: RwReferenceSpecification
referenceUrl: anObject

   referenceUrl := anObject
%

category: 'actions'
method: RwReferenceSpecification
resolve
%

! Class implementation for 'RwRepositorySpecification'

!		Instance methods for 'RwRepositorySpecification'

category: 'testing'
method: RwRepositorySpecification
canCommit
  ^ false
%

category: 'actions'
method: RwRepositorySpecification
commitForTool: aRwTool message: messageString
  "commit not supported by default"

  
%

category: 'actions'
method: RwRepositorySpecification
commitLogForTool: aRwTool limit: logLimit
  "commit log not supported by default"

  
%

category: 'copying'
method: RwRepositorySpecification
postCopy
  "don't forget to copy any compound state objects"

  super postCopy
%

category: 'actions'
method: RwRepositorySpecification
pullForTool: aRwTool remote: remoteOrNil
  "pull not supported by default"

  
%

category: 'actions'
method: RwRepositorySpecification
pushForTool: aRwTool remote: remoteOrNil
  "push not supported by default"

  
%

category: 'accessing'
method: RwRepositorySpecification
repositoryRootPath

   ^repositoryRootPath
%

category: 'accessing'
method: RwRepositorySpecification
repositoryRootPath: anObject

   repositoryRootPath := anObject
%

category: 'actions'
method: RwRepositorySpecification
updateLoadedCommitIdForTool: aRwTool
  "commit not supported by default"

  
%

category: 'accessing'
method: RwRepositorySpecification
useGit

	^ false
%

! Class implementation for 'RwDiskRepositorySpecification'

!		Instance methods for 'RwDiskRepositorySpecification'

category: 'accessing'
method: RwDiskRepositorySpecification
committish
  ^ ''
%

category: 'copying'
method: RwDiskRepositorySpecification
postCopy
  "don't forget to copy any compound state objects"

  super postCopy
%

! Class implementation for 'RwGitRepositorySpecification'

!		Instance methods for 'RwGitRepositorySpecification'

category: 'accessing'
method: RwGitRepositorySpecification
branch: aString

	self committish: aString.
	self committishType: 'branch'
%

category: 'testing'
method: RwGitRepositorySpecification
canCommit
  ^ true
%

category: 'actions'
method: RwGitRepositorySpecification
commitForTool: aRwTool message: messageString
  ^ aRwTool doGitCommit: messageString
%

category: 'actions'
method: RwGitRepositorySpecification
commitLogForTool: aRwTool limit: logLimit
  ^ aRwTool doGitCommitLog: logLimit
%

category: 'accessing'
method: RwGitRepositorySpecification
committish
  ^ committish
%

category: 'accessing'
method: RwGitRepositorySpecification
committish: anObject
  committish := anObject
%

category: 'accessing'
method: RwGitRepositorySpecification
committishType

	" branch, SHA, tag, tagPattern"

	^ committishType
%

category: 'accessing'
method: RwGitRepositorySpecification
committishType: anObject
  committishType := anObject
%

category: 'initialization'
method: RwGitRepositorySpecification
initialize
  super initialize.
  committish := 'master'.
  committishType := 'branch'
%

category: 'initialization'
method: RwGitRepositorySpecification
initializeForExport
  "if spec has been exported, clear out any of the fields that represent local disk state"

  super initializeForImport.
  remote := repositoryRootPath := nil
%

category: 'initialization'
method: RwGitRepositorySpecification
initializeForImport
  "if spec has been imported, clear out any of the fields that represent local disk state"

  super initializeForImport.
  remote := repositoryRootPath := nil
%

category: 'copying'
method: RwGitRepositorySpecification
postCopy
  "don't forget to copy any compound state objects"

  super postCopy
%

category: 'actions'
method: RwGitRepositorySpecification
pullForTool: aRwTool remote: remoteString
  ^ aRwTool doGitPull: remoteString
%

category: 'actions'
method: RwGitRepositorySpecification
pushForTool: aRwTool remote: remoteString
  ^ aRwTool doGitPush: remoteString
%

category: 'accessing'
method: RwGitRepositorySpecification
remote

	^ remote ifNil: [ 'origin' ]
%

category: 'accessing'
method: RwGitRepositorySpecification
remote: anObject

   remote := anObject
%

category: 'accessing'
method: RwGitRepositorySpecification
SHA: aString

	self committish: aString.
	self committishType: 'SHA'
%

category: 'accessing'
method: RwGitRepositorySpecification
tag: aString

	self committish: aString.
	self committishType: 'tag'
%

category: 'accessing'
method: RwGitRepositorySpecification
tagPattern: aString

	self committish: aString.
	self committishType: 'tagPattern'
%

category: 'actions'
method: RwGitRepositorySpecification
updateLoadedCommitIdForTool: aRwTool
  ^ aRwTool doGitUpdateLoadedCommitId
%

category: 'accessing'
method: RwGitRepositorySpecification
useGit

	^ true
%

! Class implementation for 'RwUrl'

!		Class methods for 'RwUrl'

category: 'instance creation'
classmethod: RwUrl
fromString: aString
  "Return a URL from a string and handle
	a String without a scheme as a HttpUrl."

  "RwUrl fromString: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'"

  "RwUrl fromString: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"

  "RwUrl fromString: 'telnet:chaos.resnet.gatech.edu'"

  "RwUrl fromString: 'file:/etc/passwd'"

  | remainder index scheme fragment newUrl |
  remainder := aString trimSeparators.
  index := remainder indexOf: $#.
  index > 0
    ifTrue: [ 
      "extract the fragment, if any"
      fragment := remainder copyFrom: index + 1 to: remainder size.
      remainder := remainder copyFrom: 1 to: index - 1 ].
  scheme := self schemeNameForString: remainder.
  (scheme = 'http' or: [ scheme = 'https' ])
    ifTrue: [ ^ self httpFromString: aString ].
  newUrl := (self urlClassForScheme: scheme) new
    privateInitializeFromText: remainder.
  newUrl privateFragment: fragment.
  ^ newUrl
%

category: 'parsing'
classmethod: RwUrl
httpFromString: aString
  ^CypressUrl absoluteFromText: aString
%

category: 'constants'
classmethod: RwUrl
schemeName

	"When searching for a class to handle a particular scheme, make sure that Url classes never match by default. This is so that abstract Url classes e.g. HierarchicalUrl can be iterated over, but will not be selected"

	^ #'none'
%

category: 'parsing'
classmethod: RwUrl
schemeNameForString: aString
	"Get the scheme name from a string, or return nil if it's not specified. 
	Used in internal parsing routines - an outsider may as well use asUrl. 
	Return scheme in lowercases."
	
	"Url schemeNameForString: 'http://www.yahoo.com'"
	"Url schemeNameForString: '/etc/passwed'"
	"Url schemeNameForString: '/etc/testing:1.2.3'"

	| index schemeName |
	index := aString indexOf: $: ifAbsent: [^ nil].
	schemeName := aString copyFrom: 1 to: index - 1.
	(schemeName allSatisfy: [:each | each isLetter]) ifFalse: [^ nil].
	^ schemeName asLowercase
%

category: 'parsing'
classmethod: RwUrl
urlClassForScheme: scheme

	"explicitly list the classes to be matched: https://github.com/dalehenrich/Rowan/issues/211"

	^ {RwFileUrl. RwCypressUrl. RwTonelUrl. RwFiletreeUrl. RwGithubUrl. RwGenericUrl. RwHierarchicalUrl. RwSmalltalkRepositoryUrl. RwGitFileTreeUrl}
				detect: [ :urlClass | urlClass schemeName = scheme ]
				ifNone: [ RwGenericUrl ].
%

!		Instance methods for 'RwUrl'

category: 'converting'
method: RwUrl
asRwRepository
  "return a platform appropriate repository for the repository identified in the receiver"

  ^ self subclassResponsibility: #'asRwRepository'
%

category: 'converting'
method: RwUrl
asRwUrl
  ^ self
%

category: 'converting'
method: RwUrl
asString

	^self printString
%

category: 'converting'
method: RwUrl
asUrl
	^self
%

category: 'accessing'
method: RwUrl
authority
	^''
%

category: 'rowan support'
method: RwUrl
createRwCypressRepositoryForPath: repositoryDirectoryPath
  | repo |
  repo := CypressFileSystemRepository new
    initializeDefaultRepositoryProperties;
    codeFormatProperty: 'Cypress';
    strictCodeFormat: false;
    initializeForDirectory: repositoryDirectoryPath;
    url: self printString;
    yourself.
  ^ repo
%

category: 'rowan support'
method: RwUrl
createRwFiletreeRepositoryForPath: repositoryDirectoryPath

	^ CypressFileSystemRepository new
		initializeDefaultRepositoryProperties;
		initializeForDirectory: repositoryDirectoryPath;
		codeFormatProperty: 'FileTree';
		strictCodeFormat: false;
		initializeReaderAndWriterClasses;
		url: self printString;
		yourself
%

category: 'rowan support'
method: RwUrl
createRwRepositoryForFormat: repositoryFormat forPath: repositoryDirectoryPath
  repositoryFormat = 'tonel'
    ifTrue: [ ^ self createRwTonelRepositoryForPath: repositoryDirectoryPath ].
  repositoryFormat = 'filetree'
    ifTrue: [ ^ self createRwFiletreeRepositoryForPath: repositoryDirectoryPath ].
  repositoryFormat = 'cypress'
    ifTrue: [ ^ self createRwCypressRepositoryForPath: repositoryDirectoryPath ]
%

category: 'rowan support'
method: RwUrl
createRwRepositoryForPath: repositoryDirectoryPath
  | hasCypress hasFiletree hasTonel repositoryFormat |
  hasTonel := hasCypress := hasFiletree := false.
  (self fileUtils directoryEntriesFrom: repositoryDirectoryPath)
    do: [ :entry | 
      | filename |
      filename := self fileUtils localNameFrom: entry.
      filename = 'properties.st'
        ifTrue: [ hasTonel := true ].
      filename = '.cypress'
        ifTrue: [ hasCypress := true ].
      filename = '.filetree'
        ifTrue: [ hasFiletree := true ] ].
  hasCypress | hasTonel
    ifTrue: [
      | theFilename |
      theFilename := hasTonel
        ifTrue: [ 'properties.st' ]
        ifFalse: [ '.cypress' ].
      self fileUtils
        readStreamFor: theFilename
        in: repositoryDirectoryPath
        do: [ :fileStream | 
          repositoryFormat := (STON fromStream: fileStream)
            at: #'format'
            ifAbsent: [ 'filetree' ] ].
      ^ self
        createRwRepositoryForFormat: repositoryFormat
        forPath: repositoryDirectoryPath ].
  hasFiletree
    ifTrue: [ ^ self createRwRepositoryForFormat: 'filetree' forPath: repositoryDirectoryPath ].
  ^ self createRwRepositoryForFormat: 'cypress' forPath: repositoryDirectoryPath
%

category: 'rowan support'
method: RwUrl
createRwTonelRepositoryForPath: repositoryDirectoryPath
  ^ CypressTonelRepository new
    initializeDefaultRepositoryProperties;
    initializeForDirectory: repositoryDirectoryPath;
    codeFormatProperty: 'Tonel';
    strictCodeFormat: false;
    initializeReaderAndWriterClasses;
    url: self printString;
    yourself
%

category: 'rowan support'
method: RwUrl
fileUtils
  ^ Rowan fileUtilities
%

category: 'fragment'
method: RwUrl
fragment
	^fragment
%

category: 'accessing'
method: RwUrl
pathFor: coll
  | ans sz |
  ans := WriteStreamPortable on: String new.
  sz := coll size.
  1 to: sz do: [ :index | 
    | pathElem |
    pathElem := coll at: index.
    ans nextPutAll: pathElem.
    index < sz
      ifTrue: [ ans nextPut: $/ ] ].
  ^ ans contents
%

category: 'printing'
method: RwUrl
printOn: aStream

	^self subclassResponsibility: #printOn:
%

category: 'fragment'
method: RwUrl
privateFragment: aString
	fragment := aString
%

category: 'parsing'
method: RwUrl
privateInitializeFromText: aString

	^self subclassResponsibility: #privateInitializeFromText:
%

category: 'parsing'
method: RwUrl
privateInitializeFromText: aString relativeTo: aUrl
	"initialize from the given string, as a relative URL.  aString will have had the scheme name removed, if it was present to begin with.  If it was, then the scheme name was the same as the receiver's scheme name"

	"by default, just do regular initialization"
	^self privateInitializeFromText: aString
%

category: 'classification'
method: RwUrl
scheme
	"return a string with the scheme of this URL.  For instance, HTTP"

	^self subclassResponsibility: #scheme
%

! Class implementation for 'RwFileUrl'

!		Class methods for 'RwFileUrl'

category: 'instance creation'
classmethod: RwFileUrl
fromString: aString
	"Method that can be called explicitly to create a FileUrl."

	^self new privateInitializeFromText: aString
%

category: 'constants'
classmethod: RwFileUrl
schemeName
	^'file'
%

!		Instance methods for 'RwFileUrl'

category: 'converting'
method: RwFileUrl
asRwRepository
  "return a platform appropriate repository for the repository located in the directory referenced by the receiver"

  ^ self createRwRepositoryForPath: self pathForDirectory
%

category: 'accessing'
method: RwFileUrl
fileName
	"Return the last part of the path,
	most often a filename but can also be a directory."

	^self path last
%

category: 'testing'
method: RwFileUrl
firstPartIsDriveLetter
	"Return true if the first part of the path is a letter
	followed by a $: like 'C:' "
	
	| firstPart |
	path isEmpty ifTrue: [^false].
	firstPart := path first.
	^firstPart size = 2 and: [
		firstPart first isLetter
			and: [firstPart last = $:]]
%

category: 'accessing'
method: RwFileUrl
host
	"Return the host name, either 'localhost', '', or a fully qualified domain name."
	
	^host ifNil: ['']
%

category: 'accessing'
method: RwFileUrl
host: hostName
	"Set the host name, either 'localhost', '', or a fully qualified domain name."
	
	host := hostName
%

category: 'private-initialization'
method: RwFileUrl
host: aHostString pathParts: aCollection isAbsolute: aBoolean

	host := aHostString.
	path := aCollection.
	isAbsolute := aBoolean
%

category: 'private-initialization'
method: RwFileUrl
initializeFromPathString: aPathString
	"<aPathString> is a file path as a String.
	We construct a path collection using various heuristics."

	| pathString hasDriveLetter |
	pathString := aPathString.
	pathString isEmpty ifTrue: [pathString := '/'].
	"Copy without empty string preceeding first / or between duplicated /s."
	path := ((pathString subStrings: '/') copyWithout: '') collect: [:token | token unescapePercents].

	"A path like 'C:' refers in practice to 'c:/'"
	((pathString endsWith: '/') or:
		[(hasDriveLetter := self firstPartIsDriveLetter) and: [path size = 1]])
			ifTrue: [path add: ''].

	"Decide if we are absolute by checking for leading $/ or
	beginning with drive letter. Smarts for other OSes?"
	self isAbsolute: ((pathString beginsWith: '/')
						or: [hasDriveLetter ifNil: [self firstPartIsDriveLetter]])
%

category: 'accessing'
method: RwFileUrl
isAbsolute
	"Should the path be considered absolute to
	the filesystem instead of relative to the default directory?"
 
	^isAbsolute
%

category: 'accessing'
method: RwFileUrl
isAbsolute: aBoolean
	"Set if the path should be considered absolute to
	the filesystem instead of relative to the default directory."

	isAbsolute := aBoolean
%

category: 'accessing'
method: RwFileUrl
path
	"Return an ordered collection of the path elements."
	
	^path
%

category: 'accessing'
method: RwFileUrl
path: aCollection
	"Set the collection of path elements."

	path := aCollection
%

category: 'paths'
method: RwFileUrl
pathDirString
	"Path to directory as url, using slash as delimiter.
	Filename is left out."

	^String streamContents: [ :s |
		isAbsolute ifTrue: [ s nextPut: $/ ].
		1 to: self path size - 1 do: [ :ii |
			s nextPutAll: (path at: ii); nextPut: $/]]
%

category: 'paths'
method: RwFileUrl
pathForDirectory
	"Path using local file system's pathname delimiter.
	DOS paths with drive letters should not
	be prepended with a delimiter even though
	they are absolute. Filename is left out."

	| delimiter |
	delimiter :=  CypressFileUtilities current pathNameDelimiter.
	^String streamContents: [ :s |
		(self isAbsolute and: [self firstPartIsDriveLetter not])
			ifTrue: [ s nextPutAll: delimiter ].
		1 to: self path size - 1 do: [ :ii |
			s nextPutAll: (path at: ii); nextPutAll: delimiter]]
%

category: 'paths'
method: RwFileUrl
pathForFile
  ^ self pathString
%

category: 'private-initialization'
method: RwFileUrl
pathParts: aCollection isAbsolute: aBoolean

	^self host: nil pathParts: aCollection isAbsolute: aBoolean
%

category: 'paths'
method: RwFileUrl
pathString
	"Path as it appears in a URL with $/ as delimiter."
	
	
	^String streamContents: [ :s | | first |
		"isAbsolute ifTrue:[ s nextPut: $/ ]."
		first := true.
		self path do: [ :p |
			first ifFalse: [ s nextPut: $/ ].
			first := false.
			s nextPutAll: p  ] ]
%

category: 'copying'
method: RwFileUrl
postCopy
	"Be sure not to share the path with the copy."

	super postCopy.
	path := path copy
%

category: 'printing'
method: RwFileUrl
printOn: aStream
	"Return the FileUrl according to RFC3986
		'file:'['//'<host>]<path>#<fragment>
	Note that <host> being '' is equivalent to 'localhost' and is not printed."

	aStream nextPutAll: self schemeName;
		nextPut: $:.

	"File URLs with hosts (which are fairly useless) cannot be relative."
	host isEmpty ifFalse: [isAbsolute ifFalse: [aStream nextPutAll: '<ErroneousURL>'. ^nil].
						aStream nextPutAll: '//';
						nextPutAll: host].

	isAbsolute ifTrue: [aStream nextPut: $/].

	aStream
		nextPutAll: self pathString.

	fragment ifNotNil:
		[aStream
			nextPut: $#;
			nextPutAll: fragment ].
%

category: 'private-initialization'
method: RwFileUrl
privateInitializeFromText: aString
	"Calculate host and path from a file URL in String format.
	Some malformed formats are allowed and interpreted by guessing."

	| schemeName pathString bare i |
	bare := aString trimSeparators.
	schemeName := RwUrl schemeNameForString: bare.
	(schemeName == nil  or: [schemeName ~= self schemeName])
		ifTrue: [
			host := ''.
			pathString := bare]
		ifFalse: [
			"First remove schemeName and colon"
			bare := bare copyFrom: (schemeName size + 2) to: bare size.
			"A proper file URL then has two slashes before host,
			A malformed URL is interpreted as using syntax file:<path>."
			(bare beginsWith: '//')
				ifTrue: [i := bare indexOf: $/ startingAt: 3.
						i=0 ifTrue: [
								host := bare copyFrom: 3 to: bare size.
								pathString := '']
							ifFalse: [
								host := bare copyFrom: 3 to: i-1.
								pathString := bare copyFrom: host size + 3 to: bare size]]
				ifFalse: [host := ''.
						pathString := bare]].
	self initializeFromPathString: pathString
%

category: 'private-initialization'
method: RwFileUrl
privateInitializeFromText: pathString relativeTo: aUrl
	"<pathString> should be a filesystem path.
	This url is adjusted to be aUrl + the path."

	| newPath |
	self host: aUrl host.
	self initializeFromPathString: pathString.
	self isAbsolute: aUrl isAbsolute.

	newPath := aUrl path copy.
	newPath removeLast.	"empty string that says its a directory"
	path do: [ :token |
		((token ~= '..') and: [token ~= '.']) ifTrue: [ 
			newPath addLast: token unescapePercents ].
		token = '..' ifTrue: [ 
			newPath isEmpty ifFalse: [ 
				newPath last = '..' ifFalse: [ newPath removeLast ] ] ].
		"token = '.' do nothing" ].
	path := newPath

	
%

category: 'classification'
method: RwFileUrl
scheme
	^self class schemeName
%

category: 'classification'
method: RwFileUrl
schemeName
	^self class schemeName
%

category: 'accessing'
method: RwFileUrl
segments

	^ path
%

! Class implementation for 'RwCypressUrl'

!		Class methods for 'RwCypressUrl'

category: 'constants'
classmethod: RwCypressUrl
schemeName
  ^ 'cypress'
%

! Class implementation for 'RwTonelUrl'

!		Class methods for 'RwTonelUrl'

category: 'constants'
classmethod: RwTonelUrl
schemeName
	^'tonel'
%

!		Instance methods for 'RwTonelUrl'

category: 'converting'
method: RwTonelUrl
asRwRepository
  "return a platform appropriate repository for the repository located in the directory referenced by the receiver"

  ^ self createRwTonelRepositoryForPath: self pathForDirectory
%

! Class implementation for 'RwFiletreeUrl'

!		Class methods for 'RwFiletreeUrl'

category: 'constants'
classmethod: RwFiletreeUrl
schemeName
	^'filetree'
%

!		Instance methods for 'RwFiletreeUrl'

category: 'converting'
method: RwFiletreeUrl
asRwRepository
  "return a platform appropriate repository for the repository located in the directory referenced by the receiver"

  ^ self createRwFiletreeRepositoryForPath: self pathForDirectory
%

category: 'printing'
method: RwFiletreeUrl
printOn: aStream
  aStream
    nextPutAll: self schemeName;
    nextPut: $:.
  aStream nextPutAll: '//'.
  aStream nextPutAll: self pathString
%

category: 'private-initialization'
method: RwFiletreeUrl
privateInitializeFromText: aString
  "Calculate host and path from a file URL in String format.
	Some malformed formats are allowed and interpreted by guessing."

  | schemeName pathString bare |
  host := ''.
  bare := aString trimSeparators.
  schemeName := RwUrl schemeNameForString: bare.
  (schemeName == nil or: [ schemeName ~= self schemeName ])
    ifTrue: [ pathString := bare ]
    ifFalse: [ 
      "First remove schemeName and colon"
      bare := bare copyFrom: schemeName size + 2 to: bare size.
      (bare beginsWith: '//')
        ifTrue: [ pathString := bare copyFrom: 3 to: bare size ]
        ifFalse: [ pathString := bare ] ].
  self initializeFromPathString: pathString
%

! Class implementation for 'RwGithubUrl'

!		Class methods for 'RwGithubUrl'

category: 'constants'
classmethod: RwGithubUrl
schemeName
  ^ 'github'
%

!		Instance methods for 'RwGithubUrl'

category: 'converting'
method: RwGithubUrl
asRwRepository
  "return a platform appropriate repository for the repository identified in the receiver"

  ^ self halt: 'not yet implemented'
%

category: 'accessing'
method: RwGithubUrl
dirPath
  ^ self pathFor: dir
%

category: 'printing'
method: RwGithubUrl
printOn: aStream
  aStream
    nextPutAll: self schemeName;
    nextPut: $:.
  aStream nextPutAll: '//'.
  aStream nextPutAll: self pathString
%

category: 'private-initialization'
method: RwGithubUrl
privateInitializeFromText: aString
  | parsedPath |
  super privateInitializeFromText: aString.
  parsedPath := {host} , path.
  (parsedPath
    detect: [ :e | e includes: $: ]
    ifNone: [ 
      project := parsedPath copyFrom: 1 to: parsedPath size - 1.
      dir := parsedPath copyFrom: 2 to: parsedPath size ])
    ifNotNil: [ :pivot | 
      project := parsedPath copyFrom: 1 to: (parsedPath indexOf: pivot) - 1.
      project addLast: (pivot copyUpTo: $:).
      committish := pivot copyFrom: (pivot indexOf: $:) + 1 to: pivot size.
      dir := parsedPath
        copyFrom: (parsedPath indexOf: pivot) + 1
        to: parsedPath size ].
  path := parsedPath.
  host := ''
%

category: 'accessing'
method: RwGithubUrl
projectPath
  ^ self pathFor: project
%

! Class implementation for 'RwGenericUrl'

!		Class methods for 'RwGenericUrl'

category: 'parsing'
classmethod: RwGenericUrl
fromString: aString
	| schemeName locator |
	schemeName := RwUrl schemeNameForString: aString.
	schemeName ifNil: [ ^self schemeName: 'xnoscheme' locator: aString ].
	locator := aString copyFrom: (schemeName size + 2) to: aString size.
	^self schemeName: schemeName locator: locator
%

category: 'instance creation'
classmethod: RwGenericUrl
schemeName: schemeName  locator: locator
	^self new schemeName: schemeName  locator: locator
%

!		Instance methods for 'RwGenericUrl'

category: 'access'
method: RwGenericUrl
locator
	^locator
%

category: 'paths'
method: RwGenericUrl
pathForDirectory

	^self locator
%

category: 'printing'
method: RwGenericUrl
printOn: aStream
	
	self schemeName ifNotNil: [
		aStream nextPutAll: self schemeName; nextPut: $:].
	
	aStream nextPutAll: self locator.

	self fragment ifNotNil: [
		aStream nextPut: $#; nextPutAll: self fragment].
%

category: 'parsing'
method: RwGenericUrl
privateInitializeFromText: aString
	schemeName := RwUrl schemeNameForString: aString.
	locator :=  schemeName 
		ifNil: [ aString ]
		ifNotNil: [ aString copyFrom: (schemeName size+2) to: aString size ].
%

category: 'parsing'
method: RwGenericUrl
privateInitializeFromText: aString relativeTo: aUrl
	schemeName := aUrl schemeName.
	locator := aString.
%

category: 'classification'
method: RwGenericUrl
scheme
	^ self schemeName.
%

category: 'access'
method: RwGenericUrl
schemeName
	^schemeName
%

category: 'private'
method: RwGenericUrl
schemeName: schemeName0  locator: locator0
	schemeName := schemeName0.
	locator := locator0.
%

! Class implementation for 'RwHierarchicalUrl'

!		Class methods for 'RwHierarchicalUrl'

category: 'instance creation'
classmethod: RwHierarchicalUrl
schemeName: schemeName  authority: authority  path: path  query: query
	^self new schemeName: schemeName  authority: authority  path: path  query: query
%

!		Instance methods for 'RwHierarchicalUrl'

category: 'access'
method: RwHierarchicalUrl
authority
	^authority
%

category: 'printing'
method: RwHierarchicalUrl
fullPath
  | ans |
  ans := WriteStreamPortable on: String new.
  path
    do: [ :pathElem | 
      ans nextPut: $/.
      ans nextPutAll: pathElem ].
  self query == nil
    ifFalse: [ 
      ans nextPut: $?.
      ans nextPutAll: self query ].
  self fragment == nil
    ifFalse: [ 
      ans nextPut: $#.
      ans nextPutAll: self fragment ].
  ^ ans contents
%

category: 'access'
method: RwHierarchicalUrl
isAbsolute
	
	path size > 0 ifFalse: [^ false].
	(path at: 1) size > 0 ifFalse: [^ false].
	^ ((path at: 1) at: 1) ~~ $.
%

category: 'access'
method: RwHierarchicalUrl
password
	"http://user:pword@foo.com' asUrl password"
	^password
%

category: 'access'
method: RwHierarchicalUrl
path
	"return a collection of the decoded path elements, as strings"
	^path
%

category: 'access'
method: RwHierarchicalUrl
path: aCollection
	"Set the collection of path elements."

	path := aCollection
%

category: 'access'
method: RwHierarchicalUrl
port
	^port
%

category: 'copying'
method: RwHierarchicalUrl
postCopy
	"Be sure not to share the path with the copy"

	super postCopy.
	path := path copy
%

category: 'printing'
method: RwHierarchicalUrl
printOn: aStream
  aStream nextPutAll: self schemeName.
  aStream nextPutAll: '://'.
  self username
    ifNotNil: [ 
      aStream nextPutAll: self username.
      self password
        ifNotNil: [ 
          aStream nextPutAll: ':'.
          aStream nextPutAll: self password ].
      aStream nextPutAll: '@' ].
  aStream nextPutAll: self authority.
  port
    ifNotNil: [ 
      aStream
        nextPut: $:;
        nextPutAll: port printString ].
  path
    do: [ :pathElem | 
      aStream nextPut: $/.
      aStream nextPutAll: pathElem ].
  self query == nil
    ifFalse: [ 
      aStream nextPut: $?.
      aStream nextPutAll: self query ].
  self fragment == nil
    ifFalse: [ 
      aStream nextPut: $#.
      aStream nextPutAll: self fragment ]
%

category: 'parsing'
method: RwHierarchicalUrl
privateInitializeFromText: aString

	| remainder ind specifiedSchemeName |
	remainder := aString.
	schemeName
		ifNil: [ 
			specifiedSchemeName := RwUrl schemeNameForString: remainder.
			specifiedSchemeName
				ifNotNil: [ 
					schemeName := specifiedSchemeName.
					remainder := remainder copyFrom: schemeName size + 2 to: remainder size ].
			schemeName
				ifNil: [ 
					"assume HTTP"
					schemeName := 'http' ] ].	"remove leading // if it's there"
	(remainder beginsWith: '//')
		ifTrue: [ remainder := remainder copyFrom: 3 to: remainder size ].	"get the query"
	ind := remainder indexOf: $?.
	ind > 0
		ifTrue: [ 
			query := remainder copyFrom: ind + 1 to: remainder size.
			remainder := remainder copyFrom: 1 to: ind - 1 ].	"get the authority"
	ind := remainder indexOf: $/.
	ind > 0
		ifTrue: [ 
			ind = 1
				ifTrue: [ authority := '' ]
				ifFalse: [ 
					authority := remainder copyFrom: 1 to: ind - 1.
					remainder := remainder copyFrom: ind + 1 to: remainder size ] ]
		ifFalse: [ 
			authority := remainder.
			remainder := '' ].	"extract the username+password"
	(authority includes: $@)
		ifTrue: [ 
			username := authority copyUpTo: $@.
			authority := authority
				copyFrom: (authority indexOf: $@) + 1
				to: authority size.
			(username includes: $:)
				ifTrue: [ 
					password := (username copyFrom: (username indexOf: $:) + 1 to: username size)
						unescapePercents asByteArray decodeFromUTF8 asString.
					username := (username copyUpTo: $:) unescapePercents asByteArray
						decodeFromUTF8 asString ]
				ifFalse: [ 
					password := nil.
					username := username unescapePercents asByteArray decodeFromUTF8 asString ] ].	"Extract the port"
	(authority includes: $:)
		ifTrue: [ 
			| lastColonIndex portString |
			lastColonIndex := authority findLast: [ :c | c = $: ].
			portString := authority copyFrom: lastColonIndex + 1 to: authority size.
			(portString allSatisfy: [ :each | each isDigit ])
				ifTrue: [ 
					port := Integer fromString: portString.
					port > 65535
						ifTrue: [ self error: 'Invalid port number' ].
					authority := authority copyFrom: 1 to: lastColonIndex - 1 ]
				ifFalse: [ self error: 'Invalid port number' ] ].	"get the path"
	path := self privateParsePath: remainder relativeTo: #()
%

category: 'parsing'
method: RwHierarchicalUrl
privateParsePath: remainder relativeTo: basePath 
	| nextTok s parsedPath |
	s := remainder readStream.
	parsedPath := OrderedCollection new.
	parsedPath addAll: basePath.
	parsedPath isEmpty ifFalse: [ parsedPath removeLast ].
	
	[ s peek = $/ ifTrue: [ s next ].
	nextTok := WriteStreamPortable on: String new.
	[ s atEnd or: [ s peek = $/ ] ] whileFalse: [ nextTok nextPut: s next ].
	nextTok := nextTok contents unescapePercents.
	nextTok = '..' 
		ifTrue: [ parsedPath size > 0 ifTrue: [ parsedPath removeLast ] ]
		ifFalse: [ nextTok ~= '.' ifTrue: [ parsedPath add: nextTok ] ].
	s atEnd ] whileFalse.
	parsedPath isEmpty ifTrue: [ parsedPath add: '' ].
	^ parsedPath
%

category: 'access'
method: RwHierarchicalUrl
query
	"return the query, the part after any ?.  Any %XY's have already been decoded.  If there wasno query part, nil is returned (it is possible to also have an empty query"
	^query 
%

category: 'classification'
method: RwHierarchicalUrl
scheme
	^ self schemeName.
%

category: 'access'
method: RwHierarchicalUrl
schemeName
	^schemeName
%

category: 'private'
method: RwHierarchicalUrl
schemeName: schemeName0  authority: authority0  path: path0  query: query0
	"initialize a new instance"
	schemeName := schemeName0.
	authority := authority0.
	path := path0.
	query := query0.
%

category: 'access'
method: RwHierarchicalUrl
username
	"http://user:pword@foo.com' asUrl username"
	^username
%

! Class implementation for 'RwSmalltalkRepositoryUrl'

!		Class methods for 'RwSmalltalkRepositoryUrl'

category: 'constants'
classmethod: RwSmalltalkRepositoryUrl
schemeName
  ^ 'smalltalk'
%

!		Instance methods for 'RwSmalltalkRepositoryUrl'

category: 'converting'
method: RwSmalltalkRepositoryUrl
asRwRepository
  "return a platform appropriate repository for the repository identified in the receiver"

  ^ self halt: 'not yet implemented'
%

category: 'accessing'
method: RwSmalltalkRepositoryUrl
committish

   ^committish
%

category: 'accessing'
method: RwSmalltalkRepositoryUrl
dir

   ^dir
%

category: 'accessing'
method: RwSmalltalkRepositoryUrl
dirPath
  ^ self pathFor: dir
%

category: 'parsing'
method: RwSmalltalkRepositoryUrl
privateParsePath: remainder relativeTo: basePath
  | parsedPath |
  parsedPath := super privateParsePath: remainder relativeTo: basePath.
  (parsedPath
    detect: [ :e | e includes: $: ]
    ifNone: [ 
      project := parsedPath copyFrom: 1 to: parsedPath size - 1.
      dir := parsedPath copyFrom: 2 to: parsedPath size ])
    ifNotNil: [ :pivot | 
      project := parsedPath copyFrom: 1 to: (parsedPath indexOf: pivot) - 1.
      project addLast: (pivot copyUpTo: $:).
      committish := pivot copyFrom: (pivot indexOf: $:) + 1 to: pivot size.
      dir := parsedPath
        copyFrom: (parsedPath indexOf: pivot) + 1
        to: parsedPath size ].
  ^ parsedPath
%

category: 'accessing'
method: RwSmalltalkRepositoryUrl
project

   ^project
%

category: 'accessing'
method: RwSmalltalkRepositoryUrl
projectPath
  ^ self pathFor: project
%

! Class implementation for 'RwGitFileTreeUrl'

!		Class methods for 'RwGitFileTreeUrl'

category: 'constants'
classmethod: RwGitFileTreeUrl
schemeName
  ^ 'gitfiletree'
%

! Class implementation for 'TonelParser'

!		Class methods for 'TonelParser'

category: 'instance creation'
classmethod: TonelParser
on: aStream forReader: aTonelReader
	^ self new 
		stream: aStream;
		packageReader: aTonelReader;
		yourself
%

category: 'instance creation'
classmethod: TonelParser
onString: aString forReader: aTonelReader
  ^ self on: (self readStreamClass on: aString) forReader: aTonelReader
%

category: 'parsing'
classmethod: TonelParser
parseStream: aStream forReader: aTonelReader
	^ (self on: aStream forReader: aTonelReader)
		 start
%

category: 'parsing'
classmethod: TonelParser
parseString: aString forReader: aTonelReader
	^ self parseStream: (self readStreamClass on: aString) forReader: aTonelReader
%

category: 'Topaz support'
classmethod: TonelParser
_compileForTopaz: aString envId: envId
  "aString is the topaz text object for topaz TMETHOD command"
| strm parser catDict category methInfo methSrc symList clsName cls
  warnStr  |
strm :=  ReadStreamPortable on: aString  .
(parser := self new) stream: strm .

parser separator ifNotNil:[ Error signal:'expected parser separator to be nil'].

catDict :=  (parser try: [ parser metadata ]).
catDict ifNil:[ Error signal:'Category dictionary not found'. ].
category := catDict at: #category .

parser separator ifNotNil:[ Error signal:'expected second parser separator to be nil'].

methInfo :=  parser method.
clsName := Symbol _existingWithAll: ((methInfo at: 1) at: 1) .

methSrc :=  (methInfo at: 2)"keywords+args" ,  parser methodBody .
symList := System myUserProfile symbolList .
cls := (symList resolveSymbol: clsName) value .
((methInfo at: 1) at: 2) ifNotNil:[:classWord |
  classWord = 'class' ifTrue:[ cls := cls class ]
      ifFalse:[ Error signal:'unrecognized ' , classWord asString, ' after >>'].
].
[ cls compileMethod: methSrc dictionaries: symList 
               category: category  
               environmentId: envId .
] on: CompileWarning do:[:ex | 
   warnStr := ex warningString .
   ex resume 
].
^ warnStr "nil if no warnings"
%

!		Instance methods for 'TonelParser'

category: 'private'
method: TonelParser
cleanSelector: aString
	"BEWARE: I'm doing some heave assumptions here: I'm removing just ONE space (in case there 
	 is one) because I expect this to be a file generated by tonel, and tonel adds one space 
	 before start with the method body to make the format more readable. 
	 But of course this is not very good :("
	^ (aString last = Character space
		ifTrue: [ aString allButLast ]
		ifFalse: [ aString ]) 
		trimLeft
%

category: 'parsing'
method: TonelParser
comment
	| result ch eatNext |
	
	result := String new writeStreamPortable.

	eatNext := false.
	stream next = $" ifFalse: [ TonelParseError signal: 'Can''t parse comment' ].	
	[ stream atEnd not 
		and: [ 
				(ch := stream next) ~= $" 
				or: [ eatNext := (stream peek = $") ] ] ]
	whileTrue: [ 
		result nextPut: ch.
		eatNext ifTrue: [ 
			stream skip: 1.
			eatNext := false ] ].
	
	^ self 
		removeFrom: '"',result contents,'"' 
		enclosingStart: $" 
		end: $"
%

category: 'private factory'
method: TonelParser
definitionForType: aString
  ^ self packageReader definitionForType: aString
%

category: 'parsing'
method: TonelParser
document
	^ { 
	self typeDef.
	self methodDefList.
	 } 
	flattened
	select: [:each | each notNil ]
%

category: 'private'
method: TonelParser
extractSelector: aString
	| separators selectorStream keywords |
	
	separators := { 
		Character space. 
		Character tab. 
		Character lf. 
		Character newPage. 
		Character cr. 
		$:}.

	keywords := Array new writeStreamPortable.
	selectorStream := aString readStream.
	[ selectorStream atEnd ]
	whileFalse: [ | word ch |
		word := String new writeStreamPortable.
		[ selectorStream atEnd not and: [ (separators includes: (ch := selectorStream next)) not ] ]
		whileTrue: [ word nextPut: ch ].
		ch = $: ifTrue: [ word nextPut: ch ]. 
		word contents trimBoth ifNotEmpty: [ :v | keywords nextPut: v ] ].
	keywords := keywords contents.

	^ (keywords size <= 2 
		ifTrue: [ keywords first]
		ifFalse: [ ('' join: (keywords pairsCollect: [ :keyword :argument | keyword ])) ])
		asSymbol
%

category: 'testing'
method: TonelParser
isEnter: aCharacter
	^ #(13 10) includes: aCharacter asciiValue
%

category: 'testing'
method: TonelParser
isSeparator: aCharacter 
	^ aCharacter isSeparator
%

category: 'parsing'
method: TonelParser
metadata
	| result ch count |
	
	result := String new writeStreamPortable.

	count := 0.
	stream peek = ${ ifFalse: [ TonelParseError signal: 'Can''t parse metadata' ].	
	[ stream atEnd not ]
	whileTrue: [ 
		ch := stream next.
		result nextPut: ch.
		ch = ${ ifTrue: [ count := count +1 ].
		ch = $} ifTrue: [ count := count -1 ].
		count = 0 ifTrue: [ ^ STON fromString: result contents ]].

	TonelParseError signal: 'Can''t parse metadata'
%

category: 'parsing'
method: TonelParser
method
	| type selector |
	
	type := self untilIncluding: '>>'.
	selector := self cleanSelector: (self untilExcluding: '[').
	type := type trimBoth substrings: ' '.
	type size = 1 ifTrue: [ type := type copyWith: nil ].
  lastSelectorParsed := selector .
	^ { 
		type.
		selector.
	}
%

category: 'parsing'
method: TonelParser
methodBody
	"I read a methodbody (what is inside [ ... ])
	 Since a method body can contain enclosing brackets we need to be sure we will skip them and
	 correctly read the method. For that, I have to take into account: 
		- I can mention [] in comments
		- I can mention [] in strings
		- I can use $[, $] 
		- I can have inner blocks
		- I can mention a comment of the form ""$"" or a comment of the form '$'
	 all that needs to be skipped "
	| result char prevChar comment string count |
	
	result := self class writeStreamClass on: String new.

	comment := false.
	string := false.
	prevChar := nil.
	count := 0.
	stream peek = $[ ifFalse: [ TonelParseError signal: 'Can''t parse method body' ].
	[ stream atEnd not ]
	whileTrue: [ 
		char := stream next.
		result nextPut: char.
		(char = $" and: [ string not and: [ prevChar ~= $$ or: [ comment ] ] ]) 
			ifTrue: [ comment := comment not ]. 
		(char = $' and: [ comment not and: [ prevChar ~= $$ or: [ string ] ] ]) 
			ifTrue: [ string := string not ]. 
		(comment or: [ string ]) ifFalse: [ 
			(char = $[ and: [  prevChar ~= $$ ]) ifTrue: [ count := count +1 ].
			(char = $] and: [ prevChar ~= $$ ]) ifTrue: [ count := count -1 ] ].
		count = 0 ifTrue: [ 
			^ self 
				removeFrom: result contents 
				enclosingStart: $[ 
				end: $]
				clean: #right ].
		prevChar := char ].

	TonelParseError signal: 'Can''t parse method body'
%

category: 'parsing'
method: TonelParser
methodDef
	^ self newMethodDefinitionFrom: { 
		self separator.
		self try: [ self metadata ]. 
		self separator. 
		self method. 
		self methodBody 
	}
%

category: 'parsing'
method: TonelParser
methodDefList
	| result |
	
	self separator. "to arrive to the end of the file in case there are no methods"
	result := Array new writeStreamPortable.
  [
	  [ stream atEnd ]
	  whileFalse: [ 
		  result nextPut: self methodDef .
		  "skip possible spaces at the end"
		  self separator 
      ].
  ] on: TonelParseError do:[:ex | 
     lastSelectorParsed ifNotNil:[
       GsFile gciLogServer:'Last selector parsed was: ', lastSelectorParsed printString .
     ].
     ex pass .
  ].
	^ result contents
%

category: 'private factory'
method: TonelParser
newMethodDefinitionFrom: anArray
	| metadata className meta selector source  |
	
	metadata := anArray second ifNil: [ Dictionary new ].
	className := anArray fourth first first.
	meta := anArray fourth first second notNil.
	selector := self extractSelector: anArray fourth second trimBoth.
	source := String streamContents: [ :s | 
		s << anArray fourth second.
		anArray fifth ifNotEmpty: [ :src | s << src ] ].

	^ self packageReader newMethodDefinitionForClassNamed: className
		classIsMeta: meta
		selector: selector
		category: (metadata at: #category ifAbsent: [ '' ]) 
		source: source
%

category: 'private factory'
method: TonelParser
newTypeDefinitionFrom: anArray
	^ self packageReader newTypeDefinitionFrom: anArray
%

category: 'accessing'
method: TonelParser
packageReader
	^ packageReader
%

category: 'accessing'
method: TonelParser
packageReader: aPackageReader 
	packageReader := aPackageReader
%

category: 'private'
method: TonelParser
removeFrom: aString enclosingStart: startChar end: endChar
	^ self 
		removeFrom: aString 
		enclosingStart: startChar 
		end: endChar
		clean: #both
%

category: 'private'
method: TonelParser
removeFrom: aString enclosingStart: startChar end: endChar clean: cleanSymbol
  "cleanSymbol can be #left, #rigth and #both"

  | result stop ch start end |
  result := self class readStreamClass on: aString trimBoth.
  result peek = startChar
    ifFalse: [ TonelParseError signal: 'I cannot remove enclosing start' ].
  result skip: 1.
  (#(#'both' #'left') includes: cleanSymbol)
    ifTrue: [ 
      stop := TonelWriter lineEnding size.
      [ stop > 0 and: [ self isSeparator: (ch := result peek) ] ]
        whileTrue: [ 
          (self isEnter: ch)
            ifTrue: [ stop := stop - 1 ].
          result skip: 1 ] ].
  start := result position.
  result setToEnd.
  result skip: -1.
  result peek = endChar
    ifFalse: [ TonelParseError signal: 'I cannot remove enclosing end' ].
  result skip: -1.
  (#(#'both' #'right') includes: cleanSymbol)
    ifTrue: [ 
      stop := TonelWriter lineEnding size.
      [ stop > 0 and: [ self isSeparator: (ch := result peek) ] ]
        whileTrue: [ 
          (self isEnter: ch)
            ifTrue: [ stop := stop - 1 ].
          result skip: -1 ] ].
  end := result position.
  ^ result originalContents copyFrom: start + 1 to: end + 1
%

category: 'parsing'
method: TonelParser
separator
	[ stream atEnd not and: [ self isSeparator: stream peek ] ]
	whileTrue: [ stream next ].
	^ nil
%

category: 'accessing'
method: TonelParser
start
	^ self document
%

category: 'accessing'
method: TonelParser
stream: aStream 
	stream := aStream
%

category: 'private parsing'
method: TonelParser
try: aBlock
	^ self 
		try: aBlock 
		onSuccess: [ :parsedValue | parsedValue ] 
		onFailure: [ nil ]
%

category: 'private parsing'
method: TonelParser
try: aBlock onFailure: failureBlock
	^ self 
		try: aBlock 
		onSuccess: [ :parsedValue |  parsedValue ] 
		onFailure: failureBlock
%

category: 'private parsing'
method: TonelParser
try: aBlock onSuccess: successBlock
	^ self 
		try: aBlock 
		onSuccess: successBlock 
		onFailure: [ nil ]
%

category: 'private parsing'
method: TonelParser
try: aBlock onSuccess: successBlock onFailure: failureBlock
	| pos |
	
	pos := stream position.
	[ ^ successBlock value: aBlock value ]
	on: TonelParseError 
	do: [ :e | 
		stream position: pos.
		^ failureBlock value ]. 
	
%

category: 'parsing'
method: TonelParser
type
	self try: [ self word: 'Class' ] onSuccess: [ :word | ^ word  ].
	self try: [ self word: 'Trait' ] onSuccess: [ :word | ^ word  ].
	self try: [ self word: 'Extension' ] onSuccess: [ :word | ^ word  ].
	
	"at end"
	TonelParseError signal: 'Can''t parse type.'	
%

category: 'parsing'
method: TonelParser
typeDef
	^ self newTypeDefinitionFrom: { 
		self separator.
		self try: [ self comment ]. 
		self separator. 
		self type. 
		self separator. 
		self try: [ 
			| typeMetadata normalizedMetadata |
			typeMetadata := self metadata.
			normalizedMetadata := Dictionary new.
			typeMetadata keysAndValuesDo: [:key :value |
				normalizedMetadata at: key asLowercase asSymbol put: value ].
			normalizedMetadata ] 
	} 
	
		
%

category: 'private parsing'
method: TonelParser
untilExcluding: aCollection
	| result |
	result := stream upToAll: aCollection.
	stream position: stream position - aCollection size.
	^ result
%

category: 'private parsing'
method: TonelParser
untilIncluding: aCollection
	^ stream upToAll: aCollection
%

category: 'private parsing'
method: TonelParser
word: aString
	| result |
	result := stream next: aString size.
	result = aString
		ifFalse: [ TonelParseError signal: 'Can''t parse ', aString ].
	^ result
%

! Class implementation for 'TonelWriter'

!		Class methods for 'TonelWriter'

category: 'accessing'
classmethod: TonelWriter
classLabel
	^ 'Class'
%

category: 'accessing'
classmethod: TonelWriter
extensionLabel
	^ 'Extension'
%

category: 'instance creation'
classmethod: TonelWriter
on: aPackageWriter

	^ self new
		packageWriter: aPackageWriter;
		yourself
%

category: 'accessing'
classmethod: TonelWriter
traitLabel
	^ 'Trait'
%

!		Instance methods for 'TonelWriter'

category: 'private'
method: TonelWriter
classNameFor: aMethodDefinition parent: aClassDefinition
	aClassDefinition ifNil: [ ^ aMethodDefinition fullClassName ].
	^ aMethodDefinition classIsMeta
		ifFalse: [ aMethodDefinition className ]
		ifTrue: [ 
			aClassDefinition isTraitDefinition
				ifFalse: [aMethodDefinition className, ' class']
				ifTrue: [aMethodDefinition className, ' classSide'] ]
%

category: 'private definitions'
method: TonelWriter
commentOf: aClassDefinition
	^ (aClassDefinition comment 
		copyReplaceAll: '"' 
		with: '""')
		withLineEndings: self newLine
%

category: 'accessing'
method: TonelWriter
definitions

   ^self packageWriter definitions
%

category: 'private'
method: TonelWriter
fileNameFor: aClassDefinition
	^ String streamContents: [ :stream | 
		stream 
			<< aClassDefinition className
			<< '.' << (self typeOf: aClassDefinition) asLowercase
			<< '.st'  ]
%

category: 'private testing'
method: TonelWriter
isClass: aClassDefinition
	^ self packageWriter isClass: aClassDefinition
%

category: 'private testing'
method: TonelWriter
isTrait: aClassDefinition
	^ self packageWriter isTrait: aClassDefinition
%

category: 'private definitions'
method: TonelWriter
methodDefinitionOf: aMethodDefinition
	^ self toSTON: (self class orderedDictionaryClass new 
		at: #category put: aMethodDefinition category asSymbol; 
		yourself)	
	
%

category: 'private'
method: TonelWriter
newLine
	 ^ self class lineEnding
%

category: 'accessing'
method: TonelWriter
packageWriter
  ^ packageWriter
%

category: 'accessing'
method: TonelWriter
packageWriter: anObject

   packageWriter := anObject
%

category: 'private'
method: TonelWriter
selectorIsComplete: keywords in: aString
	| start |
	
	start := 1.
	keywords do: [ :each | | index | 
		index := aString 
			findString: each 
			startingAt: start 
			caseSensitive: true.
		index = 0 ifTrue: [ ^ false ].
		start := index + each size ].
	^ true
%

category: 'private'
method: TonelWriter
skipComment: aStream
	"I assume I'm on top of the begining of a comment"
	aStream skip: 1.
	[ aStream atEnd not 
		and: [ aStream next ~= $" or: [ aStream peek = $" ] ] ]
	whileTrue.	
%

category: 'private'
method: TonelWriter
skipSeparators: aStream
	[ aStream peek isSeparator ]
	whileTrue: [ aStream skip: 1 ]. 
%

category: 'private'
method: TonelWriter
splitMethodSource: aMethodDefinition into: aBlock
	| keywords source declaration |
	
	keywords := aMethodDefinition selector asSymbol keywords.
	source := aMethodDefinition source readStream.
	"Skip spaces"
	(source peek isSeparator) ifTrue: [ self skipSeparators: source ].
	"Skip comments"
	(source peek = $") ifTrue: [ self skipComment: source ]. 
	"Parse declaration"
	declaration := String new writeStreamPortable.
	[ (self selectorIsComplete: keywords in: declaration originalContents) not 
		or: [ ':+-/\*~<>=@,%|&?!' includes: declaration contents trimRight last ] ]
	whileTrue: [ 
		"get separators"
		[ source atEnd not and: [ source peek isSeparator ] ]
			whileTrue: [ declaration nextPut: source next ].
		"take next word"
		[ source atEnd not and: [ source peek isSeparator not ] ]
			whileTrue: [ declaration nextPut: source next ] ].
	aBlock 
		value: (declaration contents trimLeft withLineEndings: self newLine)
		value: (source upToEnd withLineEndings: self newLine)
%

category: 'private'
method: TonelWriter
toSTON: anObject
	^ (String streamContents: [ :stream | 
		(TonelSTONWriter on: stream) nextPut: anObject ])
		withLineEndings: self newLine
%

category: 'private definitions'
method: TonelWriter
typeClassDefinitionOf: aClassDefinition
	| definition |
	
	definition := self class orderedDictionaryClass new 
		at: #name put: aClassDefinition className asSymbol; 
		at: #superclass put: aClassDefinition superclassName asSymbol;
		yourself.

	aClassDefinition type = #normal ifFalse: [ 
		definition at: #type put: aClassDefinition type ].
	
	aClassDefinition hasTraitComposition ifTrue: [ 
		definition at: #traits put: aClassDefinition traitCompositionString ].
	
	aClassDefinition hasClassTraitComposition ifTrue: [ 
		definition at: #classTraits put: aClassDefinition classTraitCompositionString ].
	
	(aClassDefinition instVarNames)
		ifNotEmpty: [ :vars | definition at: #instVars put: vars asArray ].

	(aClassDefinition classVarNames)
		ifNotEmpty: [ :vars | definition at: #classVars put: vars asArray ].
		
	((aClassDefinition poolDictionaries) collect: [:each | each asString])
		ifNotEmpty: [ :vars | definition at: #pools put: vars asArray ].
		
	(aClassDefinition classInstVarNames)
		ifNotEmpty: [ :vars | definition at: #classInstVars put: vars asArray ].

	(aClassDefinition gs_constraints)
		ifNotEmpty: [:gs_constraints | definition at: #'gs_constraints' put: gs_constraints asArray ].

	(aClassDefinition gs_options)
		ifNotEmpty: [:gs_options | definition at: #'gs_options' put: gs_options asArray ].

	definition 		
		at: #category put: aClassDefinition category asSymbol.
	
	^ self toSTON: definition
%

category: 'private definitions'
method: TonelWriter
typeDefinitionOf: aClassDefinition
	(self isTrait: aClassDefinition) 
		ifTrue: [ ^ self typeTraitDefinitionOf: aClassDefinition ].
	^ self typeClassDefinitionOf: aClassDefinition
%

category: 'private'
method: TonelWriter
typeOf: aClassDefinition
	(self isClass: aClassDefinition) ifTrue: [ ^ self class classLabel ].
	(self isTrait: aClassDefinition) ifTrue: [ ^ self class traitLabel ].

	TonelShouldIgnore signal
%

category: 'writing'
method: TonelWriter
writeClass: aClassDefinition
	[ 
		self packageWriter 
			writePackageFileNamed: (self fileNameFor: aClassDefinition) 
			do:  [ :aStream | 
				self writeClassDefinition: aClassDefinition on: aStream.
				self writeClassSideMethodDefinitions: aClassDefinition on: aStream.
				self writeInstanceSideMethodDefinitions: aClassDefinition on: aStream ] ]
	on: TonelShouldIgnore
	do: [ :e | self logCr: 'ignoring: ', aClassDefinition asString ]
%

category: 'private writing'
method: TonelWriter
writeClassDefinition: aClassDefinition on: aStream
	| nl |
	nl := self newLine.
	
	aClassDefinition hasComment 
		ifTrue: [ 
			aStream 
				<< '"' << nl
				<< (self commentOf: aClassDefinition) << nl
				<< '"' << nl ].
	aStream
		<< (self typeOf: aClassDefinition) 
		<< ' ' << (self typeDefinitionOf: aClassDefinition ) << nl
%

category: 'private writing'
method: TonelWriter
writeClassSideMethodDefinitions: aClassDefinition on: aStream
	((self definitions 
		select: [ :each | 
			each isMethodDefinition 
			and: [ each className = aClassDefinition className
			and: [ each classIsMeta ] ] ])
		sortWithBlock: [ :a :b | a selector _unicodeLessThan: b selector ])
		do: [ :each | 
			self writeMethodDefinition: each parent: aClassDefinition on: aStream ]
%

category: 'writing'
method: TonelWriter
writeExtensionMethods: methods className: className

	| nl |
	nl := self newLine.
	self packageWriter
		writePackageFileNamed: className , '.extension.st'
		do: [ :s | 
			s << 'Extension '
				<< (self toSTON: {(#'name' -> className asSymbol)} asDictionary) << nl.
			((methods select: [ :m | m classIsMeta not ])
				sortWithBlock: [ :a :b | a selector  _unicodeLessThan: b selector ])
				do: [ :each | self writeMethodDefinition: each on: s ].
			((methods select: [ :m | m classIsMeta ])
				sortWithBlock: [ :a :b | a selector  _unicodeLessThan: b selector ])
				do: [ :each | self writeMethodDefinition: each on: s ] ]
%

category: 'private writing'
method: TonelWriter
writeInstanceSideMethodDefinitions: aClassDefinition on: aStream
	((self definitions 
		select: [ :each | 
			each isMethodDefinition 
			and: [ each className = aClassDefinition className
			and: [ each classIsMeta not ] ] ])
		sortWithBlock: [ :a :b | a selector _unicodeLessThan: b selector ])
		do: [ :each | 
			self writeMethodDefinition: each parent: aClassDefinition on: aStream ]

	
	
%

category: 'private writing'
method: TonelWriter
writeMethodDefinition: aMethodDefinition on: aStream
	^ self 
		writeMethodDefinition: aMethodDefinition 
		parent: nil 
		on: aStream
%

category: 'private writing'
method: TonelWriter
writeMethodDefinition: aMethodDefinition parent: aClassDefinition on: aStream
	| nl |
	
	nl := self newLine.
	self 
		splitMethodSource: aMethodDefinition 
		into: [ :methodDeclaration :methodBody | | fullClassName |
			fullClassName := self classNameFor: aMethodDefinition parent: aClassDefinition.
			aStream 
				<< nl 
				<< (self methodDefinitionOf: aMethodDefinition) << nl 
				<< fullClassName << ' >> ' << methodDeclaration 
				<< ' [' << methodBody << nl << ']' << nl ]
%

category: 'writing'
method: TonelWriter
writePackage: packageName
	self packageWriter 
		writePackageFileNamed: 'package.st'
		do:  [ :aStream | self writePackage: packageName on: aStream ]
%

category: 'writing'
method: TonelWriter
writePackage: packageName on: aStream

	aStream 
		<< 'Package ' 
		<< (self toSTON: { #name ->  packageName asSymbol } asDictionary) 
		<< self  newLine
%

! Class implementation for 'TonelSTONWriter'

!		Instance methods for 'TonelSTONWriter'

category: 'accessing'
method: TonelSTONWriter
aliases
	^ aliases
%

category: 'accessing'
method: TonelSTONWriter
aliases: aDictionary
	aliases := aDictionary
%

category: 'private'
method: TonelSTONWriter
encodeKey: key value: value

	super encodeKey: key asSymbol
		value: (value isSymbol ifTrue: [value asString] ifFalse: [value])
%

category: 'writing'
method: TonelSTONWriter
encodeMap: pairs
	| first |
	first := true.
	writeStream nextPut: ${.
	pairs isEmpty
		ifTrue: [
			self prettyPrintSpace ]
		ifFalse: [
			self indentedDo: [
				pairs size = 1 
					ifTrue: [ self prettyPrintSpace ]
					ifFalse: [ self newlineIndent ].
				pairs keysAndValuesDo: [ :key :value |
					first 
						ifTrue: [ first := false ] 
						ifFalse: [ self mapElementSeparator ].
					self encodeKey: key value: value ] ].
				pairs size = 1 
					ifTrue: [ self prettyPrintSpace ]
					ifFalse: [ self newlineIndent ] ].
	writeStream nextPut: $}
%

category: 'initialization'
method: TonelSTONWriter
initialize
	super initialize.
	self prettyPrint: true.
	aliases := { TonelWriter orderedDictionaryClass -> nil } asDictionary
%

category: 'accessing'
method: TonelSTONWriter
stonNameFor: aClass
	^ self aliases 
		at: aClass 
		ifAbsent: [ aClass stonName ]
%

category: 'writing'
method: TonelSTONWriter
writeObject: anObject do: block
	(jsonMode and: [ anObject class ~= STON listClass and: [ anObject class ~= STON mapClass ] ])
		ifTrue: [ self error: 'wrong object class for JSON mode' ].
	self with: anObject do: [
		(self stonNameFor: anObject class) ifNotNil: [ :stonName | 
			writeStream nextPutAll: stonName.
			self prettyPrintSpace ].
		block value ]
%

! Class implementation for 'CypressMessageDigestStream'

!		Class methods for 'CypressMessageDigestStream'

category: 'instance creation'
classmethod: CypressMessageDigestStream
bytes

	^self on: ByteArray new
%

category: 'instance creation'
classmethod: CypressMessageDigestStream
characters

	^self on: String new
%

category: 'Documentation'
classmethod: CypressMessageDigestStream
comment
"WriteStreamLegacy has a wired in comment method (in 2.3.15), so we
	need this method to answer correctly provide the comment for this 
	class"
" As of GS/64 3.1, comments are now recorded in the class extraDict
  dictionary under the key #comment.  Comment information formerly
  recorded as a GsClassDocumentation under the key #description are
  converted to a string and placed under #comment during DB 
  conversion/upgrade. "

  | cmt |
  cmt := self _extraDictAt: #comment.
  ^ cmt isNil ifTrue: [ '' ] ifFalse: [ cmt ]
%

!		Instance methods for 'CypressMessageDigestStream'

category: 'digests'
method: CypressMessageDigestStream
md5sum

	^self contents md5sum
%

category: 'digests'
method: CypressMessageDigestStream
sha1Sum

	^self contents sha1Sum
%

category: 'digests'
method: CypressMessageDigestStream
sha256Sum

	^self contents sha256Sum
%

category: 'digests'
method: CypressMessageDigestStream
sha512Sum

	^self contents sha512Sum
%

! Class extensions for 'Array'

!		Instance methods for 'Array'

category: '*Cypress-PackageManagement'
method: Array
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	| indent |
	aStream
		nextPutAll: '[';
		lf.
	indent := startIndent + 1.
	1 to: self size
		do: 
			[:index |
			| item |
			item := self at: index.
			indent timesRepeat: [aStream tab].
			item _writeCypressJsonOn: aStream indent: indent.
			index < self size
				ifTrue: 
					[aStream
						nextPutAll: ',';
						lf]].
	self size = 0 ifTrue: [indent timesRepeat: [aStream tab]].
	aStream nextPutAll: ' ]'
%

! Class extensions for 'Behavior'

!		Instance methods for 'Behavior'

category: '*ast-kernel-core'
method: Behavior
parseTreeFor: aSymbol	
	^ RBParser parseMethod: (self sourceCodeAt: aSymbol) onError: [ :msg :pos | ^ nil ]
%

category: '*cypress-environmental-tools'
method: Behavior
persistentSuperclassForEnv: envId
  "result will be nil if no methods exist for specified environmentId."

  | mds |
  (mds := methDicts) _isArray
    ifTrue: [ ^ mds atOrNil: envId * 4 + 3 ].
  envId == 0
    ifTrue: [ ^ mds ].
  ^ nil
%

category: '*cypress-environmental-tools'
method: Behavior
persistentSuperclassForEnv: envId put: aValue
  "aValue should be a GsMethodDictionary, or nil ,
   caller responsible for _refreshClassCache "

  <protected>
  | ofs mds |
  (mds := methDicts) _isArray
    ifFalse: [ envId == 0
        ifTrue: [ methDicts := aValue.
          ^ self ].
      mds := {mds}.
      methDicts := mds ].
  ofs := envId * 4 + 3.
  mds size < ofs
    ifTrue: [ mds size: ofs ].
  mds at: ofs put: aValue
%

category: '*rowan-gemstone-kernel'
method: Behavior
rowanPackageName

	"answer the name of the package that the receiver is a member of. Answer 'Rowan unpackagedName` if 
		the receiver is not a member of any package"

	| loadedClass |
	loadedClass := Rowan image
		loadedClassForClass: self thisClass
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedClass loadedPackage name
%

category: '*rowan-gemstone-kernel'
method: Behavior
rowanProjectName

	"answer the name of the project that the receiver is a member of. Answer `Rowan unpackagedName` if 
		the receiver is not a member of any project"

	| loadedClass |
	loadedClass := Rowan image
		loadedClassForClass: self thisClass
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedClass loadedProject name
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileExtensionMethod: sourceString category: categoryName packageName: packageName

	| aCategory |
	
	categoryName first == $* ifFalse: [self error: 'Extension category must  contain * as first character'].
	(aCategory isEquivalent: '*', packageName asLowercase) ifFalse: [self error: 'Extension category name must match lowercased name of Rowan package'].
	^ Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategory asString asLowercase
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		inPackageNamed: packageName
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileExtensionMethod: sourceString package: aPackageName

	| aCategory |
	aCategory := '*', aPackageName asLowercase .
	^Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategory asString asLowercase
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileMethod: sourceString category: aCategoryString

	^ Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategoryString asString
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwCompileMethod: sourceString category: aCategoryString packageName: packageName

	^ Rowan projectTools browser
		addOrUpdateMethod: sourceString
		inProtocol: aCategoryString
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		inPackageNamed: packageName
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Behavior
rwGuaranteePersistentMethodDictForEnv: envId
	"in 3.5, the method persistentMethodDictForEnv: DOES NOT always return a GsMethodDictionary,
		as classes are created without a GsMethodDictionary for envId 0."

	<primitive: 2001>
	| prot |
	prot := System _protectedMode .
	[ 
		| newDict |
		(self persistentMethodDictForEnv: envId) ifNotNil: [:oldDict | ^ oldDict ].
		newDict := GsMethodDictionary new.
		self persistentMethodDictForEnv: envId put: newDict.
		^ newDict ] 
		ensure:[ prot _leaveProtectedMode ].
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Behavior
rwMethodCategories
	^ self _unifiedCategorys: 0
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwMoveMethod: methodSelector toCategory: categoryName

	^ Rowan projectTools browser
		moveMethod: methodSelector
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
		toProtocol: categoryName
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwRemoveCategory: categoryName

	^ Rowan projectTools browser
		removeProtocol: categoryName 
		fromClassNamed:  self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel'
method: Behavior
rwRemoveSelector: methodSelector

	^ Rowan projectTools browser
		removeMethod: methodSelector
		forClassNamed: self thisClass name asString
		isMeta: self isMeta
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Behavior
_constraintOn: aSymbol

"Returns the class kind constraint for the instance variable represented by
 aSymbol.  If aSymbol does not represent an instance variable of objects whose
 behavior is defined by the receiver, returns nil.
 If the instance variable aSymbol is not constrained, returns Object ."

| ivNams constrs |

ivNams := instVarNames .
constrs := constraints .
1 to: self instSize do: [ :i |
  aSymbol == (ivNams  at: i) ifTrue:[ ^ self _constraintAt: i ].
].
^ nil
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Behavior
_ivOffsetAndConstraint: aSymbol

"Searches the instVarNames instance variable of the receiver for an instance
 variable named aSymbol, and returns an Array containing the offset and the
 constraint for that instance variable.  Returns nil if no instance variable
 exists with the name aSymbol."

| idx |
idx := instVarNames indexOfIdentical: aSymbol .
idx == 0 ifTrue:[ ^ nil ].
^ { idx .  self _constraintAt: idx } 
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Behavior
_namedIvConstraintAtOffset: offset

"Returns the constraint, if any, on the named instance variable at the
 specified offset.  Returns Object if there is no such named instance variable,
 or if the instance variable at that offset is not constrained."

(offset > self instSize ) ifTrue:[ ^ Object ] .
^ self _constraintAt: offset 
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Behavior
_newConstraint: aClass atOffset: offset

"Execute the constraint change for Behavior | instvar:ConstraintTo:
 assuming all error and variance checks have been done."
| constrs |
self deprecated: 'Behavior>>_newConstraint:atOffset: deprecated, Constraints are no longer supported'.
self _validatePrivilege ifTrue:[ 
  (constrs := constraints) size == 0 ifTrue:[ | sz |
    aClass == Object ifTrue:[ ^ self "do nothing"].
    sz := self instSize .
    (constrs := Array new: sz ) replaceFrom: 1 to: sz withObject: Object.
    constraints := constrs .
  ].
  constrs at: offset put: aClass .
  (aClass == Object) ifFalse:[ self _setConstraintBit ].
  self _refreshClassCache: false .
]
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rowanCopyMethodsAndVariablesFrom: sourceClass dictionaries: dicts

"Copies all instance and class methods, pool dictionaries, and values of
 class variables from the given class to ourselves. 

 Returns an Array of methods in the source class which failed to compile.
 Some of them might be class methods.  The Array will be empty if none failed.

 Method environmentIds are copied from the source methods.
"

| failed srccls targcls sel doit otherCvs |

self _validatePrivilege ifFalse:[ ^ nil ].
self == sourceClass ifTrue:[ 
  "because iteration is directly over the source's categories dictionaries"
  ^ self error: 'source of copy must not be self' 
].
failed := { } .

"Copy pool dictionaries"
sourceClass _poolDictionaries do: [ :dict | | poolDicts |
  poolDicts := poolDictionaries .
  (poolDicts ~~ nil and:[ poolDicts includesIdentical: dict]) ifFalse: [
      poolDicts ifNil:[ poolDicts := { } . poolDictionaries := poolDicts ]
          ifNotNil:[ poolDicts isInvariant ifTrue:[
                       poolDicts := Array withAll: poolDicts . poolDictionaries := poolDicts
                     ]].
      poolDicts add: dict
  ].
].

"Copy class variable values"
otherCvs := sourceClass _classVars .
otherCvs ifNotNil:[ | destCvs |
   destCvs := classVars . 
   otherCvs == destCvs ifTrue: [ self halt ].
   otherCvs associationsDo: [ :assn | | other |
    destCvs ifNotNil:[ other := destCvs associationAt: assn key otherwise: nil ].
	(other == assn)
		ifTrue: [
			"avoid sharing associations between the reciever and sourceClass"
			destCvs removeKey: other key.	"remove the association"
			destCvs at: assn key put: assn value
		].
    (other == nil or: [other value == nil and: [assn value ~~ nil]]) ifTrue: [
        destCvs ifNil:[ destCvs := self _createClassVarsDict ].
        destCvs at: assn key put: assn value
    ].
  ].
].

"Copy class and instance methods"
1 to: 2 do: [ :j | | envId |
  j == 1 ifTrue:[ srccls := sourceClass.  targcls := self ] 
        ifFalse:[ srccls := sourceClass class.  targcls := self class ].
  envId := 0 .
  srccls categorysDo:[ :cat :sels |
      1 to: sels size do: [ :s | | oldMeth |
	sel := sels at: s.
	doit := true.
	doit ifTrue: [ | methEnvId |
          oldMeth := srccls compiledMethodAt: sel environmentId: envId .
	  methEnvId := oldMeth environmentId .
          methEnvId == envId ifFalse:[ self error:'environmentId mismatch']. 
	  ( targcls 
	     _compileMethodTrappingErrors: oldMeth sourceString 
	     dictionaries: dicts category: cat environmentId: envId ) ifNotNil:[
	    failed add: oldMeth 
          ].
        ].
      ].
  ].
].

^failed.
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rwInstVar: aString constrainTo: aClass
"Copy of instVar:constratinTo: without requiring that class be mutable"

"Changes the receiver's constraint on the instance variable named
 aString to aClass.

 The argument aString must be the name of an instance variable defined in the
 receiver or inherited from a superclass.  aClass must be a kind of Class.
 The receiver, and any subclasses for which a constraint change will result,
 must be modifiable; otherwise, an error will be generated.

 If the superclass of the receiver has a constraint on the same instance
 variable, then aClass must be identical to, or a subclass of, that inherited
 constraint.

 For each of the receiver's subclasses, if the constraint on the specified
 instance variable is aClass or is a subclass of aClass, then that constraint
 will be unchanged.  Otherwise, the subclass's constraint will be changed to
 aClass."

| ivInfo offset mySubclasses superConstraintClass |
self _validatePrivilege ifFalse:[ ^ nil ].
aClass _validateIsClass ifFalse:[ ^ nil ].
(Symbol _existingWithAll: aString) ifNotNil:[ :aSymbol |
  ivInfo := self _ivOffsetAndConstraint: aSymbol .
].
ivInfo ifNil:[ ^ self _error: #classErrNotAVar args:{ aString } ] .
offset := ivInfo at: 1 .
superConstraintClass := self superClass _namedIvConstraintAtOffset: offset.
(aClass ~~ Object and: [superConstraintClass ~~ Object])
ifTrue: [ 
	(aClass validateSubclassOf: superConstraintClass) ifFalse:[
	  ^ nil
	] ].
mySubclasses := self subclasses .
self _rwNewConstraint: aClass atOffset: offset .
mySubclasses do:[:x| x _rwNewInheritedConstraint: aClass atOffset: offset ] .
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rwNewConstraint: aClass atOffset: offset

	| oldConstraintsArray newConstraintsArray constraintsIndex instanceVariableNames |
	oldConstraintsArray := constraints.
	newConstraintsArray := oldConstraintsArray copy.
	instanceVariableNames := self class allInstVarNames.
	constraintsIndex := instanceVariableNames indexOf: #constraints.
	self _unsafeAt: constraintsIndex put: newConstraintsArray.

	[ self _newConstraint: aClass atOffset: offset ] on: Deprecated do: [:ex | ex resume ].

	constraints immediateInvariant
%

category: '*rowan-gemstone-kernel'
method: Behavior
_rwNewInheritedConstraint: aClass atOffset: offset

"Change the constraint for offset to aClass if that offset is not
 already constrained to be a subclass of aClass.  Assume all
 variance and error checks have been done."

self _validatePrivilege ifTrue:[ 
  ((self _constraintAt: offset ) isSubclassOf: aClass ) ifFalse:[
    self _rwNewConstraint: aClass atOffset: offset .
    self subclasses do:[:aSubcls|
       aSubcls _rwNewInheritedConstraint: aClass atOffset: offset ].
  ] .
]
 
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Behavior
_setConstraintBit

"Sets the constraint bit in the 'format' instance variable of the receiver."

self deprecated: 'Behavior>>_setConstraintBit deprecated, Constraints are no longer supported'.
self _validatePrivilege ifTrue:[
  format := format bitOr: 16#10 .
]
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Behavior
_setVaryingConstraint: aClass

"Assign a new value to the constraint on unnamed variables of the receiver,
 assuming all checks have been made."

| constrs ofs |

self deprecated: 'Behavior>>_setVaryingConstraint: deprecated, Constraints are no longer supported'.
self _validatePrivilege ifTrue:[
  constrs := constraints .
  ofs := self instSize + 1 .
  constrs size == 0 ifTrue:[ 
    aClass == Object ifTrue:[ ^ self "nothing to do"].
    (constrs := Array new: ofs) replaceFrom: 1 to: ofs withObject: Object .
    constraints := constrs .
  ].
  constrs at: ofs put: aClass .
  (aClass == Object) ifFalse:[ self _setConstraintBit ].
  self _refreshClassCache: false .
]
%

! Class extensions for 'Boolean'

!		Instance methods for 'Boolean'

category: '*ast-kernel-core'
method: Boolean
rbStoreOn: aStream
  aStream nextPutAll: self asString
%

category: '*Cypress-PackageManagement'
method: Boolean
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	aStream nextPutAll: self printString
%

! Class extensions for 'ByteArray'

!		Instance methods for 'ByteArray'

category: '*rowan-gemstone-kernel'
method: ByteArray
byteArrayMap

	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"

	| map |
	map := ByteArray new: 256 withAll: 0.
	self do: [ :ascii | map at: ascii + 1 put: 1 ].
	^ map
%

! Class extensions for 'CharacterCollection'

!		Instance methods for 'CharacterCollection'

category: '*rowan-gemstone-kernel'
method: CharacterCollection
asRwGemStoneVersionNumber

	^ RwGemStoneVersionNumber fromString: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
asRwRepository

	"return a platform appropriate repository for the repository identified in the receiver"

	^ self asRwUrl asRwRepository
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
asRwSemanticVersionNumber

	^ RwSemanticVersionNumber fromString: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
asRwUrl

	""

	^ RwUrl fromString: self
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
endsWith: suffix

	"Answer whether the tail end of the receiver is the same as suffix.
	 The comparison is case-sensitive."

	| ofs |
	suffix size == 0
		ifTrue: [ ^ false ].
	(ofs := self size - suffix size) < 0
		ifTrue: [ ^ false ].
	^ self at: ofs + 1 equals: suffix	"
  'Elvis' endsWith: 'vis'
  'Elvis' endsWith: ''
"
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
findString: subString startingAt: startIndex caseSensitive: aBoolean

	^ self _findString: subString startingAt: startIndex ignoreCase: aBoolean not
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
indexOfAnyOf: specialChars startingAt: oldPos

	oldPos to: self size do: [ :i | 
		(specialChars includes: (self at: i))
			ifTrue: [ ^ i ] ].
	^ 0
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
indexOfAnyOf: aByteArray startingAt: start ifAbsent: aBlock

	"returns the index of the first character in the given set, starting from start"

	| ans |
	ans := self class
		findFirstInString: self
		inSet: aByteArray asByteArray byteArrayMap
		startingAt: start.
	ans = 0
		ifTrue: [ ^ aBlock value ]
		ifFalse: [ ^ ans ]
%

category: '*tonel-gemstonecommon-core'
method: CharacterCollection
join: aCollection 
	"'*' join: #('WWWWW' 'W  EW' 'zzzz')
		->  'WWWWW*W  EW*zzzz' "
	^ self class new: (aCollection size * self size) streamContents: [:stream | 
			aCollection
				do: [:each | stream nextPutAll: each asString] 
				separatedBy: [stream nextPutAll: self]]
%

category: '*tonel-gemstonecommon-core'
method: CharacterCollection
lineIndicesDo: aBlock
	"execute aBlock with 3 arguments for each line:
	- start index of line
	- end index of line without line delimiter
	- end index of line including line delimiter(s) CR, LF or CRLF"
	
	| cr lf start sz nextLF nextCR |
	start := 1.
	sz := self size.
	cr := Character cr.
	nextCR := self indexOf: cr startingAt: 1.
	lf := Character lf.
	nextLF := self indexOf: lf startingAt: 1.
	[ start <= sz ] whileTrue: [
		(nextLF = 0 and: [ nextCR = 0 ])
			ifTrue: [ "No more CR, nor LF, the string is over"
					aBlock value: start value: sz value: sz.
					^self ].
		(nextCR = 0 or: [ 0 < nextLF and: [ nextLF < nextCR ] ])
			ifTrue: [ "Found a LF"
					aBlock value: start value: nextLF - 1 value: nextLF.
					start := 1 + nextLF.
					nextLF := self indexOf: lf startingAt: start ]
			ifFalse: [ 1 + nextCR = nextLF
				ifTrue: [ "Found a CR-LF pair"
					aBlock value: start value: nextCR - 1 value: nextLF.
					start := 1 + nextLF.
					nextCR := self indexOf: cr startingAt: start.
					nextLF := self indexOf: lf startingAt: start ]
				ifFalse: [ "Found a CR"
					aBlock value: start value: nextCR - 1 value: nextCR.
					start := 1 + nextCR.
					nextCR := self indexOf: cr startingAt: start ]]]
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
putOn: aStream

	^ aStream nextPutAll: self
%

category: '*ast-kernel-core'
method: CharacterCollection
rbStoreOn: aStream
  "Print inside string quotes, doubling inbedded quotes."

  | x |
  aStream nextPut: $'.
  1 to: self size do: [ :i | 
    aStream nextPut: (x := self at: i).
    x = $'
      ifTrue: [ aStream nextPut: x ] ].
  aStream nextPut: $'
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
rwPlatformAttributeMatchForGemStoneVersion: anRwGemStoneVersionConfigurationPlatformAttributeMatcher

	^ anRwGemStoneVersionConfigurationPlatformAttributeMatcher matchString: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
rwPlatformAttributeMatchForString: anRwStringConfigurationPlatformAttributeMatcher

	^ anRwStringConfigurationPlatformAttributeMatcher matchString: self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
rwSemanticIntegerLessThanSelf: anInteger

	"integers have greater precedence than strings"
	"anInteger < aString-> true"

  ^ true
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
rwSemanticStringLessThanSelf: aString

	^ aString < self
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
rwSemanticVersionComponentLessThan: aRwSemanticVersonComponent

	^ aRwSemanticVersonComponent rwSemanticStringLessThanSelf: self
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
substrings: separators 
	"Answer an array containing the substrings in the receiver separated 
	by the elements of separators."
	| result sourceStream subStringStream |
	
	(separators isString or: [ separators allSatisfy: [ :element | element isCharacter ] ])
		ifFalse: [ ^ self error: 'separators must be Characters.' ].
	sourceStream := self readStream.
	result := OrderedCollection new.
	subStringStream := String new writeStreamPortable.
	[ sourceStream atEnd ] whileFalse: [
		| char |
		char := sourceStream next.
		(separators includes: char)
			ifTrue: [
				subStringStream isEmpty ifFalse: [
					result add: subStringStream contents.
					subStringStream := String new writeStreamPortable ] ]
			ifFalse: [
				subStringStream nextPut: char ] ].
	subStringStream isEmpty ifFalse: [
		result add: subStringStream contents ].
	^ result asArray
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
trimBoth

	"Trim separators from both sides of the receiving string."

	^ self trimBoth: [ :char | char isSeparator ]
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
trimBoth: aBlock

	"Trim characters satisfying the condition given in aBlock from both sides of the receiving string."

	^ self trimLeft: aBlock right: aBlock
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
trimLeft

	"Trim separators from the left side of the receiving string."

	^ self trimLeft: [ :char | char isSeparator ]
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
trimLeft: aBlock

	"Trim characters satisfying the condition given in aBlock from the left side of the receiving string."

	^ self trimLeft: aBlock right: [ :char | false ]
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
trimLeft: aLeftBlock right: aRightBlock

	"Trim characters satisfying the condition given in aLeftBlock from the left side and aRightBlock from the right sides of the receiving string."

	| left right |
	left := 1.
	right := self size.
	[ left <= right and: [ aLeftBlock value: (self at: left) ] ]
		whileTrue: [ left := left + 1 ].
	[ left <= right and: [ aRightBlock value: (self at: right) ] ]
		whileTrue: [ right := right - 1 ].
	^ self copyFrom: left to: right
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
trimRight

	"Trim separators from the right side of the receiving string."

	^ self trimRight: [ :char | char isSeparator ]
%

category: '*tonel-gemstone-kernel'
method: CharacterCollection
trimRight: aBlock

	"Trim characters satisfying the condition given in aBlock from the right side of the receiving string."

	^ self trimLeft: [ :char | false ] right: aBlock
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
unescapePercents

	"change each %XY substring to the character with ASCII value XY in hex.  This is the opposite of #encodeForHTTP"

	| ans c asciiVal pos oldPos specialChars |
	ans _ WriteStream on: String new.
	oldPos _ 1.
	specialChars _ '+%'.

	[ 
	pos _ self indexOfAnyOf: specialChars startingAt: oldPos.
	pos > 0 ]
		whileTrue: [ 
			ans nextPutAll: (self copyFrom: oldPos to: pos - 1).
			c _ self at: pos.
			c = $+
				ifTrue: [ ans nextPut: $  ]
				ifFalse: [ 
					(c = $% and: [ pos + 2 <= self size ])
						ifTrue: [ 
							asciiVal _ ((self at: pos + 1) asUppercase digitValueInRadix: 16) * 16
								+ ((self at: pos + 2) asUppercase digitValueInRadix: 16).
							pos _ pos + 2.
							asciiVal > 255
								ifTrue: [ ^ self ].	"not really an escaped string"
							ans nextPut: (Character value: asciiVal) ]
						ifFalse: [ ans nextPut: c ] ].
			oldPos _ pos + 1 ].
	ans nextPutAll: (self copyFrom: oldPos to: self size).
	^ ans contents
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
withGemstoneLineEndings

	"assume the string is textual, and that CR, LF, and CRLF are all 
  valid line endings.  Replace each occurence with a single LF"

	| cr lf crlf inPos outPos outString lineEndPos newOutPos |
	cr := Character cr.
	lf := Character lf.
	crlf := ByteArray new.
	crlf
		add: cr asciiValue;
		add: lf asciiValue.

	inPos := 1.
	outPos := 1.
	outString := self class _newString: self size.

	[ 
	lineEndPos := self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [ 0 ].
	lineEndPos ~= 0 ]
		whileTrue: [ 
			newOutPos := outPos + (lineEndPos - inPos + 1).
			outString
				replaceFrom: outPos
				to: newOutPos - 2
				with: self
				startingAt: inPos.
			outString at: newOutPos - 1 put: lf.
			outPos := newOutPos.

			((self at: lineEndPos) = cr
				and: [ lineEndPos < self size and: [ (self at: lineEndPos + 1) = lf ] ])
				ifTrue: [ 
					"CRLF ending"
					inPos := lineEndPos + 2 ]
				ifFalse: [ 
					"CR or LF ending"
					inPos := lineEndPos + 1 ] ].	"no more line endings.  copy the rest"
	newOutPos := outPos + (self size - inPos + 1).
	outString
		replaceFrom: outPos
		to: newOutPos - 1
		with: self
		startingAt: inPos.

	^ outString copyFrom: 1 to: newOutPos - 1
%

category: '*tonel-gemstonecommon-core'
method: CharacterCollection
withLineEndings: lineEndingString

	| stream |
	
	stream := nil.
	self lineIndicesDo: [ :start :endWithoutDelimiters :end |
		(stream isNil and: [ endWithoutDelimiters ~= end ]) ifTrue: [
			(self copyFrom: endWithoutDelimiters + 1 to: end) = lineEndingString ifFalse: [
				stream := WriteStreamPortable with: self copy.
				stream position: start - 1 ]].
		stream ifNotNil: [
			stream next: endWithoutDelimiters - start + 1 putAll: self startingAt: start.
			endWithoutDelimiters = end ifFalse: [
				stream nextPutAll: lineEndingString ]]].
	^stream
		ifNil: [ self ]
		ifNotNil: [ 
			stream position = self size
				ifTrue: [ stream originalContents ]
				ifFalse: [ stream contents ]]
%

category: '*rowan-gemstone-kernel'
method: CharacterCollection
withoutGemstoneLineEndings

	"assume the string is textual, and that CR, LF, and CRLF are all 
	valid line endings.  Remove each occurence. "

	| cr lf crlf inPos outPos outString lineEndPos newOutPos |
	cr := Character cr.
	lf := Character lf.
	crlf := ByteArray new.
	crlf
		add: cr asciiValue;
		add: lf asciiValue.

	inPos := 1.
	outPos := 1.
	outString := self class _newString: self size.

	[ 
	lineEndPos := self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [ 0 ].
	lineEndPos ~= 0 ]
		whileTrue: [ 
			newOutPos := outPos + (lineEndPos - inPos + 1).
			outString
				replaceFrom: outPos
				to: newOutPos - 2
				with: self
				startingAt: inPos.
			outPos := newOutPos - 1.

			((self at: lineEndPos) = cr
				and: [ lineEndPos < self size and: [ (self at: lineEndPos + 1) = lf ] ])
				ifTrue: [ 
					"CRLF ending"
					inPos := lineEndPos + 2 ]
				ifFalse: [ 
					"CR or LF ending"
					inPos := lineEndPos + 1 ] ].	"no more line endings.  copy the rest"
	newOutPos := outPos + (self size - inPos + 1).
	outString
		replaceFrom: outPos
		to: newOutPos - 1
		with: self
		startingAt: inPos.

	^ outString copyFrom: 1 to: newOutPos - 1
%

! Class extensions for 'Class'

!		Instance methods for 'Class'

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
indexableSubclass: aString
instVarNames: anArrayOfInstvarNames
classVars: anArrayOfClassVars
classInstVars: anArrayOfClassInstVars
poolDictionaries: anArrayOfPoolDicts
inDictionary: aDictionary
newVersionOf: oldClass
description: aDescription
constraints: constraintsArray
options: optionsArray
	"Creates and returns a new indexable subclass of the receiver.  Instances of the
 new class are represented as pointer objects.

 This method generates an error if instances of the receiver are of special
 storage format or if they are NSCs.

 optionsArray is an Array of Symbols containing zero or more of  
   #noInheritOptions,  #subclassesDisallowed, #disallowGciStore, #modifiable , 
   #traverseByCallback 
 and at most one of 
   #dbTransient, #instancesNonPersistent, #instancesInvariant
 If present, #noInheritOptions must be the first element and it causes
 none of subclassesDisallowed, disallowGciStore, traverseByCallback,
         dbTransient, instancesNonPersistent, instancesInvariant 
 to be inherited from the superclass, nor copied from the
 current version of the class.

 Returns oldClass if it would be equivalent to the requested new class.
 (See Class(C)>>comment). "

	| hist fmt descr newClass |
	self isBytes
		ifTrue: 
			[^aString _error: #classErrBadFormat
				with: 'cannot create indexable subclass of byte class'].
	self isNsc
		ifTrue: 
			[^aString _error: #classErrBadFormat
				with: 'cannot create indexable subclass of Nsc class'].
	fmt := format bitOr: 16r4.	"add indexable bit"
	descr := aDescription.
	oldClass
		ifNotNil: 
			[(self
				_equivalentSubclass: oldClass
				superCls: self
				name: aString
				newOpts: optionsArray
				newFormat: fmt
				newInstVars: anArrayOfInstvarNames
				newClassInstVars: anArrayOfClassInstVars
				newPools: anArrayOfPoolDicts
				newClassVars: anArrayOfClassVars
				inDict: aDictionary
				constraints: constraintsArray isKernel: false )
					ifTrue: 
						[oldClass _commentOrDescription: aDescription.
						^oldClass	"avoid creation of a new version"].
			hist := oldClass classHistory.
			descr ifNil: [descr := oldClass comment]].
	newClass := self
		_subclass: aString
		instVarNames: anArrayOfInstvarNames
		format: fmt
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		inDictionary: aDictionary
		inClassHistory: hist
		description: descr
		options: optionsArray.
	newClass _installConstraints: constraintsArray oldClass: oldClass.
	^ newClass

%

category: '*rowan-gemstone-kernel'
method: Class
rwByteSubclass: aString classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'bytes'
		superclass: self name asString
		instVarNames: #()
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwByteSubclass: aString classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName  options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'bytes'
		superclass: self name asString
		instVarNames: #()
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: #()
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwComment

	"Provide direct access to comment of class, bypassing default comeent string."
  
  ^ (self _extraDictAt: #comment) ifNil: [ '' ]
%

category: '*rowan-gemstone-kernel'
method: Class
rwComment: aString

	^ Rowan projectTools browser
		updateClassComment: aString
		forClassNamed: self thisClass name asString
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwIndexableSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'variable'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: #()
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aCategoryName
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName constraints: constraintArray options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: constraintArray
		options: optionsArray
%

category: '*rowan-gemstone-kernel'
method: Class
rwSubclass: aString instVarNames: anArrayOfStrings classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts category: aCategoryName packageName: aPackageName options: optionsArray

	^ Rowan projectTools browser
		addOrUpdateClassDefinition: aString
		type: 'normal'
		superclass: self name asString
		instVarNames: anArrayOfStrings
		classVars: anArrayOfClassVars
		classInstVars: anArrayOfClassInstVars
		poolDictionaries: anArrayOfPoolDicts
		category: aCategoryName
		packageName: aPackageName
		constraints: #()
		options: optionsArray
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
subclass: aString
instVarNames: anArrayOfInstvarNames
classVars: anArrayOfClassVars
classInstVars: anArrayOfClassInstVars
poolDictionaries: anArrayOfPoolDicts
inDictionary: aDictionary
constraints: aConstraint
options: optionsArr

| hist theConstraints descr oldClass |
self deprecated: 'Obsolete in GemStone/S 64.  The preferred methods are in the Subclass Creation category (' , aString , ').'.
theConstraints := self _checkConstraints: aConstraint instVarNames: anArrayOfInstvarNames .
oldClass := self _classNamed: aString inDictionary: aDictionary .
oldClass ifNotNil:[  
  (self _equivalentSubclass: oldClass superCls: self name: aString newOpts: optionsArr 
	newFormat: self format 
    newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars 
    newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars 
    inDict: aDictionary constraints: aConstraint  isKernel: false ) ifTrue:[
       ^ oldClass  "avoid creation of a new version"
  ].
  hist := oldClass classHistory .
  descr := oldClass comment.
].
^ self _subclass: aString
          instVarNames: anArrayOfInstvarNames
          format: format
          constraints: theConstraints
          classVars: anArrayOfClassVars
          classInstVars: anArrayOfClassInstVars
          poolDictionaries: anArrayOfPoolDicts
          inDictionary: aDictionary
          inClassHistory: hist 
          description: descr
          options: optionsArr
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
subclass: aString
instVarNames: anArrayOfInstvarNames
classVars: anArrayOfClassVars
classInstVars: anArrayOfClassInstVars
poolDictionaries: anArrayOfPoolDicts
inDictionary: aDictionary
newVersionOf: oldClass
description: aDescription
constraints: constraintsArray
options: optionsArray

	"Creates and returns a new subclass of the receiver.

 optionsArray is an Array of Symbols containing zero or more of  
   #noInheritOptions,  #subclassesDisallowed, #disallowGciStore, #modifiable , 
   #traverseByCallback 
 and at most one of 
   #dbTransient, #instancesNonPersistent, #instancesInvariant
 If present, #noInheritOptions must be the first element and it causes
 none of subclassesDisallowed, disallowGciStore, traverseByCallback,
         dbTransient, instancesNonPersistent, instancesInvariant 
 to be inherited from the superclass, nor copied from the
 current version of the class.

 Returns oldClass if it would be equivalent to the requested new class.
 (See Class(C)>>comment). "

  | hist descr newClass |
  descr := aDescription.
  oldClass ifNotNil:[
    (self _equivalentSubclass: oldClass superCls: self name: aString
         newOpts: optionsArray newFormat: oldClass format 
         newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars
         newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars
         inDict: aDictionary constraints: constraintsArray isKernel: false ) ifTrue:[
      oldClass _commentOrDescription: aDescription.
      ^oldClass	"avoid creation of a new version"
    ].
    hist := oldClass classHistory.
    descr ifNil: [descr := oldClass comment]
  ].
  newClass := self _subclass: aString instVarNames: anArrayOfInstvarNames
	  format: format classVars: anArrayOfClassVars
	  classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts
	  inDictionary: aDictionary inClassHistory: hist
	  description: descr options: optionsArray.
	newClass _installConstraints: constraintsArray oldClass: oldClass.
	^ newClass
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
_checkConstraints: aConstraint instVarNames: anArrayOfInstvarNames
  "Returns aConstraint or { aConstraint } "
  | theConstraints |
  theConstraints := aConstraint .
  (self isPointers) ifTrue: [
     (aConstraint _isArray) ifFalse: [ aConstraint _error: #classErrConstraintNotClass ].
  ] ifFalse:[
   (self isBytes) ifTrue:[
     (self instSize ~~ 0) ifTrue: [ self _error: #classErrByteObjInstVars].
     (anArrayOfInstvarNames size ~~ 0) ifTrue: [  self _error: #classErrByteObjInstVars].
     (aConstraint _isArray) ifFalse: [  aConstraint _error: #classErrConstraintNotClass ].
     (aConstraint size ~~ 0) ifTrue: [  self _error: #classErrBadConstraint ] .
   ] ifFalse:[
     (self isNsc) ifTrue:[
	(aConstraint _isArray) ifFalse:[ "for compatibility with 3.0, construct an Array"
		   "specifying inherited constraints on named instance variables" 
		 "plus the specified constraint on unnamed instance variables."
	   theConstraints := { aConstraint } .
	].
     ].
   ].
  ].
  ^ theConstraints
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
_constraintsEqual: anArray
  "Result true if receiver's constraints equal to anArray or 
   if anArray is empty and receiver's constraints are all Object ."
^ [ | myConstr superInstSiz ofs arySiz |
    anArray _isArray ifTrue:[
      myConstr := constraints .
      superInstSiz := superClass ifNil:[ 0 ] ifNotNil:[:sc | sc instSize] .
      (arySiz := anArray size) == 0 ifTrue:[
	superInstSiz + 1 to: myConstr size do:[:j | 
	  (myConstr at:j ) == Object ifFalse:[ 
	     (j == (self instSize + 1) and:[ superClass ~~ nil]) ifTrue:[
	       ^ self _varyingConstraint isVersionOf: superClass _varyingConstraint 
	     ].
	     ^ false 
	  ].
	].
      ] ifFalse:[ | varConstr instSiz myConstrSiz ivNams |
	instSiz := self instSize .
	varConstr := (myConstr atOrNil: instSiz + 1) ifNil:[ Object]. 
	ofs := 1 .
	myConstr := myConstr copyFrom: superInstSiz + 1 to: instSiz .
	"elements of myConstr, and varConstr, set to nil when finding a matching
	 element in anArray."
	myConstrSiz := myConstr size .
	ivNams := instVarNames .
	1 to: arySiz do:[:j | | elem |
	  elem := anArray at: j .
	  elem _isArray ifTrue:[ | ivNam |
	    ivNam := elem atOrNil: 1 .
	    1 to: myConstrSiz do:[:m |
	      (ivNams at: (superInstSiz + m)) == ivNam ifTrue:[ 
		 ((elem atOrNil: 2) isVersionOf: (myConstr at: m))   ifTrue:[
		   myConstr at: m put: nil .
		 ] ifFalse:[
		   ^ false 
		 ].
	      ].
	    ].
	  ] ifFalse:[
	    j == arySiz ifTrue:[ 
	      (elem isVersionOf: varConstr) ifTrue:[ varConstr := nil ] ifFalse:[ ^ false ]
	    ] ifFalse:[ 
	      ^ false 
	    ].
	  ].
	].
	"items neither nil nor Object were missing from anArray"
	(varConstr == nil or:[ varConstr == Object ]) ifFalse:[ ^ false ].
	1 to: myConstrSiz do:[:j| | cx |
	  ((cx := myConstr at: j ) == nil or:[ cx == Object]) ifFalse:[ ^ false ]
	].
      ]
    ] ifFalse:[
      (self _varyingConstraint isVersionOf: anArray) ifFalse:[ ^ false ].
    ].
    true
  ] onSynchronous: Error do:[:ex| false ].
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
_equivalentSubclass: oldClass superCls: actualSelf name: aString newOpts: optionsArray newFormat: theFormat newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars inDict: aDictionary constraints: aConstraint isKernel: isKernelBool
	^ self
		_equivalentSubclass: oldClass
		superCls: actualSelf
		name: aString
		newOpts: optionsArray
		newFormat: theFormat
		newInstVars: anArrayOfInstvarNames
		newClassInstVars: anArrayOfClassInstVars
		newPools: anArrayOfPoolDicts
		newClassVars: anArrayOfClassVars
		inDict: aDictionary
		isKernel: isKernelBool
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
_installConstraints: theConstraints

	| existingConstraintsMap existingVaryingConstraint theConstraintsMap theVaryingConstraint keys existingConstraints myInstVarNames superConstraints superC superInstVarNames superConstraintsMap |
	superConstraintsMap := Dictionary new.
	existingConstraintsMap := Dictionary new.
	existingVaryingConstraint := self _varyingConstraint.
	myInstVarNames := self allInstVarNames.
	superC := self superClass.
	superInstVarNames := superC ifNil: [ {} ] ifNotNil: [ superC allInstVarNames ].
	[ 
	superConstraints := superC
		ifNil: [ {} ]
		ifNotNil: [ :superCl | superCl _constraints ifNil: [ {} ] ].
	existingConstraints := self _constraints ifNil: [ {} ] ]
		on: Deprecated
		do: [ :ex | ex resume ].
	1 to: superConstraints size do: [ :index | 
		superConstraintsMap
			at: (superInstVarNames at: index)
			put: (superConstraints at: index) ].
	1 to: existingConstraints size do: [ :index | 
		existingConstraintsMap
			at: (myInstVarNames at: index)
			put: (existingConstraints at: index) ].
	theConstraintsMap := Dictionary new.
	theVaryingConstraint := Object.
	theConstraints
		do: [ :arrayOrVaryingConstraintClass | 
			arrayOrVaryingConstraintClass _isArray
				ifTrue: [ 
					theConstraintsMap
						at: (arrayOrVaryingConstraintClass at: 1)
						put: (arrayOrVaryingConstraintClass at: 2) ]
				ifFalse: [ theVaryingConstraint := arrayOrVaryingConstraintClass ] ].
	keys := existingConstraintsMap keys copy.
	keys addAll: theConstraintsMap keys.
	keys addAll: superConstraintsMap keys.
	keys
		do: [ :key | 
			| existingConstraint theConstraint superConstraint instVarString |
			existingConstraint := existingConstraintsMap at: key ifAbsent: [  ].
			superConstraint := superConstraintsMap at: key ifAbsent: [  ].
			theConstraint := theConstraintsMap at: key ifAbsent: [  ].
			instVarString := key asString.
			existingConstraint == theConstraint
				ifTrue: [ 
					(theConstraint isNil and: [ superConstraint notNil ])
						ifTrue: [ 
							"inherit constraint from superclass"
							self _rwInstVar: instVarString constrainTo: superConstraint ] ]
				ifFalse: [ 
					existingConstraint == nil
						ifTrue: [ 
							"add theConstraint"
							self _rwInstVar: instVarString constrainTo: theConstraint ]
						ifFalse: [ 
							theConstraint == nil
								ifTrue: [ 
									"remove the constraint"
									self _rwInstVar: instVarString constrainTo: Object ]
								ifFalse: [ 
									"change the value of the constraint"
									self _rwInstVar: instVarString constrainTo: theConstraint ] ] ] ].
	existingVaryingConstraint == theVaryingConstraint
		ifFalse: [ 
			"change the varying constraint"
			[ self _setVaryingConstraint: theVaryingConstraint ]
				on: Deprecated
				do: [ :ex | ex resume ] ]
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
_installConstraints: theConstraints oldClass: oldClass

	oldClass ifNotNil: [ [ self _installOldConstraints: oldClass _constraints ] on: Deprecated do: [:ex | ex resume ] ].
	theConstraints 
		ifNil: [ constraints := nil ]
		ifNotNil: [ self _installConstraints: theConstraints ]
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
_installOldConstraints: theConstraints

	constraints := theConstraints copy
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
_primSubclass: nameSym
instVarNames: arrayOfIvNames
format: anInteger
constraints: aConstraint
classVars: aSymbolDictionary
poolDictionaries: anArrayOfPoolDicts
classInstanceVars: arrayOfCivNames

	aConstraint isEmpty ifFalse: [
"need to add constraint creation in this method"
"self halt"].
	^self
		_primSubclass: nameSym
		instVarNames: arrayOfIvNames
		format: anInteger
		classVars: aSymbolDictionary
		poolDictionaries: anArrayOfPoolDicts
		classInstanceVars: arrayOfCivNames
%

category: '*rowan-gemstone-kernel'
method: Class
_rwDefinitionOfConstraints
"This is the part of the definition that describes constraints.  Constraints are
 deprecated and not enforced, but may still be useful for some purposes.
 Returns a string of the form
     constraints: { <Array of instance-variable-symbol/class-name pairs> }
 "

| result firstElement constraintArray |
result := String new.

result add: 'constraints: '.
( constraints isKindOf: Array ) ifTrue: [
	constraintArray := self _rwSortedConstraints.
    result addAll: '{ '.
    firstElement := true.
    constraintArray do: [ :ar |
        " if not the first constraint, prefix with a period to separate
          from the last constraint "
        firstElement ifFalse: [
          result add: ' . '; lf; add: '                '
        ]
        ifTrue: [
          firstElement := false
        ].
		(ar  isKindOf: Array ) 
			ifTrue: [
				result add: '{ #'; add: (ar at: 1) ;
					add: ' . '; add: (ar at: 2) name; addLast: $} ]
			ifFalse: [ 
				"varyingConstraint"
				result add: ar name ].
      ].
    result add: ' }'.
  ]
  ifFalse: [
    constraints class class == Metaclass3 ifTrue: [
      result add: constraints name.
    ]
    ifFalse: [
      result add: ' nil'
    ].
  ].

^result
%

category: '*rowan-gemstone-kernel'
method: Class
_rwOptionsArray
  "copy of _optionsArray"

  | result optCount | 
  result := { } .
  optCount := 0 .
  self instancesDbTransient ifTrue:[ result add: #dbTransient . optCount := optCount + 1 ].
  self instancesNonPersistent ifTrue:[ result add:  #instancesNonPersistent  . optCount := optCount + 1 ].
  self instancesInvariant ifTrue:[ result add:  #instancesInvariant  . optCount := optCount + 1 ].
  optCount > 1 ifTrue:[
    self _error: #classErrBadFormat
        with:'only one of #dbTransient #instancesNonPersistent  #instancesInvariant allowed' .
  ].
  "self _structuralUpdatesDisallowed ifTrue:[ result add: #disallowGciStore  ]." "commented out variant of _optionsArray (https://github.com/dalehenrich/Rowan/issues/292)"
  self isModifiable ifTrue:[ result add: #modifiable  ].
  self subclassesDisallowed ifTrue:[ result add: #subclassesDisallowed  ].
  "self _traversalByCallback ifTrue:[ result add: #traverseByCallback  ]." "commented out variant of _optionsArray (https://github.com/dalehenrich/Rowan/issues/292)"
  ^ result
%

category: '*rowan-gemstone-kernel'
method: Class
_rwOptionsForDefinition 
  "copy of _optionsForDefinition"

  | result arr |
  result :=  'options: #(' copy .
  arr := self _rwOptionsArray .
  1 to: arr size do:[:j | result add: $ ; add: (arr at: j) ].
  result add: $)  .
  ^ result
%

category: '*rowan-gemstone-kernel'
method: Class
_rwSortedConstraints
"as of https://github.com/dalehenrich/Rowan/issues/293, no longer sorting in alphabetical order ... instance variable order is the right answer"

|   aConstraint constraintArray |
( constraints isKindOf: Array ) ifTrue: [
	constraintArray := {}.
    1 to: self instSize do: [ :x |
      aConstraint := constraints atOrNil: x .
      ((aConstraint ~~ nil _and: [aConstraint ~~ Object])
          _and:[ superClass == nil
            _or:[ ((superClass _namedIvConstraintAt: x) isVersionOf: aConstraint) not ]] )
      ifTrue: [ constraintArray add: {(instVarNames at: x) . aConstraint } ] ].

    aConstraint:= self _varyingConstraint.
    ( (aConstraint ~~ Object) _and:
        [(superClass _varyingConstraint) ~~ aConstraint] )
		ifTrue: [ constraintArray add: aConstraint ]
  ]
  ifFalse: [
    constraints class class == Metaclass3 ifTrue: [
      ^ constraints
    ]
    ifFalse: [
      ^nil
    ].
  ].

^constraintArray
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
_subclass: className instVarNames: anArrayOfInstvarNames format: theFormat constraints: theConstraints classVars: anArrayOfClassVars classInstVars: anArrayOfClassInstVars poolDictionaries: anArrayOfPoolDicts inDictionary: aDictionary inClassHistory: aClassHistory description: aDescription options: optionsArray

	"Backport of bugfix for Bug47433"

	"The preferred private subclass creation method.
 optionsArray is an Array of Symbols containing zero or more of  
   #noInheritOptions,  #subclassesDisallowed, #disallowGciStore, #modifiable , 
   #traverseByCallback 
 and at most one of 
   #dbTransient, #instancesNonPersistent, #instancesInvariant .
 If present, #noInheritOptions must be the first element and it causes
 none of subclassesDisallowed, disallowGciStore, traverseByCallback,
         dbTransient, instancesNonPersistent, instancesInvariant 
 to be inherited from the superclass, nor copied from the
 current version of the class.
"

	| cvDict result theName ivNames classCon conEle conEleEle theHist poolDicts modifiableBool fmtArr fmt nCivs sza szb civNames |
	self _validatePrivilege
		ifFalse: [ ^ nil ].
	className _isOneByteString
		ifFalse: [ 
			(className _validateClass: CharacterCollection)
				ifFalse: [ ^ nil ] ].
	self subclassesDisallowed
		ifTrue: [ ^ self _error: #'classErrSubclassDisallowed' ].
	anArrayOfClassInstVars
		ifNotNil: [ 
			anArrayOfClassInstVars _isArray
				ifFalse: [ 
					(anArrayOfClassInstVars _validateClass: Array)
						ifFalse: [ ^ nil ] ] ].
	aDictionary
		ifNotNil: [ 
			(aDictionary _validateClass: SymbolDictionary)
				ifFalse: [ ^ nil ] ].
	fmtArr := self _validateOptions: optionsArray withFormat: theFormat newClassName: className .
	fmt := fmtArr at: 1.
	modifiableBool := fmtArr at: 2.
	(self instancesInvariant and: [ (fmt bitAnd: 16r8) == 0 ])
		ifTrue: [ ^ self _error: #'classErrInvariantSuperClass' ].
	anArrayOfInstvarNames _isArray
		ifFalse: [ 
			(anArrayOfInstvarNames _validateClass: Array)
				ifFalse: [ ^ nil ] ].
	ivNames := {}.
	1 to: anArrayOfInstvarNames size do: [ :j | ivNames add: (anArrayOfInstvarNames at: j) ].
	theConstraints _isArray
		ifFalse: [ classCon := theConstraints ]
		ifTrue: [ 
			classCon := theConstraints class new.
			1 to: theConstraints size do: [ :j | 
				conEle := theConstraints at: j.
				conEle _isArray
					ifFalse: [ classCon add: conEle ]
					ifTrue: [ 
						| temp |
						temp := conEle class new.
						1 to: conEle size do: [ :k | 
							conEleEle := conEle at: k.
							(conEleEle isKindOf: CharacterCollection)
								ifTrue: [ temp add: conEleEle asSymbol ]
								ifFalse: [ temp add: conEleEle ] ].
						classCon add: temp ] ] ].
	nCivs := anArrayOfClassInstVars size.
	civNames := anArrayOfClassInstVars.
	nCivs ~~ 0
		ifTrue: [ 
			| aSet |
			civNames := Array new: nCivs.
			aSet := IdentitySet new.
			1 to: nCivs do: [ :k | 
				| aName |
				aName := (anArrayOfClassInstVars at: k) asSymbol.
				self class _validateNewClassInstVar: aName.
				civNames at: k put: aName.
				aSet add: aName.
				aSet size < k
					ifTrue: [ 
						ImproperOperation
							signal:
								'array of new class instanceVariables contains a duplicate ' , aName printString ] ] ].	"Gs64 v3.0 , cvDict and poolDicts maybe nil from caller,
    and will be converted to nil if caller passed an empty Array."
	cvDict := self _makeClassVarDict: anArrayOfClassVars.	"undo the compiler's canonicalization of empty arrays (fix bug 14103) "
	poolDicts := anArrayOfPoolDicts.
	(poolDicts _isArray and: [ poolDicts size == 0 ])
		ifTrue: [ poolDicts := nil ].
	theName := className asSymbol.
	result := self
		_subclass: theName
		instVarNames: ivNames
		format: fmt
		constraints: classCon
		classVars: cvDict
		poolDictionaries: poolDicts
		classInstanceVars: civNames.
	result _installConstraints: classCon.	
	modifiableBool
		ifTrue: [ result _subclasses: IdentitySet new ].
	subclasses ifNotNil: [ subclasses add: result ].
	aDictionary ifNotNil: [ aDictionary at: theName put: result ].

	result extraDict: SymbolDictionary new.
	result _commentOrDescription: aDescription.
	theHist := aClassHistory.
	theHist ifNil: [ theHist := ClassHistory new name: className ].
	theHist notEmpty
		ifTrue: [ result category: theHist current _classCategory ].
	theHist add: result.
	result classHistory: theHist.
	result timeStamp: DateTime now.
	result userId: System myUserProfile userId.

	sza := self class instSize + anArrayOfClassInstVars size.
	szb := result class instSize.
	sza == szb
		ifFalse: [ 
			InternalError
				signal:
					'prim 233: inconsistent class instance variables, superClass+args=>'
						, sza asString , '  newClass=>' , szb asString ].

	modifiableBool
		ifFalse: [ result immediateInvariant ].
	result copyVariables.
	self _clearCachedOrganizer.
	(fmtArr at: 3)
		ifTrue: [ GsFile gciLogServer: 'created class ' , className ].
	^ result
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: Class
_subclass: nameSym
instVarNames: arrayOfIvNames
format: anInteger
constraints: aConstraint
classVars: aSymbolDictionary
poolDictionaries: anArrayOfPoolDicts
classInstanceVars: arrayOfCivNames

self _validateNewClassName: nameSym .
^ self _primSubclass: nameSym
  instVarNames: arrayOfIvNames
  format: anInteger
  constraints: aConstraint
  classVars: aSymbolDictionary
  poolDictionaries: anArrayOfPoolDicts
  classInstanceVars: arrayOfCivNames
%

! Class extensions for 'Collection'

!		Instance methods for 'Collection'

category: '*tonel-gemstonecommon-core'
method: Collection
asDictionary

  | dict |
  dict := Dictionary new.
  self do: [:assoc |
    dict add: assoc].
  ^ dict
%

category: '*tonel-gemstonecommon-core'
method: Collection
flattened
	
	"Flattens a collection of collections (no matter how many levels of collections exist).
	Strings are considered atoms and, as such, won't be flattened
	
	Examples:
	#(1 #(2 3) #(4 (#5))) flattened returns #(1 2 3 4 5) 
	#('string1' #('string2' 'string3')) flattened returns #('string1' 'string2' 'string3')"
	
	^ Array streamContents: [ :stream | self flattenOn: stream].
%

category: '*tonel-gemstonecommon-core'
method: Collection
flattenOn: aStream

	self do: [ :each | (each isCollection and: [each isString not]) 
						ifTrue: [each flattenOn: aStream]
						ifFalse: [aStream nextPut: each]].
%

category: '*tonel-gemstone-kernel'
method: Collection
ifNotEmpty: aBlock

	^ self size == 0
		ifFalse: [ aBlock cull: self ]
%

category: '*tonel-gemstone-kernel'
method: Collection
isCollection

	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"

	^ true
%

category: '*tonel-gemstone-kernel'
method: Collection
select: selectBlock thenDo: doBlock
  "Utility method to improve readability."

  ^ (self select: selectBlock) do: doBlock
%

category: '*tonel-gemstone-kernel'
method: Collection
sort: aSortBlock

	"Sort this array using aSortBlock. The block should take two arguments
	and return true if the first element should preceed the second one."

	^ self sortWithBlock: aSortBlock
%

! Class extensions for 'CypressAddition'

!		Instance methods for 'CypressAddition'

category: '*rowan-cypress-kernel'
method: CypressAddition
isAddition
  ^ true
%

category: '*cypress-environmental-tools'
method: CypressAddition
loadClassDefinition: aSymbolDictionaryName environmentLoader: environmentLoader
  self definition
    loadClassDefinition: aSymbolDictionaryName
    environmentLoader: environmentLoader
%

category: '*cypress-environmental-tools'
method: CypressAddition
loadMethodDefinition: lookupSymbolList environmentLoader: environmentLoader
  self definition
    loadMethodDefinition: lookupSymbolList
    environmentLoader: environmentLoader
%

category: '*cypress-environmental-tools'
method: CypressAddition
postLoadDefinition: lookupSymbolList environmentId: environmentId
  self definition
    postLoadOver: nil
    lookupSymbolList: lookupSymbolList
    environmentId: environmentId
%

! Class extensions for 'CypressClassDefinition'

!		Class methods for 'CypressClassDefinition'

category: '*cypresstonel-core'
classmethod: CypressClassDefinition
name: aClassName superclassName: aSuperclassName category: aCategory instVarNames: someInstanceVariableNames classInstVarNames: someClassInstanceVariableNames classVarNames: someClassVariableNames poolDictionaryNames: somePoolDictionaryNames comment: aComment subclassType: subclassType

	^ self new
		name: aClassName asString
		superclassName: aSuperclassName asString
		category: aCategory asString
		instVarNames:
			(someInstanceVariableNames asArray collect: [ :each | each asString ])
		classInstVarNames:
			(someClassInstanceVariableNames asArray collect: [ :each | each asString ])
		classVarNames:
			(someClassVariableNames asArray collect: [ :each | each asString ])
		poolDictionaryNames:
			(somePoolDictionaryNames asArray collect: [ :each | each asString ])
		comment: (self normalizeLineEndingsOf: aComment)
		subclassType: subclassType asString
%

category: '*cypresstonel-core'
classmethod: CypressClassDefinition
name: aClassName superclassName: aSuperclassName category: aCategory instVarNames: someInstanceVariableNames classInstVarNames: someClassInstanceVariableNames classVarNames: someClassVariableNames poolDictionaryNames: somePoolDictionaryNames comment: aComment type: type
  | st |
  st := type.
  st == #'normal'
    ifTrue: [ st := '' ].
  ^ self
    name: aClassName
    superclassName: aSuperclassName
    category: aCategory
    instVarNames: someInstanceVariableNames
    classInstVarNames: someClassInstanceVariableNames
    classVarNames: someClassVariableNames
    poolDictionaryNames: somePoolDictionaryNames
    comment: aComment
    subclassType: st
%

category: '*cypresstonel-core'
classmethod: CypressClassDefinition
name: aClassName superclassName: aSuperclassName category: aCategory instVarNames: someInstanceVariableNames 
	classInstVarNames: someClassInstanceVariableNames classVarNames: someClassVariableNames 
	poolDictionaryNames: somePoolDictionaryNames gs_options: gs_options gs_constraints: gs_constraints comment: aComment 
	subclassType: subclassType

	^ self new
		name: aClassName asString
		superclassName: aSuperclassName asString
		category: aCategory asString
		instVarNames:
			(someInstanceVariableNames asArray collect: [ :each | each asString ])
		classInstVarNames:
			(someClassInstanceVariableNames asArray collect: [ :each | each asString ])
		classVarNames:
			(someClassVariableNames asArray collect: [ :each | each asString ])
		poolDictionaryNames:
			(somePoolDictionaryNames asArray collect: [ :each | each asString ])
		gs_options: gs_options 
		gs_constraints: gs_constraints
		comment: (self normalizeLineEndingsOf: aComment)
		subclassType: subclassType asString
%

category: '*cypresstonel-core'
classmethod: CypressClassDefinition
name: aClassName superclassName: aSuperclassName category: aCategory instVarNames: someInstanceVariableNames 
	classInstVarNames: someClassInstanceVariableNames classVarNames: someClassVariableNames 
	poolDictionaryNames: somePoolDictionaryNames  gs_options: someGs_options gs_constraints: someGs_constraints
	comment: aComment type: type
  | st |
  st := type.
  st == #'normal'
    ifTrue: [ st := '' ].
  ^ self
    name: aClassName
    superclassName: aSuperclassName
    category: aCategory
    instVarNames: someInstanceVariableNames
    classInstVarNames: someClassInstanceVariableNames
    classVarNames: someClassVariableNames
    poolDictionaryNames: somePoolDictionaryNames
    gs_options: someGs_options 
    gs_constraints: someGs_constraints
    comment: aComment
    subclassType: st
%

!		Instance methods for 'CypressClassDefinition'

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
accept: aVisitor
	aVisitor visitClassDefinition: self.
%

category: '*Cypress-Comparison'
method: CypressClassDefinition
category: aString

	category := aString
%

category: '*Cypress-Comparison'
method: CypressClassDefinition
classCreationSelector
  | type |
  type := self subclassType.
  type = ''
    ifTrue: [ ^ 'subclass:' ]
    ifFalse: [ 
      type = 'indexableSubclass'
        ifTrue: [ ^ 'indexableSubclass:' ]
        ifFalse: [ 
          type = 'byteSubclass'
            ifTrue: [ ^ 'byteSubclass:' ]
            ifFalse: [ self error: 'unknown subclass type: ' , type ] ] ]
%

category: '*Cypress-Comparison'
method: CypressClassDefinition
classDefinitionString

	| stream |
	stream := WriteStreamPortable on: (String new: 100).
	stream
		nextPut: $(;
		nextPutAll: superclassName;
		space;
		nextPutAll: self classCreationSelector;
		space;
		nextPutAll: self name printString.
	self subclassType = 'byteSubclass'
		ifFalse: 
			[stream
				lf;
				tab;
				nextPutAll: 'instVarNames: #(' , self instanceVariablesString , ')'].
	stream
		lf;
		tab;
		nextPutAll: 'classVars: #(' , self classVariablesString , ')';
		lf;
		tab;
		nextPutAll: 'classInstVars: #(' , self classInstanceVariablesString , ')';
		lf;
		tab;
		nextPutAll: 'poolDictionaries: #(' , self poolDictionariesString , ')';
		lf;
		tab;
		nextPutAll: 'inDictionary: ''<not-defined>''';
		nextPut: $);
		lf;
		tab;
		tab;
		nextPutAll: 'category: ' , self category printString , ';';
		lf;
		tab;
		tab;
		nextPutAll: 'comment: ' , self comment printString.
	^stream contents
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
commentStamp

	^ ''
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
createOrReviseClass

	^ self subclassType = ''
		ifTrue: [ self createOrReviseRegularClass ]
		ifFalse: [ 
			self subclassType = 'byteSubclass'
				ifTrue: [ self createOrReviseByteClass ]
				ifFalse: [ 
					| typ |
					typ := self subclassType.
					(typ = 'indexableSubclass' or: [ typ = 'variable' ])
						ifTrue: [ self createOrReviseIndexableClass ]
						ifFalse: [ self error: 'unknown subclass type: ' , self subclassType printString ] ] ]
%

category: '*cypress-environmental-tools'
method: CypressClassDefinition
createOrReviseClass: aSymbolDictionaryName environmentLoader: environmentLoader
  ^ self subclassType = ''
    ifTrue: [ 
      self
        createOrReviseRegularClass: aSymbolDictionaryName
        environmentLoader: environmentLoader ]
    ifFalse: [ 
      self subclassType = 'byteSubclass'
        ifTrue: [ 
          self
            createOrReviseByteClass: aSymbolDictionaryName
            environmentLoader: environmentLoader ]
        ifFalse: [ 
          self subclassType = 'indexableSubclass'
            ifTrue: [ 
              self
                createOrReviseIndexableClass: aSymbolDictionaryName
                environmentLoader: environmentLoader ]
            ifFalse: [ self error: 'unknown subclass type: ' , self subclassType printString ] ] ]
%

category: '*cypress-environmental-tools'
method: CypressClassDefinition
createOrReviseRegularClass: aSymbolDictionaryName environmentLoader: environmentLoader
  "To be resolved:
		- the question of an 'environment' in which to create the class.
		- the question of which SymbolDictionary in which to create the class.
	 These are perhaps the same question."

  | superClass lookupSymbolList |
  lookupSymbolList := environmentLoader lookupSymbolList.
  superClass := (lookupSymbolList resolveSymbol: self superclassName) value.
  ^ (superClass
    subclass: self name
    instVarNames: (self instVarNames collect: [ :each | each asSymbol ])
    classVars: (self classVarNames collect: [ :each | each asSymbol ])
    classInstVars: (self classInstVarNames collect: [ :each | each asSymbol ])
    poolDictionaries: #()
    inDictionary:
      ((self symbolDictionaryForClassNamed: self name symbolList: lookupSymbolList)
        ifNil: [ (lookupSymbolList resolveSymbol: aSymbolDictionaryName) value ])
    options: #())
    category: category;
    comment: self comment
%

category: '*rowan-tools-kernel'
method: CypressClassDefinition
definitionString

	| classType type |
	type := self subclassType.
	type = ''
		ifTrue: [ classType := 'normal' ]
		ifFalse: [ 
			(type = 'indexableSubclass' or: [ type = 'variable' ])
				ifTrue: [ classType := 'variable' ]
				ifFalse: [ 
					type = 'byteSubclass'
						ifTrue: [ classType := 'bytes' ]
						ifFalse: [ self error: 'unknown subclass type: ' , type ] ] ].
	^ Rowan projectTools browser
		classCreationTemplateForSubclassOf: superclassName
		className: self name printString
		type: classType
		instanceVariablesString: self instanceVariablesString
		classVariablesString: self classVariablesString
		classInstanceVariablesString: self classInstanceVariablesString
		poolDictionariesString: self poolDictionariesString
		comment: self comment printString
		category: self category printString
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
hasClassInstanceVariables

	^ self classInstVarNames isEmpty not
%

category: '*cypresstonel-core'
method: CypressClassDefinition
hasClassTraitComposition

	^false
%

category: '*cypresstonel-core'
method: CypressClassDefinition
hasComment
  ^ comment notNil and: [ comment ~= '' ]
%

category: '*cypresstonel-core'
method: CypressClassDefinition
hasTraitComposition

	^false
%

category: '*cypresstonel-core'
method: CypressClassDefinition
isClassDefinition
  ^ true
%

category: '*cypress-environmental-tools'
method: CypressClassDefinition
loadClassDefinition: aSymbolDictionaryName environmentLoader: environmentLoader
  "Create a new version of the defined class. If the class already exists,
	 copy the behaviors and state from the old version."

  | newClass oldClass lookupSymbolList |
  lookupSymbolList := environmentLoader lookupSymbolList.
  self defaultSymbolDictionaryName: aSymbolDictionaryName.
  (lookupSymbolList resolveSymbol: self name)
    ifNotNil: [ :assoc | oldClass := assoc value ].
  newClass := self
    createOrReviseClass: aSymbolDictionaryName
    environmentLoader: environmentLoader.
  (oldClass isNil or: [ newClass == oldClass ])
    ifTrue: [ ^ self ].
  self classNeedingMigration: newClass.
  self
    recompileWithSubclassesFrom: oldClass
    to: newClass
    symbolList: lookupSymbolList 
%

category: '*cypresstonel-core'
method: CypressClassDefinition
poolDictionaries

	^self poolDictionaryNames
%

category: '*rowan-cypress-kernel'
method: CypressClassDefinition
printDefinitionOn: stream

        stream
            nextPutAll: self superclassName;
            space;
            nextPutAll: self classCreationSelector;
            nextPut: $# ;
            nextPutAll: self className;
            cr; tab.
        stream
            nextPutAll: 'instanceVariableNames: ';
            store: self instanceVariablesString;
            cr; tab;
            nextPutAll: 'classVariableNames: ';
            store: self classVariablesString;
            cr; tab;
            nextPutAll: 'poolDictionaries: ';
            store: self poolDictionariesString;
            cr; tab;
            nextPutAll: 'category: ';
            store: self category asString 
%

category: '*cypresstonel-core'
method: CypressClassDefinition
sortKey
	^ self className
%

category: '*cypress-environmental-tools'
method: CypressClassDefinition
symbolDictionaryForClassNamed: aString symbolList: aSymbolList
  "Answer the SymbolDictionary containing the named class.
	 If there are multiple answers, answer the first.
	 If there are no answers (i.e., the class does not exist), answer
	 the result of evaluating aBlock."

  ^ aSymbolList asArray detect: [ :each | each
        anySatisfy: [ :every | every isBehavior and: [ every name asString = aString asString ] ] ]
  ifNone: [  ]
%

category: '*cypresstonel-core'
method: CypressClassDefinition
type
  | st |
  st := self subclassType.
  st = ''
    ifTrue: [ ^ #'normal' ].
  ^ st
%

! Class extensions for 'CypressClassStructure'

!		Instance methods for 'CypressClassStructure'

category: '*Cypress-MesssageDigest'
method: CypressClassStructure
addToDigest: aMessageDigestStream

	aMessageDigestStream
		tab;
		tab;
		nextPutAll: self class name;
		cr;
		tab;
		tab;
		tab;
		nextPutAll: 'extension:';
		nextPutAll: self isClassExtension printString;
		cr;
		tab;
		tab;
		tab;
		nextPutAll: 'comment:';
		nextPutAll: self comment;
		cr;
		tab;
		tab;
		tab;
		nextPutAll: 'properties:';
		cr;
		tab;
		tab;
		tab;
		tab.
	self properties _writeCypressJsonOn: aMessageDigestStream indent: 4.
	aMessageDigestStream
		cr;
		tab;
		tab;
		tab;
		nextPutAll: 'class methods:';
		cr.
	(self classMethods asSortedCollection: 
			[:a :b |
			(a isMetaclass printString , a selector)
				< (b isMetaclass printString , b selector)])
		do: [:each | each addToDigest: aMessageDigestStream].
	aMessageDigestStream
		tab;
		tab;
		tab;
		nextPutAll: 'instance methods:';
		cr.
	(self instanceMethods asSortedCollection: 
			[:a :b |
			(a isMetaclass printString , a selector)
				< (b isMetaclass printString , b selector)])
		do: [:each | each addToDigest: aMessageDigestStream]
%

category: '*Cypress-MesssageDigest'
method: CypressClassStructure
isSkeleton

	^instanceMethods isNil
		and: [classMethods isNil
		and: [comment isNil
		and: [isClassExtension isNil]]]
%

! Class extensions for 'CypressDefinition'

!		Instance methods for 'CypressDefinition'

category: '*cypresstonel-core'
method: CypressDefinition
<= other
	^ self sortKey <= other sortKey
%

category: '*cypresstonel-core'
method: CypressDefinition
isClassDefinition
  ^ false
%

category: '*cypresstonel-core'
method: CypressDefinition
isMethodDefinition
  ^ false
%

category: '*rowan-tools-kernel'
method: CypressDefinition
isOrganizationDefinition
  ^false
%

category: '*cypresstonel-core'
method: CypressDefinition
isTraitDefinition
  ^ false
%

category: '*cypress-environmental-tools'
method: CypressDefinition
loadClassDefinition: aSymbolDictionaryName environmentLoader: environmentLoader
  "default is to do nothing"

%

category: '*cypress-environmental-tools'
method: CypressDefinition
loadMethodDefinition: lookupSymbolList environmentLoader: environmentLoader
  "default is to do nothing"

%

category: '*cypress-environmental-tools'
method: CypressDefinition
postLoad: lookupSymbolList environmentId: environmentId
  "noop"

%

category: '*cypress-environmental-tools'
method: CypressDefinition
postLoadOver: aDefinition lookupSymbolList: lookupSymbolList environmentId: environmentId
  self postLoad: lookupSymbolList environmentId: environmentId
%

category: '*cypresstonel-core'
method: CypressDefinition
sortKey
	self subclassResponsibility
%

! Class extensions for 'CypressGemStoneDirectoryUtilities'

!		Class methods for 'CypressGemStoneDirectoryUtilities'

category: '*cypresstonel-core'
classmethod: CypressGemStoneDirectoryUtilities
default
  ^ self workingDirectory
%

category: '*cypresstonel-core'
classmethod: CypressGemStoneDirectoryUtilities
entryNamesFrom: aDirectory
  "Answer just the name of the contents of aDirectory."

  ^ (((self directoryEntriesFrom: aDirectory)
    collect: [ :each | self localNameFrom: each ])
    reject: [ :each | each = '.' or: [ each = '..' ] ])
    sortWithBlock: [ :a :b | a <= b ]
%

! Class extensions for 'CypressHierarchicalUrl'

!		Instance methods for 'CypressHierarchicalUrl'

category: '*rowan-url-3215'
method: CypressHierarchicalUrl
segments
	^ path
%

! Class extensions for 'CypressMethodDefinition'

!		Instance methods for 'CypressMethodDefinition'

category: '*rowan-cypress-kernel'
method: CypressMethodDefinition
accept: aVisitor
	^ aVisitor visitMethodDefinition: self
%

category: '*cypresstonel-core'
method: CypressMethodDefinition
fullClassName
	
	^ self classIsMeta
		ifFalse: [self className]
		ifTrue: [ self className, ' class' ]
%

category: '*cypresstonel-core'
method: CypressMethodDefinition
isExtensionMethod
	^ category beginsWith: '*'
%

category: '*cypresstonel-core'
method: CypressMethodDefinition
isMethodDefinition
  ^ true
%

category: '*cypress-environmental-tools'
method: CypressMethodDefinition
loadMethodDefinition: lookupSymbolList environmentLoader: environmentLoader
  | cls actualCls |
  cls := (lookupSymbolList resolveSymbol: self className) value.
  actualCls := self classIsMeta
    ifTrue: [ cls class ]
    ifFalse: [ cls ].
  actualCls
    compileMethod: self source
    dictionaries: environmentLoader compilationSymbolList
    category: self category
    environmentId: environmentLoader defaultEnvironmentId
%

category: '*cypress-environmental-tools'
method: CypressMethodDefinition
postLoadOver: aDefinition lookupSymbolList: lookupSymbolList environmentId: environmentId
  super
    postLoadOver: aDefinition
    lookupSymbolList: lookupSymbolList
    environmentId: environmentId.
  (self isInitializer
    and: [ aDefinition isNil or: [ self source ~= aDefinition source ] ])
    ifTrue: [ 
      (self theNonMetaClass: lookupSymbolList)
        perform: #'initialize'
        env: environmentId ]
%

category: '*cypresstonel-core'
method: CypressMethodDefinition
sortKey
	^ self className, '.', (self classIsMeta ifTrue: ['meta'] ifFalse: ['nonmeta']), '.', self selector
%

category: '*cypress-environmental-tools'
method: CypressMethodDefinition
theNonMetaClass: lookupSymbolList
  ^ self
    resolveGlobalNamed: self className
    lookupSymbolList: lookupSymbolList
    or: [  ]
%

category: '*rowan-tools-kernel'
method: CypressMethodDefinition
timeStamp

	"fake out a timeStamp for GsJade package changes browser... should not end up being 
		displayed in chagnes browser, but transport layer expects a timeStamp at the moment"

	^ 'dkh 3/29/2018 14:21'
%

! Class extensions for 'CypressMethodStructure'

!		Instance methods for 'CypressMethodStructure'

category: '*Cypress-MesssageDigest'
method: CypressMethodStructure
addToDigest: aMessageDigestStream

	aMessageDigestStream
		tab;
		tab;
		tab;
		tab;
		nextPutAll: self class name;
		cr;
		tab;
		tab;
		tab;
		tab;
		tab;
		nextPutAll: self selector;
		cr;
		tab;
		tab;
		tab;
		tab;
		tab;
		nextPutAll: 'properties:';
		cr;
		tab;
		tab;
		tab;
		tab;
		tab;
		tab.
	self properties _writeCypressJsonOn: aMessageDigestStream indent: 6.
	aMessageDigestStream
		cr;
		tab;
		tab;
		tab;
		tab;
		nextPutAll: 'source:';
		nextPutAll: self source;
		cr
%

category: '*Cypress-MesssageDigest'
method: CypressMethodStructure
isSkeleton

	^source isNil
		and: [classStructure isNil
		and: [isMetaclass isNil]]
%

! Class extensions for 'CypressModification'

!		Instance methods for 'CypressModification'

category: '*rowan-cypress-kernel'
method: CypressModification
isModification
  ^ true
%

category: '*cypress-environmental-tools'
method: CypressModification
loadClassDefinition: aSymbolDictionaryName environmentLoader: environmentLoader
  self modification
    loadClassDefinition: aSymbolDictionaryName
    environmentLoader: environmentLoader
%

category: '*cypress-environmental-tools'
method: CypressModification
loadMethodDefinition: lookupSymbolList environmentLoader: environmentLoader
  self modification
    loadMethodDefinition: lookupSymbolList
    environmentLoader: environmentLoader
%

category: '*cypress-environmental-tools'
method: CypressModification
postLoadDefinition: lookupSymbolList environmentId: environmentId
  self modification
    postLoadOver: self obsoletion
    lookupSymbolList: lookupSymbolList
    environmentId: environmentId
%

! Class extensions for 'CypressObject'

!		Instance methods for 'CypressObject'

category: '*cypress-environmental-tools'
method: CypressObject
resolveGlobalNamed: aString lookupSymbolList: lookupSymbolList or: aBlock
  ^ ((lookupSymbolList resolveSymbol: aString) ifNil: [ ^ aBlock value ]) value
%

! Class extensions for 'CypressPackageManager'

!		Instance methods for 'CypressPackageManager'

category: '*Cypress-Comparison'
method: CypressPackageManager
comparePackagesFrom: someCypressPackageInformations

	| packageNames savedLocation comparator |
	packageNames := someCypressPackageInformations collect: 
					[:each |
					savedLocation := each savedLocation.
					each name].
	comparator := CypressPackageComparator new.
	comparator comparingPackages: packageNames fromDirectory: savedLocation.
	^comparator getDifferences
%

! Class extensions for 'CypressPackageStructure'

!		Instance methods for 'CypressPackageStructure'

category: '*Cypress-MesssageDigest'
method: CypressPackageStructure
addToDigest: aMessageDigestStream

	aMessageDigestStream
		nextPutAll: self class name;
		cr;
		tab;
		nextPutAll: 'name:';
		nextPutAll: self name;
		cr;
		tab;
		nextPutAll: 'properties:';
		cr;
		tab;
		tab.
	self properties _writeCypressJsonOn: aMessageDigestStream indent: 2.
	aMessageDigestStream
		cr;
		tab;
		nextPutAll: 'classes:';
		cr.
	(self classes asSortedCollection: [:a :b | a name < b name])
		do: [:each | each addToDigest: aMessageDigestStream].
	aMessageDigestStream
		tab;
		nextPutAll: 'extensions:';
		cr.
	(self extensions asSortedCollection: [:a :b | a name < b name])
		do: [:each | each addToDigest: aMessageDigestStream]
%

category: '*Cypress-MesssageDigest'
method: CypressPackageStructure
isSkeleton

	^(properties isNil or: [properties isEmpty])
		and: [classes isNil
		and: [extensions isNil]]
%

! Class extensions for 'CypressPatchOperation'

!		Instance methods for 'CypressPatchOperation'

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
<= other
	^ self definition <= other definition
%

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
isAddition
	^ false
%

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
isModification
	^ false
%

category: '*rowan-cypress-kernel'
method: CypressPatchOperation
isRemoval
	^ false
%

! Class extensions for 'CypressRemoval'

!		Instance methods for 'CypressRemoval'

category: '*rowan-cypress-kernel'
method: CypressRemoval
isRemoval
  ^ true
%

category: '*cypress-environmental-tools'
method: CypressRemoval
loadClassDefinition: aSymbolDictionaryName environmentLoader: environmentLoader
  CypressError
    signal:
      'inappropriate to send #loadClassDefinition:environmentLoader: to a removal operation'
%

category: '*cypress-environmental-tools'
method: CypressRemoval
loadMethodDefinition: lookupSymbolList environmentLoader: environmentLoader
  CypressError
    signal:
      'inappropriate to send #loadMethodDefinition:environmentLoader: to a removal operation'
%

category: '*cypress-environmental-tools'
method: CypressRemoval
postLoadDefinition: lookupSymbolList environmentId: environmentId
  CypressError
    signal:
      'inappropriate to send #postLoadDefinition:environmentId: to a removal operation'
%

! Class extensions for 'CypressSnapshot'

!		Instance methods for 'CypressSnapshot'

category: '*cypresstonel-core'
method: CypressSnapshot
snapshot
  ^ self
%

! Class extensions for 'CypressStructure'

!		Instance methods for 'CypressStructure'

category: '*Cypress-MesssageDigest'
method: CypressStructure
addToDigest: aMessageDigestStream

	self subclassResponsibility: #addToDigest:
%

category: '*Cypress-MesssageDigest'
method: CypressStructure
digest
	"Answer a digest of the receiver, unless it is a skeleton (never populated).
	 The digest is not constrained, but is typically a ByteArray or an Integer.
	 In the case of a skeleton, answer nil so there is a distinction between
	 no such package and an empty package."

	| stream |
	self isSkeleton ifTrue: [^nil].
	stream := CypressMessageDigestStream characters.
	self addToDigest: stream.
	^stream md5sum
%

category: '*Cypress-MesssageDigest'
method: CypressStructure
isSkeleton

	^self subclassResponsibility: #isSkeleton
%

! Class extensions for 'CypressTonelRepository'

!		Instance methods for 'CypressTonelRepository'

category: '*rowan-cypress-kernel'
method: CypressTonelRepository
packageNames

	"only directories with a package.st file in them"

	| utils |
	utils := self fileUtils.
	^ (((utils directoryEntriesFrom: self directoryPath , '*')
		reject: [ :each | 
			| aGsFileStat |
			aGsFileStat := GsFile _stat: each isLstat: false.
			aGsFileStat _isSmallInteger
				ifTrue: [ false ]
				ifFalse: [ aGsFileStat isDirectory not ] ])
		collect: [ :each | utils localNameFrom: each ])
		reject: [ :each | each = '.' or: [ each = '..' ] ]
%

! Class extensions for 'Dictionary'

!		Instance methods for 'Dictionary'

category: '*Cypress-PackageManagement'
method: Dictionary
_writeCypressJsonOn: fileStream
	"Private method which may be removed in a future GemStone version."

	self _writeCypressJsonOn: fileStream indent: 0.
	fileStream lf
%

category: '*Cypress-PackageManagement'
method: Dictionary
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	| indent cnt |
	indent := startIndent.
	aStream
		nextPutAll: '{';
		lf.
	cnt := 0.
	indent := indent + 1.
	self keys asSortedCollection do: 
			[:key |
			| value |
			value := self at: key.
			cnt := cnt + 1.
			indent timesRepeat: [aStream tab].
			key _writeCypressJsonOn: aStream indent: indent.
			aStream nextPutAll: ' : '.
			value _writeCypressJsonOn: aStream indent: indent.
			cnt < self size
				ifTrue: 
					[aStream
						nextPutAll: ',';
						lf]].
	self size = 0 ifTrue: [indent timesRepeat: [aStream tab]].
	aStream nextPutAll: ' }'
%

! Class extensions for 'DoubleByteSymbol'

!		Instance methods for 'DoubleByteSymbol'

category: '*ast-kernel-core'
method: DoubleByteSymbol
rbStoreOn: aStream
  aStream nextPut: $#.
  super rbStoreOn: aStream
%

! Class extensions for 'GsFile'

!		Instance methods for 'GsFile'

category: '*tonel-gemstonecommon-core'
method: GsFile
<< items

 	items putOn: self.
	
	^ self
%

! Class extensions for 'GsNMethod'

!		Instance methods for 'GsNMethod'

category: '*rowan-gemstone-kernel'
method: GsNMethod
rowanPackageName

	"answer the name of the package that the receiver is a member of. Answer `Rowan unpackagedName` if 
		the receiver is not a member of any package"

	| loadedMethod |
	loadedMethod := Rowan image
		loadedMethodForMethod: self
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedMethod loadedPackage name
%

category: '*rowan-gemstone-kernel'
method: GsNMethod
rowanProjectName

	"answer the name of the project that the receiver is a member of. Answer `Rowan unpackagedName` if 
		the receiver is not a member of any project"

	| loadedMethod |
	loadedMethod := Rowan image
		loadedMethodForMethod: self
		ifAbsent: [ ^ Rowan unpackagedName ].
	^ loadedMethod loadedProject name
%

! Class extensions for 'Integer'

!		Class methods for 'Integer'

category: '*ast-kernel-core'
classmethod: Integer
_rwFinishFromStream: aStream signFound: aSignFound factor: aFactor radix: radix
  "BinaryExponent = ( 'e' | 'E' | 'd' | 'D' | 'q' ) ['-' | '+'] Digits
   DecimalExponent = ( 'f' | 'F' ) ['-' | '+'] Digits
   Digit = '0' | '1' | '2' | ... | '9'
   Digits = Digit {Digit}
   Exponent = BinaryExponent | DecimalExponent | ScaledDecimalExponent | FixedPointExponent
   FractionalPart = '.' Digits [Exponent]
   FixedPointExponent = 'p' [ ['-' | '+'] Digits ] 
   Number = RadixedLiteral | NumericLiteral
   Numeric = Digit | 'A' | 'B' | ... | 'Z'
   NumericLiteral = Digits ( [FractionalPart] | [Exponent] )
   Numerics = Numeric { Numeric }
   RadixedLiteral = Digits ( '#' | 'r' ) ['-'] Numerics
   ScaledDecimalExponent = 's' [ ['-' | '+'] Digits ]
"
  "parse Numerics (plus option sign) for RadixedLiteral"

  | number ch signFound factor |
  signFound := aSignFound.
  factor := aFactor.
  number := 0.
  (aStream peek isEquivalent: $-)
    ifTrue: [ 
      signFound
        ifTrue: [ ^ self _errIncorrectFormat: aStream ].
      aStream next.
      signFound := true.
      factor := -1 ]
    ifFalse: [ 
      (aStream peek isEquivalent: $+)
        ifTrue: [ 
          signFound
            ifTrue: [ ^ self _errIncorrectFormat: aStream ].
          aStream next.
          signFound := true ] ].
  [ aStream atEnd not and: [ | peekCh | peekCh := aStream peek. radix <= 10 ifTrue: [ peekCh isDigit ] ifFalse: [ peekCh isAlphaNumeric ] ] ]
    whileTrue: [ 
      ch := aStream next.
      number := number * radix + (ch digitValueInRadix: radix) ].
  ^ number * factor
%

!		Instance methods for 'Integer'

category: '*rowan-gemstone-kernel'
method: Integer
rwSemanticIntegerLessThanSelf: anInteger

	^ anInteger < self
%

category: '*rowan-gemstone-kernel'
method: Integer
rwSemanticStringLessThanSelf:  aString
  "integers have greater precedence than strings"
	" aString < anInteger -> false"

  ^ false
%

category: '*rowan-gemstone-kernel'
method: Integer
rwSemanticVersionComponentLessThan: aRwSemanticVersonComponent

	^ aRwSemanticVersonComponent rwSemanticIntegerLessThanSelf: self
%

! Class extensions for 'Interval'

!		Class methods for 'Interval'

category: '*Rowan-GemStone-Kernel'
classmethod: Interval
fromSton: stonReader
	| result values |
	values := OrderedCollection new.
	stonReader parseMapDo: [:key :value | values add: value].
	values size = 2 ifTrue: [result := self from: values first to: values second].
	values size = 3 ifTrue: [result := self from: values first to: values second by: values third].
	^result
%

!		Instance methods for 'Interval'

category: '*Rowan-GemStone-Kernel'
method: Interval
stonOn: stonWriter
  stonWriter
    writeObject: self
    streamMap: [ :dictionary | 
      dictionary
        at: #'start' put: from;
        at: #'stop' put: to;
        at: #'step' put: by ]
%

! Class extensions for 'Number'

!		Class methods for 'Number'

category: '*ast-kernel-core'
classmethod: Number
rwFromStream: aStream
  "BinaryExponent = ( 'e' | 'E' | 'd' | 'D'  'q' | 'Q') ['-' | '+'] Digits
   DecimalExponent = ( 'f' | 'F' ) ['-' | '+'] Digits
   Digit = '0' | '1' | '2' | ... | '9'
   Digits = Digit {Digit}
   Exponent = BinaryExponent | DecimalExponent | ScaledDecimalExponent | FixedPointExponent
   FractionalPart = '.' Digits [Exponent]
   FixedPointExponent = 'p' [ ['-' | '+'] Digits ] 
   Number = RadixedLiteral | NumericLiteral
   Numeric = Digit | 'A' | 'B' | ... | 'Z'
   NumericLiteral = Digits ( [FractionalPart] | [Exponent] )
   Numerics = Numeric { Numeric }
   RadixedLiteral = Digits ( '#' | 'r' ) ['-'] Numerics
   ScaledDecimalExponent = 's' [ ['-' | '+'] Digits ]
"
  | ch integerPart factor signFound |
  self _checkReadStream: aStream forClass: CharacterCollection.
  ch := aStream next.
  [ ch unicodeIsWhitespace] whileTrue: [ ch := aStream next ].
  aStream skip: -1.
  integerPart := 0.
  factor := 1.
  signFound := false.
  (aStream peek isEquivalent: $-)
    ifTrue: [ 
      aStream next.
      signFound := true.
      factor := -1 ]
    ifFalse: [ 
      (aStream peek isEquivalent: $+)
        ifTrue: [ 
          aStream next.
          signFound := true ] ].
  (aStream atEnd or: [ aStream peek isDigit not ])
    ifTrue: [ ^ self _errIncorrectFormat: aStream ].
  [ aStream atEnd not and: [ (ch := aStream peek) isDigit ] ]
    whileTrue: [ 
      aStream next.
      integerPart := integerPart * 10 + ch digitValue ].

  (ch == $r or: [ ch == $# ])
    ifTrue: [ 
      "found a radix separator"
      aStream next.
      ^ Integer
        _rwFinishFromStream: aStream
        signFound: signFound
        factor: factor
        radix: integerPart ].
  (ch isEquivalent: (Locale decimalPoint at: 1))
    ifTrue: [ 
      | chch |
		chch := aStream peek2. ".?"
		chch notNil
			ifTrue: [
				"not at eof"
				chch isDigit 
					ifFalse: [
						"we're done"
						^ integerPart * factor ] ].
	  "found a decimal point, followed by a numeric character."
      aStream next.
      ^ BinaryFloat
        _finishFromStream: aStream
        signFound: signFound
        factor: factor
        integerPart: integerPart ].
  (#( $e $E $d $D $q $s $p $f $F ) includesIdentical: ch) ifTrue:[ 
      aStream next.
      ^ BinaryFloat
        _finishFromStream: aStream
        signFound: signFound
        factor: factor
        integerPart: integerPart
        fractionalPart: 0
        exponent: ch ].
  ^ integerPart * factor
%

!		Instance methods for 'Number'

category: '*ast-kernel-core'
method: Number
rbStoreOn: aStream
  self printOn: aStream
%

category: '*Cypress-PackageManagement'
method: Number
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	aStream nextPutAll: self printString
%

! Class extensions for 'Object'

!		Instance methods for 'Object'

category: '*gemstone-interactions-kernel'
method: Object
confirm: aString
  ^ (GsConfirmInteraction prompt: aString) signal
%

category: '*gemstone-interactions-kernel'
method: Object
inform: aString
  "Display aString to the user."

  ^ (GsInformInteraction message: aString) signal
%

category: '*gemstone-interactions-kernel'
method: Object
inspect
  ^ (GsInspectInteraction theObject: self) signal
%

category: '*tonel-gemstone-kernel'
method: Object
isCollection

	"Return true if the receiver is some sort of Collection and responds to basic collection messages such as #size and #do:"

	^ false
%

category: '*tonel-gemstone-kernel'
method: Object
putOn: aStream

	^ aStream nextPut: self
%

category: '*rowan-gemstone-kernel'
method: Object
rwPlatformAttributeMatchForGemStoneVersion: anRwGemStoneVersionConfigurationPlatformAttributeMatcher
  ^ self
    error: 'Expected a String or a RwGemStoneVersion'
%

category: '*rowan-gemstone-kernel'
method: Object
rwPlatformAttributeMatchForString: anRwStringConfigurationPlatformAttributeMatcher
  ^ self
    error: 'Expected a String or a RwGemStoneVersion'
%

category: '*rowan-gemstone-kernel'
method: Object
rwSemanticIntegerLessThanSelf: anInteger
  ^ self
    error: 'Invalid semantic verson component - should be an Integer.'
%

category: '*rowan-gemstone-kernel'
method: Object
rwSemanticStringLessThanSelf: aString
  ^ self
    error: 'Invalid semantic verson component - should be String.'
%

category: '*rowan-gemstone-kernel'
method: Object
rwSemanticVersionComponentLessThan: aRwSemanticVersonComponent
  ^ self
    error: 'Invalid semantic verson component - should be String or Integer.'
%

category: '*ast-kernel-core'
method: Object
value

	^self
%

category: '*Cypress-PackageManagement'
method: Object
_writeCypressJsonOn: fileStream
	"Private method which may be removed in a future GemStone version."

	self _writeCypressJsonOn: fileStream indent: 0
%

! Class extensions for 'PositionableStreamPortable'

!		Instance methods for 'PositionableStreamPortable'

category: '*tonel-gemstonecommon-core'
method: PositionableStreamPortable
match: subCollection
  "Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."

  | pattern startMatch |
  pattern := ReadStreamPortable on: subCollection.
  startMatch := nil.
  [ pattern atEnd ]
    whileFalse: [ 
      self atEnd
        ifTrue: [ ^ false ].
      self next = pattern next
        ifTrue: [ 
          pattern position = 1
            ifTrue: [ startMatch := self position ] ]
        ifFalse: [ 
          pattern position: 0.
          startMatch
            ifNotNil: [ 
              self position: startMatch.
              startMatch := nil ] ] ].
  ^ true
%

category: '*tonel-gemstonecommon-core'
method: PositionableStreamPortable
originalContents
	"Answer the receiver's actual contents collection, NOT a copy.  1/29/96 sw"

	^ collection
%

! Class extensions for 'QuadByteSymbol'

!		Instance methods for 'QuadByteSymbol'

category: '*ast-kernel-core'
method: QuadByteSymbol
rbStoreOn: aStream
  aStream nextPut: $#.
  super rbStoreOn: aStream
%

! Class extensions for 'Rowan'

!		Class methods for 'Rowan'

category: '*rowan-gemstone-core'
classmethod: Rowan
clearGlobalAutomaticClassInitializationBlackList

	"Clear global list of project names for which automatic class initialiation should be disabled.
		user black list only applies to current user."

	^ self platform clearAutomaticClassInitializationBlackList_global
%

category: '*rowan-gemstone-core'
classmethod: Rowan
clearSessionAutomaticClassInitializationBlackList

	"Clear session list of project names for which automatic class initialiation should be disabled.
		Session black list only active for duration of GemStone session."

	^ self platform clearAutomaticClassInitializationBlackList_session
%

category: '*rowan-gemstone-core'
classmethod: Rowan
clearUserAutomaticClassInitializationBlackList

	"Clear user list of project names for which automatic class initialiation should be disabled.
		user black list only applies to current user."

	^ self platform clearAutomaticClassInitializationBlackList_user
%

category: '*rowan-gemstone-core'
classmethod: Rowan
globalAutomaticClassInitializationBlackList

	"Answer global list of project names for which automatic class initialiation should be disabled.
		Session black list only active for duration of GemStone session."

	^ self platform automaticClassInitializationBlackList_global
%

category: '*rowan-core'
classmethod: Rowan
initialize

	"Rowan initialize."

	configuration := self platform defaultConfiguration.
	self platform initialize
%

category: '*rowan-gemstone-core'
classmethod: Rowan
sessionAutomaticClassInitializationBlackList

	"Answer session list of project names for which automatic class initialiation should be disabled.
		Session black list only active for duration of GemStone session."

	^ self platform automaticClassInitializationBlackList_session
%

category: '*rowan-gemstone-core'
classmethod: Rowan
userAutomaticClassInitializationBlackList

	"Answer user list of project names for which automatic class initialiation should be disabled.
		user black list only applies to current user."

	^ self platform automaticClassInitializationBlackList_user
%

! Class extensions for 'RowanInterface'

!		Instance methods for 'RowanInterface'

category: '*rowan-gemstone-core'
method: RowanInterface
_gemstonePlatformSpec

	^ self _specification platformSpec at: 'gemstone'
%

! Class extensions for 'RwAbstractClassDefinition'

!		Instance methods for 'RwAbstractClassDefinition'

category: '*rowan-gemstone-definitions'
method: RwAbstractClassDefinition
modificationForcingNewVersion

	^ self _modificationForcingNewClassVersion before: self after: self
%

category: '*rowan-cypress-definitions'
method: RwAbstractClassDefinition
name
  ^ self key
%

! Class extensions for 'RwClassDefinition'

!		Class methods for 'RwClassDefinition'

category: '*rowan-cypress-definitions'
classmethod: RwClassDefinition
fromCypressClassStructure: aCypressClassStructure
  ^ self new
    fromCypressClassStructure: aCypressClassStructure;
    yourself
%

!		Instance methods for 'RwClassDefinition'

category: '*rowan-cypress-definitions'
method: RwClassDefinition
category

	^ properties at: 'category' ifAbsent: [  ]
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
category: aString

	^ properties at: 'category' put: aString
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
classInstVarNames
  ^ properties at: 'classinstvars'
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
classInstVarNames: anArray

	^ properties at: 'classinstvars' put: anArray
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
comment
  ^ properties at: 'comment' ifAbsent: ['']
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
compareAgainstBaseForcingNewClassVersion: aDefinition

	"all unchanged and unremoved methods need to be applied to the patch"

	| modification instanceMethodsModification classMethodsModification |
	modification := self _modificationForcingNewClassVersion
		before: aDefinition
		after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	instanceMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	classMethodsModification := self _methodsModificationClass
		extendedClassName: self key.
	self
		compareDictionary: instanceMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition instanceMethodDefinitions
		into: instanceMethodsModification
		elementClass: RwMethodDefinition
		isMeta: false.
	self
		compareDictionary: classMethodDefinitions
		againstBaseDictionaryForNewClassVersion: aDefinition classMethodDefinitions
		into: classMethodsModification
		elementClass: RwMethodDefinition
		isMeta: true.
	modification
		instanceMethodsModification: instanceMethodsModification;
		classMethodsModification: classMethodsModification.
	^ modification
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
fromCypressClassStructure: aCypressClassStructure

	properties
		at: 'category' put: aCypressClassStructure category;
		at: 'classinstvars' put: aCypressClassStructure classInstanceVariableNames;
		at: 'classvars' put: aCypressClassStructure classVariableNames;
		yourself.
	aCypressClassStructure comment ifNotNil: [ :cmt | properties at: 'comment' put: cmt ].
	aCypressClassStructure gs_options isEmpty ifFalse: [ properties at: 'gs_options' put: aCypressClassStructure gs_options ].
	aCypressClassStructure gs_constraints isEmpty ifFalse: [ properties at: 'gs_constraints' put: aCypressClassStructure gs_constraints ].
	properties
		at: 'instvars' put: aCypressClassStructure instanceVariableNames;
		at: 'name' put: aCypressClassStructure className;
		at: 'pools' put: aCypressClassStructure poolDictionaryNames;
		at: 'superclass' put: aCypressClassStructure superclassName;
		yourself.
	aCypressClassStructure subclassType isEmpty
		ifTrue: [ properties at: 'type' put: 'normal' ]
		ifFalse: [ properties at: 'type' put: aCypressClassStructure subclassType asString ].
	aCypressClassStructure instanceMethods
		do: [ :cypMethodDef | 
			self
				addInstanceMethodDefinition:
					(RwMethodDefinition fromCypressMethod: cypMethodDef) ].
	aCypressClassStructure classMethods
		do: [ :cypMethodDef | 
			self
				addClassMethodDefinition:
					(RwMethodDefinition fromCypressMethod: cypMethodDef) ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_constraints

	^self properties
				at: 'gs_constraints'
				ifAbsent: [ #() ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_constraints: constraintsArray

	(constraintsArray _isArray and: [ constraintsArray isEmpty not ])
		ifTrue: [ 
			self properties
				at: 'gs_constraints'
				put: constraintsArray ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_options

	^self properties
				at: 'gs_options'
				ifAbsent: [ #() ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_options: optionsArray

	(optionsArray _isArray and: [ optionsArray isEmpty not ])
		ifTrue: [ 
			self properties
				at: 'gs_options'
				put:
					(optionsArray collect: [ :each | each asString ]) asSortedCollection asArray ]
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_symbolDictionary

	^ self properties
		at: 'gs_SymbolDictionary'
		ifAbsent: []
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
gs_symbolDictionary: aSymbolDictionaryName

	self properties
		at: 'gs_SymbolDictionary'
		put: aSymbolDictionaryName asString
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
poolDictionaryNames
  ^ properties at: 'pools'
%

category: '*rowan-cypress-definitions'
method: RwClassDefinition
subclassType
  | type |
  type := properties at: 'type'.
  type = 'normal'
    ifTrue: [ ^ '' ].
  ^ type
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue

	propertyKey = 'comment' ifFalse: [ ^super _compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue ].
	propertyValue = baseValue
		ifTrue: [ ^ true ]
		ifFalse: [ 
			"empty or nil comments need to compare equal in GemStone"
			^(propertyValue == nil or: [ propertyValue isEmpty]) and: [ baseValue == nil or: [ baseValue isEmpty] ] ]
%

category: '*rowan-core-definitions-extensions'
method: RwClassDefinition
_methodsModificationClass

	^ RwMethodsModification
%

category: '*rowan-core-definitions-extensions'
method: RwClassDefinition
_modificationClass

	^ RwClassModification
%

category: '*rowan-gemstone-definitions'
method: RwClassDefinition
_modificationForcingNewClassVersion

	^ RwClassModificationForcingNewClassVersion
%

! Class extensions for 'RwClassExtensionDefinition'

!		Instance methods for 'RwClassExtensionDefinition'

category: '*rowan-core-definitions-extensions'
method: RwClassExtensionDefinition
_methodsModificationClass

	^ RwExtensionMethodsModification
%

category: '*rowan-core-definitions-extensions'
method: RwClassExtensionDefinition
_modificationClass

	^ RwClassExtensionModification
%

! Class extensions for 'RwClassModification'

!		Instance methods for 'RwClassModification'

category: '*rowan-gemstone-loader-extensions'
method: RwClassModification
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	aPatchSet
		addClassModification: self 
		toPatchSetInPackage: aPackage 
		inProject: aProjectDefinition.
%

! Class extensions for 'RwClassModificationForcingNewClassVersion'

!		Instance methods for 'RwClassModificationForcingNewClassVersion'

category: '*rowan-gemstone-loader-extensions'
method: RwClassModificationForcingNewClassVersion
addModificationForcingNewClassVersionToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	aPatchSet
		addForcingNewClassVersionModification: self 
		toPatchSetInPackage: aPackage 
		inProject: aProjectDefinition
%

category: '*rowan-gemstone-loader-extensions'
method: RwClassModificationForcingNewClassVersion
addModificationToPatchSet: aPatchSet inPackage: aPackage inProject: aProjectDefinition

	self shouldNotImplement: #addModificationToPatchSet:inPackage:inProject:
%

! Class extensions for 'RwClassMove'

!		Instance methods for 'RwClassMove'

category: '*rowan-gemstone-loader-extensions'
method: RwClassMove
addMovedClassToPatchSet: aPatchSet

	aPatchSet addClassMove: self
%

! Class extensions for 'RwDefinition'

!		Instance methods for 'RwDefinition'

category: '*rowan-core-definitions-extensions'
method: RwDefinition
comparePropertiesAgainstBase: aDefinition

	| keys modification |
	modification := RwPropertiesModification new.
	keys := properties keys copy.
	keys addAll: aDefinition properties keys.
	keys do: 
			[:key |
				| before after |
				before := aDefinition propertyAt: key ifAbsent: [nil].
				after := self propertyAt: key ifAbsent: [nil].
				(self _compareProperty: key propertyVaue: before againstBaseValue: after)
					ifFalse: 
						[modification addElementModification: (RwPropertyModification
							key: key
							oldValue: before
							newValue: after)]].
	^modification
%

! Class extensions for 'RwFileUrl'

!		Instance methods for 'RwFileUrl'

category: '*rowan-url-extensions'
method: RwFileUrl
asConfiguration
  "Answer a concrete RwAbstractProjectConfiguration "

  ^ RwAbstractProjectConfiguration fromUrl: self
%

category: '*rowan-url-extensions'
method: RwFileUrl
asSpecification
  "Answer an RwSpecification "

  ^ RwSpecification fromUrl: self
%

! Class extensions for 'RwGsClassVersioningPatch'

!		Instance methods for 'RwGsClassVersioningPatch'

category: '*rowan-gemstone-loader-36x'
method: RwGsClassVersioningPatch
_newSubclassWithSuperclass: newSuperclass isEquivalentToSubclass: oldClass 
newOpts: optionsArray newFormat: theFormat newInstVars: anArrayOfInstvarNames newClassInstVars: anArrayOfClassInstVars 
newPools: anArrayOfPoolDicts newClassVars: anArrayOfClassVars newConstraints: aConstraint 
suprBlock: suprBlock optsBlock: optsBlock ivsBlock: ivsBlock civsBlock: civsBlock poolsBlock: poolsBlock cvarsBlock: cvarsBlock consBlock: consBlock

	" based on Class>>_equivalentSubclass:superCls:name:newOpts:newFormat:newInstVars:newClassInstVars:newPools:newClassVars:inDict:isKernel: and ultimately needs to be rolled back into base, so that class creation and Rowan use the same new class version rules.
"

	"Class>>_equivalentSubclass:... has unwanted side effects"

	"squeezed down to the bare minimum"

	"oldClass is equivalent to the subclass that would be created using
 the other arguments if 
     instVar names match exactly ,
   and class instVar names match exactly ,
   and the classVars in oldClass can be modified to add/remove Associations 
     to match anArrayOfClassVars ,
   and pool dictionaries match exactly

  With respect to options and format, oldClass is equivalent if
    The state of format bits dbTransient, instancesNonPersistent, instancesInvariant  
     match exactly ,
    and subclassesDisallowed cannot be set in the new subclass if it not set in oldClass ,
    and modifiable  cannot be set if it is not set in oldClass  ,
    and  (SELF_CAN_BE_SPECIAL, NSC_DUPLICATES, INDEXABLE, IMPLEMENTATION, NO_STRUCT_UPDATE bits)
        of the formats must match exactly.
"

	| fmtArr |
	fmtArr := newSuperclass 
		_validateOptions: optionsArray 
		withFormat: theFormat
		newClassName: oldClass name asString.
	(oldClass isKindOf: Class)
		ifFalse: [ oldClass _validateClass: Class ].
	suprBlock value: oldClass superClass == newSuperclass.
	optsBlock value: (oldClass _optionsChangableTo: fmtArr).
	ivsBlock value: (oldClass _instVarsEqual: anArrayOfInstvarNames).
	civsBlock value: (oldClass class _instVarsEqual: anArrayOfClassInstVars).
	poolsBlock value: (oldClass _poolDictsEqual: anArrayOfPoolDicts).
	cvarsBlock value: (oldClass _classVarsChangableTo: anArrayOfClassVars copy).
	consBlock value: (aConstraint size = 0 or: [oldClass _constraintsEqual: aConstraint ])
%

! Class extensions for 'RwGsFileUtilities'

!		Class methods for 'RwGsFileUtilities'

category: '*rowan-gemstone-core-36x'
classmethod: RwGsFileUtilities
directoryExists: aDirectory

	"handle the case where GsFile class>>existsOnServer: returns nil"
	aDirectory ifNil: [ ^false ].
	^ (GsFile existsOnServer: aDirectory) == true
%

! Class extensions for 'RwGsImage'

!		Class methods for 'RwGsImage'

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsImage
applyModification: aProjectSetModification instanceMigrator: instanceMigrator

	(self _shouldCloneRowanLoader: aProjectSetModification)
		ifTrue: [ 
			| visitorClass |
			visitorClass := self _cloneRowanLoaderSymbolDictionary at: #RwGsImagePatchVisitor.
			self 
				applyModification: aProjectSetModification 
				visitorClass:visitorClass 
				instanceMigrator: instanceMigrator ]
		ifFalse: [ 
			self 
				applyModification: aProjectSetModification 
				visitorClass: RwGsImagePatchVisitor 
				instanceMigrator: instanceMigrator ]
%

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsImage
applyModification: aProjectSetModification visitorClass: visitorClass instanceMigrator: instanceMigrator

	| visitor patchSet newClassVersionPatchSet |
	visitor := visitorClass new.
	visitor visit: aProjectSetModification.
	patchSet := visitor patchSet.
	patchSet moveClassesBetweenPackages.
	patchSet classesWithNewVersions isEmpty
		ifTrue: [ 
			patchSet apply.
			^ self ].
	patchSet classesWithNewVersions
		do: [ :each | 
			each
				updatePatchesForNewClassVersion: aProjectSetModification 
					patchSet: patchSet;
				updateNewClassVersionPatchesForExtensionsIn: aProjectSetModification
					patchSet: patchSet;
				updateNewClassVersionPatchesForSubclassesIn: aProjectSetModification
					patchSet: patchSet ].
	visitor := visitorClass new.
	visitor visit: aProjectSetModification.
	newClassVersionPatchSet := visitor patchSet.
	newClassVersionPatchSet moveClassesWithNewVersionsBetweenPackages.
	newClassVersionPatchSet applyForNewClassVersions: instanceMigrator
%

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsImage
applyModification_254: aProjectSetModification instanceMigrator: instanceMigrator
	(self _shouldCloneRowanLoader: aProjectSetModification)
		ifTrue: [ 
			| visitorClass |
			visitorClass := self _cloneRowanLoaderSymbolDictionary at: #RwGsImagePatchVisitor_254.
			self 
				applyModification_254: aProjectSetModification 
				visitorClass:visitorClass 
				instanceMigrator: instanceMigrator ]
		ifFalse: [ 
			self 
				applyModification_254: aProjectSetModification 
				visitorClass: RwGsImagePatchVisitor_254 
				instanceMigrator: instanceMigrator ]
%

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsImage
applyModification_254: aProjectSetModification visitorClass: visitorClass instanceMigrator: instanceMigrator

	| visitor patchSet newClassVersionPatchSet |
	visitor := visitorClass new.
	visitor visit: aProjectSetModification.
	patchSet := visitor patchSet.
	patchSet classesWithNewVersions isEmpty
		ifTrue: [ 
			patchSet apply.
			^ self ].
	patchSet setupForNewClassVersionUpdates.
	patchSet classesWithNewVersions
		do: [ :each | 
			each
				updatePatchesForNewClassVersion: aProjectSetModification 
					patchSet: patchSet;
				updateNewClassVersionPatchesForExtensionsIn: aProjectSetModification
					patchSet: patchSet;
				updateNewClassVersionPatchesForSubclassesIn: aProjectSetModification
					patchSet: patchSet ].
	visitor := visitorClass new.
	visitor visit: aProjectSetModification.
	newClassVersionPatchSet := visitor patchSet.
	newClassVersionPatchSet applyForNewClassVersions: instanceMigrator
%

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsImage
_cloneRowanLoaderSymbolDictionary

	"in order to cleanly update Rowan using Rowan, it is necessary to isolate a copy of all of the loader code
		in a separate symbol dictionary and then use the isolated copy to execute the update."

	| rowanLoaderSymbolDict clonedSymDictName clonedSymDict |
	rowanLoaderSymbolDict := Rowan globalNamed: 'RowanLoader'.
	clonedSymDictName := #'RowanLoader_cloned'.
	clonedSymDict := rowanLoaderSymbolDict 
		_rowanCloneSymbolDictionaryNamed: clonedSymDictName 
		symbolList: GsCurrentSession currentSession symbolList.
	Transcript cr; show: 'RowanLoader symbol dictionary cloned'.
	^ clonedSymDict
%

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsImage
_shouldCloneRowanLoader: aProjectSetModification

	"When modifications are made to the Rowan-GemStone-Loader package in the Rowan project, we need to clone the RowanLoader symbol dictionary"

	| projectModification packageModification |
	projectModification := aProjectSetModification elementsModified at: 'Rowan' ifAbsent: [ ^ false ].
	packageModification := projectModification packagesModification elementsModified at: 'Rowan-GemStone-Loader' ifAbsent: [ ^ false ].
	^ packageModification isEmpty not
%

! Class extensions for 'RwGsPlatform'

!		Instance methods for 'RwGsPlatform'

category: '*rowan-services-extensions'
method: RwGsPlatform
answeringServiceClass
  ^ RowanAnsweringService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
browserServiceClass

	^ RowanBrowserService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
classServiceClass

	^ RowanClassService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
commandResultClass

	^ RowanCommandResult
%

category: '*rowan-tools-extensions'
method: RwGsPlatform
gitTools

	"Answer the platform-specific class for git tools"

	^ RwGitTool new
%

category: '*rowan-services-extensions'
method: RwGsPlatform
jadeServerClassNamed: className

	| jadeClasses |
	jadeClasses := Array with: (UserGlobals at: #JadeServer). 
	jadeClasses add: (UserGlobals at: #JadeServer64bit32). 
	jadeClasses add: (UserGlobals at: #JadeServer64bit35). 
	^jadeClasses detect:[:cls | cls name == className] ifNone:[self error: 'Could not look up a JadeServer class: ', className]
%

category: '*rowan-services-extensions'
method: RwGsPlatform
loggingServiceClass

	^ RowanLoggingService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
methodServiceClass

	^ RowanMethodService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
packageServiceClass

	^ RowanPackageService
%

category: '*rowan-tools-extensions'
method: RwGsPlatform
packageTools
	"Answer the platform-specific class for package tools"

	^RwPackageTool
%

category: '*rowan-services-extensions'
method: RwGsPlatform
projectServiceClass

	^ RowanProjectService
%

category: '*rowan-tools-extensions'
method: RwGsPlatform
projectTools
	"Answer the platform-specific class for project tools"

	^RwProjectTool
%

category: '*rowan-tools-extensions'
method: RwGsPlatform
repositoryTools
	"Answer the platform-specific class for repository tools"

	^RwRepositoryTool
%

category: '*rowan-services-extensions'
method: RwGsPlatform
serviceClass

	^ RowanService
%

category: '*rowan-services-extensions'
method: RwGsPlatform
serviceClasses
	"Explicitly add each class rather than sending #allSubclasses so
	that users other than SystemUser have visibility. Visibility in Rowan
	is determined at compile time. See STONReader>>lookupClass:"
	
	| array |
	array := Array with: RowanService. 
	array add: RowanAnsweringService; 
		add: RowanAutoCommitService; 
		add: RowanBrowserService;
		add: RowanClassService; 
		add: RowanDebuggerService; 
		add: RowanDictionaryService; 
		add: RowanFrameService;
		add: RowanLoggingService;
		add: RowanMethodService;
		add: RowanPackageService; 
		add: RowanProcessService;
		add: RowanProjectService;
		add: RowanQueryService;
		add: RowanVariableService.
	^array
%

category: '*rowan-services-extensions'
method: RwGsPlatform
serviceClassFor: className

	^self serviceClasses detect:[:cls | cls name asString = className asString] ifNone:[]
%

! Class extensions for 'RwGsSymbolDictionaryRegistry'

!		Class methods for 'RwGsSymbolDictionaryRegistry'

category: '*rowan-gemstone-loader-extensions'
classmethod: RwGsSymbolDictionaryRegistry
registry_ImplementationClass

	^ RwGsSymbolDictionaryRegistry_Implementation
%

! Class extensions for 'RwGsSymbolDictionaryRegistry_Implementation'

!		Class methods for 'RwGsSymbolDictionaryRegistry_Implementation'

category: '*rowan-gemstone-loader-36x'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addExtensionCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: registryInstance

	| methodDictionary selector protocolSymbol existing loadedMethod loadedPackage loadedClassExtension |
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	selector := compiledMethod selector.
	methodDictionary at: selector put: compiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [ behavior addCategory: protocolSymbol ].
	behavior moveMethod: selector toCategory: protocolSymbol.

	existing := registryInstance methodRegistry at: compiledMethod ifAbsent: [ nil ].
	existing
		ifNotNil: [ 
			registryInstance
				error:
					'Internal error -- existing LoadedMethod found for extension compiled method.' ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	registryInstance methodRegistry at: compiledMethod put: loadedMethod.

	loadedPackage := Rowan image 
		loadedPackageNamed: packageName 
		ifAbsent: [ self existingOrNewLoadedPackageNamed: packageName instance: registryInstance ].

	loadedClassExtension := loadedPackage
		loadedClassExtensionForClass: behavior
		ifAbsent: [ 
			| class ext |
			class := behavior theNonMetaClass.
			ext := RwGsLoadedSymbolDictClassExtension
				newForClass: class
				inPackage: loadedPackage.
			(registryInstance classExtensionRegistry
				at: class classHistory
				ifAbsentPut: [ IdentitySet new ]) add: ext.
			ext ].
	loadedClassExtension addLoadedMethod: loadedMethod.
	^ registryInstance
%

category: '*rowan-gemstone-loader-36x'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addMovedDeletedMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: registryInstance

	"there is an existing compiled method that has already been deleted from another package ... so we're adding it
		back using specialized processing"

	| methodDictionary selector |
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	selector := compiledMethod selector.
	methodDictionary 
		at: selector 
		ifAbsent: [  
			registryInstance
				error:
					'Internal error -- attempt to move a method that does not exist'  ].
	self _addMovedDeletedMethod: compiledMethod instance: registryInstance.
	^ self moveCompiledMethod: compiledMethod toProtocol: protocolString instance: registryInstance
%

category: '*rowan-gemstone-loader-36x'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addNewCompiledMethod: compiledMethod for: behavior protocol: protocolString toPackageNamed: packageName instance: registryInstance
	| methodDictionary selector protocolSymbol existing loadedMethod loadedPackage loadedClassOrExtension |
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	selector := compiledMethod selector.
	(methodDictionary at: selector ifAbsent: [  ])
		ifNotNil: [ :oldCompiledMethod | 
			"there is an existing compiled method ... that means we're adding a recompiled methoded and moving it to the (possibly new) protocol"
			self addRecompiledMethod: compiledMethod instance: registryInstance.
			^ self
				moveCompiledMethod: compiledMethod
				toProtocol: protocolString
				instance: registryInstance ].
	methodDictionary at: selector put: compiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	protocolSymbol := protocolString asSymbol.
	(behavior includesCategory: protocolSymbol)
		ifFalse: [ behavior addCategory: protocolSymbol ].
	behavior moveMethod: selector toCategory: protocolSymbol.


	existing := registryInstance methodRegistry at: compiledMethod ifAbsent: [ nil ].
	existing
		ifNotNil: [ registryInstance error: 'Internal error -- existing LoadedMethod found for compiled method.' ].
	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: compiledMethod.

	registryInstance methodRegistry at: compiledMethod put: loadedMethod.

	loadedPackage := self
		loadedPackageNamed: packageName
		ifAbsent: [ 
			registryInstance
				error: 'Internal error -- attempt to add a method to a nonexistent package.' ]
		instance: registryInstance.

	loadedClassOrExtension := loadedPackage
		loadedClassOrClassExtensionForClass: behavior
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- attempt to add a method to a package in which its class is neither defined nor extended.' ].
	loadedClassOrExtension addLoadedMethod: loadedMethod.
	^ registryInstance
%

category: '*rowan-gemstone-loader-36x'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
addRecompiledMethod: newCompiledMethod instance: registryInstance

	"add a recompiled compiled method to behavior and update the loaded things"

	| selector behavior methodDictionary oldCompiledMethod loadedMethod |
	selector := newCompiledMethod selector.
	behavior := newCompiledMethod inClass.
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	oldCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- expected an existing compiled method in the method dictionary' ].

	oldCompiledMethod == newCompiledMethod
		ifTrue: [ 
			"exit early, no more work to be done"
			^ registryInstance ].
	methodDictionary at: selector put: newCompiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	loadedMethod := registryInstance methodRegistry
		at: oldCompiledMethod
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for the old compiledMethod.' ].
	registryInstance methodRegistry removeKey: oldCompiledMethod.
	loadedMethod handle: newCompiledMethod.
	registryInstance methodRegistry at: newCompiledMethod put: loadedMethod.
	^ registryInstance
%

category: '*rowan-gemstone-loader-36x'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
moveCompiledMethod: compiledMethod toProtocol: newProtocol instance: registryInstance

	"move a compiled method into a different protocol and update loaded things"

	| behavior selector loadedMethod oldCat catSym catDict methodDictionary existingCompiledMethod |
	selector := compiledMethod selector.
	behavior := compiledMethod inClass.

	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	existingCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing CompileMethod found for patched method.' ].
	existingCompiledMethod == compiledMethod
		ifFalse: [ 
			registryInstance
				error:
					'Internal error - the existingCompiledMethod is not identical to the compiled method arg' ].

	oldCat := behavior categoryOfSelector: selector environmentId: 0.
	catSym := newProtocol asSymbol.
	catDict := behavior _baseCategorysForStore: 0.
	oldCat ifNotNil: [ (catDict at: oldCat) remove: selector ].
	catDict
		at: catSym
		ifAbsent: [ behavior addCategory: newProtocol environmentId: 0 ].
	(catDict at: catSym) add: selector.

	behavior moveMethod: selector toCategory: newProtocol environmentId: 0.

	loadedMethod := registryInstance methodRegistry
		at: compiledMethod
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- no existing LoadedMethod found for the compiledMethod.' ].

	loadedMethod updateForProtocolChange.
	^ registryInstance
%

category: '*rowan-gemstone-loader-36x'
classmethod: RwGsSymbolDictionaryRegistry_Implementation
_addMovedDeletedMethod: newCompiledMethod  instance: registryInstance

	"add a recompiled compiled method that was previously removed from loaded things
		to behavior and update the loaded things appropriately"

	| selector behavior methodDictionary oldCompiledMethod loadedMethod |
	selector := newCompiledMethod selector.
	behavior := newCompiledMethod inClass.
	methodDictionary := behavior rwGuaranteePersistentMethodDictForEnv: 0.
	oldCompiledMethod := methodDictionary
		at: selector
		ifAbsent: [ 
			registryInstance
				error:
					'Internal error -- expected an existing compiled method in the method dictionary' ].

	oldCompiledMethod == newCompiledMethod
		ifTrue: [ 
			"exit early, no more work to be done"
			^ registryInstance ].
	methodDictionary at: selector put: newCompiledMethod.
	self _clearLookupCachesFor: behavior env: 0.

	loadedMethod := registryInstance methodRegistry
		at: oldCompiledMethod
		ifAbsent: [].
	loadedMethod ifNotNil: [  
			registryInstance
				error:
					'Internal error -- unexpected loaded method found - deleteMethod processing should have removed the loaded method already' ].

	loadedMethod := RwGsLoadedSymbolDictMethod forMethod: newCompiledMethod.

	registryInstance methodRegistry at: newCompiledMethod put: loadedMethod.
	^ registryInstance
%

! Class extensions for 'RwMethodDefinition'

!		Class methods for 'RwMethodDefinition'

category: '*rowan-cypress-definitions'
classmethod: RwMethodDefinition
fromCypressMethod: cypMethodDef
  ^ self new
    fromCypressMethod: cypMethodDef;
    yourself
%

!		Instance methods for 'RwMethodDefinition'

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareAgainstBase: aDefinition 

	| modification |
	modification := RwMethodModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification: (self compareSourceAgainstBase: aDefinition).
	^modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareAgainstBaseForNewClassVersion: aDefinition

	| modification |
	modification := RwMethodModificationForNewClassVersion
		before: aDefinition
		after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification:
				(self compareSourceAgainstBaseForNewClassVersion: aDefinition).
	^ modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareAgainstBase_forUpgrade: aDefinition 
	"unconditionally create a method source modification.. so that all methods get recompiled, whether they have changed or not"

	| modification sourceModification before after |
	modification := RwMethodModification before: aDefinition after: self.
	sourceModification := RwSourceModification new.
	before := aDefinition source.
	after := self source.
	sourceModification addElementModification: (RwPropertyModificationForUpgrade
						key: 'source'
						oldValue: before
						newValue: after).
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification: sourceModification.
	^modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareExtensionMethodsAgainstBase: aDefinition

	| modification |
	modification := RwExtensionMethodModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification: (self compareSourceAgainstBase: aDefinition).
	^ modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareExtensionMethodsAgainstBase_forUpgrade: aDefinition
	"unconditionally create a method source modification.. so that all methods get recompiled, whether they have changed or not"

	| modification sourceModification before after |
	modification := RwExtensionMethodModification before: aDefinition after: self.
	sourceModification := RwSourceModification new.
	before := aDefinition source.
	after := self source.
	sourceModification addElementModification: (RwPropertyModificationForUpgrade
						key: 'source'
						oldValue: before
						newValue: after).
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition);
		sourceModification: sourceModification.
	^ modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareSourceAgainstBase: aDefinition

	| modification |
	modification := RwSourceModification new.
	aDefinition source ~= self source
		ifTrue: [
			| before after |
			before := aDefinition source.
			after := self source.
			modification addElementModification: (RwPropertyModification
								key: 'source'
								oldValue: before
								newValue: after) ].
	^modification
%

category: '*rowan-core-definitions-extensions'
method: RwMethodDefinition
compareSourceAgainstBaseForNewClassVersion: aDefinition

	"unconditional modification for new class versions"

	| modification before after |
	modification := RwSourceModification new.
	before := aDefinition source.
	after := self source.
	modification
		addElementModification:
			(RwUnconditionalPropertyModification
				key: 'source'
				oldValue: before
				newValue: after).
	^ modification
%

category: '*rowan-cypress-definitions'
method: RwMethodDefinition
fromCypressMethod: cypMethodDef
  properties
    at: 'selector' put: cypMethodDef selector asSymbol;
    at: 'protocol' put: cypMethodDef category;
    yourself.
  self source: cypMethodDef source
%

! Class extensions for 'RwMethodMove'

!		Instance methods for 'RwMethodMove'

category: '*rowan-gemstone-loader-extensions'
method: RwMethodMove
addMovedMethodToPatchSet: aPatchSet

	aPatchSet addMethodMove: self
%

! Class extensions for 'RwPackage'

!		Instance methods for 'RwPackage'

category: '*rowan-gemstone-core'
method: RwPackage
methodEnv

	^ self _gemstonePlatformSpec methodEnvForPackageNamed: self name
%

category: '*rowan-gemstone-core'
method: RwPackage
symbolDictName

	^ self _gemstonePlatformSpec symbolDictNameForPackageNamed: self name
%

category: '*rowan-gemstone-core'
method: RwPackage
useSessionMethodsForExtensions

	^ self _gemstonePlatformSpec
		useSessionMethodsForExtensionsForPackageNamed: self name
%

! Class extensions for 'RwPackageDefinition'

!		Instance methods for 'RwPackageDefinition'

category: '*rowan-core-definitions-extensions'
method: RwPackageDefinition
compareAgainstBase: aDefinition

	| modification classesModification classExtensionsModification |
	modification := RwPackageModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	classesModification := RwClassesModification new.
	classExtensionsModification := RwClassExtensionsModification new.
	self
		compareDictionary: classDefinitions
		againstBaseDictionary: aDefinition classDefinitions
		into: classesModification
		elementClass: RwClassDefinition.
	self
		compareDictionary: classExtensions
		againstBaseDictionary: aDefinition classExtensions
		into: classExtensionsModification
		elementClass: RwClassExtensionDefinition.
	modification
		classesModification: classesModification;
		classExtensionsModification: classExtensionsModification.
	^modification
%

category: '*rowan-core-definitions-extensions'
method: RwPackageDefinition
compareAgainstBase_forUpgrade: aDefinition

	| modification classesModification classExtensionsModification |
	modification := RwPackageModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	classesModification := RwClassesModification new.
	classExtensionsModification := RwClassExtensionsModification new.
	self
		compareDictionary: classDefinitions
		againstBaseDictionary_forUpgrade: aDefinition classDefinitions
		into: classesModification
		elementClass: RwClassDefinition.
	self
		compareDictionary: classExtensions
		againstBaseDictionary_forUpgrade: aDefinition classExtensions
		into: classExtensionsModification
		elementClass: RwClassExtensionDefinition.
	modification
		classesModification: classesModification;
		classExtensionsModification: classExtensionsModification.
	^modification
%

category: '*rowan-gemstone-definitions'
method: RwPackageDefinition
gs_symbolDictionary

	^ self properties
		at: 'gs_SymbolDictionary'
		ifAbsent: []
%

category: '*rowan-gemstone-definitions'
method: RwPackageDefinition
gs_symbolDictionary: aSymbolDictionaryName

	self properties
		at: 'gs_SymbolDictionary'
		put: aSymbolDictionaryName asString
%

category: '*rowan-cypress-definitions'
method: RwPackageDefinition
name
  ^ self key
%

! Class extensions for 'RwPackageSetDefinition'

!		Instance methods for 'RwPackageSetDefinition'

category: '*rowan-core-definitions-extensions'
method: RwPackageSetDefinition
compareAgainstBase: aDefinition

	| result |
	result := RwPackageSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary: aDefinition definitions
		into: result
		elementClass: RwPackageDefinition.
	^ result
%

category: '*rowan-core-definitions-extensions'
method: RwPackageSetDefinition
compareAgainstBase_forUpgrade: aDefinition

	| result |
	result := RwPackageSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary_forUpgrade: aDefinition definitions
		into: result
		elementClass: RwPackageDefinition.
	^ result
%

! Class extensions for 'RwPlatform'

!		Class methods for 'RwPlatform'

category: '*rowan-gemstone-core'
classmethod: RwPlatform
current

	^ self _userPlatformDictionary 
		at: #RwUserPlatformInstance 
		ifAbsentPut: [ RwGsPlatform new ]
%

category: '*rowan-gemstone-core'
classmethod: RwPlatform
reset

	^ self _userPlatformDictionary 
		removeKey: #RwUserPlatformInstance 
		ifAbsent: [ ]
%

category: '*rowan-gemstone-core'
classmethod: RwPlatform
_userPlatformDictionary

	"Platform globals are put into the current user's UserGlobals so that the values can be persisted.
		if the user does not have write access to UserGlobals, we'll store in session-specific dictionary"

	^self _userPlatformDictionaryForUser: RwGsImage currentUserId
%

category: '*rowan-gemstone-core'
classmethod: RwPlatform
_userPlatformDictionaryForUser: aUserId

	"Platform globals are put into the current user's UserGlobals so that the values can be persisted.
		if the user does not have write access to UserGlobals, we'll store in session-specific dictionary"

	| userGlobals |
	userGlobals := (AllUsers userWithId: aUserId) objectNamed: 'UserGlobals'.
	^ (System canWrite: userGlobals)
		ifTrue: [ userGlobals ]
		ifFalse: [ SessionTemps current ]
%

! Class extensions for 'RwPrjCreateTool'

!		Instance methods for 'RwPrjCreateTool'

category: '*rowan-tools-deprecated'
method: RwPrjCreateTool
createLoadedProject: projectName format: format root: rootPath repoPath: repoPath useGit: useGit

	| projectDefinition |
	projectDefinition := self createProject: projectName format: format root: rootPath repoPath: repoPath useGit: useGit.
	^ self class load loadProjectDefinition: projectDefinition
%

category: '*rowan-tools-deprecated'
method: RwPrjCreateTool
createPackageProject: projectName format: format root: rootPath repoPath: repoPath useGit: useGit

	| projectDefinition |
	projectDefinition := useGit
		ifTrue: [ RwProjectDefinition newForGitBasedProjectNamed: projectName ]
		ifFalse: [ RwProjectDefinition newForDiskBasedProjectNamed: projectName ].
	^ self
		createProjectFor: projectDefinition
		format: format
		root: rootPath
		repoPath: repoPath
%

category: '*rowan-tools-deprecated'
method: RwPrjCreateTool
createPackageProjectFor: projectDefinition format: format root: rootPath repoPath: repoPath

	| projectName utils rootRepoPath dirPath useGit |
	projectName := projectDefinition name.
	useGit := projectDefinition useGit.
	utils := self fileUtilities.
	rootRepoPath := rootPath , utils pathNameDelimiter , projectName.
	self
		_createProjectRepositoryDirectory: rootRepoPath
		useGit: useGit
		abort: [ ^ self ].
	dirPath := rootRepoPath , utils pathNameDelimiter , repoPath.
	utils ensureDirectoryExists: dirPath.
	utils
		writeStreamFor: 'properties.st'
		in: dirPath
		do: [ :fileStream | fileStream nextPutAll: '{ #format : ' , format printString , '}' ].
	dirPath := rootRepoPath , utils pathNameDelimiter , projectDefinition specsPath.
	utils ensureDirectoryExists: dirPath.
	projectDefinition
		repositoryRootPath: rootRepoPath;
		repoPath: repoPath;
		repositoryUrl: 'cypress:' , rootRepoPath , '/' , repoPath , '/'.
	projectDefinition projectOwnerId: Rowan image currentUserId.
	projectDefinition specification copy export.
	^ projectDefinition
%

category: '*rowan-tools-deprecated'
method: RwPrjCreateTool
createProject: projectName format: format root: rootPath repoPath: repoPath useGit: useGit

	^ useGit
		ifTrue: [ self createGitBasedProject: projectName packageNames: #() format: format root: rootPath configsPath: 'configs' repoPath: repoPath specsPath: 'specs' ]
		ifFalse: [ self createDiskBasedProject: projectName packageNames: #() format: format root: rootPath configsPath: 'configs' repoPath: repoPath specsPath: 'specs' ].
%

category: '*rowan-tools-deprecated'
method: RwPrjCreateTool
createProjectFor: projectDefinition format: format root: rootPath repoPath: repoPath

	| projectName utils |
	projectName := projectDefinition name.
	utils := self fileUtilities.
	projectDefinition
		repositoryRootPath: rootPath , utils pathNameDelimiter , projectName;
		repoPath: repoPath.
	^ self createProjectFor: projectDefinition format: format
%

! Class extensions for 'RwPrjLoadTool'

!		Instance methods for 'RwPrjLoadTool'

category: '*rowan-tools-deprecated'
method: RwPrjLoadTool
loadProjectNamed: projectNamed withConfiguration: configName

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed
		withConfiguration: configName.
	[ res := self loadProjectSetDefinition: projectSetDefinition  ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].
	"loaded project and loaded packages read from disk - mark them not dirty"
	projectSetDefinition deriveLoadedThings do: [:loadedProject |
		loadedProject markNotDirty.
		loadedProject loadedPackages valuesDo: [:loadedPackage | loadedPackage markNotDirty ] ].
	^ res
%

category: '*rowan-tools-deprecated'
method: RwPrjLoadTool
loadProjectNamed: projectNamed withConfiguration: configName instanceMigrator: instanceMigrator

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed
		withConfiguration: configName.
	[ res := self
		loadProjectSetDefinition: projectSetDefinition
		instanceMigrator: instanceMigrator ]
			on: RwExecuteClassInitializeMethodsAfterLoadNotification
			do: [:ex | ex resume: true ].
	"loaded project and loaded packages read from disk - mark them not dirty"
	projectSetDefinition deriveLoadedThings do: [:loadedProject |
		loadedProject markNotDirty.
		loadedProject loadedPackages valuesDo: [:loadedPackage | loadedPackage markNotDirty ] ].
	^ res
%

category: '*rowan-tools-deprecated'
method: RwPrjLoadTool
loadProjectNamed_old: projectNamed

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	^ self loadProjectNamed_old: projectNamed instanceMigrator: Rowan platform instanceMigrator
%

category: '*rowan-tools-deprecated'
method: RwPrjLoadTool
loadProjectNamed_old: projectNamed instanceMigrator: instanceMigrator

	"load the named project from disk, mark the loaded projects not dirty and run initializers"

	| projectSetDefinition res |
	projectSetDefinition := self class read
		readProjectSetForProjectNamed: projectNamed.
	res := self 
		_doProjectSetLoad: projectSetDefinition
		instanceMigrator: instanceMigrator 
		originalProjectSet: projectSetDefinition 
		processedClassNames: Set new.
	"loaded project and loaded packages read from disk - mark them not dirty"
	self markProjectSetNotDirty: projectSetDefinition.
	^ res
%

category: '*rowan-tools-deprecated'
method: RwPrjLoadTool
_markProjectSetNotDirty: projectSetDefinition

	self deprecated: 'Use public melthod RwPrjLoadTool>>markProjectSetNotDirty: instead'.

	self markProjectSetNotDirty: projectSetDefinition
%

! Class extensions for 'RwProject'

!		Instance methods for 'RwProject'

category: '*rowan-gemstone-core'
method: RwProject
defaultSymbolDictName

	^ self _gemstonePlatformSpec defaultSymbolDictName
%

category: '*rowan-gemstone-core'
method: RwProject
defaultUseSessionMethodsForExtensions

	^ self _gemstonePlatformSpec defaultUseSessionMethodsForExtensions
%

category: '*rowan-gemstone-core'
method: RwProject
methodEnvForPackageNamed: packageName

	^ self _gemstonePlatformSpec methodEnvForPackageNamed: packageName
%

category: '*rowan-gemstone-core'
method: RwProject
symbolDictNameForPackageNamed: packageName

	^ self _gemstonePlatformSpec symbolDictNameForPackageNamed: packageName
%

category: '*rowan-gemstone-core'
method: RwProject
useSessionMethodsForExtensionsForPackageNamed: packageName

	^ self _gemstonePlatformSpec
		useSessionMethodsForExtensionsForPackageNamed: packageName
%

! Class extensions for 'RwProjectDefinition'

!		Class methods for 'RwProjectDefinition'

category: '*rowan-definitions-deprecated'
classmethod: RwProjectDefinition
newForGitPackageProjectNamed: aString

	| spec |
	spec := RwSimpleProjectSpecification new
		specName: aString;
		yourself.
	^ self newForSpecification: spec
%

!		Instance methods for 'RwProjectDefinition'

category: '*rowan-core-definitions-extensions'
method: RwProjectDefinition
compareAgainstBase: aDefinition

	| modification packagesModification |
	modification := RwProjectModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	packagesModification := RwPackagesModification new.
	self
		compareDictionary: packages
		againstBaseDictionary: aDefinition packages
		into: packagesModification
		elementClass: RwPackageDefinition.
	modification packagesModification: packagesModification.
	^ modification
%

category: '*rowan-core-definitions-extensions'
method: RwProjectDefinition
compareAgainstBase_forUpgrade: aDefinition

	| modification packagesModification |
	modification := RwProjectModification before: aDefinition after: self.
	modification
		propertiesModification: (self comparePropertiesAgainstBase: aDefinition).
	packagesModification := RwPackagesModification new.
	self
		compareDictionary: packages
		againstBaseDictionary_forUpgrade: aDefinition packages
		into: packagesModification
		elementClass: RwPackageDefinition.
	modification packagesModification: packagesModification.
	^ modification
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
defaultSymbolDictName

	^ (self specification platformSpec at: 'gemstone') defaultSymbolDictName
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
defaultSymbolDictName: symbolDictName

	(self specification platformSpec at: 'gemstone')
		defaultSymbolDictName: symbolDictName
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
defaultUseSessionMethodsForExtensions: aBool

	(self specification platformSpec at: 'gemstone')
		defaultUseSessionMethodsForExtensions: aBool
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
methodEnvForPackageNamed: packageName

	^ (self specification platformSpec at: 'gemstone')
		methodEnvForPackageNamed: packageName
%

category: '*rowan-cypress-definitions'
method: RwProjectDefinition
name
  ^ self key
%

category: '*rowan-definitions-deprecated'
method: RwProjectDefinition
packageNamesInLoadOrder: packageNamesInLoadOrder

	packageNamesInLoadOrder
		do: [ :packageName | self addPackage: (RwPackageDefinition newNamed: packageName) ]
%

category: '*rowan-core-definitions-extensions'
method: RwProjectDefinition
projectDefinitionSourceProperty

	^ properties at: RwLoadedProject _projectDefinitionSourceKey ifAbsent: [ RwLoadedProject _projectUnknownDefinitionSourceValue ]
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
projectOwnerId

	^ (self specification platformSpec at: 'gemstone') projectOwnerId
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
projectOwnerId: aUserId

	(self specification platformSpec at: 'gemstone') projectOwnerId: aUserId
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
setSymbolDictName: symbolDictName forPackageNamed: packageName

	(self specification platformSpec at: 'gemstone')
		setSymbolDictName: symbolDictName
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
setUseSessionMethodsForExtensions: aBool forPackageNamed: packageName

	(self specification platformSpec at: 'gemstone')
		setUseSessionMethodsForExtensions: aBool
		forPackageNamed: packageName
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
symbolDictionaryRegistryClass

	^ RwGsSymbolDictionaryRegistry
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
symbolDictNameForPackageNamed: packageName

	^ (self specification platformSpec at: 'gemstone')
		symbolDictNameForPackageNamed: packageName
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
updateGsPlatformSpecLoadedProjectInfo: projectInfo

	| spec gemstoneSpec thePackageMapSpecs |
	spec := self specification.
	thePackageMapSpecs := projectInfo at:  'packageMapSpecs' .
	gemstoneSpec := spec platformSpec at: 'gemstone'.
	(thePackageMapSpecs at: #defaultSymbolDictName otherwise: nil) 
		ifNotNil: [:name | gemstoneSpec defaultSymbolDictName: name ].
	(thePackageMapSpecs at: #defaultUseSessionMethodsForExtensions otherwise: nil) 
		ifNotNil: [:boolean | 
			gemstoneSpec defaultUseSessionMethodsForExtensions: boolean  ].
	(thePackageMapSpecs at: #packageNameToPlatformPropertiesMap otherwise: nil) 
		ifNotNil: [:map | gemstoneSpec packageNameToPlatformPropertiesMap: map]
%

category: '*rowan-gemstone-definitions'
method: RwProjectDefinition
useSessionMethodsForExtensionsForPackageNamed: packageName

	^ (self specification platformSpec at: 'gemstone')
		useSessionMethodsForExtensionsForPackageNamed: packageName
%

category: '*rowan-core-definitions-extensions'
method: RwProjectDefinition
_compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue

	({ 'spec'. RwLoadedProject _projectDefinitionSourceKey } includes: propertyKey)
		ifTrue: [ 
		"spec entries are considered to be equal for comparison purposes"
		"_projectDefinitionSourceKey entries are considered equal for comparison purpposes"
		^ true ].
	^ super _compareProperty: propertyKey propertyVaue: propertyValue againstBaseValue: baseValue
%

! Class extensions for 'RwProjectSetDefinition'

!		Instance methods for 'RwProjectSetDefinition'

category: '*rowan-core-definitions-extensions'
method: RwProjectSetDefinition
compareAgainstBase: aDefinition

	| result |
	result := RwProjectSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary: aDefinition definitions
		into: result
		elementClass: RwProjectDefinition.
	^ result
%

category: '*rowan-core-definitions-extensions'
method: RwProjectSetDefinition
compareAgainstBase_254: aDefinition

	| result |
	result := RwProjectSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary: aDefinition definitions
		into: result
		elementClass: RwProjectDefinition.
	result
		updateForClassMoves;
		updateForMethodMoves.
	^ result
%

category: '*rowan-core-definitions-extensions'
method: RwProjectSetDefinition
compareAgainstBase_forUpgrade: aDefinition

	| result |
	result := RwProjectSetModification new.
	self
		compareDictionary: definitions
		againstBaseDictionary_forUpgrade: aDefinition definitions
		into: result
		elementClass: RwProjectDefinition.
	^ result
%

! Class extensions for 'RwProjectSpecification'

!		Instance methods for 'RwProjectSpecification'

category: '*rowan-gemstone-specifications'
method: RwProjectSpecification
initialize

	super initialize.
	comment := ''.
	configsPath := 'rowan/configs'.
	repoPath := 'rowan/src'.
	specsPath := 'rowan/specs'.
	platformSpec := Dictionary new
		at: 'gemstone' put: RwGemStoneSpecification new;
		yourself.
	repoSpec := RwGitRepositorySpecification new.
	version := self currentVersion.
	defaultConfigurationNames := {'Default'}.
	defaultGroupNames := {'default'}.
%

category: '*rowan-gemstone-specifications'
method: RwProjectSpecification
platformSpec

   ^platformSpec ifNil: [ 
		platformSpec := Dictionary new
			at: 'gemstone' put: RwGemStoneSpecification new;
			yourself ].
%

! Class extensions for 'RwSpecification'

!		Instance methods for 'RwSpecification'

category: '*rowan-gemstone-specifications'
method: RwSpecification
register

	Rowan image 
		loadedProjectNamed: self specName
		ifAbsent: [
			| newLoadedProject |
			newLoadedProject := RwGsLoadedSymbolDictProject newForLoadSpecification: self.
			Rowan image addLoadedProject: newLoadedProject ]
%

! Class extensions for 'RwUnmanagedProjectDefinition'

!		Instance methods for 'RwUnmanagedProjectDefinition'

category: '*rowan-gemstone-definitions'
method: RwUnmanagedProjectDefinition
defaultSymbolDictName

	^ 'UnmanagedPackages'
%

category: '*rowan-gemstone-definitions'
method: RwUnmanagedProjectDefinition
methodEnvForPackageNamed: packageName

	^ 0
%

category: '*rowan-gemstone-definitions'
method: RwUnmanagedProjectDefinition
projectOwnerId

	^ Rowan image currentUserId
%

category: '*rowan-gemstone-definitions'
method: RwUnmanagedProjectDefinition
symbolDictNameForPackageNamed: packageName

	^ self defaultSymbolDictName
%

category: '*rowan-gemstone-definitions'
method: RwUnmanagedProjectDefinition
useSessionMethodsForExtensionsForPackageNamed: packageName

	^ true
%

! Class extensions for 'SequenceableCollection'

!		Class methods for 'SequenceableCollection'

category: '*rowan-gemstone-kernel'
classmethod: SequenceableCollection
new: size withAll: value

	"Answer an instance of me, with number of elements equal to size, each 
	of which refers to the argument, value."

	^ (self new: size)
		atAllPut: value;
		yourself
%

!		Instance methods for 'SequenceableCollection'

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
allButLast

	"Answer a copy of the receiver containing all but the last
	element. Raise an error if there are not enough elements."

	^ self allButLast: 1
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
allButLast: n

	"Answer a copy of the receiver containing all but the last n
	elements. Raise an error if there are not enough elements."

	^ self copyFrom: 1 to: self size - n
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
beginsWith: aSequenceableCollection

	(aSequenceableCollection isEmpty
		or: [ self size < aSequenceableCollection size ])
		ifTrue: [ ^ false ].
	aSequenceableCollection
		withIndexDo: [ :each :index | 
			(self at: index) ~= each
				ifTrue: [ ^ false ] ].
	^ true
%

category: '*rowan-gemstone-kernel'
method: SequenceableCollection
copyUpTo: anObject

	"Answer all elements up to but not including anObject. If there
  is no such object, answer a copy of the receiver."

	| idx |
	idx := self indexOf: anObject startingAt: 1.
	idx == 0
		ifTrue: [ ^ self copy ]
		ifFalse: [ ^ self copyFrom: 1 to: idx - 1 ]
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
fifth

	"Answer the fifth element of the receiver.
	Raise an error if there are not enough elements."

	^ self at: 5
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
fourth

	"Answer the fourth element of the receiver.
	Raise an error if there are not enough elements."

	^ self at: 4
%

category: '*ast-kernel-core'
method: SequenceableCollection
lastIndexOf: anElement startingAt: lastIndex ifAbsent: exceptionBlock
  "Answer the index of the last occurence of anElement within the  
	receiver. If the receiver does not contain anElement, answer the
	result of evaluating the argument, exceptionBlock."

  lastIndex to: 1 by: -1 do: [ :index | 
    (self at: index) = anElement
      ifTrue: [ ^ index ] ].
  ^ exceptionBlock ~~ nil
    ifTrue: [ exceptionBlock value ]
    ifFalse: [ 0 ]
%

category: '*tonel-gemstonecommon-core'
method: SequenceableCollection
pairsCollect: aBlock 
	"Evaluate aBlock with my elements taken two at a time, and return an Array with the results"

	^ (1 to: self size // 2) collect:
		[:index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]
"
#(1 'fred' 2 'charlie' 3 'elmer') pairsCollect:
	[:a :b | b, ' is number ', a printString]
"
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
putOn: aStream

	self do: [ :each | each putOn: aStream ]
%

category: '*ast-kernel-core'
method: SequenceableCollection
rbStoreElementsFrom: firstIndex to: lastIndex on: aStream
  | noneYet defaultElement arrayElement |
  noneYet := true.
  defaultElement := nil.
  firstIndex to: lastIndex do: [ :index | 
    arrayElement := self at: index.
    arrayElement = defaultElement
      ifFalse: [ 
        noneYet
          ifTrue: [ noneYet := false ]
          ifFalse: [ aStream nextPut: $; ].
        aStream nextPutAll: ' at: '.
        index rbStoreOn: aStream.
        aStream nextPutAll: ' put: '.
        arrayElement rbStoreOn: aStream] ].
  ^ noneYet
%

category: '*ast-kernel-core'
method: SequenceableCollection
rbStoreOn: aStream
  aStream nextPutAll: '(('.
  aStream nextPutAll: self class name.
  aStream nextPutAll: ' new: '.
  self size rbStoreOn: aStream.
  aStream nextPut: $).
  (self rbStoreElementsFrom: 1 to: self size on: aStream)
    ifFalse: [ aStream nextPutAll: '; yourself' ].
  aStream nextPut: $)
%

category: '*ast-kernel-core'
method: SequenceableCollection
readStreamPortable

	^ ReadStreamPortable on: self
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
second

	"Answer the second element of the receiver.
	Raise an error if there are not enough elements."

	^ self at: 2
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
sixth

	"Answer the sixth element of the receiver.
	Raise an error if there are not enough elements."

	^ self at: 6
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
sort

	"Sort this array into ascending order using the '<=' operator."

	^ self sort: [ :a :b | a <= b ]
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
third

	"Answer the third element of the receiver.
	Raise an error if there are not enough elements."

	^ self at: 3
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
withIndexDo: elementAndIndexBlock

	"Just like with:do: except that the iteration index supplies the second argument to the block."

	1 to: self size do: [ :index | elementAndIndexBlock value: (self at: index) value: index ]
%

category: '*tonel-gemstone-kernel'
method: SequenceableCollection
writeStreamPortable

	^ WriteStreamPortable on: self
%

! Class extensions for 'Stream'

!		Instance methods for 'Stream'

category: '*tonel-gemstone-kernel'
method: Stream
<< items

	items putOn: self
%

! Class extensions for 'String'

!		Instance methods for 'String'

category: '*rowan-gemstone-kernel'
method: String
decodeFromUTF8

"Deprecated.  Applications should use instances of Utf8 to hold UTF-8 data.
 Decode receiver from UTF8 format."

"Undeprecated by Rowan, because the method has been undeprecated in later GemStone versions"

" Returns either a Unicode7 , Unicode16 or Unicode32 ,
 using the minimum character size needed to represent decoded result."

 ^ self _decodeFromUtf8: true
%

category: '*Cypress-PackageManagement'
method: String
_writeCypressJsonOn: aStream indent: startIndent
	"Private method which may be removed in a future GemStone version."

	aStream nextPutAll: '"'.
	CypressUrl
		writeWithHttpEscapes: (CypressObject normalizeLineEndingsOf: self)
		on: aStream.
	aStream nextPutAll: '"'
%

! Class extensions for 'Symbol'

!		Instance methods for 'Symbol'

category: '*tonel-gemstone-kernel'
method: Symbol
keywords

	"Answer an array of the keywords that compose the receiver."

	| kwd char keywords |
	keywords := Array new.
			kwd := WriteStreamPortable on: String new.
			1 to: self size do: [ :i | 
				kwd nextPut: (char := self at: i).
				char = $:
					ifTrue: [ 
						keywords add: kwd contents.
						kwd reset ] ].
			kwd position = 0
				ifFalse: [ keywords add: kwd contents ].
	(keywords size >= 1 and: [ (keywords at: 1) = ':' ])
		ifTrue: [ 
			"Has an initial keyword, as in #:if:then:else:"
			keywords := keywords allButFirst ].
	(keywords size >= 2 and: [ (keywords at: keywords size - 1) = ':' ])
		ifTrue: [ 
			"Has a final keyword, as in #nextPut::andCR"
			keywords := keywords
				copyReplaceFrom: keywords size - 1
				to: keywords size
				with: {(':' , keywords last)} ].
	^ keywords
%

category: '*ast-kernel-core'
method: Symbol
rbStoreOn: aStream
  aStream nextPut: $#.
  super rbStoreOn: aStream
%

! Class extensions for 'SymbolDictionary'

!		Instance methods for 'SymbolDictionary'

category: '*rowan-gemstone-kernel'
method: SymbolDictionary
rowanSymbolDictionaryRegistry

	"answer the RwGsSymbolDictionaryRegistry instance installed in the receiver, otherwise answer nil"

	^ self at: #'RwSymbolDictionaryRegistry' ifAbsent: [  ]
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: SymbolDictionary
_rowanCloneSymbolDictionaryNamed: aSymbol symbolList: symbolList

	"return a new symbol dictionary containing copies of all of the classes in the receiver ... the state of each class should be the same with 
		respect to class intance variables and class variables ... similar to what happens when a new version of a class is created, except the
		copied classes are not in the class history of the original class"

	"it is expected that the receiver is in the <symbolList>"

	| toBeOrdered order clonedSymDict processed aClass clonedClasses |
    "order the list of classes in the receiver in superclass order, so that superclasses are cloned before the subclasses are cloned"
	toBeOrdered := (self values select: [:each | each isBehavior ]) asIdentitySet.
	order := OrderedCollection new.
	processed := IdentitySet new.
	[ (aClass := RwGsPatchSet _anyElementOf: toBeOrdered ifEmpty: [ nil ]) isNil ]
		whileFalse: [ 
			RwGsPatchSet
				_orderBySuperclass: aClass
				from: toBeOrdered
				into: order
				ignoring: processed ].
	"create clone and clone all of the classes before compiling methods"
	clonedSymDict := self class new.
	clonedSymDict name: aSymbol.
	clonedClasses := OrderedCollection new.
	[
		symbolList add: clonedSymDict before: self. "install clone after receiver, so that methods will be compiled and reference the cloned classes"
		"clone the body of classes before compiling methods"
		order do: [:oldClass |
			| oldClassName clonedClass hist superclass |
			oldClassName := oldClass name asSymbol.
			hist := oldClass classHistory copy.	"make copy ... leverage the new class version behavior, which preserves a lot of state, without 
																adding the new class to old class' class hitory"
			superclass := symbolList objectNamed: oldClass superclass name. "look up superclass, in case superclass has been cloned"
			clonedClass :=  superclass
				_subclass: oldClassName asString 
				instVarNames: oldClass instVarNames
				format: oldClass format  
				classVars: oldClass classVarNames
				classInstVars: oldClass class instVarNames
				poolDictionaries: #()
				inDictionary: nil
				inClassHistory: hist
				description: nil
				options: oldClass _optionsArrayForDefinition .
			clonedSymDict at: oldClassName put: clonedClass.
			clonedClasses add: {clonedClass. oldClass} ].
			"compile methods in cloned class"
			clonedClasses do: [:ar | | x clonedClass oldClass |
				clonedClass := ar at: 1.
				oldClass := ar at: 2.
				(x := clonedClass _rowanCopyMethodsAndVariablesFrom: oldClass dictionaries: symbolList)
					isEmpty 
						ifFalse: [ self error: 'failed to compile methods in the cloned class ', oldClass name asString printString ] ] ] 
		ensure: [ 
			"do not leave clone in the symbol list"
			symbolList remove: clonedSymDict ifAbsent: [] ].
	^ clonedSymDict
%

! Class extensions for 'TonelParser'

!		Class methods for 'TonelParser'

category: '*tonel-gemstonecommon-core'
classmethod: TonelParser
readStreamClass

	^ ReadStreamPortable
%

category: '*tonel-gemstonecommon-core'
classmethod: TonelParser
writeStreamClass

	^ WriteStreamPortable
%

! Class extensions for 'TonelWriter'

!		Class methods for 'TonelWriter'

category: '*tonel-gemstonecommon-core'
classmethod: TonelWriter
lineEnding
  "Answer the os-specific line endings"

  ^ String with: Character lf
%

category: '*tonel-gemstonecommon-core'
classmethod: TonelWriter
orderedDictionaryClass
  "Answer the platform-specific OrderedDictionary-compatible class"

  ^ GsTonelOrderedDictionary
%

! Class extensions for 'UndefinedObject'

!		Instance methods for 'UndefinedObject'

category: '*ast-kernel-core'
method: UndefinedObject
rbStoreOn: aStream
  aStream nextPutAll: self asString
%

category: '*rowan-gemstone-kernel-extensions-36x'
method: UndefinedObject
subclass: aString 
instVarNames: anArrayOfInstvarNames 
classVars: anArrayOfClassVars 
classInstVars: anArrayOfClassInstVars 
poolDictionaries: anArrayOfPoolDicts 
inDictionary: aDictionary 
newVersionOf: oldClass 
description: aDescription 
constraints: constraintsArray
options: optionsArray

  | descr theClass superClassOffset |
  descr := aDescription.
  oldClass ifNotNil: [ 
     (Object _equivalentSubclass: oldClass
        superCls: self
        name: aString
        newOpts: optionsArray
        newFormat: oldClass format
        newInstVars: anArrayOfInstvarNames
        newClassInstVars: anArrayOfClassInstVars
        newPools: anArrayOfPoolDicts
        newClassVars: anArrayOfClassVars
        inDict: aDictionary
        constraints: constraintsArray isKernel: false ) ifTrue: [
            oldClass _commentOrDescription: aDescription.
            ^oldClass "avoid creation of a new version"
        ].
      descr ifNil: [descr := oldClass commentForFileout]
  ].
  theClass := Object
        subclass: aString
        instVarNames: anArrayOfInstvarNames
        classVars: anArrayOfClassVars
        classInstVars: anArrayOfClassInstVars
        poolDictionaries: anArrayOfPoolDicts
        inDictionary: aDictionary
        newVersionOf: oldClass
        description: descr
		constraints: constraintsArray
        options: optionsArray.
  theClass == oldClass
    ifFalse:
      [superClassOffset := Behavior _ivOffsetOf: #superClass.
      theClass _unsafeAt: superClassOffset put: nil.
      theClass class _unsafeAt: superClassOffset put: Object class superClass].
  ^theClass
%

! Class extensions for 'Warning'

!		Instance methods for 'Warning'

category: '*gemstone-interactions-kernel'
method: Warning
defaultAction
  "The user should be notified of the occurrence of an exceptional
	occurrence and given an option of continuing or aborting the
	computation. The description of the occurrence should include
	any text specified as the argument of the #signal: message."

  | response |
  response := (GsNotifyInteraction
    prompt:
      self description withoutGemstoneLineEndings , ' Press ''Proceed'' to continue.'
    confirm: 'Proceed'
    cancel: 'Debug'
    abort: 'Cancel') signal.
  response == true
    ifTrue: [ ^ super defaultAction ].
  response == false
    ifTrue: [ self halt: 'Debugging: ' , self description ].
  ^ Processor activeProcess terminate
%

! Class Initialization

run
CypressAbstractRepository initialize.
CypressGemStoneDirectoryUtilities initialize.
CypressPackageManager2 initialize.
RBConfigurableFormatter initialize.
RBPatternScanner initialize.
RBScanner initialize.
Rowan initialize.
RwLoadedThing initialize.
true
%
