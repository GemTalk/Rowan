"
No class-specific documentation for CypGsClassPatch, hierarchy is: 
Object
  CypGsPatch
    CypGsClassPatch( classDefinition packageDefinition)

"
Class {
	#name : 'RwGsClassPatch',
	#superclass : 'RwGsPatch',
	#instVars : [
		'classDefinition',
		'packageDefinition'
	],
	#category : 'Rowan-GemStone'
}

{ #category : 'instance creation' }
RwGsClassPatch class >> for: aClassDefinition inPackage: aPackageDefinition [

	^(self new)
		classDefinition: aClassDefinition;
		packageDefinition: aPackageDefinition;
		yourself
]

{ #category : 'private' }
RwGsClassPatch >> _classFormat: fmt forSubclassType: classType [
	"Legal types are normal, variable, and bytes."

	"These values need to be moved into Class"
	^classType = 'normal'
		ifTrue: [ fmt ]
		ifFalse: 
			[ classType = 'variable'
				ifTrue: [ fmt bitOr: 16r4.	"add indexable bit" ]
				ifFalse: 
					[ classType = 'bytes'
						ifTrue: [ (fmt bitAnd: 16r3 bitInvert) bitOr: 16r1 + 16r4 ]
						ifFalse: [self error: 'Unknown class type']]]
]

{ #category : 'actions' }
RwGsClassPatch >> addToNewClassesByName: aDictionary [

	"Dictionary is class name -> classAdditionPatch. Error on duplicate name."

	| name |
	name := classDefinition key.
	name ifNil: [ self error: 'Class definition with no name.' ].
	(aDictionary includesKey: name)
		ifTrue: [ self error: 'Duplicate name' ].
	aDictionary at: name put: self
]

{ #category : 'private' }
RwGsClassPatch >> basicCreateClassWithSuperclass: superclass [

	"For GemStone, the valid values are:
	bytes
	variable
	normal for non-indexable pointer object"

	"Must be in-synch with RwGsLoadedClass>>updateClassTypeFromClass"

	| type oldVersion createdClass gs_options |
	type := classDefinition classType.
	oldVersion := self oldClassVersion.
	gs_options := (classDefinition propertyAt: 'gs_options' ifAbsent: [ #() ])
		collect: [ :each | each asSymbol ].
	createdClass := type = 'normal'
		ifTrue: [ 
			superclass
				subclass: classDefinition key
				instVarNames: (classDefinition propertyAt: 'instvars')
				classVars: (classDefinition propertyAt: 'classvars')
				classInstVars: (classDefinition propertyAt: 'classinstvars')
				poolDictionaries: (classDefinition propertyAt: 'pools')
				inDictionary: nil
				newVersionOf: oldVersion
				description: (classDefinition propertyAt: 'comment' ifAbsent: [ '' ])
				options: gs_options ]
		ifFalse: [ 
			type = 'variable'
				ifTrue: [ 
					superclass
						indexableSubclass: classDefinition key
						instVarNames: (classDefinition propertyAt: 'instvars')
						classVars: (classDefinition propertyAt: 'classvars')
						classInstVars: (classDefinition propertyAt: 'classinstvars')
						poolDictionaries: (classDefinition propertyAt: 'pools')
						inDictionary: nil
						newVersionOf: oldVersion
						description: (classDefinition propertyAt: 'comment' ifAbsent: [ '' ])
						options: gs_options ]
				ifFalse: [ 
					type = 'bytes'
						ifTrue: [ 
							(classDefinition propertyAt: 'instvars') isEmpty
								ifFalse: [ self error: 'Cannot define byte class with named instvars.' ].
							superclass
								byteSubclass: classDefinition key
								classVars: (classDefinition propertyAt: 'classvars')
								classInstVars: (classDefinition propertyAt: 'classinstvars')
								poolDictionaries: (classDefinition propertyAt: 'pools')
								inDictionary: nil
								newVersionOf: oldVersion
								description: (classDefinition propertyAt: 'comment' ifAbsent: [ '' ])
								options: gs_options ]
						ifFalse: [ self error: 'Unknown class type' ] ] ].
	^ createdClass
]

{ #category : 'accessing' }
RwGsClassPatch >> classDefinition [
	^classDefinition

]

{ #category : 'accessing' }
RwGsClassPatch >> classDefinition: newValue [
	classDefinition := newValue

]

{ #category : 'accessing' }
RwGsClassPatch >> className [

	^classDefinition key
]

{ #category : 'actions' }
RwGsClassPatch >> createClassFor: aPatchSet [

	| createdClass |
	createdClass := self privateCreateClassFor: aPatchSet.
	aPatchSet createdClass: createdClass.
	^ createdClass
]

{ #category : 'actions' }
RwGsClassPatch >> existingSymbolDictionaryNamed: dictName [
	"If the current session's transient symbol list includes a dictionary with the given name, answer it. "

	| symbolName session symbolList association |
	symbolName := dictName asSymbol.
	session := GsCurrentSession currentSession.
	symbolList := session symbolList.
	^symbolList
		detect: [:each | (each at: symbolName ifAbsent: [nil]) == each]
		ifNone: 
			[ nil ]
]

{ #category : 'applying' }
RwGsClassPatch >> markPackageNotDirty [

	self markNotDirtyPackageNamed: packageDefinition key
]

{ #category : 'versioning' }
RwGsClassPatch >> oldClassVersion [
	"The old version is what is currently bound to the class definition's name."

	^ (self resolveName: classDefinition key) value
]

{ #category : 'accessing' }
RwGsClassPatch >> packageDefinition [
	^packageDefinition

]

{ #category : 'accessing' }
RwGsClassPatch >> packageDefinition: newValue [
	packageDefinition := newValue

]

{ #category : 'accessing' }
RwGsClassPatch >> packageName [

	^packageDefinition key
]

{ #category : 'private' }
RwGsClassPatch >> privateCreateClassFor: aPatchSet [

	| superclass |
	superclass := aPatchSet superclassNamed: classDefinition superclassName.
	superclass
		ifNil: [ 
			classDefinition superclassName = 'nil'
				ifFalse: [ 
					self
						error:
							'The class named ' , classDefinition superclassName printString
								, ' does not exist.' ] ].
	^ self privateCreateClassWithSuperclass: superclass
]

{ #category : 'private' }
RwGsClassPatch >> privateCreateClassWithSuperclass: superclass [

	| classProperties packageName infoSource category createdClass |
	createdClass := self basicCreateClassWithSuperclass: superclass.
	classProperties := classDefinition properties.
	packageName := packageDefinition key.
	infoSource := Rowan configuration packageInfoSource.
	category := infoSource == #Category
				ifTrue: [packageName]
				ifFalse: [classProperties at: 'category' ifAbsent: ['']].
	createdClass category: category.
	^createdClass
]

{ #category : 'accessing' }
RwGsClassPatch >> superclassName [

	^classDefinition superclassName
]
